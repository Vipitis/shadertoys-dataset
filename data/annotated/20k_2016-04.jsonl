{"id": "4d3SWl", "name": "Another Mobius", "author": "vox", "description": "Another Mobius", "tags": ["anothermobius"], "likes": 0, "viewed": 425, "date": "1461939151", "time_retrieved": "2024-06-20T18:34:23.587876", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*iTime/E)\n#define saw(x) (acos(cos(x))/PI)\n#define cosaw(x) saw(x+PI/2.0)\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\n\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\n\nvec2 mobius(vec2 uv)\n{\n    float turns = mod(floor(time), 5.0)+3.0;\n    uv = rotatez(uv.xy, PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    vec2 xy = rotatez(uv.xy, PI*2.0*(rot)+PI/turns).xy;\n    xy = sign(xy)*log(abs(xy));\n    return vec2(saw(theta*turns), saw(xy.x*PI*1.0));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = exp(-saw(time)*8.0);\n    uv = uv*scale-scale/2.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    uv = normalize(uv)/log(r+1.0);\n    uv += sin(vec2(time, time/PI*E*GR))/scale*2.0*PI;\n    uv = mobius(uv); \n    \n    const int max_iterations =1;\n    \n    \n    float dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n    float map = sqrt(dist)*PI;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n     \tuv = uv*2.0-1.0;\n        scale = exp(-saw(time+float(i))*8.0);\n        uv *= scale;\n        r = length(uv);\n        uv = normalize(uv)/log(r+1.0);\n        uv += sin(vec2(time+iteration*2.0*PI, time/PI*E*GR+iteration*2.0*PI))/scale;\n        uv = mobius(uv);\n        \n        dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n        map += sqrt(dist)*PI;\n    }\n\n    fragColor = texture(iChannel0, uv);\n    \n    fragColor = smoothstep(0.0, .75, map)*vec4(phase(map*2.0+time), 1.0);\n    fragColor = vec4(uv, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3SWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3SWM", "name": "nebula - space", "author": "pazimor", "description": "space nebula", "tags": ["space", "nebula"], "likes": 78, "viewed": 4200, "date": "1459516084", "time_retrieved": "2024-06-20T18:34:24.601374", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define iterations 4\n#define formuparam2 0.89\n \n#define volsteps 10\n#define stepsize 0.190\n \n#define zoom 3.900\n#define tile   0.450\n#define speed2  0.010\n \n#define brightness 0.2\n#define darkmatter 0.400\n#define distfading 0.560\n#define saturation 0.400\n\n\n#define transverseSpeed 1.1\n#define cloud 0.2\n\n \nfloat triangle(float x, float a) {\n\tfloat output2 = 2.0 * abs(3.0 * ((x / a) - floor((x / a) + 0.5))) - 1.0;\n\treturn output2;\n}\n \n\nfloat field(in vec3 p) {\n\t\n\tfloat strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\t\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1 * sin(iTime * 0.2 + 2.0), -1.1 + 0.3 * cos(iTime * 0.15));\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n     \tvec2 uv2 = 2. * gl_FragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv2 * iResolution.xy / max(iResolution.x, iResolution.y);\n\t\n\n\t\n\tfloat time2 = iTime;\n               \n        float speed = speed2;\n        speed = 0.005 * cos(time2*0.02 + 3.1415926/4.0);\n    \tfloat formuparam = formuparam2;\n\t//get coords and direction\n\tvec2 uv = uvs;\n\t//mouse rotation\n\tfloat a_xz = 0.9;\n\tfloat a_yz = -.6;\n\tfloat a_xy = 0.9 + iTime*0.04;\n\t\n\t\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\n\t\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\n\t\t\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\t\n\n\tfloat v2 =1.0;\n\t\n\tvec3 dir=vec3(uv*zoom,1.);\n \n\tvec3 from=vec3(0.0, 0.0,0.0);\n \n                               \n        from.x -= 5.0* (0.5);\n        from.y -= 5.0* (0.5);\n               \n               \n\tvec3 forward = vec3(0.,0.,1.);\n               \n\n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*iTime) + 0.001*iTime;\n\t\tfrom.y += transverseSpeed*(1.0)*sin(0.01*iTime) +0.001*iTime;\n\t\n\tfrom.z += 0.003*iTime;\n\t\n\t\n\tdir.xy*=rot_xy;\n\tforward.xy *= rot_xy;\n\n\tdir.xz*=rot_xz;\n\tforward.xz *= rot_xz;\n\t\t\n\t\n\tdir.yz*= rot_yz;\n\tforward.yz *= rot_yz;\n\t \n\n\t\n\tfrom.xy*=-rot_xy;\n\tfrom.xz*=rot_xz;\n\tfrom.yz*= rot_yz;\n\t \n\t\n\t//zoom\n\tfloat zooom = (time2-3311.)*speed;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, stepsize );\n\t \n\tfloat zoffset = -sampleShift;\n\tsampleShift /= stepsize; // make from 0 to 1\n\n\n\t\n\t//volumetric rendering\n\tfloat s=0.24;\n\tfloat s3 = s + stepsize/2.0;\n\tvec3 v=vec3(0.);\n\tfloat t3 = 0.0;\n\t\n\t\n\tvec3 backCol2 = vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\t\tvec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset);\n\t\t\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n\t\t\n\t\t#ifdef cloud\n\t\tt3 = field(p3);\n\t\t#endif\n\t\t\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\n\t\t\t//p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\n\t\t\tfloat D = abs(length(p2)-pa); // absolute sum of average change\n\t\t\t\n\t\t\tif (i > 2)\n\t\t\t{\n\t\t\ta += i > 7 ? min( 12., D) : D;\n\t\t\t}\n\t\t\t\tpa=length(p2);\n\t\t}\n\t\t\n\t\t\n\t\t//float dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\t//if (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t// brightens stuff up a bit\n\t\tfloat s1 = s+zoffset;\n\t\t// need closed form expression for this, now that we shift samples\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\t\t\n\t\t\n\t\t//t3 += fade;\n\t\t\n\t\tv+=fade;\n\t       \t\t//backCol2 -= fade;\n\n\t\t// fade out samples as they approach the camera\n\t\tif( r == 0 )\n\t\t\tfade *= (1. - (sampleShift));\n\t\t// fade in samples as they approach from the distance\n\t\tif( r == volsteps-1 )\n\t\t\tfade *= sampleShift;\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\t\t\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;\n\n\t\t\n\t\ts+=stepsize;\n\t\ts3 += stepsize;\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t       \n\tv=mix(vec3(length(v)),v,saturation);\n\tvec4 forCol2 = vec4(v*.01,1.);\n\t\n\t#ifdef cloud\n\tbackCol2 *= cloud;\n\t#endif\n    \n\tfragColor = forCol2 + vec4(backCol2, 1.0);\n}\n\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3SWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3XDj", "name": "Hydrokinetics (webgl)", "author": "noby", "description": "WebGL version of Hydrokinetics (assembly 2015 4k intro winner). Doesn't compile on Chrome, probably due to amount of instructions and/or compile time.\n\nhttps://www.pouet.net/prod.php?which=66059\nhttps://www.youtube.com/watch?v=7wLA0IVj7sA", "tags": ["raymarching", "distancefields", "intro", "4k", "water", "volumetric", "demo", "csg", "spheretracing", "assembly"], "likes": 40, "viewed": 942, "date": "1461414571", "time_retrieved": "2024-06-20T18:34:25.934824", "image_code": "// NOTE: This source is minified and hard to read\n// there are also some minute changes to accomodate the ES 2.0 spec.\n\n// Works on AMD, might not show or bug out on other vendors\n#define BUBBLES\n\nfloat x=.001,v=0.,y=0.,f=0.,z=0.,d=0.,r=0.,e=0.,g=0.,o=0.,t=0.,a=0.,l=0.,i=0.,u=0.,h=0.,b=0.,C=0.;\nvec3 Y;\nfloat p(float v,float g)\n{\n\treturn v*g*exp(1.-v*g);\n}\n\n// global initializations in webgl must be constants\n// this hack circumvents that\nvoid updateglobals()\n{\n    v=iTime*2.7;\n    y=p(9.,mod(clamp(v,19.,99.),2.5223));\n    f=p(3.,mod(clamp(v,19.,99.),2.5223));\n    z=1.5-smoothstep(151.,199.,v);\n    d=pow(smoothstep(151.,199.,v),2.);\n    r=1.+9.*smoothstep(-100.,100.,-v);\n    e=smoothstep(208.,228.,v);\n    g=smoothstep(254.,260.,v);\n    o=smoothstep(331.,340.,v);\n    t=smoothstep(40.,80.,v);\n    a=pow(smoothstep(101.,105.,v),.5);\n    l=1.-smoothstep(204.,205.,v);\n    i=smoothstep(214.,225.,v);\n    u=smoothstep(222.,240.,v);\n    h=smoothstep(242.,244.,v);\n    b=1.+8.*p(3.,clamp(v-204.,0.,99.));\n    C=v+.6*max(0.,f);\n    Y=9.*vec3(sin(v*.8),1,cos(.63*v));\n}\n\nmat3 p(float v)\n{\n\treturn mat3(1.,0.,0.,0.,cos(v),-sin(v),0,sin(v),cos(v));\n}\n\nmat3 n(float v)\n{\n\treturn mat3(cos(v),0.,sin(v),0.,1.,0.,-sin(v),0.,cos(v));\n}\n\nmat3 s(float v)\n{\n\treturn mat3(cos(v),-sin(v),0.,sin(v),cos(v),0.,0.,0.,1.);\n}\n\nfloat w(float v)\n{\n\treturn fract(sin(dot(v,12.9898))*43758.5);\n}\n\nfloat n(float v,float m,float x)\n{\n    float s=clamp(.5+.5*(m-v)/x,0.,1.);\n    return mix(m,v,s)-x*s*(1.-s);\n}\n\nfloat n(vec3 v,float x)\n{\n    return length(v)-x;\n}\n\nfloat s(vec3 v,vec3 x)\n{\n    return length(max(abs(v)-x,0.));\n}\n\nfloat p(float v,float m,float x)\n{\n    return min(min(v,m),v-(x+min(v,m))+m);\n}\n\nfloat c(vec3 v)\n{\n    vec3 s=floor(v),f=fract(v);\n    f=f*f*(3.-2.*f);\n    float x=s.x+s.y*57.+113.*s.z;\n    return mix(mix(mix(w(x),w(x+1.),f.x),mix(w(x+57.),w(x+58.),f.x),f.y),mix(mix(w(x+113.),w(x+114.),f.x),mix(w(x+170.),w(x+171.),f.x),f.y),f.z);\n}\n\nfloat c(vec3 v,float x)\n{\n    v.y-=x/2.;\n    vec3 m=abs(v);\n    return max(v.y,(m.x+m.y/1.2+m.z-x)/3.);\n}\n\nfloat k(vec3 x)\n{\n\treturn x.y+=20.-20.*t-.53*u,x=(x+vec3(.7,1.,.8))*p((v-101.)*.34*a*l)*n((v-101.)*.41*a*l)*s((v-101.)*.23*a*l),mix(max(c(x*n(v*.13),1.5+2.*h),-c(vec3(x.x,-x.y+.4,x.z)*n(v*.13)*p((v-260.)*.24*g)*s((v-260.)*.23*g),1.5*(1.-l)*(1.-h)+3.*g)),min(min(min(n(x+r*vec3(0.,.4883,0.),.6),n(x+r*vec3(-.3554,-.4883,-.6),.6)),n(x+r*vec3(.6838,-.4883,0.),.6)),n(x+r*vec3(-.3554,-.4883,.6),.6)),a-(1.-l)+o);\n}\n\nfloat F(vec3 x)\n{\n    float m=c(vec3(x.x,x.y,x.z)*(12.-3.*d)),f=s(vec3(x.x,x.y-.5-.2*(sin(x.z*.6)+cos(x.x*.6))-.004*m,x.z),vec3(9.,0.,9.)),y=k(x);\n    vec3 w=mod(x,z+g)-.5*(z+g);\n    float i=s(vec3(w.x+g*.1*sin(2.*x.y+2.*x.z+v),x.y,w.z+g*.1*cos(2.*x.y+2.*x.x+v)),vec3(.25,.81,.25)),l=s(vec3(w.x+g*.1*sin(2.*x.y+2.*x.z+v),x.y+.25,w.z+g*.1*cos(2.*x.y+2.*x.x+v)),vec3(.29,.04,.29)),r=max(-y+.3-.3*e+.6*h+.6*g,min(i,l)+(.00114+.0001*d-.0001*g)*m);\n    return min(n(f,r,.3),y);\n}\n\nfloat q(vec3 v)\n{\n\treturn v.zx+=.1*vec2(c(v.yzx+C*.78),c(v.zxy+C*.91)),pow(c(7.*vec3(v.x,220.+v.y+mod(C*.1,10.),v.z)),1.2);\n}\n\nvec3 Z(vec3 v)\n{\n    float x=.01;\n    return normalize(vec3(F(v+vec3(x,0.,0.))-F(v-vec3(x,0.,0.)),F(v+vec3(0.,x,0.))-F(v-vec3(0.,x,0.)),F(v+vec3(0.,0.,x))-F(v-vec3(0.,0.,x))));\n}\n\nfloat F(vec3 v,vec3 x,float m,float y,float f)\n{\n    // WebGL version of soft shadows, courtesy of iq\n    float res = 1.0;\n    float t = m;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = F( v + x*t );\n        res = min( res, f*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>y ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n    // original shadows\n    /*\n    float i=1.;\n    for(float s=m;s<y;)\n    {\n        float c=F(v+x*s);\n        if(c<.001)\n        return 0.;\n        i=min(i,f*c/s);\n        s+=c;\n    }\n    return i;\n\t*/\n}\n\nfloat Z(vec3 v,vec3 x,float m,float y,float f)\n{\n    float res = 1.0;\n    float t = m;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = k( v + x*t );\n        res = min( res, f*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>y ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n    /*\n    float i=1.;\n    for(float s=m;s<y;)\n    {\n        float c=k(v+x*s);\n        if(c<.001)\n        return 0.;\n        i=min(i,f*c/s);\n        s+=c;\n    }\n    return i;\n\t*/\n}\n\nvec3 F(vec3 x,float s)\n{\n    vec3 m=normalize(x-Y);\n    float g=max(0.,dot(m,Z(x)));\n    vec3 f=x*5.,r=mix(vec3(.7,.55,.47),vec3(.75,.61,.41),clamp(9.*x.y-1.,0.,2.))+2.*y*.2*c(vec3(f.x+v,1.,f.z+v))-.1*c(vec3(1.75*f.x-v,v,1.75*f.z-v));\n    return vec3(.4,.65,.7)/clamp(vec3(.3*s),.7,32.)*r*1.25*vec3(.85,.7,.55)*(.2+.8*g)*(.2+.8*F(x,m,.06,80.,2.));\n}\n\nvec3 Z(vec3 v,vec3 s)\n{\n    vec3 m=vec3(0.);\n    float f,i;\n    f=i=0.;\n    for(int g=0;g<30;++g)\n    {\n        m=v+f*s;\n        i=F(m);\n        f+=i;\n        if(20.<f||abs(i)<x)\n        break;\n    }\n    return F(m,f);\n}\n\nvec3 k(vec3 v,vec3 m)\n{\n    vec3 f=vec3(0.);\n    float s,i;\n    s=i=0.;\n    for(int g=0;g<30;++g)\n    {\n        f=v+s*m;\n        i=F(f);\n        s+=i;\n        if(20.<s||abs(i)<x)\n        break;\n    }\n    if(k(f)<x)\n    {\n        vec3 g=Z(f);\n        return(.45+.75*max(0.,min(1.,.8+.5*(1.+dot(s*m,g)))))*(.6*Z(f+.1*g,m-2.*dot(m,g)*g)+.4*pow(F(f,s),vec3(.4))+.4*pow(max(dot(normalize(m-Y),g),0.),80.));\n    }\n    return F(f,s);\n}\n\nvec3 q(vec3 v,vec3 m)\n{\n    vec3 f=vec3(0.);\n    float s,i,c,y,g,r=1.;\n    s=i=c=y=g=0.;\n    for(int l=0;l<90;++l)\n    {\n        f=v+s*m;\n#ifdef BUBBLES\n        // only works properly on AMD\n        i=min(F(f),q(f));\n#else\n        i=F(f);\n#endif\n        s+=i;\n        y+=b*.01*pow(i,1.6)/k(f);\n        vec3 w=normalize(f-Y);\n        r+=.015*sqrt(i)/(.005+Z(f,w,.06,6.,1.)/k(f));\n        if(20.<s||abs(i)<x)\n        break;\n\t}\n#ifndef BUBBLES\n    s=min(s,20.0);\n#endif\n    if(20.<s)\n\t\treturn vec3(min(2.*smoothstep(0.,12.,-f.y*.3),.3))/r+y+g;\n    if(k(f)<x)\n    {\n    \tvec3 l=Z(f);\n    \treturn(.45+.75*max(0.,min(1.,.8+.5*(1.+dot(s*m,l)))))*(.6*k(f+.1*l,m-2.*dot(m,l)*l)+.4*pow(F(f,s),vec3(.4))+.4*pow(max(dot(normalize(m-Y),l),0.),80.))/r+y+g;\n    }\n    return F(f,s)/r+y+g;\n}\n\nvec3 X(vec3 v)\n{\n\treturn v=pow(.1+v,vec3(2.5)),v.y=pow(v.y,.56),v.z+=pow(v.z,.8)+.1,v.yz*=.8,v.y=smoothstep(-.1,1.2,v.y*.9)+.05,v*5.-.05;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    updateglobals();\n    vec2 x=iResolution.xy,f=1.-2.*fragCoord.xy/x.xy;\n    f.y*=x.y/x.x;\n    mat3 m=p(-.22)*n(2.)*s(.06),r=p(.03*c(vec3(v*1.1578)))*n(.02*c(vec3(v*1.2462+x.x)))*s(.03*c(vec3(v*1.3102+x.y))),i=p(.008*c(17.*vec3(f.x,f.y,.22*v)))*n(.008*c(17.*vec3(f.x*.91,f.y*.73,.41*v)))*s(.008*c(17.*vec3(f.x*1.13,f.y*.91,.33*v)));\n    vec3 l=vec3(-4.-2.*g,-12.8+9.*smoothstep(0.,28.,v)+2.*smoothstep(24.,45.,v),1.),z=vec3(f,.8+.04*y);\n    float d=.2*smoothstep(50.,80.,v)-.3*p(3.,.3*clamp(v-20.,0.,20.));\n    if(v>44.&&v<61.||v>202.&&v<209.||v>105.&&v<119.||v>342.)\n    \tl=vec3(-5.,-6.-6.*clamp((v-342.)/50.,0.,9.),2.),m=p(-.6-clamp((v-342.)/105.,0.,9.))*n(2.)*s(.06),d-=.25;\n    if(v>230.&&v<240.)\n    \tl=vec3(-2.,-1.5,.5),m=p(-.12)*n(2.4)*s(0.);\n    z=normalize(z)*m*r*i;\n    vec3 C=X(pow(q(l,z),vec3(.8+d)));\n    float a=.6/(.8+(.25+1./(smoothstep(0.,28.,v)-smoothstep(383.,399.,v)))*dot(f,f));\n    fragColor=vec4(1.7*pow(.03*vec3(w(length(f)*v))+C*a,vec3(1.6)),1.);\n}\n", "image_inputs": [{"id": "4sX3zs", "previewfilepath": "https://soundcloud.com/noby/hydrokinetics", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/noby/hydrokinetics", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3XDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3XDl", "name": "Rk and Qk", "author": "eiffie", "description": "Just trying IQ's equations in 3d without really understanding the math. Seems to work fine on triplex numbers as well. Qk is a bounding radius and Rk is a conservative inner radius. (used here for coloring)", "tags": ["mandelbulb"], "likes": 16, "viewed": 972, "date": "1461962174", "time_retrieved": "2024-06-20T18:34:26.401429", "image_code": "//based on... (don't trust my math! go to the source)\n//https://www.shadertoy.com/view/4sdXWX\n//http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n\n//#define SHOW_RADII\nfloat k,qk,rk;\nfloat Rk(float k){return 1.0/pow(k,1./(k-1.))-1.0/pow(k,k/(k-1.));}\nfloat Qk(float k){return pow(2.,1./(k-1.));}\n\nvec3 mcol;\nfloat DE(vec3 z0){//mandelBulb by twinbee\n   vec4 c = vec4(z0,1.0),z = c;\n   float r = length(z.xyz),zo,zi,r1=r;\n   for (int n = 0; n < 7; n++) {\n      if(r>qk+0.25)break;//experimenting with early bailout\n      zo = asin(z.z / r) * k +iTime;\n      zi = atan(z.y, z.x) * 7.0;//even messing with the rotations stays in bounds\n      z=pow(r, k-1.0)*vec4(r*vec3(cos(zo)*vec2(cos(zi),sin(zi)),sin(zo)),z.w*k)+c;\n      r = length(z.xyz);\n   }\n   mcol=10.0*z.xxz/z.w+clamp(r-rk,0.0,3.0)*0.15;\n   return 0.5 * min(r1-rk,log(r) * r / z.w);\n}\nfloat rndStart(vec2 co){return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\nfloat sphere( in vec3 ro, in vec3 rd, in float r){\n   float b=dot(-ro,rd);\n   float h=b*b-dot(ro,ro)+r*r;\n   if(h<0.0)return -1.;\n   return b-sqrt(h);\n}\nmat3 lookat(vec3 fw,vec3 up){\n   fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   float pxl=1.0/iResolution.x;//find the pixel size\n   float tim=iTime*0.3;\n   k=7.0+sin(tim)*3.0;\n   qk=Qk(k);\n   rk=Rk(k);\n   //position camera\n   vec3 ro=vec3(abs(cos(tim)),sin(tim*0.3),abs(sin(tim)))*(qk+0.5);\n   vec3 rd=normalize(vec3((fragCoord-0.5*iResolution.xy)/iResolution.y,1.0));\n   rd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n   vec3 LDir=normalize(vec3(0.4,0.75,0.4));//direction to light\n   vec3 bcol=vec3(0.5+0.25*rd.y);\n   vec4 col=vec4(0.0);//color accumulator\n   //march\n   float t=sphere(ro,rd,qk+0.01);\n   \n  if(t>0.0){\n   t+=DE(ro+rd*t)*rndStart(fragCoord);\n   float d,od=1.0;\n   for(int i=0;i<99;i++){\n      d=DE(ro+rd*t);\n      float px=pxl*(1.+t);\n      if(d<px){\n         vec3 scol=mcol;\n         float d2=DE(ro+rd*t+LDir*px);\n         float shad=abs(d2/d),shad2=max(0.0,1.0-d/od);\n         scol=scol*shad+vec3(0.2,0.0,-0.2)*(shad-0.5)+vec3(0.1,0.15,0.2)*shad2;\n         scol*=3.0*max(0.2,shad2);\n         scol/=(1.0+t);//*(0.2+10.0*dL*dL);\n         \n         float alpha=(1.0-col.w)*clamp(1.0-d/(px),0.0,1.0);\n         col+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n         if(col.w>0.9)break;\n      }\n      od=d;\n      t+=d;\n      if(t>6.0)break;\n   }\n  }\n   col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n#ifdef SHOW_RADII\n   t=sphere(ro,rd,qk);\n   if(t<0.0)col.g=0.0;\n   t=sphere(ro,rd,rk);\n   if(t>0.0)col.b=1.0;\n#endif\n   fragColor=vec4(col.rgb,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3XDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3XDS", "name": "Together we shine", "author": "Andre", "description": "I'm still multiplying with distance fields :)", "tags": ["2d", "distancefields", "numbers", "digits"], "likes": 7, "viewed": 293, "date": "1461096186", "time_retrieved": "2024-06-20T18:34:26.401658", "image_code": "float heart(vec2 i) {\n    // From: https://www.shadertoy.com/view/ldVGzt by coyote & Fabrice\n    i.y += .034;\n    i *= 1.1;\n    return sqrt(dot(i, i) - abs(i.x)*i.y);\n}\n\nfloat diamond(vec2 i) {\n    i = abs(i);\n    return (i.x+i.y);\n}\n\nfloat square(vec2 i) {\n    i = abs(i);\n    return max(i.x,i.y);\n}\n\nfloat circle(vec2 i) {\n    return length(i);\n}\n\nfloat honeycomb(vec2 i) {\n    i.x*=.866;\n    i = abs(i);\n    return max(i.x+i.y*.5,i.y);\n}\n\nfloat segment(vec2 uv)\n{\n    uv = abs(uv);\n\tfloat f = max(0.45+uv.x,0.225+uv.y+uv.x);\n    return f;\n}\n\nfloat m(float a, float b)\n{\n    return min(a,b);\n    //return 1./(1./a+1./b);\n    //return length(vec2(a,b));\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 5.0;\n\tseg = (num!=-1 && num!=1 && num!=4                    ?m(segment(uv.yx+vec2(-0.450, 0.000)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=2 && num!=3 && num!=7?m(segment(uv.xy+vec2( 0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=5 && num!=6                    ?m(segment(uv.xy+vec2(-0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=0 && num!=1 && num!=7          ?m(segment(uv.yx+vec2( 0.000, 0.000)),seg):seg);\n\tseg = (num==0 || num==2 || num==6 || num==8           ?m(segment(uv.xy+vec2( 0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=2                              ?m(segment(uv.xy+vec2(-0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=4 && num!=7          ?m(segment(uv.yx+vec2( 0.450, 0.000)),seg):seg);\n\t\n\treturn seg;\n}\n\nvec2 rotate(vec2 i,float a) {\n   return i *mat2(cos(a), -sin(a),\n                  sin(a), cos(a));\n}\n\nfloat getShape(int nr, vec2 uv) {\n    \n    //return circle2(uv);\n        \n    bool outline = false;\n    if (nr<10)\n        return sevenSegment(uv,nr)-.3;\n    else {\n        outline = (nr>=15);\n        nr = int(mod(float(nr),5.));\n    }\n\n    float x = 0.0;\n    if (nr==0) x = heart    (uv); else\n    if (nr==1) x = diamond  (uv); else\n    if (nr==2) x = square   (uv); else\n    if (nr==3) x = circle   (uv); else\n               x = honeycomb(uv);\n        \n    return outline ? 0.15+abs(x-.1) : x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv1 = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    vec2 uv = uv1*5.0;\n    \n    float c = 1.0;\n    if (iMouse.w>0.5)\n        c = texture(iChannel1,uv-iMouse.xy*5.0/iResolution.xy).r*1.2-.1;\n    float gt = iTime*.5;\n    for (float i = 0.0; i< 20.0; i++) {\n      gt += i*1.72;\n      c *= clamp(getShape(int(i),1.6*(uv+\n                            vec2(sin(gt*0.9)*2.+cos(gt*(i/37.))\n                                ,sin(gt*0.7)+cos(gt*(i/23.)))))-.18,0.0,1.7);\n    }\n    \n\tfragColor = vec4(clamp(\n                       mix( vec3(1.7),\n                            vec3(.7,.7,1.)\n                           *(0.5+texture(iChannel0,vec2(uv1.y*4.,uv.x)+uv1*vec2(7.0,.13)).rgr),\n                            smoothstep(.0,10.,sqrt(c))\n                       *.15*max(-.2,6.-length(uv1)))\n                       *.18*(5.-length(uv))\n                       ,0.0,1.0)\n                     ,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3XDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3XR2", "name": "Roue color 1", "author": "Vicious", "description": "Yolo", "tags": ["yolo"], "likes": 2, "viewed": 135, "date": "1460194325", "time_retrieved": "2024-06-20T18:34:26.401658", "image_code": "#define PI (3.1415)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    /*fragColor = vec4(sin(iTime),\n                     sin(iTime + 2. / 3. * PI),\n                     sin(iTime + 4. / 3. * PI), 1);*/\n    vec3 color = vec3(uv.x + sin(iTime) /2.,\n                      uv.y + cos(iTime) /2.,\n                      abs(sin(iTime)));\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3XR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3XW2", "name": "- Mandelbrot Zoom -", "author": "glequeux", "description": "mandelbrot simple zoom", "tags": ["mandelbrot", "zoom", "fractale"], "likes": 0, "viewed": 193, "date": "1461438711", "time_retrieved": "2024-06-20T18:34:26.668350", "image_code": "// Simple mandelbrot implementation\n\nconst int MAXITER = 180;\nconst vec2 CENTER = vec2(-0.74364388703715,0.13182590420533); // interest point from wikipedia\nconst float MAXTIME = 25.0;\nconst float PI = 3.1415;\n\n\n\nvec2 nextMandel(vec2 z, vec2 c)\n{\n    // Zn+1 = Zn^2+c\n    //return vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c; // First attempt\n    return vec2(dot(vec3(z,1.0),vec3(z.x,-z.y,c.x)),dot(vec3(z.xx,1.0),vec3(z.yy,c.y))); // swizzle friendly ?\n    //return mat2(z,-z.y,z.x)*z + c; // from FabriceNeyret\n}\n\nfloat mandel(vec2 c)\n{    \n    vec2 z = vec2(0,0);\n    int n=0;\n    for(int i=0;i<MAXITER;i++){\n        z=nextMandel(z,c);\n        if(dot(z,z)>1e4){ // test divergence\n            break;\n        }\n        n++;\n    }\n    return float(n) - log2(log2(dot(z,z))); // smooth color\n}\n       \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv = uv*2.0 -vec2(1.0,1.0); // go to -1;1\n    \n    float t = (sin(0.3*iTime-PI*0.5)*0.5+0.5)*MAXTIME; // stay in float precision\n    float size=1.0/(pow(1.6,t)); // window size\n    vec2 center = CENTER;\n    uv*= size;\n    \n    uv.x*= ratio; // screen ratio\n    uv+= center;\n\n    float value = float(mandel(uv));\n\tfragColor = vec4(sin(value*0.2),sin(value*0.7),cos(value*0.3),1.0); // simple rainbow color\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3XW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSRB", "name": "Hello Voxel", "author": "akohdr", "description": "canonical 'hello world' for Terse Voxel viewer, as clean as I could make it.\n     (ok maybe tweaking SPHERE primitive to be time varying isn't that clean, looks cool :) )\n", "tags": ["voxel"], "likes": 18, "viewed": 324, "date": "1459879271", "time_retrieved": "2024-06-20T18:34:27.468427", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// showing local voxel bounds helps vizualize what's going on\n//#define SHOW_BOUNDS\n\n// Timebase passed into viewer\n#define iTimebase 1.5*iTime\n\n// for demo we make voxel resolution a function of time\n#define RES (1.5 - (sin(.5*T)))\n\n// alternatively fix the resolution\n//#define RES 3.\n//#define RES 1.25\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 2.5*RES\n#define EYE_D 40.*RES\n#define MAX_RAY 250\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, const in vec4 P );\n\nbool VxViewer(out vec4 fc,             // fragColor\n         const in vec2 P,              // fragCoord\n         const in vec3 R,              // iResolution\n        const in float T ) {           // timebase\n    \n\tconst vec3 WORLD_OFFSET = vec3(0,0,0);\n    const vec4 B0 = vec4(.0,.0,.0,1.),\n               B1 = vec4(.6,.6,.6,1.),\n               B2 = vec4(.3,.3,.3,1.);\n    \n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;         // vec ops faster than single scalar\n    \n    vec3 r = vec3(l.y*t.y - .8*t.x, (P.y/R.y - .5)*R.y/R.x, .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=MAX_RAY; i>0; i--) {\n        vec4 spacetime = vec4(f + WORLD_OFFSET, T);\n\n        if(cVoxel(fc, spacetime)){\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return true; // early exit\n        }\n        \n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n                \n        f += m*q;\n        s += m*d;\n    }\n    return false;\n}\n// Cut/Paste end ------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // iphones apparently don't init to zero\n\n#define AB\n#ifdef AB\n    fragColor = vec4(0.);\n\tVxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             iTimebase);\n#else\n\tif(!VxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             iTimebase)) fragColor = vec4(0.);\n#endif\n}\n\n\n//#define SPHERE(p,c,r) length(p.xyz-c)<r\n\n// let your math sense go nuts!\n#define SPHERE(p,c,r) length(p.xyz-c)<(mod(T,20.)<7.?r:r*sin((tan(.1*T))*(.3*length(p.xxy))))\n//#define SPHERE(p,c,r) length(p.xyz-c)<r*sin((.3*length(p.xxy)))\n//#define SPHERE(p,c,r) length(p.xyz-c)<r*sin(8.*(.3*length(p.xxy)))\n\n// User supplied world state function\nbool cVoxel(out vec4 c,\t    // voxel colour (if exists return true)\n       const in vec4 P \t\t// P.xyz world coord,  P.w world time\n) {\n    c = vec4(0);\n    float T = P.w,\t\t    // timebase (T is used by RES macro)\n          res = RES,\n          rPlanet = 8.,\t\t// planet radius\n          rMoon = 3.;\t\t// moon radius\n\n    vec3 pPlanet = vec3(0),\n         pMoon = vec3(12.,0.,-6.);  // note: moon isn't moving viewer orbits origin\n\n    // adjust size/positions for voxel resolution\n    rPlanet *= res;\n    rMoon *= res;\n    pMoon *= res;\n        \n\t// hit test on planet\n    if (SPHERE(P, pPlanet, rPlanet)) {\n        // spacial colouring\n        c = vec4(.25+normalize(P.xyz),1.);\n        return true;\n    }\n\n    // hit test on moon\n    if (SPHERE(P, pMoon, rMoon)) {\n        // temporal colouring\n        c = vec4(.2+sin(T)*vec3(.7),1.);\n        return true;\n    }\n\n#ifdef SHOW_BOUNDS \n    // bounding markers (white positive direction  .rgb <=> .xyz)\n    const vec4 L = vec4(13.),\n               H = vec4(.5);\n    vec4 ap = abs(P); \n\tbvec4 b = lessThan(ap,L);\n    if(length(ap.xyz-L.xyz)<3. && (b.x&&b.y&&b.z)) c = H+.3*sign(P); //local corners\n#endif\n    \n \treturn c.w>0.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSRX", "name": "Valve's screen space dither", "author": "Zavie", "description": "Experimenting with the dithering mentioned in Alex Vlachos's GDC2015 talk. Without dithering on the left; with dithering on the right.\n\nFor comparison with other dithering functions, see: https://www.shadertoy.com/view/MslGR8\n", "tags": ["noise", "dithering", "valve", "portal2"], "likes": 27, "viewed": 3521, "date": "1460438686", "time_retrieved": "2024-06-20T18:34:27.965048", "image_code": "/*\n\nThis shader tests how the Valve fullscreen dithering\nshader affects color and banding.\n\nThe function is adapted from slide 49 of Alex Vlachos's\nGDC2015 talk: \"Advanced VR Rendering\".\nhttp://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n\n--\nZavie\n\n*/\n\n\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n\nvec3 ScreenSpaceDither(vec2 vScreenPos, float colorDepth)\n{\n    // lestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n    vec3 vDither = vec3(dot(vec2(131.0, 312.0), vScreenPos.xy + iTime));\n    vDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);\n    return (vDither.rgb / colorDepth) * 0.375;\n}\n\n// ---8<----------------------------------------------------------------------\n\n// The functions that follow are only used to generate\n// the color gradients for demonstrating dithering effect.\n\nfloat h00(float x) { return 2.*x*x*x - 3.*x*x + 1.; }\nfloat h10(float x) { return x*x*x - 2.*x*x + x; }\nfloat h01(float x) { return 3.*x*x - 2.*x*x*x; }\nfloat h11(float x) { return x*x*x - x*x; }\nfloat Hermite(float p0, float p1, float m0, float m1, float x)\n{\n\treturn p0*h00(x) + m0*h10(x) + p1*h01(x) + m1*h11(x);\n}\n\n// Source:\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 generateColor(vec2 uv)\n{\n\tfloat a = sin(iTime * 0.5)*0.5 + 0.5;\n\tfloat b = sin(iTime * 0.75)*0.5 + 0.5;\n\tfloat c = sin(iTime * 1.0)*0.5 + 0.5;\n\tfloat d = sin(iTime * 1.25)*0.5 + 0.5;\n\t\n\tfloat y0 = mix(a, b, uv.x);\n\tfloat y1 = mix(c, d, uv.x);\n\tfloat x0 = mix(a, c, uv.y);\n\tfloat x1 = mix(b, d, uv.y);\n    \n    float h = fract(mix(0., 0.1, Hermite(0., 1., 4.*x0, 4.*x1, uv.x)) + iTime * 0.05);\n    float s = Hermite(0., 1., 5.*y0, 5.*y1, 1. - uv.y);\n    float v = Hermite(0., 1., 5.*y0, 5.*y1, uv.y);\n\n\treturn hsv2rgb(vec3(h, s, v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat colorDepth = mix(2.0, 255.0, pow(clamp(mix(-0.2, 1.2, abs(2.0 * fract(iTime / 11.0) - 1.0)), 0., 1.), 2.0));\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 color = pow(generateColor(uv), vec3(1. / gamma));\n    vec3 ditheredColor = color + ScreenSpaceDither(fragCoord.xy, colorDepth);\n\n    float separator = 1. - smoothstep(0.497, 0.499, uv.x) * smoothstep(0.503, 0.501, uv.x);\n    vec3 finalColor = mix(color, ditheredColor, smoothstep(0.499, 0.501, uv.x)) * separator;\n    \n\tfragColor = vec4(floor(finalColor * colorDepth) / colorDepth, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSz2", "name": "Trinoisemarble-mainsequence", "author": "Orihaus", "description": "t", "tags": ["t"], "likes": 6, "viewed": 185, "date": "1460311477", "time_retrieved": "2024-06-20T18:34:27.971382", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\nfloat zoom=1.;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.0*a.x*a.y  ); }\n\nfloat smin( float a, float b )\n{\n    float k = 0.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x+tri(p.y*2.)),tri(p.y+tri(p.x*2.)));}\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\n\n//Animated triangle noise, cheap and pretty decent looking.\nfloat triangleNoise(in vec2 p)\n{\n    float z=1.5;\n    float z2=1.5;\n\tfloat rz = 0.;\n    vec2 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec2 dg = tri2(bp*2.)*.8;\n        dg *= mm2(iTime*.1);\n        p += dg/z2;\n\n        bp *= 1.6;\n        z2 *= .6;\n\t\tz *= 1.8;\n\t\tp *= 1.2;\n        p*= m2;\n        \n        rz+= (tri(p.x+tri(p.y)))/z;\n\t}\n\treturn rz;\n}\n\n//\n\nmat2 rot(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\t//if( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p) \n{\n\tfloat res = 0.;\n    float timeinput = sin( iTime * 0.1 )*0.01;\n    vec3 c = p;\n\t\n    \n\tfor (int i = 0; i <6 ; ++i) \n    {\n        float indexover = 1.0 + ( float( i ) / 8.0 );\n        p =(.41+timeinput)*abs(p)/dot(p,p) -(0.41 + timeinput);\n        p.yz= csqr(p.yz);\n        \n        //p = abs( 1.0 + dot(p,c) * 0.7 )/abs(p*0.7);\n        \n        //p += tri2( timeinput + abs( p.xz ) ).x;\n        \n        //p.xy = csqr(p.xy);\n        //p.yz = csqr(p.yz);\n        //p.zx /= csqr(p.zx);\n        //p=p.zxy;\n       \n        //p *= triangleNoise( timeinput + p.yx * 0.5 );\n        //p -= triangleNoise( p.zy * 0.5 ) * 1.0;\n\n        res = ( .9 * res) + exp(-20.0 * abs(dot(p,c))) * 0.15 * indexover;\n\t}\n\n\treturn res;\n}\n\n\n\nvec4 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float timeinput = sin( iTime * 1.1 );\n    \n    float t = 1.0 + tminmax.x * 0.875;\n    //float dt = .1;\n    float dt = .018;//animated\n    vec3 col= vec3(0.);\n    float c = 0.5; float c2 = 0.0;\n    /*for( int i=0; i<16; i++ )\n\t{\n        float indexover = float( i ) / 16.0;\n        indexover *= indexover;\n        t+=dt*exp(-12.0*c);\n        if(t>tminmax.y)break;\n        vec3 pos = ro+t*rd;\n        \n        c += map(pos);               \n        \n        //col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\n        col = .75*col+ .75*vec3( c*c*c*c, c*c*c, c*c )*vec3(1.3, 2.0 * c, 1.25);//blue\n    }    */\n    for( int i=0; i<64; i++ )\n\t{\n        float indexover = float( i ) / 64.0;\n        indexover = pow( indexover, 0.875 );\n        t+=dt*exp((-4.0*indexover)*c) * 1.5;\n        if(t>tminmax.y)break;\n        vec3 pos = ro+t*rd;\n        \n        float imap = map(pos);\n        c = clamp( ( 0.93 * c ) + ( indexover * imap ) * 0.07, 0.0, 1.0 );\n        c2 =.99*c2+ .4*imap;\n       \n        col = .96*col+ .1*(2.5+0.15*pos*t)*vec3( c*c*c, c*c*c, c*c )*vec3(8. + indexover * 7.0, 7.0 - 4.0 * c, 1.75 + c * 4.0);//blue\n    }    \n    return vec4( col, c2 );\n}\n\n//\n\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvec3 lin2srgb( vec3 cl )\n{\n\t//cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n\n//\n\nfloat EnvBRDFApproxNonmetal( float Roughness, float NoV )\n{\n    const vec2 c0 = vec2( -1.0, -0.0275 );\n    const vec2 c1 = vec2(  1.0,  0.0425 );\n    vec2 r = Roughness * c0 + c1;\n    return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n}\n\n//\n\nvec3 fisheye_lookup(float fov, vec2 position)\n{\n\tvec2 d = position;\n\t\n\tfloat yaw = sqrt(d.x*d.x+d.y*d.y) * fov;\n\n\tfloat roll = -atan(d.y, d.x);\n\tfloat sx = sin(yaw) * cos(roll);\n\tfloat sy = sin(yaw) * sin(roll);\n\tfloat sz = sin(yaw);\t\n\n\treturn vec3(sx, sy, sz);\n}\n\n//\n\nfloat MAT_triplanarScratches(vec3 p, vec3 n)\n{\n    //Idea from http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n    //Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*triangleNoise(p.zy*0.3)\n            +abs(n.y)*triangleNoise(p.xz*0.3)\n            +abs(n.z)*triangleNoise(p.xy*0.3))/fTotal;\n}\n\n//\n\nvec3 ACESFilm( vec3 x ) {\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n    vec3 fp = fisheye_lookup( 4.2 + sin( time ) * 0.025, p );\n   //p = fp.xy;\n\n    // camera\n    vec3 ro = zoom*vec3(4.0);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    vec3 rdfp = normalize( fp.x*uu + fp.y*vv + 4.0*ww );\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.1) );\n    vec2 tmmfp = iSphere( ro, rdfp, vec4(0.,0.,0.,2.1) );\n    vec2 tmmp = iSphere( ro, rd, vec4(0.,0.,0.,1.245) );\n    \n\n\t// raymarch\n    vec4 icol = raymarch(ro,rd,tmmfp);\n    vec4 icolfp = raymarch(ro,rdfp,tmmfp);\n    vec3 col = icol.xyz * 4.0; float acol = icol.w;\n  float noise = 0.0;\n    \n    if (tmm.x<-0.)\n        col = vec3( 0.0 );\n    else \n    {\n        vec3 cnor = (ro+tmm.x*rd);\n        vec3 cnorp = (ro+tmmp.x*rd);\n        vec3 nor=cnor/2.5;\n        nor = reflect(rd, nor);     \n        \n        vec3 nor2=cnor/3.0;\n        nor2 = reflect(rd, nor2);     \n        \n        vec3 norp=cnorp/2.8;\n        norp = reflect(rd, norp); \n        \n        float frep = clamp( dot( norp, rd ), 0.0, 1.0 ); \n\t\tnoise = clamp( 0.3 + pow( MAT_triplanarScratches( cnorp - iTime * 0.03, cnorp ), 1.3 ) * 10.0, 0.0, 1.0 );\n        \n        col *= mix( 1.0, noise, frep * frep* frep);\n        //icolfp *= 0.5 + noise * 1.5;\n        \n        //\n        \n        float fre = abs( dot( nor, rd ) );\n        float fre2 = clamp( dot( nor2, rd ), 0.0, 1.0 );   \n        \n        float eclipse = pow( clamp( dot( nor2, rd ) + 2.0, 0.0, 1.0 ), 1.5 );\n        \n        //\n        \n        vec3 diffuse = vec3( clamp( dot( norp, normalize( vec3( -1.0, 1.3, 1.0 ) ) ), 0.0, 1.0 ) )  * 0.2 * (0.9 + rd * 0.3 );\n        diffuse       += vec3( clamp( dot( norp, normalize( vec3(  1.0, -0.3, -0.7 ) ) ), 0.0, 1.0 ) ) * 0.15 * ( 1.3 - rd * 0.3 );\n        diffuse       += vec3( clamp( dot( norp, normalize( vec3(  0.0, -0.0, -1.0 ) ) ), 0.0, 1.0 ) ) * 0.1 * ( 0.9 + rd * 0.3 );\n        \n        \n        float fade = pow( 1.0 - fre2, 1.7 );\n        vec3 storedcol = fade * vec3( clamp( smin( smin( smin( acol, col.z ), col.y ), col.x ), 0.0, 8.0 ) );// * vec3(2.8 - tmm.x * 0.125, 4.0, 2.5 + tmm.x * 1.5);\n        col += clamp( diffuse * (1.0-0.7*tmm.x*noise), 0.0, 1.0 );// * vec3(1.1 - tmm.x * 0.125, 0.5, 0.5 + tmm.x * 0.5);\n        col *= vec3( pow( ( 1.0 - fre * fre ) + pow( fre, 4.0 ), 5.0 ) );\n        \n        col += clamp( icolfp.xyz * pow( fre2, 3.0 ), 0.0, 4.0 ) * 256.0 * clamp( pow( 1.0 + fp.z, 4.0 ), 0.0, 1.2 );\n        col *= fade * eclipse;\n        \n        col = .3 *(log(1.0+col));\n        col += 1.3 *(log(1.0+(storedcol * eclipse * 0.04)));\n        col *= clamp( pow( 1.0 + fp.z, 0.5 ), 0.0, 1.0 );\n    }\n\t\n\t// shade\n    //col = clamp(col,0.,1.);\n    fragColor = vec4( lin2srgb( pow( ACESFilm( vec3( col ) ), vec3( 1.5 ) ) * 1.3 ), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcXDl", "name": "Gilmore Stripes", "author": "airtight", "description": "Playing with Andy Gilmore style color palette", "tags": ["palette", "stripes"], "likes": 17, "viewed": 709, "date": "1461977604", "time_retrieved": "2024-06-20T18:34:27.971382", "image_code": "const float PI = 3.14159;\nconst float numStripes = 16.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 gilmoreCol(float x){\n    \n     //stepped hue\n     x = floor(x*numStripes)/numStripes;\n    \n     //offset hue to put red in middle\n    //flip it and reverse it\n    float hue = fract((1.0 - x) - 0.45);\n    \n    //saturation is higher for warmer colors\n    float sat = 0.3 + sin(x*PI)*0.5;\n    \n    //brightness higher in middle\n    float bri = (smoothstep(0.,0.6, x) - smoothstep(0.6,1.0,x))*.6 + 0.3;\n   \n    //darker\n    bri *= 0.85;\n    \n    return vec3(hue, sat,bri);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //stripes\n    float x = uv.x;\n    x = fract( x  +  iTime/10. );\n   \n    //rings\n    vec2 p =(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    x = distance(p , vec2(0)); \n    x = fract( x  +  iTime/10. );\n    \n    vec3 hsv = gilmoreCol(x);\n    \n    //vertical brightness gradient\n    hsv.z -= fract( uv.y  )/2.;\n    \n    //add in gradient stripes\n    //th-th-thats all folks\n    float stripes = 1. - fract(x*numStripes);\n    hsv.z = mix(hsv.z,stripes,0.03); \n    \n    vec3 col = hsv2rgb(hsv);\n  \tfragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcXDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcXWl", "name": "Realtime Spacetime ", "author": "pix", "description": "Based on https://www.shadertoy.com/view/XddXWf  ..  got some motion to it", "tags": ["raytrace", "spacetime"], "likes": 13, "viewed": 377, "date": "1461946659", "time_retrieved": "2024-06-20T18:34:27.988617", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 po = ro - sph.xyz;\n    \n    float b = dot( rd, po );\n    float c = dot( po, po ) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    h = b + sqrt( h );//#\n    \n    return -h;//#\n}\n\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return d;\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\n}    \n   \n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return (pos - sph.xyz)/sph.w;    \n}\n\n//=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    vec2 vxy = voronoi( 50.0*d.xy );\n   \tvec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n    col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n   \tcol += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n\n}\n\n//--------------------------------------------------------------------\n\nvec4 sph1 = vec4( cos(iTime*.5)*.5, 0.0, sin(iTime*.5)*.5, 1.0 );//#\n\n// moon coord\nvec4 sph2 = sph1 + vec4( cos(iTime*.7)*2., 0.0, sin(iTime*.7)*2.5, -.8 );//#\n\nvec4 sph3 = sph2 + vec4( cos(-iTime*2.)*.5, 0.0, sin(-iTime*2.)*.5, -.15 );//#\n\nfloat rayTrace( in vec3 ro, in vec3 rd, vec4 k)//#\n{\n    return shpIntersect( ro, rd, k );//#\n}\n\nfloat map( in vec3 pos )\n{\n    float d1 = length( pos.xz - sph1.xz );\n    float d2 = length( pos.xz - sph2.xz );\n    float d3 = length( pos.xz - sph3.xz );\n    \n    float d = -log( exp( -d1 ) + exp( -d2 ) + exp( -d3 ));\n    \n    float h = 1.0-2.0/(1.0 + 0.3*d*d);\n    \n    return pos.y - h;\n}\n\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\n{\n    float t = 0.0;\n    \n    // bounding plane\n    float h = (1.0-ro.y)/rd.y;\n    if( h>0.0 ) t=h;\n\n    // raymarch 30 steps    \n    for( int i=0; i<30; i++ )    \n    {        \n        vec3 pos = ro + t*rd;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    return t;    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col = background( rd, lig );\n    \n    // raytrace stuff    \n    float t1 = rayTrace( ro, rd, sph1 );//#\n    float t2 = rayTrace( ro, rd, sph2 );//#\n    float t3 = rayTrace( ro, rd, sph3 );//#\n\tfloat t = min(min(t1,t2),t3);//#\n    \n    vec4 sph = sph1;//#\n    if (t == t2) sph = sph2;//#\n    if (t == t3) sph = sph3;//#\n    \n    if( t>0.0 )\n    {\n        vec3 mat = vec3( 0.18 );\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph );//#\n            \n        float am = 0.1*iTime;\n        vec2 pr = vec2( cos(am), sin(am) );\n        vec3 tnor = nor;\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\n\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\n        pr = vec2( cos(am2), sin(am2) );\n        vec3 tnor2 = nor;\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\n\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\n\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\n\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\n        sea *= 0.15;\n\n        vec3 land = vec3(0.02,0.04,0.0);\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\n        land *= 0.5;\n\n        float los = smoothstep(0.45,0.46, l);\n        mat = mix( sea, land, los );\n\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\n        float clouds1 = smoothstep( 0.3, 0.6, cc1 );\n\n        float cc2 = fancyCube( iChannel1, tnor2, 0.2, 0.0 ).y;\n        float clouds2 = smoothstep( 0.3, 0.6, cc2);\n\n        float clouds = clouds1;// + clouds2*0.1;\n\n        //mat = mix( mat, vec3(0.0), smoothstep( 0.0, 0.6, cc1 ) );\n\n        //mat = mix( mat, vec3(0.93*0.15), clouds );\n\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\n        mat *= 0.8;\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\n        lin += 0.01;\n        col = mat * lin;\n        col = pow( col, vec3(0.4545) );\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\n\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\n    }\n    \n    // raymarch stuff    \n    float tmax = 20.0;\n    if( t>0.0 ) tmax = t; \n    t = rayMarch( ro, rd, tmax );    \n    if( t<tmax )\n    {\n    \tvec3 pos = ro + t*rd;\n\n        vec2 scp = sin(2.0*6.2831*pos.xz+iTime*15.0);\n            \n        vec3 wir = vec3( 0.0 );\n        wir += 1.0*exp(-12.0*abs(scp.x));\n        wir += 1.0*exp(-12.0*abs(scp.y));\n//        wir += 0.5*exp( -4.0*abs(scp.x));\n//        wir += 0.5*exp( -4.0*abs(scp.y));\n//        wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph, 4.0 );//#\n\n        col += wir*0.5*exp( -0.05*t*t );;\n        //col += 0.5*exp( -0.05*t*t );;\n    }        \n\n    if( dot(rd,sph.xyz-ro)>0.0 )//#\n    {\n        float d = min(min(sphDistance( ro, rd, sph1 ), sphDistance( ro, rd, sph2 )), sphDistance( ro, rd, sph3));//#\n        vec3 glo = vec3(0.0);\n        glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n        glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n       \tglo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n        col += glo*2.0;\n    }        \n    \n    col *= smoothstep( 0.0, 6.0, iTime );\n\n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\n\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\n\n    vec3 col = render( ro, rd );\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    \n    fragColor = vec4( render( ro + cam*fragRayOri,\n                                   cam*fragRayDir ), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcXWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcXzf", "name": "Elliptic curve warmup", "author": "huttarl", "description": "Rendering an elliptic curve for cycling values of a and b.\n(OK, once in a great while you'll get a non-elliptic curve: when a = b = 0.)", "tags": ["math", "function", "elliptic"], "likes": 4, "viewed": 623, "date": "1460493651", "time_retrieved": "2024-06-20T18:34:28.322886", "image_code": "// This is an exercise in preparation for another shader I'm working on,\n// https://www.shadertoy.com/view/lstXRj (not published yet).\n\n// See https://en.wikipedia.org/wiki/Elliptic_curve about elliptic curves.\n\n// HT to marius at https://www.shadertoy.com/view/Mt2Gzw, who already made a shader\n// with elliptic curves. I used his delta idea (adapted).\n\n// Idea: add sound. Maybe have two sounds, and the volume of one is\n// proportional to a, the other, to b.\n\n// Idea: make this 3D, a hill growing and spawning a blob.\n//   Maybe make it stereoscopic, and/or VR.\n\n// Idea from Jo Grace:\n//   a water surface spawning a droplet that comes out, then splashes back down.\n\nconst float PI = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2. - 1.) * 5.; // center at origin and zoom out.\n    \n    // By keeping a's and b's cycles out of close sync, the idea is to\n    // cover a bigger variety of curve shapes over time.\n    float a = -0.5 - 8.5 * cos(iTime), b = 0.5 + 8.5 * cos(iTime * 0.71415);\n    \n\t// fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float delta = -uv.y * uv.y + uv.x * uv.x * uv.x + a * uv.x + b;\n    float ad = abs(delta);\n\n    const float hueChange = 1.;\n    float r1 = sin(ad * hueChange + iTime) * 0.5 + 0.5;\n    float g1 = sin(ad * hueChange + iTime + PI * 2. / 3.) * 0.5 + 0.5;\n    float b1 = sin(ad * hueChange + iTime + PI * 4. / 3.) * 0.5 + 0.5;\n\n    // JG wanted rainbow colors.\n    // Rainbow on black:\n    // fragColor = vec4(r1, g1, b1, 1.0) * pow(0.8, ad*5.);\n    // Rainbow on white:\n    fragColor = mix(vec4(r1, g1, b1, 1.0), vec4(1.0), 1. - pow(0.2, ad));\n\n    // a little fancy coloring...\n    // fragColor = vec4(ad, pow(abs(delta), 0.16), pow(abs(delta), 0.1), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddSDS", "name": "Fur Space 3", "author": "aiekick", "description": "Based on shane shader : [url=https://www.shadertoy.com/view/ll2SRy]Transparent Cube Field[/url]", "tags": ["space", "fur", "3"], "likes": 29, "viewed": 1077, "date": "1461245456", "time_retrieved": "2024-06-20T18:34:28.686578", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* \n\tBased on shane shader : https://www.shadertoy.com/view/ll2SRy\n*/\n\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat dstepf = 0.0;\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*1.8);\n    p.y += cos(p.z*.2) * sin(p.x*.8);\n\tp *= getRotZMat(p.z*0.8+sin(p.x)+cos(p.y));\n    p.xy = mod(p.xy, 0.3) - 0.15;\n\tdstepf += 0.003;\n\treturn length(p.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5)); \n    vec3 ro = vec3(0, 0, iTime*1.26), col = vec3(0), sp;\n\tfloat cs = cos( iTime*0.375 ), si = sin( iTime*0.375 );    \n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n\tfloat t=0.06, layers=0., d=0., aD;\n    float thD = 0.02;\n\tfor(float i=0.; i<250.; i++)\t\n\t{\n        if(layers>15. || col.x > 1. || t>5.6) break;\n        sp = ro + rd*t;\n        d = map(sp); \n        aD = (thD-abs(d)*15./16.)/thD;\n        if(aD>0.) \n\t\t{ \n            col += aD*aD*(3.-2.*aD)/(1. + t*t*0.25)*.2; \n            layers++; \n\t\t}\n        t += max(d*.7, thD*1.5) * dstepf; \n\t}\n    col = max(col, 0.);\n    col = mix(col, vec3(min(col.x*1.5, 1.), pow(col.x, 2.5), pow(col.x, 12.)), \n              dot(sin(rd.yzx*8. + sin(rd.zxy*8.)), vec3(.1666))+0.4);\n    col = mix(col, vec3(col.x*col.x*.85, col.x, col.x*col.x*0.3), \n             dot(sin(rd.yzx*4. + sin(rd.zxy*4.)), vec3(.1666))+0.25);\n\tfragColor = vec4( clamp(col, 0., 1.), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddSRl", "name": "Cirrocumulus Business", "author": "jameswilddev", "description": "cloud computing?", "tags": ["sea", "cloud", "sky", "floor", "sand", "cirrocumulus"], "likes": 1, "viewed": 119, "date": "1460894565", "time_retrieved": "2024-06-20T18:34:28.686578", "image_code": "vec3 densityToColor(float density) {\n    return mix(vec3(0.1, 0.2, 0.3), mix(vec3(0.2, 0.6, 1.0), vec3(0.8, 0.82, 1.0), density), density);\n}\n\nvec2 coord(vec2 pix, vec2 res) {\n\treturn (pix - res / 2.0) / min(res.x, res.y) * 2.0;\n}\n\nvec2 wave(vec2 axis, float freq, float amount, vec2 loc) {\n    return loc + sin(iTime + dot(normalize(axis), loc) / freq) * amount;\n}\n\nfloat density(vec2 loc) {\n    return 1.0 / (length(loc) + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(densityToColor(density(wave(vec2(-2.0, 4.0), 0.01, 0.3, wave(vec2(9.0, -11.0), 0.2, 0.3, wave(vec2(4.0, 7.0), 0.07, 0.1, coord(fragCoord.xy, iResolution.xy)))))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddSWf", "name": "Generalized Mandelbrot", "author": "coyote", "description": "z=z^d+c, 2<=d<=6", "tags": ["fractal", "mandelbrot"], "likes": 10, "viewed": 1069, "date": "1461852877", "time_retrieved": "2024-06-20T18:34:28.686578", "image_code": "void mainImage( out vec4 o, vec2 p )\n{\n    p = (p+p-(o.xy=iResolution.xy))/o.y/.7;\n    vec2 z = p;\n    float a, r, d = 2.+2.*(1.-cos(iTime/5.));\n    o = vec4(0,0,0,1);\n    for( float i = 0. ; i < 100. ; i++ ) {\n        r = length(z);\n        a = d * atan(z.y, z.x);\n        z = pow(r, d) * vec2(cos(a), sin(a)) + p;\n        if( r > 100.) {\n            o.r = d * i/100.;\n            break;\n        }\n    }\n    o = sqrt(o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddSWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddSWX", "name": "8-bittish waterfall", "author": "roywig", "description": "Just a quick sketch; colors and gradient and so on need some real work. Could be golfed pretty small.\n\nInspired by Mark Ferrari\nhttp://www.gdcvault.com/play/1023586/8-Bit-8-Bitish-Graphics\nhttp://www.effectgames.com/demos/canvascycle/?sound=0", "tags": ["water"], "likes": 13, "viewed": 297, "date": "1461807124", "time_retrieved": "2024-06-20T18:34:28.686578", "image_code": "#define PI 3.14159\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\nvec3 palette(float value){\n    value = sin((value-.25)*PI*2.)/2.+0.5;\n    return mix(vec3(0.108,0.943,1.000),vec3(0.023,0.679,1.000),value);\n}\nvec3 colorWave(float in_,float wavea, float waveb){\n    float value = map(in_,wavea,waveb,0.,1.);\n    return palette(mod(value-iTime,1.))*step(wavea,in_)*(1.-step(waveb,in_));\n}\nfloat wave(float x, float height,float y){\n    return height*sin(x)+y;\n}\nfloat nthWave(float x, float n){\n    return wave(x, n,exp(n)-1.);\n}\nvec3 waves(vec2 z){\n    vec3 color;\n    color = colorWave(z.y,0.,nthWave(z.x,1.));\n    for (float j = 1.; j < 6.; j+=1.){\n        color += colorWave(z.y, nthWave(z.x,j),nthWave(z.x,j+1.));\n    }\n\treturn color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 z = fragCoord.xy/iResolution.xy;\n    z.x *= iResolution.x/iResolution.y;\n    z += vec2(-1);\n    z = z * 10.;\n    z.y = -z.y;\n    vec3 color = mix(waves(z),waves(z-vec2(PI,0.)),0.5);\n    color = mix(color, vec3(0.044,0.069,0.225),(z.y/30.));\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddXW7", "name": "Functional Animation", "author": "akohdr", "description": "Playing with time dependent macros and simple 2D animation overlays.\nClick to move Green point, last quadrant clicked selects underlying texture.\nIncludes Barycentric coordinate triangle test function.\n", "tags": ["2d", "animation", "barycentric", "functional"], "likes": 1, "viewed": 173, "date": "1460420796", "time_retrieved": "2024-06-20T18:34:29.953330", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Barycentric 2D triangle test (order of a,b,c irrelevant)\n#define TRIABC(p,a,b,c) triBarycentricSwizzle2(vec4(p,a),vec4(b,c))\n//#define TRIABC triBarycentricSwizzle\n//#define TRIABC triBarycentric\n\n// outline width 5.0\n//#define TRIABC(p,a,b,c) abs(sdTriangle(a,b,c,p))<5.0\n\n// filled when facing\n//#define TRIABC(p,a,b,c) sdTriangle(a,b,c,p)<0.\n\n// hollow mask when facing\n//#define TRIABC(p,a,b,c) sdTriangle(a,b,c,p)>0.\n\n// box test\n//#define TRIABC(p,a,b,c) (BOXAB(p,MIN3(a,b,c),MAX3(a,b,c))&&length(a+b+c)<5.)\n\n#define Q(q) if(q) return true;\n#define QF(q) if(q) return false;\n#define QOR(a,b,c) {Q(a); Q(b); Q(c);}\n#define QORF(a,b,c) {QF(a); QF(b); QF(c);}\n\n// Barycentric method for filled 2D triangle\nbool triBarycentricSwizzle2(const in vec4 a, const in vec4 b) \n{\n    vec4 p = vec4(a.z,b.wxy) - vec4(b.xyz,a.w),\n         q = vec4(a.wz, b.yx) * b,\n         r = vec4(q.zx - q.wy, a.zw * b.wz),\n         s = a.yxyx * p;\n    vec2 t = (r.xy + s.yw + s.zx)/(r.x + r.y + r.z - r.w);\n    return !(t.x<0.||t.y<0.||(t.x + t.y)>1.);\n}\n\n// Barycentric method for filled 2D triangle\nbool triBarycentricSwizzle(const in vec2 p, const in vec2 a, const in vec2 b, const in vec2 c) \n{\n    vec4 q = vec4(b.yx, a.yx)*vec4(a,c),\n         r = vec4(q.zx - q.wy, b*c.yx),\n         s = p.xyxy*(vec4(c.y,a,b.x) - vec4(a.y,c.x,b.y,a.x));\n    vec2 t = (r.xy + s.xz + s.yw)/(r.x + r.y + r.z - r.w);\n    return !(t.x<0.||t.y<0.||(t.x + t.y)>1.);\n}\n\n// Barycentric method for filled 2D triangle\nbool triBarycentric(const in vec2 p, const in vec2 a, const in vec2 b, const in vec2 c) \n{\n    // could likely vectorize/swizzle further\n    vec2 pac = a.yx*c.xy,\n         pab = a.xy*b.yx;\n    \n    float ax=a.x, ay=a.y, bx=b.x, by=b.y, cx=c.x, cy=c.y, px=p.x, py=p.y,\n\n// the method:\n//          f = ay*(cx - bx) + ax*(by - cy) + bx*cy - by*cx,\n//          s = (ay*cx - ax*cy + (cy - ay)*px + (ax - cx)*py)/f,\n//          t = (ax*by - ay*bx + (ay - by)*px + (bx - ax)*py)/f;\n\n          // some partials\n//          aycx = ay*cx, \n//          axby = ax*by, \n//          axcy = ax*cy, \n//          aybx = ay*bx,\n//          aycx_axcy = aycx - axcy, \n//          axby_aybx = axby - aybx,\n          aycx_axcy = pac.x - pac.y, \n          axby_aybx = pab.x - pab.y,\n        \n          // compute f,s,t\n          f = aycx_axcy + axby_aybx + bx*cy - by*cx,\n          s = (aycx_axcy + (cy - ay)*px + (ax - cx)*py)/f,\n          t = (axby_aybx + (ay - by)*px + (bx - ax)*py)/f;\n\n    // boolean test s>0 & t>0 & s+t<1 to see if we're in triangle a,b,c\n\n// really need disassembly to see what compiler generates.\n//    return s>0. && t>0. && s+t<1.;\n//    return !(s<0. || t<0. || s+t>1.);\n    QORF(s<0., t<0., (s+t)>1.)\n    return true;\n}\n\n// Range test (use logical equivalences to eng. early return for particular use case)\n#define RNGT(a,l,v,u,b,c) a l v c v u b\n\n// Normal form decorator ensures a<b before applying ternary op F\n#define NF(F,a,c,b) ((a<b) ? F(a,c,b) : F(b,c,a))\n\n// Deal with non-commutative ops explicitly\n#define AOPB(a,c,b) (a c b)\n#define BOPA(a,c,b) (b c a)\n\n// abs difference between two terms\n#define DIF(a,b) NF(BOPA,a,-,b)\n// shorthand\n#define DIFy(a,b) DIFc(a.y,b,y)\n#define DIFx(a,b) DIFc(a.x,b,x)\n\n// call-less ABS eesentially expands to ternary assignment (compiler should do this)\n// (watch the LISPy-ness use of brackets a is src term not value)\n#define ABS(a) DIF((a),0.)\n#define ABSI(a) DIF((a),0)\n\n#define IN_AND(a,v,b) RNGT(a,<=,v,<=,b,&&)\n#define IN_OR(a,v,b) !(RNGT(a,>,v,>,b,||))\n#define IN IN_OR\n\n#define OUT_AND(a,v,b) !RNGT(a,<=,v,<=,b,&&)\n#define OUT_OR(a,v,b) RNGT(a,>,v,>,b,||)\n#define OUT OUT_OR\n\n#define MID(a,b,f) ((a<b) ? a+(f-a)*(a/b) : b+(f-b)*(b/a))\n#define MIDF(a,b,f) vec2(MID(a.x,b.x,f.x),MID(a.y,b.y,f.y))\n\n#define MIN3(a,b,c) min(a,min(b,c))\n#define MAX3(a,b,c) max(a,max(b,c))\n\n#define BOXAB_IN(p,a,b) NF(IN,a.x,p.x,b.x)&&NF(IN,a.y,p.y,b.y)\n#define BOXAB_OUT(p,a,b) !(NF(OUT,a.x,p.x,b.x)||NF(OUT,a.y,p.y,b.y))\n#define BOXAB BOXAB_OUT\n\n#define DISK(p,c,r) length(p-c)<r\n//#define HLINE(p,c,r) abs(p.y-c.y)<r\n#define HLINE(p,c,r) DIFy(p,c)<r\n\n//#define VLINE(p,c,r) abs(p.x-c.x)<r\n#define VLINE(p,c,r) DIFx(p,c)<r\n\n// variations on theme\n#define TRI1a(p,c,r,h,v) ABS(p.x-c.x)<r-ABS(p.y-c.y) && p.y v c.y && p.x h c.x\n#define TRI1b(p,c,r,h,v) abs(p.y-c.y)<r-abs(c-p).x && p.y v c.y && p.x h c.x\n#define TRI1c(p,c,r,h,v) DIF(p.x,c.x)<r-DIF(p.y,c.y) && p.y v c.y && p.x h c.x\n#define TRI2a(p,c,r,h,v) abs(p.x-c.y)<r-abs(c-p).y && p.y v c.y && p.x h c.x\n#define TRI2b(p,c,r,h,v) abs(p.x-c.y)<r-abs(c-p).y && p.y v c.y && p.x h c.x\n\n#define TRI3(p,c,r,h,v) abs(p.x-c.y)<r+abs(c-p).y && p.x v c.x && p.y h c.y\n#define TRI4(p,c,r,h,v) abs(p.x-c.x)<r+abs(c-p).y && p.y v c.y && p.x h c.x\n#define TRI5(p,c,r,h,v) abs(p.y-c.x)<r+abs(c-p).x && p.y v c.y && p.x h c.x\n#define TRI6(p,c,r,h,v) abs(p.y-c.y)<r+abs(c-p).x && p.y v c.y && p.x h c.x\n\n#define QUAD(p,c,r,h,v) abs(p.x-c.x)<r+abs(c-p).x && p.y v c.y && p.x h c.x\n#define DIA1(p,c,r) abs(p.x-c.y)<r-abs(c-p).y && p.x < c.x && p.x < c.x\n\n#define TRI_112(p,c,r,h,v) abs(p.x-c.x)<r-abs(c-p).y && p.y v c.y && p.x h c.x\n\n#define TRI TRI1c\n\n#define QC(C,p) if(p) {fc=C;return;}\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ORG vec4(1.,.5,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define SLM vec4(1.,.5,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n#define vO vec2(0,0)\n\n#define iM iMouse\n#define iR iResolution\n#define iT iTime\n\n#define sT(a,f) a*sin(f*iT)\n#define asT(a,f) abs(a*sin(f*iT))\n#define cT(a,f) a*cos(f*iT)\n#define acT(a,f) abs(a*cos(f*iT))\n\n#define linT(a,st,dt,t) a*smoothstep(st,st+dt,t)\n\n// Returns background based on last quadrant clicked\nvec4 quadrantChannel(const in vec2 P) {\n\n    vec2 irxy = iR.xy, \n         ctr = irxy/2., \n         uv = P/irxy;\n\n    return iM.x<ctr.x ? \n        \tiM.y>ctr.y ? texture(iChannel0, uv) : texture(iChannel3, uv) :\n        \tiM.y>ctr.y ? texture(iChannel1, uv) : texture(iChannel2, uv);\n}\n\n// Distance func just seems like bit of overkill....\n\n// signed distance to a 2D triangle (iq)\nfloat sdTriangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n\tvec2 e0 = b - a, e1 = c - b, e2 = a - c, v0 = p - a, v1 = p - b, v2 = p - c,\n\n\t     pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 ),\n\t     pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 ),\n\t     pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 ),\n    \n         d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fc, in vec2 P ) {\n    \n\tvec2 ctr = iR.xy/2.,\n         uv = P/iR.xy;\n\n    // Lissajous path\n    float r = min(ctr.x,ctr.y)-iR.x/40.;\n    vec2 orb = vec2(sT(r,3.),cT(r,2.)),\n         lp = ctr + orb;\n    \n\t// cyan triangle\n    vec2 a = ctr + orb,\n         b = ctr - orb,\n         c = iM.xy;\n    \n    vec2 co = normalize(P.xy);\n    QC((CYN+vec4(co.xy,co.xy))/1.6, TRIABC(P,a,b,c))\n    QC(quadrantChannel(P), BOXAB(P,a,b))\n\n    float sz = 10.+abs(cT(20.,.5));\n        \n    QC(RED, TRI(P, lp, sz, <, >))\n    QC(GRN, TRI(P, lp, sz, >, >))\n    QC(BLU, TRI(P, lp, sz, <, <))\n    QC(YEL, TRI(P, lp, sz, >, <))\n\n    QC(YEL, DISK(P, ctr.xy + orb.xy, sz))\n    QC(GRN, DISK(P, iM.xy, sz))\n\n    float l = asT(100.,3.);\n    QC(ORG,NF(IN,l, P.x, l+sT(iR.x/3.,2.)))\n    QC(PRP,IN(l, P.y, l+asT(iR.y/2.,2.)))\n        \n    QC(vec4(2.*P.xy,1.,1.)/iR.x*asT(1.,2.), DISK(P, P, sz))\n    \n    fc = quadrantChannel(P);\n}\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddXWX", "name": "wobblyrect", "author": "elpuri", "description": "wobblez", "tags": ["rect"], "likes": 3, "viewed": 125, "date": "1461825481", "time_retrieved": "2024-06-20T18:34:30.135226", "image_code": "float distanceToPerimeter(vec2 p, vec2 bounds, float radius)\n{\n\treturn length(max(abs(p) - bounds, 0.0)) - radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord - iResolution.xy * 0.5;\n    float radius = 20.0;\n\tvec2 bounds = vec2(140.0 - radius, 90.0 - radius);\n\tfloat w = 12.0;\n//    float w = sin(atan(p.y, p.x) * 6.0 + iTime * 3.5) * 3.0 + 8.0;\n\tfloat wobble = sin(fragCoord.x / 20.0 + iTime * 3.5) + sin(fragCoord.y / 20.0 + iTime * 2.2);\n//\tfloat wobble = sin(atan(p.y, p.x) * 6.0 + iTime * 3.5);\n//\tfloat wobble = 0.0;\n    wobble *= 3.0;\n    float d = distanceToPerimeter(p, bounds, radius);\n    float c = 0.3 + smoothstep(0.5 + wobble, 1.5 + wobble, d) * 0.7 - smoothstep(w - 0.5 + wobble, w + 0.5 + wobble, d);\n\tvec2 texCoord = vec2(fragCoord/ iResolution.xy);\n    vec4 bgColor = texture(iChannel0, texCoord);\n    vec4 frameColor = vec4(1.0, 0.2, 0.5, c);\n    fragColor = vec4(mix(bgColor.rgb, frameColor.rgb, frameColor.a), 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dtXW7", "name": "Shader Lesson #4: Pythagoras", "author": "hubbe", "description": "Demonstrates the pythagorean theorem.  Moving the red, blue and green triangles will either let you build two squares, with sides matching the sides of the triangle (in white). Or, you can build one larger square with sides matching the hypotenuse. ", "tags": ["educational", "mondrian"], "likes": 4, "viewed": 293, "date": "1459753789", "time_retrieved": "2024-06-20T18:34:30.141394", "image_code": "// Plot a function, and a background grid.\n\nhighp float pi = 3.14159265;\n\n// Fom -2 to 2\nhighp float scale = 4.0;\n\n// Transform an vec2 onscreen coordinate (0.0-1.0) to a coordinate that\n// we want to plot the function for. (+/- scale*2)\nvec2 p2v(vec2 pos) {\n    pos -= vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n    pos *= scale;\n    return pos;\n}\n\nfloat a() {\n    float f = sin(iTime / 2.0) * 0.8;\n    return f + 1.1;\n}\n\nfloat b() {\n    float f = sin(iTime / 2.0 / pi) * 0.8;\n    return f + 1.1;\n}\n\n// Draws the triangle.\nbool t(vec2 pos) {\n    pos = p2v(pos);\n//    if (pos.x < 0.0 && pos.y < 0.0 && pos.x > -b() * pos.y / a()- b())\n//        return true;\n\n    return pos.x > 0.0 && pos.y > 0.0 && pos.x < a() - a() * pos.y / b();  \n}\n\n// Draws one side square.\nbool c1(vec2 pos) {\n    pos = p2v(pos);\n    if (a() < b()) {\n      return pos.x > 0.0 && pos.y > 0.0 && pos.x < a() && pos.y < a();\n    } else {\n       return pos.x > 0.0 && pos.y < 0.0 && pos.x < a() && pos.y > - a();\n    }        \n}\n\n// Draws the other side square.\nbool c2(vec2 pos) {\n    pos = p2v(pos);\n    if (a() < b()) {\n       return pos.x < 0.0 && pos.y > 0.0 && pos.x > -b() && pos.y < b();\n    } else {\n       return pos.x > 0.0 && pos.y > 0.0 && pos.x < b() && pos.y < b();\n    }        \n}\n\n// Draws the square for the hypotenuse.\nbool h(vec2 pos) {\n    pos = p2v(pos);\n    vec2 av = vec2(a(), 0.0);\n    vec2 bv = vec2(0.0, b());\n    vec2 ab = bv - av;\n    float l = length(ab);\n    ab /= l;\n    vec2 abx = vec2(ab.y, -ab.x);\n    pos -= bv;\n    vec2 v = vec2(dot(abx, pos), dot(ab, pos));\n    return v.y < 0.0 && v.y > -l && v.x < 0.0 && v.x > -l;\n}\n\n\nvec4 squares(vec2 pos) {\n   \tbool H = h(pos);\n    bool C1 = c1(pos);\n    bool C2 = c2(pos);\n    vec4 ret = vec4(H ? 1.0 : 0.5, C1 ? 1.0 : 0.5, C2 ? 1.0 : 0.5, \n                (H || C1 || C2) ? 1.0 : 0.0);\n\tvec2 p = p2v(pos);\n    if (a() < b()) {\n        if (!H && C2 && p.y < b() - a())\n            ret = vec4(0,0,1,1);\n        if (H && p.x > 0.0 && p.y > a())\n            ret = vec4(0,0,1,1);\n        if (!H && C1)\n            ret = vec4(0,1,0,1);\n        if (H && p.y < 0.0 && p.x < a() - b())\n            ret = vec4(0,1,0,1);\n        if (!H && C2 && p.y > b() - a())\n            ret = vec4(1,0,0,1);\n        if (H && p.y < 0.0 && p.x > a() - b())\n            ret = vec4(1,0,0,1);\n    } else {\n        if (!H && C1 && p.x < a() - b())\n            ret = vec4(0,1,0,1);\n        if (H && p.y > 0.0 && p.x > b())\n            ret = vec4(0,1,0,1);\n        if (!H && C2)\n            ret = vec4(0,0,1,1);\n        if (H && p.x < 0.0 && p.y < b() - a())\n            ret = vec4(0,0,1,1);\n        if (!H && C1 && p.x > a() - b())\n            ret = vec4(1,0,0,1);\n        if (H && p.x < 0.0 && p.y > b() - a())\n            ret = vec4(1,0,0,1);\n    }\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    int cnt = 0;\n    int cnt2 = 0;\n    int cnt3 = 0;\n    int cnt4 = 0;\n    int max_cnt = 0;\n    // Multisample.\n    vec4 sum = vec4(0.0);\n    for (float x = -1.25; x <= 1.25; x += 0.25) {\n        for (float y = -1.25; y <= 1.25; y += 0.25) {\n            max_cnt ++;\n            if (t((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt ++;\n            if (c1((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt2 ++;\n            if (c2((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt3 ++;\n            if (h((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt4 ++;\n            sum += squares((fragCoord.xy + vec2(x, y)) / iResolution.yy);\n        }\n    }\n    if (cnt > max_cnt / 2) cnt = max_cnt - cnt;\n    if (cnt2 > max_cnt / 2) cnt2 = max_cnt - cnt2;\n    if (cnt3 > max_cnt / 2) cnt3 = max_cnt - cnt3;\n    if (cnt4 > max_cnt / 2) cnt4 = max_cnt - cnt4;\n    sum /= float(max_cnt);\n    \n    float color = float(cnt) * 2.0 / float(max_cnt);\n    float color2 = float(cnt2) * 2.0 / float(max_cnt);\n    float color3 = float(cnt3) * 2.0 / float(max_cnt);\n    float color4 = float(cnt4) * 2.0 / float(max_cnt);\n\tfloat bg = 0.0;\n    vec2 v = p2v(uv);\n    // Black axis\n//    if (abs(v.x) < scale/iResolution.x || abs(v.y) < scale/iResolution.y) {\n//      bg = 0.0;\n//    } else {\n\t    vec2 grid = step(mod(v, vec2(2.0, 2.0)), vec2(1.0, 1.0));\n    \tif (grid.x == grid.y) {\n          bg = 0.3;\n        } else {\n          bg = 0.4;\n        }\n//    }\n    \n    // Blend colors.\n    fragColor = vec4(bg);\n    fragColor = mix(fragColor, sum, sum.w);\n    fragColor = mix(fragColor, vec4(0.0), color2);\n    fragColor = mix(fragColor, vec4(0.0), color3);\n    fragColor = mix(fragColor, vec4(0.0), color4);\n    fragColor = mix(fragColor, vec4(2.0), color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dtXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dtXWf", "name": "Win", "author": "vox", "description": "I don't know what abomination I've created here, but maybe someone can tell me!\nI tried to make it look like this: https://www.shadertoy.com/view/MtjGz3", "tags": ["win"], "likes": 3, "viewed": 393, "date": "1461859146", "time_retrieved": "2024-06-20T18:34:30.141394", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*iTime/PI)\n#define saw(x) (acos(cos(x))/PI)\n#define stair floor\n#define jag fract\n\nvec2 SinCos( const in float x )\n{\nreturn vec2(sin(x), cos(x));\n}\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\nvec2 tree(vec2 uv)\n{\n    float turns = mod(floor(time/2.0), 6.0)+3.0;\n    uv = rotatez(uv.xy, PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    \n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    \n    vec2 xy = rotatez(uv.xy, \n                      PI*2.0*(rot)+PI/turns).xy;\n    \n    xy = sign(xy)*log(abs(xy));\n    \n    return vec2(saw(theta*turns), saw(xy.x*PI*2.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy*2.0;\n    float scale = .1+saw(time/PI)*2.0;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv += sin(vec2(time, time/PI*E*GR))*scale/2.0;\n    float r = length(uv);\n    uv = normalize(uv)/log(r+1.0);\n    uv += sin(vec2(time, time/PI*E*GR))*scale/2.0;\n    uv = tree(uv)*2.0-1.0; \n    uv += sin(vec2(time, time/PI*E*GR))*scale/2.0;\n    scale = .1+saw(time/PI);\n    uv = tree(uv); \n\n    fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dtXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dtXzX", "name": "Elliptic curve explorer", "author": "huttarl", "description": "Click the mouse to set the a and b parameters for the elliptic curve, to see how they affect the shape of the curve. The red lines show values for a and b that introduce singular points, making the curve non-elliptic.", "tags": ["math", "curve", "elliptic"], "likes": 3, "viewed": 504, "date": "1460605450", "time_retrieved": "2024-06-20T18:34:30.680652", "image_code": "// This is an exercise in preparation for another shader I'm working on,\n// https://www.shadertoy.com/view/lstXRj (not published yet).\n\n// In particular, it lets you explore how changes in a and b affect the curve.\n// Click mouse to set a = mouse x coordinate, b = mouse y.\n\n// The red curve shows values for a and b that introduce singular points in\n// the curve, such as cusps (a=b=0), self-intersections (certain b > 0), or\n// isolated points (certain b < 0), which make the curve non-elliptic.\n\n// For values of a and b left of the red curve, the elliptic includes a separate\n// round shape. For values above the red curve, the elliptic has a \"horseshoe\"\n// bend. For values below the red curve, the elliptic looks more like a simple\n// hyperbola.\n\n// See https://en.wikipedia.org/wiki/Elliptic_curve about elliptic curves.\n\n// HT to marius at https://www.shadertoy.com/view/Mt2Gzw, who already made a shader\n// with elliptic curves. I used his delta idea (adapted).\n\n// TODO: display the values of a and b on-screen, e.g. using digits from\n//    https://www.shadertoy.com/view/Xst3zX\n// TODO: use a 1:1 aspect ratio?\n// TODO: make the distance formulas more accurate for black line\n//    See e.g. https://www.shadertoy.com/view/Xd2Xz1\n//     or https://www.shadertoy.com/view/4ts3DB ?\n//   For the red line, we just get by with vertical distance to the nearest\n//   line.\n//   For the cubic curve, maybe also look at\n//    http://www.gamedev.net/topic/419160-distance-from-point-to-cubic-curve/\n//   What I see online talks about distance to a cubic spline, so we may need\n//   to approximate the curve as a spline.\n\nconst float PI = 3.14159265;\n\nfloat distRedLine(vec2 p) {\n    // The red line is where 4a^3 + 27b^2 = 0.\n    if (p.x > 0.) return 999999.;\n    // Just return vertical distance -- good enough.\n    float y = sqrt(p.x * p.x * p.x * -4./27.);\n    return abs(abs(p.y) - y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2. - 1.) * 5.; // center at origin and zoom out.\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = (m * 2. - 1.) * 5.;\n    \n    float a = m.x, b = m.y;\n        \n    float delta = -uv.y * uv.y + uv.x * uv.x * uv.x + a * uv.x + b;\n    float ad = abs(delta);\n\n    const float hueChange = 1.;\n    vec4 curveColor = vec4(\n        sin(ad * hueChange + iTime) * 0.5 + 0.5,\n        sin(ad * hueChange + iTime + PI * 2. / 3.) * 0.5 + 0.5,\n        sin(ad * hueChange + iTime + PI * 4. / 3.) * 0.5 + 0.5,\n\t    1.0);\n\n    // Thin black line in the middle\n    curveColor *= min(ad * 10., 1.);\n    \n    vec4 background = vec4(1.0);\n    \n    // Show where values of a,b would make the curve non-singular.\n    // When the determinant of a and b is zero, the curve is singular.\n    float dist = distRedLine(uv); // distance from red line\n    float color = min(dist * 20., 1.0);\n    background *= vec4(1., color, color, 1.);\n\n    // JG wanted rainbow colors.\n    // Rainbow on black:\n    // fragColor = vec4(r1, g1, b1, 1.0) * pow(0.8, ad*5.);\n    // Rainbow on white:\n    fragColor = mix(curveColor, background, 1. - pow(0.2, ad));\n\n    // a little fancy coloring...\n    // fragColor = vec4(ad, pow(abs(delta), 0.16), pow(abs(delta), 0.1), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dtXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SD2", "name": "Flow (Figure in report)", "author": "imagicien", "description": "Render I have done for a report for project 'Le Lounge' at Universite de Sherbrooke.\n\nHold the left mouse button to see something HOT.", "tags": ["perlin"], "likes": 2, "viewed": 164, "date": "1461444562", "time_retrieved": "2024-06-20T18:34:31.165560", "image_code": "// Render done for a report for project \"Le Lounge\"\n// Carl Lemaire, Universit de Sherbrooke\n\n#define X0 0.0\n#define Y0 0.5\n#define ALIVE_RADIUS 0.3\n#define DIEOUT_SIGMA 0.35\n#define Y_AXIS_SCALE 0.625\n\nvec3 getColor(float value)\n{\n    return clamp(vec3(\n        3.0 *  value,\n        3.0 * (value - 0.33),\n        3.0 * (value - 0.67)\n        ), 0.0, 1.0);\n}\n\nfloat dieOut(vec2 p)\n{\n    float dieOutSigma = DIEOUT_SIGMA * 1.0;\n\n    float x = p.x - X0;\n    float y = (p.y - Y0) * Y_AXIS_SCALE;\n    float rho = sqrt(x*x + y*y);\n\n    if (rho <= ALIVE_RADIUS)\n    {\n        return 1.0;\n    }\n    else\n    {\n        rho = rho - ALIVE_RADIUS;\n        return exp(-rho*rho / (2.0*dieOutSigma*dieOutSigma));\n    }\n}\n\n// Noise function adapted from a shader found on ShaderToy.com\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\nfloat noise(in vec3 x)\n{\n    // Perlin noise\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0),   hash(n + 1.0),   f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define SPACE_SCALE 16.0\n#define TIME_SCALE 0.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * TIME_SCALE * (float(iMouse.z > 0.0) * 0.5 + 1.0);\n    float x = uv.x;\n    float y = uv.y;\n\n    // The more a pixel is far from the Synaesthesis core, the more it is transparent.\n    float dieOutIntensity = dieOut(uv);\n\n    // Fractal-like sum of noises; each element of the sum has its own a frequency range.\n    // Adding up multiple noises gives a much more interesting and smooth effect.\n    float noiseIntensity = \n        noise(vec3(x, y,  time * 1.0) * SPACE_SCALE *  1.0) /  1.0 +\n        noise(vec3(x, y, -time * 1.2) * SPACE_SCALE *  2.0) /  2.0 +\n        noise(vec3(x, y,  time * 1.4) * SPACE_SCALE *  4.0) /  4.0 +\n        noise(vec3(x, y, -time * 1.6) * SPACE_SCALE *  8.0) /  8.0 +\n        noise(vec3(x, y,  time * 1.8) * SPACE_SCALE * 16.0) / 16.0 +\n        0.0;\n\t//noiseIntensity /= (1.0 + 1.0/2.0 + 1.0/4.0 + 1.0/8.0 + 1.0/16.0);\n    \n    float gray = dieOutIntensity - (1.0 - dieOutIntensity) * noiseIntensity;\n    \n    if (iMouse.z > 0.0)\n    \tfragColor = vec4(getColor(gray), 1.0);\n    else\n    \tfragColor = vec4(vec3(gray), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SDj", "name": "rusFlag", "author": "skpuralsk", "description": "    ", "tags": ["flag"], "likes": 1, "viewed": 77, "date": "1461413991", "time_retrieved": "2024-06-20T18:34:31.171652", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy;\n    xy.x = xy.x / iResolution.x;\n    xy.y = xy.y / iResolution.y;\n    \n    vec4 rusFlag = vec4(abs(sin(iTime)),0.0,0.0,abs(sin(iTime)));\n    if(xy.y > 0.33) {\n        rusFlag = vec4(0.0,0.0,abs(sin(iTime)),abs(sin(iTime)));\n    }\n    if(xy.y > 0.66) {\n        rusFlag = vec4(abs(sin(iTime)),abs(sin(iTime)),abs(sin(iTime)),abs(sin(iTime)));\n    }\n    \n\tfragColor = rusFlag;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SDN", "name": "Retro racetrack", "author": "tomkel", "description": "silly retro ractrack", "tags": ["procedural"], "likes": 10, "viewed": 258, "date": "1459461973", "time_retrieved": "2024-06-20T18:34:31.171652", "image_code": "float zigzag( float x )\n{ \n   /* float y = mod(x,3.142 ) / 3.142;\n    if ( y > 0.5 )\n    {\n        return 1.0-(y -0.5)/0.5;\n    }\n    return (y*2.0); */\n    \n    return cos(x);\n}\n\nfloat box( vec3 position, vec3 lengths, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    \n    float d0 = max( p.x - lengths.x, -p.x - lengths.x );\n    float d1 = max( p.y - lengths.y, -p.y - lengths.y );\n    float d2 = max( p.z - lengths.z, -p.z - lengths.z );\n    return vec4( max( d0, max(d1,d2 )), 1.0,0, 0.8).x;\n}\n\nfloat cylinder( vec3 position, vec2 dim, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    return max( length( p.zy ) - dim.x,\n                 max( p.x - dim.y, -p.x - dim.y));\n}\n\n\n\nfloat feature( vec3 position, vec2 dim, vec3 raypos )\n{\n \n   // float zoff = float(int(raypos.z / 10.0));\n    float y = (iTime*100.0);\n    float x = -zigzag( (y+raypos.z)/100.0 )*40.0;\n    \n    position.y -= floor( mod( (raypos.z + y) / 1000.0 , 2.0 )) * 10.0;\n    \n    //roadpos.y += iTime*100.0;\n    //position.x += x; //zigzag( raypos.z/100.0 )*40.0 ;\n    \n    //position.x = x;\n    float c0, c1, c2;\n    {\n    vec3 r = vec3( raypos.x, raypos.y, mod( raypos.z + y + 1000.0, 10.0 ) );\n  //  vec3 r = mod( raypos,10.0 );\n    vec3 p = r - vec3( position.x + x, position.y, position.z  );\n    c0 =  max( length( p.zx ) - dim.x,\n                 max( p.y - dim.y, -p.y - dim.y));\n    }\n    \n     {\n    vec3 r = vec3( raypos.x, raypos.y, mod( raypos.z + 1000.0 + y, 10.0 ) );\n    vec3 p = r - vec3( -position.x + x, position.y, position.z );\n    c1 =  max( length( p.zx ) - dim.x,\n                 max( p.y - dim.y, -p.y - dim.y));\n    }\n    \n    {\n    vec3 r = vec3( raypos.x, raypos.y, mod( raypos.z + 1000.0 + y, 10.0 ) );\n    vec3 p = r - vec3(  x, position.y + dim.y, position.z );\n    c2 =  max( length( p.zy ) - dim.x * 0.5,\n                 max( p.x - 15.0, -p.x - 15.0));\n    }\n    \n    return min( min(c0,c1 ), c2 );\n}\n\n\n\nvec4 road( vec2 roadpos )\n{\n    vec4 surface = vec4( 0.5,0.5,0.5,1.0);\n\n    \n    roadpos.y += iTime*100.0;\n    roadpos.x += zigzag( roadpos.y/100.0 )*40.0 ;\n    vec2 roadabs = abs(roadpos );\n    \n    if ( roadabs.x > 10.0 )\n    {\n    \n        if ( roadabs.x > 12.0)\n        {\n        \tsurface = vec4(0.0,1.0,0.0,1.0 );\n        }\n        else\n        {\n            float fy =  floor( (roadabs.y) / 0.8 );\n            if ( mod( fy, 2.0 ) == 0.0 )\n            {\n            \tsurface = vec4( 1,1,1,1.0);\n            }\n            else\n            {\n                surface = vec4( 1.0,0.0,0.0,1.0);\n            }\n        }\n    }\n    else\n    {\n        if ( roadabs.x < 0.1 )\n        {\n            float fy =  floor( (roadabs.y + 2.0 ) / 4.0 );\n            if ( mod( fy, 2.0 ) == 0.0 )\n            {\n            \tsurface = vec4( 1,1,1,1.0);\n            }\n            else\n            {\n                surface = vec4( 0.5,0.5,0.5,1.0);\n            }\n        }\n        else \n        {\n        \tsurface = vec4( 0.5,0.5,0.5,1.0);\n        }\n    }\n    \n    float fy = floor( roadabs.y / 20.0 );\n    \n    \n    \n    \n    if ( mod( fy, 2.0 ) == 0.0 ) \n    {\n        surface *= 0.8;\n    }\n    \n    return surface;\n     \n}\n\nfloat sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    return distance( spherepos, raypos ) - r;\n}\n\nvec4 getlight( vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    vec4 amb = vec4(0.3,0.3,0.3,1.0);\n    float d = distance( position, lightpos );\n    vec3 n = normalize( position - lightpos );\n    if ( dot( normal, n ) > 0.5 )\n    {\n        return lightcolour + amb;;\n    }\n    else if ( dot( normal, n ) > 0.1 )\n    {\n        return lightcolour * 0.5 + amb;;\n    }\n        \n    return amb;\n    \n}\n\n\nfloat smin( float a,  float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    float blend = -log( res )/k;\n    return blend;\n}\n\n\nfloat sdf( vec3 raypos )\n{\n    float xpos = iMouse.x / iResolution.x - 0.5 ;\n    float y = (iTime-3.0)*100.0;\n    float x = (xpos * 0.0 + zigzag( y/100.0 ))*40.0;\n    //float e = 1.0; //abs( 0.5 + abs( cos( iTime )) * 3.0 ) ;\n    float sdf0 = cylinder( vec3( x, 0.5, 0.0 ), vec2( 0.49,1.3 ), raypos  );\n    float sdf1 = cylinder( vec3( x, 0.5, 2.0 ), vec2( 0.49,1.2 ), raypos  );\n    float sdf2 =  box( vec3( x, 0.7, 1.0 ), vec3( 1.0, 0.5, 1.0), raypos);\n    float sdf3 =  feature( vec3(15.0,0,5.0), vec2(1.0,4.0), raypos );\n\n    return \n        \t min( sdf3, \n                min( sdf2, \n                    min( sdf1, \n                        min( sdf0, min(raypos.y, 20.0-raypos.y )) \n                    )\n                )\n              );\n                    //sphere( vec3( 0,10, 0.0), 2.0, raypos ), e );\n}\n\nvec4 contact( vec3 position, vec3 normal, float scale )\n{\n    float s = sdf( position + normal * scale );\n    \n    if ( s < scale )\n    {\n        return vec4(0.8,0.8,0.8,1.0);\n    }\n    \n    return   vec4(1.0,1.0,1.0,1.0);\n    \n    \n}\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ) - sdf( raypos - vec3( delta,0,0 ) );\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ) - sdf( raypos - vec3( 0,delta,0 ) );\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ) - sdf( raypos - vec3( 0,0,delta ) );\n    return vec3( dx,dy,dz );\n    //return vec3(0,-1.0,0);\n}\n\nvec4 march( vec3 ray, vec3 origin, float ep, vec2 uv)\n{\n    vec3 p = origin;\n    //int pscale = int(  float(iFrameRate) / 60.0 * 1024.0);\n    for ( int i = 0; i < 256; i++ )\n    {\n       /* if ( i == pscale )\n        {\n            break;\n        } */ \n        float step = sdf(p);\n        if ( step  <  ep )\n        {\n            if ( p.y  > 19.0 )\n            {\n    \t\t\treturn vec4( 0.3,0.3,1.0,1.0) *  ( (uv.y - 0.5) / 0.5  ) + \n                       vec4( 1.0,1.0,1.0,1.0) *  (1.0 - ( (uv.y-0.5) / 0.5  )) ;\n            }\n            else if ( p.y  > ep )\n            {\n            \tvec3 normal = normalize( grad( p, 0.1 ) );\n            \treturn getlight( normal, p,  vec3( 500 ,0,1000 ), vec4(1.0, 1.0, 1.0, 0 ));\n                \t   //getlight( normal, p,  vec3( -100,-100,-100 ), vec4(0.0,1.0,1.0,1.0 )) ;\n            }\n        \t\n            else \n        \t{\n            \treturn road( vec2( p.x, p.z ) ) * contact( p, vec3(0.0,1.0,0.0), 0.25 );\n        \t}\n        }\n        \n        p += ray * step;\n    }\n    \n    if ( ray.y < 0.0 )\n    {\n    \tvec3 h = ray * -origin.y / ray.y + origin;\n \t\treturn road( vec2( h.x, h.z ) ) * contact( p, vec3(0.0,1.0,0.0), 0.25 );\n    }\n    else\n    {\n   \n    return vec4( 0.3,0.3,1.0,1.0) *  ( (uv.y - 0.5) / 0.5  ) + \n           vec4( 1.0,1.0,1.0,1.0) *  (1.0 - ( (uv.y-0.5) / 0.5  )) ; \n    }\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    /*if ( uv.y > 0.8 )\n    {\n        fragColor = vec4( 0.3,0.3,1.0,1.0) *  ( (uv.y - 0.5) / 0.5  ) + \n                    vec4( 1.0,1.0,1.0,1.0) *  (1.0 - ( (uv.y-0.5) / 0.5  )) ;\n    }\n    else */ \n    {\n         float aspect = iResolution.y / iResolution.x;\n    \n    \t vec3 origin = vec3(0.0, 2.0,-5.0 );\n    \t vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n        \n        float y = (iTime-0.0)*100.0;\n        float x = zigzag( y/100.0 )*40.0;\n   \n    \tray = rotatevecY( ray, x/80.0 );\n        origin.x += x;\n    \torigin = rotatevecY( origin, 0.0 );\n    \n\t\tfragColor = march( ray, origin, 0.01, uv );\n        \n        //float y = (iTime-0.0)*100.0;\n        //float x = zigzag( y/100.0 )*40.0;\n        \n        //vec2 vp = uv - vec2(0.5,0.5 );\n  \t\t//vec2 rp = vec2( -x + vp.x / -vp.y * 5.0,  5.0 / -vp.y \t);\n        \n\t\t//fragColor = road( rp);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SRf", "name": "Illusion.", "author": "IO", "description": "Hi there,\nstill on it with another shader.\nIt's feels good to finde a way to express my self and learn to focus my wild thoughts.\n\nDid you have any idea how i can get ride of this loop?\n\nSee ya in the next days.\n\nHave an inspiring day!\nIO_", "tags": ["2d", "sdf", "sin", "cos", "animation"], "likes": 6, "viewed": 200, "date": "1460496541", "time_retrieved": "2024-06-20T18:34:31.171652", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fColor = vec3(1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0 * uv - 1.;\n    uv.x *= iResolution.x/ iResolution.y;\n    \n    vec2 pos = vec2(.0);\n    \n    for(float i = 20.0; i > 0.; --i)\n    {\n        pos = vec2(sin(iTime+(20.0 - i)*0.4)*0.02, sin(iTime+(20.0 - i)*0.4)*0.02);\n    \tfloat dist = length( pos - uv) - 0.05 * i;\n    \tfloat o = 1. - smoothstep(0.0,5.0/iResolution.x, dist);\n\n        fColor = mix(fColor , vec3(1.)* (1. -mod(i,2.)),o);\n    }\n    \n\tfragColor = vec4(fColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SWj", "name": "AnyQuad_Cube", "author": "yafacex", "description": "learning field distance", "tags": ["learn"], "likes": 1, "viewed": 112, "date": "1461391816", "time_retrieved": "2024-06-20T18:34:31.917271", "image_code": "//You'd better use seperate member(p0,p1....) in stead of array(p[4]) for constructor convenience\nstruct quad\n{\n\tvec3 p0,p1,p2,p3;\t\n};\nstruct cube\n{\n\tquad q0,q1,q2,q3,q4,q5;\t\n};\ncube genCube(vec3 p0,float w,float h,float l){\n\tfloat w2 = w*.5,h2 = h*.5,l2 = l*.5;\n\tvec3 ftl = p0 - vec3(-w2,-h2,l2);\n\tvec3 ftr = p0 - vec3(w2,-h2,l2);\n\tvec3 fbl = p0 - vec3(-w2,h2,l2);\n\tvec3 fbr = p0 - vec3(w2,h2,l2);\n\tvec3 btl = p0 - vec3(-w2,-h2,-l2);\n\tvec3 btr = p0 - vec3(w2,-h2,-l2);\n\tvec3 bbl = p0 - vec3(-w2,h2,-l2);\n\tvec3 bbr = p0 - vec3(w2,h2,-l2);\n\treturn cube(\n\t\tquad(ftl,ftr,fbr,fbl),\n\t\tquad(ftr,btr,bbr,fbr),\n\t\tquad(btr,btl,bbl,bbr),\n\t\tquad(btl,ftl,fbl,bbl),\n\t\tquad(ftl,btl,btr,ftr),\n\t\tquad(fbl,bbl,bbr,fbr) );\n}\nquad rotateXq(quad q,float a){\n\tmat3 m = mat3(1,0,0,\n\t\t\t\t0,cos(a),sin(a),\n\t\t\t\t0,-sin(a),cos(a));\n\tq.p0*=m;\n\tq.p1*=m;\n\tq.p2*=m;\n\tq.p3*=m;\n\treturn q;\n}\nquad rotateYq(quad q,float a){\n\tmat3 m = mat3(cos(a),0,sin(a),\n\t\t\t\t0,1,0,\n\t\t\t\t-sin(a),0,cos(a));\n\tq.p0*=m;\n\tq.p1*=m;\n\tq.p2*=m;\n\tq.p3*=m;\n\treturn q;\n}\nquad rotateZq(quad q,float a){\n\tmat3 m = mat3(cos(a),sin(a),0,\n\t\t\t\t-sin(a),cos(a),0,\n\t\t\t\t0,0,1);\n\tq.p0*=m;\n\tq.p1*=m;\n\tq.p2*=m;\n\tq.p3*=m;\n\treturn q;\n}\ncube rotateXc(cube c,float a){\n\tc.q0 = rotateXq(c.q0,a);\n\tc.q1 = rotateXq(c.q1,a);\n\tc.q2 = rotateXq(c.q2,a);\n\tc.q3 = rotateXq(c.q3,a);\n\tc.q4 = rotateXq(c.q4,a);\n\tc.q5 = rotateXq(c.q5,a);\n\treturn c;\n}\ncube rotateYc(cube c,float a){\n\tc.q0 = rotateYq(c.q0,a);\n\tc.q1 = rotateYq(c.q1,a);\n\tc.q2 = rotateYq(c.q2,a);\n\tc.q3 = rotateYq(c.q3,a);\n\tc.q4 = rotateYq(c.q4,a);\n\tc.q5 = rotateYq(c.q5,a);\n\treturn c;\n}\ncube rotateZc(cube c,float a){\n\tc.q0 = rotateZq(c.q0,a);\n\tc.q1 = rotateZq(c.q1,a);\n\tc.q2 = rotateZq(c.q2,a);\n\tc.q3 = rotateZq(c.q3,a);\n\tc.q4 = rotateZq(c.q4,a);\n\tc.q5 = rotateZq(c.q5,a);\n\treturn c;\n}\nfloat dz(vec3 p0,vec3 p1){\n\treturn p0.x*p1.y - p0.y*p1.x;\n}\nfloat inTri0(vec3 p,vec3 p0,vec3 p1,vec3 p2){\n\tif(dz(p0-p,p-p1) * dz(p1-p,p-p2) > 0. && dz(p1-p,p-p2) * dz(p2-p,p-p0) > 0.)\n\t\treturn 1.;\n\telse\n\t\treturn -1.;\n}\n//why inTri1 and inTri2 are both OK??????why?why?why?\n//None of them can be smoothed!!!!!How to do it?????\nfloat inTri1(vec3 p,vec3 p0,vec3 p1,vec3 p2){\n\treturn min(cross(p0-p,p-p1).z * cross(p1-p,p-p2).z,cross(p1-p,p-p2).z * cross(p2-p,p-p0).z);\n}\n//inTri2 is wrong!!!\nfloat inTri2(vec3 p,vec3 p0,vec3 p1,vec3 p2){\n\treturn min(dot(cross(p0-p,p-p1) , cross(p1-p,p-p2)),dot(cross(p1-p,p-p2) , cross(p2-p,p-p0)));\n}\nfloat inTri3(vec3 p,vec3 p0,vec3 p1,vec3 p2){\n\treturn min(dz(p0-p,p-p1) * dz(p1-p,p-p2),dz(p1-p,p-p2) * dz(p2-p,p-p0));\n}\nfloat inTri(vec3 p,vec3 p0,vec3 p1,vec3 p2){\n\treturn inTri3(p,p0,p1,p2);\n}\nfloat inQuad(vec3 p,quad q){\n\treturn max(inTri(p,q.p0,q.p1,q.p2),inTri(p,q.p0,q.p2,q.p3));\n}\nfloat inCube(vec3 p,cube c){\n\tfloat r = inQuad(p,c.q0);\n\tr = max(r,inQuad(p,c.q1));\n\tr = max(r,inQuad(p,c.q2));\n\tr = max(r,inQuad(p,c.q3));\n\tr = max(r,inQuad(p,c.q4));\n\tr = max(r,inQuad(p,c.q5));\n\treturn r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy - vec2(0.5*iResolution.x/iResolution.y,0.5);\n\t\n\tcube c = genCube(vec3(0,0,0),0.2,0.2,0.2);\n\tcube c1 = genCube(vec3(0,-0.3,0),0.2,0.2,0.2);\n\tcube c2 = genCube(vec3(0,0.3,0),0.2,0.2,0.2);\n\n\tc = rotateXc(c,iTime);\n\tc = rotateYc(c,iTime);\n\tc = rotateZc(c,iTime);\n\n\tc1 = rotateXc(c1,iTime);\n\tc1 = rotateYc(c1,iTime);\n\tc1 = rotateZc(c1,iTime);\n\n\tc2 = rotateXc(c2,iTime);\n\tc2 = rotateYc(c2,iTime);\n\tc2 = rotateZc(c2,iTime);\n\tfloat d = inCube(vec3(uv,0),c);\n\tfloat d1 = inCube(vec3(uv,0),c1);\n\tfloat d2 = inCube(vec3(uv,0),c2);\n\td = max(max(d,d1),d2);\n\t// float d = inQuad(vec3(uv,0),q);\n\tif (d > 0.)\n\t{\n\t\t// d = smoothstep(-0.01,0.01,d - 0.01);\n\t\tfragColor = vec4(0,0,1,1);\n\t}else{\n\t\tfragColor = vec4(0,0,0,0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SWs", "name": "TheBadOmen", "author": "richm", "description": "theme is good versus evil", "tags": ["3d"], "likes": 17, "viewed": 757, "date": "1461985789", "time_retrieved": "2024-06-20T18:34:31.917271", "image_code": "/* richm may 2016 */\n\nmat2 rot(float t)\n{\n\treturn mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat pentagram(vec3 p)\n{\n    float d = 0.0;\n    float fp = 1.0;\n    mat2 rm = rot(6.283185 / 5.0 * 3.0);\n    vec2 pa = vec2(1.0, 0.0);\n    vec2 pb = pa * rm * rm;\n    for (int i = 0; i < 5; ++i) {\n        vec2 del = normalize(pa - pb);\n        mat2 xfm = mat2(del.x, del.y, -del.y, del.x);\n        vec2 q = p.xz * xfm;\n        float r = max(abs(q.x - 0.75) - 0.0125, abs(q.y) - 2.0);\n        d = min(d, r);\n        d = mix(d, r, fp);\n        pa *= rm;\n        pb *= rm;\n        fp = 0.0;\n    }\n    float c = length(p.xz);\n    c = max(c - 2.25, 2.2 - c);\n    d = min(d, c);\n    return d;\n}\n\nfloat mapmat = 0.0;\nfloat mapdel = 0.0;\nvec2 maptex = vec2(0.0);\n\nfloat map(vec3 p)\n{\n    mapmat = 0.0;\n    mapdel = 0.0;\n    \n\tfloat d = 2.0 + p.y;\n    float pen = pentagram(p);\n    mapdel = abs(d - pen);\n    if (pen < d) {\n        d = max(pen, d);\n        mapmat = 1.0;\n    }\n    \n    float room = -sdBox(p, vec3(6.0, 8.0, 6.0));\n    if (room < d) {\n        d = min(d, room);\n        mapmat = 2.0;\n    }\n    \n    vec3 q = p;\n    q.xz = abs(q.xz);\n    q.xz = q.xz - vec2(3.0, 4.0);\n    q.xz *= rot(3.14159 * 0.25);\n    float mbox = sdBox(q, vec3(0.1, 3.0, 2.0));\n    if (mbox < d) {\n        d = mbox;\n        mapmat = 3.0;\n        maptex = 1.0 - q.zy * 2.0;\n    }\n    \n    vec3 wp = p - vec3(-5.0, 2.0, 0.0);\n    float wbox = sdBox(wp, vec3(5.25, 1.5, 0.2));\n    if (-wbox > d) {\n        d = max(d, -wbox);\n        mapmat = -1.0;\n    }\n    \n    wp = p - vec3(-5.0, 2.6, 0.0);\n    wbox = sdBox(wp, vec3(5.25, 0.2, 1.0));\n    if (-wbox > d) {\n        d = max(d, -wbox);\n        mapmat = -1.0;\n    }\n    \n    wp = p - vec3(4.0, -2.0, 0.0);\n    wbox = sdBox(wp, vec3(0.05, 1.0, 0.05));\n    if (wbox < d) {\n        d = min(d, wbox);\n        mapmat = -2.0;\n    }\n    \n    wp = p - vec3(4.0, -1.3, 0.0);\n    wbox = sdBox(wp, vec3(0.05, 0.05, 0.25));\n    if (wbox < d) {\n        d = min(d, wbox);\n        mapmat = -2.0;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.00001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nvec3 blood(vec3 p, vec3 r, float mat, float del)\n{\n    vec3 tex = texture(iChannel0, p.xz * 0.25).xyz;\n    float spt = tex.x;\n    spt = spt * 2.0 - 1.0;\n    spt = sin(spt * 3.14159 * 5.0);\n    tex *= tex;\n    \n    vec3 from = vec3(0.8, 0.2, 0.1);\n    vec3 to = vec3(1.0, 1.0, 1.0);\n\n    float mdp = 1.0 - pow(1.0 - min(del,0.5), 8.0);\n    mdp = mix(mdp, 0.0, mat);\n    float prod = max(-r.y, 0.0);\n    float bld = 1.0 - 1.0 / (1.1 + mdp + spt);\n    bld = mix(1.0, bld, 1.0-mdp);\n    tex = vec3(pow(1.0 - tex.x, 1.0));\n    return tex * mix(from, vec3(1.0), bld);\n}\n\nvec3 texture_(vec3 p)\n{\n\tvec3 ta = texture(iChannel0, p.yz).yyy;\n\tvec3 tb = texture(iChannel0, p.xz).yyy;\n\tvec3 tc = texture(iChannel0, p.xy).yyy;\n    return (ta*ta + tb*tb + tc*tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.33));\n    r.yz *= rot(-1.57 * 0.05);\n    r.xz *= rot(iTime * 0.5);\n    vec3 o = vec3(0.0, 0.0, -3.0);\n    o.xz *= rot(iTime * 0.5);\n    \n    vec3 fc = vec3(1.0);\n    float ft = 0.0;\n    \n    vec3 lpos = vec3(-2.0, 1.5, 0.0);\n    \n    for (int i = 0; i < 8; ++i) {\n    \n        float t = trace(o, r);\n        ft += t;\n        vec3 w = o + r * t;\n        vec3 sn = normal(w);\n        float fog = 1.0 / (1.0 + ft * ft * 0.05);\n        \n        vec3 ldel = w + sn * 0.01 - lpos;\n        float ldist = length(ldel);\n        ldel /= ldist;\n        vec3 lit = vec3(1.0) / (1.0 + ldist * ldist * 0.01);\n        \n        if (mapmat < 3.0) {\n            float premat = mapmat;\n            float predel = mapdel;\n            float lt = trace(lpos, ldel);\n            float lm = max(sign(lt - ldist), 0.0);\n            lit *= lm * max(dot(sn, -ldel), 0.0);\n            lit *= fog;\n            if (premat < 2.0) {\n                if (premat == -1.0) {\n                    fc *= vec3(1.0);\n                } else if (premat == -2.0) {\n                    fc *= texture_(w * 0.125) * lit * 4.0;\n                } else {\n                \tfc *= blood(w, r, premat, predel) * lit;\n                }\n            } else {\n                fc *= texture_(w * 0.125) * lit;\n            }\n            break;\n        }\n\n        vec3 dirt = texture(iChannel0, maptex * 0.125).xyz;\n        float fres = abs(dot(r, -sn));\n        float fade = 1.0 - float(i) / 7.0;\n        fc = mix(fc, vec3(dirt), fres) * lit * fade;\n        \n        o = w + sn * 0.01;\n        r = reflect(r, sn);\n    }\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "lsf3zs", "previewfilepath": "https://soundcloud.com/gurkanizmirligil/your-bedtime-story-is-scaring", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/gurkanizmirligil/your-bedtime-story-is-scaring", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3XD2", "name": "This Is Not A Pipe", "author": "dr2", "description": "  This is clearly not Magritte's masterpiece. But is the 3D form less\n  'not a pipe' than the original?\n", "tags": ["raymarching", "smoker", "pipe"], "likes": 12, "viewed": 760, "date": "1461446122", "time_retrieved": "2024-06-20T18:34:31.933388", "image_code": "// \"This Is Not A Pipe\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat PrCapsShDf (vec3 p, float r, float w, float h)\n{\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  return abs (length (p) - r) - w;\n}\n\nvec3 ltDir;\nfloat dstFar, tCur;\nint idObj;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 rp;\n  float dMin, d;\n  dMin = dstFar;\n  p.x += 1.;\n  q = p;\n  d = SmoothMax (PrCapsShDf (q.xzy, 0.5, 0.09, 0.3), -0.5 + q.y, 0.05);\n  q.y -= smoothstep (0.5, 2.5, q.x) - 0.5;\n  q.x -= 1.3;\n  rp = vec2 (0.1, 0.17) - vec2 (0.05, 0.06) * (q.x / 0.6 - 1.);\n  d = 0.5 * SmoothMin (d, max (SmoothMin (PrEllCylDf (q.yzx, rp, 1.2),\n     PrEllCylDf (q.yzx - vec3 (0., 0., 1.2), rp + 0.007, 0.007), 0.05),\n     0.03 - length (q.yz * vec2 (1.1, 0.35))), 0.12);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = p;\n  q.y -= 0.3 + 0.03 * Fbm2 (40. * q.xz);\n  d = 0.5 * PrCylDf (q.xzy, 0.5, 0.01);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 vn;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  int idObjT;\n  idObjT = idObj;\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  vn = normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n  idObj = idObjT;\n  return vn;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.07 * d, h));\n    d += max (0.04, 0.08 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, q;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      q = ro;\n      q.xy -= vec2 (0.4);\n      q.xy = Rot2D (q.xy, -0.2 * pi);\n      if (q.x < -0.03) vn = VaryNf (10. * q, vn, 0.1);\n      col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.),\n         0.5 * Fbm3 (2. * ro)) : vec3 (0.1), vec3 (0.7, 0.6, 0.),\n         SmoothBump (-0.03, 0.03, 0.01, q.x));\n      sh = ObjSShadow (ro, ltDir);\n      col = col * (0.2 + sh * (0.1 * max (vn.y, 0.) +\n         0.8 * max (dot (vn, ltDir), 0.))) +\n         0.5 * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 8.);\n    } else if (idObj == 2) {\n      col = mix (vec3 (0.7, 0., 0.) * smoothstep (0.1, 1.5, Fbm1 (0.5 * tCur)),\n         vec3 (0.1, 0.01, 0.01), clamp (Fbm2 (30. * ro.xz) - 0.3, 0., 1.));\n    }\n  } else col = vec3 (0.9, 0.8, 0.6);\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 25.;\n  zmFac = 12.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 2. * pi * mPtr.y;\n  } else {\n    az = 2. * pi * sin (0.05 * tCur);\n    el = -0.3 * pi * cos (0.2 * tCur);\n  }\n  el = clamp (el, - 0.5 * pi, 0.5 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 0., -15.);\n  ltDir = vuMat * normalize (vec3 (-1., 0.5, -0.5));\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4v3 (ip);\n  t2 = Hashv4v3 (ip + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3a (p);\n    a *= 0.5;\n    p *= 4. * mr;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3XD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3XDs", "name": "yummi cloud", "author": "tomaes", "description": "...", "tags": ["blur", "plasma", "slow"], "likes": 4, "viewed": 101, "date": "1462046084", "time_retrieved": "2024-06-20T18:34:31.933388", "image_code": "float render(vec2 _uv, float _t)\n{\n   return (sin( (sin(_uv.x*10.+_t)  *\n                 cos(_uv.y*50.+_t)) * \n                 (_uv.x*_uv.y) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y * 1.25;\n    float t = (iTime+1.8) * 10.5;  \n\n    float b = .5+sin( sqrt(uv.x*5.+uv.x*5.)+t*.1)*.005;\n        \n    float c = b*render(vec2(uv.x+sin((t*.2*b)*.5),uv.y*b), 30.*sin(1./uv.y)*0.03) \n        \t+ b*render(vec2(uv.y+sin((t*.2*b)*.5),uv.y*b), 10.*sin(1./uv.y)*0.02);\n\n    if (c < sin(uv.x*5.+t*.1)) c *= (1.-c);\n    \n\tfragColor  = vec4(c*1.25+uv.y*0.2,c*1.25,c,1.0);\n    fragColor += vec4(vec3(length(uv.y*.22-c)),1.0) / .5*tan(5.*sin(1.4*sin(uv.x*5.+t*.05)*.04*sin(uv.y+mod(uv.y+t*.02,.1)*10.5 ))*3.5   );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3XDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3XRB", "name": "Fractal Experiment 18 : Lattice", "author": "aiekick", "description": "Fractal Experiment 18 : Lattice", "tags": ["fractal", "experiment", "lattice", "18"], "likes": 12, "viewed": 710, "date": "1459878301", "time_retrieved": "2024-06-20T18:34:32.850627", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on https://www.shadertoy.com/view/4stXR7\n*/\n\nconst vec3 ld = vec3(0.,1., .5);\nfloat dstepf = 1.0;\nfloat t = 0.;\n\nvec2 path(float z){return sin(z*.2 + vec2(1.6,0));}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat fractus(vec3 p)\n{\n\tvec2 z = p.xy;\n    vec2 c = vec2(-1.04,-0.36) * vec2(cos(p.z), sin(p.z));\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<6.;i++)\n    {\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n\t\tif (k > 4.) break;\n        z = vec2(z.x * z.x - z.y * z.y, 2.* z.x * z.y) + c;\n    }\n\treturn  sqrt(k/h)*log(k);   \n}\n\nfloat df(vec3 p)\n{\n\tvec3 tutu;\n\t\n   \tvec3 pz = p;\n    pz.z += 0.;\n    pz.xy = mod(pz.xy, 8.) - 8.*0.5;\n\tpz *= getRotZMat(sin(pz.z*0.));\n\ttutu.x = min(1.,fractus(pz.xyz));\n\n\tvec3 py = p;\n\tpy.y += 0.;\n    py.xz = mod(py.xz, 8.) - 8.*0.5;\n\tpy *= getRotYMat(sin(py.y*0.));\n\ttutu.y = min(1.,fractus(py.xzy));\n\t\n\tvec3 px = p;\n    px.x += 0.;\n\tpx.z += -0.5;\n    px.yz = mod(px.yz, 8.) - 8.*0.5;\n\tpx *= getRotXMat(sin(px.x*0.));\n\ttutu.z = min(1.,fractus(px.yzx));\n\n\tfloat k = tutu.x*tutu.y*tutu.z;\n\treturn k;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy) - df(p-e.xyy),\n\t\tdf(p+e.yxy) - df(p-e.yxy),\n\t\tdf(p+e.yyx) - df(p-e.yyx) );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = df( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float d = max(length(l), 0.01);\n    float atten = 1.0-exp( -0.01*d*d );\n    l /= d;\n    \n    vec3 n = nor(p, prec);\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    dif *= softshadow(p, rd, 0.1, 1.);\n    \n    vec3 lin = vec3(0.08,0.32,0.47);\n    lin += 1.0*dif*vec3(1,1,0.84);\n    lin += 2.5*spe*dif*vec3(1,1,0.84);\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin * atten * calcAO(p, n);\n}\n\n\nfloat trace( in vec3 ro, in vec3 rd)\n{\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = ro;\n\t\n\tfor (float i=0.; i<150.; i++)\n\t{\n\t\tif (s < 0.025*log(d*d/s/500.) || d>40.) break; // last change was d*d\n\t\ts = df(p);\n\t\td += s * 0.2;\n\t\tp = ro + rd * d;\t\n\t\tdstepf += 0.005;\n\t}\n\t\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*fragCoord-si)/min(si.x, si.y);\n\n\tt = iTime * 0.1;\n\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(cos(t),cos(t)*sin(t),sin(t));\n\tro.xz *= 10.5;\n    ro.y *= 9.;\n\tt+= .1;\n    vec3 co = ro + vec3(sin(t), cos(t),cos(t));\n\t\n\tfloat fov = 0.8;\n\tvec3 axisZ = normalize(co - ro);\n\tvec3 axisX = normalize(cross(cu, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rd = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat d = trace(ro, rd);\n\tvec3 p = ro + rd * d;\t\n\t\n    float fogd = 0.01;\n    if (iMouse.z>0.)\n        fogd = 0.001;\n    \n\tfragColor.rgb = vec3(0.47,0.6,0.76) * lighting(p, ro, rd, 0.0001); \n\tfragColor.rgb = mix( fragColor.rgb, vec3(0.5,0.49,0.72), 1.0-exp( -fogd*d*d ) ); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3XRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scSWM", "name": "Marching spaceslime", "author": "Fluffy", "description": "Raymarching arbitrary geometry with reflections, and background.", "tags": ["raymarching"], "likes": 2, "viewed": 230, "date": "1459521955", "time_retrieved": "2024-06-20T18:34:32.850627", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n////////////////////////////////////////////////////////////////////////\n\n\n#define PI 3.14159265359\nconst vec3 sunDir = normalize(vec3(1.0, 1.0, 0.5));\n\n/*float terrainFunction(float x, float z)\n{\n    return sin(x) * sin(z) * 1.0;\n}*/\n\n/*vec3 normalAt(float x, float y)\n{\n    float epsilon = 0.01;\n    \n    float s = terrainFunction(x, y);\n    float dx = s - terrainFunction(x + epsilon, y);\n    float dy = s - terrainFunction(x, y + epsilon);\n    return normalize(vec3(dx, epsilon, dy));\n    \n}*/\n\nfloat terrainFunction(vec3 posIn)\n{\n    vec3 pos = vec3(posIn.x - 1.5, posIn.y, posIn.z - 1.0);\n    float scale = 1.0;\n    float time = iTime * 1.0;\n    return sin(pos.x)+sin(pos.y + time)+sin(pos.z)\n        -sin(pos.x)*sin(pos.y + time)*sin(pos.z)\n        -cos(time) * sin(pos.y) + cos(pos.x) * sin(pos.z) + sin(pos.y) * cos(pos.z);\n    //return snoise(vec3(pos.x * scale, pos.y * scale + time + (sin(time / 4.0) * 4.0 + 1.0), pos.z * scale));\n}\n\n/*\nvec3 normalAt(vec3 pos)\n{\n    float epsilon = 0.01;\n    \n    float s = terrainFunction(pos);\n    float dx = s - terrainFunction(vec3(pos.x + epsilon, pos.y, pos.z));\n    float dy = s - terrainFunction(vec3(pos.x, pos.y + epsilon, pos.z));\n    float dz = s - terrainFunction(vec3(pos.x, pos.y, pos.z + epsilon));\n                                   \n    return normalize(vec3(dx, dy, dz));\n}\n/*/\nvec3 normalAt(vec3 p)\n{\n    vec2 e = vec2(0.01, -0.01); \n    return normalize(\n        e.xyy * terrainFunction(p - e.xyy) + \n        e.yyx * terrainFunction(p - e.yyx) + \n        e.yxy * terrainFunction(p - e.yxy) + \n        e.xxx * terrainFunction(p - e.xxx) );\n}\n//*/\nfloat march(vec3 offset, vec3 dir)\n{\n    const float minDist = 2.0;\n    const float maxDist = 20.0;\n    const float delta = 0.1;\n\tfloat amp = sin(iTime / 10.0) + 1.5;\n    \n    float lastTer = 0.0;\n    float closest = 0.0;\n    \n    float d = minDist;\n    \n    for (float t = 0.0; t < 256.0; t++)\n    {\n        //float d = pow(t - minDist, 1.0) + minDist;\n        if (d > maxDist)\n            break;\n        vec3 pos = offset + dir * d;\n        //float ter = terrainFunction(pos.x, pos.z);\n        float ter = terrainFunction(pos);\n        \n        if (ter >= amp)\n        {\n            //return d - delta * 0.5;\n            return d - delta + delta * ((amp -lastTer) / (ter - lastTer));\n        }\n        \n        lastTer = ter;\n        \n        if (ter > closest)\n            closest = ter;\n        \n        d += delta;// * t / 30.0;\n    }\n    \n    return closest - amp;\n}\n\nvec3 rotX(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cy = c * vec.y;\n    float sy = s * vec.y;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(vec.x, cy - sz, sy + cz));\n}\n\nvec3 rotY(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cx = c * vec.x;\n    float sx = s * vec.x;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(cx - sz, vec.y, sx + cz));\n}\n\nvec4 background(vec3 dir)\n{\n    float sunDot = clamp(dot(dir, sunDir), 0.0, 1.0);\n    vec3 col = vec3(0.0, 0.4, 0.6) * sunDot;\n    \n    float mul = 200.0;\n    vec3 n = dir * mul;\n    \n    float s = pow(abs(snoise(n)), 10.0);\n    \n    if (sunDot > 0.0)\n    \ts *= 1.0 - pow(sunDot, 2.0);\n    col += vec3(s);\n    \n    if (sunDot > 0.0)\n    {\n        sunDot = pow(sunDot * 1.03, 128.0);\n        vec3 sun = vec3(1.0, 1.0, 0.2) * sunDot;\n        col += sun;\n    }\n    \n    return vec4(col, 1.0);\n}\n\nvec3 shade(vec3 position, vec3 rayDir)\n{\n    vec3 col = vec3(0.6, 0.8, 1.0);\n    \n    float mul = 1.0;\n    \n    for (int i = 0; i < 3; i++)\n    {\n    \tvec3 normal = normalAt(position);\n        col = col * (1.0 - mul) + mul * clamp(dot(normal, sunDir), 0.0, 1.0) * col;\n        \n        float dist = march(position, sunDir);\n        if (dist >= 0.0)\n            col *= 0.8;\n        else\n            col *= clamp(pow(-dist * 10.0, 0.8), 0.8, 1.0);\n        \n        rayDir = reflect(rayDir, normal);\n        \n        dist = march(position, rayDir);\n        if (dist >= 0.0)\n            position = (position + rayDir * dist);\n        else\n        {\n            col = col + col * clamp(background(rayDir).xyz, 0.0, 0.5) * 1.5;\n            break;\n        }\n        \n        mul *= 0.8;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 15.0, 0);\n    float focalLength = 2.0;\n    float x = fragCoord.x / iResolution.x - 0.5;\n    float y = (fragCoord.y / iResolution.y - 0.5) * (iResolution.y / iResolution.x);\n    \n    vec3 rayDir = normalize(vec3(x * focalLength, -1, y * focalLength));\n    rayDir = rotX(rayDir, -iMouse.y / 100.0);\n    rayDir = rotY(rayDir, -iMouse.x / 100.0);\n    \n    float dist = march(cameraPos, rayDir);\n    if (dist < 0.0)\n    {\n        fragColor = background(rayDir);\n        return;\n    }\n    \n    vec3 pos = (cameraPos + rayDir * dist);\n    \n\tvec3 color = shade(pos, rayDir) / sqrt(dist / 10.0) * 1.5;\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scXRB", "name": "Balls of Meta", "author": "IO", "description": "Last nights meta balls.\n\ni know the code is still shitty, but it's going on. \nIf you have any advise or comment feel free to share it.\n\nHave a inspiring day.\nIO_", "tags": ["2d", "sdf", "blackwhite", "metabals"], "likes": 11, "viewed": 320, "date": "1459882861", "time_retrieved": "2024-06-20T18:34:33.147656", "image_code": "// Thanks to hughsk for the smin function \n// and the Inspiration.\n// https://www.shadertoy.com/view/XsyGRW\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 fColor = vec3(0.0);\n   \n    uv = 2.0 * uv - 1.0; // moves uv to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; // Fix aspect ratio. Extend uv.x to [-1*aspectRatio,1*aspecRatio]\n   \n    float aaFactor = 0.01; // Antialising Factor for smoothstep\n      \n   \t//Sphere Positions\n    vec2 oPos00 = vec2(sin(iTime*0.2+0.07),sin(iTime*0.8-0.07)*0.2);\n    vec2 oPos01 = vec2(cos(iTime*0.8-0.07),cos(iTime*0.8-0.07)*0.1);\n    vec2 oPos10 = vec2(cos(iTime*0.2),0.0);\n    vec2 oPos11 = vec2(sin(iTime*0.8),0.05);\n    \n    //Scene Buildup\n    float mat0 = length(oPos00 - uv) - 0.2;\t\t\t  // Distance field of a sphere\n    mat0 = smin(mat0,length(oPos01 - uv) - 0.35,0.3); // smin for merching the objects in the Scene \n    mat0 = smin(mat0,length(oPos10 - uv) - 0.2,0.3);  // 0.3 factor for archiving \n    mat0 = smin(mat0,length(oPos11 - uv) - 0.25,0.3); // noticable lerping between objects\n\n    // object/scene Mask for coloring\n    float object0 = 1.0 - smoothstep(0.0,aaFactor, mat0);\n\tfloat scene = 1.0 - object0;\n    \n    //Coloring\n    vec3 sceneColor = vec3(1.0,1.0,1.0);\n    vec3 objectColor0 = vec3(0.0,0.0,0.0);\n\n    //Uncomment it for eye cancer color\n    //sceneColor = vec3(1.0,0.0,0.65);\n    //objectColor0 = vec3(0.0,1.0,1.0);\n    \n    //Mix objectcolor with scenebackgroundcolor\n    fColor = vec3(mix(objectColor0,sceneColor,scene));\n\n\tfragColor = vec4(fColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scXz2", "name": "Cellular Tiling", "author": "Shane", "description": "Creating a Voronoi feel with minimal instructions by way of a tileable cellular texture.", "tags": ["2d", "voronoi", "cellular", "cell", "tile", "bio"], "likes": 21, "viewed": 1827, "date": "1460343804", "time_retrieved": "2024-06-20T18:34:34.765977", "image_code": "/*\n\n\tCellular Tiling\n\t---------------\n\n    Creating a Voronoi feel with minimal instructions by way of a tileable texture constructed \n\tvia a simplistic cellular pattern algorithm... That description was a bit verbose, but the \n\tmethod is really easy to understand. This is the 2D version, but I have a simple 3D example \n\tthat I'll put up pretty soon.\n\n\tThere's an old texture generation routine that involves drawing a bunch of random gradient \n\tcircles (or other shapes) onto a texture using the darken (min(src, dst)) blend. The result \n\tis a cellular looking texture reminiscent of Voronoi, which is hardly surprising, given the\n\tsimilar methods of construction.\n\n\tBy applying various colors, shapes and sizes, you can make some really cool looking images, \n\tbut it's not particularly suitable for realtime generative purposes, due to the fact that \n\tyou need to draw a lot of shapes (normally circles) to cover the area, etc.\n\n\tAnyway, I figured I could cheapen the process by doing it in repeatable tile form, since a\n\tsmaller area requires fewer circles for coverage, etc. I had the idea after working with \n\tTruchet tiles. It worked pretty well, so then I got to wondering how few operations I could \n\tget away with without it looking too repetitive. As it turns out, very few. In fact, it can \n\tbe a particularly cheap process.\n\n\tNaturally, there are a few restrictions. The obvious one is that small repeatable tiles look \n\tvery repetitive when you zoom out, so that has to be considered. The upside was the entire\n    point of doing this, which is that it requires virtually no extra effort to produce 3D tiles. \n\tThat means quasi 3D celluar surfaces that are fast enough to include in a distance \n\tfunction... under certain restrictions, of course.\n\n\tThe code in this particular example comprises mostly bumping and lighting, which I added out \n\tof sheer boredom, so you'll probably only want to look it if you're equally bored. :) The \n\t\"cellTex\" routine and the accompanying \"drawShape\" function are all that are required, for \n\tanyone interested. Both\tcontain just a few self explanatory lines.\n    \n    \n    \n    Related Examples:\n    \n    \n    // A 3D application.\n    3D Cellular Tiling - Shane\n    https://www.shadertoy.com/view/ld3Szs\n    \n    // Taking minimal instructions to the extreme. :)\n    One Tweet Cellular Pattern - Shane\n    https://www.shadertoy.com/view/MdKXDD\n\n*/\n\n// Layer rotation: For the cost of an extra 2x2 matrix by vec2 multiply, you can drastically \n// increase the randomness. I came up with this when experimenting. The idea can be extended\n// to the 3D version as well.\n#define LAYER_ROTATION\n\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(1, 113, 57);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (eight circles, in this case) using \n// the darken (min(src, dst)) blend at various locations on a tile. Make the tile wrappable by \n// ensuring the shapes wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four circles. Of course, there is 4-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's lower overall. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// However, the main reason you'd bother in the first place is the ability to extrapolate\n// to a 3D setting (swap circles for spheres) for virtually no extra cost. The result isn't\n// perfect, but 3D cellular tiles can enable you to put a Voronoi looking surface layer on a \n// lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawShape(in vec2 p){\n    \n    // Wrappable circle distance. The squared distance, to be more precise.\n    p = fract(p) - .5;    \n    return dot(p, p);\n    \n    // Other distance metrics.\n    \n    //p = abs(fract(p) - .5);\n    //p = pow(p, vec2(8));\n    //return pow(p.x+p.y, .125)*.25;\n    \n    //p = abs(fract(p) - .5);\n    //p *= p;\n    //return max(p.x, p.y);\n    \n    //p = fract(p) - .5;\n    //float n = max(abs(p.x)*.866 + p.y*.5, -p.y);\n    //return n*n;\n    \n}\n\n// Draw some cirlcles on a repeatable tile. The offsets were partly based on science, but\n// for the most part, you could choose any combinations you want.\n//\nfloat cellTex(in vec2 p){   \n    \n \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. Layer rotation \n    // drastically improves randomness, for very little extra cost.\n    p = mat2(.5, -.866, .866, .5)*(p - .5); // \n    #endif\n    \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    \n    \n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n\n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. \n    p = mat2(.5, -.866, .866, .5)*(p - .5);\n    #endif\n    \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);\n    \n}\n///////////\n\n// Colored cellular texture.\n//\nvec3 tex2D(vec2 p){\n    \n    float c = cellTex(p*2.)*.95 + .05;\n\tvec3 col = vec3(c*c*.7, c, c*c*.2) + (cellTex(p*6.))*.05 - .025; // Bio green.\n    //vec3 col = vec3(c*c, c*sqrt(c), c) + (cellTex(p*3.))*.05 - .025; // Blueish.\n    col = clamp(col, 0., 1.);\n    // Sinusoidally mixing in a complimentary color, of sorts, for a bit of variance.\n    return mix(col, col.yzx, dot(sin(p*12. - sin(p.yx*12. + c*6.283)), vec2(.5))*.15 + .2);\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, we're returning \n// some combined cellular texture values that coincide with the texture value above.\n//\nfloat bumpFunc(vec2 p){ \n\n    \n\treturn cellTex(p*2.)*.95 + (cellTex(p*6.))*.05; // Range: [0, 1]\n\t\n    // Grayscale version of the colored function.\n\t//return dot(tex2D(p), vec3(.299, .587, .114)); // Range: [0, 1]\n\n\n}\n\n// Standard bump function.\n//\nvec3 bump(vec3 sp, vec3 sn, float bumpFactor){\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n   \n \t\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor ); \n    \n    return sn;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;  \n    \n    // uv *= iResolution.y/450.; // Maintaining cellular size.\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane. \n    vec3 ro = vec3(vec2(iTime*.35, sin(iTime*.05)*2.), -1);\n    vec3 sp = vec3(uv + ro.xy, 0.); // Surface posion. Hit point, if you prefer.\n    vec3 rd = normalize(sp - ro); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = ro + vec3(cos(iTime)*.66, sin(iTime)*.33, -1); // Light position - Back from the screen.\n\tvec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n     \n  \n    // Bump mapping. Perturbing the normal.\n    sn = bump(sp, sn, .05);\n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = min(1./(.75 + lDist*0.15 + lDist*lDist*0.05), 1.);\n\t//float atten = min(1./(lDist*lDist*1.), 1.);\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    //diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 64.);\n    //float fre = clamp(dot(sn, rd) + 1., .0, 1.); // Fake fresnel, for the glow.\n\n    \n\t\n    // TEXTURE COLOR\n    //\n\t// Using the position to index into the texture.\n    vec3 texCol = tex2D(sp.xy);\n    \n    \n    \n    // Applying some unrealistic refraction.\n    vec3 ref = sp + refract(rd, sn, 1./1.425)*.15;\n    float b = bumpFunc(ref.xy);\n    ref = vec3(.5, .05, .1)*b;\n    \n    // Equally unrealistic, cloudy reflection. Just for fun. Not important.\n    vec3 rfl = sp + reflect(rd, sn)*2.;\n    b = noise3D(rfl)*.66 + noise3D(rfl*2.)*.34;\n    b = smoothstep(.3, 1., b);\n    ref += mix(vec3(.125, .2, .25), vec3(1, .8, 1), b*b)*.25;\n    ref *= ref;\n\n\n\n\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = texCol*(diff + .5) + ref +  texCol.zxy*spec*.5;// + vec3(.5, .8, 1)*fre*fre*2.;\n    col *= atten;\n    \n    \n    // Apply a vignette. The point light already does this, but this sets off the\n    // edges a little more.\n    //uv = fragCoord/iResolution.xy; \n    //col *= pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125/2.);\n\n    // Done. \n\tfragColor = vec4(sqrt(max(col, 0.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdXDX", "name": "Smooth Voronoi Contours", "author": "Shane", "description": "A method to produce smooth, precise contour lines... but it's really just an excuse to make a colorful, moving abstract picture. :)", "tags": ["voronoi", "abstract", "smooth", "contour"], "likes": 115, "viewed": 6126, "date": "1461942126", "time_retrieved": "2024-06-20T18:34:35.796350", "image_code": "/*\n\n\tSmooth Voronoi Contours\n\t-----------------------\n\n\tUsing a numerical gradient to produce smooth \"fract\" contours on 2D Voronoi.\n\n\tShadertoy user \"drone1\" was kind enough to help me problem shoot some AA code\n\tyesterday on an image similar to this one, but I wanted to produce it without\n\tAA for realtime usage. There might be better methods, but this is the one I\n\tchose. It's partly based off of IQ's \"Ellipse - Distance Estimation\" example.\n\n\tIf you press pause, you should notice that the contour lines are smooth and \n\tprecise, regardless of the shape of the curve.\n\t\n\tFor anyone wondering, the weird abstract image is just an amalgamation of two \n\tlayers of smooth 2D Voronoi and an old concentric circle trick. In pseudo code:\n\n\tfloat val = Vor(p*freq)*A1 + Vor(p*freq*3.)*A2;\n\tval = clamp(cos(val*freq2*PI)*contrast, 0., 1.);\n\n    See IQ's distance estimation example for a good explanation regarding the \n\tgradient related contour snippet:\n\n    Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    There's an accompanying articles, which is really insightful here:\n    http://www.iquilezles.org/www/articles/distance/distance.htm\n\n\tAnother example using the technique.\n\t2D Noise Contours - Shane\n\thttps://www.shadertoy.com/view/XdcGzB\n\n*/\n\n// Glossy version. It's there to show that the method works with raised surfaces too.\n//#define GLOSSY\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(2097152, 262144)*n);\n    return cos(p*6.283 + iTime)*.5;\n    //return abs(fract(p+ iTime*.25)-.5)*2. - .5; // Snooker.\n    //return abs(cos(p*6.283 + iTime))*.5; // Bounce.\n\n}\n\n// Smooth Voronoi. I'm not sure who came up with the original, but I think IQ\n// was behind this particular algorithm. It's just like the regular Voronoi\n// algorithm, but instead of determining the minimum distance, you accumulate\n// values - analogous to adding metaball field values. The result is a nice\n// smooth pattern. The \"falloff\" variable is a smoothing factor of sorts.\n//\nfloat smoothVoronoi(vec2 p, float falloff) {\n\n    vec2 ip = floor(p); p -= ip;\n\t\n\tfloat d = 1., res = 0.0;\n\t\n\tfor(int i = -1; i <= 2; i++) {\n\t\tfor(int j = -1; j <= 2; j++) {\n            \n\t\t\tvec2 b = vec2(i, j);\n            \n\t\t\tvec2 v = b - p + hash22(ip + b);\n            \n\t\t\td = max(dot(v,v), 1e-4);\n\t\t\t\n\t\t\tres += 1.0/pow( d, falloff );\n\t\t}\n\t}\n\n\treturn pow( 1./res, .5/falloff );\n}\n\n// 2D function we'll be producing the contours for. \nfloat func2D(vec2 p){\n\n    \n    float d = smoothVoronoi(p*2., 4.)*.66 + smoothVoronoi(p*6., 4.)*.34;\n    \n    return sqrt(d);\n    \n}\n\n// Smooth fract function. A bit hacky, but it works. Handy for all kinds of things.\n// The final value controls the smoothing, so to speak. Common sense dictates that \n// tighter curves, require more blur, and straighter curves require less. The way \n// you do that is by passing in the function's curve-related value, which in this case\n// will be the function value divided by the length of the function's gradient.\n//\n// IQ's distance estimation example will give you more details:\n// Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n// There's an accompanying article, which is really insightful, here:\n// http://www.iquilezles.org/www/articles/distance/distance.htm\nfloat smoothFract(float x, float sf){\n \n    x = fract(x); return min(x, x*(1.-x)*sf);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n\n    // Standard epsilon, used to determine the numerical gradient. \n    vec2 e = vec2(0.001, 0); \n\n    // The 2D function value. In this case, it's a couple of layers of 2D simplex-like noise.\n    // In theory, any function should work.\n    float f = func2D(uv); // Range [0, 1]\n    \n    // Length of the numerical gradient of the function above. Pretty standard. Requires two extra function\n    // calls, which isn't too bad.\n    float g = length( vec2(f - func2D(uv-e.xy), f - func2D(uv-e.yx)) )/(e.x);\n   \n    // Dividing a constant by the length of its gradient. Not quite the same, but related to IQ's \n    // distance estimation example: Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    g = 1./max(g, 0.001);\n    \n    // This is the crux of the shader. Taking a function value and producing some contours. In this case,\n    // there are twelve. If you don't care about aliasing, it's as simple as: c = fract(f*12.);\n    // If you do, and who wouldn't, you can use the following method. For a quick explanation, refer to the \n    // \"smoothFract\" function or look up a concetric circle (bullseye) function.\n    //\n    // For a very good explanation, see IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    //\n    // There's an accompanying articles, which is really insightful, here:\n\t// http://www.iquilezles.org/www/articles/distance/distance.htm\n    //\n    float freq = 12.; \n    // Smoothing factor. Hand picked. Ties in with the frequency above. Higher frequencies\n    // require a lower value, and vice versa.\n    float smoothFactor = iResolution.y*0.0125; \n    \n    #ifdef GLOSSY\n    float c = smoothFract(f*freq, g*iResolution.y/16.); // Range [0, 1]\n    //float c = fract(f*freq); // Aliased version, for comparison.\n    #else\n    float c = clamp(cos(f*freq*3.14159*2.)*g*smoothFactor, 0., 1.); // Range [0, 1]\n    //float c = clamp(cos(f*freq*3.14159*2.)*2., 0., 1.); // Blurry contours, for comparison.\n    #endif\n    \n    \n    // Coloring.\n    //\n    // Convert \"c\" above to the greyscale and green colors.\n    vec3 col = vec3(c);\n    vec3 col2 = vec3(c*0.64, c, c*c*0.1);\n    \n    #ifdef GLOSSY\n    col = mix(col, col2, -uv.y + clamp(fract(f*freq*0.5)*2.-1., 0., 1.0));\n    #else\n    col = mix(col, col2, -uv.y + clamp(cos(f*freq*3.14159)*2., 0., 1.0));\n    #endif\n    \n    // Color in a couple of thecontours above. Not madatory, but it's pretty simple, and an interesting \n    // way to pretty up functions. I use it all the time.\n    f = f*freq;\n    \n    #ifdef GLOSSY\n    if(f>8. && f<9.) col *= vec3(1, 0, .1);\n    #else\n    if(f>8.5 && f<9.5) col *= vec3(1, 0, .1);\n    #endif \n   \n    \n\t// Since we have the gradient related value, we may as well use it for something. In this case, we're \n    // adding a bit of highlighting. It's calculated for the contourless noise, so doesn't match up perfectly,\n    // but it's good enough. Comment it out to see the texture on its own.  \n    #ifdef GLOSSY\n    col += g*g*g*vec3(.3, .5, 1)*.25*.25*.25*.1;\n    #endif \n    \n    \n    //col = c * vec3(g*.25); // Just the function and gradient. Has a plastic wrap feel.\n\t\n    // Done.\n\tfragColor = vec4( sqrt(clamp(col, 0., 1.)), 1.0 );\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdXDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdXRB", "name": "collab x cabbibo 2 ", "author": "macbooktall", "description": "cabbibo and i are ping ponging some code and rendering gifs and this march is from the second we made here: https://assets.ello.co/uploads/asset/attachment/3779581/ello-optimized-6da2d75e.gif\n\nuse mouse to adjust camera", "tags": ["prism"], "likes": 0, "viewed": 151, "date": "1460035308", "time_retrieved": "2024-06-20T18:34:38.705623", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n// Includes code from hg_sdf library by Mercury http://mercury.sexy/hg_sdf/\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.00001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS =500;\n\nvec3 lightPos = vec3( .9 , .8 , .6 );\nvec3 camDir;\nfloat difVal;\nfloat prismSize = 0.6 + cos(iTime*4.)*0.05;\n\n#define MOUSE_CAM\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\np = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\nfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\nfGDFEnd\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat pNoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n  \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\nfloat rz = 0.;\n    vec3 bp = p;\nfor (float i=0.; i<=3.; i++ )\n{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\nz *= 1.5;\np *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n}\nreturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 m )\n{\n    float an = 0.3 + 10.0*m.x;\n    \n    //float an  = -iTime * .1 * 3.14159;\n    #ifdef MOUSE_CAM    \n\tcamPos = vec3(5.5*sin(an),(m.y - .5) * 4.,5.5*cos(an));\n    #else\n    camPos = vec3(5.5*sin(3.14159*1.95),1.,5.5*cos(3.14159*1.95));\n    #endif\n    camTar = vec3(-0.05,0.0,0.0);\n}\n\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n   return (-d1.x>d2.x) ? vec2( -d1.x , d1.y ) : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 smoothU( vec2 d1, vec2 d2, float k)\n{\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \nreturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n \n\nvec2 prism( vec3 pos, float size ){\n    \n    pos -= vec3( 0., -.6 , 0. );\n    \n    float octDist = fOctahedron( pos  , size );\n    float planeDist = sdPlane( pos , vec4( 0., 1. , 0. , 0. ) );\n    \n    float dist = opS(  planeDist , octDist );\n    \n    return vec2( dist , 1. );\n    \n}\n\n\nvec4 grow = vec4( 1. );\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += .050*sin(  8.*p.zxy)*grow.x;\n    p.xyz += 0.0850*sin(  12.0*p.yzx+ sin(iTime*4.)*1.8)*grow.y;\n    p.xyz += 0.05*sin(  5.0*p.yzx+ cos(iTime*4.)*1.8 )*grow.z;\n    p.xyz += 0.060*sin( 4.0*p.yzx)*grow.w;\n    return p;\n}\n\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvec2 goo( vec3 pos ){\n\n    pos.xz = rotate(pos.xz, sin(iTime*4.)*0.1);\n    \n    vec3 nPos = mapP( pos - vec3( -.4 , -.2 , 0.0) );\n    \n    difVal = length(nPos -( pos - vec3( -.5 , -.2 , 0.0) ));\n\n    float dist = length( nPos ) - .6 + cos(iTime * 4.)*0.08;\n    \n    pos -= vec3( 0., -.7 , 0. );\n    \n    // second larger prism\n    float octDist = prism( pos , prismSize ).x;\n    float planeDist = sdPlane( pos , vec4( 0., 1. , 0. , 0. ) );\n    \n    float prisDist = octDist;\n    \n    \n    //vec2 res = opS( vec2( prisDist , 2.) , vec2( dist , 3. ));\n   // dist = opS( prisDist , dist );\n    \n   //vec2 res = vec2( dist , 3.);\n    \n    \n    return vec2( dist * .03 , 2. );\n    \n    \n}\n\nvec2 lightMap( vec3 pos ){\n\n    \n   float dist =length( pos - lightPos ) - .3;\n    \n    return vec2( dist , 4. );\n    \n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos , float io ){  \n   \n    vec2 idx =vec2(1.);\n    \n    float clock = iTime*4.;\n    float phase = (idx.y+idx.x)*3.14159;\n    \n    float anim = sin(phase + clock);\n    \n    vec2 crystal = prism( pos, prismSize );\n    vec2 flow = goo( pos + vec3(0.,anim*0.025,0.)  );\n    \n    vec2 res2 = smoothU( crystal , flow , .2 );// vec2(smin(crystal.x, flow.x, 0.15), 3.);\n    \n    vec2 l = lightMap( pos );\n    //res = opU( res , l );\n    \n    res2.x *= io;\n\n   \treturn res2;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd  , in float io){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\nfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n  vec2 m = map( ro+rd*t , io );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax , float io )\n{\nfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\nfloat h = map( ro + rd*t , io).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor , float io )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos , io).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n#define STEPS 10\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .1  * float( i );\n\n        lum += triNoise3D( p * .5 , 1.2);// + sin( p.y * 3. ) + sin( p.z * 5.);\n    \n       //\tcol += hsv( lum / 10. + .8 , 1. , 1. ) * ( float(STEPS) - float(i)) / float(STEPS) * lum;\n        \n        col += vec3( .2 , 0. , 0.2) * lum * lum * lum * 1. / (float( i)+1.);\n    }\n    \n    return col/float(STEPS);\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos , in float io ){\n    \nvec3 eps = vec3( 0.001, 0.0, 0.0 );\nvec3 nor = vec3(\n   map( pos+eps.xyy , io ).x - map( pos-eps.xyy , io ).x,\n   map( pos+eps.yxy , io ).x - map( pos-eps.yxy , io ).x,\n   map( pos+eps.yyx , io ).x - map( pos-eps.yyx , io ).x );\nreturn normalize(nor);\n}\n\n\nvec3 noiseNormal( vec3 pos ){\n return normalize( vec3(hash(pos.x) , hash( pos.y ), hash( pos.z) ) );  \n}\n\n\n\n\nvec3 doGooCol( vec3 p , vec3 n , float id ){\n  \n    vec3 lightDir = normalize(lightPos - p);\n    \n    float match = dot( lightDir , n );\n    float ao = calcAO( p , n , 1. );\n    \n    vec3 fNorm = normalize(noiseNormal( p * 100. ) + n);\n   \tvec3 refl = reflect( lightDir ,fNorm );\n    \n    float rMatch = dot( refl , camDir );\n    \n    \n    if( id - 1.96 < .01 ){\n      \tvec3 sparkle = rMatch *  vec3( 1.3 , .7 , 0. );\n    \treturn sparkle + match * vec3( 1. , .6 , 0. );\n    \n       \n    }\n    \n    \n    float v = length( p - vec3( 0. ) );\n    \n  \tvec3 rb = hsv( difVal * .4 + .9 , .9 , .8 );\n    \n   // return vec3( 1. ) * ao * ao * ao * 60. * (rMatch * rMatch * rMatch + match);// rb * rMatch * ao + vec3(1.,.5 , 0.)*rMatch;\n     \n   return vec3( 1. ) * ao * ao * ao * 60.; \n}\n\nvec3 doBGCol( vec3 p  ){\n return vec3( triNoise3D( p * .1 , .0 ) );   \n}\nvec3 doSecondColor( vec3 rd , vec3 p , vec3 n  ){\n    \n    float ior = .9;\n    float dRay = .02;\n    //First break it into rays\n    \n    vec3 rR = refract( rd , n , ior + dRay );\n    vec3 rG = refract( rd , n , ior );\n    vec3 rB = refract( rd , n , ior - dRay );\n    \n    \n    vec2 resR = calcIntersection( p + rR * .01 , rR , -1. );\n    vec2 resG = calcIntersection( p + rG * .01 , rG , -1. );\n    vec2 resB = calcIntersection( p + rB * .01 , rB , -1. );\n    \n    vec3 col = vec3( 1.6 , .2 , 0. );\n    \n    //return col;\n    \n    float fc = length( fogCube( p * .1 , rd , n  ) );\n    \n    //return doCol( 1. , p , n );//col * vec3( pow( fc , 2.) - .5 );\n    \n    \n    \n    // BUGS\n    if( resR.y < -.5 || resG.y < -.5 || resB.y < -.5){\n        col = vec3( 0. , .5 , 0.); \n    }else{\n\n    \n        vec3 pR = p + rR * (resR.x +.01);\n        vec3 pG = p + rG * (resG.x +.01);\n        vec3 pB = p + rB * (resB.x +.01);\n\n        vec3 nR = calcNormal( pR , -1. );\n        vec3 nG = calcNormal( pG , -1. );\n        vec3 nB = calcNormal( pB , -1. );\n\n        vec3 r2R = refract( rR , nR , ior + dRay );\n        vec3 r2G = refract( rG , nG , ior );\n        vec3 r2B = refract( rB , nB , ior - dRay );\n\n        vec2 res2R = calcIntersection( pR + r2R * .01 , r2R , 1. );\n        vec2 res2G = calcIntersection( pG + r2G * .01 , r2G , 1. );\n        vec2 res2B = calcIntersection( pB + r2B * .01 , r2B , 1. );\n\n\n         // BUGS\n        if( res2R.y < -.5 || res2G.y < -.5  || res2B.y < -.5 ){\n            \n            vec3 c = vec3( 1. , 0., 0.);\n            \n            vec3 p2R = pG + r2R * (2. +.01);\n            vec3 p2G = pR + r2G * (2. +.01);\n            vec3 p2B = pG + r2B * (2. +.01);\n\n            \n             col = c.xyy * doBGCol( p2R ) \n                + c.yxy * doBGCol( p2G )  \n                + c.yyx * doBGCol( p2B );\n            \n            col *= vec3( .4 , .6 , 1.3 );; \n            //col *= vec3( 1.);\n        }else{\n            \n            \n            vec3 p2R = pG + r2R * (res2R.x +.01);\n            vec3 p2G = pR + r2G * (res2G.x +.01);\n            vec3 p2B = pG + r2B * (res2B.x +.01);\n\n            \n            vec3 n2R = calcNormal( p2R , 1. );\n            vec3 n2G = calcNormal( p2G , 1. );\n            vec3 n2B = calcNormal( p2B , 1. );\n            \n            \n            \n            vec3 c = vec3( 1. , 0., 0.);\n            \n            col = c.xyy * doGooCol( p2R , n2R, res2R.y ) \n                + c.yxy * doGooCol( p2G , n2G, res2G.y )  \n                + c.yyx * doGooCol( p2B , n2B, res2B.y );\n            \n            //col *= .8;\n           \n            col *= vec3( .4 , .6 , 1.3 );\n            //col *= vec3( 1. );//\n           \n\n           \n            //col = c;\n        }\n        \n\n    }\n    \n    \n    \n    \n    \n    \n    return col ;\n    \n    \n}\n\n\nvec3 doCol( float id , vec3 p , vec3 n ){\n    \n    vec3 lightDir = lightPos - p;\n    \n    float match = dot( normalize( lightDir ) , n );\n    float ao = calcAO( p , n , 1. );\n    \n    if( id < 1.95 ){\n    \tvec3 c =  doSecondColor( camDir , p , n );\n        return c; //vec3( 1. , 0.,  0.);\n        \n    }else{\n     return doGooCol( p , n , id );// - (n * .5 + .5); \n        \n    }\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    grow.x = 1.9 + sin(iTime*4.)*.1;//(sin( iTime * 4. ) + 10. ) / 10.;\n    \n    grow.y = 1.8 + cos(iTime*4.)*.1;//(sin( iTime * 8. ) + 10. ) / 10.;\n    grow.z = 2.2 + sin(iTime*4.)*.1;//(sin( iTime * 16. ) + 10. ) / 10.;\n     grow.w = 2.3 + cos(iTime*4.)*.1;//(sin( iTime * 32. ) + 10. ) / 10.;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.01+sin(iTime*4.)*0.01 );  // 0.0 is the camera roll\n    \n// create view ray\nvec3 rd = normalize( camMat * vec3(p.xy,3.5) ); // 2.0 is the lens length\n    \n    camDir = rd;\n    \n    vec2 res = calcIntersection( ro , rd , 1.  );\n\n\n    vec3 col = vec3( 0.);\n    \n\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos , 1. );\n        \n        vec3 depthColor = fogCube( pos , rd , norm  );\n \t\t\n        col = doCol( res.y , pos , norm );\n        \n        \n    }else{\n        \n       vec3 c = doBGCol( ro + rd * 2. );\n     col = vec3(.2, 0.5, 1.) *c * c*c * 5.; \n        \n    }\n\tcol = pow( col, vec3(.792545) );\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdXRf", "name": "Stars 3", "author": "gigatron", "description": "wip to simulate Razor 1911 voyage demo star sequence at beginning seconds 20 !\nThx to mr tambako; // not yet perfect !!", "tags": ["stars", "rotation", "shape"], "likes": 1, "viewed": 134, "date": "1460642157", "time_retrieved": "2024-06-20T18:34:39.414735", "image_code": "/*\n\"Tamby's Star Test\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n// thank you ;\n\n#define TS(A,F) A*(0.5 + sin(iTime*F))\n#define TC(A,F) A*(0.5 + cos(iTime*F))\n\nconst float pi = 3.14159;\nconst float bs = 0.001;\nconst float bw = 0.006;\n// global float vars .. \n \nconst float px=0.0;\nconst float py=0.1;// not used yet ! \nconst float st=0.1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    float xr = vect.x*cos(angle) + vect.y*sin(angle);\n    float yr = vect.x*sin(angle) - vect.y*cos(angle);\n    return vec2(xr, yr);\n}\n\nfloat star(vec2 uv, vec2 center, float r1, float sf, float nb, float rs)\n{\n\tuv-= center + vec2(0., 0.5*(0.6 - (iResolution.x-iResolution.y)/iResolution.x)); \n    float alpha1 = mod(atan(uv.x, uv.y) + iTime*rs, 2.*pi/nb);\n    float alpha2 = mod(2.*pi/nb-atan(uv.x, uv.y) - iTime*rs, 2.*pi/nb);\n    float alpha = alpha1<pi/nb?alpha2:alpha1;\n    float f = sf*length(uv)*cos(alpha)/cos(pi/nb) - length(uv)*(sf-1.);\n    float v = smoothstep(r1 - bs, r1 + bs, f) + 0.5 - 0.5*smoothstep(r1 - 2.*bs - bw, r1 + bs - bw, f) + 0.2*pow(smoothstep(r1*0.9, r1*0.2, f), 0.2);\n\n    float f2 = length(uv);\n    float v2 = (1. - smoothstep(r1 - bs, r1 + bs, f2)) ;\n    \n    //return v + v2 -0.5*v3;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord.xy / iResolution.xx;\n    \n    float t=iTime;\n    uv.y =4.2*uv.y;// razor 1911 voyage star sequence ... wip !\n\t    \n     float v = star(-uv, vec2(0.175, 0.1), 0.03 + TS(0.02, 1.), 1.05, 5., -1.8);\n    float rot = -iTime * 1.0;\n        \n    //stars\n    for (int i = 0 ; i < 8 ; i++) {\n         float ct=float(i/300);\n         \n v *= star(uv, vec2(0.9+ct +  sin (-rot   -float(i) * 0.8 )/1.4,0.5 + cos (-rot   -float(i) * 0.8 ))/1.1, 0.060  , 1.05, 5., -1.8);\n\n        \n    }\n \n          \n    \n  fragColor.rgb = mix(vec3(1.0*v,0.4*v,v*3.0),  vec3(0.,0.,0.), v);\n\n\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSDf", "name": "blues 'n hues", "author": "tomaes", "description": "layered interference plasma + layers of motion blur.", "tags": ["interference", "motionblur", "pseudo3d", "style"], "likes": 2, "viewed": 234, "date": "1461871174", "time_retrieved": "2024-06-20T18:34:39.414735", "image_code": "vec3 r( vec2 _uv, float _t )\n{\n    //_uv.x += min(.85*mod(_uv.x+_t,length(.5-_uv)*.1 ), .1  );\n    //_uv.y += min(.85*mod(_uv.y+_t,length(.5-_uv)*.6 ), .1  );\n\n    //_uv.x += .75*mod(_uv.x,.01 );\n    //_uv.y += .75*mod(_uv.y,.005+sin(_t+_uv.y*.5)*.1 );\n\n    float c = 1.;\n    \n    if ( mod(_uv.x*.02/_uv.y   +_t*.1,.1) > .05)\n    {\n      c  = mod( mod(length(.7-_uv),.1)*20.*sin(_t+sqrt(abs(2.*sin(_uv.y)*cos(_uv.x)*2.))),.26)*5.;\n      c -= mod( mod(length(.3-_uv),.1)*20.*sin(_t+sqrt(abs(2.*sin(_uv.y)*cos(_uv.x)*2.))),.26)*5.; \n\t  c += mod( length(.7-_uv)*sin(_t+sqrt(abs(2.*sin(_uv.y)*cos(_uv.x)*2.)) ),.26)*5.;\n      c += mod( length(.3-_uv)*sin(_t+sqrt(abs(2.*sin(_uv.y)*cos(_uv.x)*2.)) ),.26)*5.; \n    }\n    else\n    {\n      c  = mod( length(.7-_uv)*sin(_t+sqrt(2.*sin(_uv.y)*cos(_uv.x)*2.)),.26)*5.;\n      c += mod( length(.3-_uv)*sin(_t+sqrt(2.*sin(_uv.y)*cos(_uv.x)*2.)),.26)*5.; \n    }\n    \n    return vec3(1.2-c,.6-c,min(c-_uv.x/_uv.y,.8));    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime + 1.5;//3.8\n   \n    //fragColor = vec4( r(uv,t), 1. );\n    //fragColor = vec4( 0.8*r(uv,t)+0.3*r(uv,t+.01)+0.2*r(uv,t+.02), 1. );\n\t\n    fragColor = vec4(.0);\n    \n    // motion blur\n    for( float f = .0; f < .2; f+=.01 )\n        fragColor += vec4( r(uv,t+f)*(.06-f*.03),1. );\n    \n    // radial blur\n    //for( float f = 1.; f > .0; f -=.01 )\n    //    fragColor += .015 * vec4( r( uv*f,t+(1.-f)*.1 ), 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSDj", "name": "patterns and rotation", "author": "rjoudrey", "description": "experimenting with patterns and rotations", "tags": ["2d"], "likes": 2, "viewed": 91, "date": "1461550514", "time_retrieved": "2024-06-20T18:34:39.414735", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    xy = xy * 2.0 - 1.0;\n    xy.x *= aspectRatio;\n    \n    xy /= cos(iTime) - 1.3;\n    xy += iTime * 0.5;\n    \n    \n    // rotate the space\n    xy = rotate2d(iTime * 0.1) * xy;\n    xy *= 4.0;\n    // create pattern\n    xy = mod(xy-1., 2.) - 1.;\n    \n    xy = rotate2d(iTime * 0.1) * xy;\n    \n    float x = xy.x;\n    float y = xy.y;\n    \n    float dist = length(xy);\n    float angle = floor(atan(xy.y / xy.x));\n    // increase the distance to the line based off its angle\n    float outerEdge = 0.9 + sin(angle * 20. + iTime) * .05;\n    float innerEdge = outerEdge - .02;\n    float aaSize = .01;\n    // tiny smoothstep addition on the edge gives it an anti-aliased look\n    float c = (step(dist, outerEdge) + smoothstep(outerEdge + aaSize, outerEdge, dist)) * \n        (step(innerEdge, dist) + smoothstep(innerEdge - aaSize, innerEdge, dist));\n    \n    float cDist = 0.13;\n    float cWidth = 0.02;\n    // without aa, big difference\n    c += step(dist, cDist) * step(cDist - cWidth, dist);\n    \n\tfragColor = vec4(c, 0, 0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSR2", "name": "Antialiasing VR", "author": "lebek", "description": "https://www.shadertoy.com/view/llXGR4 copied from iq shader just added VR", "tags": ["iq", "vr"], "likes": 24, "viewed": 1742, "date": "1460312023", "time_retrieved": "2024-06-20T18:34:40.408899", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An edge antialising experiment (not multisampling used)\n//\n// If slow_antialias is disabled, then only the 4 closest hit points are used for antialising, \n// otherwise all found partial-intersections are considered.\n\n\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa-ba*h ), h );\n}\n\nvec3 opU( vec3 d1, vec3 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec3 map( vec3 p )\n{\n    vec2 id = floor( (p.xz+1.0)/2.0);\n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;\n    \n    float ph = sin(0.5 + 3.1*id.x + sin(7.1*id.y));\n    \n    p.xz += 0.5*sincos(1.0+0.5*iTime+(p.y+11.0*ph)*0.8);\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-1.0*iTime+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iTime+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iTime+4.0);\n    \n    vec2 h1 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h2 = sdSegment(p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h3 = sdSegment(p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    \n    return opU( opU( vec3(h1.x-0.12,                                         ph + 0.0/3.0, h1.y), \n                     vec3(h2.x-0.12-0.05*cos( 500.0*h2.y - iTime*4.0), ph + 1.0/3.0, h2.y) ), \n                     vec3(h3.x-0.12-0.02*cos(2000.0*h3.y - iTime*4.0), ph + 2.0/3.0, h3.y) );\n}\n\n//-------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos, in float dt )\n{\n    vec2 e = vec2(1.0,-1.0)*dt;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.15;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.5*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d);\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------\nvec3 shade( in float t, in float m, in float v, in vec3 ro, in vec3 rd )\n{\n    float px = 0.0001;//(2.0/iResolution.y)*(1.0/3.0);\n    float eps = px*t;\n\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormal( pos, eps );\n    float occ = calcOcc( pos, nor );\n\n    vec3 col = 0.5 + 0.5*cos( m*vec3(1.4,1.2,1.0) + vec3(0.0,1.0,2.0) );\n    col += 0.05*nor;\n    col = clamp( col, 0.0, 1.0 );\n    col *= 1.0 + 0.5*nor.x;\n    col += 0.2*clamp(1.0+dot(rd,nor),0.0,1.0);\n    col *= 1.4;\n    col *= occ;\n    col *= exp( -0.15*t );\n    col *= 1.0 - smoothstep( 15.0, 35.0, t );\n    \n    return col;\n}\n\n//-------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\t\n    \n\tvec3 ta = 0.5*vec3(0.0, 4.0,-4.0);\n    \n    float fl = 1.0;\n\t\n    float px = (2.0/iResolution.y)*(1.0/fl);\n    \n    vec3 col = vec3(0.0);\n\n    //---------------------------------------------\n    // raymach loop\n    //---------------------------------------------\n    const float maxdist = 32.0;\n\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n\n    vec3 oh = vec3(0.0);\n    mat4 hit = mat4(-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0);\n\n    \n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 h = map( ro + t*rd );\n        float th1 = px*t;\n        res = vec3( t, h.yz );\n        if( h.x<th1 || t>maxdist ) break;\n\n        \n\n        float th2 = px*t*3.0;\n        if( (h.x<th2) && (h.x>oh.x) )\n        {\n            float lalp = 1.0 - (h.x-th1)/(th2-th1);\n\n             if( hit[0].x<0.0 )\n             {\n             hit[0] = hit[1]; hit[1] = hit[2]; hit[2] = hit[3]; hit[3] = vec4( t, oh.yz, lalp );\n             }\n\n        }\n        oh = h;\n\n        \n        t += min( h.x, 0.5 )*0.5;\n    }\n    \n    if( t < maxdist )\n        col = shade( res.x, res.y, res.z, ro, rd );\n\n    for( int i=0; i<4; i++ ) // blend back to front\n    if( hit[3-i].x>0.0 )\n        col = mix( col, shade( hit[3-i].x, hit[3-i].y, hit[3-i].z, ro, rd ), hit[3-i].w );\n\n \n    //---------------------------------------------\n    \n    return pow( col, vec3(0.5,0.7,0.5) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n\tvec3 ro = 0.6*vec3(2.0,-3.0, 4.0);\n\tvec3 ta = 0.5*vec3(0.0, 4.0,-4.0);\n    \n    float fl = 1.0;\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(1.0,0.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n    \n    vec3 col = render(ro, rd);\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + 0.6*vec3(2.0,-3.0, 4.0);\n    vec3 col = render(ro, fragRayDir);\n    \n    //vec2 q = fragCoord.xy/iResolution.xy;\n    //col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n\tfragColor = vec4( col, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSRs", "name": "Abstract Music", "author": "MatHack", "description": "Art ^^ ! Just for the mega fun GLSL", "tags": ["wave", "music", "art"], "likes": 22, "viewed": 1040, "date": "1460927582", "time_retrieved": "2024-06-20T18:34:40.408899", "image_code": "//Fast Code, No Optim and clean ;) !\n\nfloat freqs[16];\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\n\nfloat PI=3.14159265;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xx;    \n    vec2 mouse = iMouse.xy / iResolution.xy;    \n    vec2 uv2 =  -1.0 + 2.0 * uv;\n    uv2.y += 0.45;    \n    //uv2.xy -= (mouse*4.0) - 2.0;\n    uv2.xy *= 4.5;  \n    \n    float time = iTime + (2.0*freqs[0]);\n\n    vec3 color = vec3(0.0);\n    vec3 color2 = vec3(0.0);\n    \n    float nbPointX = 128.0;\n    float nbPointY = 128.0;\n    float resX =  (iResolution.x/nbPointX)/iResolution.x;\n    float resY =  (iResolution.y/nbPointY)/iResolution.y;\n    \n        \n    for( int i=0; i<16; i++ ){\n        freqs[i] = clamp( 1.9*pow( texture( iChannel0, vec2( 0.05 + 0.5*float(i)/16.0, 0.25 ) ).x, 3.0 ), 0.0, 1.0 );\n        \n        float wave = sqrt(sin( (-(freqs[i]*noise2d(uv*10.0+ vec2(rotate2d(iTime)).xy ) )*3.1416) + ((uv2.x*uv2.x) + (uv2.y*uv2.y)) ) );\n     \n\t\tvec2 v = rotate2d(iTime) * (uv * 2.0);\n        \n \t\twave = smoothstep(0.8, 1.0, wave);\n        color2 += wave * (vec3(v.x, v.y, 1.7-v.y*v.x)*0.08) * freqs[i];\n        \n        float endPixelX = (1.0/iResolution.x)*(wave*1.0);\n    \tfloat endPixelY = (1.0/iResolution.x)*(wave*1.0);\n        //Grid 1\n        if(mod(uv.x, resX) >= 0.0 && mod(uv.x, resX) <= endPixelX && mod(uv.y, resY) >= 0.0 && mod(uv.y, resY) <= endPixelY){\n            color2 += (vec3(v.x, v.y, 1.7-v.y*v.x)*0.08) ;\n        }  \n        \n        \n        wave = smoothstep(0.99999, 1.0, wave);\n        color2 += wave * vec3(0.2) ;\n      \n        \n    }\n\n\n\tfragColor =  vec4(color2, 1.0);\n    \n      \n}\n\n", "image_inputs": [{"id": "Xsf3Rl", "previewfilepath": "https://soundcloud.com/demoscenetimemachine/artillery", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/demoscenetimemachine/artillery", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSWf", "name": "Cellular Activities", "author": "vox", "description": "Cellular Activities", "tags": ["cellularactivities"], "likes": 4, "viewed": 397, "date": "1461849739", "time_retrieved": "2024-06-20T18:34:40.754118", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime/PI+100.0)\n#define saw(x) (acos(cos(x))/PI)\n\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 tree(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n\treturn cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb);\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = (4.0+3.0*sin(time/PI))*PI;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float r = length(uv);\n\n    \n    float map = 0.0;\n    float noise = 1.0;\n    \n\tconst int max_iterations = 4;\n    \n    vec2 multa, multb, offa, offb;\n\n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        \n        multa = cos(vec2(time*.1, time*.2)+iteration*PI);\n        offa = cos(vec2(time*.3, time*.4)+iteration*PI);\n        multb = cos(vec2(time*.5, time*.6)+iteration*PI);\n        offb = cos(vec2(time*.7, time*.8)+iteration*PI);\n        \n        uv = tree(uv, multa, offa, multb, offb);\n        float dist = length(uv);\n        uv = saw(uv*1.0*PI)*2.0-1.0;\n        map += pow(clamp(1.0-length(uv), 0.0, 1.0), .5)*noise;    \n        noise *= clamp(1.0-length(fwidth(uv)), 0.0 ,1.0)*\n            \t clamp(1.0-fwidth(map), 0.0 ,1.0);\n        \n    }\n    \n    fragColor = vec4(phase(map*1.0*PI+time), 1.0);\n    \n    //fragColor = vec4(uv*.5+.5, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSWS", "name": "SimpleParticles", "author": "chazbg", "description": "Particle emitter + fading", "tags": ["particles"], "likes": 3, "viewed": 660, "date": "1461586294", "time_retrieved": "2024-06-20T18:34:40.754353", "image_code": "float dist2(vec2 a, vec2 b)\n{\n    return dot(a - b, a - b);\n}\n\nvec2 getDir(vec2 uv)\n{\n    float delta = 0.01;\n    float n = texture(iChannel0, vec2(uv.x, uv.y + delta)).r;\n    float s = texture(iChannel0, vec2(uv.x, uv.y - delta)).r;\n    float e = texture(iChannel0, vec2(uv.x + delta, uv.y)).r;\n    float w = texture(iChannel0, vec2(uv.x - delta, uv.y)).r;\n    vec2 dir = normalize(vec2(e - w, n - s));\n    return dir;\n}\n\nvec3 drawParticles(vec2 uv, vec2 ePos, vec2 dir, float time, float duration)\n{\n    vec3 col = vec3(0.0);\n   \t\n    float r = 0.001;\n    const int particleCount = 5;\n    float delta = 3.0 / (duration * float(particleCount));\n    \n    \n    for (int i = 0; i < particleCount; i++)\n    {\n        float offset = float(i) / float(particleCount);\n        \n        vec2 pPos = ePos + mod(offset + delta * time, 1.0) * dir;\n    \tfloat fade = (1.0 - dist2(pPos, ePos));\n   \t\tcol += mix(vec3(0.2, 0.5, 0.1), vec3(0.0), smoothstep(0.0, r, dist2(uv, pPos))) * fade;\n    }\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.4;\n    \n    fragColor = vec4(0.0);\n\tfragColor += vec4(drawParticles(uv, vec2(0.5, 0.0), vec2(0.0, 1.0),  mod(iTime, 3.0), 3.0),1.0);\n    fragColor += vec4(drawParticles(uv, vec2(0.5, 0.0), vec2(1.0, 1.0),  mod(iTime, 4.0), 2.0),1.0);\n    fragColor += vec4(drawParticles(uv, vec2(0.5, 0.0), vec2(-1.0, 1.0), mod(iTime, 3.0), 1.5),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stXDS", "name": "turbulent cloud tunnel", "author": "public_int_i", "description": "cloud tunnel", "tags": ["tunnel", "cloud"], "likes": 13, "viewed": 249, "date": "1461250757", "time_retrieved": "2024-06-20T18:34:40.754353", "image_code": "//Ethan Alexander Shulman 2016\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\n\n#define pi 3.14\n#define lightDirection normalize(vec3(1.,1.,1.))\n#define ambientColor skyColor*.2+vec4(.2)\n#define diffuseColor vec4(.8)\n#define skyColor vec4(.25,.45,.94,1.)*.5\n#define sunColor vec4(1.,.84,.94,1.)*1.35\n#define cloudRoughness 0.243\n\n\n//2d point rotation\nvec2 rot(in vec2 p, in float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n//3d point rotation on xy then xz axes\nvec3 rot(in vec3 ip, in vec2 a) {\n    vec3 p = ip;\n    p.yz = rot(p.yz,a.y);\n    p.xz = rot(p.xz,a.x);\n    return p;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//cloud distance function, rough and not an accurate distance\nfloat df(vec3 ip, float i) {\n                \n    ip.xy = rot(ip.xy,cos(ip.z*.034)+iTime);\n    float ldst = abs(length(ip.xy)-20.)-3.-(6.+cos(cos(ip.x/24.234)+ip.z/131.5435+\n                                   cos(ip.y/33.3958)+ip.x/191.9257+\n                                   cos(ip.z/36.3834)+ip.y/135.3245)*6.);\n    ldst += (cos((ip.x/i)/i+cos(cos((ip.x+ldst*4.)/i)*cloudRoughness+(ip.y*.39)/i)*4.0192854)*\n             cos((ip.y/i)/i+cos(cos(.8+(ip.y+ldst*4.)/i)*cloudRoughness+(ip.z*.37)/i)*4.0817395)*\n             cos((ip.z/i)/i+cos(cos(1.6+(ip.z+ldst*4.)/i)*cloudRoughness+(ip.x*.41)/i)*4.0243927))*i;\n    \n    return max(.2, ldst);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup ray from pixel coordinate, camera rotation and camera origin\n\tvec3 rd = normalize(vec3( (fragCoord*2.-iResolution.xy)/iResolution.x, 1. )),\n \t\t rp = vec3(0.,0.,iTime*50.);\n\n    //rough transparent object ray marching with 4 lod's for lighting\n\t//only 1 lod is rendered each step and lod's are switched each step for speed\n    vec2 c = vec2(0.);\n    float s = 0., im = 2.;\n    for (int i = 0; i < 64; i++) {\n        vec3 pd = rp+rd*s;\n        float ie = pow(im = mod(im,4.)+1., 2.),\n              od = df(pd, ie);\n        c += vec2( (df(pd+lightDirection*(ie*2.), ie)-od)/(ie*2.),\n                    .02)*pow(max(0.,(ie*.4-od))/(ie*.4),4.);\n        if (c.y >= 1.) break;\n        \n        s += od*(min(s/2.,.5)+hash3(pd)*.4);\n    }\n    c.x *= .05;\n    \n    vec4 sky = skyColor;\n    fragColor = pow(mix(skyColor,skyColor*.05+diffuseColor*c.x,c.y), vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stXDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stXRf", "name": "underwater tennis court", "author": "tomaes", "description": "A different kind of idea I wanted to try. ;)", "tags": ["2d", "distortion", "fading", "tennis"], "likes": 0, "viewed": 130, "date": "1460652647", "time_retrieved": "2024-06-20T18:34:41.190644", "image_code": "vec3 lookUp( vec2 _uv, float _t )\n{\n    _uv += _uv * (sin(_t*0.4)*0.3);\n    \n    // \"melt\" effect\n    _uv += (sin((_uv.x*10.05/_uv.y)*(0.15+sin(_t)*0.04) + _t * 0.8)*0.15);\n    \n    float o1 = 0.01;\n    float dist = distance(_uv,vec2(0.5,0.5));\n    \n    vec3 black = vec3(0.0,0.0,0.0);\n    vec3 white = vec3(1.0,1.0,1.0);\n    vec3 green = vec3(0.2,1.0,0.4);\n    vec3 blue  = vec3(0.2,0.6,1.0);\n\tvec3 c = green;\n    \n    if (_uv.x > 0.1 && _uv.x < 0.9)\n    \tc = blue;\n\n    if (_uv.x > (0.1+o1) && _uv.x < (0.9-o1))\n        c = white;\n\n    // surface\n    if (_uv.x > (0.1+o1*2.0) && _uv.x < (0.9-o1*2.0))\n        c = blue;\n    \n    // side lines\n    if ((_uv.x > 0.2 && _uv.x < 0.2+o1) ||\n        (_uv.x > 0.8 && _uv.x < 0.8+o1)) \n        c = white;\n \t\n    // t-line: vertical\n    if ((_uv.x > 0.5  && _uv.x < 0.5+o1) &&\n        (_uv.y > 0.05 && _uv.y < 0.95))\n        c = white;\n        \n    // net cord\n    if ((_uv.y > 0.49 && _uv.y < 0.51) &&\n        (_uv.x > 0.12 && _uv.x < 0.88))\n    \tc = black;\n    \n    // t-lines: down\n    if ((_uv.y > 0.05 && _uv.y < 0.06) &&\n        (_uv.x > 0.2 && _uv.x < 0.8))\n    \tc = white;\n\n    // t-lines: up\n    if ((_uv.y > 0.95 && _uv.y < 0.96) &&\n        (_uv.x > 0.2 && _uv.x < 0.8))\n    \tc = white;\n    \n    return vec3( c.r-dist, c.g-dist*0.3, c.b); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float t = iTime + 900. + abs(sin(iTime*0.5+(uv.y*uv.x)*0.5))*(0.2*uv.x/uv.y);\n\n    \n    if (uv.y > 0.1 && uv.y < 0.9) \n    for(float f = 0.1; f < 100.0; f += 10.0)\n    {    \n        // ball transition\n        if ( distance(vec2(uv.x,uv.y*0.7+0.15), vec2(0.5,0.5)) < cos(t+f*0.01) )\n    \t\tcol += 0.13 * lookUp( uv, t - (1.0/f)*2.0 );\n        else\n        {\n            col += 0.03 * lookUp( uv, t - (1.0/f)*1.0 );\n            \n            if (((col.r + col.g + col.b)/3.0) > 0.05)\n            col = 1.3-col;//vec3(0.0,0.0,0.0);\n        \t\telse\n            col = vec3(1.0,1.0,1.0-min(f*0.04, 0.69));\n\n        }\n    }\n    \n   \n    fragColor = vec4( col, 1.0 );          \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stXRj", "name": "Nielmo: Mandelbrot", "author": "Nielmo", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 145, "date": "1460287790", "time_retrieved": "2024-06-20T18:34:41.190644", "image_code": "// Nielmo 2016\n\nvec2 mc(in vec2 a, in vec2 b) {\n    //return vec2(a.x*b.x-a.y*b.y, dot(a.xy,b.yx));\n    return vec2(dot(a,vec2(b.x,-b.y)), dot(a.xy,b.yx));\n}\n\nvec4 mandelbrot( vec2 p, float depth, vec2 r, float scale, float t) {\n//    vec2 loc =  vec2(0.7,0.35);\n//    vec2 loc =  vec2(0.73700,0.24340);\n//    vec2 loc =  vec2(1.19622,0.32835);\n//    vec2 loc =  vec2(-0.4002,0.3604);\n//    vec2 loc =  vec2(0.1304,0.8792);\n//    vec2 loc =  vec2(1.19622,0.32835);\n    vec2 loc =  vec2(0.749107,-0.135849);\n    \n\n    //float t = iTime;\n    //scale = 1.0;\n    //r = vec2(1.0, 0.0);\n    \n    //mc(c,vec2(sin(t),cos(t)));\n    \n\tvec2 c = (iResolution.xy*-0.5+p.xy)*scale;\n\tc = mc(c,r) - loc;\n\n    vec2 z = vec2(0.0,0.0);\n    float n = 0.0;\n    for(int nn=0;nn<=1024;nn++) {\n        z = mc(z,z)+c;\n        n++;\n        if(dot(z,z)>=256.0) {\n            break;\n        }\n        if(n>=depth) {\n            break;\n        }\n    }\n    if(n>=depth) {\n\t\treturn vec4(0.0,0.0,0.0,1.0);\n    }\n    n = n -log2(log2(dot(z,z)));\n    n = n / 128.0;\n    n = sqrt(n);\n    float cr = 0.5+0.5*cos(n*7.0+t);\n    float cg = 0.5+0.5*cos(n*11.0+t*1.111);\n    float cb = 0.5+0.5*cos(n*13.0+t*2.567);\n\treturn vec4(cr,cg,cb,1.0);\n}\n\n# define A 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t//int antialias = 1;\n    //antialias = fragCoord.x<iResolution.x/2.0;\n    float t = iTime;\n    float depth=300.0;\n\n    float sr = 0.13;\n    float scale = 0.32+0.300*sin(t*sr);\n    scale = 4.0*scale*scale*scale / iResolution.y;\n\n    float rr = 1.0;\n    vec2 r = vec2(sin(5.0*sin(0.17*t)*rr),cos(7.7*cos(0.07*t)*rr));\n    \n    vec4 c = vec4(0.0);\n    float n = 0.0;\n    float a = float(A);\n    float ni = 0.0;\n    for(int i=0; i<A; i++) {\n\t    float nj = 0.0;\n\t    for(int j=0; j<A; j++) {\n    \t\tc = c + mandelbrot(fragCoord.xy+vec2(ni/a,nj/a),depth,r,scale,t);\n            n++;\n\t        nj++;\n        }\n        ni++;\n    }\n    fragColor = c / n;\n            \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stXzB", "name": "Amiga Vector Balls", "author": "gigatron", "description": "Amiga tribute vector balls; i have my 1200/050 Mhz !!! Must have 3ghz now .... to do something similar ?? 58 fps with 3.6*4 + gfxc :)))", "tags": ["amiga", "balls", "vector", "bouncing"], "likes": 7, "viewed": 251, "date": "1460043748", "time_retrieved": "2024-06-20T18:34:42.979041", "image_code": "// all from iq !!! the alien brain !!\n\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\nfloat dfSemiArc2(float rma, float rmi, vec2 uv)\n{\n\treturn min(abs(length(uv) - rma) - rmi, uv.x+4.0);\n}\n\n\n\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.t));\n}\n\n//--- Letters ---\nvoid G(inout float df, vec2 uv)\n{\n\t\n\tdf = min(df, dfSemiArc(0.5, 0.125, uv));\n\tdf = min(df, dfQuad(vec2(0.000, 0.375), vec2(0.000, 0.625), vec2(0.250, 0.625), vec2(0.25, 0.375), uv));\n\tdf = min(df, dfRect(vec2(0.250, 0.50), uv - vec2(0.0,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.250,-0.125), vec2(-0.125,0.125), vec2(0.250,0.125), vec2(0.250,-0.125), uv));\t\n}\n\nvoid I(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.280,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,0.40)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,-0.625)));\n}\n\n//\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.1,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,-0.20)));\n   \n}\n\n\nvoid T(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.700, 0.25), uv - vec2(-0.8,0.38)));\n    \n \n   \n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.0,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.95,0.38)));\n   df = min(df, dfRect(vec2(0.200, 0.60), uv - vec2(-0.600,-0.10)));\n    df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.95,-0.10)));\n    \n  //  df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.80,-0.10)));\n\n   df = min(df, dfQuad(vec2(-0.900,-0.100), vec2(-0.600,-0.100), vec2(-0.350,-0.625), vec2(-0.550,-0.625), uv));\n   \n   \n}\n\nvoid O(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.20,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.750,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,-0.625)));\n   \n}\n\nvoid N(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.30,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.650,-0.625)));\n   df = min(df, dfQuad(vec2( -1.300,.625), vec2(-1.000,0.625), vec2(-0.450,-0.625), vec2(-0.650,-0.625), uv));\n}\n\n\n\n\n\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n//---------------\n\n//--- From e#26829.0 ---\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  /*  p.z = 0.1,0.15;\n    p.y = p.y - s ;\n    p.x = p.x - s ;\n   */\n\treturn length(p) - s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    \n  \n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n\n // return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n//----------------------------------------------------------------------\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\n\nvec2 map( in vec3 pos )\n{\tfloat bf=1.4;\n \tfloat j=1.8; // jump factor\n    float t=iTime;\n\n    \n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n    vec2( sdSphere(    pos-vec3( 0.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*2.0)*j), 0.0), 0.25 ), 46.9 ) );\n for (int i=2;i<15;i++){\n float ii=float(i); // need to eliminate float(i) at formula ;\n\n res = opU( res, vec2( sdSphere(    pos-vec3( 2.-ii+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*ii)*j), 0.0), 0.25 ), 46.9 ) );\n\n// res = opU( res, vec2( sdSphere(    pos-vec3( 2.-ii+2.*sin(t)+ii,0.3+abs(sin(t*2.+bf/6.*ii)*j), 0.0+ii), 0.25 ), 46.9 ) );\n\n     \n// play like you want !! double number of balls and drop fps !!! we need QUANTUM Computer now !!\n  //   QUBIT Rulez !!!\n     \n//res = opU( res, vec2( sdSphere(    pos-vec3( 2.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*4.0)*j), 0.0), 0.25 ), 46.9 ) );\n//res = opU( res, vec2( sdSphere(    pos-vec3( 3.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*5.0)*j), 0.0), 0.25 ), 46.9 ) );\n//res = opU( res, vec2( sdSphere(    pos-vec3( 4.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*6.0)*j), 0.0), 0.25 ), 46.9 ) );\n//res = opU( res, vec2( sdSphere(    pos-vec3( 5.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*7.0)*j), 0.0), 0.25 ), 46.9 ) );\n//res = opU( res, vec2( sdSphere(    pos-vec3( 6.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*8.0)*j), 0.0), 0.25 ), 46.9 ) );\n//res = opU( res, vec2( sdSphere(    pos-vec3( 7.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*9.0)*j), 0.0), 0.25 ), 46.9 ) );\n//res = opU( res, vec2( sdSphere(    pos-vec3( 8.0+2.*sin(t),0.3+abs(sin(t*2.+bf/6.*10.0)*j), 0.0),0.25 ), 46.9 ) );\n\n// for loop to replace lines above .. substract 2 cause loop start at 2 .     \n     \n     \n}     \n \n \n \n \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.2 )\n        {\n            \n            float f = mod( floor(0.*pos.z) + floor(4.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.0+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -.2, 0.8 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd )-0.2;\n\n\tcol = pow( col, vec3(0.4545) );\n    float t=iTime;\n     float bf=1.4;\n\t \n\n\tfloat dist = 1e6;\n\t\n\tfloat charSpace = 1.025;\n\t\n\tvec2 chuv = p*15.0-vec2(22.,-14.0);// replace logo \n\tchuv.x += charSpace * 3.0;\n    \n    G(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.)))); chuv.x -= charSpace;\n    \n    I(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*2.0)))); chuv.x -= charSpace;\n    G(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*3.0)))); chuv.x -= charSpace;\n    A(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*4.0)))); chuv.x -= charSpace;\n    T(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*5.0)))); chuv.x -= charSpace;\n    R(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*6.0)))); chuv.x -= charSpace;\n    O(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*7.0)))); chuv.x -= charSpace;\n    \n\tN(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*8.0)))); chuv.x -= charSpace;\n\n    float mask = smoothstep(8.0/iResolution.y,0.10,dist);\n    \n\n    fragColor=vec4( col*mask, 1.0 );\n}", "image_inputs": [{"id": "4dsGzX", "previewfilepath": "https://soundcloud.com/virgill/physical-presence-chiptune-rmx", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/physical-presence-chiptune-rmx", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stXzj", "name": "dark ominous clouds", "author": "public_int_i", "description": "dark evil looking clouds, the other day i tried to make a real-time cloud renderer and it actually turned out decent.", "tags": ["clouds", "dark", "ominous"], "likes": 5, "viewed": 175, "date": "1460895973", "time_retrieved": "2024-06-20T18:34:42.979041", "image_code": "//Ethan Alexander Shulman 2016\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\n\n#define pi 3.14\n#define lightDirection normalize(vec3(1.,1.,1.))\n#define ambientColor skyColor*.2+vec4(.2)\n#define diffuseColor vec4(.8)\n#define skyColor vec4(.55,.65,.94,1.)\n#define sunColor vec4(1.,.84,.94,1.)*1.35\n#define cloudRoughness .3\n\n\n//2d point rotation\nvec2 rot(in vec2 p, in float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n//3d point rotation on xy then xz axes\nvec3 rot(in vec3 ip, in vec2 a) {\n    vec3 p = ip;\n    p.yz = rot(p.yz,a.y);\n    p.xz = rot(p.xz,a.x);\n    return p;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//cloud distance function, rough and not an accurate distance\nfloat df(vec3 ip, float i) {\n    \n    float fp = (floor(abs(ip.x)/200.)+floor(abs(ip.z)/200.)*1024.)*2.4321239;\n    vec3 p = vec3(mod(abs(ip.xz),200.)-100., ip.y+hash(fp*.3954+fp*3.49634)*100.-50.).xzy;    \n                \n    float ldst = abs(ip.y)-(6.+cos(cos(ip.x/24.234)+ip.z/131.5435+\n                                   cos(ip.y/33.3958)+ip.x/191.9257+\n                                   cos(ip.z/36.3834)+ip.y/135.3245)*6.);\n    ldst += (cos((ip.x/i)/i+cos(cos((ip.x+ldst*4.)/i)*cloudRoughness+(ip.y*.39)/i)*4.0192854)*\n             cos((ip.y/i)/i+cos(cos(.8+(ip.y+ldst*4.)/i)*cloudRoughness+(ip.z*.37)/i)*4.0817395)*\n             cos((ip.z/i)/i+cos(cos(1.6+(ip.z+ldst*4.)/i)*cloudRoughness+(ip.x*.41)/i)*4.0243927))*i+min(3.,length(p.xz)*.05);\n    \n    return max(.2, ldst);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup ray from pixel coordinate, camera rotation and camera origin\n\tvec3 rd = normalize(vec3( (fragCoord*2.-iResolution.xy)/iResolution.x, 1. )),\n \t\t rp = vec3(0.,cos(iTime*.12945)*100.-80.,iTime*20.);\n\n\tvec2 cameraRotation = vec2(pi/2.+cos(iTime*.0963)*2., pi/3.+cos(iTime*.12945)*.23);\n\trd = rot(rd,cameraRotation);\n\n    //rough transparent object ray marching with 4 lod's for lighting\n\t//only 1 lod is rendered each step and lod's are switched each step for speed\n    vec2 c = vec2(0.);\n    float s = 0., im = 2.;\n    for (int i = 0; i < 64; i++) {\n        vec3 pd = rp+rd*s;\n        float ie = pow(im = mod(im,4.)+1., 2.),\n              od = df(pd, ie);\n        c += vec2( (df(pd+lightDirection*(ie*2.), ie)-od)/(ie*2.),\n                    .02)*pow(max(0.,(ie*.4-od))/(ie*.4),4.);\n        if (c.y >= 1.) break;\n        \n        s += od*(.5+hash3(pd)*.4);\n    }\n    c.x *= .07;\n    \n    fragColor = c.xyyy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3SRj", "name": "Circles without loops", "author": "calx", "description": "A set of circles or dotted line without looping", "tags": ["circleswithoutloops"], "likes": 1, "viewed": 155, "date": "1460209385", "time_retrieved": "2024-06-20T18:34:42.979041", "image_code": "float smoothv = 0.001;\nfloat maxCircles = 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (sin(iTime) * maxCircles) * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2  v = vec2(floor(uv.x + 0.5), 0.0);   \n       \n \tfloat d = distance(uv, v);\n    \n    float c = smoothstep(d-smoothv, d+smoothv, 0.2);\n    \n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3SRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3SRs", "name": "piano roll", "author": "tomaes", "description": "a scrolling piano.", "tags": ["2d", "art"], "likes": 1, "viewed": 205, "date": "1460836208", "time_retrieved": "2024-06-20T18:34:42.985630", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float t = iTime + 10.0;\n    vec3  c = vec3(1.0,1.0,1.0);\n    float tw = 1.0/12.0;\n    \n    uv.x += t*0.1;\n    \n    if (uv.y > 0.88 && uv.y < 1.0)\n        c = 1.0-c;\n\n    // split keys at the bottom\n    if (uv.y < 0.15)\n        uv.x += sin(uv.x*t*0.01)*0.2;\n    if (uv.y < 0.2)\n        uv.x += cos(uv.x*t*0.01)*0.02;\n    \n    uv.y += 0.08;\n    \n    // white keys + sepatation\n    if (uv.y > 0.2 && uv.y < 0.95)\n    {\n        c = vec3(1.0-uv.y*0.01,0.95,0.92);\n        \n        if (mod(uv.x, tw) < 0.002)\n        \tc = vec3(0.0,0.0,0.0);\n    }\n    \n\t// white keys shade\n    if (uv.y > 0.2 && uv.y < 0.95)\n    {        \n        if (mod(uv.x+0.08,tw) < 0.06)\n        \tc = vec3(1.0,1.0,0.99);\n    }\n\n    float p = mod(uv.x-0.05, tw*7.0);\n    \n\t// black keys\n    if ( uv.y > 0.55 && uv.y < 0.95 )\n    {\n\t\tif (\n            (p > 0.02  && p < 0.05)  // c#\n         || (p > 0.10  && p < 0.13)  // d#\n         || (p > 0.27  && p < 0.30)  // f#           \n         || (p > 0.35  && p < 0.38)  // g#           \n         || (p > 0.435 && p < 0.465) // a#           \n            )\n        \tc = vec3(uv.y * 0.2, uv.y * 0.15, 0.0);\n    }\n    \n    // black keys shading\n    if ( uv.y > 0.55 && uv.y < 0.95 )\n    {\n\t\tif (\n            (p > 0.02  && p < 0.028)  // c#\n         || (p > 0.10  && p < 0.108)  // d#\n         || (p > 0.27  && p < 0.278)  // f#           \n         || (p > 0.35  && p < 0.358)  // g#           \n         || (p > 0.435 && p < 0.442)  // a#           \n            )\n        \t//c = vec3(uv.y * 0.6, uv.y * 0.15, 0.0);\n            c = vec3(0.5,0.5,0.5);\n    }\n    \n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3SRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3Szs", "name": "3D Cellular Tiling", "author": "Shane", "description": "Creating a Voronoi surface feel with minimal instructions by way of a cellular 3D tile.", "tags": ["3d", "voronoi", "sss", "volumetric", "scattering", "cellular", "tiling", "cell"], "likes": 143, "viewed": 8262, "date": "1460906570", "time_retrieved": "2024-06-20T18:34:46.245347", "image_code": "/*\n\n    3D Cellular Tiling\n    ------------------\n    \n    Creating a Voronoi feel with minimal instructions by way of a 3D tile constructed via a \n\tsimplistic cellular pattern algorithm. It works surprisingly well under various situations,\n\tbut isn't a replacement for the standard 3D Voronoi algorithm.\n\n\tThis is a 3D counterpart to my 2D cellular tiling example. The link is below, where I explain\n\tthe process more thoroughly, for anyone interested. I came up with the idea for a repeatable\n\tcellular tile when experimenting with 3D Truchet tiles.\n\n\tNaturally, there are a few restrictions. The obvious one is that repeatable tiles with low\n\tobject density look very repetitive when you zoom out, so that has to be considered. The \n\tupside is quasi 3D celluar surfaces that are fast enough to include in a distance function.\n\n\tAnyway, the 3D tiling function is explained below. For anyone interested, the scene itself\n\tutilizes an oldschool, warping planes trick. Shadertoy user Branch uses it to great effect in \n\tthe example \"18756.2048d,\" which is well worth the look.\n\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\t18756.2048d - Branch\n\thttps://www.shadertoy.com/view/ld3XzS\n\n*/\n\n#define PI 3.14159265\n#define FAR 50.\n\n// Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.15;\nconst float freqB = 0.25;\nconst float ampA = 3.6;\nconst float ampB = .85;\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n) - 0.2, 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (six to eight spheres, in this case) \n// using the darken (min(src, dst)) blend at various 3D locations on a cubic tile. Make the \n// tile wrappable by ensuring the objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four spheres. Of course, there is 8-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's way, way lower. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.166));\n    \n}\n\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    // Draw four overlapping objects (spheres, in this case) using the darken blend \n    // at various positions throughout the tile.\n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    \n    // Add some smaller spheres at various positions throughout the tile.\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n    \n    // More is better, but I'm cutting down to save cycles.\n    //c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    //c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.); // Normalize.\n    \n}\n\n// The same as above, but with an extra two spheres. This is used by the bump map function,\n// which although expensive, isn't too bad. Just for the record, even bump mapping a\n// reasonably fast cellular function, like 8-Tap Voronoi, can still be a drain on the GPU.\n// However, the GPU can bump map this function in its sleep.\n//\nfloat cellTile2(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB)); }\n\n\n// There's a few simple, warping tricks being employed here. One is the oldscool, \"top and bottom\n// planes\" via \"abs(p.y).\" The planes are then twisted about the XY plane with respect to distance \n// using the 2D rotation function, \"rot2(p.z/12.),\" etc, then wrapped aound a curvy path, \"path(p.z).\"\n//\n// Finally, some surface detailing is added with a sinusoidal bottom layer, and the cellular layer \n// over the top of it. Normally, adding cellular layering utterly fries the GPU, but the \"cellTile\"\n// function used here merely makes it slightly uncomfortable. :)\n//\nfloat map(vec3 p){\n    \n    \n     float sf = cellTile(p*.25); // Cellular layer.\n    \n     p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z/12.)*p.xy; // Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.25)); // Sinusoidal layer.\n     \n     return 2. - abs(p.y) + n + sf; // Warped double planes, \"abs(p.y),\" plus surface layers.\n   \n\n     // Standard tunnel. Comment out the above first.\n     //vec2 tun = p.xy - path(p.z);\n     //return 3. - length(tun) - (0.5-surfFunc(p)) +  dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.333))*.5+.5;\n\n \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float noi = noise3D(p*64.);\n    float vor = cellTile2(p*.75);\n    \n    return vor*.98 + noi*.02;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 80; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return clamp(t, 0., FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n*/\n\n// Using a variation of IQ's AO function to calculate thickness, but with the normal flipped.\n// IQ uses a similar setup to calculate SSS... Subsurface AO, I guess you'd call it. :)\nfloat thickness(in vec3 p, in vec3 n){\n    \n    float sNum = 4.;\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<sNum + .001; i++ ){\n    \n        float hr = 0.05 + .4*i/sNum; \n        //vec3 rn = normalize(n + RandomHemisphereDir(n, hr)*rad*.5);\n        float dd = map(p - n*hr);\n        occ += (hr - min(dd, 0.))*sca;\n        sca *= .9;\n    }\n    return 1. - max(occ/sNum, 0.); \n    \n}\n\n/*\n// Shadows.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24;\n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    for (int i=0; i<maxIterationsShad; i++){\n    \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        // +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        dist += min(h, stepDist);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // Shadow value.\n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n/////\n// Code block to produce four layers of fine mist. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*2. + (cos(p.yzx) + 1. + iTime*4.)*1.57);\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n\n    float t = trig3(p*PI);\n\tp += (t - iTime*0.25);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*PI); \n\tp += (t - iTime*0.25)*0.7071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.7071;\n\n    t = trig3(p*PI);\n\tres += t*0.5;\n\t \n\treturn res/2.2071;\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Four layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/8.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<4; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(1./(1. + sDi*0.25 + sDi*sDi*0.05), 1.);\n\t    // Noise layer.\n        mist += trigNoise3D(ro/2.)*sAtt;\n        // Advance the starting point towards the hit point.\n        ro += rd*t/4.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/2. + hash31(ro)*0.1-0.05, 0., 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t//vec3 lookAt = vec3(0., 0.25, iTime*2.);  // \"Look At\" position.\n\t//vec3 camPos = lookAt + vec3(2., 1.5, -1.5); // Camera position, doubling as the ray origin.\n\t\n\tvec3 lookAt = vec3(0., 0.0, iTime*6. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0., 1, 8);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \n        // Texture scale factor.\n        const float tSize0 = 1./4.; \n    \t\n        //vec3 tsp = sp-vec3(path(sp.z), 0.);\n       \n    \t// Texture-based bump mapping.\n\t    //sn = doBumpMap(iChannel0, tsp*tSize0, sn, 0.025);//\n        \n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .2);///(1.+t*.5/FAR)\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + distlpsp*0.3); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.5;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n        \n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Obtaining the texel color. \n        vec3 ref = reflect(sn, rd);\n\n        // Object texturing.\n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = smoothstep(-.05, .95, texCol)*(smoothstep(-.5, 1., crv)*.75+.25);\n        \n    \t/////////   \n        // Translucency, courtesy of a mixture XT95 and IQ;s procedures - See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        //float th = thickness( sp, sn, 1., 1. );\n        float th = thickness( sp, sn);\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = max((tdiff + .25)*th*1.5, 0.);  \n        trans = pow(trans, 4.)*1.;        \n    \t////////        \n\n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading = 1.;// crv*0.5+0.5; \n    \t\n        // Shadows - They didn't add enough aesthetic value to justify the GPU drain, so they\n        // didn't make the cut.\n        //shading *= softShadow(sp, ld, 0.05, distlpsp, 8.);\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec + vec3(1, .6, .2)*spec*spec*spec*.5;\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*2.;\n        //sceneCol += vec3(1, .05, 0)*trans;\n        sceneCol += texCol*mix(vec3(1, .05, 0), vec3(1, .05, .15), abs(hf.y))*trans*6.;\n      \n        \n        /*\n        // Cool blue hilights. Adapted from numerous examples on here. Kali uses it to great effect.\n        float per = 10.;\n    \tfloat tanHi = abs(mod(per*.5 + t + iTime, per) - per*.5);\n    \tvec3 tanHiCol = vec3(0, .2, 1)*(1./tanHi*.2);\n        sceneCol += tanHiCol;\n        */\n        \n        \n        //vec3 refCol = vec3(.5, .7, 1)*smoothstep(.2, 1., noise3D((sp + ref*2.)*2.)*.66 + noise3D((sp + ref*2.)*4.)*.34 );\n        //sceneCol += refCol*.5;\n\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n        \n        //sceneCol = vec3(ao);\n\t   \n\t\n\t}\n       \n    // Blend the scene and the background with some very basic, 4-layered fog.\n    float mist = getMist(camPos, rd, light_pos, t);\n    vec3 sky = vec3(2.5, 1.75, .875)* mix(1., .72, mist)*(rd.y*.25 + 1.);\n    sceneCol = mix(sceneCol, sky, min(pow(t, 1.5)*.25/FAR, 1.));\n\n    // Clamp, perform rough gamma correction, then present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3Szs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3XDS", "name": "Valentiness", "author": "aetelani", "description": "Cute", "tags": ["fractal"], "likes": 1, "viewed": 126, "date": "1461175934", "time_retrieved": "2024-06-20T18:34:46.724383", "image_code": "// Distributed under CC-BY-NC-SA license (c) 2016 by Anssi Etelniemi, aetelani(a)live.com \nvec2 uv, z, z1;\n#define PI 3.14159\n//precision lowp float;\nfloat t;\nmat4 R3(vec3 ax, float angle);\n\n// z_n1 = z_n0^2 + constant\nvec2 cMul(vec2 a, vec2 b) {            \n    return vec2(mod(length(b), 0.4));\n    /*return sin(vec2(a.x * b.x - a.y * b.y,\n                    a.x * b.y + a.y * b.x\n               ));*/\n}\n\nmat2 R(float a) { // z\n    // xyz\n    mat4 r3 = R3(vec3(.0, 0., 1.), a);\n    // col-major.stpq\n    return mat2(r3[0].st, r3[1].st);\n//\t\treturn mat2(vec2(cos(a), sin(a)), vec2(-sin(a), cos(a)));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 Ry(float a) { // y\n    mat4 r3 = R3(vec3(0., 1., .0), a);\n    return mat2(r3[0].st, r3[1].st);\n}\n\nmat2 Rx(float a) { // x\n    mat4 r3 = R3(vec3(1., 0., .0), a);\n    return mat2(r3[0].st, r3[1].st);\n}\n\nmat4 R3(vec3 ax, float angle) {\n    vec3 axis = normalize(ax);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n/*\n [Mxx, Mxy, Mxz, Cx],\n [Myx, Myy, Myz, Cy],\n [Mzx, Mzy, Mzz, Cz],\n [Lx,  Ly,  Lz,   W]\n*/\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n\tuv = fragCoord.xy / iResolution.xy;    \n    const int depth = 10;\n    vec2 a = vec2(uv.x - .5, uv.y - .5);\n    vec2 c = vec2(0.6);\n\n    for(int i=0; i < depth; ++i) {\n        z =  cMul(z, z) + c * a * R(float(depth)+float(depth) + t);\n        c += sin(t) * 0.6;\n\t}\n\n    float dist = distance(a, z);\n    vec4 col = vec4(0.);\n\n    col.r = length(z);\n    col.g = dot(z, z) * .4;\n    if (col.g > 0.5) {\n        col.b  = length(cross(z.xyx, a.xyx));\n    } else if (length(a) > .7) {\n        col.r = vec4(1.0).r;\n\t}\n        \n\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3XR2", "name": "Greenpulse", "author": "vrav", "description": "learning exercise ch6, thebookofshaders.com", "tags": ["2d"], "likes": 0, "viewed": 127, "date": "1460234009", "time_retrieved": "2024-06-20T18:34:47.027437", "image_code": "uniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst vec3 RED = vec3(1.,0.,0.);\nconst vec3 GRN = vec3(0.,1.,0.);\nconst vec3 BLU = vec3(0.,0.,1.);\n\nfloat plot(vec2 st, float pct){\n    float d = 0.005;\n    return  smoothstep( pct-d, pct, st.y) - \n            smoothstep( pct, pct+d, st.y);\n}\n\nfloat bump(float x, float ofs, float p) {\n    return 1. - clamp(pow(abs(x+ofs)*2., p), 0., 1.);\n}\n\nvec3 addline(vec3 col, float line, vec3 linecol) {\n    return (1.-line)*col + line*linecol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    \n    float x = st.x*2. - 1.;\n    float r,g,b,w,e = 0.;\n    \n    x = floor(x*iResolution.x*.025);\n    x *= (1.-abs(sin(iTime*.2)))*2.;\n    \n    float p = 2.5;\n    r = bump(x, .5, p);\n    g = bump(x, 0., p);\n    b = bump(x,-.5, p);\n    w = bump(x, 1.2, p);\n    e = bump(x,-1.2, p);\n    \n    vec3 c = vec3(r,g,b);\n    c = mix(c, vec3(1.,0.,1.), w);\n    c = mix(c, vec3(1.,0.,1.), e);\n    \n    float rl = plot(st, r);\n    float gl = plot(st, g);\n    float bl = plot(st, b);\n    float wl = plot(st, w);\n    float el = plot(st, e);\n    \n    c = addline(c, rl, RED);\n    c = addline(c, gl, GRN);\n    c = addline(c, bl, BLU);\n    c = addline(c, wl, RED+BLU);\n    c = addline(c, el, RED+BLU);\n    \n    fragColor = vec4(c,1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3XW7", "name": "1D DCT test", "author": "anastadunbar", "description": "https://unix4lyfe.org/dct/\nThe green curve is made up of cosines.", "tags": ["test", "fft", "study", "fourier", "transform", "jpg", "jpeg"], "likes": 1, "viewed": 232, "date": "1459641964", "time_retrieved": "2024-06-20T18:34:47.027437", "image_code": "#define time iTime\n#define pi 3.14159265358979323\nfloat function(float x) {\n    return cos(x*40.*sin(time));\n}\nconst float count = 40.;\nfloat dct_1d(float freq) {\n    float sum = 0.;\n    for (float x=0.;x<count;x++) {\n        sum += function(x/count)*cos(pi*freq*(2.*x+1.)/(2.*count));\n    }\n    if (freq == 0.) { sum *= 1./sqrt(2.); }\n    return sum/2.;\n}\n#define clamps(x) clamp(x,0.,1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec3 color = vec3(0.);\n    float line_thickness = 0.005;\n    float line_sharpness = 200.;\n    color.r += 1.-clamps((abs(((function(p.x)+1.)/2.)-p.y)-line_thickness)*line_sharpness);\n    float c = 0.;\n    \n    const float loops = 30.;\n    #define x p.x\n    for (float i = 0.; i < loops; i++) {\n        float amp = dct_1d(i/2.);\n        c += cos(x*i*(pi/2.))*amp;\n    }\n    color.b = dct_1d(floor(p.y*loops)/2.)/(count/4.);\n    c /= count/2.;\n    color.g += 1.-clamps((abs(((c+1.)/2.)-p.y)-line_thickness)*line_sharpness);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcSDj", "name": "Perfect Flower", "author": "vox", "description": "Perfect Flower Forever", "tags": ["perfectflower"], "likes": 5, "viewed": 488, "date": "1461478803", "time_retrieved": "2024-06-20T18:34:47.027437", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/PI;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/PI;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/PI;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/PI;\n}\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 stair(vec2 x)\n{\n    return vec2(stair(x.x), stair(x.y));\n}\n\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\n\nvec3 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c)\n{\n    vec2 duv = b-p;\n    \n    vec2 xdir = c-b;\n    vec2 ydir = a-b;\n    float w = cross(xdir, ydir);\n    return vec3((dot(duv, normalize(xdir))), (dot(duv, normalize(ydir))), w);\n}\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec4 tree(vec4 uv)\n{\n    vec4 uv0 = uv;\n\n    mat4 last = mat4(0.0);\n    float mind = 1.0E32;\n    float omega = 0.0;\n    const int max_iterations = 16;\n    \n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n    \tfloat iteration = PI*2.0*(float(i)/(float(max_iterations) ));//*(1.0+saw(time+float(i)))));\n        \n        mat4 square = mat4(-1.0, -1.0, 0.0, 0.0,\n                           1.0, -1.0, 0.0, 0.0,\n                           1.0, 1.0, 0.0, 0.0,\n                           -1.0, 1.0, 0.0, 0.0);\n\n        float size =  .5;\n\n        float r = iteration;\n        float theta = iteration-time;\n        square = RotateZ(square, theta);\n        \n        vec2 center = vec2(sin(theta+time), cos(theta+time));\n        square = translate(square, center);\n\t\tcenter = square[1].xy;\n        float d = length(center-uv0.xy);\n        if(d < mind)\n        {\n            last = square;\n            mind = d;\n            omega = theta;\n        }\n    }\n    \n    vec2 center = last[1].xy;\n    vec3 uv1 = vec3(invBilinear(uv0.xy, last[0].xy, last[1].xy, last[2].xy));\n\n    return vec4(uv1.xy, mind, omega);\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5*uv.x;\n\telse\n\t\treturn 0.0;\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0+saw(time/4.0)*4.0;\n    float r = pow(log(length(uv)+1.), .75);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+theta/turns+iTime*.2), saw(theta/turns+iTime*.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 uv = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    float scale;\n    \n\tconst int max_iterations =4;\n\n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = PI*(float(i)/(float(max_iterations) ));\n        if(i <= 1)\n        {\n        \tscale = 2.0*PI+time*4.0*PI;\n            uv.xy = uv.xy*scale-scale/2.0;\n            if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n            uv.xy = RotateZ(uv.xy, time/PI+iteration);\n            uv.xy += .125*scale*vec2(sin(time/GR*.2345+iteration), cos(time/E*.345+iteration));\n            uv.xy = (saw(spiral(uv.xy)*2.0*PI)*2.0-1.0)*(GR+sin(time+iteration)/PI);\n        }\n    \telse\n        {\n        \tscale = GR+sin(time+iteration)/PI;//pow(amplitude, length(uv0*2.0-1.0)/sqrt(2.0)*sin(time*GR/2.0+float(i)-1.0));\n            uv.xy = uv.xy*scale-scale/2.0;\n        }\n        uv = tree(uv);\n        map += saw(uv.z+uv.w)*PI;//square(uv.xy, float(i))*noise;\n    }\n    \n    float map2 = 0.0;\n    /*\n    noise = 1.0;\n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        uv = spiral(uv);\n        map2 += uv.g*noise;\n        \n        noise *= clamp(.95-fwidth(map2), 0.0, 1.0);\n    }\n    */\n    \n    \n    \n    \n    fragColor.rg = uv.rg;//saw(uv.zw);//saw(uv.zw*PI);\n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    //fragColor = vec4(noise);\n    map = map+time;//map*PI + time*PI;\n    fragColor = vec4(vec3(saw(map+map2),\n                          saw(4.0*PI/3.0+map+map2),\n                          saw(2.0*PI/3.0+map+map2)),\n                     1.0);\n    return;\n/*\n\tconst int max_iterations = 8;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        noise += clamp(1.0-fwidth(map), 0.0, 1.0);\n        \n        uv = tree(uv); \n        \n        map += square(uv, float(i)/float(max_iterations))/noise;\n    } \n    map = map*PI + time;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcSRl", "name": "travelling light", "author": "tomaes", "description": "mhhm, ok? :)", "tags": ["2d", "light"], "likes": 1, "viewed": 98, "date": "1460799250", "time_retrieved": "2024-06-20T18:34:47.027437", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float t = mod(iTime+10.46, 1000.0);  \n    \n    float ox = sin(t*0.5)+0.5;\n    float oy = cos(t*0.5)+0.5;\n    float at = atan(uv.x-0.5,uv.y+0.5)*0.4; \n      \n    float d1 = distance(uv, vec2(0.25+ox,0.25));\n    float d2 = distance(uv, vec2(0.75,   0.75+oy));\n    float c = mod(sin(d1+d2),0.1)*(d1/d2);\n    c += 0.2*mod(sin(d1+d2+0.05),0.1)*(d1/d2);\n    \n\tfragColor = vec4(c+at,c*0.7,c*0.6, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcXD2", "name": "Rise of the Invaders - 231ch", "author": "iapafoto", "description": "An old shader, with 30 char less and with appropriate indentation (better in full screen)", "tags": ["2tweets", "invaders", "asciiart", "2tc15", "codegolf"], "likes": 34, "viewed": 1652, "date": "1461526586", "time_retrieved": "2024-06-20T18:34:47.027437", "image_code": "// Created by Sebastien Durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\n\n                    ////                     ////         \n                    ////                     ////\n                        ////             ////         \n                        void             ////\n                    mainImage(out vec4 o,vec2 d){\n                    float t=iTime; o+=1.-o+fract(\n                .3*t); d    *=.03;for(int    i=0 ,y;i\n                ++<7;) o    *=1.>mod(((y=    int(mod(\n            t-d.y/o,14.)))>3? 35552534e8:56869384.)/exp2(\n            float(y*7+int(abs(mod(d.x/o-7.*cos(t),14.)-7.\n            ))))    ,2.)?.5:1.;o.z*=2.;}/////////    ////\n            ////    /////////////////////////////    ////\n            ////    ////                     ////    ////\n            ////    ////                     ////    ////\n                        ////////    ////////   \n                        ////////    ////////   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcXD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddSRX", "name": "Participating Media  Experiment", "author": "tomkel", "description": "experiments with participating media. Lots wrong! ", "tags": ["procedural"], "likes": 22, "viewed": 409, "date": "1460741387", "time_retrieved": "2024-06-20T18:34:47.033565", "image_code": "const vec3 cLight \t\t= vec3( 1100.0,1100.0,1000.0 );\nconst vec4 cLightColour = vec4(1.0,1.0,1.0,1.0 ) ;\nconst float cScatter \t= 0.002;\t// scatter prob\nconst float cAbsorb \t= 0.001;\t// absorb prob\nconst float cG \t\t\t= -0.2;\t\t// Heney-Greenstein \"thick fog\" phase fn param. sign forard/backward, mag particle size\nconst float cIntensity \t= 120.0;\n\nconst float cA \t\t\t= 0.0;\nconst float cB \t\t\t= 1.0;\nconst float cC \t\t\t= 0.0;\n\nfloat sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    return distance( spherepos, raypos ) - r;\n}\n\nfloat atten( float d, float A, float B, float C, float intensity )\n{\n    return intensity / ( A*d*d + B*d + C );\n}\n\n\nvec4 getlight( vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    vec3  tolight = lightpos - position;\n    vec3 n = normalize( tolight );\n    return max( dot( normal, n ), 0.0 ) * cLightColour  * atten( length( tolight ), cA, cB, cC, cIntensity ); //cIntensity /  length( tolight) ;//, tolight );\n}\n\n\nfloat sdf( vec3 raypos )\n{ \n    vec3 rayposmod = mod( raypos,  vec3( 50.0,50.0,50.0 ));\n    return max( sphere( vec3( 25.0,25.0, 25.0), 10.0, rayposmod ), sphere( vec3( 1000.0,1000.0,1000.0 ), 100.0, raypos )  );\n}\n\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ) - sdf( raypos - vec3( delta,0,0 ) );\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ) - sdf( raypos - vec3( 0,delta,0 ) );\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ) - sdf( raypos - vec3( 0,0,delta ) );\n    return vec3( -dx,-dy,-dz );\n}\n\nfloat hg( float costheta )\n{\n    const float g = cG; \n    float num =  1.0 - g*g ;\n    float denom = 2.0 * pow( 1.0 + g*g - 2.0 * g * costheta, 3.0/2.0 );\n    return cScatter * num / denom ;\n}\n\nfloat outsc( float d )\n{\n    const float ab = cAbsorb;\n    const float sc = cScatter;\n    const float ex = sc + ab;\n    \n    return exp(-ex*d );\n}\n\nvec4 inscray( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    vec4 lighting = cLightColour  * atten( distance( origin, cLight  ), cA, cB, cC, cIntensity );\n    for ( int i = 0; i < 100; i++ )\n    {\n        float dist =  distance( p , cLight ) ; \n        float step = sdf(p); \n   \n        if ( step > dist )\n        {\n            return lighting;\n        } \n        else if ( step  <  ep )\n        {\n           return vec4(0,0,0,0);\n                 \n        } \n        \n        p += ray * step;\n    } \n    \n     return lighting;\n}\n\n\nvec4 march( vec3 ray, vec3 origin, float ep, vec3 axis  )\n{\n    vec3 p = origin;\n    const float stepsize = 4.0;\n    vec4 inscattered =vec4( 0,0,0,0 );\n    for ( int i = 0; i < 256; i++ )\n    {\n        float d = length( p -origin );\n        float step = min( sdf(p), stepsize );\n        if ( step  <  ep || d > 1000.0 )\n        {\n            vec3 normal = normalize( grad( p, 0.1 ) );\n            vec4 s = getlight( -normal, p,  cLight, vec4(1.0,1.0,1.0,1.0 )); \n            \n            return s * vec4( 0.7,0.7,1.0,1.0) * outsc(d) + inscattered;\n                 \n        }\n       \n        vec3 isray = normalize ( cLight-p   );\n        \n       inscattered +=  inscray( isray, p, 1.0 ) * outsc(d) * hg( dot( -isray, normalize(ray) ) ) * step;\n       \n        \n        p += ray * step;\n    }\n    \n    return inscattered;\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec3 origin = vec3( 0.0, 0.0,  -250.0  );\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    float angle =  (iMouse.x / iResolution.x - 0.5 ) * 3.142 * 2.0;\n    origin = rotatevecY( origin, iTime );\n    ray = rotatevecY( ray, iTime );\n\t\n   vec3  axis = rotatevecY( vec3(0,0,1),  angle );\n    \n\tfragColor = march( ray, origin + vec3( 1000.0, 1000.0, 1000.0 ), 0.01, axis );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddSW2", "name": "Moebius Strip", "author": "dr2", "description": "Escher's static ants are now marching spiders", "tags": ["escher", "spider", "moebius"], "likes": 10, "viewed": 552, "date": "1461666087", "time_retrieved": "2024-06-20T18:34:47.046435", "image_code": "// \"Moebius Strip\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Escher's static ants are now marching spiders.\n\n// 2 versions:\n//   original is slow and GPU-demanding\n//   new is faster and more resource friendly\n\n#define FAST_VERS 1 // set = 0 for old version\n\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\n#if FAST_VERS\n#define N_SPD 9\n#else\n#define N_SPD 3   // increase if your GPU can handle it\n#endif\n\n#if ! FAST_VERS\nmat3 spdMat[N_SPD];\nvec3 spdPos[N_SPD];\n#endif\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir[4], qHit;\nfloat dstFar, tCur, mobRad, legLenU, legLenD, bdyHt, spdVel, nSpd;\nint idObj;\nconst int idMob = 1, idBdy = 11, idHead = 12, idEye = 13, idAnt = 14, idLegU = 15,\n   idLegD = 16;\n\nfloat MobiusDf (vec3 p, float r, vec2 b, float rc)\n{\n  vec2 q;\n  float a;\n  q = vec2 (length (p.xz) - r, p.y);\n  a = atan (p.z, p.x);\n  q = Rot2D (q, 0.5 * a);\n  qHit = vec3 (q, a);\n  return 0.7 * (length (max (abs (q) - b, 0.)) - rc);\n}\n\nfloat ShpCylDf (vec3 p, vec3 v, float md, float r, float rf)\n{\n  float len, s;\n  len = length (v);\n  v = normalize (v);\n  s = clamp (dot (p, v), 0., len);\n  p -= s * v;\n  s = s / len - md;\n  return length (p) - r * (1. - rf * s * s);\n}\n\nfloat SpdDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 5.5;\n  p *= szFac;\n  dMin *= szFac; \n  p.y -= bdyHt + 0.7;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  q -= vec3 (0., 0.15, -0.3);\n  d = ShpCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), 0., 0.07, 0.7);\n  if (d < dMin) { dMin = d;  idObj = idAnt; }\n  p.y += bdyHt;\n  for (int j = 0; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * ShpCylDf (q, kneePos[j] - hipPos[j], 0., 0.25, 0.3);\n    if (d < dMin) { dMin = d;  idObj = idLegU;  qHit = q; }\n    q = p - kneePos[j];\n    d = 0.6 * ShpCylDf (q, footPos[j] - kneePos[j], 0.3, 0.2, 1.3);\n    if (d < dMin) { dMin = d;  idObj = idLegD;  qHit = q; }\n  }\n  dMin /= szFac;\n  return dMin;\n}\n\n#if FAST_VERS\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, aq, na;\n  dMin = dstFar;\n  d = MobiusDf (p, mobRad, vec2 (0.07, 0.8), 0.02);\n  if (d < dMin) { dMin = d;  idObj = idMob; }\n  q = p;\n  a = tCur * spdVel / (2. * pi * mobRad);\n  q.xz = Rot2D (q.xz, a);\n  na = floor (nSpd * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / nSpd;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += mobRad;\n  if (PrCylDf (q.xzy, 1., 0.7) < dMin) {\n    a += aq;\n    if (2. * floor (0.5 * na) != na) a += 2. * pi;\n    q.xy = Rot2D (q.xy, 0.5 * a);\n    dMin = SpdDf (q, dMin);\n  }\n  return dMin;\n}\n\n#else\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  d = MobiusDf (p, mobRad, vec2 (0.07, 0.8), 0.02);\n  if (d < dMin) { dMin = d;  idObj = idMob; }\n  for (int k = 0; k < N_SPD; k ++) {\n    q = p - spdPos[k];\n    if (PrCylDf (q.xzy, 1., 0.7) < dMin) {\n      q = spdMat[k] * q;\n      q.xy = vec2 (q.y, - q.x);\n      dMin = SpdDf (q, dMin);\n    }\n  }\n  return dMin;\n}\n\n#endif\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n#if FAST_VERS\n  for (int j = 0; j < 120; j ++) {\n#else\n  for (int j = 0; j < 60; j ++) {\n#endif\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvoid Setup ()\n{\n  vec3 v;\n  vec2 ca, sa;\n  float gDisp, a, az, fz, d, ll;\n  nSpd = float (N_SPD);\n  spdVel = 1.5;\n  for (int j = 0; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];  hipPos[j + 4].x *= -1.;\n  }\n  gDisp = spdVel * tCur;\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = 0; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) +\n       mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n#if ! FAST_VERS\n  for (int k = 0; k < N_SPD; k ++) {\n    a = tCur * spdVel / (2. * pi * mobRad) + (4. / nSpd) * pi * float (k);\n    spdPos[k] = vec3 (mobRad, 0., 0.);\n    spdPos[k].xz = Rot2D (spdPos[k].xz, a);\n    ca = vec2 (cos (a), cos (-0.5 * a));\n    sa = vec2 (sin (a), sin (-0.5 * a));\n    spdMat[k] = mat3 (ca.y, - sa.y, 0., sa.y, ca.y, 0., 0., 0., 1.) *\n                mat3 (ca.x, 0., - sa.x, 0., 1., 0., sa.x, 0., ca.x);\n  }\n#endif\n}\n\nvec3 SpdCol (vec3 vn)\n{\n  vec3 col;\n  if (idObj == idBdy) {\n    col = mix (vec3 (0.9, 0.9, 0.1), vec3 (0.2, 0.5, 0.2),\n      SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = vec3 (0.2, 0.5, 0.2);\n    if (qHit.z > 0.4) col = mix (vec3 (0.2, 0.05, 0.05), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z < 0.6) ? vec3 (1., 0., 0.) : vec3 (0.9, 0.9, 0.1);\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (vec3 (0.2, 0.5, 0.2), vec3 (0.9, 0.9, 0.1), \n       SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec3 (0.7, 0.7, 0.3);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, f, spec, cd, cs;\n  int idObjT;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idMob) {\n      if (abs (qHit.y) > 0.6 ||  mod (10. * (qHit.z / pi + 1.), 1.) > 0.7) {\n        col = vec3 (0.3, 0.3, 0.33);\n        spec = 0.1;\n        f = 5.;\n      } else {\n        col = vec3 (0.4, 0.2, 0.2);\n        spec = 0.5;\n        f = 0.2;\n      }\n      vn = VaryNf (30. * ro, vn, f);\n    } else if (idObj >= idBdy) {\n      col = SpdCol (vn);\n      spec = 1.;\n    }\n    cd = 0.;\n    cs = 0.;\n    for (int k = 0; k < 4; k ++) {\n      cd += max (dot (vn, ltDir[k]), 0.);\n      cs += pow (max (0., dot (ltDir[k], reflect (rd, vn))), 64.);\n    }\n    col = col * (0.1 + 0.5 * cd + 0.5 * spec * cs);\n  } else col = vec3 (0.2, 0.3, 0.4);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  az = 0.1 * tCur;\n  el = 0.2 * pi * cos (0.06 * tCur);\n  dstFar = 20.;\n  mobRad = 3.;\n  Setup ();\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = vuMat * normalize (vec3 (uv, 3.5));\n  ro = vuMat * vec3 (0., 0., -12.);\n  ltDir[0] = normalize (vec3 (1., 1., 1.));\n  ltDir[1] = normalize (vec3 (1., 1., -1.));\n  ltDir[2] = normalize (vec3 (-1., -1., 1.));\n  ltDir[3] = normalize (vec3 (-1., -1., -1.));\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddSW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddSWX", "name": "Plasma Prima 2", "author": "hobscure", "description": "Prima", "tags": ["sinusworm"], "likes": 2, "viewed": 84, "date": "1461871388", "time_retrieved": "2024-06-20T18:34:47.215340", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-(0.05+sin(iTime)/10.0), pct, st.y) - \n          smoothstep( pct, pct+(0.05+sin(iTime)/10.0), st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec3 color = vec3(st.y * sin(iTime));\n    \n    float v = (cos((st.x * 10.0) + iTime * 1.0) + cos((st.x * 10.0)*2.0/3.0*3.1415 + iTime * 1.0) )/5.0 + 0.1;\n    float v2 = v +  sin((st.x * 20.0)*100.0*3.1415 + iTime * 1.0) / 10.0  ;\n    float v3 = (cos((st.x*sin(st.y) * 10.0) + iTime * 1.0) + cos((st.x * 10.0)*2.0/3.0*3.1415 + iTime * 1.0) )/5.0 + 0.5;\n    \n    float pct = plot(st+vec2(0., -0.3) ,v3);\n    float pct2 = plot(st ,v2);\n\tfloat pct3 = plot(st+vec2(0., 0.2) ,v);\n\n    vec3 bg = vec3(0., 1., 0.);\n    vec3 clr = vec3(pct+pct2+pct3);\n    \n    color = (clr*color+clr)*vec3(1.0,0.0,0.0);\n\tcolor += bg;\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddSzl", "name": "First Attempt - Ray Marching", "author": "Icohedron", "description": "My first attempt at Distance Field Ray Marching after a few hours of research on the topic, as well as trial and error.\nI'm a newbie so don't be so harsh! Feedback is highly appreciated!", "tags": ["3d", "raymarching", "fractal", "distancefield", "phong", "lighting"], "likes": 12, "viewed": 298, "date": "1461003766", "time_retrieved": "2024-06-20T18:34:48.221487", "image_code": "/* Distance Field Ray Marching\n * Made by Icohedron\n *\n * I'm still learnin'.\n * The journey is more important than what you get in the end.\n *\n * Big thanks to Inigo Quilez's excellent articles and presentations\n * http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n * http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n * http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n *\n * I do not claim ownership for any of the code used below. (Variations of it have been used soooo many times already so...)\n * Feel free to use it yourself.\n\n * Tips? Tricks? Feedback is highly appreciated!\n */\n\n#define FOV 90.0\n#define MAX_STEPS 64\n#define STEP_PRECISION 0.001\n#define NORMAL_PRECISION  0.001\n#define SHININESS 8.0\n#define CLIP_FAR 32.0\n#define AO_SAMPLES 5.0\n#define SHADOW_ITERATIONS 32\n#define FOG_MULTIPLIER 0.08\n\n//// Primitive Shapes / Distance Fields ////\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdPlaneXZ(vec3 p) {\n\treturn p.y;\n}\n\n// 3D Fractal - \"Mandebulb\"\nfloat mandelbulb(vec3 p) {\n\tvec3 z = p;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 32 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, 8.0-1.0)*8.0*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,8.0);\n\t\ttheta = theta*8.0;\n\t\tphi = phi*8.0;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=p;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n//// The Scene / Combined Distance Fields ////\n\nfloat map(vec3 p) {\n    float dist = sdPlaneXZ(p - vec3(1.0, -1.0, 0.0));\n    dist = min(dist, udRoundBox(p - vec3(-1.0, 0.0, 0.75), vec3(0.8), 0.1));\n    dist = min(dist, sdSphere(p - vec3(1.5, 0.0, 0.75), 1.0));\n    dist = min(dist, mandelbulb(p - vec3(0.0, 0.0, -1.5)));\n    return dist;\n}\n\n//// Distance Field Ray Marching ////\n\nfloat march(vec3 rOrigin, vec3 rDirection) {\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rOrigin + rDirection * totalDistance;\n        float dist = map(p);\n        totalDistance += dist;\n        if (dist < STEP_PRECISION) break;\n    }\n    return totalDistance;\n}\n\n//// Calculate Surface Normal ////\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(NORMAL_PRECISION, 0.0, 0.0)) - map(p - vec3(NORMAL_PRECISION, 0.0, 0.0)),\n        map(p + vec3(0.0, NORMAL_PRECISION, 0.0)) - map(p - vec3(0.0, NORMAL_PRECISION, 0.0)),\n        map(p + vec3(0.0, 0.0, NORMAL_PRECISION)) - map(p - vec3(0.0, 0.0, NORMAL_PRECISION))\n    ));\n}\n\n//// Ambient Occlusion ////\n\nfloat calcAmbientOcclusion(vec3 p, vec3 surfaceNormal) {\n   float r = 0.0;\n   float w = 1.0;\n   for (float i = 0.0; i <= AO_SAMPLES; i++)\n   {\n      float d0 = i / AO_SAMPLES;\n      r += w * (d0 - map(p + surfaceNormal * d0));\n      w *= 0.3;\n   }\n   return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//// Soft Shadows ////\n\nfloat softShadow(vec3 rOrigin, vec3 rDirection, float start, float end, float k) {\n\tfloat shade = 1.0;\n    float dist = start;\n    float stepDistance = end / float(SHADOW_ITERATIONS);\n    for(int i = 0; i < SHADOW_ITERATIONS; i++) {\n\t\tfloat h = map(rOrigin + rDirection * dist);\n        shade = min(shade, k * h / dist);\n        dist += clamp(h, 0.02, 0.1);\n        if (h < 0.001 || dist > end) break;\n    }\n    return clamp(shade, 0.0, 1.0);\n}\n\n//// Fog ////\n\nvoid applyFog(inout vec3 color, vec3 fogColor, float dist) {\n    float fogFactor = 1.0 - exp(-dist * FOG_MULTIPLIER);\n    color = mix(color, fogColor, fogFactor);\n}\n\n//// Phong Lighting /////\n\nvoid calcLighting(inout vec3 color, vec3 surfacePos, vec3 cameraPos) {\n    vec3 lightPos = vec3(3.0 * cos(0.75 * iTime), 2.0, 3.0 * sin(0.75 * iTime));\n    vec3 lightColor = vec3(0.9, 0.8, 0.75);\n    float lightIntensity = 2.0;\n    \n    vec3 surfaceNormal = getNormal(surfacePos);\n    vec3 lightVector = lightPos - surfacePos;\n    float distanceToLight = length(lightVector);\n    float attenuation = lightIntensity * min(1.0 / distanceToLight, 1.0);\n    lightVector = normalize(lightVector);\n    vec3 viewDirection = normalize(cameraPos - surfacePos);\n    \n    float NdotL = max(0.0, dot(surfaceNormal, lightVector));\n    float ambient = 0.1;\n    float diffuse = NdotL;\n    float specular = NdotL * pow(max(0.0, dot(reflect(-lightVector, surfaceNormal), viewDirection)), SHININESS);\n    \n    float ambientOcclusion = calcAmbientOcclusion(surfacePos, surfaceNormal);\n    float shadow = softShadow(surfacePos, lightVector, 0.02, distanceToLight, 16.0);\n    \n    color = max((ambient + ((diffuse + specular) * attenuation * lightColor)) * ambientOcclusion * shadow * color, ambient * ambientOcclusion * color);\n}\n\n//// MAIN FUNCTION ////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cPosition = normalize(vec3(sin(0.5 * iTime), 1.0, cos(0.5 * iTime))) * 4.0;\n    \n    vec3 cForward = normalize(cLookAt - cPosition);\n    vec3 cRight = normalize(cross(cForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cUp = normalize(cross(cForward, -cRight));\n    \n    float fovFactor = tan(radians(FOV / 2.0));\n    \n    vec3 cROrigin = cPosition;\n    vec3 cRDirection = normalize(cForward + cRight * uv.x * fovFactor + cUp * uv.y * fovFactor);\n    \n    float dist = march(cROrigin, cRDirection);\n    \n    vec3 fogColor = vec3(0.0);\n    if (dist >= CLIP_FAR) {\n        fragColor = vec4(fogColor, 0.0);\n        return;\n    }\n    \n    vec3 color = vec3(1.0);\n    calcLighting(color, cROrigin + cRDirection * dist, cPosition);\n    applyFog(color, fogColor, dist);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddXDf", "name": "FINALLY Correct (..?)", "author": "vox", "description": "FINALLY Correct (..?)", "tags": ["finallycorrect"], "likes": 1, "viewed": 433, "date": "1461936574", "time_retrieved": "2024-06-20T18:34:48.221487", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*iTime/E)\n#define saw(x) (acos(cos(x))/PI)\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\n\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\n\nvec2 mobius(vec2 uv)\n{\n    float turns = 6.0;//saw(time)*3.0+3.0;\n    uv = rotatez(uv.xy, PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    vec2 xy = rotatez(uv.xy, PI*2.0*(rot)+PI/turns).xy;\n    xy = sign(xy)*log(abs(xy));\n    return vec2(saw(theta*turns), saw(xy.x*PI*2.0));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = exp(-saw(time)*2.0);\n    uv = uv*scale-scale/2.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    uv = normalize(uv)/log(r+1.0);\n    uv += sin(vec2(time, time/PI*E*GR))*scale*4.0*PI;\n    uv = mobius(uv); \n    \n    const int max_iterations =1;\n    \n    \n    float dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n    float map = sqrt(dist)*PI;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n     \tuv = uv*2.0-1.0;\n        scale = exp(-saw(time+float(i))*2.0);\n        uv *= scale;\n        r = length(uv);\n        uv = normalize(uv)/log(r+1.0);\n  \t  \tuv += sin(vec2(time/PI*E*GR, time))*scale*4.0*PI;\n        uv = mobius(uv);\n        \n        dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n        map += sqrt(dist)*PI;\n    }\n\n    fragColor = texture(iChannel0, uv);\n    \n    fragColor = smoothstep(0.0, .75, map)*vec4(phase(map*2.0+time), 1.0);\n    fragColor = vec4(uv, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddXDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddXWf", "name": "Rectangle with a highlight", "author": "elpuri", "description": "For selecting things", "tags": ["2d", "ui"], "likes": 4, "viewed": 184, "date": "1461915751", "time_retrieved": "2024-06-20T18:34:48.457823", "image_code": "float distanceToPerimeter(vec2 p, vec2 bounds, float radius)\n{\n\treturn length(max(abs(p) - bounds, 0.0)) - radius;\n}\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord - iResolution.xy * 0.5;\n    float radius = 6.0;\n\tvec2 bounds = vec2(170.0 - radius, 120.0 - radius);\n\tconst float w = 8.0;\n    float d = distanceToPerimeter(p, bounds, radius);\n    float innerStep = smoothstep(0.25, 1.75, d);\n    float outerStep = smoothstep(w - 0.75, w + 0.75, d);\n    float c = 0.3 + innerStep * 0.7 - outerStep;\n    float inBorder = cubicPulse(w * 0.5 + 0.5, w * 0.2, d); \n\tvec2 texCoord = vec2(fragCoord/ iResolution.xy);\n    vec4 bgColor = texture(iChannel0, texCoord);\n    \n    const float highlightSpeed = 0.66;\n    const float highlightWidth = 0.13;\n    \n    float angle = (atan(p.y, p.x * bounds.y / bounds.x) / 3.1415 + 1.0) * 0.5;\n    angle = mod(angle + iTime * highlightSpeed, 1.0);\n    angle = cubicPulse(highlightWidth, highlightWidth, angle) * inBorder;\n    vec4 frameColor = vec4(1.0, 0.2, 0.5, c);\n    frameColor.rgb = mix(frameColor.rgb, vec3(1.0, 0.8, 0.9), angle);\n    fragColor = vec4(mix(bgColor.rgb, frameColor.rgb, frameColor.a), 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddXWj", "name": "7ujuK7ehQST", "author": "diegov", "description": "spheres", "tags": ["raymarching"], "likes": 0, "viewed": 124, "date": "1461617133", "time_retrieved": "2024-06-20T18:34:48.457823", "image_code": "float epsilon = 0.003;\n\nfloat sceneDistance(vec3 point) {\n    if (point.z > 0.65) {\n        return 0.65 - point.z;\n    }\n    float currMin = 100000000.0;\n    for (int j = 0; j < 10; ++j) {\n        float jf = float(j);\n        vec3 sphereCentre = vec3(sin(iTime / 2.0 + jf) * 0.4, cos(iTime / 3.1 + jf + 0.5) * 0.2, \n                                 cos(sin(iTime / 14.43 + jf * 3.0) * 5.0) * 0.5);\n        float dist = length(point - sphereCentre) - 0.1;\n        currMin = min(currMin, dist);\n    }\n    return min(currMin, 0.65 - point.z);\n}\n\nvec3 getNormal(vec3 point) {\n    return normalize(vec3(sceneDistance(vec3(point.x + epsilon, point.y, point.z)) - \n                          \tsceneDistance(vec3(point.x - epsilon, point.y, point.z)),\n                          sceneDistance(vec3(point.x, point.y + epsilon, point.z)) -\n                          \tsceneDistance(vec3(point.x, point.y - epsilon, point.z)),\n                          sceneDistance(vec3(point.x, point.y, point.z + epsilon)) - \n                          \tsceneDistance(vec3(point.x, point.y, point.z - epsilon))));\n}\n\nbool isLit(vec3 point, vec3 light, vec3 normal) {\n    vec3 direction = normalize(light - point);\n    vec3 curr = point + normal * epsilon * 1.1;\n    \n    for (int i = 0; i < 60; ++i) {\n        float dist = sceneDistance(curr);\n        float lightDist = length(light - curr);\n        if (lightDist < dist) {\n            return true;\n        }\n        if (dist < epsilon) {\n            return false;\n        }\n        curr = curr + direction * dist;\n    }\n    return false;\n}\n\nfloat lightContribution(vec3 point, vec3 light, vec3 normal) {\n    float lightContribution;\n    if (isLit(point, light, normal)) {\n    \tvec3 lightDist = light - point;\n        float lightDivisor = sqrt(1.0 + length(lightDist));\n        lightContribution = clamp(dot(normalize(lightDist), normal) / lightDivisor, 0.0, 1.0);\n    } else {\n    \tlightContribution = 0.0;\n    }\n    return lightContribution;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.y) - vec2(0.75, 0.5);\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n\tvec3 direction = normalize(cross(right, up) + vec3(0.5 * uv.x, 0.5 * uv.y, 0.0));\n    \n    float travelled = 0.0;\n    \n    vec3 camera =  vec3(uv / 1.6, -0.8);\n    \n    vec3 light1 = vec3(0.9, 0.5, -1.8);\n    vec3 light2 = vec3(-0.7, 1.5, -1.4);\n    \n    vec3 curr = camera;\n    for (int i = 0; i < 50; ++i) {\n        float dist = sceneDistance(curr);\n        travelled += dist;\n        \n        if (dist < epsilon) {\n            \n            vec3 normal = getNormal(curr);\n            float lightContribution1 = lightContribution(curr, light1, normal);\n            float lightContribution2 = lightContribution(curr, light2, normal);\n            \n            fragColor = vec4(1.0, 0, 0, 1) * (lightContribution1 + lightContribution2) / 1.5;\n            return;\n        }\n        if (travelled > 10.0) {\n            break;\n        }\n        curr = curr + (direction * dist);\n    }\n    \n    fragColor = vec4(0, 0, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddXWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjSzt", "name": "Star corona", "author": "toninoni", "description": "Just playing around with flight404's main sequence shader.", "tags": ["star", "corona", "astronomy"], "likes": 9, "viewed": 254, "date": "1460105117", "time_retrieved": "2024-06-20T18:34:48.457823", "image_code": "// This is just a dirty customisation test of the main sequence star\n// shader in https://www.shadertoy.com/view/4dXGR4# by\n// flight404\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e5);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat scale = 0.1;\n\tfloat brightness\t= 0.1;\n\t\n\tvec3 white\t\t\t= vec3( 0.8, 0.8, 0.8 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.28318530718;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=1; i++ ){\n\t\tfloat power = pow( 9.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 1.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 2.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0 * scale;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0 * scale;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\n\t\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( corona * white);\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtSD4", "name": "saturn", "author": "substack", "description": "implicit function ringed planet", "tags": ["implicit"], "likes": 9, "viewed": 706, "date": "1459468150", "time_retrieved": "2024-06-20T18:34:49.633862", "image_code": "//glsl-noise:\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat torus (vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\nmat4 scale (float x, float y, float z) {\n  return mat4(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);\n}\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvec3 sunpos = vec3(20,10,20);\nvec2 model(vec3 p) {\n  mat4 m = invert(scale(1.8,0.3,1.8));\n  float ring = torus(vec3(m*vec4(p,1)),vec2(4.5,0.5))\n    + snoise(p*8.0)*0.05;\n  float planet = sphere(p,4.0);\n  float sun = sphere(p-sunpos,2.0);\n  return vec2(min(ring,min(planet,sun)));\n}\n\nvec3 calcNormal(vec3 pos) {\n  const float eps = 0.002;\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(v1*model(pos + v1*eps).x\n    + v2*model(pos + v2*eps).x\n    + v3*model(pos + v3*eps).x\n    + v4*model(pos + v4*eps).x);\n}\n\nconst int steps = 25;\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n  for (int i = 0; i < steps; i++) {\n    if (latest < precis || dist > maxd) break;\n    vec2 result = model(rayOrigin + rayDir * dist);\n    latest = result.x;\n    type = result.y;\n    dist += latest;\n  }\n  if (dist < maxd) res = vec2(dist, type);\n  return res;\n}\n\nvec2 raytrace(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 50.0, 0.001);\n}\n\nvec2 square(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 camera(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n  return mat3(uu, vv, ww);\n}\n\nvec3 camera(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = lookAt(origin, target, 0.0);\n  return camera(camMat, screenPos, lensLength);\n}\n\nvec3 lighting (vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n  vec3 lin = vec3(0.0);\n  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n  float dif = max(dot(nor,lig),0.0);\n  lin += dif*vec3(2);\n  lin += vec3(0.05);\n  return mal*lin;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float cameraAngle = 0.2 * t;\n  vec3 rayOrigin = vec3(18.0 * sin(cameraAngle), 2.2, 18.0 * cos(cameraAngle));\n  vec3 rayTarget = vec3(0, 0, 0);\n  vec2 screenPos = square(iResolution.xy);\n  float lensLength = 2.0;\n  vec3 rayDirection = camera(rayOrigin, rayTarget, screenPos, lensLength);\n  vec2 collision = raytrace(rayOrigin, rayDirection);\n  if (collision.x > -0.5) {\n    vec3 pos = rayOrigin + rayDirection * collision.x;\n    if (length(pos) > 25.0 && length(pos-vec3(sunpos))<=5.0) { // sun\n      fragColor = vec4(1,1,1,1);\n    } else if (length(pos) <= 6.0) { // planet\n      vec3 nor = calcNormal(pos);\n      vec3 mat = (vec3(0.9,0.75,0.6+sin(pos.y*2.0+3.0)*0.05))*vec3(\n        sin(pos.y*2.0*sin(pos.y*2.5)+sin(pos.y*2.0)+snoise(pos*3.0)*0.4)*0.05+0.6\n      );\n      vec3 col = lighting(pos, nor, rayDirection, collision.x, mat);\n      col = pow(clamp(col,0.0,1.0), vec3(1.2));\n      fragColor = vec4(col, 1.0);\n    } else { // ring\n      float edge = length(pos)+snoise(pos*8.0)*0.03;\n      vec3 col = vec3(0.95,0.8,0.7)*vec3(\n        sin(1.5+sqrt(length(pos)*4.0)*2.0+sqrt(sin(length(pos)*8.1))\n          +snoise(pos*12.0)*0.3)*0.2+0.6)\n        * (abs(edge-8.6)<0.1?0.2:1.0)\n      ;\n      if (length(pos)>=10.0) col = vec3(0,0,0);\n      else if (abs(pos.y)>0.35) col = vec3(0,0,0);\n      else {\n        vec3 p = normalize(-sunpos)*7.5;\n        col *= min(1.0,(length(pos-p)-4.0)/4.0);\n      }\n      fragColor = vec4(col, 1.0);\n    }\n  } else {\n    fragColor = vec4(vec3(pow(snoise(rayDirection*128.0),4.0)),1);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtSRX", "name": "Poorly implemented 2D metaballs", "author": "tomator", "description": "Click to move subtractive metaball. Change ANTIALIAS to 1 for better performance or comment it out to disable it entirely.", "tags": ["2d", "metaballs", "newbie"], "likes": 9, "viewed": 644, "date": "1460951444", "time_retrieved": "2024-06-20T18:34:49.633862", "image_code": "struct Metaball{\n    vec2 pos;\n    float r;\n    vec3 col;\n};\n\nvec4 calcball( Metaball ball, vec2 uv)\n{\n    float dst = ball.r / (pow(abs(uv.x - ball.pos.x), 2.) + pow(abs(uv.y - ball.pos.y), 2.));\n    return vec4(ball.col * dst, dst);\n}\n\nvec3 doballs( vec2 uv )\n{\n    Metaball mouse;\n    mouse.pos = iMouse.xy / iResolution.yy;\n    mouse.r = .015;\n    mouse.col = vec3(.5);\n    \n    Metaball mb1, mb2, mb3, mb4;\n    mb1.pos = vec2(1.3, .55+.2*sin(iTime*.5)); mb1.r = .05; mb1.col = vec3(0., 1., 0.);\n    mb2.pos = vec2(.6, .45); mb2.r = .02; mb2.col = vec3(0., .5, 1.);\n    mb3.pos = vec2(.85, .65); mb3.r = .035; mb3.col = vec3(1., .2, 0.);\n    mb4.pos = vec2(1.+.5*sin(iTime), .2); mb4.r = .02; mb4.col = vec3(1., 1., 0.);\n    \n    vec4 ball1 = calcball(mb1, uv);\n    vec4 ball2 = calcball(mb2, uv);\n    vec4 ball3 = calcball(mb3, uv);\n    vec4 ball4 = calcball(mb4, uv);\n    \n    vec4 subball1 = calcball(mouse, uv);\n    \n    float res = ball1.a + ball2.a + ball3.a + ball4.a;\n    res -= subball1.a;\n    float threshold = res >= 1.5 ? 1. : 0.;\n    \n    vec3 color = (ball1.rgb + ball2.rgb + ball3.rgb + ball4.rgb - subball1.rgb) / res;\n    color *= threshold;\n    color = clamp(color, 0., 1.);\n\treturn color;\n}\n\n#define ANTIALIAS 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    vec3 color = doballs(uv);\n    \n    #ifdef ANTIALIAS\n    float uvs = .75 / iResolution.y;\n    color *= .5;\n    color += doballs(vec2(uv.x + uvs, uv.y))*.125;\n\tcolor += doballs(vec2(uv.x - uvs, uv.y))*.125;\n    color += doballs(vec2(uv.x, uv.y + uvs))*.125;\n    color += doballs(vec2(uv.x, uv.y - uvs))*.125;\n    \n    #if ANTIALIAS == 2\n  \tcolor *= .5;\n    color += doballs(vec2(uv.x + uvs*.85, uv.y + uvs*.85))*.125;\n    color += doballs(vec2(uv.x - uvs*.85, uv.y + uvs*.85))*.125;\n    color += doballs(vec2(uv.x - uvs*.85, uv.y - uvs*.85))*.125;\n    color += doballs(vec2(uv.x + uvs*.85, uv.y - uvs*.85))*.125;\n    #endif\n    #endif\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtSzl", "name": "Fur Space 2", "author": "aiekick", "description": "Fur Space 2", "tags": ["space", "fur", "2"], "likes": 12, "viewed": 690, "date": "1461002534", "time_retrieved": "2024-06-20T18:34:50.209545", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0., ts = 0.;\n\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat df(vec3 p)\n{\n\tp.x += sin(p.z*1.2);\n    p.y += cos(p.z*.2) * sin(p.x*.8);\n\tp *= getRotZMat(p.z*1.8+sin(p.x)+cos(p.y));\n    p.xy = mod(p.xy, 0.8) - 0.4;\n\treturn length(p.xy);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy) - df(p-e.xyy),\n\t\tdf(p+e.yxy) - df(p-e.yxy),\n\t\tdf(p+e.yyx) - df(p-e.yyx) );\n    return normalize(n);\n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float d = max(length(l), 0.01);\n    float atten = .8-exp( -0.01*d*d );\n    vec3 n = nor(p, prec);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    vec3 lin = vec3(0.08,0.32,0.47);\n    lin += 2.5*fre*vec3(1);\n    return lin * atten;\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = vec3(0.5,0.49,0.72);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*fragCoord.xy-si)/min(si.x, si.y);\n\t\n\tt = iTime;\n\tts = sin(t)*.5+.5;\n    \n    vec3 ro = vec3(1.2*vec2(cos(t*.5),sin(t*.5)),t*2.);\n\n    vec3 cu = vec3(0,1,0);\n    vec3 co = ro + vec3(0.,0,1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(co - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * uv.x * x + fov * uv.y * y);\n\t\n\tfloat s = 0.01;\n\tfloat d = 0.;\n\tvec3 p = ro + rd * d;\n\tfloat dMax = 20.;\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (s<0.01*log(d*d/s/1000.) || d>dMax) break;\n\t\ts = df(p);\n        d += s * 0.2;\n        p = ro + rd * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rd, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n        fragColor.rgb = vec3(0.47,0.6,0.76) * lighting(p, ro, rd, .000001);\n\t\tfragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.03*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtXD2", "name": "JS1k 2016 winner clone", "author": "BlueHeisenberg", "description": "Clone of the winner of the 2016 JS1k.", "tags": ["js1k2016js1k2016"], "likes": 6, "viewed": 193, "date": "1461680875", "time_retrieved": "2024-06-20T18:34:50.209545", "image_code": "float T = 34962.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    precision mediump float;\n    vec2 R, M;\n\tT += iTime;\n    \n    R.x = iResolution.x * 0.8;\n    R.y = iResolution.y * 0.8;\n    M.x = iMouse.x == 0.0 ? iTime/100.0 : iMouse.x;\n    M.y = iMouse.y == 0.0 ? iTime/100.0 : iMouse.y;\n    \n    float t = 5e-3;\n    for (float i = 0.; i < 64.; i++) {\n        vec3 p = vec3((2. * fragCoord.xy - R) / R.yy, t - 1.), b = vec3(.707, .707, 0);\n        float a = T;\n        p.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n        for (float i = 0.; i < 20.; i++) {\n            a = (M / R * 6.).x;\n            p.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            a = (M / R * 6.).y;\n            p.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            p -= min(0., dot(p, b)) * b * 2.;\n            b = b.zxx;\n            p -= min(0., dot(p, b)) * b * 2.;\n            b = b.zxz;\n            p -= min(0., dot(p, b)) * b * 2.;\n            b = b.xxy;\n            p = p * 1.5 - .25;\n        }\n        t += length(p) / 3325.;\n        if (length(p) / 3325. < 5e-3 || t > 2.) {\n            b = vec3(1);\n            p *= .5;\n            fragColor = vec4(p / length(p) * (t < 2. ? 5. / i : i / 64.), dot(p, b));\n            break;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtXD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtXRS", "name": "Visible Clock 2", "author": "dr2", "description": "An update...", "tags": ["raymarching", "gears", "clock"], "likes": 14, "viewed": 618, "date": "1460062261", "time_retrieved": "2024-06-20T18:34:52.500729", "image_code": "// \"Visible Clock 2\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  The mechanics of timekeeping; when the clock is open time speeds up\n  to show all the gears rotating. This is an improved version that is\n  much faster (and less likely to browser-crash) than the original;\n  the second hand is now shown by default and the mouse is active. \n*/\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrOBox2Df (vec2 p, vec2 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q;\n  q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nvec3 ltDir, szCase;\nfloat ntt[12], gRot[6], dstFar, tCur, todCur, tCyc, tSeq, aVelFac, axDist, axRad,\n   wlGap, ttWid, hFac1, hFac2, fadeCase, openMech;\nint idObj, showCase;\nbool visCase;\nconst int idBody = 10, idGearS = 11, idGearB = 12, idAxH = 13, idAxM = 14,\n   idAxS = 15, idAxF = 16, idAxB = 17, idBar = 18, idCase = 19, idRing = 20,\n   idFoot = 21;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd.z *= -1.;\n  ro.z *= -1.;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (ro.xy + 2. * tCur + rd.xy * (100. - ro.z) /rd.z);\n  return mix (mix (vec3 (0.2, 0.2, 0.6), vec3 (1.), 0.7 * Fbm2 (0.1 * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nfloat GearWlDf (vec3 p, float rtFac, float nth, float aRot, float tWid,\n   float wlThk, float dMin, int idGear)\n{\n  vec3 q, qq;\n  float nspi, rad, d, a, g, r;\n  q = p;\n  nspi = 1./8.;\n  rad = rtFac * nth;\n  r = rad - 1.5 * tWid;\n  d = PrOBox2Df (vec2 (length (q.xz) - r, q.y), vec2 (2. * tWid, wlThk));\n  q.zx = Rot2D (q.zx, aRot);\n  g = atan (q.z, - q.x);\n  if (d < dMin) {\n    qq = q;\n    a = 2. * pi / nth;\n    qq.xz = Rot2D (qq.xz, a * floor (g / a + 0.5));\n    d = 0.4 * max (d, - (r + clamp (2. * (abs (qq.z) - tWid) - abs (qq.x),\n       qq.x - tWid, qq.x + tWid)));\n  }\n  d = min (d, PrCylDf (q.xzy, 5.2 * wlThk, 2. * wlThk));\n  a = 2. * pi * nspi;\n  q.xz = Rot2D (q.xz, a * floor (g / a + 0.5));\n  q.x += 0.5 * (rad - tWid);\n  d = min (d, PrOBoxDf (q, vec3 (0.5 * rad - 2. * tWid, wlThk, 0.03 * rad)));\n  if (d < dMin) { dMin = d;  idObj = idGear; }\n  return dMin;\n}\n\nfloat GearsDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, angRot, rtFac, sx, tw, rtFacB, wlThk, f1, f2;\n  int kk;\n  wlThk = 0.16;\n  rtFacB = (7./32.);\n  kk = int (floor (3. - p.y / wlGap));\n  if (kk >= 0 && kk < 6) {\n    sx = -1.;\n    for (int k = 0; k < 6; k ++) {\n      sx = - sx;\n      wlThk *= 0.92;\n      f1 = ntt[2 * k];\n      f2 = ntt[2 * k + 1];\n      angRot = gRot[k];\n      if (k == kk) break;\n    }\n    rtFac = rtFacB;\n    tw = ttWid;\n    if (kk == 1) rtFac *= 0.8;\n    else if (kk == 4) {\n      rtFac *= 0.66667;\n      tw *= 0.65;\n    }\n    q = p;\n    q.y = mod (q.y, wlGap) - 0.5 * wlGap;\n    q.x -= sx * axDist;\n    dMin = GearWlDf (q, rtFac, f1, angRot, ttWid, wlThk, dMin, idGearB);\n    angRot = - (f1 / f2) * angRot + pi / f2;\n    q.x -= -2. * sx * axDist;\n    dMin = GearWlDf (q, rtFac, f2, angRot, tw, wlThk, dMin, idGearS);\n  }\n  return dMin;\n}\n\nfloat GearsRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float d, dHit, srd, dda;\n  srd = - sign (rd.y);\n  dda = - srd / (rd.y + 0.00001);\n  dHit = PrOBoxDf (ro, vec3 (szCase.x, 3. * wlGap, szCase.z));\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = GearsDf (p, dstFar);\n    dHit += min (d, wlGap * (0.3 + max (0.,\n       fract (dda * fract (srd * p.y / wlGap)))));\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat AxlesDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;  q.xy -= vec2 (- axDist, 2. * wlGap);\n  d = PrCylDf (q.xzy, axRad, 0.9 * wlGap);\n  q = p;  q.xy -= vec2 (- axDist, 1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.3 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -0.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, - wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, -2. * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  if (d < dMin) { dMin = d;  idObj = idAxB; }  \n  q = p;  q.y = abs (q.y) - 2.75 * wlGap;\n  d = PrOBoxDf (q, vec3 (axDist - 1.8 * axRad, 0.3 * axRad, 0.7 * axRad));\n  q.x = abs (q.x) - axDist;\n  d = min (d, PrCylDf (q.xzy, 2. * axRad, 0.3 * axRad));\n  if (d < dMin) { dMin = d;  idObj = idBar; }\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.05 * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxF; }  \n  return dMin;\n}\n\nfloat HandsDf (vec3 p, float dMin)\n{\n  vec3 q, pp;\n  float d, angRot;\n  pp = p;\n  p.y -= 2.5 * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 0.25 * wlGap);\n  d = PrCylDf (q.xzy, 1.5 * axRad, 0.7 * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxH; }  \n  p.y += 2. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 1.5 * wlGap);\n  d = PrCylDf (q.xzy, axRad, 2. * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxM; }  \n  p.y += 3. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 3.2 * wlGap);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.6 * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxS; }  \n  p = pp;\n  p.xy -= vec2 (axDist, 0.5 * wlGap);\n  angRot = - gRot[0];\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2., 2.85 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.);\n  if (d < dMin) { dMin = d;  idObj = idAxH; }\n  angRot *= hFac1;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.5, 3.25 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.5);\n  if (d < dMin) { dMin = d;  idObj = idAxM; }\n  angRot *= hFac2;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.7, 3.65 * wlGap);\n  d = PrCapsDf (q.zyx, 0.3 * ttWid, 3.2);\n  if (d < dMin) { dMin = d;  idObj = idAxS; }\n  return dMin;\n}\n\nfloat CaseDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= -0.8 + 0.5 * wlGap;\n  q = p;\n  d = PrRoundBoxDf (q, szCase - 0.5, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idCase; }\n  q.xy -= vec2 (-8., 4.3);\n  d = PrTorusDf (q.xzy, 0.22, 3.2);\n  q = p;\n  q.xy -= vec2 (axDist, 4.3);\n  d = min (d, PrTorusDf (q.xzy, 0.22, 7.2));\n  if (d < dMin) { dMin = d;  idObj = idRing; }\n  q = p;  q.xy = abs (q.xy) - vec2 (10., 2.4);  q.z -= 8.7;\n  d = PrCylDf (q, 1., 0.5);\n  if (d < dMin) { dMin = d;  idObj = idFoot; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  if (visCase) dMin = CaseDf (p, dMin);\n  else dMin = AxlesDf (p, dMin);\n  dMin = HandsDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjNDf (vec3 p)\n{\n  float dMin;\n  dMin = ObjDf (p);\n  if (! visCase) dMin = GearsDf (p, dMin);\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjNDf (p + e.xxx), ObjNDf (p + e.xyy),\n     ObjNDf (p + e.yxy), ObjNDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 objCol;\n  vec2 s;\n  float a;\n  if (idObj == idCase) {\n    objCol = vec4 (0.9, 0.9, 1., 1.);\n    if (ro.y > 0.) {\n      s = ro.xz - vec2 (axDist, 0.);\n      if (length (s) < 7.) {\n        objCol = vec4 (0.8, 0.8, 0.6, 0.5);\n        a = 6. * (atan (s.y, - s.x) / pi + 1.);\n        if (abs (mod (a + 0.5, 1.) - 0.5) < 0.05 &&\n           abs (length (s.xy) - 5.9) < 0.9) objCol *= 0.1;\n      } else if (length (ro.xz - vec2 (-8., 0.)) < 3.) objCol =\n         vec4 (0.8, 0.75, 0.8, 0.) * (1. - 0.5 * Noisefv2 (50. * ro.xz));\n    }\n  } else if (idObj == idRing) objCol = vec4 (0.7, 0.7, 0.1, 1.);\n  else if (idObj == idGearB) objCol = vec4 (1., 1., 0.5, 1.);\n  else if (idObj == idGearS) objCol = vec4 (0.8, 0.8, 0.2, 1.);\n  else if (idObj == idAxB) objCol = vec4 (0.6, 0.6, 0.3, 1.);\n  else if (idObj == idAxH) objCol = vec4 (1., 0.3, 0.2, 1.);\n  else if (idObj == idAxM) objCol = vec4 (0.3, 0.2, 1., 1.);\n  else if (idObj == idAxS) objCol = vec4 (0.3, 1., 0.2, 1.);\n  else if (idObj == idAxF || idObj == idBar) objCol = vec4 (0.6, 0.3, 0.2, 1.);\n  else if (idObj == idFoot) objCol = vec4 (0.4, 0.4, 0.4, 0.1);\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 vn, roo, col, colC, colNC;\n  float dstObj, d, f;\n  int idObjT, showMode;\n  colC = vec3 (0., 0., 0.2);\n  colNC = colC;\n  showMode = showCase;\n  if (fadeCase == 0.) showMode = 0;\n  else if (fadeCase == 1.) showMode = 2;\n  if (showMode > 0) {\n    roo = ro;\n    visCase = true;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (ro);\n      colC = objCol.rgb * (0.2 + max (dot (vn, ltDir), 0.) +\n         objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n      if (idObj == idCase && objCol.a > 0.5)\n         colC = mix (colC, BgCol (ro, reflect (rd, vn)), 0.15);\n    }\n    ro = roo;\n  }\n  if (showMode < 2) {\n    visCase = false;\n    dstObj = GearsRay (ro, rd);\n    idObjT = idObj;\n    d = ObjRay (ro, rd);\n    if (d < dstObj) {\n      dstObj = d;\n    } else {\n      idObj = idObjT;\n    }\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (ro);\n      colNC = objCol.rgb * (0.2 + max (dot (vn, ltDir), 0.) +\n         objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n    }\n  }\n  if (showMode == 1) col = mix (colNC, colC, fadeCase);\n  else col = (showMode == 0) ? colNC : colC;\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid SetConfig ()\n{\n  tCyc = 40.;\n  tSeq = mod (tCur, tCyc);\n  if (showCase == 1) {\n    fadeCase = 1. - SmoothBump (0.15, 0.85, 0.05, tSeq / tCyc);\n    openMech = SmoothBump (0.25, 0.75, 0.05, tSeq / tCyc);\n  } else if (showCase == 0) {\n    fadeCase = 0.;\n    openMech = 1.;\n  } else {\n    fadeCase = 1.;\n    openMech = 0.;\n  }\n  aVelFac = 2. * pi / (12. * 3600.);\n  if (showCase < 2) aVelFac *=\n     (1. + 69. * SmoothBump (0.4, 0.6, 0.002, tSeq / tCyc));\n  wlGap = 1.4 * (1. + 1.3 * openMech);\n  szCase = vec3 (13.5, 4.4, 8.5);\n  axDist = 4.83;\n  axRad = 0.3;\n  ttWid = 0.35;\n  ntt[0] = 36.; ntt[1] = 12.; ntt[2] = 48.;  ntt[3] = 12.;\n  ntt[4] = 32.; ntt[5] = 16.; ntt[6] = 36.;  ntt[7] = 12.;\n  ntt[8] = 60.; ntt[9] = 12.; ntt[10] = 32.; ntt[11] = 16.;\n  hFac1 = (ntt[0] / ntt[1]) * (ntt[2] / ntt[3]);\n  hFac2 = (ntt[4] / ntt[5]) * (ntt[6] / ntt[7]) * (ntt[8] / ntt[9]) *\n     (ntt[10] / ntt[11]);\n  gRot[0] = - todCur * aVelFac;\n  for (int k = 0; k < 5; k ++)\n     gRot[k + 1] = - gRot[k] * ntt[2 * k] / ntt[2 * k + 1];\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  showCase = 1;\n  dstFar = 80.;\n  az = pi;\n  el = 0.5 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  }\n  el = clamp (el, 0.4 * pi, 0.9 * pi);\n  SetConfig ();\n  if (showCase == 1) az +=\n     (1. - 2. * floor (mod (tCur / (3. * tCyc), 2.))) * 2. * pi * tSeq / tCyc;\n  el -= 0.04 * pi * openMech;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -50.);\n  ltDir = vuMat * normalize (vec3 (1., 0.5, -1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtXWf", "name": "Craters on Craters", "author": "NickWest", "description": "Moon surface with craters. Simple lighting.", "tags": ["moon", "surface", "lunar", "crater"], "likes": 5, "viewed": 253, "date": "1461939155", "time_retrieved": "2024-06-20T18:34:52.506838", "image_code": "#define animSpeed 0.05\n\n//-----------------------------------------------------------------------------\n// Crater in -1.0 to 1.0 space\nfloat crater(in vec2 pos) {\n    float len = length(pos);\n    float pi = 3.1415926535;\n    float x = clamp(pow(len, 4.0) * 8.0, pi*0.5, pi*2.5);\n    float t = clamp(len, 0.0, 1.0);\n    return sin(-x) + 0.5 - 0.5 * cos(t * pi);\n}\n\n//-----------------------------------------------------------------------------\nvec2 pseudoRand(in vec2 uv) {\n    // from http://gamedev.stackexchange.com/questions/32681/random-number-hlsl\n    float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.233)      )) * 43758.5453));\n    float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.233) * 2.0)) * 43758.5453));\n    return vec2(noiseX, noiseY);}\n\n//-----------------------------------------------------------------------------\nfloat repeatingCraters(in vec2 pos, in float repeat, in float scaleWeight) {\n    vec2 pos01 = fract(pos * vec2(repeat));\n    vec2 index = (pos * vec2(repeat) - pos01) / repeat;\n    vec2 scale = pseudoRand(index);\n    float craterY = crater(vec2(2.0) * (pos01 - vec2(0.5)));\n    return mix(1.0, pow(0.5*(scale.x + scale.y), 4.0), scaleWeight) * craterY; \n}\n\n//-----------------------------------------------------------------------------\nfloat getY(in vec2 pos) {    \n    float y = 0.5;\n    for(int i=0;i<int(100);++i) {\n        float f01 = float(i) / float(99.0);\n        float magnitude = pow(f01, 2.3);\n        vec2 offs = pseudoRand(vec2(float(i+2), pow(float(i+7), 3.1)));\n        float repeat = 0.5 / (magnitude + 0.0001);\n\n        y += magnitude * repeatingCraters(pos+offs, repeat, 1.0);\n    }\n    \n\treturn y;\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = (fragCoord.xy - iResolution.xy*0.5) / vec2(iResolution.y);\n    pos += vec2(1.0); // avoid negative coords\n\n    vec2 offs = vec2(0.001, -0.001);\n    \n    pos.x += iTime * animSpeed;\n    pos.y -= iTime * animSpeed * 0.25;\n    \n    float y = getY(pos);\n    float y1 = getY(pos - offs);\n    //float y2 = getY(pos + offs);\n\n    vec3 normal = normalize(vec3(0.01, y-y1, 0.01));\n\n    float d = 0.5 + 0.5 * dot(normal, normalize(vec3(2.0, 1.0, 2.0)));\n    \n    float shadeScale = 1.0;\n\n    /*\n    // shadows\n    {\n        \n        for(int i=0;i<int(40);++i) {\n            float f01 = float(i+1) / float(40.0);\n            f01 = pow(f01, 2.0);\n\n            vec2 posTest = pos - vec2(f01, -f01) * 0.5;\n\n            float yTest = getY(posTest);\n\n            float over = yTest - (y + f01 * 3.0);\n            \n            if(over > 0.0)\n                shadeScale = min(shadeScale, mix(1.0, 0.7, clamp(over*0.5,0.0,1.0)));\n        }\n    }\n    \n    d *= shadeScale;\n    */\n\n    float c = y * 0.02 - 0.5 + d * 1.3;\n\n    // color ramp\n    vec3 rgb = vec3(mix(mix(vec3(0.0,0.0,0.0), vec3(0.8,0.6,0.4), c), vec3(1.0,0.95,0.90), c));\n    \n    fragColor = vec4(rgb,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3SDj", "name": "EARF", "author": "zackpudil", "description": "Happy EARF day everybody :)", "tags": ["raymarching", "distancefields"], "likes": 3, "viewed": 218, "date": "1461475903", "time_retrieved": "2024-06-20T18:34:52.506838", "image_code": "const float TMAX = 20.0;\n\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.54831);\n}\n\nfloat hash2(vec2 n) {\n    return fract(sin(dot(n, vec2(12.989, 71.233)))*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0 - f*2.0);\n\t\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\t\n\treturn mix(\n\t\tmix(\n\t\t\tmix(hash(n + 000.0), hash(n + 001.0), f.x),\n\t\t\tmix(hash(n + 057.0), hash(n + 058.0), f.x),\n\t\t\tf.y),\n\t\tmix(\n\t\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\t\n\tf += 0.5000*noise(p); p *= 2.01;\n\tf += 0.2500*noise(p); p *= 2.04;\n\tf += 0.1250*noise(p); p *= 2.02;\n\tf += 0.0625*noise(p);\n\t\n\tf /= 0.9375;\n\t\n\treturn f;\n}\n\nvoid rotate(inout vec2 p, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\tp = mat2(c, s, -s, c)*p;\n}\n\nvec2 map(vec3 p) {\n\tvec3 q = p;\n\trotate(p.xz, 0.1*iTime);\n    float f = 0.0;\n    if(length(p) - 1.0 <= 0.1 ) {\n\t\tf = smoothstep(0.0, 1.0, 100.0*smoothstep(0.5, 1.0, fbm(4.0*p)));\n\t\tf += smoothstep(0.0, 1.0, 10.0*smoothstep(0.5, 1.0, fbm(2.0*p + vec3(0, 0, iTime))));\n    }\n\tvec2 d1 = vec2(length(p) - 1.0 - 0.01*f, 0.0);\n\trotate(q.xz, 0.5*iTime);\n\tq.x -= 1.8;\n    f = 0.0;\n    if(length(q) - 0.3 <= 0.1) {\n\t\tf = fbm(5.0*q);\n    }\n\tvec2 d2 = vec2(length(q) - 0.3 + 0.05*f, 1.0);\n\t\n\treturn d1.x < d2.x ? d1 : d2;\n}\n\nvec3 intersect(vec3 ro, vec3 rd) {\n\tfloat td = 0.0;\n\tfloat mid = -1.0;\n\tfloat g = 0.0;\n    \n\tfor(int i = 0; i < 100; i++) {\n\t\tvec2 s = map(ro + rd*td);\n\t\tif(abs(s.x) < 0.001 || td >= TMAX) break;\n\t\ttd += s.x*0.95;\n\t\tmid = s.y;\n        if(s.y <= 0.0) g += clamp(0.05 - s.x, 0.0, 1.0);\n\t}\n\t\n\tif(td >= TMAX) mid = -1.0;\n\treturn vec3(td, mid, g);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy).x - map(p - h.xyy).x,\n\t\tmap(p + h.yxy).x - map(p - h.yxy).x,\n\t\tmap(p + h.yyx).x - map(p - h.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n\nvec3 earfColor(vec3 p) {\n\tfloat f = 0.0;\n\tvec3 col = vec3(0.2, 0.4, 0.8);\n\trotate(p.xz, 0.1*iTime);\n\t\n\tf = smoothstep(0.5, 1.0, fbm(4.0*p));\n\tcol = mix(col, vec3(0.2, 0.8, 0.4), smoothstep(0.0, 1.0, 100.0*f));\n\t\n\tf = smoothstep(0.5, 1.0, fbm(2.0*p + vec3(0, 0, iTime)));\n\tcol = mix(col, vec3(0.8), smoothstep(0.0, 1.0, 10.0*f));\n\t\n\treturn col;\n}\n\nvec3 moonColor(vec3 p) {\n\t\n\tvec3 col = vec3(0.2);\n\trotate(p.xz, 0.5*iTime);\n\tp.x -= 1.8;\n\tfloat f = fbm(5.0*p);\n\tcol *= f;\n\t\n\treturn col;\n}\n\nmat3 camera(vec3 e, vec3 l) {\n\tvec3 f = normalize(l - e);\n\tvec3 r = cross(vec3(0, 1, 0), f);\n\tvec3 u = cross(f, r);\n\t\n\treturn mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = -1.0 + 2.0*( fragCoord.xy / iResolution.xy );\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tfloat atime = iTime*0.3;\n    float s = 0.01*iMouse.x + 1.5;\n\tvec3 ro = 2.5*vec3(cos(s), 0, -sin(s));\n\tvec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 2.0));\n\t\n\tvec3 col = vec3(1.0)*step(0.997, hash2(rd.xy));\n\t\n\tvec3 i = intersect(ro, rd);\n\t\n\tif(i.y > -0.5) {\n        col = vec3(0);\n\t\tvec3 lig = normalize(vec3(-1.0, 0, -0.2));\n\t\tvec3 pos = ro + rd*i.x;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\t\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 32.0);\n        float fre = pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0);\n\t\t\n\t\tcol =  0.01*vec3(1.0, 0.97, 0.85);\n\t\tcol += 0.70*vec3(1.0, 0.97, 0.85)*dif;\n\t\t\n\t\tif(i.y == 0.0) {\n\t\t\tcol *= earfColor(pos);\n\t\t\tcol += 2.0*spe*vec3(1.0, 0.97, .1)*dif;\n            col += 0.1*fre*vec3(1.0, 1.0, 1.0)*dif;\n\t\t} else {\n\t\t\tcol *= moonColor(pos);\n            col += 0.1*fre*vec3(1.0, 1.0, 1.0);\n\t\t}\n\t}\n    \n    col += pow(abs(i.z), 4.0)*vec3(0.0, 0.3, 1.0);\n\tcol = pow(col, vec3(0.454545));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3SDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3SDS", "name": "Nexus 7 stripped Ball", "author": "LaBodilsen", "description": "A Nexus 7 effect.\nmy first try at shader code, and first raymarching experiment.  \ninspired by Blueberry's revision 2016 live shader effort. \nthanks to Dila, for the youtube tutorial that got me startet on this path\n\nsorry for any newbie errors.", "tags": ["raymarching", "amiga", "ball", "bounce", "nexus7"], "likes": 7, "viewed": 209, "date": "1461170144", "time_retrieved": "2024-06-20T18:34:52.955400", "image_code": "float map (vec3 p){\n\n\tfloat ax = iTime*0.6;\n\tfloat ay = iTime*1.5;\n\tfloat az = -iTime*.8;\n\n    float div = iResolution.y*(.7/iResolution.y);\n    p.y += .8-abs(sin(iTime*2.5)*1.5);\n\tp.x +=  -div+(abs(mod(iTime*1.2,div*4.)-div*2.));\n    p.xy *= mat2(cos(az),-sin(az),sin(az),cos(az));\n    p.zy *= mat2(cos(ax),-sin(ax),sin(ax),cos(ax));\n    p.zx *= mat2(cos(ay),-sin(ay),sin(ay),cos(ay));\n    \n    float sphere1 = length(p)-.75;\n    float sphere2 = length(p)-.74;\n\n    float cube1 = length(max(abs(p-vec3(0.0,0.0,-.6))-vec3(.8,.8,.06),0.0))-.01;\n    float cube2 = length(max(abs(p-vec3(0.0,0.0,-.3))-vec3(.8,.8,.06),0.0))-.01;\n    float cube3 = length(max(abs(p)-vec3(.8,.8,.06),0.0))-.01;\n    float cube4 = length(max(abs(p-vec3(0.0,0.0,.3))-vec3(.8,.8,.06),0.0))-.01;\n    float cube5 = length(max(abs(p-vec3(0.0,0.0,.6))-vec3(.8,.8,.06),0.0))-.01;\n    float cube = min(min(min(cube1,cube2),min(cube3,cube4)),cube5);\n    \n    return max(-cube,max(sphere1,-sphere2));\n}\n\nvec3 get_normal( in vec3 p ) // by iq\n{ \n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    //Init\n    fragColor = vec4(0.0);\n\n    //Draw Background\n    vec3 blue=vec3(0.0,0.,.5-length(uv)/8.);\n    vec3 red=vec3(0.2,0.,0.0);\n\n    float radius=0.47;\n    float arms=10.;\n   \n    vec3 fc=red;\n\t//Draw Arms\n    if(cos(atan(uv.y,uv.x)*arms+(texture(iChannel0,uv).r*1.5)+sin(length(uv*20.))/1.5)<-.8\n       || length(uv)<radius+texture(iChannel0,uv).r*0.2){\n        fc=blue;}\n\n    //Draw Center\n    if(length(uv)<radius+texture(iChannel0,uv).r*0.2-.15)\n        fc=red;\n\n    //Raymarch and draw Sphere object\n    float move = iTime;\n    vec3 origin = vec3(0.0,0.0,-1.9);\n    vec3 ray_dir = normalize(vec3(uv,2.0));\n    vec3 light = vec3(3.,2.0,-4.0);\n    \n    \n    float t= 0.0;\n\tfloat color = 0.0;\n    vec3 point = vec3(0.0);\n    for (int iterations = 0;iterations<80;iterations++){\n        point = origin + ray_dir * t;\n        float distance_point = map(point);\n        if (distance_point < 0.0001 || distance_point > 15.){\n\t\t\tt = min(distance_point, 15.);\n            if (t < 15.) {\n            vec3 point_normal = get_normal(point);\n\t\t\tvec3 light_dir = normalize(light-point);\n    \t\tcolor = (max(-0.1, dot(light_dir, point_normal))+.1);\n    \t\tfc = vec3(color+.1,color-.1,color-0.3);\n                break;}\n        }\n        t += distance_point;\n    }\n    \n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3SDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3SR2", "name": "patterns and lines", "author": "quisten", "description": "work in progress as always. loading screen in the making? PS: should be watched in fullscreen :) ", "tags": ["2d", "image"], "likes": 10, "viewed": 282, "date": "1460329186", "time_retrieved": "2024-06-20T18:34:52.955400", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat pattern(vec2 uv, float s, float time)\n{\n    vec2 puv2 = uv*s;\n    float flow = .65+.35*(cos(puv2.x*8.0+9.0*sin(puv2.y+time*.75)));\n   \n    float lineWidth = .885+.1*flow; \n    float linePattern = 0.0; \n     float lineGradient = float(pow(.4+.3*length(uv-.5), 3.));\n   \n    \n   \tfloat lineX = float(max(0.0, -lineWidth-sin((puv2.x+puv2.y)*200.0)));\n    float lineY = float(max(0.0, -lineWidth-cos((-puv2.x+puv2.y)*200.0)));\n    \n    linePattern += 11.0*lineGradient*(lineX+lineY);\n    \n    //dots\n    vec4 dots = vec4(max(0.0, 0.7-pow(length(mod((puv2-vec2(.138,.153))*63.6500, 2.0)-.5), .40)));\n    if (dots.x > (.20+.075*flow))\n        linePattern = .5;\n    linePattern += dots.x*.25;\n       \n    \n    dots = vec4(max(0.0, 0.7-pow(length(mod((puv2-vec2(.4360,.4515))*63.6500, 2.0)-.5), .40)));\n    if (dots.x > (.25+.05*flow))\n         linePattern = .5;\n    return linePattern; \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv*vec2(1.0, iResolution.y/iResolution.x);\n    float time = iTime;\n    \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(.5);\n    \n    \n    //gradient\n    fragColor = vec4(.15*uv.y);\n    \n    //add some light\n    fragColor +=  0.1*vec4(max(0.0, 1.0-length((uv-vec2(0.0,.75))-.5)));\n    \n   \n \n    // pattern\n    ///////////////////////////////////////////////////  \n    float linePattern = pattern(uv2,3.0, time);\n   // linePattern += .5*pattern(uv2*4.0, time);\n    \n    float colorPattern = .65+.35*(sin(uv.x*5.0+7.0*cos(uv.y+time)));\n    \n    linePattern *= colorPattern*colorPattern;\n    fragColor += linePattern;\n    \n    \n    //circles\n    ////////////////////////////////////////////////\n    float circles = 0.0;\n    float cflow = .75+.25*(cos(time*6.2+uv.x*34.0+5.0*sin(uv.y*3.4+time*3.35)));\n    float dflow = .75+.25*(cos(uv.x*12.0+12.0*sin(uv.y*19.0+time*4.75)));\n    \n    vec2 uvc = (uv2-vec2(0.5, .28))*1.95+vec2(0.0, -.1);\n    float theta = atan(uvc.x, uvc.y);  \n    float c = length(uvc); \n    \n   // float teth = (atan((uv.y-.5)/length(uv-.5))) ;\n    \n    float teth2 = (acos((uv.x-.5)/length(uv-.5))) ;\n    \n    float rt = (( sin(time+theta*4.0*sin((theta+time)*1.0))));\n    float rt2 = (( sin(theta*2.0-time+cos(theta*5.0+time))) );\n    \n    // outer boarder\n    if (c < .228 && c > 0.225)  // outerCircle\n        circles += .5+dflow;\n    \n    if (c < .223 && c > 0.205)  // dotted \n        circles += .75*(.5+.5*sin(theta*200.0+time*10.0));\n    \n    if (c < .203 && c > 0.200)  // outerCircle\n        circles += .5;\n    \n    // loading - layer 1\n    if (c < .15 && c > 0.11)  // rotating\n         if (rt < 0.4 && rt < 0.1)\n        circles += .55+cflow;\n        \n    \n    // loading - layer 2\n    if (c < .11 && c > 0.08)  // inner\n         if (rt2 < 0.3 && rt2 < 0.7)\n        circles += .55+dflow;\n    \n    // loading - layer 3\n    if (c < .08 && c > 0.04)  // rotating\n         if (rt < 0.84 && rt < 0.4)\n        circles += .45;    \n     \n    if (c < .030 && c > 0.025)  // inner rotating dotted\n        circles += .35*(.5+.5*sin(theta*50.0+time*10.0));\n    \n    // shading\n    /////////////////////////////////////\n    fragColor *= (.05+.95*vec4(pow(max(0.0,c-0.228), .50))); \n        \n        \n        // give it some pattern\n     circles += max(0.0, circles*pattern(uv2, 5.4, time));\n    fragColor += circles*cflow;\n    \n    \n    \n        \n\t// vignetting\n    /////////////////////////////////////\n    float v = 1.0-length(uv-.5); \n    float vv = 1.1*pow(v*.95+.05*rand(uv+time), 1.35);\n         \n    //fragColor = vec4(1.0);\n    fragColor *= vec4(vv);\n    \n    // gamma correction\n    /////////////////////////////////////\n    fragColor = sqrt(fragColor);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3SR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3XDX", "name": "Squares Background", "author": "vamoss", "description": "Square animation for background", "tags": ["square", "rectangle", "background"], "likes": 11, "viewed": 299, "date": "1461772887", "time_retrieved": "2024-06-20T18:34:52.961057", "image_code": "const float total = 60.;//number of rectangles\nconst float minSize = 0.01;//rectangle min size\nconst float maxSize = 0.1-minSize;//rectangle max size\nconst float yDistribution = 0.5;\n\nvec4 bgColor = vec4(0.01, 0.16, 0.42, 1.0);\nvec4 rectColor = vec4(0.01, 0.26, 0.57, 1.0);\n\nfloat rectangle(vec2 uv, vec2 pos, float width, float height) {\n\treturn step(pos.x, uv.x) * step(uv.x, pos.x + width) * step(pos.y, uv.y) * step(uv.y, pos.y + height);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float velX = iTime/8.;\n    float velY = iTime/10.;\n    \n    vec4 color = bgColor*(2.-abs(uv.y*2.));\n    \n    for(float i=0.; i<total; i++){\n        float index = i/total;\n        float rnd = rand(vec2(index));\n        vec3 pos = vec3(0, 0., 0.);\n        pos.x = fract(velX*rnd+index)*4.-2.0;\n        pos.y = sin(index*rnd*1000.+velY) * yDistribution;\n        pos.z = maxSize*rnd+minSize;\n        vec2 uvRot = uv - pos.xy + pos.z/2.;\n    \tuvRot = rotate2d( i+iTime/2. ) * uvRot;\n        uvRot += pos.xy+pos.z/2.;\n        float rect = rectangle(uvRot, pos.xy, pos.z, pos.z);\n\t    color += rectColor * rect * pos.z/maxSize;\n    }\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3XDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3XRl", "name": "2D Smoke", "author": "finalman", "description": "Nothing special, just playing around with ways to generate good looking smoke.", "tags": ["2d", "swirls", "smoke"], "likes": 32, "viewed": 1489, "date": "1460810850", "time_retrieved": "2024-06-20T18:34:52.961320", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\n\nmat2 rotate2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nfloat smokeBase(vec2 pos)\n{\n    float v = clamp(pos.x * 1.5, -1.0, 1.0);\n    return 1.0 - exp(-cos(v * PI * 0.5) * smoothstep(0.0, -1.0, pos.y) * 3.0);\n}\n\nvec2 swirl(vec2 center, float angle, float radius, vec2 pos)\n{\n    pos -= center;\n    angle *= exp(-length(pos) / radius);\n    pos *= rotate2D(angle);\n    pos += center;\n    return pos;\n}\n\nvec2 movingSwirl(vec2 start, vec2 end, float angle, float radius, float frequency, vec2 pos)\n{\n    float phase = fract((iTime + 10.0) * frequency);\n    angle *= (1.0 - cos(phase * TAU)) * 0.5;\n    vec2 center = mix(start, end, phase);\n    return swirl(center, angle, radius, pos);\n}\n\nvec2 swirls(vec2 pos)\n{\n    pos = movingSwirl(vec2( 0.0, -1.5), vec2( 0.3, 2.0),  5.0, 0.5, 0.10, pos);\n    pos = movingSwirl(vec2( 0.0, -1.5), vec2(-0.3, 2.0), -4.0, 0.5, 0.11, pos);\n    pos = movingSwirl(vec2( 0.2, -1.1), vec2( 0.5, 1.8),  4.5, 0.4, 0.12, pos);\n    pos = movingSwirl(vec2(-0.2, -1.3), vec2(-0.4, 1.2), -3.8, 0.4, 0.13, pos);\n    pos = movingSwirl(vec2( 0.1, -1.5), vec2(-0.3, 1.5),  4.7, 0.3, 0.14, pos);\n    pos = movingSwirl(vec2(-0.1, -1.4), vec2( 0.4, 1.6), -3.8, 0.3, 0.15, pos);\n    pos = movingSwirl(vec2( 0.0, -1.5), vec2( 0.3, 2.0),  5.0, 0.5, 0.16, pos);\n    pos = movingSwirl(vec2( 0.0, -1.5), vec2(-0.3, 2.0), -4.0, 0.5, 0.17, pos);\n    pos = movingSwirl(vec2( 0.2, -1.1), vec2( 0.5, 1.8),  4.5, 0.4, 0.18, pos);\n    pos = movingSwirl(vec2(-0.2, -1.3), vec2(-0.4, 1.2), -3.8, 0.4, 0.19, pos);\n    pos = movingSwirl(vec2( 0.1, -1.5), vec2(-0.3, 1.5),  4.7, 0.3, 0.20, pos);\n    pos = movingSwirl(vec2(-0.1, -1.4), vec2( 0.4, 1.6), -3.8, 0.3, 0.21, pos);\n    \n    return pos;\n}\n\nfloat smoke(vec2 pos)\n{\n    pos = swirls(pos);\n    return smokeBase(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    float gamma = 2.2;\n    \n    vec3 bg = pow(texture(iChannel0, uv * vec2(0.5, 0.7)).xyz, vec3(gamma)) * vec3(0.5, 0.5, 0.6);\n    float smokeWhite = smoke(uv);\n    float smokeShadow = smoke(uv + vec2(-0.15, 0.1));\n    \n    vec3 color = mix(bg * mix(1.0, 0.3, smokeShadow), vec3(1.0), smokeWhite);\n    \n    fragColor = vec4(pow(color, vec3(1.0 / gamma)), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3XRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscSRj", "name": "nkhhuuhiuh", "author": "jakeTboss", "description": "lol", "tags": ["kkk"], "likes": 1, "viewed": 257, "date": "1460208501", "time_retrieved": "2024-06-20T18:34:52.961320", "image_code": "void mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 screen = fragCoord.xy / iResolution.xy; // <== environnement\n\tfloat sound = texture( iChannel0 , vec2(screen .x , 0.75)) .x; // <== chargement de l'image\n    vec3 color = vec3 (.0); // <== initialisation\n    \n    color += vec3(abs(sin(iTime)) - smoothstep(0.0 , 0.02, abs(sound - screen.y)),\n                  abs(sin(iTime * 2./3. *3.1415)) - smoothstep(0.0 ,0.02, abs(sound - screen.y)),\n                  abs(sin(iTime * 4./3. *3.1415)) - smoothstep(0.0 ,0.02, abs(sound - screen.y)));\n    \n    fragColor =vec4 (color, 1. );\n        \n        \n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscSWS", "name": "420", "author": "Sin", "description": "Yo.\n\nHappy 420.", "tags": ["2d", "sin", "animation", "420"], "likes": 2, "viewed": 217, "date": "1461162034", "time_retrieved": "2024-06-20T18:34:52.961320", "image_code": "// Weed formula http://www.wolframalpha.com/input/?i=polar+(1%2Bsin(theta))*(1%2B0.9+*+cos(8*theta))*(1%2B0.1*cos(24*theta))*(0.9%2B0.05*cos(200*theta))+from+theta%3D0+to+2*Pi\nfloat weed(vec2 uv)\n{\n    float d = 1.;\n    float count = 7.;\n    float rad = .8;\n    uv.y += .35; \n    \n    float theta = atan(uv.y, uv.x); \t\n   \tfloat r = .2* (1.+sin(theta))*(1.+.9 * cos(8.*theta))*(1.+.1*cos(24.*theta))*(.9+.05*cos(200.*theta));\n    float l = length(uv);\n    \n    d = clamp((l - r ), 0., 1.);\n    uv.y -= .2; \n\n    for(float i = 0.; i < 7. ; ++i)\n    {\n        uv += vec2(cos(iTime*.2 + i / count * 6.28)*rad,sin(iTime*.2+ i / count*6.28)*rad);\n    \n    \ttheta = atan(uv.y, uv.x);\n     \t\n   \t \tr = .1* (1.+sin(theta))*(1.+.9 * cos(8.*theta))*(1.+.1*cos(24.*theta))*(.9+.05*cos(200.*theta));\n    \tl = length(uv);\n    \td = min(d,clamp((l - r ), 0., 1.));\n        uv -= vec2(cos(iTime*0.2 + i / count * 6.28)*rad,sin(iTime*0.2+ i / count*6.28)*rad);\n    }\n    \n\treturn 1. - smoothstep(0., 50./iResolution.x,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fColor = vec3(0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float or = weed(uv+vec2(sin(iTime)*.02,cos(iTime)*.01));\n    float og = weed(uv+vec2(sin(iTime)*.01,cos(iTime)*.01));\n    float ob = weed(uv-vec2(sin(iTime)*.01,cos(iTime)*.01));\n    float shift = clamp(0.,1.,or + og + ob);\n    \n    fColor += or* vec3(1.,0.,0.);\n    fColor += og* vec3(0.,1.,0.);\n    fColor += ob* vec3(0.,0.,1.);\n    \n    fColor = mix(vec3(0.),fColor,shift);\n    \n    \n\tfragColor = vec4(fColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscSzl", "name": "Gamma Correction Tutorial", "author": "finalman", "description": "Right part of screen is correctly converted to sRGB before outputting and left part is not. More info at the top of the shader.", "tags": ["tutorial", "gamma", "srgb"], "likes": 32, "viewed": 3505, "date": "1460826760", "time_retrieved": "2024-06-20T18:34:53.682456", "image_code": "/*\n\nA common misconception among new computer graphics programmers is that RGB values are mapped\nlinearly to brightness when displayed on the screen. However, this is actually not true.\nA well calibrated computer monitor does not use the linear RGB colorspace, but instead use the\nslightly wonky sRGB colorspace. Being aware of this is key to writing good looking shaders with\nnatural shading and colors.\n\nIn sRGB higher resolution is given to darker colors with RGB values close to zero. \nThis is a good thing, since our eyes are more sensitive to differences in brighness in dark colors\nthan in bright ones. A computer monitor using linear RGB would make dark images look really shitty.\n\nIn coder terms: In sRGB myColor * 2.0 is not twice as bright as myColor, and it may even have\na different hue. \n\nShadertoy does not automatically convert colors from linear RGB to sRGB for us. We must do it\nourselves. In this shader the right part of the screen is correctly converted to sRGB before outputting,\nand the left part is not. Apart from making the picture brighter overall, it also removes some artifacts\nthat can be seen in the left part.\n\nIn the topmost pattern the three primary colors are linearly blended together. If we don't convert \nto sRGB dark fringes will be seen where two colors are blended halfway, like around the green blobs.\n\nThe bottom pattern has some very high frequency content. Here we can see a lower frequency pattern\nappearing when the color is not converted to sRGB. It looks just like aliasing, but it's actually an\nartifact of not being in the correct colorspace and wrongly expecting 0.5 to be half as bright as 1.0,\nwhen it actually comes out a lot darker than that on the screen. The right part should have a uniform\nbrightness if your monitor is correcly calibrated.\n\nWorking in sRGB all the time is a huge hassle, however. What we typically do is to write our shader\nin linear RGB and then convert it to sRGB once before writing to fragColor. Care must be taken when\nsampling textures for their color values, however. Textures are also stored in sRGB rather than linear\nRGB, so when using them in our linear RGB based shader we must convert the color value from sRGB to\nlinear RGB before using it. \n\nThis still leaves a slight problem, though, since your graphics card will perform filtering and\ninterpolation of the texture as if it was linear RGB rather than sRGB. This can be solved by informing\nOpenGL that the color space of the texture is sRGB. Having an option for this for all textures and\nbuffers (including the framebuffer) is something I personally would like to see in a future update\nof Shadertoy.\n\nIn practice, instead of using the sRGB colorspace as is, we often use a gamma curve of 2.2 as a very good\napproximation, which saves us a few cycles. Holding your mouse button down on the shader will use\ngamma 2.2 instead of sRGB. (Spoiler alert: the difference is imperceptible).\n\nHere is a lighthearted youtube video that may explain this whole thing better than I can:\n  https://www.youtube.com/watch?v=LKnqECcg6Gw\n\nAnd some further reading on Wikipedia:\n  https://en.wikipedia.org/wiki/SRGB\n  https://en.wikipedia.org/wiki/Gamma_correction\n\nHappy shading!\n\n*/\n\nconst float GAMMA = 2.2;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvec3 decodeSRGB(vec3 screenRGB)\n{\n    vec3 a = screenRGB / 12.92;\n    vec3 b = pow((screenRGB + 0.055) / 1.055, vec3(2.4));\n    vec3 c = step(vec3(0.04045), screenRGB);\n    return mix(a, b, c);\n}\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return (iMouse.z < 0.5) ? encodeSRGB(linearRGB) : gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 screenToLinear(vec3 screenRGB)\n{\n    return (iMouse.z < 0.5) ? decodeSRGB(screenRGB) : gamma(screenRGB, GAMMA);\n}\n\nmat2 rotate2D(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 pattern1(vec2 fragCoord)\n{\n\tvec2 uv = 2.0 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec2 a = (uv * 10.0) + iTime;\n    vec2 b = (uv * 12.0) + iTime;\n    float r = clamp(sin(a.x) * cos(a.y) + 0.4, 0.0, 1.0);\n    float g = clamp(sin(b.x) * cos(b.y) * 1.2 - 0.1, 0.0, 1.0);\n    \n    return mix(mix(vec3(0,0,1), vec3(1,0,0), r), vec3(0,1,0), g);\n}\n\nvec3 pattern2(vec2 fragCoord)\n{\n    fragCoord = fragCoord - iResolution.xy * vec2(0.5, 0.25);\n    fragCoord *= rotate2D(sin(iTime) * 0.01);\n    \n    vec2 uv = fragCoord * PI * 0.99;\n    \n    return vec3((sin(uv.x) + cos(uv.y)) * 0.25 + 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    \n    if (fragCoord.y > iResolution.y * 0.5 + 2.0 && fragCoord.y < iResolution.y - 4.0)\n    {\n        color = pattern1(fragCoord);\n    }\n    else if (fragCoord.y < iResolution.y * 0.5 - 2.0 && fragCoord.y > 4.0)\n    {\n        color = pattern2(fragCoord);\n    }\n    \n    if (fragCoord.x > iResolution.x * 0.5)\n    {\n        color = linearToScreen(color);\n    }\n        \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscSzS", "name": "Noisey", "author": "addminztrator", "description": "//random noisey shader", "tags": ["random"], "likes": 4, "viewed": 555, "date": "1459914319", "time_retrieved": "2024-06-20T18:34:53.682681", "image_code": "mat2 m = mat2( 0.8, 0.6, -0.6, 0.8);\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n} \n\nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat noise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n     \n    vec4 i = permute(permute(ix) + iy);\n     \n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n     \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n     \n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n     \n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n     \n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat fbm( vec2 p ){\n\tfloat f = 0.0;\n\tf += 0.5000*noise(p); p*=m*2.02;\n\tf += 0.2500*noise(p); p*=m*2.03;\n\tf += 0.1250*noise(p); p*=m*2.01;\n\tf += 0.0625*noise(p); p*=m*2.04;\n\tf /= 0.9375;\n\treturn f;\n}\n\n// By A Saad Imran\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.y;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat r = sqrt( dot(p,p));\n\tfloat a = atan( p.y, p.x );\n\tvec3 col = vec3( 0.0 );\n\tfloat f = fbm( p + iTime);\n\t//vec3 col = vec3(1.0);\n\tcol = mix( col, vec3(0.2, 0.5, 0.4), f);\n\t\n\tf = fbm( vec2(8.0, 8.0*f) + iTime);\n\tcol = mix (col, vec3(sin(iTime), 0.5, sin(iTime)), f);\n    \n    f = fbm( vec2(16.0*f, 30.0*a) + iTime);\n\tcol = mix (col, vec3(1.0, sin(iTime), 0.4), f);\n    \n\tfragColor = vec4(col, 1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscXRB", "name": "sample wave shader", "author": "TheAnig", "description": "sample shader using sine wave", "tags": ["wave"], "likes": 4, "viewed": 165, "date": "1459958850", "time_retrieved": "2024-06-20T18:34:53.682681", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\n\tvec3 wave_color = vec3(0.0,0.0,0.0);\n\n\t// To create the waves\n\tfloat wave_width = 1.0;\n\tuv  = -1.0 + 2.2 * uv;\n\tuv.y += 0.1;\n    float r,g,b;\n    r = 0.0;\n    g = 1.0;\n    b = 0.0;\n\tfor(float i = 0.0; i < 15.0; i++) {\n\t\t\n\t\tuv.y += (0.06 * sin(uv.x + i/7.0 + iTime ));\n\t\twave_width = abs(1.0 / (107.0 * uv.y));\n\t\twave_color += vec3(wave_width * r  , wave_width * g, wave_width * b);\n\t}\n\t\n\t\n\t\n\tfragColor = vec4(wave_color, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscXRj", "name": "Yolo Trippy", "author": "Vicious", "description": "yolo", "tags": ["yolo"], "likes": 3, "viewed": 151, "date": "1460210586", "time_retrieved": "2024-06-20T18:34:53.682681", "image_code": "#define speed (25.2)\n#define k2PI (2.*3.14159265359)\n#define kStarDensity .011\n#define kMotionBlur 1.4\n#define kNumAngles 90. + sin(iTime)*30.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = ( fragCoord.xy -  iResolution.xy*.5 ) / iResolution.x; // use this for mouse panning\n\tfloat A = atan(position.y,position.x);\n\tfloat angle0 = A / k2PI;\n\tfloat angle = fract(angle0 + .002*iTime);\n\tfloat rad = .3*length(position);\n\tfloat angleFract = fract(angle*kNumAngles);\n\tfloat angleStep = floor(angle*kNumAngles);\n\tfloat angleToRandZ = 10.*fract(angleStep*fract(angleStep*.7535)*45.1);\n\tfloat angleSquareDist = fract(angleStep*fract(angleStep*.82657)*13.724);\n\tfloat t = speed * iTime - angleToRandZ;\n\tfloat angleDist = (angleSquareDist+0.1);\n\tfloat adist = angleDist/rad*kStarDensity;\n\tfloat dist = abs(fract((t*.1+adist))-.5);\n\tfloat white1 = max(0.,1.0 - dist * 100.0 / (kMotionBlur*speed+adist));\n\tfloat white2 = max(0.,(.5-.5*cos(k2PI * angleFract))*1./max(0.6,2.*adist*angleDist));\n\tfloat white = white1*white2;\n\tvec3 color;\n\tcolor.r = .03*white1 + white*(0.3 + 5.0*angleDist);\n\tcolor.b = white*(0.1 + .5*angleToRandZ);\n\tcolor.g = 0.2*white;\n\t\n\tfloat nebD1 = 1.0/rad + 4.5*(1.0 + sin(1.1 + 3.0*A + 0.71*cos(2.0*A)));\n\tfloat nebD2 = 1.0/rad + 3.7*(1.0 + sin(3.7 + 2.0*A + 0.46*sin(3.0*A)));\n\tfloat R1 = 1.0 * rad * (1.0 + sin(0.3+3.0*A + 2.4 * cos(0.2+3.0*A)*sin(2.1+0.42*(nebD1+speed*iTime)) + sin(2.0*6.283*position.x) ));\n\tfloat R2 = 1.0 * rad * (1.0 + sin(1.1+4.0*A + 3.2 * cos(0.7+4.0*A)*sin(1.7+0.27*(nebD2+speed*iTime)) + cos(3.0*6.283*position.y) ));\n\tfloat P1 = 0.5 + .5*sin(5.7*position.x+.22*(speed*iTime));\n\tfloat P2 = 0.5 + .5*sin(4.44*position.y+.17*(speed*iTime)) ;\n\tcolor.r += 0.6*R1 + 0.3*R2 + 0.1*P1*P2 ;\n\tcolor.b += 0.3*R1 + 0.8*R2 + .1*P2*R1;\n\tcolor.g += 1.1*R1*R2*P2;\n\tfragColor = vec4( (color.grb+ vec3(texture(iChannel0, (fragCoord.xy / iResolution.xy))))/1.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscXzB", "name": "Musical Glowing Tubes", "author": "ksamksamksam", "description": "Forest of abstract tree-like tubes with a starry sky background and dense mist rising. Glowing blobs climb up the tubes to the beat of the music. Wait for it...", "tags": ["raycasting", "music", "audio", "texturemapping"], "likes": 9, "viewed": 615, "date": "1460012180", "time_retrieved": "2024-06-20T18:34:55.913162", "image_code": "const float MAX_DIST = 1000.0; //Max distance from camera that we want to \n\t\t\t\t\t\t\t   //render objects.\nconst float PI = 3.141592654;\n\nvec2 tubeSpace = vec2(15,25); //Space we want to fill with tubes.\n\nconst int numTubes = 45; //This is only a const because GLSL doesn't like\n\t\t\t\t\t\t //dynamic indexing so I refuse to make it all caps\n\t\t\t\t\t\t //or put it where its const friends are.\n\nvec4 tubes[numTubes]; //I'm representing the tubes as 4D vectors where \n\t\t\t\t\t  //tube.x is the x-coordinate of the tube, tube.y is \n\t\t\t\t\t  //the z-coordinate, tube.z is the radius, and tube.w\n\t\t\t\t\t  //is the current position of the tube's glowing blob.\n\nconst int numLights = numTubes + 1; //Each blob is a light source plus the main light.\nvec3 lights[numLights];\n\nfloat mainLi = 2.75; //Intensity of the main light.\nfloat blobLi = 0.2; //Intensity of the blob lights.\nfloat mainKf = 1.0; //Falloff factor of the main light.\nfloat blobKf = 1.0; //Falloff factor of the blob lights.\n\nvec3 cam = vec3(0.0,0.0,-10.0);\n\nvec4 ambColor;\nvec4 tubeColor = vec4(.11,.11,.11,1.0);\nvec4 blobColor = vec4(1,.55,0.0,1.0);\nvec4 mainColor = vec4(1.0,1.0,1.0,1.0);\n\n/* Hash-based noise stolen from https://www.shadertoy.com/view/4sfGzS.\n * Yes, I realize that iq was trying the demonstrate that the texture-based\n * noise was better but I wanted all inputs to be easily substituted and the\n * noise texture would have to be static. Plus, the hash function doubles as\n * a seeded random number generator.\n */\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n/* Given a color vector, clamps the color values to be between 0-1.\n*/\nvec4 clampColor(vec4 col)\n{\n    return vec4(min(max(0.0,col.x),1.0), min(max(0.0,col.y),1.0), min(max(0.0,col.z),1.0), min(max(0.0,col.w),1.0));\n}\n\n/* Given a tube, ray origin point p1, and second point on the ray p2,\n * if there is an intersection between the ray and the tube return true\n * and store the point of intersection in intPt; otherwise return false.\n */\nbool tubeRayIntersect(out vec3 intPt, in vec4 tube, in vec3 p1, in vec3 p2)\n{\n    //Since the tubes have no rotation, we don't care where along the y-axis\n    //the ray hits and can therefore ignore the y-coordinate of the ray\n    vec2 flatp1 = vec2(p1.xz);\n    vec2 flatp2 = vec2(p2.xz);\n    \n    //We can perform a simple ray-circle intersection between a cross-section\n    //of the tube and our newly flattened ray.\n    vec2 center = vec2(tube.xy);\n    float radius = float(tube.z);\n    \n    //We get p1 position in circle space.\n    vec2 localP1 = flatp1 - center;\n    \n    //Calculate and normalize the ray direction vector, then drop the\n    //y-coordinate of that.\n    vec3 orRayDir = normalize(p2 - p1);\n    vec2 rayDir = vec2(orRayDir.xz);\n    \n    //Caculate ray-circle intersection\n    float a = dot(rayDir,rayDir);\n    float b = dot(rayDir,localP1);\n    float c = dot(localP1,localP1) - (radius*radius);\n    float delta = (b * b) - (a * c);\n    \n    //No intersection\n    if (delta <= 0.0)\n    {\n        return false;\n    }\n    \n    else \n    {\n        //Calculate t with some quadratic magic and store intersection point\n        //where ro + rd*t = y into intPt.\n        float t = (-b-sqrt(delta)*sign(radius))/a;\n        intPt = p1 + (orRayDir*t);\n        return true;\n    }\n}\n\n/* Given a tube and a point on that tube, calculate the uv position on the\n * texture which corresponds to that point. (texture mapping on a cylinder)\n */\nvec2 pointToTexture(vec3 pt, vec4 tube)\n{\n    //Get x and y of vector from center of the tube to our point\n    float newz = pt.z - tube.y;\n    float newx = pt.x - tube.x;\n    \n    //Calculate the angle in radians between the above vector and an arbitrary\n    //starting point; the proportion of this angle to 2PI is the u component\n    //and the y-coordinate over the tube's diameter is out v component\n\tfloat xfrac =  (atan( tube.w*newz , tube.w*newx)+PI*0.5)/(3.0*PI);\n    float yfrac = pt.y/(3.5*PI*tube.z);\n    \n    return vec2(xfrac,yfrac);\n}\n\n/* Calculate the surface normal of the given tube at the given point\n*/\nvec3 tubeNormal(in vec4 tube, in vec3 pt)\n{\n    vec2 n = normalize(vec2(pt.xz) - vec2(tube.xy));\n    \n    return vec3(n.x, 0.0, n.y);\n}\n\n/* Function stolen from https://www.shadertoy.com/view/Xsd3R2 and modified.\n * Given a point and an array of noise parameters, calculate the fractal\n * noise value of a point. If called upon to animate the fractal, do so using\n * the current time.\n*/\nfloat fractal_noise(vec3 p, float[5] c, bool anim)\n{\n    float f = 0.0;\n    \n    // add animation if warranted\n    if (anim)\n    {\n    \tp = p - vec3(1.0, 1.0, 0.0) * iTime * 0.04;\n    }\n    \n    //fractal-ing the noise\n    p = p * 2.0;\n    f += c[0] * noise(p); p = 2.0 * p;\n\tf += c[1] * noise(p); p = 2.0 * p;\n\tf += c[2] * noise(p); p = 2.0 * p;\n\tf += c[3] * noise(p); p = 2.0 * p;\n    f += c[4] * noise(p);\n    \n    return f;\n}\n\n/* We want to create a mist coming up from the ground. Given a point on the \n * screen, calculate the density of the mist at that point.\n */\nfloat mistDensity(vec3 pt)\n{\n    //I'm using animated fractal noise to simulate the cloudy mist effect.\n    float consts[5];\n    consts[0] = 0.5;\n    consts[1] = 0.5;\n    consts[2] = 0.25;\n    consts[3] = 0.0625;\n    consts[4] = 0.03125;\n    \n    float den = fractal_noise(pt, consts, true);\n    \n    den = clamp(den, 0.0, 1.0);\n    \n    //We want to ramp off the density as the mist goes higher up the screen.\n    den *= (.79)/((pt.y+1.5)/4.0)-1.1;\n    \n    return den;\n}\n\n/* We want to create a starry sky background.\n*/\nvec4 starrySky(vec3 pt)\n{\n    //Dark blue sky\n    vec4 color = vec4(.01,0.007,.015,1.0);\n    \n    //Come up with something to seed our random number generator. It doesn't \n    //make much sense, but I like the idea of seeding with a texture, even \n    //the actual texture won't be reflected in the distribution of the stars.\n    vec2 uv = (.5 * (pt.xy * iResolution.yy + iResolution.xy))/iResolution.xy;   \n    float prob = length(clampColor(texture(iChannel2,uv)));\n\t\n    if (hash(prob) > .992)\n    {\n        //Add stars, and make 'em sparkle by attenuating their value based on\n        //the sine of the current time. Throw in some randomness based on the\n        //screen point position so they're staggered.\n        color = clampColor(hash(length(pt))*(2.0*sin(iTime+100.0*hash(length(pt))))*vec4(.4,.4,.4,1.0));\n    }\n    \n    return color;\n}\n\n/* I have a disclaimer: I am well aware of iq's awesome and efficient ray\n * marching algorithm that is loads better than whatever I hacked here, but\n * I didn't want the meat of my shader to be cannibalized, since I'm supposed\n * to demonstrate what I can do, not what I can steal effectively (although \n * this is also an important skill that I must say I excel at). I usually don't\n * like to reinvent the wheel so were this a production project, I would steal\n * whatever I could with the proper authorization.\n * \n * That said, this uses a very simple ray casting algorithm that calculates the\n * diffuse term of the one primitive it can handle (cylinders) using the Lambert\n * shading model. It takes in a screen point as input and stores the color of\n * scene at that point in the vec4 color.\n */\nvoid render(out vec4 color, in vec3 pix)\n{\n    //First, our background.\n    color = starrySky(pix);\n    \n    //We want to store the distance of the closest object we have hit so far.\n    //We also want to store the tube that we have hit, if we have hit one.\n    float closeDist = MAX_DIST;\n    vec4 hitTube = vec4(-1,-1,-1,-1);\n\n    vec3 intPt, light, lightNorm, camNorm;\n    vec4 lightcolor, texColor, tempColor, blobC;\n    float f, intensity, falloff, col1, diffDot, lightFac, blobDot, blobK;\n    float consts[5];\n    \n    for (int i = 0; i < numTubes; i++)\n    {\n        \n        //If we've intersected our tube, AND it's closer than the max distance\n        //AND it's closer than the last closest tube we hit...\n        if (tubeRayIntersect(intPt, tubes[i], cam, pix) && length(intPt-pix)<closeDist && length(intPt-pix)<MAX_DIST)\n        {   \n            //...we can get this party started. First we set the color\n            //vector to black because we're going to be adding color onto it.\n            color = vec4(0.0,0.0,0.0,1.0);\n            \n            //We're adding texture to the tubes with fractal noise.\n            consts[0] = 0.3;\n            consts[1] = 0.25;\n            consts[2] = 0.125;\n            consts[3] = 0.2625;\n            consts[4] = 0.0;\n            \n            f = fractal_noise(intPt, consts, false);\n            \n            //Calculate the textured color by combining the noise and the\n            //tube's default color.\n            texColor = (3.0*tubeColor + 2.0*tubeColor * f)*(0.3333333);\n            \n            //Set our new closest distance and hit tube.\n            closeDist = length(intPt-pix);\n            hitTube = tubes[i];\n            \n            //Store the normal from the camera to the intersection point.\n            camNorm = normalize(cam-intPt);\n\n            //Calculating the diffuse color contribution of each light to\n            //our tube such that diffuse = color * brightness factor\n            for (int j = 0; j < numLights; j++)\n            {\n                //By default, since most of the lights will be blob lights,\n                //we will assume this is a blob light and set its parameters\n                //accordingly.\n                lightcolor = blobColor;\n                intensity = blobLi;\n                falloff = blobKf;\n                light = lights[j];\n                \n                //BUT, if this is the first light in the list, we will assume\n                //it's the main light and set its parameters based on that. It's\n                //kind of a yucky way of doing things but I tried making a Light\n                //struct so I could package all this up and it slowed the shader\n                //WAY down.\n                if (j == 0)\n                {\n                    lightcolor = mainColor;\n                    intensity = mainLi;\n                    falloff = mainKf;\n                }\n                                \n                \n                //Light attenuation factor: light falls off at a rate proportional \n                //to the inverse square of the distance between surface and \n                //source light [Lambert's first law].  1/(c1+c2*d+c3*d^2).\n                col1 = (1.15/(falloff))/(1.0*falloff + .07 *(length(light-intPt))+ .015 * falloff * (length(light-intPt) * length(light - intPt))); \n\n                //brightness is dependent on angle from light source\n                lightNorm = normalize(light-intPt);\n                diffDot = dot(lightNorm, tubeNormal(tubes[i], intPt));\n                diffDot = max(0.0, diffDot);\n                \n                //Combine these all with the light intensity and color\n                lightFac = diffDot * col1 * intensity;\n                tempColor = vec4(lightcolor[0]*texColor[0], lightcolor[1]*texColor[1], lightcolor[2]*texColor[2],1.0);\n            \t\n                //add to the color at this point\n                color += lightFac * tempColor; \n            }\n            \n            //Color contribution from our blob. Depends on angle from camera\n            //and our point's distance from the blob. I'm faking the look of\n            //internal illumination with the color falloff.\n            blobDot = dot(camNorm, tubeNormal(tubes[i], intPt));\n            blobK = blobDot/(length(intPt-vec3(tubes[i].x,tubes[i].w,tubes[i].y)))-.3;\n            blobC = max(0.0,blobK)*blobColor;\n            \n            //add a texture to the blob color to make it seem like the tube has\n            //an internal structure that is being lit up\n            blobC = (2.0*blobC + 3.0*blobC*texture(iChannel0,pointToTexture(intPt, tubes[i])))*(1.0/3.0);\n\n            //Add it all up with the ambient color\n\t\t\tcolor = clampColor(color + ambColor + blobC);  \n        }\n    }\n    \n    //Throw in our mist. Calculate mist density, then figure out if there's a\n    //tube in the way. The tube will occlude the mist depending on its distance\n    //from camera. Trying to create the appearance that the mist covers a 3D\n    //space despite being 2D.\n    float tubeFac = 1.0;\n    \n    if (hitTube != vec4(-1))\n    {\n        tubeFac = smoothstep(-4.0,15.0,hitTube.y);\n    }\n    \n    color += tubeFac*vec4(.15,.15,.15,0.0)*mistDensity(pix);\n}\n\n/* Main image function where we write to our pixel.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Grab the frequency and waveform from out audio input.\n    float freq = texture(iChannel1, vec2(0.5, 0.0)).x;\n    float wave = (2.0*texture( iChannel1, vec2(.1,0.5) ).z);\n    \n    //Set the main light position, which will move around slightly based\n    //on the audio wave.\n    vec3 light = vec3(-5.0,0.0,-5.0);\n    light.x = wave*cos(iTime);\n    light.y = wave*sin(iTime);\n    \n    //Attenuate blob color based on frequency and wavelength of the audio\n    blobColor.yz -= wave/5.0;\n    blobColor *= 3.0*freq;\n    \n    //attenuate main light intensity based on the frequency of the audio\n    mainLi = mainLi + 2.0*freq;\n    \n    //gently move the ambient color across the color spectrum based on the sine\n    //of the global time\n    ambColor = vec4(cos(iTime)/40.0+.01, sin(iTime)/75.0+.01, (cos(iTime)+sin(iTime))/100.0+.01, 1.0);\n    \n    //Add our main light to the light list\n    lights[0] = light;\n    \n    //Set up our tubes scattered across the tube space.\n    float ycurr = 1.0;\n    float xcurr = -12.0;\n    \n    int currTubeNum = 0;\n    \n    //Amount that we want to stagger every other row of tubes.\n    float stagger = 1.9;\n    \n    for (int i = 0; i < numTubes; i++)\n    {   \n        //Set the position of the tube's blob. It will move up the length of \n        //the tube, while also animating to the audio. The blobs in each tube\n        //all start at different locations along the tube.\n        float blobLoc = hash(float(i))*wave*70.0-50.0+(fract(iTime))*50.0;\n        \n        //If we've reached the top of the tube, go back down.\n        if (blobLoc > 5.0)\n        {\n            blobLoc -= 15.0;\n        }\n        \n        //Add this tube and its blob light source to the tube and light lists.\n        tubes[i] = vec4(xcurr, ycurr, 0.5,blobLoc);\n        lights[i+1] = vec3(xcurr, blobLoc, ycurr);\n        \n        //Move to the x location where we will place our next tube.\n        xcurr += tubeSpace.x/5.0;\n        \n        //If we've reached the end of an even row, jump to the next row\n        //without staggering.\n        if (mod(ycurr,2.0)==0.0 && xcurr > 12.0+stagger)\n        {\n            xcurr = -12.0;\n            ycurr += tubeSpace.y/5.0;\n        }\n        \n        //If we're at the end of an odd row, jump to the next row with some\n        //stagger\n        if (mod(ycurr,2.0)!=0.0 && xcurr > 12.0)\n        {\n            xcurr = -12.0+stagger;\n            ycurr += tubeSpace.y/5.0;\n        }\n    }\n    \n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;  \n    \n    //Render!\n    render(fragColor, vec3(p, cam.z+2.0));\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdSDj", "name": "Perfect Tree Spiral", "author": "vox", "description": "Reduced code by ~200 characters. Didn't use last rotateZ suggestion because one of my rotateZ's is for squares defined by 4 vertices. Thanks, as always, Fabrice!", "tags": ["perfecttreespiral"], "likes": 8, "viewed": 613, "date": "1461625373", "time_retrieved": "2024-06-20T18:34:56.937451", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime)\n#define saw(x) (acos(cos(x))/PI)\n#define stair floor\n#define jag fract\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(iTime)*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn (1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5)*uv.x;\n\telse\n\t\treturn (0.0);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0+saw(time/4.0)*4.0;\n    float r = pow(log(length(uv)+1.), .75);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+theta/turns+iTime*.2), saw(theta/turns+iTime*.1));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 uv = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    \n\tconst int max_iterations =8;\n\n    float scale = 2.0*PI;\n    uv *= scale;\n    uv -= scale/2.0;\n    //uv.xy += vec2(cos(iTime*.234), sin(iTime*.345))*1.0;\n    uv.xy = spiral(uv.xy*scale);\n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = PI*(float(i)/(float(max_iterations) ));\n        scale = 2.0;//pow(amplitude, length(uv0*2.0-1.0)/sqrt(2.0)*sin(time*GR/2.0+float(i)-1.0));\n        //if(i == 0) uv.xy = (uv.xy*2.0-1.0)*vec2(iResolution.x/iResolution.y, 1.0)*.5+.5;\n        //    uv.xy += .125*vec2(sin(time/PI), cos(time/2.0*GR));\n        uv.xy = tree(uv.xy);\n        map += square(uv.xy, float(i));\n    }\n    \n    float map2 = 0.0;\n    /*\n    noise = 1.0;\n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        uv = spiral(uv);\n        map2 += uv.g*noise;\n        \n        noise *= clamp(.95-fwidth(map2), 0.0, 1.0);\n    }\n    */\n    \n    \n    \n    \n    fragColor.rg = uv.rg;//saw(uv.zw);//saw(uv.zw*PI);\n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    //fragColor = vec4(noise);\n    fragColor.rgb = phase(map+time)*\n        \t\t\tclamp(map, 0.0, 1.0);\n    return;\n/*\n\tconst int max_iterations = 8;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        noise += clamp(1.0-fwidth(map), 0.0, 1.0);\n        \n        uv = tree(uv); \n        \n        map += square(uv, float(i)/float(max_iterations))/noise;\n    } \n    map = map*PI + time;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdSzS", "name": "A Sphere and its shadow", "author": "jake", "description": "No raytracing involved, haha :)", "tags": ["phong", "sphere"], "likes": 11, "viewed": 209, "date": "1460083888", "time_retrieved": "2024-06-20T18:34:56.937451", "image_code": "void mainImage(out vec4 O, vec2 U)\n{\n\tvec2\n        R  = iResolution.xy,\n        uv = U / max(R.x, R.y),\n        c  = vec2(.5,.275),\n       \tq  = (uv-c)/.5,\n       \tm  = vec2(5.*cos(iTime/3.)*sin(iTime/2.), 5.*sin(iTime/11.)*cos(iTime/7.));\n\n    float\n      \tr = .2,\n        d2 = dot(q,q),\n        zd = r*r-d2,\n        mm = dot(m,m),\n        p0 = (1.+5.*pow(.5+.75*sin((iTime+1.)/5.)*cos(iTime), 2.))+mm/500.,\n      \tz = sqrt(abs(zd));\n\n\tvec3\n\t\tl      = vec3(m,8.*(.1+.3*sin(iTime))),\n\t\tp      = vec3(q,z),\n        p2l    = l-p,\n        p2ldir = normalize(p2l),\n        n      = normalize(p);\n    \n    float i    = dot(p2ldir, n),\n          j    = pow(abs(i), i>0.?p0:(1./p0));\n          j    += abs(max((.1*p0-1.0), 0.)*((j*i>0.)?pow(abs(i), 10.):0.0));\n    \n    O = vec4(j);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXD7", "name": "Sphere complex", "author": "Fluffy", "description": "Infinite spheres raymarched with a minimum marching distance.", "tags": ["raymarching"], "likes": 8, "viewed": 399, "date": "1459826327", "time_retrieved": "2024-06-20T18:34:56.937451", "image_code": "#define REFLECTIONS 2\n#define GLOSSY 0.9\n\n#define PI 3.14159265359\nvec3 sunDir;\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat terrainFunction(vec3 pos)\n{\n    float d = sin(iTime / 20.0) * 0.5 + 0.75;\n    vec3 c = vec3(d);\n    pos = mod(pos, c) - 0.5 * c;\n        \n    float time = iTime * 1.0;\n    \n    vec3 nPos1 = vec3(pos.x, pos.y - 1.0, pos.z);\n    vec3 nPos2 = vec3(pos.x, pos.y + 1.0, pos.z);\n    vec3 nPos3 = vec3(pos.x, pos.y, pos.z + 1.0);\n    vec3 nPos4 = vec3(pos.x, pos.y, pos.z - 1.0);\n    vec3 nPos5 = vec3(pos.x + 1.0, pos.y, pos.z);\n    vec3 nPos6 = vec3(pos.x - 1.0, pos.y, pos.z);\n    \n    return -\n        opS(sdSphere(nPos6, 0.5),\n        opS(sdSphere(nPos5, 0.5),\n        opS(sdSphere(nPos4, 0.5),\n        opS(sdSphere(nPos3, 0.5),\n        opS(sdSphere(nPos2, 0.5),\n        opS(sdSphere(nPos1, 0.5),\n        sdSphere(pos, 1.0)))))));\n}\n\nvec3 normalAt(vec3 pos)\n{\n    float epsilon = 0.01;\n    \n    float s = terrainFunction(pos);\n    float dx = s - terrainFunction(vec3(pos.x + epsilon, pos.y, pos.z));\n    float dy = s - terrainFunction(vec3(pos.x, pos.y + epsilon, pos.z));\n    float dz = s - terrainFunction(vec3(pos.x, pos.y, pos.z + epsilon));\n                                   \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat march(vec3 offset, vec3 dir)\n{\n    const float minDist = 3.0;\n    const float maxDist = 20.0;\n    const float delta = 1.0;\n\tfloat amp = 0.001;\n    \n    float lastTer = 0.0;\n    float closest = 0.0;\n    \n    float d = minDist;\n    \n    for (float t = 0.0; t < 256.0; t++)\n    {\n        if (d > maxDist)\n            break;\n        vec3 pos = offset + dir * d;\n        float ter = terrainFunction(pos);\n        \n        if (ter >= amp)\n            return d - delta + delta * ((amp -lastTer) / (ter - lastTer));\n        \n        lastTer = ter;\n        \n        if (ter > closest)\n            closest = ter;\n        \n        d += delta;\n    }\n    \n    return closest - amp;\n}\n\nvec3 rotX(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cy = c * vec.y;\n    float sy = s * vec.y;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(vec.x, cy - sz, sy + cz));\n}\n\nvec3 rotY(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cx = c * vec.x;\n    float sx = s * vec.x;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(cx - sz, vec.y, sx + cz));\n}\n\nvec3 shade(vec3 position, vec3 rayDir)\n{\n    vec3 col = vec3(sin(iTime / 13.0) * 0.3 + 0.5, 0.8, sin(iTime / 4.0) * 0.2 + 0.8);\n    \n    float mul = 1.0;\n    \n    for (int i = 0; i < REFLECTIONS + 1; i++)\n    {\n    \tvec3 normal = normalAt(position);\n        col = col * (1.0 - mul) + mul * clamp(dot(normal, sunDir), 0.4, 1.0) * col * 1.4;\n        \n        vec3 dir = vec3(1.0, 0.0, 0.0);\n        col += vec3(sin(iTime / 10.0) * 0.5 + 0.5, 0.2, 0.6) * clamp(dot(normal, dir), 0.0, 1.0) * 0.5;\n        col *= sin(iTime / 4.0) / 4.0 + 1.0;\n        \n        rayDir = reflect(rayDir, normal);\n        \n        float dist = march(position, rayDir);\n        if (dist >= 0.0)\n            position = (position + rayDir * dist);\n        else\n            break;\n        \n        mul *= GLOSSY;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunDir = normalize(vec3(0.0, sin(iTime), cos(iTime)));\n    \n    vec3 cameraPos = vec3(sin(iTime / 7.0), sin(iTime / 5.0) * 3.0, sin(iTime / 13.0));\n    float focalLength = sin(iTime / 2.0) * 4.0 + 5.0;\n    float x = fragCoord.x / iResolution.x - 0.5;\n    float y = (fragCoord.y / iResolution.y - 0.5) * (iResolution.y / iResolution.x);\n    \n    float lookX = iTime / 4.0;\n    float lookY = iTime / 5.18513;\n    \n    vec3 rayDir = normalize(vec3(x * focalLength, -1, y * focalLength));\n    rayDir = rotX(rayDir, lookX);\n    rayDir = rotY(rayDir, lookY);\n    \n    float dist = march(cameraPos, rayDir);\n    if (dist < 0.0)\n        return;\n    \n    vec3 pos = (cameraPos + rayDir * dist);\n    \n\tvec3 color = shade(pos, rayDir);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXDB", "name": "basicRT", "author": "DimitryK", "description": "Implementing a raytracer using the geometric solution to the ray-sphere intersection.", "tags": ["basic"], "likes": 0, "viewed": 108, "date": "1461379416", "time_retrieved": "2024-06-20T18:34:56.937451", "image_code": "struct Sphere{\n \tvec3 origin;\n    float radius;\n};\n    \nstruct Ray{\n  \tvec3 origin;\n    vec3 dir;\n};      \n\nstruct RayIntersect{\n    Sphere sp;\n    vec3 ip0;\n    vec3 ip1;\n    bool is_intersecting;\n};\n\n\nRayIntersect myIntersect( in Sphere sphere, in Ray ray)\n{\n    RayIntersect Ri = RayIntersect(sphere, vec3(0.0), vec3(0.0), false);\n    vec3 L = sphere.origin - ray.origin;\n    \n    float r2 = sphere.radius * sphere.radius;\n    \n    float tca = dot(L, ray.dir);\n    \n    if (tca < 0.0) return Ri;\n    \n    float d2 = dot(L, L) - tca*tca;\n    \n    if (d2 > r2) return Ri;\n    \n    Ri.is_intersecting = true;\n    \n    float tch = sqrt( r2 - d2 );\n    float t0 = tca - tch;\n    float t1 = tca + tch;\n    \n    Ri.ip0 = ray.origin + ray.dir * t0;\n    Ri.ip1 = ray.origin + ray.dir * t1;\n    \n    return Ri;\n}\n\n\nvec3 diffuse ( vec3 lp, RayIntersect Ri, vec3 color)\n{\n\tvec3 ld = normalize(lp - Ri.sp.origin);\n    vec3 n = normalize(Ri.ip0 - Ri.sp.origin);\n    \n    return color * max(0.0, dot(n, ld));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x * 2.0 - 1.0;\n    uv.y = uv.y * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    // Ray origin = ro, direction = rd\n    Ray ray = Ray(vec3(0.0, 0.0, -2.0), normalize( vec3( uv, 1.0) ));\n    Sphere sp = Sphere(vec3(0.0, 0.0, 0.0), 1.);\n    \n    // Intersect with the scene\n    //float id = intersect( ro, rd );\n    \n    \n    vec3 col = vec3(1.0);\n    vec3 amb = vec3(145.0, 221.0, 221.0) / 255.0 * 0.12;\n    \n    RayIntersect intersect = myIntersect( sp, ray);\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    \n    vec3 litePos = vec3( -0.5+3.5*cos(0.75*time),\n                         1.0,\n                         0.5 + 3.5*sin(0.75*time) );\n    \n    \n    \n    if (intersect.is_intersecting == true){\n        col = diffuse(litePos, intersect, col)*0.7 + amb;\n        fragColor = vec4(min(col, 1.0),1.0);\n    }\n    else{\n        fragColor = vec4(0.0, 0.0, 0.0 ,1.0);\n    }\n\t\n}", "image_inputs": [{"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXDj", "name": "Crater Nation", "author": "Passion", "description": "Using the bumpmap, 3d texturing, and greyscale fuctions from Shane's 'Abstract Corridor' and magicBox function from dgreensp's 'Magic Fractal'", "tags": ["fractal", "raymarch", "bumpmap", "magicbox"], "likes": 7, "viewed": 295, "date": "1461651199", "time_retrieved": "2024-06-20T18:34:57.889119", "image_code": "#define MAX_STEPS 32\n#define EPS .001\n\nfloat time = iTime;\nconst int MAGIC_BOX_ITERS = 16;\nconst float MAGIC_BOX_MAGIC = 0.65;\n\n//https://www.shadertoy.com/view/4ljGDd - dgreensp\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n// Rotation\nmat2 rot2D(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a),  cos(a));       \n}\n\n// Sphere or moon in this case\nfloat map(vec3 p){\n    return length(p) - 1.; //min(s, s2);\n}\n\n// Raymarching\nfloat trace(vec3 o, vec3 r, inout vec3 hitPos){\n    float hit = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++){\n        vec3 p = o + r * hit;\n        float dist = map(p);\n        if(dist < EPS) break;\n        hit += dist * 0.5;\n    }\n    hitPos = o + hit*r;\n    \n    return hit;\n}\n\n// Normal mapping\nvec3 getNormal( in vec3 p ){\n\n    vec2 e = vec2(0.5773,-0.5773)*EPS;   //0.001;\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + \n                      e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n\n// Specular highlights from an article I was looking at\n// https://machinesdontcare.wordpress.com/2008/10/29/subsurface-scatter-shader/\nfloat blinnPhongSpe(vec3 norm, vec3 dLight, float shine){\n    vec3 halfVecAngle = normalize(vec3(norm + dLight));\n    return pow(clamp(dot(norm, halfVecAngle), 0.0, 1.0), shine);\n}\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Directional Light\n    vec3 dLight = normalize(vec3(0.25, 0.8, 0.5));\n    \n    // Adjust and set up uv Coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Initializing fragColor\n    fragColor = vec4(0.0);\n    \n    // Rotate Light a bit\n    dLight.xz *= rot2D(time*.5);\n    dLight.xy *= rot2D(time);\n    \n    // Create the ray with a bit of wide angle/fish eye lens effect\n    vec3 r = normalize(vec3(uv, 1.0- dot(uv,uv) * 0.333)); // \n    \n    // Camera origin\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    \n    // Rotate the ray and camera a look at function may be better...\n    r.xz*=rot2D(time/2.-iMouse.x/50.);\n    o.xz*=rot2D(time/2.-iMouse.x/50.);\n    \n    r.zy*=rot2D(time/3.);\n    o.zy*=rot2D(time/3.);\n    \n    // Hit position for normal mapping\n    vec3 hitPos = vec3(0.0);\n    float t = trace(o, r, hitPos);\n    \n    // Sphere or background for\n    float sphOrBg = map(o + r*t);\n    \n    // Get the normal\n    vec3 norm = getNormal(hitPos);\n    // Reset the normal using the bump map function\n    norm = doBumpMap(iChannel0, hitPos*(1.0/3.0), norm, 0.025);\n    \n    // Diffuse\n    float diff = clamp(dot(norm, dLight), 0.015, 1.0);\n    // Specular\n    float spec = blinnPhongSpe(norm, dLight, 180.);\n    \n    vec4 bg = vec4(0.0); //vec4(.69, .79, 1.0 , 1.0);\n    //bg *= dot(dLight, r)*.5 + .5;\n    vec3 p = 0.26*M*r;\n    vec3 p2 = 0.24*M*r;\n    \n    float mb = magicBox(p2+time*.015);\n    mb *= .025;\n    // level of detail.\n    //vec3(uv*3., 0.0);\n    \n    float result = magicBox(p+time*.01);\n    // Scale to taste.  Also consider non-linear mappings.\n    result *= 0.018;\n    // Background color\n    bg = vec4(result*result*mb,result*result*result*mb,result*result*result*result*mb,1.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    if(abs(sphOrBg) < 0.5){\n        // mixing for fog not nessecary here...\n        fragColor = vec4(diff+spec); //mix(vec4(vec3(diff+spec), 1.0), bg, smoothstep(.2, .4, t*.03));\n    }else\n        fragColor = bg;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXW7", "name": "Psychedelia", "author": "bwestlin", "description": "My fist shadertoy attempt, a psychadelic sinus effect", "tags": ["2d", "sound", "soundcloud"], "likes": 2, "viewed": 184, "date": "1460394769", "time_retrieved": "2024-06-20T18:34:57.889119", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / max(iResolution.x, iResolution.y);\n    vec2 m = vec2(1.0, iResolution.y / iResolution.x) / 2.0;\n    float t = (iTime + 100.0) / 4.0;\n    float s = 0.01 + 0.99 * min(texture(iChannel0, vec2(1.0, 0.0)).x * 1.5, 1.0);\n    float s2 = 0.99 + 0.01 * s;\n    vec2 p = vec2(\n        m.x + sin(t * 4.0 + s * 4.0) * m.x * s,\n        m.y + cos(t * 4.0 + s * 4.0) * m.y * s);\n    float d = distance(uv.xy, p) * 20.0 * s;\n\tfragColor = vec4(\n        0.7 + 0.3 * sin(d * sin(t * s2 * 1.0) * 16.0),\n        0.7 + 0.3 * sin(d * sin(t * s2 * 1.5) * 4.0),\n        0.7 + 0.3 * sin(d * sin(t * s2 * 2.3) * 2.0),\n        1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXzl", "name": "Flower Spiral", "author": "vox", "description": "Flower Spiral", "tags": ["flowerspiral"], "likes": 2, "viewed": 506, "date": "1461011511", "time_retrieved": "2024-06-20T18:34:58.919333", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time (float(__LINE__)+iTime/PI)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 stair(vec2 x)\n{\n    return vec2(stair(x.x), stair(x.y));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, time*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\nvec2 spiral(vec2 uv, out float layer)\n{\n    //uv = normalize(uv)*log(length(uv)+1.0);\n    float turns = 1.0;\n    float r = log(pow(PI, length(uv)+time))/(PI);\n    float theta = turns*(atan(uv.y, uv.x)+r);\n    layer += stair(r);\n    return vec2(saw(r*PI), saw(theta));\n}\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5*uv.x;\n\telse\n\t\treturn 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float z = 0.0;\n    \n    float map = 1.0;\n    \n    float scale = log(time)+time;//pow(E, amplitude*log(saw(iTime/lambda)+E));\n    uv *= scale;\n    uv -= scale/2.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    uv = normalize(uv)*log(length(uv)+E);\n    \n    \n    uv = spiral(uv, z);\n    uv = spiral(uv*2.0-1.0, z);\n\n\n\tconst int max_iterations = 16;\n\n    float noise = 0.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iterations = float(i)/float(max_iterations);\n        \n        uv = tree(uv); \n        \n        map *= 1.0+iterations*square(uv, iterations);\n        noise += map;\n    }\n    map = log(map+noise)*PI + time/PI+z*PI;\n    fragColor.rg = uv;\n    fragColor.b = 0.0;\n    \n    vec3 jolt = 1.0-pow(saw(time), 4.0)*\n        \t\t\tphase(time);\n    \n    fragColor = vec4(vec3(saw(map+jolt.x),\n                          saw(4.0*PI/3.0+map+jolt.y),\n                          saw(2.0*PI/3.0+map+jolt.z)),\n                     1.0);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstSWN", "name": "Breathing Mandelbrot", "author": "macrocosme", "description": " Mandelbrot set fractal versus time", "tags": ["mandelbrotfractal"], "likes": 4, "viewed": 619, "date": "1459467456", "time_retrieved": "2024-06-20T18:34:58.919333", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec2 c=vec2(2.0)*(uv-0.5)+vec2(0.0,0.0); /* constant c, varies onscreen*/\n    vec2 z=c;\n    /* Mandelbrot iteration: keep iterating until z gets big */\n    for (int i=0;i<300;i++) {\n        /* break if length of z is >= 4.0 */\n        if (z.r*z.r+z.g*z.g>=4.0) break;\n        /* z = z^2 + c;  (where z and c are complex numbers) */\n        z=vec2(\n            z.r*z.r-z.g*z.g,\n            2.0*z.r*z.g\n        )+c;\n    }\n        fragColor=fract(vec4(z.r*tan(iTime),abs(z.g/tan(iTime)),tan(iTime)/0.25*length(z),0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstXD7", "name": "collab x cabbibo", "author": "macbooktall", "description": "cabbibo and i are ping ponging some code and rendering gifs and this march is from the first we made here: https://twitter.com/Cabbibo/status/717753579553959936\n\nuse mouse to adjust camera", "tags": ["raymarch"], "likes": 13, "viewed": 312, "date": "1459818183", "time_retrieved": "2024-06-20T18:35:01.089357", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n// License Creative Commons Attribution-NonCommercial License.\n// Includes code from hg_sdf library by Mercury http://mercury.sexy/hg_sdf/\n// Also includes smooth min by IQ http://iquilezles.org/www/articles/smin/smin.htm\n\nconst float MAX_TRACE_DISTANCE = 4.0; // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 50;\n\n#define MOUSE_CAM \n//#define ROTATE_SHAPE\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\nfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\nfGDFEnd\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n, float phase) {\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    p.x += phase * x;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n        p += size*(c - stop);\n        c = stop;\n    }\n    if (c <start) {\n        p += size*(c - start);\n        c = start;\n    }\n    return c;\n}\n\n// From https://www.shadertoy.com/view/XtjSRm\n// shane code\nfloat vNoise( in vec3 p )\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) ); p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy); \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\n\nfloat shapeSize = .75;\n\nvec2 map1(vec3 pos) {\n\n    vec3 p = pos;\n    float rep = 8.;\n    vec2 idx = floor((pos.xz - shapeSize) / max(pos.xz,0.3))*0.1;\n    float i = pModPolar(pos.xz, rep);\n    float clock = iTime*4.;\n    float phase = length(pos.xz)*4.;\n    float anim = sin(phase + clock);\n    \n    pos.x -= shapeSize*1. + anim*0.05;\n\n    float dist = fTorus(pos, shapeSize*0.25, shapeSize*0.5);\n    float centerTorus = fTorus(p, shapeSize*0.25, shapeSize);\n    float centerOcta = fOctahedron(p - vec3(0.,cos(clock)*0.05,0.), shapeSize*0.75);\n\n    dist = fOpUnionStairs(dist, centerTorus, .1 + anim*0.1, 4., 0.);\n    dist = smin(dist, centerOcta, 0.2);\n\n    vec2 res = vec2(dist, abs(pos.y));\n\nreturn res;\n}\n\nvec2 map2(vec3 pos , float io) {\n\n    vec3 p = pos;\n    float rep = 4.;\n\n    float i = pModPolar(pos.xz, rep);\n    float x = pModInterval1(pos.x, shapeSize*0.05, 0., 15.);\n    float clock = iTime*4.;\n    float phase = length(pos.xz)*2.;\n    float anim = sin(phase + clock);\n    \n    pos.x -= shapeSize*.35;\n    pos.z -= anim*0.1;\n\n    float dist = fOctahedron(pos, shapeSize*.25);\n    float centerShape = fOctahedron(p,shapeSize*0.8);\n\n    dist = min(dist, centerShape);\n    \n    vec2 res = vec2(dist, abs(pos.y));\n    res.x = io * res.x;\n\n    return res;\n}\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvec2 map( vec3 pos , float io ){ \n\n    #ifdef ROTATE_SHAPE\n    pos.xz = rotate(pos.xz, iTime);\n    pos.xy = rotate(pos.xy, sin(iTime*4.)*0.1);\n\t#endif\n    \n\treturn mix(map1(pos),map2(pos , io),0.3);\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd , float io ){\n    float h = INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    vec2 m = map( ro+rd*t , io );\n    h = m.x;\n    t += h;\n    id = m.y;\n\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return vec2( res , id );\n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos, in float io ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n    map(pos+eps.xyy , io).x - map(pos-eps.xyy , io).x,\n    map(pos+eps.yxy , io).x - map(pos-eps.yxy , io).x,\n    map(pos+eps.yyx , io).x - map(pos-eps.yyx , io).x );\n    return normalize(nor);\n}\n\n// Gets background color if nothing is hit\n// also used for refraction\nvec3 bgCol( in vec3 p ){\n\n    float n = vNoise( p * .2 + sin( iTime * 4.0 ) * .005) * vNoise( p * 1. + sin( iTime * 4.0 )* .005);\n    vec3 disPos = vec3( p );\n    vec3 c = n * (normalize(disPos)*.5+ .5 );// * texture( iChannel0 , normalize(-p )).xyz;\n    \n    c = vec3( n *n *n * 10.0);\n    \n    return c;\n}\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n    vec3 color = vec3( 0. );\n\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n\n    float ior = .8; // index of refraction\n    float lba = .02; // light bend amount\n\n    if( res.y > -.5 ){\n\n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos , 1. );\n\n        vec3 lightDir = normalize( lightPos - pos );\n\n        float match = max( 0. , dot( lightDir , norm ));\n\n        vec3 refrR = refract( rd , norm , ior * (1. - lba) );\n        vec3 refrG = refract( rd , norm , ior * 1. );\n        vec3 refrB = refract( rd , norm , ior * (1. + lba) );\n\n        vec3 posR = pos + refrR * INTERSECTION_PRECISION * 1000.;\n        vec3 posG = pos + refrG * INTERSECTION_PRECISION * 1000.;\n        vec3 posB = pos + refrB * INTERSECTION_PRECISION * 1000.;\n\n        //vec3 colR = texture( iChannel0 , refrR ).xyz * vec3( 1. , 0., 0. );\n        //vec3 colG = texture( iChannel0 , refrG ).xyz * vec3( 0. , 1., 0. );\n        //vec3 colB = texture( iChannel0 , refrB ).xyz * vec3( 0. , 0., 1. );\n\n        float r = 0.;\n        float g = 0.;\n        float b = 0.;\n\n\n        vec2 resR = calcIntersection( posR , refrR , -1. );\n        vec2 resG = calcIntersection( posG , refrG , -1. );\n        vec2 resB = calcIntersection( posB , refrB , -1. );\n\n\n        vec3 p2 , n2 , r2;\n\n        if( resR.y == 2. ){\n        p2 = posR + refrR * resR.x;\n        n2 = calcNormal( p2 , -1. );\n\n\n        r = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n\n        p2 = posR + refrR * resR.x;\n        n2 = calcNormal( p2 , -1. );\n        r2 = refract( refrR , n2 , ior * (1. - lba) );\n\n        r = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).x;\n\n    }\n\n    if( resG.y == 2. ){\n\n        p2 = posG + refrG * resG.x;\n        n2 = calcNormal( p2 , -1. );\n        g = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n\n        p2 = posG + refrG * resG.x;\n        n2 = calcNormal( p2 , -1. );\n        r2 = refract( refrG , n2 , ior * 1. );\n        g = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).y;\n    }\n\n    if( resB.y == 2. ){\n\n    p2 = posB + refrB * resB.x;\n    n2 = calcNormal( p2 , -1. );\n    b = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n\n    p2 = posB + refrB * resB.x;\n    n2 = calcNormal( p2 , -1. );\n    r2 = refract( refrB , n2 , ior * (1. + lba) );\n\n    b = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).z;\n\n    }\n\n\n    color = vec3( r , g , b );\n\n\n\n\n\n\n\n\n\n\n\n    }else{\n\n    color = bgCol( rd * MAX_TRACE_DISTANCE );\n\n    }\n\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    #ifdef MOUSE_CAM    \n    float angle = iMouse.x / iResolution.x * 2. * 3.14 ;\n    float y = ((iMouse.y / iResolution.y ) -.5 ) * 2.0;\n\n    vec3 ro = vec3( cos( angle ) * shapeSize*4. , y , sin( angle ) * shapeSize*4. );\n    #else\n    vec3 ro = vec3( shapeSize*4. + cos( iTime*4. ) * 0.025 , 0. ,shapeSize +  sin( iTime*4. ) * .025 );    \n    #endif\n\n    vec3 ta = vec3( 0. , 0. , 0. );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, .0 ); // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.5) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( ro , rd , 1. );\n\n\n    vec3 color = render( res , ro , rd );\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-nd-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsVGWW", "name": "stripeeees", "author": "dysposin", "description": "stripes", "tags": ["stripes"], "likes": 0, "viewed": 136, "date": "1460221169", "time_retrieved": "2024-06-20T18:35:01.089357", "image_code": "float stripe(vec2 uv){\n    float speed = 40.;\n    float noLines = 100.;\n    float str = .6;\n    float w = sin((uv.y+(iTime/speed))*noLines);\n    w = w*str;\n\treturn w-.2;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 texColor = texture(iChannel0,uv);\n        \n    fragColor = vec4(texColor.b, texColor.gr+stripe(uv),1.0);\n    \n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3SDf", "name": "Voronoi Eyes", "author": "zackpudil", "description": "These meetings tho .....", "tags": ["2d", "voronoi"], "likes": 1, "viewed": 179, "date": "1461787565", "time_retrieved": "2024-06-20T18:35:01.089357", "image_code": "float hash(float n) {\n\treturn fract(sin(n)*43758.4543621);\n}\n\nfloat noise(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tfloat n = p.x + p.y*57.0;\n\t\n\treturn mix(\n\t\tmix(hash(n + 00.0), hash(n + 01.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x),\n\t\tf.y);\n}\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\t\n\tf += 0.5000*noise(p); p *= 2.01;\n\tf += 0.2500*noise(p); p *= 2.03;\n\tf += 0.1250*noise(p); p *= 2.04;\n\tf += 0.0625*noise(p); p *= 2.00;\n\t\n\tf /= 0.9375;\n\t\n\treturn f;\n}\n\nvec2 hash(vec2 x) {\n\tvec2 n = vec2(dot(x, vec2(171, 311)), dot(x, vec2(269, 382)));\n\treturn fract(sin(n)*43785.454621);\n}\n\nvec3 voronoi(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tvec2 mr, mg;\n\tfloat md = 8.0;\n\t\n\tfor(int i = -1; i <= 1; i++) {\n\t\tfor(int j = -1; j <= 1; j++) {\n\t\t\tvec2 g = vec2(float(i), float(j));\n\t\t\tvec2 o = hash(p + g);\n\t\t\to = 0.5 + 0.5*sin(6.28*o + iTime);\n\t\t\tvec2 r = g + o - f;\n\t\t\tfloat d = dot(r, r);\n\t\t\t\n\t\t\tif(d < md) {\n\t\t\t\tmd = d;\n\t\t\t\tmr = r;\n\t\t\t\tmg = g;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(sqrt(md), mr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 v = voronoi(2.0*uv);\n\tvec3 col = mix(vec3(1), vec3(0), v.x*v.x);\n\t\n\tfloat r = length(v.yz);\n\tfloat a = atan(v.z, v.y);\n\t\n\tif(r < 0.3) {\n\t\tr -= 0.1*smoothstep(0.05, 0.1, 0.5*abs(0.2*sin(iTime + 2.0*v.x)));\n\t\ta = fbm(20.0*uv);\n\t\t\n\t\tfloat f = 0.0;\n\t\tcol = vec3(0.2, 0.4, 0.8);\n\t\t\n\t\tf = smoothstep(0.24, 0.25, r);\n\t\tcol = mix(col, vec3(0, 0, 1), f);\n\t\t\n\t\tf = smoothstep(0.3, 1.0, fbm(vec2(5.0*r, 15.0*a)));\n\t\tcol = mix(col, vec3(0, 0.6, 0.7), 2.0*f);\n\t\t\n\t\tf = smoothstep(0.05, 0.1, r);\n\t\tcol = mix(col, vec3(0), 1.0 - f);\n\t\t\n\t\tf = smoothstep(0.25, 0.3, r);\n\t\tcol = mix(col, vec3(1), f);\n\t}\n\t\n\tcol = mix(col, vec3(1, 0, 0), smoothstep(0.7, 1.0, fbm(vec2(5.0*r, 3.0*a))));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3SDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3SRS", "name": "Canyon perlin 2D", "author": "Daedelus", "description": "canyon terrain noise\npreliminal experiment for background in: https://www.pouet.net/prod.php?which=67336\nI seem to have copy pasted the entirity of the hg_sdf library into this, shoutouts to mercury for that", "tags": ["canyon"], "likes": 7, "viewed": 157, "date": "1460805764", "time_retrieved": "2024-06-20T18:35:01.089357", "image_code": "// GLSL Compatible and semi-minified HG_SDF from: http://mercury.sexy/hg_sdf/\n/*#define PI 3.14159265359\nconst float _1=.57735026919;\nconst vec2 _A=normalize(vec2(2.61803398875, 1));\nconst vec2 _B=normalize(vec2(1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fPlane(vec3 p,vec3 n,float d){return dot(p,n)+d;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fBox2Cheap(vec2 p,vec2 b){vec2 q=abs(p)-b;return max(q.x,q.y);}\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}\nfloat fCorner(vec2 p){vec2 q=min(p,0.);return length(max(p,0.))+max(q.x,q.y);}\nfloat fBlob(vec3 p){p=abs(p);if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;float l=length(p),b=max(max(max(dot(p,vec3(_1)),dot(p.xz,_A)),dot(p.yx,_B)),dot(p.xz,_B));return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*PI,PI));}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}*/\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\n/*float fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}\nfloat fDisc(vec3 p,float r){float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\nfloat fHexagonCircumcircle(vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*0.866+q.z*.5,q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*0.866,h.y));}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\n*/void pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}/*\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;p=abs(p)-d;return s;}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\nfloat fOpUnionChamfer(float a,float b,float r){return min(min(a,b),(a-r+b)*sqrt(.5));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(max(a,b),(a+r+b)*sqrt(.5));}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat fOpUnionRound(float a,float b,float r){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat fOpUnionColumns _M(1.)p.x+=0.70710678118*-r+c*1.41421356237;if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return min(min(min(length(p)-c,p.x),a),b);}\nfloat fOpDifferenceColumns _M(-1.)p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat fOpUnionStairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n*/float fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}/*\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\nfloat fOpEngrave(float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\nfloat fOpTongue(float a,float b,float ra,float rb){return min(a,max(a-ra,abs(b)-rb));}*/\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat perlin(vec3 x)\n{\n    return (noise(x) + noise(x * 2.0) * 0.5 + noise(x * 12.0) * 0.5 + noise(x * 24.0) * 0.25) * 0.25;\n}\n\nfloat perlin2(vec2 x)\n{\n\treturn (\n         16.0 * texture(iChannel0, x * 0.3) + \n         6.0 * texture(iChannel0, x) + \n         3.0 * texture(iChannel0, x * 3.0) + \n         0.3 * texture(iChannel0, x * 12.0) + \n         0.2 * texture(iChannel0, x * 25.0)).x * 0.1;\n}\n\nfloat fField(vec3 point, out float material)\n{\n    material = 0.0;\n\t\n    vec3 pt = (point + vec3(2.2, 0.21, 6.6)) * 7.5;\n    pt.x += sin(pt.y * 4.0) * 0.02;\n    float cactus = fCapsule(pt, 0.14, 1.6);\n    float cactus1 = fCapsule(pt + vec3(0.6, 0.0, 0.0), 0.1, 0.5);\n    float cactus2 = fCapsule(pt - vec3(0.4, 0.1, 0.0), 0.12, 0.6);\n    float cactus3 = fCapsule(pt.yxz + vec3(0.55, 0.13, 0.0), 0.12, 0.35);\n    cactus = fOpUnionSoft(cactus, cactus1, 0.3);\n    cactus = fOpUnionSoft(cactus, cactus2, 0.2);\n    cactus = fOpUnionSoft(cactus, cactus3, 0.2);\n    cactus /= 7.5;\n    \n    float ground = point.y;\n    float offset = perlin2(point.xz * 0.005);\n    point.y = cos(point.y * 2.6) * 0.5 + 0.5;\n    offset += perlin2(point.yz * vec2(0.1, 0.01)) * 0.1;\n    \n    float distance = ground + offset;\n    if(cactus < distance)\n    {\n        distance = cactus;\n        material = 1.0;\n    }\n    \n    return distance;\n}\n\nfloat fField(vec3 point)\n{\n    float stub;\n\treturn fField(point, stub);\n}\n\nvec3 Gradient(vec3 intersection, float distance)\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize(vec3(fField(intersection + epsilon.xyy),\n    fField(intersection + epsilon.yxy),\n    fField(intersection + epsilon.yyx))\n        - distance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    const float DISTANCE_SCALE = 0.4;\n    const float FOV_BIAS = 0.14;\n    const int RAY_STEPS = 150;\n    const float NEAR_CLIP = 0.5;\n    const float FAR_CLIP = 30.0;\n    const vec3 SKY = vec3(0.2, 0.4, 0.7);\n    const vec3 HORIZON = vec3(0.9, 1.0, 0.9);\n    const float TILT = 0.11;\n    vec3 normal, intersection, origin = vec3(0.0, 0.0, -10.0), direction = vec3(0.0, 0.0, 1.0);\n    pR(direction.xz, uv.x * FOV_BIAS);\n    pR(direction.yz, uv.y * FOV_BIAS - TILT);\n    \n    pR(origin.xz, iTime * 0.1);\n    pR(direction.xz, iTime * 0.1);\n    \n    float material, distance, totalDistance = NEAR_CLIP;\n    for(int i =0 ;  i < RAY_STEPS; ++i)\n    {\n        intersection = origin + direction * totalDistance;\n        distance = fField(intersection, material) * DISTANCE_SCALE;\n        totalDistance += distance;\n        if(distance <= 0.0 || totalDistance >= FAR_CLIP)\n            break;\n    }\n    \n    normal = Gradient(intersection, distance);\n    float diffuse = max(0.0, dot(normalize(vec3(sin(iTime), 0.2, 0.0)), normal) * 0.7 + 0.3);\n    \n    vec3 color;\n    if(material == 0.0)\n        color = mix(vec3(0.6, 0.1, 0.06), vec3(1.0, 0.6, 0.17), noise(intersection.yyy * 20.0));\n    else\n        color = vec3(0.1, 0.7, 0.0) * noise(intersection * vec3(300.0, 20.0, 300.0)) + vec3(0.1, 0.2, 0.15);\n    color *= (diffuse + vec3(0.2, 0.1, 0.6));\n    \n    float fog = min(totalDistance / FAR_CLIP, 1.0);\n    vec3 skyColor = mix(HORIZON, SKY, pow(abs(direction.y), 0.5));\n    \n\tfragColor = vec4(mix(color, skyColor, fog * fog), 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3SRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3SWX", "name": "Pi Train Integer Test", "author": "mzadami", "description": "Test code for integer arithmetic extracted from Pi Train: https://www.shadertoy.com/view/MdtXWj\n\nIf your WebGL implementation supports ints, then you'll see green digits of pi all the way down.\n", "tags": ["pi", "integer"], "likes": 7, "viewed": 191, "date": "1461743641", "time_retrieved": "2024-06-20T18:35:03.883376", "image_code": "// ============================================================================================\n//\n// ShaderToy test of integer maths working in your WebGL implementation for Fabrice\n//\n// Works out a single base 10 digit of pi using a lovely formula I discovered which\n// has a nice base-10 feel to it!\n//\n// pi/4 = 7/10 + 22/200 - 52/3000 - 312/40000 + 2/5000000 + 2852/6000000 + ...\n//\n// The nth term is given by ImaginaryPart[3(3i+1)^n - (2i-1)^n] / n10^n\n//\n\nconst int POW10_PER_COMPONENT\t= 7;\nconst int BASE_FOR_NUMBER\t\t= 10000000;\nconst int MAX_DIGIT\t\t\t\t= 60;\nconst int MAX_1OVER3_TERMS\t\t= 122;\nconst int MAX_2OVER11_TERMS\t\t= 93;\n\nbool IsZero(ivec4 lo)\n{\n\treturn lo.x == 0 && lo.y == 0 && lo.z == 0 && lo.w == 0;\n}\n\n// Returns +1(a>b), 0, -1(a<b)\nint CompareAbsValues(ivec4 a, ivec4 b)\n{\n\tif (a.w > b.w) {return +1;}\n\tif (a.w < b.w) {return -1;}\n\t\t\n\tif (a.z > b.z) {return +1;}\n\tif (a.z < b.z) {return -1;}\n\n\tif (a.y > b.y) {return +1;}\n\tif (a.y < b.y) {return -1;}\n\n\tif (a.x > b.x) {return +1;}\n\tif (a.x < b.x) {return -1;}\n\n\treturn 0;\n}\n\nvoid DivMod(int a, int b, out int out_div, out int out_mod)\n{\n\tif (a == 0)\n\t{\n\t\tout_div = 0;\n\t\tout_mod = 0;\n\n\t\treturn;\n\t}\n\n\tout_div = a / b;\n\tout_mod = a - out_div * b;\n}\n\nint Mod(int a, int b)\n{\n\tint div = a / b;\n\tint mod = a - b * div;\n\n\treturn mod;\n}\n\nivec4 Div(ivec4 a, int divisor, out int out_mod)\n{\n\tivec4 ans = a;\n\n\tif (ans.w != 0)\n\t{\n\t\tint div_w;\n\t\tint mod_w;\n\n\t\tDivMod(ans.w, divisor, div_w, mod_w);\n\n\t\tans.w  = div_w;\n\t\tans.z += mod_w * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.z != 0)\n\t{\n\t\tint div_z;\n\t\tint mod_z;\n\n\t\tDivMod(ans.z, divisor, div_z, mod_z);\n\n\t\tans.z  = div_z;\n\t\tans.y += mod_z * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.y != 0)\n\t{\n\t\tint div_y;\n\t\tint mod_y;\n\n\t\tDivMod(ans.y, divisor, div_y, mod_y);\n\n\t\tans.y  = div_y;\n\t\tans.x += mod_y * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.x != 0)\n\t{\n\t\tint div_x;\n\t\tint mod_x;\n\n\t\tDivMod(ans.x, divisor, div_x, mod_x);\n\n\t\tans.x = div_x;\n\n\t\tout_mod =  mod_x;\n\t}\n\telse\n\t{\n\t\tout_mod = 0;\n\t}\n\n\treturn ans;\n}\n\nivec4 Double(ivec4 a)\n{\n\tivec4 ans = a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\t}\n\n\treturn ans;\n}\n\nivec4 Treble(ivec4 a)\n{\n\tivec4 ans = a + a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\n\t\tif (ans.x >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.x -= BASE_FOR_NUMBER;\n\t\t\tans.y += 1;\n\t\t}\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\n\t\tif (ans.y >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.y -= BASE_FOR_NUMBER;\n\t\t\tans.z += 1;\n\t\t}\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\n\t\tif (ans.z >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.z -= BASE_FOR_NUMBER;\n\t\t\tans.w += 1;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nivec4 Add(ivec4 a, ivec4 b)\n{\n\tivec4 ans = a + b;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\t}\n\n\treturn ans;\n}\n\n// a must be > b\nivec4 Sub(ivec4 a, ivec4 b)\n{\n\tivec4 ans = a - b;\n\n\tif (ans.x < 0)\n\t{\n\t\tans.x += BASE_FOR_NUMBER;\n\t\tans.y -= 1;\n\t}\n\n\tif (ans.y < 0)\n\t{\n\t\tans.y += BASE_FOR_NUMBER;\n\t\tans.z -= 1;\n\t}\n\n\tif (ans.z < 0)\n\t{\n\t\tans.z += BASE_FOR_NUMBER;\n\t\tans.w -= 1;\n\t}\n\n\treturn ans;\n}\n\nivec4 Add(ivec4 a, bool aneg, ivec4 b, bool bneg, out bool out_a_plus_b_neg)\n{\n\tif (aneg == bneg)\n\t{\n\t\tout_a_plus_b_neg = aneg;\n\n\t\treturn Add(a,b);\n\t}\n\n\t// Signs are different.\n\tint sign = CompareAbsValues(a,b);\n\n\tif (sign == 0)\n\t{\n\t\tout_a_plus_b_neg = false;\n\n\t\treturn ivec4(0,0,0,0);\n\t}\n\n\tif (sign < 0)\n\t{\n\t\tout_a_plus_b_neg = bneg;\n\t\t\t\n\t\treturn Sub(b,a);\n\t}\n\n\tout_a_plus_b_neg = aneg;\n\n\treturn Sub(a,b);\n}\n\n// Divides by BASE_FOR_NUMBER.\nvoid ApplyShift(out ivec4 a)\n{\n\ta.x = a.y;\n\ta.y = a.z;\n\ta.z = a.w;\n\ta.w = 0;\n}\n\t\n// Return Frac(10^power * Abs(num)/denom)\nfloat GetFractionalPart(ivec4 numerator, int denominator, int power_of_ten)\n{\n\tif (power_of_ten >= 0)\n\t{\n\t\tint m;\n\t\tDiv(numerator, denominator, m);\n\n\t\tconst int MAX_ITERS = MAX_DIGIT / POW10_PER_COMPONENT;\n\n\t\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t\t{\n\t\t\tif (power_of_ten < POW10_PER_COMPONENT)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm *= BASE_FOR_NUMBER;\n\t\t\tm  = Mod(m, denominator);\n\n\t\t\tpower_of_ten -= POW10_PER_COMPONENT;\n\n\t\t\tif (m == 0)\n\t\t\t{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\tif (power_of_ten >= 4) {m = Mod(10000 * m, denominator); power_of_ten -= 4;}\n\t\tif (power_of_ten >= 2) {m = Mod(100   * m, denominator); power_of_ten -= 2;}\n\t\tif (power_of_ten >= 1) {m = Mod(10    * m, denominator); power_of_ten -= 1;}\n\t\t\t\n\t\treturn float(m) / float(denominator);\n\t}\n\n\tconst int NUM_POWERS_OF_10_TO_KEEP = 4;\n\n\t// Throw away terms we don't need.\n\tconst int MAX_ITERS = MAX_DIGIT / POW10_PER_COMPONENT;\n\n\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t{\n\t\tif (power_of_ten + POW10_PER_COMPONENT > -NUM_POWERS_OF_10_TO_KEEP)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tApplyShift(numerator);\n\n\t\tif (IsZero(numerator))\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tpower_of_ten += POW10_PER_COMPONENT;\n\t}\n\n\t// Divide by the denominator to get the fractional part in the wrong place...\n\tint the_mod;\n\n\tnumerator = Div(numerator, denominator, the_mod);\n\t\t\n\tfloat ans = float(the_mod) / float(denominator);\n\n\t// We can't divide by more than 100 at a time.\n\tconst int MAX_DIV100_ITERS = (NUM_POWERS_OF_10_TO_KEEP + POW10_PER_COMPONENT) / 2;\n\n\tfor (int iter = 0; iter < MAX_DIV100_ITERS; iter++)\n\t{\n\t\tif (power_of_ten > -2)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tnumerator = Div(numerator, 100, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.01;\n\n\t\tpower_of_ten += 2;\n\t}\n\n\t// And one more if required.\n\tif (power_of_ten == -1)\n\t{\n\t\tnumerator = Div(numerator, 100, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.1;\n\t}\n\n\treturn fract(ans);\n}\n\n// Im((2i - 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral2(int nth_digit)\n{\n\tint\t\tnum_terms\t= 8 + (MAX_2OVER11_TERMS-8) * nth_digit / (MAX_DIGIT-1);\n\tint\t\tshift\t\t= 0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tivec4 re = ivec4(1,0,0,0); bool re_neg = true;\n\tivec4 im = ivec4(2,0,0,0); bool im_neg = false;\n\n\tfor (int term = 1; term < MAX_2OVER11_TERMS; term++)\n\t{\n\t\tint shifted_digit = nth_digit - term + shift;\n\n\t\tfloat f = GetFractionalPart(im, term, shifted_digit);\n        \n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w*3 < 0 ||\n\t\t\tre.w*3 < 0)\n\t\t{\n\t\t\tint mod;\n\n\t\t\tim = Div(im,10,mod);\n\t\t\tre = Div(re,10,mod);\n\n\t\t\tshift += 1;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tivec4 new_re = Add(Double(im), !im_neg, re, !re_neg, new_re_neg);\n\t\tivec4 new_im = Add(Double(re),  re_neg, im, !im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\n// Im((3i + 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral3(int nth_digit)\n{\n\tint\t\tnum_terms\t= 8 + (MAX_1OVER3_TERMS-8) * nth_digit / (MAX_DIGIT-1);\n\tint\t\tshift\t\t= 0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tivec4 re = ivec4(1,0,0,0); bool re_neg = false;\n\tivec4 im = ivec4(3,0,0,0); bool im_neg = false;\n\n\tfor (int term = 1; term < MAX_1OVER3_TERMS; term++)\n\t{\n\t\tint shifted_digit = nth_digit - term + shift;\n\n\t\tfloat f = GetFractionalPart(im, term, shifted_digit);\n\n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w*3 < 0 ||\n\t\t\tre.w*3 < 0)\n\t\t{\n\t\t\tint mod;\n\n\t\t\tim = Div(im,10,mod);\n\t\t\tre = Div(re,10,mod);\n\n\t\t\tshift += 1;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tivec4 new_re = Add(Treble(im), !im_neg, re, re_neg, new_re_neg);\n\t\tivec4 new_im = Add(Treble(re),  re_neg, im, im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\nint GetNthDigitOfPi(int nth_digit)\n{\n\tfloat a = GetNthDigitOfSpiral3(nth_digit);\n\tfloat b = GetNthDigitOfSpiral2(nth_digit);\n\n\tfloat s = 4.0 * (a*3.0-b);\n\n\ts -= floor(s);\n\n\tint digit = int(floor(10.0 * s));\n\n\treturn digit;\n}\n\n// =========================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv\t\t= fragCoord.xy / iResolution.xy;\n    float\taspect\t= float(iResolution.x) / float(iResolution.y);\n\n    uv.y  = 1.0 - uv.y;\n    uv.x *= aspect;\n    uv   *= 10.0;\n    \n    // Scrolling through time...\n    float fdigit = uv.y + max(0.0, (iTime - 2.0) * 0.5);\n    \n    // So we get nice gaps.\n    if (fract(fdigit) < 0.1 || fract(fdigit) > 0.9 || fract(uv.x) < 0.1 || fract(uv.x) > 0.9)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    // -1 so we get a 3 first!\n    int digit_to_find\t= int(fdigit) - 1;\n    int nth_digit_of_pi\t= GetNthDigitOfPi(digit_to_find);\n    \n    if (int(uv.x) >= nth_digit_of_pi || digit_to_find >= MAX_DIGIT)\n    {\n        fragColor = vec4(0.1,0.1,0.1,1.0);\n        return;\n\t}\n\n    // Is it correct?\n\tbool correct = false;\n\n\tif (digit_to_find == -1 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find ==  0 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find ==  1 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find ==  2 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find ==  3 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find ==  4 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find ==  5 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find ==  6 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find ==  7 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find ==  8 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find ==  9 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 10 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 11 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 12 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 13 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 14 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 15 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 16 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 17 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 18 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 19 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find == 20 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 21 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find == 22 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 23 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 24 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 25 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 26 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 27 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 28 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 29 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 30 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 31 && nth_digit_of_pi == 0) {correct = true;}\n\tif (digit_to_find == 32 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 33 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 34 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 35 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 36 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find == 37 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 38 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 39 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find == 40 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find == 41 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 42 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 43 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 44 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 45 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 46 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 47 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 48 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find == 49 && nth_digit_of_pi == 0) {correct = true;}\n\tif (digit_to_find == 50 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 51 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 52 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 53 && nth_digit_of_pi == 0) {correct = true;}\n\tif (digit_to_find == 54 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 55 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 56 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 57 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 58 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 59 && nth_digit_of_pi == 4) {correct = true;}\n    \n\tif (correct)\n\t{\n\t    fragColor = vec4(0.1,1.0,0.2,1.0);\n\t}\n\telse\n\t{\n\t    fragColor = vec4(0.8,0.3,0.2,1.0);\n\t}\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3SWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3SzB", "name": "perlin noise demo 2D", "author": "hcf", "description": "little demo", "tags": ["perlinnoisedemo"], "likes": 17, "viewed": 1143, "date": "1459961374", "time_retrieved": "2024-06-20T18:35:03.889462", "image_code": "#define cloud\n//#define turbulence\n//#define marble\n//#define granite\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return  -1.+2.*fract(sin(h)*43758.5453123);\n}\n\nvec2 hash22(vec2 p)\n{\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283 + iTime);\n}\n\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    float ym = mix(xm1,xm2,w.y); \n    return ym;\n   \n}\n\nfloat noise_sum(vec2 p){\n    p *= 4.;\n\tfloat a = 1., r = 0., s=0.;\n    \n    for (int i=0; i<5; i++) {\n      r += a*perlin_noise(p); s+= a; p *= 2.; a*=.5;\n    }\n    \n    return r/s;///(.1*3.);\n}\n\nfloat noise_sum_abs(vec2 p)\n{\t\n    p *= 4.;\n\tfloat a = 1., r = 0., s=0.;\n    \n    for (int i=0; i<5; i++) {\n      r += a*abs(perlin_noise(p)); s+= a; p *= 2.; a*=.5;\n    }\n    \n    return (r/s-.135)/(.06*3.);\n}\n\nfloat noise_sum_abs_sin(vec2 p)\n{\t\n    p *= 7.0/4.0;\n    float f = noise_sum_abs(p);\n    f = sin(f * 1.5 + p.x * 4.0);\n    \n    return f *f;\n}\n\nfloat noise_one_octave(vec2 p){\n    float r = 0.0;\n\tr += 0.125*abs(perlin_noise(p*30.));\n    return r;\n}\n\nfloat noise(vec2 p){\n\n\t#ifdef marble\n    \treturn noise_sum_abs_sin(p);\n    #elif defined turbulence\n    \treturn noise_sum_abs(p);\n    #elif defined granite\n    \treturn noise_one_octave(p);\n    #elif defined cloud\n    \treturn noise_sum(p);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv *= vec2(iResolution.x/iResolution.y,1.);\n     \n    float f = noise(uv);\n    \n    f = f*0.5+0.5;\n    \n    vec3 lightColor = vec3(1.0);\n\t\n    vec3 color = vec3(lightColor*f);\n   \n\tfragColor = vec4(color,1.0);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3SzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3XDB", "name": "paper lantern", "author": "kaswan", "description": "paper lantern created with ray marching.\n\nglow effect is actually subsurface scatterring.", "tags": ["raymarching", "glow", "paper", "lantern"], "likes": 9, "viewed": 259, "date": "1461238524", "time_retrieved": "2024-06-20T18:35:04.871494", "image_code": "// Paper Lantern created by SeongWan Kim (kaswan / twitter @idgmatrix)\n// Thanks to iq and @kevinroast \n// shadow and glow effect codes from http://www.kevs3d.co.uk/dev/shaders/distancefield6.html\n\n#define EPSILON 0.005\n#define MAX_ITERATION 256\n#define AO_SAMPLES 4\n#define SSS_SAMPLES 5\n#define SHADOW_RAY_DEPTH 16\n\nfloat longitude;\nfloat latitude;\nfloat sphere(vec3 pos)\n{\n    float r = 1.0;\n    \n    vec3 rpos = pos;\n    \n    float time = iTime * 0.5;\n\tfloat s = sin(time);\n    float c = cos(time);\n    \n    rpos.x = pos.x * c + pos.z * s; \n    rpos.z = pos.x * s - pos.z * c; \n    \n    float d = length(rpos);\n    \n    longitude = atan(rpos.z, rpos.x);\n    latitude = asin(rpos.y / d);\n    \n    d += abs(sin(longitude * 3.0) * 0.15) * abs(sin(latitude * 14.0) * 0.15);\n    \n    d -= r;\n    \n    return d;\n}\n\nfloat cylinder(vec3 pos, vec3 c)\n{\n  return length(pos.xz - c.xy) - c.z;\n}\n\nfloat paperLantern(vec3 pos)\n{\n    float d = sphere(pos);\n    return max(d, -cylinder(pos, vec3(0.0, 0.0, 0.45)));\n}\n\nbool isPlane = false;\nfloat plane(vec3 pos, vec4 n)\n{\n \tfloat d = dot(pos, n.xyz) - n.w;\n    \n    if (d < EPSILON) isPlane = true;\n    \n    return d;\n}\n\nfloat scene(vec3 pos)\n{\n    float d;\n    \n    d = paperLantern(pos);\n    d = min(d, plane(pos, vec4(0.0, 1.0, 0.0, -1.2)));\n    d = min(d, plane(pos, vec4(0.0, 0.0, -1.0, -10.0)));\n    d = min(d, plane(pos, vec4(1.0, 0.0, 0.0, -6.0)));\n    d = min(d, plane(pos, vec4(-1.0, 0.0, 0.0, -6.0)));\n    \n    return d;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n   float r = 0.0;\n   float w = 1.0;\n   for (int i = 1; i <= AO_SAMPLES; i++)\n   {\n      float d0 = float(i) * 0.2;\n      r += w * (d0 - scene(p + n * d0));\n      w *= 0.5;\n   }\n   return 1.0 - clamp(r, 0.0, 1.0);\n}\n\nfloat calcSSS(vec3 ro, vec3 rd)\n{\n   float total = 0.0;\n   float weight = 0.5;\n   for (int i = 1; i <= SSS_SAMPLES; i++)\n   {\n      float delta = pow(float(i), 2.5) * EPSILON * 32.0;\n      total += -weight * min(0.0, sphere(ro+rd * delta));\n      weight *= 0.9;\n   }\n   return clamp(total, 0.0, 1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n\tvec3 p = ro + rd * 0.12;\n    \n\tfor (int i = 0; i < SHADOW_RAY_DEPTH; i++)\n    {\n     \t\n        float d = scene(p);\n        \n        if (d < EPSILON) {\n        \treturn 0.0;\n        }\n        \n        p += rd * d;\n    }\n    \n    return 1.0;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k)\n{\n   float res = 1.0;\n   float t = 0.12;         \n   for (int i = 0; i < SHADOW_RAY_DEPTH; i++)\n   {\n      float h = scene(ro + rd * t);\n      res = min(res, k*h/t);\n      t += h;\n      if (t > 5.0) break; \n   }\n   return clamp(res, 0.25, 1.0);\n}\n\nvec3 lightColor = vec3(1.2, 1.0, 0.5);\n//vec3 sssColor = vec3(1.9 + 0.1 * abs(sin(iTime * 6.0)), 1.3, 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;    \n    \n\tvec3 sssColor = vec3(1.9 + 0.1 * abs(sin(iTime * 6.0)), 1.3, 0.5);\n    vec3 d = vec3(uv, -2.0) - vec3(0.0, -0.0, -5.0);;\n    vec3 rd = normalize(d);\n    \n    vec3 lpos = vec3(-2.0*sin(iTime * 0.5), 3.0, -2.0*cos(iTime * 0.5));\n    //vec3 lpos = vec3(-2.0, 3.0, -2.0);\n    \n    vec3 pos = vec3(0.0, 0.0, -5.0);\n    \n    float distance;\n    \n    for (int i = 0; i < MAX_ITERATION; i++) {\n\t    \n        distance = scene(pos);\n        \n        if (distance < EPSILON) {\n\t\t\t\n\t\t\tvec3 eps = vec3(EPSILON, 0.0, 0.0);\n            vec3 normal;\n        \t    \n            normal.x = scene(pos + eps.xyz) - scene(pos - eps.xyz);\n            normal.y = scene(pos + eps.yxz) - scene(pos - eps.yxz);\n            normal.z = scene(pos + eps.zyx) - scene(pos - eps.zyx);\n            \n            vec3 n = normalize(normal);\n            vec3 l = normalize(lpos - pos);\n            \n            vec3 light = max(dot(n,l),0.0) * lightColor * 0.5;\n\n            vec4 tex;\n            if (isPlane) {\n            \tvec4 c;\n\t\t\t\ttex = texture(iChannel0, pos.yz * 0.2) * abs(n.x);\n            \ttex += texture(iChannel0, pos.zx * 0.2) * abs(n.y);\n            \ttex += texture(iChannel0, pos.xy * 0.2) * abs(n.z);\n                \n                light *= tex.xyz * vec3(1.0, 0.45, 0.1);\n            }\n            else{\n                vec2 uv = vec2(longitude, latitude); \n\t\t\t\ttex = texture(iChannel1, uv * 1.0);\n                \n                light += tex.xyz * 0.08;\n            }\n            \n\t\t\tlight *= softShadow(pos, l, 8.0) * 1.5;\n\t\t\tlight = mix(light, sssColor, calcSSS(pos, rd));\n            light += calcAO(pos, n) * 0.3;\n            \n            fragColor = vec4(light, 1.0);\n            \n\t\t\treturn;\n        }\n\n        pos += distance * rd;\n    \n    }\n    \n\tfragColor = vec4(1.0, 0.2, 0.0, 1.0);   \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3XDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcSRj", "name": "Wormhood", "author": "finalman", "description": "Glowing microscopic worms? Maybe?", "tags": ["distancefields"], "likes": 13, "viewed": 680, "date": "1460207160", "time_retrieved": "2024-06-20T18:35:04.877346", "image_code": "const int MAX_STEPS = 200;\nconst int NUM_SPHERES = 12;\n\nfloat sphere(vec3 pos, float radius, vec3 smpl)\n{\n    return length(pos - smpl) - radius;\n}\n\nfloat plane(vec3 dir, float offset, vec3 smpl)\n{\n    return dot(dir, smpl) + offset;\n}\n\nfloat dfDist(vec3 smpl)\n{\n    float T1 = 10.0;\n    float T2 = 2.0 * T1;\n    \n    float result = 10000.0;\n    \n    smpl.y += sin(smpl.z * 0.2 + iTime) * sin(iTime * 1.33)\n              + sin(smpl.x * 0.3 + iTime) * sin(iTime * 3.22)\n              + sin(smpl.x * 0.5 + smpl.z * 0.22 + iTime) * sin(iTime * 2.22 + smpl.z * 0.1);\n    float o = floor((smpl.z + T1) / T2);\n    smpl.x += o * 7.0;\n    smpl.xz = mod(smpl.xz + T1, T2) - T1;\n    \n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float t = float(i) / float(NUM_SPHERES);\n        float n = t + iTime * 0.25 + o * 0.5;\n        vec3 pos = vec3(sin(n * 5.0) * 5.0, cos(n * 3.0) * 9.0, cos(n * 2.0) * 3.0 + 5.0);\n        float radius = texture(iChannel0, vec2(t*t)).x * 2.0 + 1.4;\n        result = min(result, sphere(pos, radius, smpl));\n    }\n    \n    result = min(result, plane(vec3(0, -1, 0), 10.0, smpl));    \n    result = min(result, plane(vec3(0, 1, 0), 10.0, smpl));    \n    \n    return result;\n}\n\nvec3 dfNormal(vec3 smpl)\n{\n    const float E = 0.04;\n    \n    float d0 = dfDist(smpl);\n    float dX = dfDist(smpl + vec3(E, 0, 0));\n    float dY = dfDist(smpl + vec3(0, E, 0));\n    float dZ = dfDist(smpl + vec3(0, 0, E));\n    \n    return normalize(vec3(dX - d0, dY - d0, dZ - d0));\n}\n\nfloat dfOcclusion(vec3 smpl, vec3 normal)\n{\n    float N = 1.0;\n    return clamp(dfDist(smpl + normal * N) / N, 0.0, 1.0);\n}\n\nfloat trace(inout vec3 pos, vec3 dir, out vec3 normal)\n{\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        steps++;\n        float d = dfDist(pos);\n        pos += d * dir * 1.0;\n        \n        if (d < 0.001)\n        {\n            break;\n        }\n    }\n    \n    normal = dfNormal(pos);\n    return float(steps) / float(MAX_STEPS);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 opos = vec3(4.5,sin(iTime * 0.4) * 3.0 + 2.0,-7.0 + iTime * 3.0);\n    vec3 pos = opos;\n    vec3 dir = normalize(vec3((fragCoord.x - iResolution.x * 0.5) / iResolution.y, fragCoord.y / iResolution.y - 0.5, 1.0));\n    vec3 normal;\n    \n    float steps = trace(pos, dir, normal);\n    float occ = dfOcclusion(pos, normal);\n    float fogAmt = 1.0 - exp(-distance(opos, pos) * 0.01);\n    vec3 fogCol = vec3(0.2, 0.14, 0.18);\n    \n    vec3 diffuse = vec3(0.4, 0.5, 0.6) * dot(normal, normalize(vec3(1.0, 0.3, -1.0)));\n    vec3 ambient = vec3(0.4, 0.2, 0.1);\n    vec3 color = (ambient + diffuse) * vec3(1.0 - steps) + pow(1.0 - occ, 1.5) * vec3(1.0, 0.9, 0.8) * 0.8;\n    \n    \n    color = mix(color, fogCol, fogAmt);\n    color = (1.0 - exp(-color * 1.5)) * 1.3;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcSzj", "name": "Blockscape", "author": "finalman", "description": "Cubey!", "tags": ["distancefield"], "likes": 13, "viewed": 744, "date": "1460215832", "time_retrieved": "2024-06-20T18:35:04.877604", "image_code": "const int MAX_STEPS = 200;\n\nvec2 getHex(vec2 pos)\n{\n    return floor(pos + 0.5);\n}\n\nfloat getHexHeight(vec2 hex)\n{\n    return (mix(texture(iChannel0, hex / 256.0, -100.0).x * 10.0, 4.5, \n                1.5 * pow(sin(hex.x * 0.133 + hex.y * 0.7 - iTime * 0.1), 2.0)) - 9.0) * 0.35;\n}\n\nfloat getPlaneDist(vec3 point, vec3 normal, vec3 smpl)\n{\n    return dot(smpl - point, normal);\n}\n\nfloat getHexDist(vec2 hex, vec3 smpl)\n{\n    float result = smpl.y - getHexHeight(hex);\n    \n    result = max(result, getPlaneDist(vec3(hex.x + 0.48, 0.0, hex.y), vec3( 1.0, 0.0,  0.0), smpl));\n    result = max(result, getPlaneDist(vec3(hex.x - 0.48, 0.0, hex.y), vec3(-1.0, 0.0,  0.0), smpl));\n    result = max(result, getPlaneDist(vec3(hex.x, 0.0, hex.y + 0.48), vec3( 0.0, 0.0,  1.0), smpl));\n    result = max(result, getPlaneDist(vec3(hex.x, 0.0, hex.y - 0.48), vec3( 0.0, 0.0, -1.0), smpl));\n    \n    return result;\n}\n\nfloat dfDist(vec3 smpl)\n{\n    smpl.xz *= mat2(sin(1.), cos(1.), -sin(1.), cos(1.));\n    \n    float result = 1000.0;\n    \n    vec2 centerHex = getHex(smpl.xz);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 hex = centerHex + vec2(x, y);\n            result = min(result, getHexDist(hex, smpl));\n            result = min(result, getHexDist(hex, smpl * vec3(1.0, -1.0, 1.0)));\n        }\n    }\n    \n    \n    return result;\n}\n\nvec3 dfNormal(vec3 smpl)\n{\n    const float E = 0.02;\n    \n    float d0 = dfDist(smpl);\n    float dX = dfDist(smpl + vec3(E, 0, 0));\n    float dY = dfDist(smpl + vec3(0, E, 0));\n    float dZ = dfDist(smpl + vec3(0, 0, E));\n    \n    return normalize(vec3(dX - d0, dY - d0, dZ - d0));\n}\n\nfloat dfOcclusion(vec3 smpl, vec3 normal)\n{\n    float N = 0.3;\n    return clamp(dfDist(smpl + normal * N) / N, 0.0, 1.0);\n}\n\nfloat trace(inout vec3 pos, vec3 dir, out vec3 normal)\n{\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        steps++;\n        float d = dfDist(pos);\n        pos += d * dir * 0.75;\n        \n        if (d < 0.001)\n        {\n            break;\n        }\n    }\n    \n    normal = dfNormal(pos);\n    return float(steps) / float(MAX_STEPS);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 origin = vec3(0.2, 0.0, iTime);\n    vec3 pos = origin;\n    vec3 dir = normalize(vec3((fragCoord.x - iResolution.x * 0.5) / iResolution.y,\n                              fragCoord.y / iResolution.y - 0.7,\n                              1.0));\n    vec3 normal;\n    \n    float steps = trace(pos, dir, normal);\n    float occ = dfOcclusion(pos, normal);\n    float fogAmt = 1.0 - exp(-distance(origin, pos) * 0.01);\n    vec3 fogCol = vec3(0.2, 0.14, 0.18);\n    \n    vec3 diffuse = vec3(0.4, 0.5, 0.6) * clamp(dot(normal, normalize(vec3(1.0, 1.3, -1.0))), 0.0, 1.0);\n    vec3 ambient = vec3(0.4, 0.2, 0.1);\n    vec3 color = (ambient * occ + diffuse) * 4.0 / abs(pos.y * pos.y * pos.y);\n    \n    color = mix(color, fogCol, fogAmt);\n    color = (1.0 - exp(-color));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcXW2", "name": "thumbsup", "author": "Tapped", "description": "Share whenever you feel that the like button on Facebook is too dull :thumbsup:", "tags": ["like", "thumb", "facebook", "thumbsup"], "likes": 4, "viewed": 151, "date": "1461613589", "time_retrieved": "2024-06-20T18:35:04.877604", "image_code": "const float eps = 0.01;\n\nfloat sdCappedCylinder(in vec3 p, in vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r)\n{\n \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 rotateZ(in vec3 p, float a)\n{\n    vec3 r;\n    r.x = p.x*cos(a) + p.y*sin(a);\n    r.y = p.x*sin(a) - p.y*cos(a);\n    r.z = p.z;\n    return r;\n}\n\nvec3 rotateY(in vec3 p, float a)\n{\n    vec3 r;\n    r.x = p.x*cos(a) + p.z*sin(a);\n    r.z = p.x*sin(a) - p.z*cos(a);\n    r.y = p.y;\n    return r;\n}\n\nvec2 trace(in vec3 p)\n{    \n    p = rotateY(p, iTime*1.8);\n    float mat = 1.;\n    float base = sdCappedCylinder(rotateZ(p-vec3(-1.0,0,0), 3.14 * 0.5), vec2(1,0.5));\n    float oY = 0.7;\n    float thumb = min(sdCapsule(p, vec3(0.5,oY,0), vec3(0.7,0.7 + oY,0), 0.35),\n                      sdCapsule(p, vec3(0.7,0.7 + oY,0), vec3(0.65,1.0 + oY,0), 0.35));\n    float otherFingers = udRoundBox(p-vec3(1,0,0), vec3(0.2, 0.3, 0.2), 0.65);//length(p - vec3(0.5, 0, 0)) - 0.81;\n    float fingers = min(min(sdCappedCylinder(rotateZ(p, 3.14 * 0.5), vec2(0.8,0.5)), thumb)\n                        , otherFingers);\n    \n    if(fingers < base)\n        mat = 2.;\n    \n    return vec2(min(fingers, base), mat);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 e = vec3(eps*10.,0,0);\n    vec3 n;\n    n.x = trace(p+e.xyz).x-trace(p-e.xyz).x;\n    n.y = trace(p+e.yxz).x-trace(p-e.yxz).x;\n    n.z = trace(p+e.yzx).x-trace(p-e.yzx).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2((fragCoord.x - iResolution.x *.5) / iResolution.y, \n                   (fragCoord.y - iResolution.y *.5) / iResolution.y);\n    \n    vec3 rP = vec3(0,0.4,6.);\n    vec3 rD = normalize(vec3(uv, -1));\n    \n    vec3 bgColor = vec3(0.4,0.36,0.4-0.05*uv.y)*(1.0-0.25*length(uv*2.));\n    vec3 color = bgColor;\n    float t = 0.;\n    for(int i = 0;i < 36;++i)\n    {\n        vec3 p = rP + rD * t;\n        vec2 d = trace(p);\n        if(d.x < eps)\n        {\n            vec3 n = calcNormal(p);\n            if(d.y == 1.)\n            \tcolor = vec3(0.3,0.3,0.9); \n            else\n                color = vec3(1.0,1.0,1.0);\n            \n            color *= 2. * max(dot(n, vec3(0.33)), 0.) + 0.1;\n            break;\n        }\n        \n        t += d.x;\n    }\n    \n\tfragColor = vec4(color,1);//vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcXzj", "name": "stupid circles", "author": "ungzd", "description": "Lol", "tags": ["circle"], "likes": 2, "viewed": 158, "date": "1460224839", "time_retrieved": "2024-06-20T18:35:04.877604", "image_code": "\nfloat dots(vec2 st) {\n    vec2 st2 = st * 9.728;\n    float radius = 0.3 + sin(iTime * 3.0) * 0.056 + st.x * 0.220;\n    return smoothstep(radius, radius+0.05, distance(st2, vec2(floor(st2.x), floor(st2.y)) + vec2(0.5, 0.5)));\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rotated_dots(vec2 st) {\n    return dots((st + vec2(-0.5)) * rotate2d(sin(iTime*0.3)*3.0));\n}\n\nfloat circle(vec2 st, float boundary) {\n    float border = 0.004;\n    return smoothstep(boundary-border, boundary+border, distance(vec2(0.5, 0.5), st));\n}\n\nfloat pulse(float x) {\n    const float k = 6.384;\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat pulses() {\n    const float speed = 1.872;\n    return pulse(fract(iTime * speed))*0.05 + 0.3;\n}\n\nfloat waves(vec2 st) {\n    st *= rotate2d(iTime);\n    vec2 st2 = vec2(sin(st.x * 4.608), sin(st.y * 2.336));\n    st2 *= rotate2d(iTime);\n    float patt = sin(st2.x * 30.936 + 5.932) + sin(st2.x * 24.0 - 10.376) + sin(st2.y * 29.0 + 2.372) + sin(st2.y * 45.0);\n    return smoothstep(0.3, 0.6, patt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    st += vec2(-iResolution.y/(1.5*iResolution.x), 0.);\n    \n    vec3 background = mix(vec3(0.043,0.800,0.599), vec3(0.053,0.980,0.734), rotated_dots(st));\n    vec3 fgcircle = mix(vec3(1.000,0.070,0.464), vec3(0.620,0.022,0.429), waves(st));\n    vec3 foreground = mix(fgcircle, background, vec3(circle(st, pulses())));\n    \n    fragColor = vec4(foreground, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddSDS", "name": "chocolate factory", "author": "tomaes", "description": "delete lines 13/14 for different effects.", "tags": ["2d", "abstract", "experimental", "slow", "style"], "likes": 4, "viewed": 188, "date": "1461326575", "time_retrieved": "2024-06-20T18:35:04.877604", "image_code": "float render(vec2 _uv, float _t)\n{\n   return (sqrt( (sin(_uv.x*2.0+_t)  *\n                  cos(_uv.y*1.0+_t)) * \n                 (_uv.x+_uv.y) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float t = 200.0+iTime * 10.5;  \n\n    t += 1.94 / sqrt(sin(uv.x*20.0)+cos(uv.y*20.0));  \n    t -= sin(t*0.0001*uv.x*50.0)*39.0 / sqrt(sin(uv.x*20.0)+cos(uv.y*20.0));\n    \n    float c = 0.5*render(uv, t*t*sqrt(uv.x*0.02+uv.y*0.001)*0.003) + \n        \t  0.5*render(uv, t*t*sqrt(uv.x*0.01+uv.y*0.010)*0.002);\n        \n    if (c < 0.55)\n        c -= abs(0.5-c);\n        \n\tfragColor = vec4(c*1.25+uv.y*0.2,c*1.25,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddSRs", "name": "disco saturn", "author": "substack", "description": "saturn with some warping and color blending", "tags": ["saturn"], "likes": 5, "viewed": 770, "date": "1461013755", "time_retrieved": "2024-06-20T18:35:06.095743", "image_code": "//glsl-noise:\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat torus (vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\nmat4 scale (float x, float y, float z) {\n  return mat4(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);\n}\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvec3 sunpos = vec3(20,10,20);\nvec2 model(vec3 p) {\n  mat4 m = invert(scale(1.8,0.3,1.8));\n  float ring = torus(vec3(m*vec4(p,1)),vec2(4.5,0.5))\n    + snoise(p*8.0)*0.05;\n  float planet = sphere(p,4.0);\n  float sun = sphere(p-sunpos,2.0);\n  return vec2(min(ring,min(planet,sun)));\n}\n\nvec3 calcNormal(vec3 pos) {\n  const float eps = 0.002;\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(v1*model(pos + v1*eps).x\n    + v2*model(pos + v2*eps).x\n    + v3*model(pos + v3*eps).x\n    + v4*model(pos + v4*eps).x);\n}\n\nconst int steps = 25;\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n  for (int i = 0; i < steps; i++) {\n    if (latest < precis || dist > maxd) break;\n    vec2 result = model(rayOrigin + rayDir * dist);\n    latest = result.x;\n    type = result.y;\n    dist += latest;\n  }\n  if (dist < maxd) res = vec2(dist, type);\n  return res;\n}\n\nvec2 raytrace(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 50.0, 0.001);\n}\n\nvec2 square(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 camera(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n  return mat3(uu, vv, ww);\n}\n\nvec3 camera(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = lookAt(origin, target, 0.0);\n  return camera(camMat, screenPos, lensLength);\n}\n\nvec3 lighting (vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n  vec3 lin = vec3(0.0);\n  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n  float dif = max(dot(nor,lig),0.0);\n  lin += dif*vec3(2);\n  lin += vec3(0.05);\n  return mal*lin;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float cameraAngle = 0.2 * t;\n  vec3 rayOrigin = vec3(18.0 * sin(cameraAngle), 2.2, 18.0 * cos(cameraAngle));\n  vec3 rayTarget = vec3(0, 0, 0);\n  vec2 screenPos = square(iResolution.xy);\n  float lensLength = 2.0;\n  vec3 rayDirection = camera(rayOrigin, rayTarget, screenPos, lensLength);\n  rayDirection.x += sin(4.0*t + uv.x*4.0) / 20.0;\n  rayDirection.y += cos(8.0*t + uv.y*4.0) / 20.0;\n\n  vec2 collision = raytrace(rayOrigin, rayDirection);\n  if (collision.x > -0.5) {\n    vec3 pos = rayOrigin + rayDirection * collision.x;\n    if (length(pos) > 25.0 && length(pos-vec3(sunpos))<=5.0) { // sun\n      fragColor = vec4(1,1,1,1);\n    } else if (length(pos) <= 6.0) { // planet\n      vec3 nor = calcNormal(pos);\n      vec3 mat = (vec3(0.9,0.75,0.6+sin(pos.y*2.0+3.0)*0.05))*vec3(\n        sin(pos.y*2.0*sin(pos.y*2.5)+sin(pos.y*2.0)+snoise(pos*3.0)*0.4)*0.05+0.6\n      );\n      vec3 col = lighting(pos, nor, rayDirection, collision.x, mat);\n      col = pow(clamp(col,0.0,1.0), vec3(1.2));\n      fragColor = vec4(col, 1.0);\n    } else { // ring\n      float edge = length(pos)+snoise(pos*8.0)*0.03;\n      vec3 col = vec3(0.95,0.8,0.7)*vec3(\n        sin(1.5+sqrt(length(pos)*4.0)*2.0+sqrt(sin(length(pos)*8.1))\n          +snoise(pos*12.0)*0.3)*0.2+0.6)\n        * (abs(edge-8.6)<0.1?0.2:1.0)\n      ;\n      if (length(pos)>=10.0) col = vec3(0,0,0);\n      else if (abs(pos.y)>0.35) col = vec3(0,0,0);\n      else {\n        vec3 p = normalize(-sunpos)*7.5;\n        col *= min(1.0,(length(pos-p)-4.0)/4.0);\n      }\n      fragColor = vec4(col, 1.0);\n    }\n  } else {\n    fragColor = vec4(vec3(pow(snoise(rayDirection*128.0),4.0)),1);\n  }\n  fragColor.x *= sin(t*3.0+sin(t*4.0+uv.x*uv.x*2.0)+cos(t*4.0+uv.y*uv.y*8.0));\n  fragColor.y *= sin(t*2.0+sin(t*2.0+uv.x*uv.x*8.0)+cos(t*1.0+uv.y*uv.y*8.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddSWX", "name": "Warp Spiral", "author": "vox", "description": "Warp Spiral", "tags": ["warpspiral"], "likes": 0, "viewed": 457, "date": "1461871537", "time_retrieved": "2024-06-20T18:35:06.095743", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*iTime/PI)\n#define saw(x) (acos(cos(x))/PI)\n#define cosaw(x) (asin(sin(x+PI/2.0))/PI+.5)\n#define stair floor\n#define jag fract\n\nvec2 SinCos( const in float x )\n{\nreturn vec2(sin(x), cos(x));\n}\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\nvec2 tree(vec2 uv)\n{\n    float turns = mod(floor(time/2.0), 6.0)+3.0;\n    uv = rotatez(uv.xy, PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    \n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    \n    vec2 xy = rotatez(uv.xy, \n                      PI*2.0*(rot)+PI/turns).xy;\n    \n    xy = sign(xy)*log(abs(xy));\n    \n    return vec2(saw(theta*turns), cosaw(xy.x*PI*2.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy*2.0;\n    float scale = exp(-saw(time/PI)*2.0);\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    uv = normalize(uv)/log(r+1.0)/log(sqrt(2.0));\n    uv += sin(vec2(time, time/PI*E*GR))/scale*2.0*PI;\n    scale = exp(-saw(time/PI)*2.0);\n    uv = tree(uv)*scale-scale/2.0; \n    \n    r = length(uv);\n    uv = normalize(uv)/log(r+1.0)/log(sqrt(2.0));\n    uv = tree(uv); \n\n    fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddSz2", "name": "Petalburst", "author": "vrav", "description": "another very messy learning exercise", "tags": ["2d", "abstract"], "likes": 6, "viewed": 190, "date": "1460420095", "time_retrieved": "2024-06-20T18:35:06.095743", "image_code": "#define PI 3.14159265359\n\nfloat lerp(float a, float b, float t) {\n  return a + t*(b-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.yy;\n    vec3 color = vec3(0.0);\n\t\n    vec2 pos = vec2(.5)-st*1.3;\n    pos.x += (sin(iTime))*.15+.2;\n    pos.y += (cos(iTime))*.15+.1;\n\t\n    float r = sqrt(dot(pos,pos));\n    float a = atan(pos.y,pos.x);\n    \n    float at = iTime*.5;\n    at = floor(at) + clamp((sin(fract(at)*PI*.55)), 0., .999);\n    a += at;\n    \n    float ct = 2.5;\n    \n    // flower\n    float f = abs(cos(a*ct))*.4+.3;\n    \n    // sun\n    float g = smoothstep(0.+fract(at),1., cos(a*ct*4.))*0.2+0.5;\n    \n    // blend the shapes\n    f = lerp(f,g,sin(iTime));\n    \n    // eggyolk\n    float e = smoothstep(.2*(abs(sin(at))+.5),.38*(abs(sin(at))+.5),r);\n    e = clamp(smoothstep(f*.8,f+.4*abs(sin(iTime)),e),0.,1.);\n    \n    // outline of f\n    float o = smoothstep(f,f+0.03, r );\n    o -= clamp(smoothstep(f,f+0.08, r ), 0.,1.);\n    \n    color = vec3(1.,.9,.8)*( f+o )*.8\n          + vec3(1.,.8,.2)*clamp(1.-e*r*.8, 0., 1.)*.8\n          + clamp(1.-r*3.*(abs(sin(at*.5)*.5+1.)), 0.,1.)*.2;\n    \n    color = mix(vec3(.0,.4,.8), color, color);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddSzl", "name": "The whole is greater than the...", "author": "Andre", "description": "Was just playing around and found this. What do you see in this?", "tags": ["2d", "distancefield", "rorschach"], "likes": 19, "viewed": 576, "date": "1461003799", "time_retrieved": "2024-06-20T18:35:06.095743", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv1 = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    vec2 uv = uv1*4.0;\n    \n    float c = 1.;\n    uv.x = abs(uv.x);\n    uv.x -= 1.;\n    float gt = iTime*.05;\n    for (float i = 0.0; i< 100.0; i++) {\n      gt += i*.72;\n      c *= min(1.1,distance(uv,\n                            vec2(sin(gt*0.9)+cos(gt*(i/37.))\n                                ,sin(gt*0.7)+cos(gt*(i/23.)))));\n    }\n    \n\tfragColor = vec4(clamp(\n                       mix( vec3(.1,.1,.15),\n                            vec3(1.,1.,0.9),\n                            smoothstep(.1,0.12,c))\n                       *(0.5+texture(iChannel0,vec2(uv1.y*4.,uv.x)+uv1*vec2(7.0,.13)).g\n                       *.25*max(-.2,4.0-length(uv)))\n                       ,0.0,1.0)\n                     ,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSDf", "name": "domo light", "author": "Baizhengbiao123", "description": "cpy", "tags": [], "likes": 0, "viewed": 87, "date": "1461917624", "time_retrieved": "2024-06-20T18:35:07.811016", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ), vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n    res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSWB", "name": "Spirale (Figure in report)", "author": "imagicien", "description": "Render I have done for a report for project 'Le Lounge' at Universite de Sherbrooke.\n\nClick on the figure, then move the cursor left/right to see how the spiral effect is acheived.", "tags": ["spiral"], "likes": 5, "viewed": 179, "date": "1461342777", "time_retrieved": "2024-06-20T18:35:08.223222", "image_code": "// For a report regarding project \"Le Lounge\"\n// By Carl Lemaire, Universit de Sherbrooke\n\n#define TWO_PI 6.28318530718\n#define X0 0.5\n#define Y0 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    float x = -(uv.x - X0) * 2.0;\n    float y = -(uv.y - Y0) * 2.0;\n\n    float rho = sqrt(x*x + y*y);\n    float phi = atan(y, x);\n\n    float normPhi = phi / TWO_PI + 0.5;\n    float spiralFactor = clamp(1.25 - 1.5 * (iMouse.x / iResolution.x), 0.0, 1.0);\n    float rhoSpir = rho * (spiralFactor * normPhi + 1.0);\n    float nbTurns = abs(ceil(log2(rhoSpir)));\n    float progOnBranch = fract(log2(rhoSpir));\n    \n    vec3 couleur = vec3(0.5);\n    float damRayRes = 4.0;\n    float damAngRes = damRayRes * 8.0;\n    \n    if (rhoSpir < 1.0)\n    {\n        if (nbTurns < 1.0)\n        {\n            if (progOnBranch > 0.95)\n            {\n                fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n                return;\n            }\n            \n            couleur = vec3(1.0);\n        }\n        else if (nbTurns < 2.0)\n        {\n            if (progOnBranch > 0.95)\n            {\n                fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n                return;\n            }\n            \n            couleur = vec3(1.0);\n        }\n        else\n        {\n        \tif (rho < 0.01)\n                fragColor = vec4(0.0);\n            else\n                fragColor = vec4(0.7);\n    \t\treturn;\n        }\n    }\n    else\n    {\n        if (rho < 1.0 && rho > 0.99)\n        \tfragColor = vec4(0.0);\n        else if(rho < 0.99)\n        \tfragColor = vec4(0.7);\n        else\n        \tfragColor = vec4(1.0);\n    \treturn;\n    }\n\t\n    float timeOffset = fract(iTime) * 2.0;\n    \n    float damierRayon = mod(floor(progOnBranch * damRayRes), 2.0) * 2.0 - 1.0;\n    float damierAngle = mod(floor(normPhi * damAngRes - timeOffset), 2.0) * 2.0 - 1.0;\n    float damier = clamp(damierRayon * damierAngle, 0.0, 1.0);\n    \n\tfragColor = vec4(couleur * damier, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSWf", "name": "Perlin Noise!", "author": "allegrocm", "description": "Perlin Noise. Rand() code is based off something I found at  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl \n\n", "tags": ["noise"], "likes": 0, "viewed": 668, "date": "1461899005", "time_retrieved": "2024-06-20T18:35:08.223222", "image_code": "\nfloat noise(vec2 co)\n{\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec2 co, float scale)\n{\n    vec2 pos = co;\n    ivec2 ipos = ivec2(co / scale);\n    pos = vec2(ipos) * scale;\n    float r = noise(pos);\n    return r;\n}\n\nfloat cubicInterpolate(vec4 p, float x)\n{\n\treturn p.y + 0.5 * x*(p.z - p.x + x*(2.0*p.x - 5.0*p.y + 4.0*p.z - p.w + x*(3.0*(p.y - p.z) + p.w - p.x)));\n}   \n\n\nfloat bicubicNoise(vec2 co, float scale)\n{\n     //16!! points to interpolate across\n    mat4 m;\n    ivec2 ipos = ivec2(co/scale);\n    for(int x = 0; x < 4; x++)\n    {\n    \tfor(int y = 0; y < 4; y++)\n        {\n         \tm[x][y] = noise(vec2(ipos + ivec2(x, y)) * scale);   \n        }\n        \n    }\n    \n\t//find our t-values by subtracting pos from quantized pos\n    vec2 qpos = vec2(ipos) * scale;\n    vec2 t = (co-qpos) / scale;\n    float t1 = t.x;\n    t1 = t.y;\n    //do cubic interpolation four times, and then one more time\n    vec4 cubix = vec4(\n        cubicInterpolate(m[0], t1),\n        cubicInterpolate(m[1], t1),\n        cubicInterpolate(m[2], t1),\n        cubicInterpolate(m[3], t1));\n   \treturn cubicInterpolate(cubix, t.x);\n\t\n}\n\nfloat smoothedNoise(vec2 co, float scale)\n{\n    //four values to interpolate across\n    vec2 pos = co;\n    ivec2 ipos = ivec2(co / scale);\n    \n    //four points to interpolate across\n    float p00 = noise(vec2(ipos + ivec2(0, 0)) * scale);\n    float p10 = noise(vec2(ipos + ivec2(1, 0)) * scale);\n    float p01 = noise(vec2(ipos + ivec2(0, 1)) * scale);\n    float p11 = noise(vec2(ipos + ivec2(1, 1)) * scale);\n    \n    //find our t-values by subtracting pos from quantized pos\n    vec2 qpos = vec2(ipos) * scale;\n    vec2 t = (pos-qpos) / scale;\n    \n    //bilinear interpolation\n    float px0 = p00 * (1.0-t.x) + p10 * t.x;\n    float px1 = p01 * (1.0-t.x) + p11 * t.x;\n    return px0 * (1.0 - t.y) + px1 * t.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n  \n    float p = 0.0;\n\tfor(int i = 0; i < 6; i++)\n    {\n        float amplitude = pow(0.5, float(i)+1.0);\n      \tp +=  amplitude * bicubicNoise(fragCoord.xy + vec2((iTime*-1.0 + 9000.0) * 10.0, 0.0), 128.0 * amplitude);\n    }\n   \n  //  p = smoothedNoise(fragCoord.xy, 32.0);\n    fragColor.xyz = vec3(p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSzs", "name": "Mouse Tracker", "author": "akohdr", "description": "Quick and dirty mouse tracking tool.", "tags": ["mouse"], "likes": 4, "viewed": 154, "date": "1461026576", "time_retrieved": "2024-06-20T18:35:08.780892", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Quick and dirty mouse tracking tool because I needed one.\n\n// Cut/Paste this code into a seperate buffer and overlay on your shader.\n// You can then track absolute and texture coord position of mouse.\n\n#define BLK vec4(.0,.0,.0,1.)\n#define WHT vec4(1.,1.,1.,1.)\n\n// tweaked 7 seg decoder originally from dr2 @ https://www.shadertoy.com/view/MddXRl\n#define HSEG(a,b,c) (1.-smoothstep(a,b,abs(c)))\n#define SEG(q) HSEG(.13,.17,q.x)*HSEG(.5,.57,q.y)\n#define CHK b=a/2;if(b*2!=a)d+= \nfloat Seg7(vec2 q, int v)\n{\n  float d;\n  int a, b;\n  const vec2 vp = vec2 (.5,.5), \n             vm = vec2 (-.5,.5), \n             vo = vec2 (1,0);\n  if (v < 5) {\n    if (v == -1) a = 8;\n    else if (v == 0) a = 119;\n    else if (v == 1) a = 36;\n    else if (v == 2) a = 93;\n    else if (v == 3) a = 109;\n    else a = 46;\n  } else {\n    if (v == 5) a = 107;\n    else if (v == 6) a = 123;\n    else if (v == 7) a = 37;\n    else if (v == 8) a = 127;\n    else a = 111;\n  }\n  q = (q-.5) * vec2(1.7,2.3);\n  d = 0.; CHK SEG(vec2(q.yx - vo));\n  a = b;  CHK SEG(vec2(q.xy - vp));\n  a = b;  CHK SEG(vec2(q.xy - vm));\n  a = b;  CHK SEG(vec2(q.yx));\n  a = b;  CHK SEG(vec2(q.xy + vm));\n  a = b;  CHK SEG(vec2(q.xy + vp));\n  a = b;  CHK SEG(vec2(q.yx + vo));\n  return d;\n}\n\nint decDigit(lowp float v, int i) {\n    float f = float(i), \n          p1 = pow(10.,f-1.);\n    return int((mod(v,pow(10.,f))-mod(v,p1))/p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy,\n         left = vec2(-1,0),\n         home=24.*(fragCoord*vec2(-1,1))/iResolution.xy;\n    \n    fragColor = vec4(0);\n\n    // Likely easier to use black to blend so comment/remove this\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n#define DIGITS(l) for(int i=1;i<=l;i++){xy+=left;fragColor+=vec4(Seg7(xy,decDigit(v,i) ));}\n    \n    // Current frame\n    float v = float(iFrame); \n    vec2 xy = home + vec2(12.,-20);\n    DIGITS(8);\n\n    // Mouse position XY absolute\n    v = float(iMouse.x); \n    xy = home + vec2(7.,-18);\n    DIGITS(4);\n    \n    v = float(iMouse.y); \n    xy = home + vec2(12.,-18);\n    DIGITS(4);\n\n    // Mouse position XY texure coord (3 dec. places)\n    v = 1000.*iMouse.x/iResolution.x; \n    xy = home + vec2(7.,-16);\n    DIGITS(3);\n    \n    v = 1000.*iMouse.y/iResolution.y; \n    xy = home + vec2(12.,-16);\n    DIGITS(3);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXD2", "name": "Two lines atmospheric scattering", "author": "Bananaft", "description": "Attmpt to make fast and simple atmosphere shader.", "tags": ["sun", "sky", "atmosphericscattering", "atmosphere", "rayleigh", "mie"], "likes": 46, "viewed": 2240, "date": "1461681354", "time_retrieved": "2024-06-20T18:35:08.787002", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // animation\n    vec2 sunVec;\n    if (iMouse.x<20.0)\n    {\n     \t   sunVec = vec2((0.8+0.5 * sin(iTime)),( 0.44 + 0.4 * cos( 2.0 * iTime)));\n    }else{\n    \tsunVec = iMouse.xy/iResolution.y;\n    }\n     \t\n   \n    //Mie mask\n    float sun = max(1.0 - (1.0 + 10.0 * sunVec.y + 1.0 * uv.y) * length(uv - sunVec),0.0)\n        + 0.3 * pow(1.0-uv.y,12.0) * (1.6-sunVec.y);\n\t\n    //the sauce\n    fragColor = vec4(mix(vec3(0.3984,0.5117,0.7305), vec3(0.7031,0.4687,0.1055), sun)\n              * ((0.5 + 1.0 * pow(sunVec.y,0.4)) * (1.5-uv.y) + pow(sun, 5.2)\n              * sunVec.y * (5.0 + 15.0 * sunVec.y)),1.0);\n    \n    //fragColor = vec4(sun);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXDX", "name": "Sine Worm", "author": "hobscure", "description": "Worm", "tags": ["worm"], "likes": 1, "viewed": 85, "date": "1461884115", "time_retrieved": "2024-06-20T18:35:08.944512", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.05, pct, st.y) - \n          smoothstep( pct, pct+0.05, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec3 color = vec3(st.y * sin(iTime));\n    \n    float v = (cos((st.x * 10.0) + iTime * 1.0) + cos((st.x * 10.0)*2.0/3.0*3.1415 + iTime * 1.0) )/5.0 + 0.5;\n    float v2 = v +  sin((st.x * 20.0)*50.0*3.1415 + iTime * 1.0) / 10.0  ;\n    float v3 = (cos((st.x*sin(st.y) * 10.0) + iTime * 1.0) + cos((st.x * 10.0)*2.0/3.0*3.1415 + iTime * 1.0) )/5.0 + 0.5;\n    \n    float pct = plot(st ,v2);\n   \n    \n    color = (pct)*color+pct*vec3(1.0,0.0,0.0);\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXW4", "name": "basic raytracer learning", "author": "ProgC", "description": "implement basic raytracer with iq's tutorial on youtube.", "tags": ["raytracer"], "likes": 6, "viewed": 738, "date": "1459535839", "time_retrieved": "2024-06-20T18:35:08.950637", "image_code": "\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    // sphere expression\n    //|xyz|^2 - r^2 = 0\n    // xyz = ro + t * rd;\n    // let's find out the t with quadratic equation.\n    // rd's length is 1 so skip it.\n    \n    vec3 oc = ro - sph.xyz;\n    float a = 1.0;\n    float b = 2.0 * dot( oc, rd );\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b * b - 4.0 * a * c;\n    if ( h < 0.0 ) return -1.0;\n    float t = (-b - sqrt(h)) / 2.0;\n    return t;    \n}\n\nvec3 nSphere( in vec3 pos, in vec4 sph )\n{\n    return (pos-sph.xyz ) / sph.w;\n}\n\nvec3 nPlane( in vec3 pos)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    // plane equation for y = 0\n    // ro.y + r * rd.y = 0 and solve for t\n    return -ro.y / rd.y;\n}\n\nvec4 sph = vec4(0.0, 1.0, 0.0, 1.0);\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT )\n{\n    resT = 1000.0;\n    float id = -1.0;\n    float tSphere = iSphere( ro, rd, sph );\n    float tPlane = iPlane( ro, rd );\n    \n    if ( tSphere > 0.0 ) \n    {\n        id = 1.0;\n        resT = tSphere;\n    }\n    if ( tPlane > 0.0 && tPlane < resT ) \n    {\n        id = 2.0;\n        resT = tPlane;\n    }\n    return id;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize( vec3( 0.5 ) );\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    sph.x = 0.5 * cos(iTime);\n    sph.z = 0.5 * sin(iTime);\n    \n    // generate a ray with origin ro and direction rd\n    vec3 ro = vec3(0.0, 1, 3.0);\n    vec3 rd = normalize( vec3(  -1.0 + 2.0 * uv, -1.0 ) );\n    \n    // intersect the ray with the 3d scene.\n    float t;\n    float id = intersect( ro, rd, t );\n        \n    // draw black by default.\n    vec3 col = vec3(0.0);\n    \n    if ( id > 0.0 && id <= 1.0 )\n    {\n        // hit something\n        vec3 pos = ro + t * rd;\n        vec3 nor = nSphere( pos, sph );\n        float dif = clamp(dot(nor, light ), 0.0, 1.0);\n        float amb = 0.2 + 0.1 * nor.y;\n        col = vec3( 0.2, 0.8, 0.2 ) * dif + amb + vec3(0.5, 0.6, 0.7) * amb;\n    }\n    else if ( id >= 1.4 )\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = nPlane( pos );\n        float dif = clamp( dot (nor, light), 0.0, 1.0 );\n        float amb = smoothstep( 0.0, sph.w, length(pos.xz-sph.xz) );\n        col = vec3(amb * 0.7);\n    }\n    col = sqrt(col);\n    \n    \n    fragColor = vec4(col, 1.0);           \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXzB", "name": "Rotozoom Demo", "author": "TrueBoolean", "description": "Using a rotation matrix to rotate screen coordinates.", "tags": ["rotation", "rotozoom"], "likes": 1, "viewed": 203, "date": "1460125940", "time_retrieved": "2024-06-20T18:35:09.096078", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CAMERA CONTROL\n    float camRot=iTime/2.0;\n    mat2 rotationMatrix = mat2(cos(camRot), -sin(camRot), sin(camRot), cos(camRot));\n    float zoom=sin(iTime)*3.+10.5;\n    float CENTER_SCREEN=0.5;\n    //SCREEN SCALING\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=CENTER_SCREEN;\n    //ROTOZOOM \n    uv*=rotationMatrix;\n    uv*=zoom;\n    //If you want a texture use below:\n\t//fragColor = vec4(texture(iChannel0, uv));\n    //Produce procedural random tiling, as suggested by FabriceNeyret2\n    fragColor = vec4(fract(1e4*sin(dot(floor(8.*uv),vec2(983,-5)))));\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXzf", "name": "LUX meets JPN", "author": "tomaes", "description": "...started as flags of Japan and Luxembourg, hence the title.", "tags": ["2d", "distortion", "minimal", "flags"], "likes": 10, "viewed": 176, "date": "1460724650", "time_retrieved": "2024-06-20T18:35:09.096078", "image_code": "// flag of Japan\nvec3 jpn(vec2 _uv)\n{   \n    float off = atan(_uv.x,_uv.y)*0.1 > 0.1 ? 1.0: 2.0-_uv.y;\n    vec3 col = vec3(2.2-off,1.1-off,0.8-off);\n\t\n    if ( distance( vec2(_uv.x,0.15+_uv.y*0.7),vec2(0.5,0.5)) < 0.15 )\n    \tcol = vec3(1.0,0.2,0.2+_uv.x*0.4 );\n    \n    return col;\n}\n\n// flag of Luxembourg\nvec3 lux(vec2 _uv)\n{\n    if (mod(_uv.y, 1.0) < 0.3333)\n    {\n        return vec3(0.0,0.6,1.0); //blue\n    } \n    else\n\tif (mod(_uv.y, 1.0) < 0.6666)\n    {\n        return vec3(1.0,1.0-_uv.x*0.1,1.0); //white\n    }\n    else\n    {\n        return vec3(1.0,0.0,_uv.x*0.3); //red\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = 3000.0+iTime;\n    \n    uv.y += sin(t+uv.x*sin(uv.x*6.0+t)*uv.y*sin(t)*10.0)*0.5;   \n    uv.y += sin(t*0.1+uv.x*5.0)*0.2;\n    \n    if ( ((uv.y/uv.x)*0.3+(uv.y+uv.x)*0.7) > (sin(t)) ) \n    {    \n    \tfragColor = vec4(jpn(uv),1.0) - vec4(lux(uv),1.0)*mod(t+uv.y,1.0)*0.8; \n    }\n    else\n    \tfragColor = vec4(lux(uv),1.0) - vec4(jpn(uv),1.0)*0.15;\n    \n    // band\n    if ( (uv.y*uv.x+0.05) > (sin(t)) && (uv.y*uv.x) < (sin(t)) \n       && (mod(uv.x+t*0.4,0.1) < 0.08)\n       ) \n    \tfragColor =  vec4(1.0,1.0,1.0,1.0);//vec4(0.5,0.9,uv.x*0.5,1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3SRj", "name": "Equalizer Yolo", "author": "Vicious", "description": "yolo", "tags": ["yolo"], "likes": 5, "viewed": 474, "date": "1460206456", "time_retrieved": "2024-06-20T18:35:09.096078", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    float sound = texture (iChannel0, vec2(screen.x, 0.75)).x;\n    \n    vec3 color = vec3(.0);\n    \n    color += vec3(abs(sin(iTime)) - smoothstep(0.0, 0.2, abs(sound - screen.y)),\n                  abs(sin(iTime * 2.0/3.0 * 3.1415)) - smoothstep(0.0, abs(sin(iTime) * 0.1), abs(sound - screen.y)),\n                  abs(sin(iTime * 4.0/3.0 * 3.1415)) - smoothstep(0.0, abs(sin(iTime) * 0.1), abs(sound - screen.y)));\n                  \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3SRS", "name": "Fractal Experiment 19", "author": "aiekick", "description": "Fractal Experiment 19", "tags": ["fractal", "experiment", "19"], "likes": 31, "viewed": 1063, "date": "1459889751", "time_retrieved": "2024-06-20T18:35:09.920254", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on https://www.shadertoy.com/view/4stXR7\n*/\n\nconst vec3 ld = vec3(0.,1., .5);\nfloat dstepf = 1.0;\nfloat t = 0.;\n\nvec2 path(float z){return sin(z*.2 + vec2(1.6,0));}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat fractus(vec3 p)\n{\n\t\n\tvec2 z = p.xy;\n    vec2 c = vec2(0.28,-0.56) * cos(p.z*0.1);\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<8.;i++)\n    {\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nfloat df(vec3 p)\n{\n\tp *= getRotZMat(cos(p.z*0.2)*2.);\n\tp.xy = mod(p.xy, 3.5) - 3.5*0.5;\n\tp *= getRotZMat(cos(p.z*0.6)*2.);\n\treturn fractus(p);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy) - df(p-e.xyy),\n\t\tdf(p+e.yxy) - df(p-e.yxy),\n\t\tdf(p+e.yyx) - df(p-e.yyx) );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = df( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float d = max(length(l), 0.01);\n    float atten = 1.0-exp( -0.01*d*d );\n    if (iMouse.z> 0.) atten = exp( -0.001*d*d )-0.5;\n    l /= d;\n    \n    vec3 n = nor(p, prec);\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    dif *= softshadow(p, rd, 0.1, 1.);\n    \n    vec3 lin = vec3(0.08,0.32,0.47);\n    lin += 1.0*dif*vec3(1,1,0.84);\n    lin += 2.5*spe*dif*vec3(1,1,0.84);\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin * atten * calcAO(p, n);\n}\n\n\nfloat trace( in vec3 ro, in vec3 rd)\n{\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = ro;\n\t\n\tfor (float i=0.; i<150.; i++)\n\t{\n\t\tif (s < 0.0025*log(d) || d>40.) break;\n\t\ts = df(p);\n\t\td += s * (s>0.1?0.15:0.01);\n\t\tp = ro + rd * d;\t\n\t\tdstepf += 0.005;\n\t}\n\t\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*fragCoord-si)/min(si.x, si.y);\n\n\tt = iTime * 2.;\n\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(0,0,t);\n    vec3 co = ro + vec3(0, 0,.1);\n\t\n\tfloat fov = 0.8;\n\tvec3 axisZ = normalize(co - ro);\n\tvec3 axisX = normalize(cross(cu, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rd = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat d = trace(ro, rd);\n\tvec3 p = ro + rd * d;\t\n\t\n\tfragColor.rgb = vec3(0.47,0.6,0.76) * lighting(p, ro, rd, 0.1); \n\tfragColor.rgb = mix( fragColor.rgb, vec3(0.5,0.49,0.72), 1.0-exp( -0.01*d*d ) ); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3SW2", "name": "Bokehlicious", "author": "finalman", "description": "Click and drag to adjust focal depth and aperture", "tags": ["blur", "bokeh", "camera", "particles", "focus"], "likes": 17, "viewed": 1224, "date": "1461494760", "time_retrieved": "2024-06-20T18:35:09.926498", "image_code": "const int NUM_PARTICLES = 128;\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\n\nfloat bokeh(vec2 p, vec2 a, float r)\n{\n    float l = length(p - a);\n    \n    if (l > r + 0.1)\n    {\n        return 0.0;\n    }\n    \n    float s = 0.01;\n    float d = l * exp(sin(9.0 * atan(p.y - a.y, p.x - a.x)) * 0.02);\n    float g = mix(0.9, 0.6, texture(iChannel0, 4.0 * p - a * 1.9).x);\n    float t = smoothstep(r + s, r - s, d);\n    \n    return 0.001 * mix(0.0, mix(g, t, clamp(l / r, 0.0, 1.0)), t) / (r * r);\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    float aperture = 0.5;\n    float focus = 3.5;\n    \n    if (iMouse.z > 0.0)\n    {\n        aperture = iMouse.x / iResolution.x;\n        focus = 7.0 * iMouse.y / iResolution.y;\n    }\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 c = vec3(0);\n    \n    for (int i = 0; i < NUM_PARTICLES; i++)\n    {\n        vec3 color;\n        vec3 pos;\n        float radius;\n\n        float t = float(i) / float(NUM_PARTICLES);\n        float p = t + iTime * 0.03;\n        color = normalize(vec3(sin(t * TAU * 1.0) + 5.1, cos(t * TAU * 2.0) + 1.1, cos(t * TAU * 3.0) + 1.1));\n        pos = vec3(2.0 * sin(t * TAU * 5.0 + p * 0.7),\n                                abs(sin(p * 3.0 * TAU)) - 0.5,\n                                4.0 * cos(t * TAU + p * 0.8));\n        float d = pos.z + 2.5;\n        \n        if (d > 0.0)\n        {\n            pos.xy /= d;\n            radius = max(abs(1.0 / d - 1.0 / focus) * aperture, 0.0001);\n            c += color * bokeh(uv, pos.xy, radius);\n        }\n    }\n    \n\tc = pow(c, vec3(1.0 / 2.2));\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3Sz2", "name": "Space Tiling2", "author": "akohdr", "description": "Using Iq's viewer to tile Isohedral Tetrahedron added sdIsoTet() and orientation macros\nMouse controls camera, added some interlacing flags YMMV", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives"], "likes": 16, "viewed": 953, "date": "1460248744", "time_retrieved": "2024-06-20T18:35:11.926552", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// based on Iq's primitives viewer https://www.shadertoy.com/view/Xds3zN\n\n// Interlacing YMMV potentially useful for debugging/speed/cooling/projection\n//#define INTERLACE_AGGRESSIVE\n//#define INTERLACE_X\n//#define INTERLACE_Y\n// try this with all interlacing flags uncommented, then switch them off/on individually\n//#define SPOOKY\n\n// Isohedral Tetrahedron distance function\nfloat sdIsoTet(vec3 p, float h) \n{\n    vec3 q = abs(p);\n    \n    float y = p.y,\n          d1 = q.z-max(0.,y),\n          d2 = max(q.x*.5 + y*.5,.0) - min(h, h+y);\n    return length(max(vec2(d1,d2),.005)) + min(max(d1,d2), 0.);\n}\n\nfloat sdOctahedron(vec3 p, float h) \n{\n    vec2 d = .5*(abs(p.xz)+p.y) - min(h,p.y);\n    return length(max(d,0.)) + min(max(d.x,d.y), 0.);\n}\n\nfloat sdTruncOct(vec3 p, float h, float k) \n{\n    vec2 d = max(.5*(abs(p.xz)-p.y),.0) - min(h-k, h-p.y);\n    return length(max(d,0.)) + min(max(d.x,d.y), 0.);\n}\n\nfloat sdSpheresCursor(vec3 p, float h, float r) {\n\treturn length(max(abs(p)-h, -1.))-r;\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//=======================================================================================\n// TODO: Is there a colorspace gen func out there?\n#define RED 290.67\n#define GRN 110.67\n#define BLU 209.67\n#define YEL 170.67\n#define CYN 333.67\n#define PRP 143.67\n\n#define ISOTET_RED(p,s,u) sdIsoTet((p-vec3(.0,-u,.0)).zyx,s)\n#define ISOTET_BLU(p,s,u) sdIsoTet((p-vec3(.0,.0,.0)).xyz,s)\n#define ISOTET_GRN(p,s,u) sdIsoTet((p-vec3(.0,.0,.0)).xzy,s)\n#define ISOTET_YEL(p,s,u) sdIsoTet((p-vec3(.0,.0,-u)).yzx,s)\n#define ISOTET_CYN(p,s,u) sdIsoTet((p-vec3(.0, u,.0)).zxy,s)\n#define ISOTET_PRP(p,s,u) sdIsoTet((p-vec3(-u,-u,.0)).yxz,s)\n\n//=======================================================================================\nvec2 map( in vec3 pos )\n{\n    // We keep a collection of more interesting primitives to show shadows\n    \n    // central sphere on plane\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    \n    // tiled Isohedral Tetrahedron\n    float sT = sin(iTime), cT = cos(iTime),\n          o = cT*1.5*(1.+cos(2.1+sT)), h=.9,\n          s = .15, u = s+s;\n    res = opU( res, vec2(ISOTET_BLU(pos-vec3(-o, h, o),s,u), BLU ) );\n    res = opU( res, vec2(ISOTET_YEL(pos-vec3( 0, h, o),s,u), YEL ) );\n    res = opU( res, vec2(ISOTET_CYN(pos-vec3( o, h, o),s,u), CYN ) );\n    res = opU( res, vec2(ISOTET_RED(pos-vec3(-o, h,-o),s,u), RED ) );\n    res = opU( res, vec2(ISOTET_GRN(pos-vec3( 0, h,-o),s,u), GRN ) );\n    res = opU( res, vec2(ISOTET_PRP(pos-vec3( o, h,-o),s,u), PRP ) );\n\n    // cluster spheres\n    res = opU( res, vec2(sdSpheresCursor(pos-vec3(-2, .3, 1),.2,.08), BLU ) );\n\n    // truncated octahedron\n    res = opU( res, vec2(sdTruncOct(pos-vec3(-2., .3, 0.),.2,.1), RED ) );\n\n    // regular octahedron\n    res = opU( res, vec2(sdOctahedron(pos-vec3(-3., .1, 0.),.25), GRN ) );\n        \n    // box minus sphere\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-1., .3, 0.), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-1., .3, 0.), 0.25)), 13.0 ) );\n\n    // tri prism minus box\n    res = opU( res, vec2( opS(\n\t\t\t\t\t sdTriPrism(  pos-vec3(2., .3, 0.), vec2(0.45,0.05)), \n\t\t             udRoundBox(  pos-vec3(2., .3, 0.), vec3(0.15),0.05)\n             )));\n    \n  \t// twisted torus\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(1., 0.35, 0.)),vec2(.2, .05)), 46.7 ) );\n\n    return res;\n}\n//=======================================================================================\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += .5*res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// TODO: use bit-ops in GLSL 3.0 instead of mod\n#ifdef SPOOKY\n#define INTERLACE(c,p,f,a,b,C) if(mod(p.f-mod(float(iFrame),a),a)<b){c=C;discard;}\n#else\n#define INTERLACE(c,p,f,a,b,C) if(mod(p.f-mod(float(iFrame),a),a)<b){c=C;return;}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#ifdef INTERLACE_Y\n#ifdef INTERLACE_AGGRESSIVE\n    INTERLACE(fragColor,fragCoord,y,4.,3.,vec4(.3))\n#else\n    INTERLACE(fragColor,fragCoord,y,2.,1.,vec4(.3))\n#endif\n#endif\n\n#ifdef INTERLACE_X\n#ifdef INTERLACE_AGGRESSIVE\n    INTERLACE(fragColor,fragCoord,x,6.,5.,vec4(.3))\n#else\n    INTERLACE(fragColor,fragCoord,x,2.,1.,vec4(.3))\n#endif\n#endif\n        \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy+vec2(0,1);\n\t\t \n\tfloat time = 28.0 + iTime*7.;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + .8*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3Sz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3SzB", "name": "rosace 3c", "author": "FabriceNeyret2", "description": "variant of https://www.shadertoy.com/view/ls3XWM\n\n(scroll with mouse)", "tags": ["pseudo3d", "short", "rosace"], "likes": 152, "viewed": 2800, "date": "1459963197", "time_retrieved": "2024-06-20T18:35:12.199346", "image_code": "// inspired from Shane's ribbon variant of https://www.shadertoy.com/view/ls3XWM \n\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float h = iResolution.y;  U = 4.*(U+iMouse.xy)/h;                    // normalized coordinates\n    vec2 K = ceil(U); U = 2.*fract(U)-1.;  // or K = 1.+2.*floor(U) to avoid non-fractionals\n    float a = atan(U.y,U.x), r=length(U), v=0., A;                       // polar coordinates\n    \n    for(int i=0; i<7; i++)\n        // if fractional, there is K.y turns to close the loop via K.x wings.\n        v = max(v,   ( 1. + .8* cos(A= K.x/K.y*a + iTime) ) / 1.8  // 1+cos(A) = depth-shading\n                   * smoothstep(1., 1.-120./h, 8.*abs(r-.2*sin(A)-.5))), // ribbon (antialiased)\n        a += 6.28;                                                       // next turn\n\n \n    O = v*vec4(.8,1,.3,1); O.g = sqrt(O.g);                              // greenify\n  //O = v*(.5+.5*sin(K.x+17.*K.y+iDate.w+vec4(0,2.1,-2.1,0)));           // random colors\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**  // 318\n#define d  O = max(O,O-O+(1.+.8*cos(A= K.x/K.y*a + iTime))/1.8 * smoothstep(1., 1.-120./R, 8.*abs(r-.2*sin(A)-.5))); a += 6.28;\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float R = iResolution.y;\n    U = 4.*(U+iMouse.xy)/R;\n    vec2 K = ceil(U); U = 2.*fract(U)-1.;  // or K = 1.+2.*floor(U) to avoid non-fractionals\n    float a = atan(U.y,U.x), r=length(U), A;\n    \n\tO -= O;  \n    d d d d d d d\n        \n    O *= vec4(.8,1,.3,1); O.g = sqrt(O.g);  \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscSWl", "name": "Blurry Conetracer", "author": "olawlor", "description": "Shows how you can build soft shadows and camera blur using a conetracer (raytracer with thickened rays) approach.\n\nJust a simple demo of the technique, not a production version. ", "tags": ["raytracer", "antialiasing", "conetracer"], "likes": 21, "viewed": 1122, "date": "1462051742", "time_retrieved": "2024-06-20T18:35:14.108484", "image_code": "/*\nA toy GLSL demonstration of \"conetracing\", a raytracing variant\nthat uses thicker cones instead of thin rays, which gives us cheap:\n  - Single-sample soft shadows\n  - Antialiased object edges\n  - Camera blurring\n  - Blurry reflections\n\nThe scene is hardcoded here, and generally just a toy demo implementation.\n\nSee the original SIGGRAPH 1984 paper \"Ray Tracing with Cones\" by John Amanatides,\nor Cyril Crassin's Pacific Graphics 2011 \"Interactive Indirect Illumination Using Voxel Cone Tracing\".\n\nThis version by Dr. Orion Lawlor, lawlor@alaska.edu\nCodebase stretches back to the 1990's, this version 2016-04-30 \nCode released as Public Domain (though attribution is welcome!)\n*/\n/********************* Conetracer utilities ***************/\n\n/**\ncircleSliceArea:\nReturn the area of:\n\t the portion of a circle, centered at the origin with radius 1, \n\t which has x-coordinate greater than frac.\n\t -1<=frac<=1\n\ni.e. return the area in #'s:\n\n<pre>\n    y\n \n    ^\n    |<---- 1 ---->|\n_--------___\n    |       -_         \n    |        |\\_        \n    |        |##\\         \n    |        |###\\       \n    |        |####|       \n    |        |####|    \n----+--------+####+-----> x \n    |        |####| \n    |        |####|       \n    |        |###/       \n    |        |##/        \n    |        |/        \n_   |   ___--         \n -------\n -->|  frac  |<--\n</pre>\n\nThis value is also equal to the integral\n      / 1\n      |\n      | 2*sqrt(1-x^2) dx\n      |\n      / frac\n(multiply by r^2 to get the area for a non-unit circle)\n*/\nfloat circleSliceArea(float frac)\n{\n\tfloat half_pi=3.14159265358979/2.0;\n\treturn (\n\t\thalf_pi-\n\t\tfrac*sqrt((1.0-frac)*(1.0+frac))-\n\t\tasin(frac)\n\t\t);\n}\n\nstruct circleOverlap_t {\n\tfloat f1; // fraction of circle 1 overlapped by circle 2\n\tfloat f2; // fraction of circle 2 overlapped by circle 1\n};\n\n/*circleOverlap:\nGiven two circles with radii 1.0 and r2, \nwith centers separated by a distance d, return \nthe fraction f1 of circle 1 overlapped by circle 2, and \nthe fraction f2 of circle 2 overlapped by circle 1.\n*/\n//(Version with r1 not fixed to 1.0)\ncircleOverlap_t circleOverlap(float r1,float r2,float d)\n{\n\tcircleOverlap_t r;\n\tif (r1+r2<=d) //Circles do not overlap at all\n\t\t{r.f1=0.0; r.f2=0.0;}\n\telse if (d+r2<=r1) //Circle 2 entirely in circle 1\n\t\t{r.f1=r2*r2/(r1*r1); r.f2=1.0;}\n\telse if (d+r1<=r2) //Circle 1 entirely in circle 2\n\t\t{r.f1=1.0; r.f2=r1*r1/(r2*r2);}\n\telse {\n\t//Circles partially overlap, creating a crescent shape\n\t//Compute the area of the circles\n\t\tfloat pi=3.14159265358979;\n\t\tfloat area1=r1*r1*pi;\n\t\tfloat area2=r2*r2*pi;\n\t//Compute area of overlap region\n\t\tfloat alpha=(r1*r1+d*d-r2*r2)/(2.0*d);\n\t\tfloat beta=d-alpha;\n\t\tfloat area_overlap=r1*r1*circleSliceArea(alpha/r1)+\n\t\t                  r2*r2*circleSliceArea(beta/r2);\n\t\tr.f1=area_overlap/area1;\n\t\tr.f2=area_overlap/area2;\n\t}\n\treturn r;\n}\n\n\n/***************************** shared vertex/fragment code *********************/\nvec3 camera; // location of camera center\nvec3 L=normalize(vec3(0.8,-0.5,0.7)); // points toward light source\nfloat time; // time, in seconds\n\n\n/* Raytracer framework */\nconst float invalid_t=1.0e3; // far away\nconst float close_t=1.0e-3; // too close (behind head, self-intersection, etc)\n\n/* This struct describes a ray */\nstruct ray_t {\n\tvec3 C; // start point of ray (typically the camera, hence the name C)\n\tvec3 D; // direction of ray \n\t\n\tfloat r_start; // radius of cone at start of ray\n\tfloat r_per; // change in radius as a function of (unit) ray parameter T\n};\n\n/* Return the location along this ray at this t value. */\nvec3 ray_at(ray_t ray,float t) {\n\treturn ray.C+t*ray.D;\n}\n\n/* Return the radius of this ray at this t value. \n   The \"abs\" allows camera rays to narrow down, then expand again.\n*/\nfloat ray_radius(ray_t ray,float t) {\n\treturn ray.r_start + abs(t*ray.r_per);\n}\n\n\n\n/* This struct describes how a surface looks */\nstruct surface_hit_t {\n\tfloat shiny; /* 0: totally matte surface; 1: big phong highlight */\n\tvec3 reflectance; /* diffuse color */\n\tfloat mirror; /* proportion of perfect mirror specular reflection (0.0 for non-mirror) */\n\tfloat solid; /* if <1.0, object is emissive only */\n};\n\n\n/* This struct describes everything we know about a ray-object hit. */\nstruct ray_hit_t {\n\tvec3 P; /* world coords location of hit */\n\tvec3 N; /* surface normal of the hit */\n\tfloat t; /* ray t value at hit (or invalid_t if a miss) */\n\tfloat exit_t; /* where to continue world walk on a miss */\n\tfloat frac; /* fraction of ray that is covered by this object (0.0: none; 1.0: all)*/\n\tfloat shadowfrac; /* fraction of ray that is covered by all objects (0.0: none; 1.0: all)*/\n\tsurface_hit_t s;\n};\n\nvec3 calc_world_color(vec3 C,vec3 D);\n\n/* Return the t value where this ray hits \n    the sphere with this center and radius. */\nvoid sphere_hit(inout ray_hit_t rh,ray_t ray,   // ray parameters\n\t\tvec3 center,float r, // object parameters\n\t\tsurface_hit_t surface)  // shading parameters\n{\n\t// solve for ray-object intersection via quadratic equation:\n\t//   0 = a*t^2 + b*t + c\n\tfloat a=dot(ray.D,ray.D);\n\tfloat b=2.0*dot(ray.C-center,ray.D);\n\tfloat closest_t=-b/(2.0*a); // ray T value at closest approach point\n\tfloat ray_rad=ray_radius(ray,closest_t); // radius at closest approach\n\tfloat center_to_center=length(ray_at(ray,closest_t)-center); // distance between centers\n\tcircleOverlap_t overlap=circleOverlap(r,ray_rad,center_to_center);\n\tfloat rayFrac=min(overlap.f2,1.0);\n\tif (rayFrac==0.0) return; // ray misses completely\n\t\n\tfloat first_t, last_t;\n\tfirst_t=last_t=closest_t; // ray-object intersection point\n\tfloat c=dot(ray.C-center,ray.C-center)-r*r;\n\tfloat det=b*b-4.0*a*c;\n\tif (det>=0.0) { /* a real hit (not just a glancing edge hit) */\n\t\tfloat entr_t=(-b-sqrt(det))/(2.0*a); /* - intersection == entry point */\n\t\tfloat exit_t=(-b+sqrt(det))/(2.0*a); /* + intersection == exit point */\n\t\tif (entr_t>close_t) first_t=entr_t;\n\t\tif (exit_t>close_t) last_t=exit_t;\n\t}\n\t\n\tif (first_t<close_t) return; /* behind head */\n\t\n\t// Add shadow contribution regardless of sort order:\n\t//rh.shadowfrac=max(rh.shadowfrac,rayFrac);  // max shadows (weird voronoi look on boundaries)\n\trh.shadowfrac=min(1.0,rh.shadowfrac+rayFrac);  // sum shadows (still looks a little weird)\n\t\n\tif (first_t>rh.t) return; /* beyond another object */\n\t\n\tvec3 P=ray_at(ray,first_t); // ray-object hit point (world coordinates)\n\t\n\t/* If we got here, we're the closest hit so far. */\n\trh.s=surface;\n\trh.t=first_t; // hit location\n\trh.exit_t=last_t; /* continue walk from exit point */\n\trh.P=P;\n\trh.N=normalize(P-center); // sphere normal is easy!\n\trh.frac=rayFrac; \n\t\n}\n\n/* Return a ray_hit for this world ray.  Tests against all objects (in principle). */\nray_hit_t world_hit(ray_t ray,float is_shadowray)\n{\n\tray_hit_t rh; rh.t=invalid_t; rh.frac=rh.shadowfrac=0.0;\n\t\n// Intersect new ray with all the world's geometry:\n    if (is_shadowray<0.5) {\n        // The Sun\n        sphere_hit(rh,ray, L*100.0,10.0,\n             surface_hit_t(0.0,vec3(10.0),0.0,0.0));\n    }\n    \n\t// Black camera sphere\n\tsphere_hit(rh,ray, camera,0.2,\n\t\t surface_hit_t(1.0,vec3(0.0,0.0,0.0),0.0,1.0));\n\t\n\t// Big brown outer sphere\n\tsphere_hit(rh,ray, vec3(0.0,0.0,-115.0),105.0,\n\t\t surface_hit_t(1.0,vec3(0.4,0.3,0.2),0.0,1.0));\n\t\n\t// Big green outer sphere\n\tsphere_hit(rh,ray, vec3(0.0,0.0,-11.5),10.7,\n\t\t surface_hit_t(1.0,vec3(0.2,0.6,0.4),0.3,1.0));\n\n\t// Wavy lines of floating red spheres\n\tfor (float i=-2.0;i<=2.0;i+=1.0) \n\tfor (float j=-2.0;j<=2.0;j+=1.0) \n\t{\n\t\tvec2 loc=vec2(i*2.0,j*2.0);\n\t\t// float r=length(loc)/10.0; // around green sphere\n\t\tfloat z=0.0;\n\t\tsphere_hit(rh,ray, vec3(loc,abs(3.0*sin(i*j+time))-z),0.3+1.0*fract(0.3*i*j),\n\t\t\t surface_hit_t(1.0,vec3(0.8,0.4,0.4),0.2,1.0));\n\t}\n\t\n\treturn rh;\n}\n\n/* Compute the world's color looking along this ray */\nvec3 calc_world_color(ray_t ray) {\n\tvec3 skycolor=vec3(0.4,0.6,1.0);\n\tvec3 color=vec3(0.0);\n\tfloat frac=1.0; /* fraction of object light that makes it to the camera */\n\t\n\tfor (int bounce=0;bounce<8;bounce++) \n\t{\n\t\tray.D=normalize(ray.D);\n\t/* Intersect camera ray with world geometry */\n\t\tray_hit_t rh=world_hit(ray,0.0);\n\n\t\tif (rh.t>=invalid_t) {\n\t\t\tcolor+=frac*skycolor; // sky color\n\t\t\tbreak; // return color; //<- crashes my ATI\n\t\t}\n\n\t/* Else do lighting */\n\t\tif (rh.s.solid>0.5) { // solid surface \n\t\t\tif (dot(rh.N,ray.D)>0.01) rh.N=-rh.N; // flip normal to face right way\n            \n            /*\n            // Phong (crude hack, 'sun' sphere works better)\n\t\t\tvec3 H=normalize(L+normalize(-ray.D));\n            float specular=rh.s.shiny*pow(clamp(dot(H,rh.N),0.0,1.0),500.0);\n            */\n\t\t\tfloat diffuse=clamp(dot(rh.N,L),0.0,1.0);\n\n\t\t\t// check shadow ray \n\t\t\tray_t shadow_ray=ray_t(rh.P,L, ray_radius(ray,rh.t),0.01);\n\t\t\tray_hit_t shadow=world_hit(shadow_ray,1.0);\n\t\t\tif (shadow.t<invalid_t) {\n\t\t\t\tfloat illum=1.0-shadow.shadowfrac;\n\t\t\t\tdiffuse*=illum; \n\t\t\t\t//specular*=illum; \n\t\t\t}\n\n\t\t\tfloat ambient=0.05;\n\n\t\t\tvec3 curObject=(ambient+diffuse)*rh.s.reflectance; // +specular*vec3(1.0);\n\t\t\t\n\t\t\tcolor+=frac*rh.frac*curObject;\n\t\t\t//color=rh.N; // debug: show surface normal at hit\n        } else { // emissive object\n            color+=frac*rh.frac*rh.s.reflectance;\n        }\n\t\t\n\t/* Check for ray continuation */\n\t\tif (rh.frac<1.0) \n        { // partial hit--continue ray walk to composite background\n\t\t\tif (rh.s.mirror>0.0) { // uh oh, need two recursions\n\t\t\t\t// fake partial mirror using sky light\n\t\t\t\tcolor+=frac*rh.frac*rh.s.mirror*skycolor;\n\t\t\t\t//color+=vec3(1,0,0); \n\t\t\t}\n\t\t\t\n\t\t\tfrac*=(1.0-rh.frac);\n\t\t\t\n\t\t\tfloat t=rh.exit_t+0.1;\n\t\t\tray.r_start=ray_radius(ray,t);\n\t\t\tray.C=ray_at(ray,t);\n\t\t}\n\t\telse if (rh.s.mirror>0.0) { // mirror reflection\n\t\t\tfrac*=rh.s.mirror;\n\t\t\tfloat t=rh.t;\n\t\t\tray.r_start=ray_radius(ray,t);\n            float curvature=10.0; // HACK: should depend on radius\n            ray.r_per=curvature*ray.r_per; \n\t\t\tray.C=ray_at(ray,t);\n\t\t\t//color+=rh.s.mirror*calc_world_color(rh.P,reflect(D,rh.N));\n\t\t\tray.D=reflect(ray.D,rh.N); // bounce off normal\n\t\t}\n\t\telse break;\n\t\tif (frac<0.005) return color;\n\t} \n\t\n\treturn color;\n}\n\n/* \n// Old GLSL main \nuniform vec3 camera; // world coordinates of camera\nvarying vec4 myColor;\nvarying vec3 location; // world coordinates of our pixel\n\nvoid main(void) {\n\tvec3 C=camera; // origin of ray (world coords)\n\tvec3 D=location-camera; // direction of ray (world coords)\n\tray_t camera_ray=ray_t(C,D,0.0,2.0/768.0);\n\n\tgl_FragColor.rgb=calc_world_color(camera_ray);\n\tgl_FragColor.a=1.0; // opaque\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx-0.5;\n    vec2 mouse = iMouse.xy / iResolution.xy-0.5;\n    time=iTime;\n    camera=vec3(5.0*mouse.x,-10.0,5.0+5.0*mouse.y);\n    \n\tvec3 C=camera; // origin of ray (world coords)\n\tvec3 D=normalize(vec3(uv.x,1.0,uv.y-0.2)); // direction of ray (world coords)\n\n    float blur=abs(10.0*sin(0.5*time)); // wild time-dependent blurring\n   \t//float blur=1.3; // reasonable antialiasing\n    ray_t camera_ray=ray_t(C,D,0.1/iResolution.x,blur/iResolution.x);\n\n\tfragColor=vec4(calc_world_color(camera_ray),1.0);\n}\n\n\n// VR stuff is UNTESTED!\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float blur=1.3;\n    ray_t camera_ray=ray_t(fragRayOri+vec3(0.0,-10.0,0.0),fragRayDir,0.1/iResolution.x,blur/iResolution.x);\n\tfragColor=vec4(calc_world_color(camera_ray),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscSWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscXDf", "name": "Sol System", "author": "dencarl", "description": "Our solar system.  Heavily modified from a ball occlusion example by iq.\n\nSimple at the moment.  Might add more later.", "tags": ["3d", "sun", "earth", "raytrace", "moon", "planets"], "likes": 12, "viewed": 1276, "date": "1461823762", "time_retrieved": "2024-06-20T18:35:15.514787", "image_code": "// Inspired by https://www.shadertoy.com/view/ldX3Ws (inigo quilez - iq/2013)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// TODO: \n//    - Saturn rings\n//    - asteroid belt\n//    - shading\n//    - textures\n//    - shadows / eclipses\n//    - skybox / milky way\n\n#define eps 0.001\n#define NUMSPH 9\nvec4 sphere[NUMSPH];\n\nvoid getPlanet( in int i, out float r, out float d, out vec3 c, out float op, out float rp, out float ga)\n{\n    // i index\n    // r radius (km)\n    // d distance (km)\n    // c color (rgb)\n    // op orbital period (days)\n    // rp rotation period (days)\n    // ga geometric albedo (fraction)\n    \n    if( i == 0 )\n    {\n        // Sol\n\t\tr = 695700.0;\n\t\td = 0.0;\n\t\tc = vec3( 1.0, 0.5, 0.0 );\n        op = 0.0;\n        rp = 0.0;\n        ga = 1.0;\n        return;\n    }\n    if( i == 1 )\n    {\n        // Mercury\n\t\tr = 2439.7;\n\t\td = (69816.9+46001.2+57909.05)/3.0*1000.0;\n\t\tc = vec3( 0.6, 0.6, 0.6 );\n        op = 87.9691;\n        rp = 58.646;\n        ga = 0.142;\n        return;\n    }\n    if( i == 2 )\n    {\n        // Venus\n\t\tr = 6051.8;\n\t\td = (108939.0+107477.0+108208.0)/3.0*1000.0;\n\t\tc = vec3(0.8, 0.76, 0.66 );  // 204, 195, 168\n        op = 224.701;\n        rp = -243.025;\n        ga = 0.67;\n        return;\n    }\n    if( i == 3 )\n    {\n        // Earth\n\t\tr = 6378.1;\n\t\td = (152100.0+147095.0+149598.0)/3.0*1000.0;\n\t\tc = vec3(0.3, 0.3, 0.5);\n        op = 365.256363;\n        rp = 0.99726968;\n        ga = 0.367;\n        return;\n    }\n    if( i == 4 )\n    {\n        // Mars\n\t\tr = 3389.5;\n\t\td = (249.2+206.7+227.9392)/3.0*1000.0*1000.0;\n\t\tc = vec3(0.66, 0.44, 0.28); // 168, 112, 72\n        op = 686.971;\n        rp = 1.025957;\n        ga = 0.170;\n        return;\n    }\n\tif( i == 5 )\n    {\n        // Jupiter\n\t\tr = 69911.0;\n\t\td = (816.04+740.55+778.299)/3.0*1000.0*1000.0;\n\t\tc = vec3( 0.73, 0.68, 0.62 ); // 187, 173, 157\n        op = 4332.59;\n        rp = 9.925/24.0;\n        ga = 0.52;\n        return;\n    }\n    if( i == 6 )\n    {\n        // Saturn\n\t\tr = 58232.0;\n\t\td = (1509.0+1350.0+1429.39)/3.0*1000.0*1000.0;\n\t\tc = vec3( 0.65, 0.58, 0.43 ); // 166, 149, 109\n        op = 10759.22;\n        rp = 10.55/24.0;\n        ga = 0.47;\n        return;\n    }\n    if( i == 7 )\n    {\n        // Uranus\n\t\tr = 25362.0;\n\t\td = (3008.0+2742.0+2875.04)/3.0*1000.0*1000.0;\n\t\tc = vec3( 0.75, 0.88, 0.91 ); // 190, 228, 231\n        op = 30688.5;\n        rp = 0.71833;\n        ga = 0.51;\n        return;\n    }\n    if( i == 8 )\n    {\n        // Moon\n\t\tr = 1737.1;\n\t\td = (362600.0+405400.0+384399.0)/3.0;\n\t\tc = vec3( 0.39, 0.38, 0.37 ); // 100, 97, 94\n        op = 27.321661;\n        rp = 27.321661;\n        ga = 0.136;\n        return;\n    }\n}\n\n// test if position is inside sphere boundary\nvec3 nSphere( in vec3 pos, in vec4 sph )\n{\n    return (pos-sph.xyz)/sph.w;\n}\n\n// ?\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// ?\nfloat sSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n\t\n    return step( min( -b, min( c, b*b - c ) ), 0.0 );\n}\n\n// return negative if nothing hit\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 nor, out float rad, out float id )\n{\n\tfloat res = 1e20;\n\tfloat fou = -1.0;\n\t\n\tnor = vec3(0.0);\n\n\tfor( int i=0; i<NUMSPH; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n\t    float t = iSphere( ro, rd, sph ); \n\t\tif( t>eps && t<res ) \n\t\t{\n\t\t\tres = t;\n\t\t\tnor = nSphere( ro + t*rd, sph );\n\t\t\tfou = 1.0;\n\t\t\trad = sphere[i].w;\n            id = float(i);\n\t\t}\n\t}\n\t\t\t\t\t\t  \n    return fou * res;\t\t\t\t\t  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\t\n    //-----------------------------------------------------\n    // animate planets\n    //-----------------------------------------------------\n\tfloat time = iTime + 0.7/0.3*0.5;\n\tfloat an = 0.3*time - .7*m.x;\n\n    // other planets\n    for( int i=0; i<NUMSPH; i++ )\n\t{\n        // get planet info\n        float r, d, op, rp, ga;\n        vec3 c;\n        getPlanet( i, r, d, c, op, rp, ga );\n        \n        // rescale for illustrative purposes\n        d = max(0.0, pow(d+1.0,1.0/2.125) ) / 2.5;\n        r = pow(r+1.0,1.0/1.9) / 1.0;\n        \n        // find rotation from time elapsed and orbital period\n        //float a = -an / pow(op+1.0, 1.0/2.0 ) * 50.0;\n        float a = -an / op * 600.0;\n\n        // set animated position of planets\n        sphere[i] = vec4( d*cos(a), 0.0, d*sin(a), r );\n    }\n    // the sun\n\t//sphere[0].w = sphere[5].w;\n    //sphere[0].w = log(sphere[0].w);\n    sphere[0].xyz = vec3(0.0);\n    // moon\n    float r = sphere[8].w;\n    //sphere[8] /= 10.0;\n\tsphere[8] += sphere[3];\n    sphere[8].w = r;\n    \n\t\t\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t//vec3(3.5*sin(an),1.5*cos(0.5*an)+22.2,2.5*cos(an));\n    //vec3 ro = vec3(200.0, 200.0,100.0);\n    //vec3 ta = vec3(0.0,0.0,-1000.0);\n\n    //vec3 ro1 = normalize( vec3(0.1,1.0,0.75)) * sphere[0].w * 7.0;\n    //vec3 ta1 = vec3(0.0,-1.0,-1.0) * length(sphere[7].xyz);\n    //vec3 ro2 = normalize( vec3(1.0,0.0,0.01)) * sphere[0].w * 1.01;\n    //vec3 ta2 = vec3(2.50,0.0,-5.0) * length(sphere[7].xyz);\n\n    vec3 ro1 = normalize( vec3(0.0,1.0,0.0) - normalize( sphere[7].xyz )) * length(sphere[7].xyz) * 1.0;\n    vec3 ta1 = vec3(0.0,0.0,0.0) * length(sphere[7].xyz);\n\n    vec3 ro2 = normalize( cross(sphere[7].xyz, vec3(0.0,1.0,0.0) )) * sphere[0].w * 1.0095;\n    vec3 ta2 = sphere[7].xyz; // vec3(2.50,0.0,-5.0) * length(sphere[7].xyz);\n\n    // set ray origin and target\n    vec3 ro = mix( ro1, ro2, 1.0-smoothstep(-1.0,1.0,cos(an*0.3)) );\n    vec3 ta = mix( ta1, ta2, 1.0-smoothstep(-1.0,1.0,cos(an*0.3)) );\n\n    // calculate camera orientation\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n    // background colour\n    vec3 col = vec3(0.0, 0.0, 0.15);\n    \n    // vertical gradient\n    // col *= (0.98+0.1*rd.y);\n\tcol.z += (0.1+0.1*rd.y);\n    \n\t// cast ray to find planets\n\tvec3 nor;\n\tfloat rad = 0.5;\n    float id;\n\tfloat t = intersect(ro,rd,nor, rad, id);\n\tif( t>0.0 )\n\t{\n        // planet stats do-hickey\n\t\tfloat r, d, op, rp, ga;\n        getPlanet( int(id), r, d, col, op, rp, ga );        \n    }\n    // vigneting\n    //col *= 1.0 - 0.45*dot((q-0.5),(q-0.5));\n\n    fragColor = vec4( col, 1.0 );\n    return;\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscXDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscXDX", "name": "Faux raytrace in 2D", "author": "LaBodilsen", "description": "Faking a raytracing scene with 2D functions. (work in progress)\n\njust a checkerboard floor with a red reflective sphere. \ntrying to recreate this: https://www.tjhsst.edu/~dhyatt/superap/sphere1.jpg\n(changed the title, as it might have tricked some)", "tags": ["sphere", "checkerboard", "floor", "fauxraytracing", "fauxphong"], "likes": 10, "viewed": 651, "date": "1461922271", "time_retrieved": "2024-06-20T18:35:15.514787", "image_code": "// 27-05-2016: reworked the shadow to closer match my \"Real retracing in 3D\" shader\n// 27-05-2016: Added fake Ambient occlusion to the floor and sphere\n// 27-05-2016: reworked floor lightning\n// 27-05-2016: Adjusted reflection -  still wip\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(.8-sqrt(uv.y),0.,0.);\n    float size = (-uv.y+.1)/1.5;\n\tfloat time = iTime*.5;\n    float r = 0.6;\n\n    //floor\n    if (uv.y < .0){\n    color = vec3(0.,0.,0.);\n    color += vec3(mod(floor(uv.x/size+sin(time)) + floor(uv.y*20./size+time),2.)-.8-uv.y);\n\n    // Lightsource falloff on floor\n    color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-uv.x/6.,.6+uv.y/1.5))));\n    }\n\n    // Floor Ambient occlusion\n    color *= smoothstep(1.-length(vec2(uv.x+.3,uv.y*2.+1.2)),1.,length(vec2(.6,.6)));\n    \n\t// Shadow\n    vec2 sphe = uv;\n    sphe.y += (uv.y*1.3)+1.2;\n    sphe.x += (uv.y-uv.x/5.5)+1.;\n\tfloat radius = r-.17;\n    float shadow = step(length(sphe),radius);\n    if (shadow > radius){\n        float shadow = .5;//(length(sphe+(r/3.))*.7/r);\n        color *= shadow;\n    }\n\n    //Sphere\n    vec2 pos = vec2 (.3,.1);\n\tradius = 1.-step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r);\n    if (radius < r){\n        color = vec3(0.,0.,0.);\n    \tfloat light = 1.3-length(vec2(pos.x+uv.x-.2,(pos.y+uv.y-.2)))/.7;\n    \tfloat highlight = .05/length(vec2(pos.x+uv.x+uv.y/6.,pos.y+uv.y)-.2)-.2;\n\n        \n    \tcolor.r = step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r)*light;\n    \tcolor.gb += vec2(step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r)*highlight);\n\n\n        // reflection\n        if (uv.y < -cos(pos.x+.1+uv.x*1.2)/6.){\n\t\t\tvec2 uvrf = vec2(uv.x+pos.x,uv.y);\n            size = -cos(tan(sin(uvrf.x)*1.6)/.6)/10.+sin(-.01+pos.y+uvrf.y-3.12)-uvrf.y/5.;\n\t    \tcolor += vec3(mod(floor(cos(uvrf.y-1.5)+1.5*uvrf.x/size+sin(time)) + \n                              floor(-uvrf.y+uvrf.y*5./size+time+1.1),2.)-1.-uvrf.y);\n    \t    color.r += step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r)*light*1.2;\n\n        }\n\n\t// Shadow reflection\n    vec2 sphe = uv*2.;\n    sphe.y += (uv.y-.25);\n    sphe.x += (uv.x+.5);\n\tfloat radius = r;\n    float shadow = step(3.-length(sphe),radius);\n    if (shadow > radius){\n        float shadow = .6;//(length(sphe+(r/3.))*.7/r);\n        color *= shadow;\n    }\n\t// Sphere ambient occlusion\n    color *= smoothstep(1.-length(vec2(uv.x+.3,uv.y*2.+2.)),1.,.6);\n\n    } \n\n\tfragColor = vec4(vec3(color.rgb),1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscXDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscXWM", "name": "rosace 5 ( 252 chars) ", "author": "FabriceNeyret2", "description": "rosace (generalisation of https://www.shadertoy.com/view/ls3XWM )", "tags": ["pseudo3d", "2tweets", "short", "rosace"], "likes": 32, "viewed": 1038, "date": "1459619903", "time_retrieved": "2024-06-20T18:35:15.514787", "image_code": "// in the taste of http://9gag.com/gag/am9peXo\n// generalisation of https://www.shadertoy.com/view/ls3XWM\n\n\n/**/  // 252 chars  (-9 tomkh, -8 Fabrice )\n\n\n#define d  O+=.1*(1.+cos(A=2.33*a+iTime)) / length(vec2( fract(a*k*7.96)-.5, 16.*length(U)-1.6*k*sin(A)-8.*k)); a+=6.3;\n//#define d  O+= (1.+cos(A=2.33*a+iTime)) * smoothstep(.5,0., length(vec2( fract(a*k*7.96)-.5, 16.*length(U)-1.6*k*sin(A)-8.*k))); a+=6.3;\n#define c  d d d  k+=k;\n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    U = (U+U-(O.xy=iResolution.xy)) / O.y;\n    float a = atan(U.y,U.x), k=.5, A;\n    O -= O;\n    c c c c\n}\n/**/\n\n\n\n\n/** // 269 chars\n\n#define A  7./3.*a + iTime\n#define d  O += .1*(1.+cos(A)) / length(vec2( fract(a*k*50./6.283)-.5, 16.*(length(U)-.1*k*sin(A)-.5*k))); a += 6.283;\n#define c  d d d k+=k;\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\n    U = (U+U-(O.xy=iResolution.xy))/O.y;\n    float a = atan(U.y,U.x), k=.5;\n    \n\tO -= O;  \n    c c c c\n    //  O += .2*vec4(0,1,2,0);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscXWX", "name": "Moebius Strip 2", "author": "dr2", "description": "More spiders and a see-through floor (just like the Escher original)", "tags": ["raymarching", "escher", "spider", "moebius"], "likes": 11, "viewed": 851, "date": "1461760893", "time_retrieved": "2024-06-20T18:35:15.530537", "image_code": "// \"Moebius Strip 2\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir[4], qHit;\nfloat dstFar, tCur, mobRad, legLenU, legLenD, bdyHt, spdVel, nSpd;\nint idObj;\nconst int idMob = 1, idBdy = 11, idHead = 12, idEye = 13, idAnt = 14, idLegU = 15,\n   idLegD = 16;\n\nfloat MobiusGDf (vec3 p, float r, vec2 b, float rc, float ns)\n{\n  vec3 q;\n  float d, a, na, aq;\n  q = vec3 (length (p.xz) - r, 0., p.y);\n  a = atan (p.z, p.x);\n  q.xz = Rot2D (q.xz, 0.5 * a);\n  d = length (max (abs (q.xz) - b, 0.)) - rc;\n  q = p;\n  na = floor (ns * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / ns;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 0.5 * aq);\n  q.x = abs (abs (q.x) - 0.48 * b.y) - 0.24 * b.y;\n  d = max (d, rc - length (max (abs (q.xz) - vec2 (0.12, 0.35) * b.y, 0.)));\n  return 0.7 * d;\n}\n\nfloat ShpCylDf (vec3 p, vec3 v, float md, float r, float rf)\n{\n  float len, s;\n  len = length (v);\n  v = normalize (v);\n  s = clamp (dot (p, v), 0., len);\n  p -= s * v;\n  s = s / len - md;\n  return length (p) - r * (1. - rf * s * s);\n}\n\nfloat SpdDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 5.5;\n  p *= szFac;\n  dMin *= szFac; \n  p.y -= bdyHt + 0.7;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  q -= vec3 (0., 0.15, -0.3);\n  d = ShpCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), 0., 0.07, 0.7);\n  if (d < dMin) { dMin = d;  idObj = idAnt; }\n  p.y += bdyHt;\n  for (int j = 0; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * ShpCylDf (q, kneePos[j] - hipPos[j], 0., 0.25, 0.3);\n    if (d < dMin) { dMin = d;  idObj = idLegU;  qHit = q; }\n    q = p - kneePos[j];\n    d = 0.6 * ShpCylDf (q, footPos[j] - kneePos[j], 0.3, 0.2, 1.2);\n    if (d < dMin) { dMin = d;  idObj = idLegD;  qHit = q; }\n  }\n  dMin /= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, aq, na;\n  dMin = dstFar;\n  d = MobiusGDf (p, mobRad, vec2 (0.07, 0.8), 0.02, 28.);\n  if (d < dMin) { dMin = d;  idObj = idMob; }\n  q = p;\n  a = tCur * spdVel / (2. * pi * mobRad);\n  q.xz = Rot2D (q.xz, a);\n  na = floor (nSpd * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / nSpd;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += mobRad;\n  if (PrCylDf (q.xzy, 1., 0.7) < dMin) {\n    a += aq;\n    if (2. * floor (0.5 * na) != na) a += 2. * pi;\n    q.xy = Rot2D (q.xy, 0.5 * a);\n    dMin = SpdDf (q, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvoid Setup ()\n{\n  vec3 v;\n  vec2 ca, sa;\n  float gDisp, a, az, fz, d, ll;\n  nSpd = 13.;\n  spdVel = 1.5;\n  for (int j = 0; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];  hipPos[j + 4].x *= -1.;\n  }\n  gDisp = spdVel * tCur;\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = 0; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) +\n       mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 SpdCol (vec3 vn)\n{\n  vec3 col, c1, c2;\n  c1 = vec3 (1., 0.6, 0.3);\n  c2 = vec3 (0.2, 0.2, 0.5);\n  if (idObj == idBdy) {\n    col = mix (c1, c2, SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c2;\n    if (qHit.z > 0.4) col = mix (vec3 (0.2, 0.05, 0.05), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z < 0.6) ? vec3 (0., 1., 0.) : c1;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c2, c1,  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, spec, cd, cs;\n  int idObjT;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idMob) {\n      col = vec3 (0.35, 0.35, 0.4);\n      spec = 0.1;\n      vn = VaryNf (30. * ro, vn, 3.);\n    } else if (idObj >= idBdy) {\n      col = SpdCol (vn);\n      spec = 1.;\n    }\n    cd = 0.;\n    cs = 0.;\n    for (int k = 0; k < 4; k ++) {\n      cd += max (dot (vn, ltDir[k]), 0.);\n      cs += pow (max (0., dot (ltDir[k], reflect (rd, vn))), 64.);\n    }\n    col = col * (0.1 + 0.6 * cd + spec * cs);\n  } else col = vec3 (0.2, 0.4, 0.3);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  az = -0.1 * tCur;\n  el = -0.2 * pi * cos (0.06 * tCur);\n  dstFar = 20.;\n  mobRad = 3.5;\n  Setup ();\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0., -12.);\n  ltDir[0] = normalize (vec3 (1., 1., 1.));\n  ltDir[1] = normalize (vec3 (1., 1., -1.));\n  ltDir[2] = normalize (vec3 (-1., -1., 1.));\n  ltDir[3] = normalize (vec3 (-1., -1., -1.));\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscXWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdSDN", "name": "clover-snake", "author": "javalang", "description": "just a remix from www.shadertoy.com/view/XsXGzn and www.shadertoy.com/view/MsBSDz\nuncomment LUCKY if you want feel lucky :)", "tags": ["25d", "formula"], "likes": 9, "viewed": 555, "date": "1459504383", "time_retrieved": "2024-06-20T18:35:15.531534", "image_code": "//mix from https://www.shadertoy.com/view/XsXGzn\n//and https://www.shadertoy.com/view/MsBSDz\n\n//#define LUCKY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(1.0,1.0,1.0);\n    float time = iTime*.2;\n\n\tfor(int i = 20; i>0; i--)\n    {     \n        vec2 shape = uv - vec2(.5,.45);  \n        shape.x+=cos(float(i)/3.5-time*1.3)/2.5;\n        shape.y+=sin(float(i)/2.5-time*1.7)/2.5;\n\n        vec2 sh2=shape*vec2(2.,1.2);//*2.-1.;\n        float t=iTime*1.5;\n        float lucky=1.0;\n#ifdef LUCKY\n        lucky=1.3;\n#endif    \n    \tfloat a = atan(sh2.x,sh2.y)*lucky;\n    \tfloat r = length(sh2);\n    \tfloat s = 0.5 + 0.5*sin(3.0*a + t);\n    \tfloat g = sin(1.57+3.0*a+t);\n    \tfloat d = 0.15 + 0.3*sqrt(s) + 0.15*g*g;\n    \tfloat h = clamp(2.*r/d,0.0,1.0);\n    \tfloat f = 1.0-smoothstep( 0.95, 1.0, h );\n    \th *=1.0-0.5*(1.0-h)*smoothstep(0.95+0.5*h,1.0,sin(3.0*a+t));\n        col *= h;\n        col.y+=.02;\n        col = mix( col, 1.2*vec3(0.1*h,0.12+0.5*h,0.1), f-.01 );\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdSRl", "name": "Electric Whiskers", "author": "ddddddddd", "description": "Messing around with (unclamped) sphere normal vectors.", "tags": ["2d", "distortion", "plasma", "sphere", "blending", "glow", "electric", "electricity"], "likes": 26, "viewed": 1051, "date": "1460991032", "time_retrieved": "2024-06-20T18:35:15.999667", "image_code": "/*\n\n\"Electric Whiskers\"\nby Dean Alex 2016, dean[at]neuroid co uk\n\nMessing around with (unclamped) sphere normal vectors.\n\nedit. changed the sqrt.\n\n*/\n\n\nfloat sq( in float f ){\n    return sqrt( abs( f )) * sign(f);\n}\nvec3 sq3( in vec3 v ){\n    return vec3(\n        sq(v.x),\n        sq(v.y),\n        sq(v.z)\n    );\n}\n         \nvec3 sh( in vec3 pos, in vec2 uv )\n{\n    vec2 xy = (uv.xy - pos.xy) / pos.z;\n    float len = dot(xy,xy);\n    return vec3( xy, sq( 1.0 - len ));\n}\nfloat tsin( in float mf ){\n    return sin( iTime * mf);\n}\nfloat tcos( in float mf ){\n    return cos( iTime * mf);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 norm;\n    float w = iResolution.x;\n    float h = iResolution.y;\n    float m = min(w,h);\n    \n    vec3 s1 = sh(\n        vec3( w * 0.5, h * 0.5, m * 0.5 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s2 = sh(\n        vec3( (tsin(1.7)*0.4 + 0.5)*w, (tcos(1.3)*0.4 + 0.5)*h, m * 0.1 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s3 = sh(\n        vec3( (tsin(0.5)*0.3 + 0.5)*w, (tcos(-2.0)*0.4 + 0.5)*h, m * 0.5 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s4 = sh(\n        vec3( (tcos(-0.31)*0.6 + 0.5)*w, (tsin(-0.4)*0.2 + 0.5)*h, m * 3.3 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    \n    //\n    norm = sq3( cross( s2.yzx, s1.zxy ));\n    norm = sq3( cross( norm, s3.zxy ));\n    norm = sq3( cross( -norm, s4.xyz ));\n    \n    \n    //\n    \n    float mag = length( norm );\n    float a = pow( smoothstep( 1.0, 5.0, mag ), 0.5 );\n    float s = atan( norm.z, norm.x ) / 6.283185307179586;\n    float t = asin( norm.y ) / 3.14159265358979;\n    fragColor = texture( iChannel0, vec2( s*5.1 + iTime*0.2, t * s ));\n    fragColor.g = min( fragColor.g, fragColor.b );\n    vec3 lightDir = normalize( vec3( tcos(1.5) * -1.6, -0.3, tsin(1.5) * 5.0 ));\n    float mflight = max(dot( norm, lightDir), 0.0);\n    float dis1 = 1.0 - length( norm - lightDir ) / 2.0;\n    mflight += pow( dis1, 10.0) * 2.5;\n    fragColor.rgb *= mflight;\n    vec3 l1p = vec3( tsin(1.7) * 0.6, tcos(2.5) * 0.5, -tsin(0.5) * 0.6 );\n    vec3 l1c = vec3( 1.0, 2.0, 3.0 );\n    float dis = 1.0 - length( norm - l1p ) / 2.0;\n    fragColor.rgb += l1c * pow( dis, 0.8 );\n    fragColor = mix( fragColor, vec4(1.0,0.0,0.0,1.0), a );\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdSRS", "name": "Flag of Finland", "author": "mazander", "description": "Flag of Finland", "tags": ["flagoffinland"], "likes": 1, "viewed": 111, "date": "1460061544", "time_retrieved": "2024-06-20T18:35:15.999667", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 1.5 - 0.25;\n    uv.y += 0.1 * sin(uv.x * 5.0 + 2.13 * iTime) * uv.x;\n    uv.x += 0.03 * sin(1.14 * iTime) * uv.x;\n    if(uv.y < 0. || uv.y > 1. ||uv.x < 0. ||uv.x > 1.) {\n        fragColor = vec4(0.);\n    } else if(uv.y > 4. / 11. && uv.y < 7. / 11. || uv.x > 5. / 18. && uv.x < 8. / 18.) { // Finnish flag ratios y:4:3:4  x:5:3:10\n        fragColor = vec4(0., 53. / 255., 0.5 , 1.);\n    } else {\n        fragColor = vec4(1.);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdSWM", "name": "Whitepoint", "author": "koalefant", "description": "Playing with distance fields and ambient occlusion.", "tags": ["distancefield", "ao", "ambientocclusion"], "likes": 18, "viewed": 416, "date": "1459774273", "time_retrieved": "2024-06-20T18:35:16.866376", "image_code": "float sd_sphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nvec3 op_rep(vec3 p, vec3 c){\n\treturn vec3(mod(p.x, c.x),\n\t\t\t\tmod(p.y, c.y),\n\t\t\t\tmod(p.z, c.z)) - 0.5 * c;\n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k ) {\n\tfloat res = exp( -k*a ) + exp( -k*b );\n\treturn -log( res )/k;\n}\n\nfloat displacement(vec3 p, float radius) {\n\tvec3 v = sin(p / 3.1415926 / radius);\n\treturn v.x*v.y*v.z;\n}\n\nfloat sd_floor(vec3 p) {\n\tfloat floor_r = 0.25;\n\tfloat pi = 3.1415926;\n\tfloat xoffset = cos(pi / 6.0) * floor_r*2.0;\n\tfloat floor_a = sd_sphere(op_rep(p, vec3(xoffset*2.0,0.0,xoffset)), floor_r*2.0);\n\tfloat floor_b = sd_sphere(op_rep(p+vec3(xoffset,0.0,xoffset/2.0), vec3(xoffset*2.0,0.0,xoffset)), floor_r*2.0);\n\treturn min(floor_a, floor_b);\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sd_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sd_torus_xz( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sd_torus_yz( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat level_distance(vec3 p) {\n\tfloat t = iTime;\n\tfloat floor_dist = sd_floor(op_rep(p + vec3(0,-1,0), vec3(0,4.6,0)));\n\tfloor_dist += cos(t*0.5)*0.2*cos(p.x)*cos(p.z);\n\n\tvec3 p_rep = op_rep(p+vec3(3,-1,3), vec3(5,0,5.95));\n\tfloat dome_osc = cos(t*2.0)*0.01;\n\tfloat dome = -sd_sphere(p_rep, 3.0) + dome_osc;\n\tdome = min(dome,\n\t\tsd_torus_yz(op_rep(p+vec3(0.5,-1,0), vec3(5,0,0)),\n\t\t\t\t\tvec2(1.6+dome_osc*3.0, 0.1)));\n\n\tfloat r = min(floor_dist, dome);\n\tr = min(r, sd_box(p, vec3(0.5,1,0.5)));\n\tr = min(r, sd_box(p+vec3(0,-0.5,0), vec3(0.25,1,0.25)));\n\n\tr = min(r, sd_capsule(p, vec3(-0.5,0,0.25), vec3(-0.5,1,-0.25), 0.2));\n\n\tr = min(r, sd_torus_xz(p+vec3(0,cos(t)*0.4-0.2,0), vec2(0.8, 0.1)));\n\tr = min(r, sd_torus_xz(p+vec3(0,sin(t*0.1)*0.2-0.2,0), vec2(1.0, 0.1)));\n\treturn r;\n}\n\nfloat total_distance(vec3 p) {\n\treturn level_distance(p);\n}\n\n// Based on \"GPU Ray Marching of Distance Fields\"\n// 2012 Lukasz Jaroslaw Tomczak\n// \n// modified to redistributed more samples closer to the surface\nfloat ambient_occlusion(vec3 p, vec3 n, int reflection) {\n\tconst int steps = 5;\n\tfloat sample_distance = 0.7;\n\tfloat occlusion = 0.0;\n\tfor (int i = 1; i <= steps; i++) {\n\t\tfloat k = float(i) / float(steps);\n\t\tk *= k;\n\t\tfloat current_radius = sample_distance * k;\n\t\tfloat distance_in_radius = total_distance(p + current_radius * n);\n\t\tocclusion += pow(0.5, k * float(steps)) * (current_radius - distance_in_radius);\n\t}\n\tfloat scale = 0.4;\n\treturn 1.0 - clamp(scale * occlusion, 0.0, 1.0 );\n}\n\nvec3 normal(vec3 p) {\n\tfloat e = 0.0001;\n\tfloat f0 = total_distance(p);\n\tfloat fx = total_distance(vec3(p.x + e,p.y,p.z));\n\tfloat fy = total_distance(vec3(p.x,p.y + e,p.z));\n\tfloat fz = total_distance(vec3(p.x,p.y,p.z + e));\n\treturn normalize(vec3(fx-f0,fy-f0,fz-f0));\n}\n\nvec4 raymarch(vec3 origin, vec3 dir) {\n\tfloat t = 0.0;\n\tconst int max_steps = 256;\n\tfloat epsilon = 0.00075;\n\tvec3 fog_color = vec3(1.0);\n\tvec4 color = vec4(fog_color,1);\n\tint num_reflections = 1;\n\tint reflections_left = num_reflections;\n\tfor(int i = 0; i < max_steps; ++i) {\n\t\tvec3 p = origin + dir * t;\n\t\tfloat d = total_distance(p);\n\t\tif(d < epsilon) {\n\t\t\tvec3 n = normal(p);\n\t\t\tvec3 sample_color = vec3(0.8);\n\t\t\t// distance fade\n\t\t\tsample_color = mix(sample_color, fog_color, vec3(clamp(1.0-exp(-length(p)/8.0), 0.0, fog_color.x))); // Sphere color\n\t\t\t// front light\n\t\t\t//color.xyz += 0.1 * vec3(1) * clamp(dot(-dir, n),0,1);\n\t\t\t// ambient occlusion\n\t\t\tsample_color *= ambient_occlusion(p, n, num_reflections - reflections_left);\n\n\t\t\tif (false) {\n\t\t\t\tfloat step_intensity = 1.0-(float(i))/float(max_steps);\n\t\t\t\tcolor.yz *= vec2(step_intensity);\n\t\t\t}\n            float f = 1.0;\n            if (num_reflections != reflections_left)\n            \tf = 0.075;\n\t\t\tcolor.xyz = mix(color.xyz, sample_color, f);\n            break;/*\n\t\t\tif (reflections_left == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// restart loop starting from new reflection point\n\t\t\t\treflections_left -= 1;\n\t\t\t\tepsilon *= 10.0;\n\t\t\t\torigin = p + n * epsilon * 2.0;\n\t\t\t\tdir = normalize(dir-2.0*n*dot(dir,n));\n\t\t\t\ti = 0;\n\t\t\t\tt = 0.0;\n\t\t\t\tmax_steps /= 4;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t}\n\t\tt += d * 1.0;\n\t}\n\treturn vec4(pow(color.xyz, vec3(2.2)), color.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n\tvec2 uv = coord.xy / iResolution.xy;\n    const float pi = 3.1415926;\n    \n    vec3 origin = vec3(cos(iTime * 0.1+pi*0.5)* 5.0-2.5, 2, cos(iTime*0.05)*0.2);\n    vec2 mouse = -2.0*(vec2(iMouse) / vec2(iResolution) - vec2(0.5));\n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0);\n    float ax = (uv.x-0.5+mouse.x)*pi*0.25 * 1.6;\n    float ay = (uv.y-0.5+mouse.y)*pi*0.25;\n    float cx = cos(ax);\n    float cy = cos(ay);\n    float sx = sin(ax);\n    float sy = sin(ay);\n    vec3 dir = normalize(vec3(cx, sy, sx*cy));\n    fragColor = raymarch(origin, dir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdXDB", "name": "Friendship!", "author": "drone1", "description": "Simple thing with some colors I liked. \n\nIf it's obvious to anyone why uncommenting  WHY_THE_MASSIVE_ALIASING causes massive aliasing, I'd love to hear it. I only spent a few minutes looking at it but it was not obvious to me. ", "tags": ["2d"], "likes": 4, "viewed": 140, "date": "1461444138", "time_retrieved": "2024-06-20T18:35:17.381582", "image_code": "// Uncomment -- anyone know what's going on w/ the aliasing here?\n//#define WHY_THE_MASSIVE_ALIASING\n\n// Uncomment for crazy glitch mode\n//#define GLITCH\n\n#ifdef GLITCH\n#define NUM_CELLS\t( mix( iResolution.x, rand( iTime * 0.1 ) * 50.0, step( 0.5, mod( rand( iTime ), 1.0 ) ) ) )\n#else\n#define NUM_CELLS 30\n#endif\n\n// Turning this off since AA doesn't actually look great for this.\n#define AA 1\n\nfloat rand( float x )\n{\n    return fract( 823473.28374 * \n                 ( 0.5 + 0.5 * sin( \n                     dot( \n                         vec2( x * 1423.023 + iTime * 0.000001, iTime * 0.00000001 + x / 32345.023 ), \n                         vec2( 23.87, 8734.6235 )\n                     )\n                 ) )\n           );\n}\n\nvec3 color( vec2 uv ) \n{\n    vec3 clr = vec3( 1.0 );\n\n    float nc = float( NUM_CELLS );\n    float fx = floor( uv.x * nc ) / nc;\n    float xr = rand( fx );\n    float yoffset = mod( xr * 13.23 + pow( 2.0, 16.0 * xr ) * 0.1 * iTime, 1.0 );\n    float fy = floor( uv.y * nc + yoffset ) / nc;\n    \n    clr *= xr * xr;\n    clr.r -= fx * fy;\n    clr.g -= 0.2 * fy;\n    clr.b *= 1.1 * sqrt( fx );\n    \n    clr *= xr;\n    clr.b *= 1.0 - 0.3 * sqrt( uv.y );\n    \n    vec2 c = vec2( fract( uv.x * nc ), fract( uv.y * nc + yoffset ) );\n    clr *= 1.0 + 0.3 * sqrt( 4.0 * c.x * ( 1.0 - c.x ) * c.y * ( 1.0 - c.y ) ); \n    clr.r += 0.1 + 0.5 * uv.y;\n    clr = clr * 0.9 + 0.1 * smoothstep( 0.0, 1.0, clr );\n    clr += 0.2;\n    clr *= 1.05;   \n    \n    return clr;\n}\n\nvec3 render( vec2 uv )\n{\n    float v = sqrt( 16.0 * uv.x * ( 1.0 - uv.x ) * uv.y * ( 1.0 - uv.y ) );\n\n    // Anyone know this causes massive aliasing?\n#ifdef WHY_THE_MASSIVE_ALIASING\n    uv = -1.0 + 2.0 * uv;\n    uv.x *= pow( 1.0 - v, 0.01 + 0.5 * ( 0.5 + 0.5 * sin( iTime * 0.1 ) ) );\n    uv = 0.5 + 0.5 * uv;\n#endif\n    \n    vec3 clr = vec3( 0.0 );\n    \n    vec2 ir = 1.0 / iResolution.xy;\n    \n    for ( int i = 0; i < AA; ++i )\n    for ( int j = 0; j < AA; ++j )\n    {\n        vec2 offset = ir.xy / float( AA ) * vec2( float( i ), float( j ) );\n        clr += color( uv + offset );\n    }\n    \n    clr /= float( AA * AA );\n\n    // vignette\n    clr *= 1.1 * min( 1.0, 0.1 + v );\n\n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(render( uv ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdXDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdXDf", "name": "Mooglius", "author": "vox", "description": "Mooglius", "tags": ["mooglius"], "likes": 2, "viewed": 411, "date": "1461937632", "time_retrieved": "2024-06-20T18:35:17.381582", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*iTime/E)\n#define saw(x) (acos(cos(x))/PI)\n#define cosaw(x) saw(x+PI/2.0)\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\n\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\n\nvec2 mobius(vec2 uv)\n{\n    float turns = mod(floor(time), 10.0)+3.0;//saw(time)*3.0+3.0;\n    uv = rotatez(uv.xy, PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    vec2 xy = rotatez(uv.xy, PI*2.0*(rot)+PI/turns).xy;\n    xy = sign(xy)*log(abs(xy));\n    return vec2(saw(theta*turns/2.0), saw(xy.x*PI*1.0));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = exp(-saw(time)*2.0);\n    uv = uv*scale-scale/2.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    uv = normalize(uv)/log(r+1.0);\n    uv += sin(vec2(time, time/PI*E*GR))*scale*4.0*PI;\n    uv = mobius(uv); \n    \n    const int max_iterations =1;\n    \n    \n    float dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n    float map = sqrt(dist)*PI;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        scale = exp(-saw(time+float(i))*2.0);\n     \tuv = uv-.5;\n        uv *= scale;\n        r = length(uv);\n \t   \tuv = normalize(uv)/log(r+1.0);\n        uv += sin(vec2(time+iteration*2.0*PI, time/PI*E*GR+iteration*2.0*PI))*scale;\n        uv = mobius(uv);\n        \n        dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n        map += sqrt(dist)*PI;\n    }\n    \n    fragColor = smoothstep(0.0, .75, map)*vec4(phase(map*2.0+time), 1.0);\n    fragColor = texture(iChannel0, uv);\n    fragColor = vec4(uv, 0.0, 1.0);\n}\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdXDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdXWX", "name": "sINE cOMB", "author": "hobscure", "description": "sinus combulator", "tags": ["sinecomb"], "likes": 1, "viewed": 97, "date": "1461877646", "time_retrieved": "2024-06-20T18:35:17.539112", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct+0.07, pct, st.y) - \n          smoothstep( pct, pct+0.07, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec3 color = vec3(st.y * sin(iTime));\n    \n    float v = (cos((st.x * 10.0) + (iTime * (st.y/9000.0)) * 5.0)/ 5.0 )+ 0.5;\n    \n    float v2 = v + (cos((st.x * 800.0) + (iTime) * 5.0)/ 5.0 );\n    \n    float pct = plot(st ,v2);\n    \n    color = (pct)*color+pct*vec3(1.0,0.0,0.0);\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdXWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdXzj", "name": "Implicit-CG-UD", "author": "lesolorzanov", "description": "Creation of implicit surfaces using sphere tracing and flat shading", "tags": ["implicit"], "likes": 0, "viewed": 619, "date": "1460566194", "time_retrieved": "2024-06-20T18:35:18.557330", "image_code": "// Blobs\n// Based on Eric Galin's work\n \nconst int Steps = 200;\nconst float Epsilon = 0.05; // Marching epsilon\n \nconst float lipshietz = 8.5;\nconst float depthMax = 20.0;\n\nconst float near = 10.0;\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n \nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n \nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n \n \n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n \n// Primitive functions\n \n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n \n// Segment skeleton\n// p : point\n// a,b  : extremity of the segment\n// e : energy associated to skeleton\n// R : radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e,float R)\n{\n  vec3 v = b - a;\n  vec3 w = p - a;\n\n  float c1 = dot(w,v);\n  if ( c1 <= 0.0 )\n    return e*falloff(length(p-a),R);\n\n  float c2 = dot(v,v);\n  if ( c2 <= c1 )\n      return e*falloff(length(p-b),R);\n\n  float t = c1 / c2;\n  vec3 Pb = a + t * v;\n    \n  return e*falloff(length(p-Pb),R);\n}\n\n\n\n// Potential field\n// p : point\nfloat object(vec3 p)\n{         \n  p.z=-p.z;\n  float v = -0.5;\n    float ks=0.0;\n    \n  //jaja creyeron que se iban a robar mi formula XD\n    \n    bool wave=false;\n   //3.0*sin(iTime)\n    \n    float pi=3.14159265359;\n    //float dx=-9.5*sin(iTime), dy=-1.5*sin(iTime), dz=5.0*sin(iTime);\n    float dx=-9.0, dy=-1.5,dz=5.0;\n    float x=0.0,y=-1.0,z=1.0,speed=1.0,near=3.5,ds=1.0,dr=0.5;\n    \n    if(wave){\n        v+=segment(p, vec3(2.5+dx,1.0-dy*sin(iTime),1.0+dz), vec3(2.5+dx,4.0-dy*sin(iTime),1.0+dz), 1.0,1.0);\n        v+=segment(p, vec3(1.0+dx,4.0-dy*sin(iTime),1.0+dz), vec3(4.0+dx,4.0-dy*sin(iTime),1.0+dz), 1.0,1.0);\n       \t\n    }else{    \n        //ks+= pow( point(p, vec3(0.0,1,0),1.0,2.0) , power ) ;\n       \n        v+=point(p, vec3(0.0,1.0,0),1.0,2.0);\n    }\n  return v;\n}\n \n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n \n// Trace ray using sphere tracing\n// a : ray origin\n// u : ray direction\nvec3 Trace(vec3 a, vec3 u, out bool hit)\n{\n  hit = false;\n  float temp = 0.0;\n  float depth = 0.0;\n  vec3 p = a;\n  \n  for(int i=0; i<Steps; i++)\n  {\n    if (!hit) {\n      float v = object(p);\n      if (v > 0.0) {\n        hit = true;\n      }\n      //p += Epsilon*u;\n      temp = max(Epsilon, abs(v/lipshietz));\n      depth += temp;\n      if(depth > depthMax)\n      {\n         return p;\n      }\n      p+=temp*u;\n    }\n  }\n  return p;\n}\n \n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n  //return vec3(0.0,0.2,0.5);\n}\n \n// Lighting\n// p : point,\n// n : normal at point\nvec3 shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  vec3 lightColor = vec3(0.5*sin(iTime)+0.5, 0.5*sin(iTime-1.05)+0.5, 0.5*sin(iTime-2.1)+0.5);\n \n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l))+0.4;\n \n  c += diff*lightColor;\n \n  return c;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n \n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -5.0));\n  vec3 ro = vec3(0.0, 1.2, 20.0);\n \n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  //float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n \n  // Trace ray\n  bool hit;\n  vec3 pos = Trace(ro + rd*near, rd, hit);\n \n  // Shade background\n  vec3 rgb = background(rd);\n \n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n    // Shade\n    rgb = shade(pos, n);\n  }\n \n  fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MstSDB", "name": "Sceneradio@wappuradio- Live 2016", "author": "Exca", "description": "Template for live coding done during Sceneradio show at wappuradio, a student made radio station operating in Finland during last weeks of may. For more info visit wappuradio.fi.", "tags": ["raymarching"], "likes": 0, "viewed": 269, "date": "1461438541", "time_retrieved": "2024-06-20T18:35:21.072829", "image_code": "/*** Sceneradio@Wappuradio live coding ***\n\nIf any of the viewers wish to know more about coding raymarchers there's great tutorial at\nhttps://www.shadertoy.com/view/XllGW4 Basic functions are copied from that tutorial.\n\nFor more additional info visit http://iquilezles.org/www/index.htm\n\nThis is 2 hour live shader coding during radio show.\nFor the template used visit: https://www.shadertoy.com/view/MdtSDB\n\nActual code starts from line 385\n*/\n// __ Matrix functions __ _____________________________________\n\n    // Return 2x2 rotation matrix\n    // With vector swizzle/mask can use as a 3x3 xform\n    // For y, you need to invert \n    // angle in radians\n    // ========================================\n    mat2 Rot2(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat2( c, -s, s, c );\n    }\n\n    // http://www.songho.ca/opengl/gl_anglestoaxes.html\n\n    // Return 4x4 rotation X matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4X(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4( 1, 0, 0, 0,\n                     0, c,-s, 0,\n                     0, s, c, 0,\n                     0, 0, 0, 1 );\n    }\n\n    // Return 4x4 rotation Y matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4Y(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4( c, 0, s, 0,\n                     0, 1, 0, 0,\n                    -s, 0, c, 0,\n                     0, 0, 0, 1 );\n    }\n\n    // Return 4x4 rotation Z matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4Z(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4(\n            c,-s, 0, 0,\n            s, c, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n         );\n    }\n\n    // Translate is simply: p - d\n    // opTx will do transpose(m)\n    // p' = m*p\n    //    = [m0 m1 m2 m3 ][ p.x ]\n    //      [m4 m5 m6 m7 ][ p.y ]\n    //      [m8 m9 mA mB ][ p.z ]\n    //      [mC mD mE mF ][ 1.0 ]\n    // ========================================\n    mat4 Loc4( vec3 p ) {\n        p *= -1.;\n        return mat4(\n            1,  0,  0,  p.x,\n            0,  1,  0,  p.y,\n            0,  0,  1,  p.z,\n            0,  0,  0,  1\n        );\n    }\n\n    // if no support for GLSL 1.2+\n    //     #version 120\n    // ========================================\n    \n// __ Smoothing functions _____________________________________\n\n    // Smooth Min\n    // http://www.iquilezles.org/www/articles/smin/smin.htm\n\n    // Min Polynomial\n    // ========================================\n    float sMinP( float a, float b, float k ) {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n    }\n\n    // Min Exponential\n    // ========================================\n    float sMinE( float a, float b, float k) {\n        float res = exp( -k*a ) + exp( -k*b );\n        return -log( res )/k;\n    }\n\n    // Min Power\n    // ========================================\n    float sMin( float a, float b, float k ) {\n        a = pow( a, k );\n        b = pow( b, k );\n        return pow( (a*b) / (a+b), 1.0/k );\n    }\n\n// __ Surface Primitives ____________________________\n\n    // Return max component x, y, or z\n    // ========================================\n    float maxcomp(in vec3 p ) {\n        return max(p.x,max(p.y,p.z));\n    }\n\n// Signed\n\n    // b.x = Width\n    // b.y = Height\n    // b.z = Depth\n    // Leave r=0 if radius not needed\n    // ========================================\n    float sdBox(vec3 p, vec3 b, float r) {\n        vec3 d = abs(p) - b;\n        return min(maxcomp(d),0.0) - r + length(max(d,0.0));\n        // Inlined maxcomp\n        //return min(max(d.x,max(d.y,d.z)),0.0) - r + length(max(d,0.0));\n    }\n\n    // ========================================\n    float sdCappedCylinder( vec3 p, vec2 h ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    // ========================================\n    float sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n        vec3 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h ) - r;\n    }\n\n    // c.x Width\n    // c.y Base Radius\n    // c.z Depth\n    // Note: c must be normalized\n    // ========================================\n    float sdCone( vec3 p, vec3 c) // TODO: do we need to use 'in' for all primitives?\n    {\n        // c.x = length\n        // c.y = base radius\n        //float q = length( p.xy );\n        //return dot( c, vec2( q, p.z ) ); // BUG in iq's docs -- laying on side\n\n        float q = length( p.xz );\n        return dot( c.xy, vec2( q, p.y ) );\n\n        // Alt. cone formula given in: ???\n        //vec2 q = vec2( length( p.xz ), p.y );\n        //float d1 = -p.y - c.z;\n        //float d2 = max( dot(q,c.xy), p.y );\n        //return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n    }\n\n    // ========================================\n    float sdCylinder( vec3 p, vec3 c ) {\n        return length(p.xz - c.xy) - c.z;\n    }\n\n    // n.xyz = point on plane\n    // n.w   = distance to plane\n    // Note: N must be normalized!\n    // ========================================\n    float sdPlane( vec3 p, vec4 n ) {\n        return dot( p, n.xyz ) + n.w;\n    }\n\n    // 4 sided pyramid\n    // h.x = base X\n    // h.y = height\n    // h.z = base Z (usually same as h.x)\n    // ========================================\n    float sdPyramid4( vec3 p, vec3 h ) {\n        p.xz = abs(p.xz);                   // Symmetrical about XY and ZY\n        vec3 n = normalize(h);\n        return sdPlane(p, vec4( n, 0.0 ) ); // cut off bottom\n    }\n\n    // ========================================\n    float sdSphere( vec3 p, float r ) {\n        return length(p) - r;\n    }\n\n    // ========================================\n    float sdSphere2( vec3 p, float r ) {\n        return abs(length(p) - r);\n    }\n\n    // ========================================\n    float sdTorus( vec3 p, vec2 t ) {\n        vec2 q = vec2(length(p.xy) - t.x, p.z);\n        return length(q) - t.y;\n    }\n\n    // TODO: document/derive magic number 0.866025\n    // ========================================\n    float sdTriPrism( vec3 p, vec2 h ) {\n        vec3 q = abs(p);\n        return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    }\n// __ Distance Operations _____________________________________\n\n// Basic\n    // Op Union\n    // ========================================\n    float opU( float d1, float d2 ) {\n        return min( d1, d2 );\n    }\n\n    // Op Subtraction\n    // ========================================\n    float opS( float a, float b ) {\n        return max( -b, a ); // BUG in iq's docs: -a, b\n    }\n\n    // Op Intersection\n    // ========================================\n    float opI( float a, float b ) {\n        return max( a, b );\n    }\n\n// Advanced\n    // ========================================\n    float opBlend( float a, float b, float k ) {\n        return sMin( a, b, k );\n    }\n\n    // a angle\n    // ========================================\n    float displacement( vec3 p, float a ) {\n        return sin(a*p.x)*sin(a*p.y)*sin(a*p.z); // NOTE: Replace with your own!\n    }\n\n    // ========================================\n    float opDisplace( vec3 p, float d1, float d2 ) {\n        return d1 + d2;\n    }\n\n    // Op Union Translated\n    // ========================================\n    vec4 opUt( vec4 a, vec4 b, float fts ){\n        vec4 vScaled = vec4(b.x * (fts * 2.0 - 1.0), b.yzw);\n        return mix(a, vScaled, step(vScaled.x, a.x) * step(0.0, fts));\n    }\n\n\n// __ Domain Operations _______________________________________\n\n// NOTE: iq originally inlined the primitive inside the Domain operations. :-(\n// This implied that you would have needed to provide \n// a primitive with one of the sd*() functions above\n// since we can't have a generic pointer to a function!\n// However we have moved them back out to the caller\n// for clarity and flexibility without general loss of precision.\n\n// Basic\n\n    // Op Repetition\n    // ========================================\n    vec3 opRep( vec3 p, vec3 spacing ) {\n        return mod(p,spacing) - 0.5*spacing;\n    }\n\n// Deformations\n\n    // Op Twist X\n    // ========================================\n    vec3 opTwistX( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.x );\n        return   vec3( m*p.yz, p.x );\n    }\n\n    // Op Twist Y\n    // ========================================\n    vec3 opTwistY( vec3 p, float angle ) {\n#if 0 // original\n        float c = cos( angle * p.y );\n        float s = sin( angle * p.y );\n        mat2  m = mat2( c, -s, s, c );\n        vec3  q = vec3( m*p.xz, p.y );\n        // return primitive(q); // BUG in iq's docs, should be: return q\n        return q;\n#else // cleaned up\n        mat2 m = Rot2( angle * p.y );\n        return   vec3( m*p.xz, p.y );\n#endif\n    }\n\n    // Op Twist Z\n    // ========================================\n    vec3 opTwistZ( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.z );\n        return   vec3( m*p.xy, p.z );\n    }\n\n    // iq's bend X\n    // ========================================\n    vec3 opCheapBend( vec3 p, float angle ) {\n#if 0 // original // broken :-(\n        float c = cos( angle * p.y );\n        float s = sin( angle * p.y );\n        mat2  m = mat2( c, -s, s, c );\n        vec3  q = vec3( m*p.xy, p.z ); // BUG in iq's docs, should be: p.yx\n#else\n        mat2  m = Rot2( angle * p.y );\n        vec3  q = vec3( m*p.yx, p.z );\n#endif\n        return q;\n    }\n\n    // Op Cheap Bend X\n    // ========================================\n    vec3 opBendX( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.y );\n        return   vec3( m*p.yx, p.z );\n    }\n\n    // Op Cheap Bend Y\n    // ========================================\n    vec3 opBendY( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.z );\n        return   vec3( m*p.zy, p.x );\n    }\n\n    // Op Cheap Bend Z\n    // ========================================\n    vec3 opBendZ( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.x );\n        return   vec3( m*p.xz, p.y );\n    }\n\n    // d = distance to move\n    // ========================================\n    vec3 opTrans( vec3 p, vec3 d ) {\n        return p - d;\n    }\n\n    // Note: m must already be inverted!\n    // TODO: invert(m) transpose(m)\n    // Op Rotation / Translation\n    // ========================================\n    vec3 opTx( vec3 p, mat4 m ) {   // BUG in iq's docs, should be q\n        return (transpose(m)*vec4(p,1.0)).xyz;\n    }\n\n    // Op Scale\n    // ========================================\n    float opScale( vec3 p, float s ) {\n        return sdBox( p/s, vec3(1.2,0.2,1.0), 0.01 ) * s; // TODO: FIXME: NOTE: replace with primative sd*()\n    }\n\n\n/******************************\n Start here\n******************************/\n\nconst float EPSILON=0.001;\nconst int STEPS=100;\nconst float MAX_DIST=30.;\n\n//Pient st studiossa :D\n\nfloat distFunc(vec3 p, out float material, float t)\n{\n    vec3 op = p;\n    p+=vec3(sin(iTime)*2., 0.,3.);\n    float radius = 0.9;\n//    vec3 rep = opRep(p, vec3(3.1, 3.1, 3.1));\n//    p = mix(rep, p, abs(cos(iTime*0.3)*0.2));\n    p = opTwistZ(p , sin(iTime*0.4)*0.4+0.0);\n    //p = opTwistY(p, cos(iTime*3.)*1.);\n    float height = -2.5;\n    float mp=0.9+sin(iTime)*0.4;\n    float tt = iTime*3.;\n    float ball = sdSphere(p + vec3(sin(tt)*4., cos(tt)*mp+height, .5), radius+sin(tt)*0.4);\n    ball = sMin( ball, sdSphere(p +vec3(sin(tt+0.2)*4., cos(tt+.1)*mp+height, 1.), radius+sin(tt+.4)*0.4),1.5);\n   \tball = sMin( ball, sdSphere(p +vec3(sin(tt+0.4)*4., cos(tt+.2)*mp+height, 1.5),radius+sin(tt+.8)*0.4),2.1);\n   \tball = sMin( ball, sdSphere(p +vec3(sin(tt+0.6)*4., cos(tt+.3)*mp+height, 2.), radius+sin(tt+1.2)*0.4),2.1);\n   \tball = sMin( ball, sdSphere(p +vec3(sin(tt+0.8)*4., cos(tt+.4)*mp+height, 2.5),radius+sin(tt+1.6)*0.4),2.1);\n  \tball = sMin( ball, sdSphere(p +vec3(sin(tt+1.0)*4., cos(tt+.5)*mp+height, 3.), radius+sin(tt+2.)*0.4),2.1);\n    \n    \n    \n   \tfloat ground = sdPlane(op, vec4(0, 1., 0.,2.));\n    \n    vec3 pyrp = op;\n    pyrp -= vec3(0., 0., iTime*5.);\n    pyrp = opRep(pyrp, vec3(4.,0., 4.));\n    float pyramids = sdPyramid4(pyrp+vec3(0.,0.,0), vec3(0.1));\n\t\n//    ball = 0.;\n    \n    \n    material = ball <ground?0.:1.;\n    material = pyramids < material ? 2. : material;\n    float dist = opU(ball, ground);\n    dist = opU(pyramids, dist);\n    \n    if(t < 0.4)\n        dist = 0.4;\n    return dist;\n}\n\nvec3 calcLight(vec3 p, float material, vec3 rd, float t)\n{\n    vec2 eps = vec2(0.0, EPSILON);\n    float m = 0.;\n    float d1 = distFunc(p + eps.yxx,m,t);\n    float d2 = distFunc(p - eps.yxx,m,t);\n\tvec3 normal = normalize(vec3(\n    d1 - d2,\n    distFunc(p + eps.xyx,m,t) - distFunc(p - eps.xyx,m,t),\n    distFunc(p + eps.xxy,m,t) - distFunc(p - eps.xxy,m,t)));\n    vec3 diffuse = vec3(max(0.0, dot(-rd, normal)));\n    \n    if(material < 0.5)\n    {\n     //balls   \n        diffuse*= vec3(1.7, 1.5,1.8);//*abs(sin(t*24.));\n    }\n    else if(material < 1.5)\n    {\n      //ground\n        diffuse *= abs(sin(t*40.+iTime*3.));\n    }\n    else if(material < 2.5)\n    {\n     \t//pyramids\n        diffuse*=vec3(0., 0., 1.);\n    }\n    \n    vec3 specular = pow(diffuse, vec3(32.0));\n    \n\treturn vec3(diffuse + specular);\n}\n\nvec3 setCamera( in vec3 eye, in vec3 target, in vec2 uv )\n{\n    float fov = 1.0;\n\tvec3 forward = normalize( target - eye );\n    vec3 up = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 right = normalize( cross(up,forward));\n\tvec3 raydir = normalize( uv.x*up + uv.y*right + fov*forward );\n\treturn raydir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //Map uv to -1..1 & fix aspect\n    uv*=2.;\n    uv-=1.;\n    uv.x*=iResolution.x/iResolution.y;\n    float time = iTime;\n    \n    vec3 eye = vec3(sin(time)*.1,cos(time*1.)+.5,3.);\n//    eye = vec3(0., 1., 1.);\n    vec3 lookAt =  vec3(cos(time)*3.,cos(time*3.2)*0.3-1.6,sin(time));    \n    lookAt = -eye;\n    lookAt = vec3(0.);\n    vec3 rayDir = setCamera(eye, lookAt, uv);\n    \n    vec3 color = vec3(0.);\n    \n    //Distance counter\n    float t = 0.;\n    vec3 bg = vec3(sin(time)*0.2+1.2, sin(time+0.4)*0.2+1.2, 1.2);\n    bg = vec3(1.1,0.8,0.4);\n    bg*=sin((uv.y+sin(time+uv.x))*20.)*0.3+1.;\n    //March\n    for(int i =0; i<STEPS;i++){\n        vec3 p = rayDir*t+eye;\n        float material = 0.;\n        float dist = distFunc(p,material,t);\n        \n        if(dist < EPSILON )\n        {\n         \tcolor = calcLight(p,material,rayDir, t);   \n            color =mix(color, bg,max(0.,(t-20.)/(MAX_DIST-20.)));\n            break;\n        }\n        if(t > MAX_DIST)\n        {\n         \tcolor = bg;\n         //   color = vec3(1.);\n//            color *= mod(uv.x*uv.y+time*0.2, 0.06)+0.9; \n  //          color *= mod(uv.y+time*0.2, 0.06)+0.9; \n            break;\n        }\n            \n        t += dist;\n    }\n\tfragColor = vec4(color,1.0);\n}\n\n//KOODI EI ILMEISESTI NY? TEEEN REFRESHIN. HETKI", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MstSDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MstSWB", "name": "rising lethe bulbs", "author": "tomaes", "description": "2d design shader with some fake water. ;)", "tags": ["2d", "water", "minimal", "style"], "likes": 1, "viewed": 195, "date": "1461410456", "time_retrieved": "2024-06-20T18:35:21.072829", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float t = iTime * 0.1;   \n    float c = 0.27; //+ sin(t*10.0+uv.y)*0.2; // - uv.y*0.01;\n    float b = sin((uv.y*0.5+t*5.0)*5.0-uv.y*15.0)*(0.05-uv.y*0.24);\n\n    uv.x += mod(uv.x+t,0.04+0.001/uv.y);\n    uv.y += mod(uv.x+t,0.04+0.001/uv.y);\n    \n    // bg stripes\n    if (mod(uv.y,0.1)<0.06)\n        c = 0.38-c + sin(3.14159*uv.x)*0.15 + mod(uv.y,0.05);\n\n    // outter border\n    if (uv.x > 0.38+b && uv.x < 0.63-b)\n        c = uv.y*0.3;  \n    \n    // border\n    if (uv.x > 0.39+b && uv.x < 0.61-b)\n        c = 0.3+uv.y*0.1;  \n    \n    // fill\n    if (uv.x > 0.4-b && uv.x < 0.6+b)\n        //c = 0.5 + mod(uv.y,0.05);\n        c = 0.8-uv.y + mod( sqrt(uv.x*0.05+uv.y*0.05),0.03 ) * 20.0;\n    \n    // middle\n    if (uv.x > 0.497-b && uv.x < 0.503+b)\n    {\n        c = 0.5+uv.x*0.7;\n        \n        if (uv.x > 0.5-b && uv.x < 0.5+b)\n        \tc -= 0.6-distance(uv,vec2(0.5,uv.x+0.3))*0.9;   \n    }\n    \n    fragColor = vec4(c-uv.y*0.2,c-0.04,c*1.16,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MstSWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MstXDX", "name": "Line Grapher", "author": "jackdavenport", "description": "Creates a series of graphs. ", "tags": ["line", "graph"], "likes": 1, "viewed": 121, "date": "1461886400", "time_retrieved": "2024-06-20T18:35:21.072829", "image_code": "#define LINE_WIDTH .1\n\nvoid drawLine(float y, vec2 uv, vec3 color, inout vec3 fc) {\n \n    if(uv.y > y-LINE_WIDTH && uv.y < y+LINE_WIDTH) {\n     \n        fc = color;\n        \n    }\n    \n    fc = clamp(fc, 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord - iResolution.xy * .5 )/ iResolution.y) * 10.;\n\tfloat x = uv.x;\n    float y = 0.;\n    vec3 fc = vec3(0.);\n    \n    //draw background\n    drawLine(0., uv, vec3(.5), fc);\n    //x = .5;\n    //drawLine(x, uv, vec3(.5), fc);\n    //x = uv.x;\n    //finish background\n    \n   \ty = sin(iTime*3.5 + x);\n\tdrawLine(y, uv, vec3(1.), fc);\n    \n    y = cos(iTime*3.5 + x) * 5.;\n    drawLine(y, uv, vec3(1.,0.,0.), fc);\n    \n    y = tan(-iTime + x);\n    drawLine(y, uv, vec3(0.,1.,0.), fc);\n    \n    y = texture(iChannel0, vec2(x,.5+.5*sin(iTime))).r * 2. - 1.;\n    drawLine(y, uv, vec3(0.,1.,1.), fc);\n    \n    //add more here\n    //y = x;\n    //drawLine(y, uv, vec3(1.,1.,0.), fc);\n    \n\tfragColor = vec4(fc,1.);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MstXDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3SDB", "name": "egg yolk twister", "author": "tomaes", "description": "...", "tags": ["2d", "minimal", "style"], "likes": 8, "viewed": 198, "date": "1461145260", "time_retrieved": "2024-06-20T18:35:21.078667", "image_code": "#define PI 3.141592653589793\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float t = iTime * 0.5 + 139.7;\n\n    // moving bg texture\n    vec3 c = vec3( 0.25 + min(sqrt(sin(uv.x*200.0+t*0.5)+cos(uv.y*200.0)),0.7 ),0.5,0.2*abs(0.5-uv.y));\n    \n    float p[8];\n    \n    for(int i = 0; i < 8; i++)\n        p[i] = 0.5 + sin( float(i)*2.0*PI/8.0 + t + sin(2.0*uv.x+t)*2.0)*(0.25+0.2*sin(uv.x+t));\n\t\n    // \"yolk\"\n    for(int i = 1; i < 8; i++)\n        if ((p[i-1]-p[i]) > 0.0 && uv.y < p[i-1] && uv.y > p[i] )\n            //c += 1.5 * vec3(0.8,0.2,0.5-p[i]*2.5);\n        \tc += 1.5 * vec3(0.8,0.2,(p[i-1]-p[i])*uv.y*2.5);\n    \n    // \"arms\"\n    for(int i = 0; i < 8; i++)\n\t\tif (distance(vec2(uv.x,uv.y),vec2(uv.x,p[i])) < 0.05+sin(uv.x*4.0)*0.05)\n        if (mod(uv.x+uv.y,0.1) < 0.01+sin(uv.x+uv.y)*0.1)\n            c = vec3(1.0,1.0,1.0-p[i]*0.25);\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3SDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3SRj", "name": "Voronoi comparison", "author": "mattz", "description": "Why do we want a spherical Voronoi function? Left: traditional 3D Voronoi cells projected onto sphere lead to curvy borders, uneven cell sizes. Right: new method computed directly on the sphere mitigates these issues.", "tags": ["voronoi", "worley", "spherical", "picking", "point"], "likes": 44, "viewed": 1251, "date": "1460137027", "time_retrieved": "2024-06-20T18:35:23.175952", "image_code": "//===============================================================================================\n//\n// Comparison of Voronoi cells on sphere created by \"traditional\" 3D Voronoi with spherical\n// Voronoi. This is a mash-up of two shaders:\n//\n//   left:  \"Voronoi - 3D\" by iq: https://www.shadertoy.com/view/ldl3Dl\n//   right: \"Spherical voronoi\" by mattz: https://www.shadertoy.com/view/MtBGRD\n//\n// Most of the code here comes from iq's original, with some extra bits pasted in to make the\n// latter one work.\n//\n// The left half of the screen is the set of traditional 3D Voronoi boundaries projected onto\n// the sphere. Since the cutting planes beween 3D Voronoi cells are not locally perpendicular\n// to the sphere, they can form curves instead of straight lines on thes sphere's surface. \n// Also since the jittered 3D points are not uniformly distributed on the sphere, the Voronoi\n// cells appear to have an uneven size distribution.\n//\n// The right half of the screen is the spherical Voronoi diagram, which is constructed to \n// combat both problems.\n//\n// Licensed under the MIT License, since iq's original is, too. \n//\n// His code is copyright  2013 Inigo Quilez\n// My additions are copyright  2016 Matt Zucker\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//===============================================================================================\n\nvec3 hash( vec3 x )\n{\n  x = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n            dot(x,vec3(269.5,183.3,246.1)),\n            dot(x,vec3(113.5,271.9,124.6)));\n\n  return fract(sin(x)*43758.5453123);\n}\n\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x, out vec3 p1, out vec3 p2 )\n{\n\n  vec3 p = floor( x );\n  vec3 f = fract( x );\n\n  float id = 0.0;\n  vec2 res = vec2( 100.0 );\n  \n  p1 = vec3(1000.);\n  p2 = p1;\n  \n  for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n      for( int i=-1; i<=1; i++ )\n        {\n          // b is cell with integer coordinates\n          vec3 b = vec3( float(i), float(j), float(k) );\n          vec3 r = vec3( b ) - f + hash( p + b );\n          float d = dot( r, r );\n\n          if( d < res.x )\n            {\n              id = dot( p+b, vec3(1.0,57.0,113.0 ) );\n              res = vec2( d, res.x );\n              p2 = p1;\n              p1 = r;\n            }\n          else if( d < res.y )\n            {\n              res.y = d;\n              p2 = r;\n            }\n        }\n\n  return vec3( sqrt( res ), abs(id) );\n}\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\n/* Try to restrict branching? Don't know if this has any effect... */\n#define RESTRICT_BRANCHING\n\nfloat warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta;\n\nconst float N = 6.0;\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n#ifdef RESTRICT_BRANCHING\n    vec3 s = step(vec3(c), a);\n    s.yz -= vec2(s.x*s.y, (s.x + s.y - s.x*s.y)*s.z);\n#else\n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n#endif\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in vec3 pos, out mat3 PT, out vec2 g) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPT(pos);\n    \n    // Project to cube face\n    vec3 c = pos * PT;     \n    vec2 p = c.xy / c.z;      \n    \n    // Unwarp through arctan function\n    vec2 q = atan(p*tan_warp_theta)/warp_theta; \n    \n    // Map [-1,1] interval to [0,N] interval\n    g = (q*0.5 + 0.5)*N;\n    \n}\n\n\n/* For any grid point on a cube face, along with projection matrix, \n   obtain the 3D point it represents. */\nvec3 gridToPos(in mat3 PT, in vec2 g) {\n    \n    // Map [0,N] to [-1,1]\n    vec2 q = g/N * 2.0 - 1.0;\n    \n    // Warp through tangent function\n    vec2 p = tan(warp_theta*q)/tan_warp_theta;\n\n    // Map back through permutation matrix to place in 3D.\n    return PT * vec3(p, 1.0);\n    \n}\n\n\n/* Return whether a neighbor can be identified for a particular grid cell.\n   We do not allow moves that wrap more than one face. For example, the \n   bottom-left corner (0,0) on the +X face may get stepped by (-1,0) to \n   end up on the -Y face, or, stepped by (0,-1) to end up on the -Z face, \n   but we do not allow the motion (-1,-1) from that spot. If a neighbor is \n   found, the permutation/projection matrix and grid coordinates of the \n   neighbor are computed.\n*/\nbool gridNeighbor(in mat3 PT, in vec2 g, in vec2 delta, out mat3 PTn, out vec2 gn) {\n\n    vec2 g_dst = g.xy + delta;\n    vec2 g_dst_clamp = clamp(g_dst, 0.0, N);\n\n    vec2 extra = abs(g_dst_clamp - g_dst);\n    float esum = extra.x + extra.y;\n \n#ifdef RESTRICT_BRANCHING    \n        \n    vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n    PTn = getPT(pos);\n    gn = ((pos*PTn).xy*0.5 + 0.5) * N;\n    \n    return min(extra.x, extra.y) == 0.0 && esum < N;\n    \n#else\n    \n    if (max(extra.x, extra.y) == 0.0) {\n        PTn = PT;\n        gn = g_dst;\n        return true;\n    } else if (min(extra.x, extra.y) == 0.0 && esum < N) {\n        // Magic stuff happens here.\n        vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n        PTn = getPT(pos);\n        gn = ((pos * PTn).xy*0.5 + 0.5) * N;\n        return true;\t        \n    } else {\n        return false;\n    }\n    \n#endif\n\n}\n\n/* From https://www.shadertoy.com/view/Xd23Dh */\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n                  dot(p,vec2(269.5,183.3)), \n                  dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot(normalize(a),normalize(b));\n}\n\n\n/* Just used to visualize distance from spherical Voronoi cell edges. */\nfloat bisectorDistance(vec3 p, vec3 a, vec3 b) {\n    vec3 n1 = cross(a,b);\n    vec3 n2 = normalize(cross(n1, 0.5*(normalize(a)+normalize(b))));\n    return abs(dot(p, n2));             \n}\n\n/* Color the sphere/cube points. */\nvec3 gcolor(vec3 pos) {\n\n    mat3 PT;\n    vec2 g;\n\n    // Get grid coords\n    posToGrid(pos, PT, g);\n    \n    // Snap to cube face - note only needed for visualization.\n    pos /= dot(pos, PT[2]);\n\n    const float farval = 1e5;\n    \n    // Distances/colors/points for Voronoi\n    float d1 = farval;\n    float d2 = farval;\n\n    float m1 = -1.0;\n    float m2 = -1.0;\n\n    vec3 p1 = vec3(0);\n    vec3 p2 = vec3(0);\n\n\t// For drawing grid lines below\n    vec2 l = abs(fract(g+0.5)-0.5);\n\n    // Move to center of grid cell for neighbor calculation below.\n    g = floor(g) + 0.5;\n\n    // For each potential neighbor\n    for (float u=-1.0; u<=1.0; ++u) {\n        for (float v=-1.0; v<=1.0; ++v) {\n            \n            vec2 gn;\n            mat3 PTn;\n\n            // If neighbor exists\n            if (gridNeighbor(PT, g, vec2(u,v), PTn, gn)) {\n                \n                float face = dot(PTn[2], vec3(1.,2.,3.));\n                \n                // Perturb based on grid cell ID\n                gn = floor(gn);\n                vec3 rn = hash3(gn*0.123 + face);\n                gn += 0.5 + (rn.xy * 2.0 - 1.0)*1.0*0.5;\n\n                // Get the 3D position\n                vec3 pos_n = gridToPos(PTn, gn);\n                \n                // Compute squared distance on sphere\n                float dp = sphereDist2(pos, pos_n);\n                \n                // See if new closest point (or second closest)\n                if (dp < d1) {\n                    d2 = d1; p2 = p1;\n                    d1 = dp; p1 = pos_n;\n                } else if (dp < d2) {\n                    d2 = dp; p2 = pos_n;\n                }\n                \n            }\n        }\n    }\n\n    vec3 c = vec3(1.0);\n\n    // voronoi lines    \n    c = mix(c, vec3(0.0),\n            smoothstep(0.01, 0.005, bisectorDistance(pos, p2, p1)));\n\n    // goodbye\n    return c;\n\n}\n\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n  // camera movement\n  const float twopi = 6.283185307179586;\n  float an = iTime*twopi/12.0;\n  vec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n  vec3 ta = vec3( 0.0, 1.0, 0.0 );\n  // camera matrix\n  vec3 ww = normalize( ta - ro );\n  vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  // create view ray\n  vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n  // sphere center\t\n  vec3 sc = vec3(0.0,1.0,0.0);\n    \n  tan_warp_theta = tan(warp_theta);\n\n\n  // raytrace\n  float tmin = 10000.0;\n  vec3  nor = vec3(0.0);\n  float occ = 1.0;\n  vec3  pos = vec3(0.0);\n\t\n  // raytrace-plane\n  float h = (0.0-ro.y)/rd.y;\n  if( h>0.0 ) \n    { \n      tmin = h; \n      nor = vec3(0.0,1.0,0.0); \n      pos = ro + h*rd;\n      vec3 di = sc - pos;\n      float l = length(di);\n      occ = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n    }\n\n  // raytrace-sphere\n  vec3  ce = ro - sc;\n  float b = dot( rd, ce );\n  float c = dot( ce, ce ) - 1.0;\n  h = b*b - c;\n  if( h>0.0 )\n    {\n      h = -b - sqrt(h);\n      if( h<tmin ) \n        { \n          tmin=h; \n          nor = normalize(ro+h*rd-sc); \n          occ = 0.5 + 0.5*nor.y;\n        }\n    }\n\n  // shading/lighting\t\n  vec3 col = vec3(0.9);\n  if( tmin<100.0 ) \n    {\n      pos = ro + tmin*rd;\n\n      vec3 pv = 4.0*pos;\n      float f = 1.0;\n      if (h == tmin) {\n\n        if (p.x >= 0.0) {\n          f = gcolor(pos-sc).x;\n        } else {\n          vec3 p1, p2;\n          vec3 v = voronoi( pv, p1, p2 );\n          \n          vec3 pm = 0.5*(p1+p2);\n          vec3 n = normalize(p2-p1);\n          vec3 np = normalize(pos-sc);\n          float d = abs(dot(pm, n));\n          float cos_theta = dot(n, np); \n          float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n          f = smoothstep(0.005, 0.01, 0.28*d/sin_theta);\n        }\n        \n      } else {\n\n        f = 0.4;\n\n      }\n\n\t\t\n      f *= occ;\n      col = vec3(f*1.2);\n      col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n    }\n\t\n  col = sqrt( col );\n  col *= step(1.0/640.0, abs(fragCoord.x - 0.5*iResolution.x)/iResolution.x);\n\t\n\t\n  fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3SRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3XDS", "name": "Smooth Triplanar Mapping", "author": "Xor", "description": "Here is a simple example of how you might apply texture mapping in a shader. This also includes bumpmapping and reflections.", "tags": ["3d", "texture", "triplanar", "bumpmapping"], "likes": 37, "viewed": 1527, "date": "1461167815", "time_retrieved": "2024-06-20T18:35:23.175952", "image_code": "vec3 LIGHT = normalize(vec3(-0.2,-0.5,-0.8));\n\nfloat MAX = 120.0;\nfloat PRE = 0.01;\n#define T iTime/8.0\n\n#define Smooth\n\n//One-dimensional white noise\nfloat n1(float n)\n{\n \treturn fract(cos(n*42.52)*251.62);\n}\n//Three-dimensional white noise\nfloat n1(vec3 n)\n{\n    vec3 s = vec3(42.52,51.98,56.72);\n \treturn fract(cos(dot(n,s))*251.62);\n}\n//Three-dimensional perlin\nfloat p1(vec3 n)\n{\n\tvec3 fn = floor(n);\n    vec3 sn = n-fn;\n    sn *= sn*(3.-2.*sn);\n    \n    const vec2 o = vec2(0,1);\n    \n    float h1 = mix(n1(fn+o.xxx),n1(fn+o.yxx),sn.x);\n    float h2 = mix(n1(fn+o.xyx),n1(fn+o.yyx),sn.x);\n    float s1 = mix(h1,h2,sn.y);\n    \n    h1 = mix(n1(fn+o.xxy),n1(fn+o.yxy),sn.x);\n    h2 = mix(n1(fn+o.xyy),n1(fn+o.yyy),sn.x);\n    float s2 = mix(h1,h2,sn.y);\n    \n    return mix(s1,s2,sn.z);\n}\n//Tri-linear Texturing Function\nvec3 t3(sampler2D tex, vec3 p, vec3 n)\n{\n    mat3 R = mat3(vec3(cos(T),sin(T),0),vec3(-sin(T),cos(T),0),vec3(0,0,-1));\n    p *= R/8.0;\n    n *= R;\n    #ifdef Smooth\n \treturn  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n    #else\n    return (texture(tex,p.xy).rgb\n           +texture(tex,p.zy).rgb\n           +texture(tex,p.xz).rgb)/3.0;\n    #endif\n}\n//Main Distance Field Function\nfloat model(vec3 p)\n{   \n    float S = length(p)-12.0;\n    return S;\n}\n//Simple Raymarcher\nvec4 raymarch(vec3 p, vec3 d)\n{\n    float S = 0.0;\n    float L = S;\n    vec3 D = normalize(d);\n    vec3 P = p+D*S;\n    for(int i = 0;i<240;i++)\n    {\n        S = model(P);\n        L += S;\n        P += D*S;\n        if ((L>MAX) || (S<PRE)) {break;}\n    }\n    return vec4(P,min(L/MAX,1.0));\n}\n//Normal Function\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * PRE;\n\n \tvec3 N = normalize(model(p+P.xyy)*P.xyy+model(p+P.yxy)*P.yxy+\n                  model(p+P.yyx)*P.yyx+model(p+P.xxx)*P.xxx);\n    \n    vec3 B = vec3(t3(iChannel0,p+P.xzz,N).r,t3(iChannel0,p+P.zxz,N).r,\n                  t3(iChannel0,p+P.zzx,N).r)-t3(iChannel0,p,N).r;\n    B = (B-N*dot(B,N));\n    return normalize(N+B*8.0);\n}\n//Sky\nvec3 sky(vec3 d)\n{\n    vec3 M = vec3(T*0.9,T*0.1,0);\n    float S = 0.7+dot(d,LIGHT)*0.3;\n    float C = p1(d*4.0+M)*p1(d*7.0+M)*(p1(d*13.0+M)*0.6+p1(d*25.0+M)*0.4);\n \treturn mix(vec3(0.2,0.6,0.9),vec3(1,1,1),pow(S,64.0))*(S*0.5+0.5)+C;\n}\n//Color/Material Function\nvec3 color(vec3 p, vec3 d)\n{\n    vec3 N = normal(p);\n    vec3 C = smoothstep(vec3(.2),vec3(.7),t3(iChannel0,p,N).rgb);\n \tfloat L = max(dot(N,LIGHT),.1);\n    float R = smoothstep(.5,.0,-dot(N,d))*.5;\n    return mix(C*L,sky(reflect(d,N)),R);\n}\n//Camera Variables\nvoid camera(out vec3 P,out vec3 D, out vec3 X, out vec3 Y, out vec3 Z)\n{\n\tfloat M = float((iMouse.x+iMouse.y)>0.0);\n\tvec2 A = (0.5-iMouse.xy/iResolution.xy)*vec2(6.2831,3.1416);\n\tP = 32.0*mix(vec3(1,0,0),vec3(cos(-A.x)*cos(A.y),sin(-A.x)*cos(A.y),sin(A.y)),M);\n\n\tD = -P;\n\n\tX = normalize(D);\n\tY = normalize(cross(X,vec3(0,0,1)));\n\tZ = cross(X,Y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P,D,X,Y,Z;\n    camera(P,D,X,Y,Z);\n\tvec2 UV = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    D = normalize(mat3(X,Y,Z) * vec3(1.0,UV));\n    \n    vec4 M = raymarch(P,D);\n    float fog = M.w*M.w;\n    vec3 COL = mix(color(M.xyz,D),sky(D),fog);\n\tfragColor = vec4(COL,1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3XDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3XWS", "name": "Rainbow Spiral", "author": "vox", "description": "Rainbow Spiral", "tags": ["rainbowspiral"], "likes": 11, "viewed": 952, "date": "1461059497", "time_retrieved": "2024-06-20T18:35:23.175952", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time (float(__LINE__)+iTime/PI)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 stair(vec2 x)\n{\n    return vec2(stair(x.x), stair(x.y));\n}\n\n\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec4 spiral(vec4 uv)\n{\n    //uv = normalize(uv)*log(length(uv)+1.0);\n    float r = log(length(uv)+1.0)*2.0*PI;\n    float theta = mod((atan(uv.y, uv.x)+r), 2.0*PI);\n    \n    return vec4(saw(r), saw(theta),\n               \tr, theta);\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5*uv.x;\n\telse\n\t\treturn 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 uv = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    float amplitude = 32.0;\n    float scale = pow(E, saw(time)*amplitude);\n    uv.xy *= scale;\n    uv.xy -= scale/2.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n    \n\tconst int max_iterations = 1;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv = spiral(uv);\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        map += (uv.z+uv.w);\n    }\n    \n    fragColor.rg = saw(uv.zw);//saw(uv.zw*PI);\n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    \n    \n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);\n    \n    return;\n/*\n\tconst int max_iterations = 8;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        noise += clamp(1.0-fwidth(map), 0.0, 1.0);\n        \n        uv = tree(uv); \n        \n        map += square(uv, float(i)/float(max_iterations))/noise;\n    } \n    map = map*PI + time;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3XWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcSRf", "name": "BW Pattern wave", "author": "mrvux", "description": "First shader here, simple convoluted sine functions.\nLittle rework of an old 1kb never released demo, so made a two tweet version :)", "tags": ["sine", "pattern"], "likes": 3, "viewed": 128, "date": "1460475577", "time_retrieved": "2024-06-20T18:35:23.175952", "image_code": "void mainImage(out vec4 r,in vec2 v)\n{\n\tvec2 u=v/iResolution.xy,h=u-.5;\n    h.x*=1.8;\n    float t=iTime,s=clamp(sin(t),.1,.9),c=sin(u.x*99.0);\n    c+=mix(cos(u.y*50.0+t*.2),c,s);\n    c*=mix(cos(c+dot(h,h)*.7+t*.2),c,clamp(cos(t*.8),.1,.5));\n\tc*=mix(sin(dot(h,h)),c,s*s);\n\tc=pow(c,.8);\n    r=vec4(c,c,c,c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcSRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcSWS", "name": "SoundParticles", "author": "chazbg", "description": "Scale and transform particles based on the low frequency sound value", "tags": ["sound", "particles"], "likes": 0, "viewed": 510, "date": "1461057701", "time_retrieved": "2024-06-20T18:35:23.175952", "image_code": "vec3 drawCircle(vec2 pos, float r, vec3 color, vec2 uv)\n{\n    float t = r - length(uv - pos);\n    return mix(vec3(0), color, smoothstep(0.0, 0.08, t)); \n}\n\nfloat rand(float val, float seed){\n\treturn cos(val*sin(val*seed)*seed);\t\n}\n\nvec2 getParticlePos(float t, float phase, float freq, float r)\n{\n    float time = (t + phase) * freq;\n    return vec2(sin(time), cos(time)) * r / 2.0 + 0.5;\n}\n     \nvec3 drawParticle(vec2 pos, vec3 color, float time, float timelength)\n{\n\tvec3 col= vec3(0.0);\n    float seed = 1.0;\n    vec2 pp = vec2(1.0,0.0);\n    for(float i=1.0;i<=128.0;i++){\n        float d=rand(i, seed);\n        float fade=(i/128.0)*time;\n        vec2 particpos = vec2(0.5) + time*pp*d;\n        //pp = rr*pp;\n        col = mix(color/fade, col, smoothstep(0.0, 0.0001, 0.1 - length(particpos - pos)));\n    }\n    col*=smoothstep(0.0,1.0,(timelength-time)/timelength);\n\t\n    return col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bass = texture(iChannel0, vec2(0, 0)).y;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.5;\n\n    fragColor = vec4(0,0,0,1);\n\tfragColor += vec4(drawCircle(getParticlePos(iTime, 0.0 + 0.3 * bass, 0.75, 0.2), 0.12 * bass, vec3(0.1, 0.5, 0.2), uv),1.0);\n    fragColor += vec4(drawCircle(getParticlePos(iTime, 0.4 + 0.3 * bass, 0.5 , 0.5), 0.17 * bass, vec3(0.1, 0.5, 0.2), uv),1.0);\n    fragColor += vec4(drawCircle(getParticlePos(iTime, 0.8 + 0.3 * bass, 0.25, 0.7), 0.15 * bass, vec3(0.1, 0.5, 0.2), uv),1.0);\n    fragColor += vec4(drawCircle(getParticlePos(iTime, 1.2 + 0.3 * bass, 0.40, 0.8), 0.10 * bass, vec3(0.1, 0.5, 0.2), uv),1.0);\n\tfragColor += vec4(drawParticle(uv, vec3(0.1, 0.5, 0.2), mod(iTime, 3.0), 2.0), 1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcSzs", "name": "ChessField", "author": "greg_o", "description": "Chess field shader", "tags": ["chessfield"], "likes": 2, "viewed": 164, "date": "1460761949", "time_retrieved": "2024-06-20T18:35:23.436531", "image_code": "vec3 calcColor(vec3 ambient, vec3 view, vec3 normal, vec3 light,float lightintensity){\nambient *= 0.2;\n\nvec3 nview = normalize(view);\nvec3 nnormal = normalize(normal);\nvec3 nlight = normalize(light);\nvec3 nhalf = normalize(nview+nlight);\nvec3 reflected = reflect(nnormal*-1.0,nlight);\n\t\nreturn ambient+(max(dot(nnormal,nlight),0.0)*0.6+0.3*pow(max(dot(reflected,nview),0.0),2.0))*lightintensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 1.0 + vec2(-0.5, -0.5);\n\n    vec3 chessBlack= vec3(0.2, 0.23, 0.3); \n    vec3 chessWhite = vec3(0.93, 0.9, 0.98); \n    vec3 pixel; \n    \n    \n    if(uv.y > -0.1){\n    \tpixel = vec3(smoothstep(-0.1, 1., uv.y))*0.2+ 0.8;\n    }\n    else{\n    \n        float de = 0.5;\n        float scale = 0.4;\n        float speed = 0.1;\n        vec2 textCoord = vec2( uv.x / uv.y , de/uv.y) * scale - vec2(0.0, (iTime * speed));\n        float cube = sign((mod(textCoord.x,0.1) - 0.05) * (mod(textCoord.y,0.1) - 0.05));\n        if(0.0 < cube) {\n        pixel = chessBlack; \n        } else{ \n        pixel = chessWhite; \n        }\n        vec3 nd = vec3(0.,0.,0.);\n        if(abs(cube) < 0.1){\n        \tnd + vec3(1.0,1.0, 1.0);\n        }\n        pixel = calcColor(pixel, vec3(textCoord.x, -1.0, textCoord.y) + nd, vec3(0.0 + (uv.x / uv.y)*2.0 ,1.0,0.0), vec3(0.0, 1.53, 2.0- (iTime * speed)) , length(textCoord)/3. );\n\t\t\n    }\n    \n    fragColor = vec4(vec3(pixel), 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcSzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcXDS", "name": "RM Study : Convergence S vs T", "author": "aiekick", "description": "clcik with mouse to see in yellow the var S and in violet the var T. (x axis is the iteration, y axis is the value)\nthe label in top left is the iteration before break\nthe two curve has not the same scaled\n", "tags": ["d", "rm", "study", "convergence", "s", "vs"], "likes": 4, "viewed": 511, "date": "1461091170", "time_retrieved": "2024-06-20T18:35:24.157821", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec2 ballParams = vec2(4.78, 4.5);\n\n#define break_condition 0.01*log(t*t/s/1e4)\n#define curve1_var s\n#define curve2_var log(t*t/s)\n\n#define MAX_DISTANCE 20.\n/////////////////////////\n// GLSL Number Printing - @P_Malin (CCO 1.0)=> https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x){\n    if(x==0) return 480599.0; if(x==1) return 139810.0; if(x==2) return 476951.0; if(x==3) return 476999.0;\tif(x==4) return 350020.0; \n    if(x==5) return 464711.0; if(x==6) return 464727.0; if(x==7) return 476228.0; if(x==8) return 481111.0; if(x==9) return 481095.0; \n    return 0.0;}\nfloat PrintValue(vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces){\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n            if((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;} \n        else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;} \n            else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));} } }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));}\nvec3 WriteValueToScreenAtPos(vec2 fragCoord, float vValue, vec2 vPixelCoord, vec3 vColour, vec2 vFontSize, float vDigits, float vDecimalPlaces, vec3 vColor){\n    float num = PrintValue(fragCoord, vPixelCoord, vFontSize, vValue, vDigits, vDecimalPlaces);\n    return mix( vColour, vColor, num);}\n\n/////////////////////////////////////////////////////////////////\n\nvec4 displ(vec3 p)\n{\n    vec2 g = p.xz;\n    vec3 col =  texture(iChannel0, g+iTime*0.1).rrr;\n   \tcol = clamp(col, 0., 1.);\n    float dist = dot(col,vec3(0.11));\n    return vec4(dist,col);\n}\n\nfloat df(vec3 p)\n{\n    vec4 disp1 = displ(p*0.07); // 0.1 ca merde 0.11 ca marche....\n    float m = length(p);\n    float me = m - ballParams.x + disp1.x;\n    float mi = m - ballParams.y - disp1.x;\n    return max(-mi, me);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uvn = fragCoord/si*vec2(1.,20.);\n\tvec2 g = fragCoord;\n    if (iMouse.z > 0.)\n\t\tg = iMouse.xy;\n\t\n\tvec2 uv = (g+g-si)/min(si.x, si.y);\n\tfloat d = 1.88;\n\tfloat a = iTime;\n\tfloat e = 10.52;\n    vec3 ro = vec3(cos(a)*d,e, sin(a)*d);\n\n    vec3 cu = vec3(0,1,0);\n    vec3 co = vec3(0);\n\t\n\tfloat fov = 0.5;\n\tvec3 z = normalize(co - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * uv.x * x + fov * uv.y * y);\n\t\n\tfloat s = 1., so = 1.;;\n\tfloat t = 0.0;\n\tvec3 p = ro;\n\t\n\tfloat c = 0.;\n\tvec3 curve0 = vec3(0);\n\tvec3 curve1 = vec3(0);\n    vec3 curve2 = vec3(0);\n    float outStep = 0.;\n\tfor (float i=0.; i< 950.; i++)\n\t{\n\t\tif (iMouse.z > 0. && abs(fragCoord.x - i) < 1.)\n\t\t{\n\t\t\tcurve0 += 0.048 * vec3(1,1,0) / length(uvn.y - curve1_var);\n\t\t\tcurve1 += 0.048 * vec3(0.48,0,0.48) / length(uvn.y - curve2_var);\n            if(t>MAX_DISTANCE)\n            \tcurve2 += 0.2 * vec3(0,0,1) / uvn.x;\n            else if(s < break_condition)\n            \tcurve2 += 0.2 * vec3(1,0,1) / uvn.x;\n        }\n\t\tif (s < break_condition || t > MAX_DISTANCE ) break;\n\t\ts = df(p);\n        s *= (s>so?2.:1.);so=s; // Enhanced Sphere Tracing => lgdv.cs.fau.de/get/2234 \n\t\tt += s * 0.2;\n\t\tp = ro + rd * t;\n\t\toutStep++;\n\t}\n\tif (iMouse.z > 0.)\n    {\t\n        fragColor = vec4(curve0 + curve1 + curve2,1);\n    \tfragColor.rgb = WriteValueToScreenAtPos(fragCoord, outStep, vec2(20,si.y-20.), \n                                                fragColor.rgb, vec2(12.0, 15.0), 1., 0., vec3(0.9));\n    }\n\telse\n\t\tfragColor = vec4(nor(p,s), 1);\n\t\t\n\t\t\n\t\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcXDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcXRf", "name": "Oh dear.....", "author": "akohdr", "description": "silliness....might be fun as a texture.\nOriginal implementation highlighted compilation limitations of using deep nested macros.\n", "tags": ["retro", "text", "fun", "word", "characters", "vic20"], "likes": 2, "viewed": 367, "date": "1460500833", "time_retrieved": "2024-06-20T18:35:26.830715", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Started off as a thought exercise for fast font system ...\n// .... then old memories crept in and an hour was lost :)\n\n// Irony is source is larger than VIC-20 RAM ?!!! ROFL\n\n// Originally implemented with cascaded macros much shorter <3000 chars\n// unfortunately unbearably slow to compile and publish and wouldn't work on iPhone\n\n#define BLU vec4(.0,.0,.7,1.)\n#define CYN vec4(.3,.8,.7,1.)\n#define WHT vec4(1)\n\n//<<<<<<<<<<<<<<<<<<<  UNCOMMENT for compile ERRORS\n// for those getting compilation errors uncomment this\n//  (you will loose everything but asterisk working on it...... )\n//#define LOW_MEMORY\n#define VDU_NOISE\n\n\n\n// Just enough to mockup screen, feel free to finish it, emulator in a shader anyone?\n\n// Using ASCII although if memory serves ye olde VIC-20 wasn't ASCII\n\n#define  s_ 32.\n#define  a_ 42.\n#define  d_ 46.\n#define n2_ 50.\n#define n3_ 51.\n#define n5_ 53.\n#define n8_ 56.\n#define  A_ 65.\n#define  B_ 66.\n#define  C_ 67.\n#define  D_ 68.\n#define  E_ 69.\n#define  F_ 70.\n#define  I_ 73.\n#define  M_ 77.\n#define  R_ 82.\n#define  S_ 83.\n#define  T_ 84.\n#define  V_ 86.\n#define  Y_ 89.\n\n// workaround for lack of arrays until GLSL 3\nbool bitIndex(float i,int a,int b,int c,int d,int e,int f,int g,int h)\n{\n    if(i<1.) return a>0;\n    else if(i<2.) return b>0;\n    else if(i<3.) return c>0;\n    else if(i<4.) return d>0;\n    else if(i<5.) return e>0;\n    else if(i<6.) return f>0;\n    else if(i<7.) return g>0;\n    return h>0;\n}\n\n// alternatively we can lean on mod masks.....  (why did it take till GLSL3 for bit ops?)\n\n/*\n\tWe can use exp2()\n// pow() has significant issues on iPad\n// quick dirty impl. provides integer powers of 2 up to 2^8\nfloat pow2_8(float p) {\n    if(p<1.) return 1.;\n    if(p<2.) return 2.;\n    if(p<3.) return 4.;\n    if(p<4.) return 8.;\n    if(p<5.) return 16.;\n    if(p<6.) return 32.;\n    if(p<7.) return 64.;\n    if(p<8.) return 128.;\n}\n*/\n\n\n// digit value from value v at column i (one based) under base b\nfloat modMask(lowp float v, lowp float i, lowp float b) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = pow(b,f-1.);\n    return (mod(v,pow(b,f))-mod(v,p1))/p1;\n}\n#define hexDigit(v,i) modMask(v,i,16.)\n//#define binDigit(v,i) modMask(v,i,2.)\n#define decDigit(v,i) modMask(v,i,10.)\n\n// fix for binDigit which was failing on iPad due to issues with pow()\nfloat binDigit(lowp float v, lowp float i) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = exp2(f-1.);\n    return (mod(v,exp2(f))-mod(v,p1))/p1;\n}\n\n// masks are input in reverse order and need index first for #define currying\nbool glyphMask(float x, float v) {\n    float f = 8.-floor(x),\n          p1 = pow(10.,f-1.),\n          m0 = mod(v,pow(10.,f)),\n          m1 = mod(v,p1);\n    return (m0-m1)/p1>.1;\n}\n\n// Turns out dangling static macros work fine (poor man's currying)\n#define MASK_1      if(y<=1.) glyphMaskY(b,h,y,0.5,x,\n#define MASK_2 else if(y<=2.) glyphMaskY(b,h,y,1.5,x,\n#define MASK_3 else if(y<=3.) glyphMaskY(b,h,y,2.5,x,\n#define MASK_4 else if(y<=4.) glyphMaskY(b,h,y,3.5,x,\n#define MASK_5 else if(y<=5.) glyphMaskY(b,h,y,4.5,x,\n#define MASK_6 else if(y<=6.) glyphMaskY(b,h,y,5.5,x,\n#define MASK_7 else if(y<=7.) glyphMaskY(b,h,y,6.5,x,\n#define MASK_8 else if(y<=8.) glyphMaskY(b,h,y,7.5,x,\n#define MASK_END return decDigit(b,y+1.)>.0;\n\n#define BITS_1      if(y<1.) return bitIndex(x,\n#define BITS_2 else if(y<2.) return bitIndex(x,\n#define BITS_3 else if(y<3.) return bitIndex(x,\n#define BITS_4 else if(y<4.) return bitIndex(x,\n#define BITS_5 else if(y<5.) return bitIndex(x,\n#define BITS_6 else if(y<6.) return bitIndex(x,\n#define BITS_7 else if(y<7.) return bitIndex(x,\n#define BITS_8 else if(y<8.) return bitIndex(x,\n\nvoid glyphMaskY(inout float b, float hmm, float y, float l, float x, float v) {\n\n    float a = abs(y-l);\n    \n    if(a<.5+hmm) {\n        \n        float f = 8.-floor(x+hmm),\n              p1 = pow(10.,f-1.),\n              m0 = mod(v,pow(10.,f)),\n              m1 = mod(v,p1);\n        b += pow(10.,y)*((m0-m1)/p1>.5 ? 1. : 0.);\n    }\n}\n\n// Nasty cascaded if impl.\n// makes for quick rendering after it eventually compiles\nbool glyph(const in vec4 p) {\n    float ch = p.w;\n    if((ch - s_)<.4) return false; //space\n\n    vec2 sl = mod(p.xy,8.);\n    float x = sl.x-1.05,   //used by macros\n          y = sl.y,\n\t\t  b = 0.;\n    \n    // OMG I think I inadvertently figured out why VIC-20 had wonky pixels(!)\n\t// likely artifacts of mains noise on comparator(s) in the rasterizer and demodulator\n    // tweak this for sub-pixel VDU effect  (US mains hum 60hz, UK 50hz)\n    // (could likely take it further with main noise bias in colour channels and interlacing)\n#ifdef  VDU_NOISE\n    float h = .07*(.3+abs(.3*sin(iTime)))*sin(50.*iTime);\n#else\n    float h = 0.;\n#endif\n/*\n    if((ch - a_)<1.){\n        glyphMaskY(b,h,y,0.5,x,00001000.);\n        glyphMaskY(b,h,y,1.5,x,00101010.);\n        glyphMaskY(b,h,y,2.5,x,00011100.);\n        glyphMaskY(b,h,y,3.5,x,00111110.);\n        glyphMaskY(b,h,y,4.5,x,00011100.);\n        glyphMaskY(b,h,y,5.5,x,00101010.);\n        glyphMaskY(b,h,y,6.5,x,00001000.);\n        glyphMaskY(b,h,y,7.5,x,00000000.);\n        return modMask(b,y+1.)>.0;\n    }\n*/\n/*\n    if((ch - a_)<1.){\n             if(y<1.) return glyphMask(x, 00001000.);\n        else if(y<2.) return glyphMask(x, 00101010.);\n        else if(y<3.) return glyphMask(x, 00011100.);\n        else if(y<4.) return glyphMask(x, 00011100.);\n        else if(y<5.) return glyphMask(x, 00011100.);\n        else if(y<6.) return glyphMask(x, 00101010.);\n        else if(y<7.) return glyphMask(x, 00001000.);\n        else if(y<8.) return glyphMask(x, 00000000.);\n    }\n*/    \n\n#ifdef LOW_MEMORY\n    #define  a_00101010 a_\n    if((ch - a_00101010)<.1){\n        MASK_1 00001000.);\n        MASK_2 00101010.);\n        MASK_3 00011100.);\n        MASK_4 00111110.);\n        MASK_5 00011100.);\n        MASK_6 00101010.);\n        MASK_7 00001000.);\n        MASK_8 00000000.);\n        MASK_END\n                        }\n#else\n\t// OK lets see if we can help out the compiler\n    // try (partial) red/black tree on value of ch\n    if(binDigit(ch,1.)<1.)   // fails on iPad ?! FIX: pow() has issues on iPad see binDigit()\n    {\n        if(binDigit(ch,2.)<1.) \n        {\n            #define n8_00111000 n8_\n            if((ch - n8_00111000)<.1){\n                MASK_1 00111100.);\n                MASK_2 01000010.);\n                MASK_3 01000010.);\n                MASK_4 00111100.);\n                MASK_5 01000010.);\n                MASK_6 01000010.);\n                MASK_7 00111100.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  D_01000100 D_\n            if((ch - D_01000100)<.1){\n                MASK_1 11110000.);\n                MASK_2 01001000.);\n                MASK_3 01000100.);\n                MASK_4 01000100.);\n                MASK_5 01000100.);\n                MASK_6 01001000.);\n                MASK_7 11110000.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  T_01010100 T_\n            if((ch - T_01010100)<.1){\n                MASK_1 01111100.);\n                MASK_2 00010000.);\n                MASK_3 00010000.);\n                MASK_4 00010000.);\n                MASK_5 00010000.);\n                MASK_6 00010000.);\n                MASK_7 00010000.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n        } \n        else \n        { //2\n            if(binDigit(ch,3.)<1.) \n            {\n                #define  a_00101010 a_\n                if((ch - a_00101010)<.1){\n                    MASK_1 00001000.);\n                    MASK_2 00101010.);\n                    MASK_3 00011100.);\n                    MASK_4 00111110.);\n                    MASK_5 00011100.);\n                    MASK_6 00101010.);\n                    MASK_7 00001000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define n2_00110010 n2_\n                if((ch - n2_00110010)<.1){\n                    MASK_1 00111100.);\n                    MASK_2 01000010.);\n                    MASK_3 00000010.);\n                    MASK_4 00001100.);\n                    MASK_5 00110000.);\n                    MASK_6 01000000.);\n                    MASK_7 01111110.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  B_01000010 B_\n                if((ch - B_01000010)<.1){\n                    MASK_1 11111000.);\n                    MASK_2 01000100.);\n                    MASK_3 01000100.);\n                    MASK_4 01111000.);\n                    MASK_5 01000100.);\n                    MASK_6 01000100.);\n                    MASK_7 11111000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  R_01010010 R_\n                if((ch - R_01010010)<.1){\n                    MASK_1 01111100.);\n                    MASK_2 01000010.);\n                    MASK_3 01000010.);\n                    MASK_4 01111100.);\n                    MASK_5 01001000.);\n                    MASK_6 01000100.);\n                    MASK_7 01000010.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            } \n            else \n            {//3\n                #define  d_00101110 d_\n                if((ch - d_00101110)<.1){\n                    MASK_1 00000000.);\n                    MASK_2 00000000.);\n                    MASK_3 00000000.);\n                    MASK_4 00000000.);\n                    MASK_5 00000000.);\n                    MASK_6 00011000.);\n                    MASK_7 00011000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  F_01000110 F_\n                if((ch - F_01000110)<.1){\n                    MASK_1 01111110.);\n                    MASK_2 01000000.);\n                    MASK_3 01000000.);\n                    MASK_4 01111000.);\n                    MASK_5 01000000.);\n                    MASK_6 01000000.);\n                    MASK_7 01000000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  V_01010110 V_\n                if((ch - V_01010110)<.1){\n                    MASK_1 01000010.);\n                    MASK_2 01000010.);\n                    MASK_3 01000010.);\n                    MASK_4 01000010.);\n                    MASK_5 00100100.);\n                    MASK_6 00100100.);\n                    MASK_7 00011000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            }\n        }\n    } \n    else // 1\n    {\n        if(binDigit(ch,2.)<1.) \n        {\n            if(binDigit(ch,3.)<1.) \n            {\n                #define  A_01000001 A_\n                if((ch - A_01000001)<.1){\n                    MASK_1 00011000.);\n                    MASK_2 00100100.);\n                    MASK_3 01000010.);\n                    MASK_4 01111110.);\n                    MASK_5 01000010.);\n                    MASK_6 01000010.);\n                    MASK_7 01000010.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  I_01001001 I_\n                if((ch - I_01001001)<.1){\n                    MASK_1 00111000.);\n                    MASK_2 00010000.);\n                    MASK_3 00010000.);\n                    MASK_4 00010000.);\n                    MASK_5 00010000.);\n                    MASK_6 00010000.);\n                    MASK_7 00111000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  Y_01011001 Y_\n                if((ch - Y_01011001)<.1){\n                    MASK_1 01000100.);\n                    MASK_2 01000100.);\n                    MASK_3 01000100.);\n                    MASK_4 00111000.);\n                    MASK_5 00010000.);\n                    MASK_6 00010000.);\n                    MASK_7 00010000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            }\n            else \n            { //3\n                #define n5_00110101 n5_\n                if((ch - n5_00110101)<.1){\n                    MASK_1 01111110.);\n                    MASK_2 01000000.);\n                    MASK_3 01111000.);\n                    MASK_4 00000100.);\n                    MASK_5 00000010.);\n                    MASK_6 01000100.);\n                    MASK_7 00111000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  E_01000101 E_\n                if((ch - E_01000101)<.1){\n                    MASK_1 01111110.);\n                    MASK_2 01000000.);\n                    MASK_3 01000000.);\n                    MASK_4 01111000.);\n                    MASK_5 01000000.);\n                    MASK_6 01000000.);\n                    MASK_7 01111110.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  M_01001101 M_\n                if((ch - M_01001101)<.1){\n                    MASK_1 01000010.);\n                    MASK_2 01100110.);\n                    MASK_3 01011010.);\n                    MASK_4 01000010.);\n                    MASK_5 01000010.);\n                    MASK_6 01000010.);\n                    MASK_7 01000010.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            }\n        }\n        else \n        { //2\n            #define n3_00110011 n3_\n            if((ch - n3_00110011)<.1){\n                MASK_1 00111100.);\n                MASK_2 01000010.);\n                MASK_3 00000010.);\n                MASK_4 00011100.);\n                MASK_5 00000010.);\n                MASK_6 01000010.);\n                MASK_7 00111100.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  C_01000011 C_\n            if((ch - C_01000011)<.1){\n                MASK_1 00111000.);\n                MASK_2 01000100.);\n                MASK_3 10000000.);\n                MASK_4 10000000.);\n                MASK_5 10000000.);\n                MASK_6 01000100.);\n                MASK_7 00111000.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  S_01010011 S_\n            if((ch - S_01010011)<.1){\n                MASK_1 00111100.);\n                MASK_2 01000010.);\n                MASK_3 01000000.);\n                MASK_4 00111100.);\n                MASK_5 00000010.);\n                MASK_6 01000010.);\n                MASK_7 00111100.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n        }\n    }//1\n    \n#endif\n    \n\treturn false;\n}\n\n// Remainder of nested macro impl. messy but works\n#define k(C) if(i++>l){return C;}\nfloat frameBuffer(float loc) {\n    if(loc>110.) return s_;\n\n    int i = 1, l = int(loc);\n    if(l<23){\n        k(a_) k(a_) k(a_) k(a_) k(s_)\n        k(C_) k(B_) k(M_) k(s_) k(B_) k(A_) k(S_) k(I_) k(C_)\n        k(s_) k(V_) k(n2_) k(s_)\n        k(a_) k(a_) k(a_) k(a_)\n    }\n    if(l<44) return s_;\n    i = 45;\n    if(l<66){\n        k(n3_) k(n5_) k(n8_) k(n3_) k(s_) k(B_) k(Y_) k(T_) k(E_) k(S_) k(s_)\n        k(F_) k(R_) k(E_) k(E_) k(s_) k(s_) k(s_) k(s_) k(s_) k(s_) k(s_)\n    }\n    if(l<88) return s_;\n    i = 89;\n    if(l<110){\n    \tk(R_) k(E_) k(A_) k(D_) k(Y_) k(d_)\n    }    \n\n\treturn s_;\n}\n\nbool screen(in vec4 p) {\n    vec4 b = floor(p/8.);\n    p.z = floor(22.*b.y + b.x);\n    p.w = frameBuffer(p.z);\n    return glyph(p);\n}\n\nvec4 blink(vec2 p) {\n\treturn ((p.x>8.)||(p.x<1.)||(p.y>50.)||(p.y<42.)) ?\n        WHT : mod(iTime,1.2)<.6 ? BLU : WHT;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (iMouse.z>0.) ?\n        fragCoord/iMouse.xy :\n        fragCoord/iResolution.xy;\n\n    //flip screen\n    uv.y = 1.-uv.y;\n\n    vec2 b = vec2(.1,.15),\n         b1 = 1.01-b,\n         b2 = b/2.,\n         ins = uv-b2;\n    \n    if(ins.x<0. || ins.y<0. || ins.x>b1.x || ins.y>b1.y) {\n        fragColor = CYN;\n    } else {\n    \n        vec2 scr = (1.+b)*uv-b2,\n             xy = vec2(176.,184.)*scr;\n\n        xy.y -= 2.;  // feels just like adjusting V-sync on the portable telly :)\n\n        fragColor = screen(vec4(xy,0,0)) ? BLU : blink(xy);\n\n#ifdef VDU_NOISE\n        // interlacing noise suggestion per Andre\n        fragColor *= float(mod(float(iFrame)+floor(fragCoord.y),iResolution.y<768.?3.:4.));\n#endif\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcXz2", "name": "Fractal Yolo", "author": "Vicious", "description": "Yolo", "tags": ["yolo"], "likes": 0, "viewed": 95, "date": "1460202741", "time_retrieved": "2024-06-20T18:35:26.830715", "image_code": "void mainImage( out vec4 f, in vec2 p )\n{\n    float n = 0.;\n    vec2 c = vec2(-.745,.186) + 3. * (p.xy/iResolution.y-.5)*pow(.01,1.+cos(.4*iTime) * 1.3 * sin(iTime)), z=c*n;\n    \n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y ) + c;\n\n        if( dot(z,z)>1e10 ) break;\n\n        n++;\n    }\n    \n    f = .5 + .5*cos( vec4(30,40,110,0) + 1.05*(n - log2(log2(dot(z,z)))) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcXzj", "name": "Singular. ", "author": "IO", "description": "Hi, \nAnother Night.\n\nSo ya. It's keep going on.\n\nDoes it turns left or right around?\nCan't figure out..\n\nWhat ever. \nHave a inspiring day.\nIO_", "tags": ["2d", "sdf", "sin", "cos", "chromatic", "dots", "rotation"], "likes": 10, "viewed": 299, "date": "1460162724", "time_retrieved": "2024-06-20T18:35:26.830715", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fColor = vec3(.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n   \tvec2 oPos00 = vec2(.0);\n   \tvec2 oPos01 = vec2(.0,.2);\n   \tvec2 oPos10 = vec2(.0,-.3);\n   \tvec2 oPos11 = vec2(.3,.0);\n    \n    float count = 15.;\n    \n    for(float i = 0.; i <  15.; ++i)\n    {\n       vec2 oPos00 = vec2(cos(iTime*0.5+i/ count * 6.28+0.5)*0.5,sin(i/count * 6.28)*0.5);\n       vec2 oPos01 = vec2(cos(iTime*0.5+i/ count * 6.28+0.48)*0.5,sin(i/count * 6.28)*0.5);\n       vec2 oPos10 = vec2(cos(iTime*0.5+i/ count * 6.28+0.45)*0.5,sin(i/count * 6.28)*0.5);\n        \n       float o00 = length(oPos00 - uv) - 0.05; \n       float o01 = length(oPos01 - uv) - 0.05; \n       float o10 = length(oPos10 - uv) - 0.05; \n        \n       vec3  mat00 = (1. - smoothstep(0.0,5.0/iResolution.x,o00)) * (vec3(1.0,0.0,0.0)*1.0);\n       vec3  mat01 = (1. - smoothstep(0.0,5.0/iResolution.x,o01)) * (vec3(0.0,1.0,0.0)*1.0);\n       vec3  mat10 = (1. - smoothstep(0.0,5.0/iResolution.x,o10)) * (vec3(0.0,0.0,1.0)*1.0);\n        \n        \n       fColor += mat00;\n       fColor += mat01;\n       fColor += mat10;  \n    }\n   \n\tfragColor = vec4(fColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XddSD7", "name": "Dynamic resolution interferences", "author": "waterhead", "description": "Just some simple test pattern for some dynamic coordinate space tiling. Just subdivides continous coordinate space into dynamically sized squares and renders some circular interferences into it, in order to show the varying grid size.", "tags": ["2d", "grid", "interference", "circle"], "likes": 7, "viewed": 326, "date": "1459763977", "time_retrieved": "2024-06-20T18:35:27.109697", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float MAX_DIMENSION = max(iResolution.x, iResolution.y);\n    float U_OFFSET = -0.5;\n    float V_OFFSET = -0.5 * iResolution.y / iResolution.x;\n\n    \n    // init some arguments for animation, like rotation, zoom and stuff:\n    float rotation = sin(0.31 * iTime);\n    float pelSize = (1.000001 - (cos(iTime * 0.23) * 0.5 + 0.5)) * 20.0;\n    float zoom = pelSize / MAX_DIMENSION;\n    float zoomH = 0.5 * zoom;\n\n    // grab UV and center\n    vec2 uv = vec2(fragCoord.x / MAX_DIMENSION + U_OFFSET,\n                   fragCoord.y / MAX_DIMENSION + V_OFFSET);\n\n    // apply rotation\n    float sinA = sin(rotation);\n    float cosA = cos(rotation);\n    vec2 pnt = vec2(uv.x * cosA - uv.y * sinA - zoomH,\n                    uv.y * cosA + uv.x * sinA - zoomH);\n    \n    vec2 offsetUV = floor((pnt + zoom) / zoom) * zoom;\n    \n    vec3 color = vec3(0.0);\n   \n    for(float i = 0.0; i < 4.0; i++) {\n        // move circle center to to somehwere\n        vec2 center = vec2( 0.3 * sin(iTime * 0.13 + i * 1.5707963267948966),\n                            0.3 * cos(iTime * 0.17 + i * 1.5707963267948966));\n        \n        // grab distance to center...\n        float distance = length(center - offsetUV);\n\n        // ...and create some color based on distance:\n        color.x += sin(distance * (201.0)) * 1.0;\n        color.y += sin(distance * (167.0)) * 2.0;\n        color.z += sin(distance * (123.0)) * 4.0;\n    }\n\n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XddSDX", "name": "P6MM Inversion Attempt Result 2", "author": "vox", "description": "Figured it out. Just a Mobius transformation. At least it's pretty when used like an IFS... Here's the ugly first attempt: \nhttps://www.shadertoy.com/view/XdtSDX", "tags": ["p6mminversionresultattempt2mobius"], "likes": 0, "viewed": 428, "date": "1461836951", "time_retrieved": "2024-06-20T18:35:27.340008", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime)\n#define saw(x) (acos(cos(x))/PI)\n\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 tree(vec2 uv)\n{\n\tfloat t = sin(iTime) * 6.0;\n\tvec2 a = sin(vec2(time*.1, time*.2));\n\tvec2 b = sin(vec2(time*.3, time*.4));\n\tvec2 c = sin(vec2(time*.5, time*.6));\n\tvec2 d = sin(vec2(time*.7, time*.8));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv = saw(tree(uv)*2.0*PI)*2.0-1.0; \n    uv = saw(tree(uv)*2.0*PI)*2.0-1.0; \n    uv = saw(tree(uv)*2.0*PI); \n\n    fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddSDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XddSRs", "name": "Sandbox 3 2 1", "author": "j3553", "description": "My 1st post to Shadertoy. Originally 3 separate shaders from GLSLsandbox's precursor: glsl.heroku. I couldn't retrace all credits apart from Paulo Falcao, Simon Green and Chris Wood. Shaders were ported to and blended in Quartz Composer before rewriting.", "tags": ["sandbox", "heroku"], "likes": 6, "viewed": 173, "date": "1460927804", "time_retrieved": "2024-06-20T18:35:28.055203", "image_code": "// plasma functions: makePoint and minDist\nfloat makePoint(vec2 x, vec2 f, vec2 s, float t)\n{\n   vec2 p = vec2(sin(t*f.x), cos(t*f.y)) * s;\n   return sin(length(p - x) * 5.);\n}\n\nvec2 minDist(vec2 mind, float i, float d)\n{\n   return min(mind, d);\n}\n\n// dreamwaves functions: Distort, pattern, hash and noise\nvec2 Distort(vec2 p)\n{\n    float theta  = atan(p.y, p.x);\n    float radius = length(p);\n    radius = pow(radius, 1.3);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return 0.5 * (p + 1.0);\n}\n\nvec4 pattern(vec2 p)\n{\n\tvec2 m=mod(p.xy+p.x+p.y,2.)-1.;\n\treturn vec4(length(m));\n}\n\nfloat hash(const float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(const vec3 x)\n{\n\tvec3 p=floor(x);\n\tvec3 f=fract(x);\n\n    \tf=f*f*(3.0-2.0*f);\n\n    \tfloat n=p.x+p.y*57.0+p.z*43.0;\n\n    \tfloat r1=mix(mix(hash(n+0.0),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+57.0+1.0),f.x),f.y);\n    \tfloat r2=mix(mix(hash(n+43.0),hash(n+43.0+1.0),f.x),mix(hash(n+43.0+57.0),hash(n+43.0+57.0+1.0),f.x),f.y);\n\n\treturn mix(r1,r2,f.z);\n}\n\n// PchasingLightBlobs\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n\tvec2 pos1 = ( fragCoord.xy / iResolution.xy * 7. );\n\n\tvec2 pos2 = ( fragCoord.xy/iResolution.x ) * 2.0 - vec2(1.0,iResolution.y/iResolution.x);\n\n\tvec2 pos3 = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tpos3.x *= iResolution.x / iResolution.y;\n\tpos3 *= 3.0;\n\n\tfloat t = iTime*0.7;\n\t\n\tfloat off = noise(pos1.xyx + .3*iTime);\n\t\n\tvec4 col1 = pattern(Distort(pos1+off));\n\n\tcol1.xy = Distort(col1.xy);\n\n\tcol1 = vec4(col1.x - off, sin(col1.y) - off, cos(col1.z), 1.0);\n\n\tvec2 a = vec2(1e10, 1e10);\n\ta = minDist(a, 1.0, makePoint(pos2, vec2(3.3,2.9), vec2(0.1,0.1), t));\n\ta += minDist(a, 2.0, makePoint(pos2, vec2(1.9,2.0), vec2(0.4,0.4), t));\n\ta *= minDist(a, 3.0, makePoint(pos2, vec2(0.8,0.7), vec2(0.4,0.5), t));\n\ta += minDist(a, 4.0, makePoint(pos2, vec2(2.3,0.1), vec2(0.6,0.3), t));\n\ta *= minDist(a, 5.0, makePoint(pos2, vec2(0.8,1.7), vec2(0.5,0.4), t));\n\ta += minDist(a, 6.0, makePoint(pos2, vec2(0.3,1.0), vec2(0.4,0.4), t));\n\ta *= minDist(a, 7.0, makePoint(pos2, vec2(1.4,1.7), vec2(0.4,0.5), t));\n\ta += minDist(a, 8.0, makePoint(pos2, vec2(1.3,2.1), vec2(0.6,0.3), t));\n\ta *= minDist(a, 9.0, makePoint(pos2, vec2(1.8,1.7), vec2(0.5,0.4), t));     \n\n\tfloat i = a.x * 50.0;\n\t\n\tvec3 col2 = 1.4 - vec3(0.8 * i, 0.8 * i, 0.4 * i);\n\n\tfloat col3 = 0.7;\n\tfor(float i = 0.0; i < 50.0; i++)\n\t{\n\t\tvec2 randCoord = vec2(rand(vec2(i, i)), rand(vec2(i, i+10.0)));\n\t\trandCoord.x += sin(iTime/2.0 + randCoord.y * randCoord.y);\n\t\trandCoord.y += sin(iTime + randCoord.x * 2.0);\n\t\t\n\t\trandCoord = randCoord * 2.0 - 1.0;\n\t\tcol3 += 1.0 / distance(pos3, randCoord) * 0.6;\n\t}\n\tcol3 *= 0.02;\n\tcol3 = pow(col3, 0.9);\n\n\tvec4 col3B = vec4( vec3(col3 + rand(pos3) * (1.0 / 128.0)), 0.3);\n\tcol3B = pow(col3B, vec4(1.5, iTime*iTime,0.86, 0.3));\n\n\tvec3 col2A = 1.-col2;\n\tfragColor = max(min(col1,vec4(col2,1.0)) , min (col3B,vec4(col2A,1.0)));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtSDM", "name": "Tribute to OW", "author": "vox", "description": "Thanks OW!", "tags": ["tributetoow"], "likes": 6, "viewed": 136, "date": "1459699001", "time_retrieved": "2024-06-20T18:35:28.055203", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+theta/turns+iTime), saw(theta+iTime*1.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float scale = 2.0*PI+iTime;\n    uv *= scale;\n    uv -= scale/2.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv += vec2(cos(iTime*.234), sin(iTime*.345))*1.0;\n    uv = spiral(uv*scale);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv = spiral(uv*scale);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv = spiral(uv*scale);\n   fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtSDX", "name": "P6MM Inversion Result Attempt", "author": "vox", "description": "An attempt at getting the same result as: https://www.shadertoy.com/view/MtjGz3", "tags": ["p6mminversionresultattempt"], "likes": 4, "viewed": 423, "date": "1461829727", "time_retrieved": "2024-06-20T18:35:28.055203", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime/PI/PI)\n#define saw(x) (acos(cos(x))/PI)\n#define stair floor\n#define jag fract\n\nvec2 SinCos( const in float x )\n{\nreturn vec2(sin(x), cos(x));\n}\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\nvec2 tree(vec2 uv)\n{\n    const float max_additional_turns = 10.0;\n    float turns = 2.0+mod(floor(iTime), max_additional_turns);\n    float theta = atan(uv.y, uv.x);\n\n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n\n    vec2 xy = rotatez(uv.xy, PI*2.0*(rot)+1.0*PI/turns);\n    \n    //xy = sign(xy)*log(abs(xy));\n    //return vec2(saw(theta*turns+PI*stair(xy.x*1.0)), 1.0-jag(xy.x*4.0));\n    //return vec2(saw(xy.y*turns+PI*stair(xy.x*1.0)), 1.0-jag(xy.x*4.0));\n    return vec2((xy.y*turns), (xy.x*turns));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = (2.0+sin(time))*PI;\n    uv = uv*scale-scale/2.0;\n    uv += sin(vec2(time, time/PI*E*GR))*scale*.125;\n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    uv = normalize(uv)/log(r);\n    uv += sin(vec2(time, time/PI*E*GR))*scale;\n\n    uv = saw(tree(uv))*2.0-1.0; \n    uv = saw(tree(uv))*2.0-1.0; \n    uv = saw(tree(uv));\n\n    fragColor = vec4(uv, 0.0, 1.0)*pow(clamp(r-1.0, -1.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtSDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtSRB", "name": "hypnotic wavy lines", "author": "hubbe", "description": "blorg", "tags": ["fnord"], "likes": 2, "viewed": 155, "date": "1461559536", "time_retrieved": "2024-06-20T18:35:28.055203", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = vec2(uv.x + sin(uv.y + iTime), uv.y + sin(uv.x + iTime * 0.3));\n    vec2 uv3 = vec2(uv2.x + sin(uv2.y + iTime * 0.2), uv2.y + sin(uv2.x + iTime * 0.5));\n    vec2 uv4 = vec2(uv3.x + sin(uv3.y + iTime * 0.1), uv3.y + sin(uv3.x + iTime * 0.15));\n   \n    fragColor =\n        vec4(1,0.5,0.2,1) * max(0.0,pow(-sin(uv2.y * 34.0), 20.0)) +\n        vec4(-1,2,0.2,1) * max(0.0,pow(-sin(uv3.y * 34.0), 20.0)) +\n        vec4(1, 0.2, 0.5, 1) * max(0.0,pow(-sin(uv4.y * 34.0), 20.0)) +\n\tvec4(0.2,0.1,0.2,1); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtXRS", "name": "Voronoids", "author": "mazander", "description": "Voronoi distance visualization with moving points.", "tags": ["voronoi"], "likes": 13, "viewed": 405, "date": "1459973288", "time_retrieved": "2024-06-20T18:35:28.218722", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 uv = vec4(fragCoord, fragCoord) / iResolution.y;\n    vec4 a = vec4(1.01, 1.11, 1.21, 1.31) * iTime * .2, p;\n    \n    float d = .5;\n    \n    for(float i = 0.; i < 20.; i++) {\n       \t\n        a += i * vec4(3.,4.,5.,6.) + vec4(1.3,2.5,3.3,4.1);\n\t\tp = fract(uv + sin(a)) - .5; // Wrapping the offset point.\n        d = min(d, min(dot(p.xy, p.xy), dot(p.zw, p.zw))); // Take square root outside loop for efficiency.\n    }\n\n    // \"dist>=0.\" and sqrt(Max)*4. = 1., so no clamping needed, in this case.\n    d = sqrt(d)*4.;\n    \n    fragColor = vec4(vec3(d*d*.5, d, pow(d, .66)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SDs", "name": "Julia set + perlin noise", "author": "stduhpf", "description": "I tried to make a procedural orbit trap for the julia set, as described here:\nhttp://iquilezles.org/www/articles/ftrapsprocedural/ftrapsprocedural.htm", "tags": ["procedural", "2d", "fractal", "noise", "perlin", "orbittraps"], "likes": 5, "viewed": 291, "date": "1462027027", "time_retrieved": "2024-06-20T18:35:28.576362", "image_code": "//procedural orbit trap with perlin noise \n\n\nconst int n= 64; \n\nfloat rand(vec2 co){\n    return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453)-.5;}\nvec2 grad(vec2 co){\n    return vec2(rand(co),rand(vec2(2,3)*co.yx+.5));\n        }\nfloat perlin(vec2 uv)\n{\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n    \n    vec2 grad1 = grad(inco);\n    vec2 grad2 = grad(inco+vec2(1,0));\n    vec2 grad3 = grad(inco+vec2(1,1));\n    vec2 grad4 = grad(inco+vec2(0,1));\n    \n    float s = dot(grad1,relco);\n    float t = dot(grad2, relco-vec2(1,0));\n    float u = dot(grad3, relco-1.);\n    float v = dot(grad4, relco-vec2(0,1));\n    \n    float n1 = mix(s,t,smoothstep(0.,1.,relco.x));\n    float n2 = mix(v,u,smoothstep(0.,1.,relco.x));\n\n    return mix(n1,n2,smoothstep(0.,1.,relco.y));\n}\nvec2 multc(vec2 a, vec2 b)\n     {\n         return vec2(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);}\nvec2 gettrap(vec2 a)\n{\n float b = perlin(a+iTime/2.);\n    return vec2(40.*b/length(a),b+.5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv-=vec2(.5+ abs(iResolution.y-iResolution.x)/(2.*iResolution.y),.5);\n    uv*=3.;\n    vec2 um = iMouse.xy/iResolution.y;\n      um-=vec2(.5+ abs(iResolution.y-iResolution.x)/(2.*iResolution.y),.5);\n    um*=3.;\n        \n    vec4 color = vec4(0);\n    vec2 z =uv;\n    vec2 c = um;\n    float f=0.;\n    for (int i=0;i<n;i++)\n    {\n        if (length(z)>float(i))continue;\n        f+=1.;\n        z=multc(z,z)+c;\n        vec2 t = gettrap(um-z+cos(iTime/10.)/8.);\n        color+=vec4(vec3(t.x),t.y);\n        color*=.5;\n    }\n    \n\tfragColor = mix(color,f*vec4(.5,0,0,0)/float(n),1.-color.w)*2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SWB", "name": "Spiral Flower", "author": "vox", "description": "Improved. EPS Removed.", "tags": ["spiralflower"], "likes": 2, "viewed": 465, "date": "1461099741", "time_retrieved": "2024-06-20T18:35:28.576362", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define time ((saw(float(__LINE__))*.1+1.0)*iTime/PI)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/PI;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/PI;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/PI;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/PI;\n}\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 stair(vec2 x)\n{\n    return vec2(stair(x.x), stair(x.y));\n}\n\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c)\n{\n    vec2 duv = b-p;\n    \n    vec2 xdir = c-b;\n    vec2 ydir = a-b;\n    float w = cross(xdir, ydir);\n    return vec2((dot(duv, normalize(xdir))), (dot(duv, normalize(ydir))));\n}\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec4 tree(vec4 uv)\n{\n    vec4 uv0 = uv;\n\n    mat4 last = mat4(0.0);\n    float mind = 1.0E32;\n    float omega = 0.0;\n    const int max_iterationts = 18;\n    \n    \n    for(int i = 0; i < max_iterationts; i++)\n    {\n    \tfloat iteration = PI*2.0*(float(i)/(float(max_iterationts) ));//*(1.0+saw(time+float(i)))));\n        \n        mat4 square = mat4(0.0, 0.0, 0.0, 0.0,\n                           1.0, 0.0, 0.0, 0.0,\n                           1.0, 1.0, 0.0, 0.0,\n                           0.0, 1.0, 0.0, 0.0);\n\n        float size =  .5;\n\n        square = translate(square, vec2(-.5));\n        square = scale(square, vec2(2.0));\n        \n        float r = iteration;\n        float theta = iteration-time;\n        square = RotateZ(square, theta);\n        \n        vec2 center = vec2(sin(theta), sin(theta+PI/2.0));\n        square = translate(square, center);\n        square = scale(square, vec2(.5));\n        square = translate(square, vec2(.5));\n\t\tcenter = square[1].xy;\n        float d = length(center-uv0.xy);\n        if(d < mind)\n        {\n            last = square;\n            mind = d;\n            omega = theta;\n        }\n    }\n    \n    vec2 center = (last[0].xy+last[1].xy+last[2].xy+last[3].xy)/4.0;\n    vec4 uv1 = vec4(invBilinear(uv0.xy, last[0].xy, last[1].xy, last[2].xy), mind,omega);\n\n    return vec4(uv1.xy, mind, omega);\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5*uv.x;\n\telse\n\t\treturn 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 uv = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    float amplitude = 2.0+sin(time);\n    float scale;\n    \n\tconst int max_iterations =9;\n\n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n        if(i == 0)\n        {\n        \tscale = amplitude;\n            uv.xy = uv.xy*scale*2.0-scale;\n            uv.xy += .5*scale*vec2(sin(time/GR*1.2345), cos(time/E*2.345));\n            uv.x *= iResolution.x/iResolution.y;\n        }\n    \telse\n        {\n        \tscale = amplitude;//pow(amplitude, length(uv0*2.0-1.0)/sqrt(2.0)*sin(time*GR/2.0+float(i)-1.0));\n            uv.xy = uv.xy*2.0-1.0;\n        }\n        uv = tree(uv);\n        map += saw(uv.z+uv.w)*PI;//square(uv.xy, float(i))*noise;\n    }\n    \n    float map2 = 0.0;\n    /*\n    noise = 1.0;\n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        uv = spiral(uv);\n        map2 += uv.g*noise;\n        \n        noise *= clamp(.95-fwidth(map2), 0.0, 1.0);\n    }\n    */\n    \n    \n    \n    \n    fragColor.rg = uv.rg;//saw(uv.zw);//saw(uv.zw*PI);\n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    //fragColor = vec4(noise);\n    map = map+time;//map*PI + time*PI;\n    fragColor = vec4(vec3(saw(map+map2),\n                          saw(4.0*PI/3.0+map+map2),\n                          saw(2.0*PI/3.0+map+map2)),\n                     1.0);\n    return;\n/*\n\tconst int max_iterations = 8;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        noise += clamp(1.0-fwidth(map), 0.0, 1.0);\n        \n        uv = tree(uv); \n        \n        map += square(uv, float(i)/float(max_iterations))/noise;\n    } \n    map = map*PI + time;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SWj", "name": "Droste Zoom", "author": "roywig", "description": "It's a Droste zoom... with a twist!\n\nDerived with the help of Jos Leys' article:\nhttp://www.josleys.com/article_show.php?id=82", "tags": ["droste", "escher", "complex", "conformal", "exponential"], "likes": 24, "viewed": 600, "date": "1461392295", "time_retrieved": "2024-06-20T18:35:28.582508", "image_code": "#define PI 3.14159\n\nvec2 cInverse(vec2 a) { return\tvec2(a.x,-a.y)/dot(a,a); }\nvec2 cMul(vec2 a, vec2 b) {\treturn vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x); }\nvec2 cDiv(vec2 a, vec2 b) {\treturn cMul( a,cInverse(b)); }\nvec2 cExp(vec2 z) {\treturn vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y)); }\nvec2 cLog(vec2 a) {\tfloat b =  atan(a.y,a.x); if (b>0.0) b-=2.0*PI;return vec2(log(length(a)),b);}\n\nvoid mainImage( out vec4 fragColor, in vec2 z )\n{\n\tz = (z - iResolution.xy/2.)/iResolution.y;\n    float r1 = 0.1, r2 = 1.0,\n        scale = log(r2/r1),angle = atan(scale/(2.0*PI));\n    // Droste transform here\n    z = cLog(z);\n    z.y -= iTime/2.;\n    z = cDiv(z, cExp(vec2(0,angle))*cos(angle)); // Twist!\n    z.x = mod(z.x-iTime,scale);\n    z = cExp(z)*r1;\n    // Drawing time.\n    fragColor = texture(iChannel0,.5+.5*z); \n    z = sin(z*25.);\n    fragColor = vec4(mix(vec3(z.x*z.y),fragColor.xyz,.85),1.);\n\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SWl", "name": "WAVY WAVE", "author": "hobscure", "description": "wave", "tags": ["wavy"], "likes": 1, "viewed": 82, "date": "1461939932", "time_retrieved": "2024-06-20T18:35:28.788460", "image_code": " #define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-(0.05+sin(iTime)/10.0), pct, st.y) - \n          smoothstep( pct, pct+(0.05+sin(iTime)/10.0), st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec3 color = vec3(st.y * sin(iTime));\n    \n    float v = (cos((st.x * 10.0) + iTime * 1.0) + cos((st.x * 10.0)*2.0/3.0*3.1415 + iTime * 1.0) )/5.0 + 0.5;\n    float v2 = v +  sin((st.x * 20.0)*100.0*3.1415 + iTime * 1.0) / 10.0  ;\n    \n    float v3 = (cos((st.x*sin(st.y) * 10.0) + iTime * 1.0) + cos((st.x * 10.0)*2.0/3.0*3.1415 + iTime * 1.0) )/5.0 + 0.5;\n    \n    float v4 = 0.25+ 0.7/(exp((st.x+(sin(iTime)/2.0)-0.75)/0.07)+1.0);\n    float v5 =  0.75- 0.7/(exp((st.x+(sin(iTime)/2.0)-0.25)/0.07)+1.0);\n    \n    float v6 = (v4*v5+0.3);\n    float v7 = 0.6 + 0.5/(exp((st.x+(sin(iTime)/2.0)-0.45)/0.01)+1.0)- 0.5/(exp((st.x+(sin(iTime)/2.0)-0.55)/0.01)+1.0);\n    \n    float v8 = v7*(0.5+0.4*sin(st.x*iTime));\n    \n    float pct = plot(st ,v8);\n   \n    \n    color = (pct)*color+pct*vec3(1.0,0.0,0.0);\n\nfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3XDB", "name": "Amphitheater", "author": "dr2", "description": "Somewhere in the Roman empire... Use the mouse to examine the architecture.", "tags": ["raymarching", "architecture", "android"], "likes": 13, "viewed": 543, "date": "1461158587", "time_retrieved": "2024-06-20T18:35:28.807530", "image_code": "// \"Amphitheater\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4v3 (ip);\n  t2 = Hashv4v3 (ip + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo)\n{\n  return length (p - vec2 (rhi * clamp (p.x / rhi, -1., 1.), 0.)) - rlo;\n}\n\nvec2 SSBump (float w, float s, float x)\n{\n  return vec2 (step (x + s, w) * step (- w, x + s),\n     step (x - s, w) * step (- w, x - s));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 sunDir;\nvec2 rAngHCs, rAngACs, rAngLCs, rAngTCs;\nfloat dstFar, tCur;\nint idObj;\nbool walk;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, p;\n  float ds, fd, att, attSum, d, sd;\n  if (rd.y >= 0.) {\n    p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;  p.xz += 0.1 * tCur;\n    att = Fbm2 (p.xz);  attSum = att;\n    d = fd;\n    ds *= fd;\n    for (int j = 0; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    attSum *= 0.3;  att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n    col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) *\n       max (rd.y - 0.1, 0.)));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  } else {\n    p = ro - (ro.y / rd.y) * rd;\n    col = 0.6 * mix (vec3 (0.4, 0.4, 0.1), vec3 (0.5, 0.5, 0.2),\n       Fbm2 (9. * p.xz)) * (1. - 0.1 * Noisefv2 (150. * p.xz));\n  }\n  return col;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq, qt;\n  vec2 rh, drh;\n  float d, a;\n  qq = p;\n  qq.xz = Rot2D (qq.xz, 2. * pi / 48.);\n  a = atan (qq.z, - qq.x) / (2. * pi);\n  q = qq;  q.y -= 0.57;\n  d = PrCylAnDf (q.xzy, 2., 0.03, 0.57);\n  q = qq;  q.xz = Rot2D (q.xz, 2. * pi * (floor (24. * a) + 0.5) / 24.);\n  q.y -= 0.11;\n  d = max (d, - max (PrFlatCyl2Df (q.yz, 0.2, 0.16), -0.1 - q.y));\n  q = qq;  q.xz = Rot2D (q.xz, 2. * pi * (floor (48. * a) + 0.5) / 48.);\n  qt = q;\n  q.y -= 0.63;\n  d = max (d, - max (PrFlatCyl2Df (q.yz, 0.13, 0.1), -0.05 - q.y));\n  q = qq;  q.xz = Rot2D (q.xz, 2. * pi * (floor (96. * a) + 0.5) / 96.);\n  q.y -= 0.96;\n  d = max (d, - max (PrFlatCyl2Df (q.yz, 0.08, 0.05), -0.025 - q.y));\n  q = qt;  q.xy -= vec2 (-1.9, 0.47);\n  d = min (d, PrOBoxDf (q, vec3 (0.07, 0.01, 0.02)));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = p;  q.y -= 0.25;\n  rh = vec2 (1.8, 0.25);\n  drh = vec2 (0.05, 0.0175);\n  d = PrCylAnDf (q.xzy, rh.x, 0.5 * drh.x, rh.y);\n  for (int k = 0; k < 13; k ++) {\n    q.y -= - drh.y;  rh -= drh;\n    d = min (d, PrCylAnDf (q.xzy, rh.x, 0.5 * drh.x, rh.y));\n  }\n  qq = p;\n  a = atan (qq.z, - qq.x) / (2. * pi);\n  qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (6. * a) + 0.5) / 6.));\n  q = qq;  q.y -= 0.07;\n  d = max (d, - max (PrFlatCyl2Df (q.yz, 0.22, 0.1), -0.05 - q.y));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.y = abs (q.y - 0.26) - 0.25;\n  d = PrCylAnDf (q.xzy, 0.3, 0.01, 0.01);\n  q = qq;  q.xy -= vec2 (-0.3, 0.26);\n  d = min (d, PrCylDf (q.xzy, 0.01, 0.25));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;  q.y -= 0.03;\n  d = PrCylDf (q.xzy, 0.2, 0.03);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;  q.y -= -0.003;\n  d = PrCylDf (q.xzy, 2.5, 0.003);\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  return dMin;\n}\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 s;\n  float hGap, bf, d, szFac, spx;\n  bool isMob;\n  isMob = (length (p.xz) > 0.4);\n  if (isMob) {\n    p.xz = Rot2Cs (p.xz, rAngTCs);\n    s = step (0., p.xz);\n    p.xz = abs (p.xz) - 0.5;\n    p.xz = Rot2D (p.xz, ((s.x == s.y) ? -0.75 :\n       (0.75 - 2. * step (s.x, s.y))) * pi);\n    szFac = 25.;\n  } else {\n    p.xz = vec2 (- p.z, p.x);  p.y -= 0.06;\n    szFac = 10.;\n  }\n  p *= szFac;\n  hGap = 2.;\n  bf = isMob ? PrBoxDf (p, vec3 (3. * hGap, 6., 3. * hGap)) : 0.;\n  dMin *= szFac;\n  if (isMob) {\n    p.xz = mod (p.xz + hGap, 2. * hGap) - hGap;\n    if (s.x == s.y) p.xz = vec2 (- p.z, p.x);\n    if (! walk) {\n      p.xz = vec2 (- p.z, p.x);\n      if (s.x == s.y) p.xz = - p.xz;\n    }\n  }\n  spx = 2. * step (0., p.x) - 1.;\n  q = p;  q.y -= 2.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = p;  q.y -= 1.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = p;  q.xz = Rot2Cs (q.xz, rAngHCs);\n  q.x = abs (q.x) - 0.3;  q.y -= 3.;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.2));\n  q = p;  q.x = abs (q.x) - 1.05;  q.y -= 2.1;\n  if (isMob || ! walk) q.yz = Rot2Cs (q.yz, rAngACs *\n     vec2 (1., (walk ? spx : 1.)));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;  q.x = abs (q.x) - 0.4;  q.y -= 1.;\n  if (isMob) q.yz = Rot2Cs (q.yz, rAngLCs * vec2 (1., spx));\n  q.y -= -0.8;\n  d = max (min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55)), bf);\n  if (d < dMin) { dMin = d;  idObj = 11; }\n  q = p;  q.xz = Rot2Cs (q.xz, rAngHCs);\n  q.x = abs (q.x) - 0.4;  q.yz -= vec2 (2.6, 0.7);\n  d = max (PrSphDf (q, 0.15), bf);\n  if (d < dMin) { dMin = d;  idObj = 12; }\n  dMin /= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = RobDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.07 * d, h));\n    d += max (0.04, 0.08 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, q;\n  vec2 ss;\n  float dstObj, spec, sn, a, f, sh;\n  int idObjT;\n  bool isRuf;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    isRuf = true;\n    spec = 0.1;\n    if (idObj == 1 || idObj == 2) a = atan (ro.z, - ro.x) / (2. * pi);\n    if (idObj == 1) {\n      q = ro;\n      col = vec3 (0.8, 0.6, 0.3);\n      ss = vec2 (0.);\n      if (abs (q.y - 0.53) < 0.021) {\n        ss = SSBump (0.008, 0.013, q.y - 0.53);\n        sn = 0.3;\n      } else if (abs (q.y - 0.9) < 0.013) {\n        ss = SSBump (0.005, 0.008, q.y - 0.9);\n        sn = 0.2;\n      } else if (abs (q.y - 1.125) < 0.008) {\n        ss = SSBump (0.003, 0.005, q.y - 1.125);\n        sn = 0.15;\n      }\n      if (ss.x + ss.y != 0.) {\n        vn.y += sn * (ss.y - ss.x);\n        vn = normalize (vn);\n        col *= 0.8 * ss.x + 1.1 * ss.y;\n        isRuf = false;\n      } else if (length (q.xz) > 2. && q.y < 0.505) {\n        q.xz = Rot2D (q.xz, 2. * pi * (floor (24. * a) + 0.5) / 24.);\n        if (abs (q.z) < 0.032) {\n          ss = SSBump (0.013, -0.015, q.z);\n          if (ss.x + ss.y != 0.) {\n            vn.xz += 0.3 * (ss.y - ss.x) * vn.zx * vec2 (-1., 1.);\n            col *= 0.8 * ss.x + 1.1 * ss.y;\n          }\n        }\n      }\n      if (length (q.xz) > 2. && abs (q.y - 0.84) < 0.03) {\n        q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a) + 0.5) / 6.);\n        q.y -= 0.84;\n        if (length (q.yz) < 0.03) {\n          col = mix (vec3 (1., 0.7, 0.), vec3 (0., 0., 1.),\n             step (0., sin (500. * length (q.yz))));\n          isRuf = false;\n          spec = -1.;\n        }\n      }\n    } else if (idObj == 2) {\n      if (length (ro.xz) > 1.82) {\n        f = SmoothBump (0.7, 1.1, 0.1, Fbm2 (40. * vec2 (10. * a, ro.y)));\n        col = vec3 (0.6, 0.6, 0.8) * mix (1., 0.9, f);\n      } else {\n        col = vec3 (0.6, 0.6, 0.7) * mix (1., 0.9, Noisefv3a (200. * ro));\n      }\n    } else if (idObj == 3) {\n      col = vec3 (0.8, 0.8, 0.2);\n      spec = 1.;\n    } else if (idObj == 4) {\n      col = vec3 (0.1, 0.2, 0.6);\n    } else if (idObj == 5) {\n      if (length (ro.xz) > 2.) col = vec3 (0.4, 0.4, 0.3) * (1. -\n         0.1 * SmoothBump (0.1, 0.3, 0.05, mod (30. *\n         (length (ro.xz) - 2.), 1.)));\n      else col = vec3 (0.5, 0.5, 0.45) * mix (1., 0.7, Noisefv2 (400. * ro.xz));\n    } else if (idObj == 11) {\n      col = (length (ro.xz) > 0.4) ? vec3 (0.2, 0.8, 0.2) : vec3 (0.8, 0.2, 0.8);\n      spec = 0.5;\n    } else if (idObj == 12) {\n      col = (length (ro.xz) > 0.4) ? vec3 (0.8, 0.3, 0.) : vec3 (1., 0., 0.);\n      spec = 1.;\n    }\n    if (spec >= 0.) {\n      if (idObj == 1 && isRuf || idObj == 5) vn = VaryNf (100. * ro, vn, 0.5);\n      sh = ObjSShadow (ro, sunDir);\n      col = col * (0.2 +\n         sh * (0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n         sh * spec * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n    }\n  } else {\n    sh = (rd.y < 0.) ? ObjSShadow (ro - (ro.y / rd.y) * rd, sunDir) : 1.;\n    col = sh * BgCol (ro, rd);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid SetState ()\n{\n  float tCyc, wkSpd, rAngH, rAngA, rAngL, rAngT;\n  wkSpd = 2. * pi * 0.55 / 7.;\n  tCyc = mod (wkSpd * tCur, 7.);\n  rAngT = - 0.07 * (4. * floor (wkSpd * tCur / 7.) + min (tCyc, 4.)) / wkSpd;\n  rAngTCs = vec2 (cos (rAngT), sin (rAngT));\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = -0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    rAngH = 0.;\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  rAngHCs = vec2 (cos (rAngH), sin (rAngH));\n  rAngACs = vec2 (cos (rAngA), sin (rAngA));\n  rAngLCs = vec2 (cos (rAngL), sin (rAngL));\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p, w;\n  float ti[7], rI, rO, hI, hO, hC, s;\n  ti[0] = 0.;  ti[1] = ti[0] + 0.3;  ti[2] = ti[1] + 0.1;  ti[3] = ti[2] + 0.4;\n  ti[4] = ti[3] + 0.1;  ti[5] = ti[4] + 0.3;  ti[6] = ti[5] + 0.3;\n  t = mod (0.02 * t, ti[6]);\n  rI = 1.6;  rO = 5.5;  hI = 0.7;  hO = 0.5;  hC = 0.2;\n  if (t < ti[1]) {\n    s = (t - ti[0]) / (ti[1] - ti[0]);\n    w = vec3 (rO - s * (rO - rI), hO + s * (hC - hO), -0.5 * pi);\n  } else if (t < ti[2]) {\n    s = (t - ti[1]) / (ti[2] - ti[1]);\n    w = vec3 (rI, hC + s * (hI - hC), -0.5 * pi);\n  } else if (t < ti[3]) {\n    s = (t - ti[2]) / (ti[3] - ti[2]);\n    w = vec3 (rI, hI, - 0.5 * pi + s * 1.333 * pi);\n  } else if (t < ti[4]) {\n    s = (t - ti[3]) / (ti[4] - ti[3]);\n    w = vec3 (rI, hI - s * (hI - hC), 0.833 * pi);\n  } else if (t < ti[5]) {\n    s = (t - ti[4]) / (ti[5] - ti[4]);\n    w = vec3 (rI + s * (rO - rI), hC + s * (hO - hC), 0.833 * pi);\n  } else {\n    s = (t - ti[5]) / (ti[6] - ti[5]);\n    w = vec3 (rO, hO, 0.833 * pi + s * 0.667 * pi);\n  }\n  p.xz = w.x * vec2 (cos (w.z), sin (w.z));  p.y = w.y;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 12.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  vuMode = 1.;\n  az = 0.;\n  el = (vuMode == 1.) ? 0.05 : -0.3;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  if (vuMode == 1.) {\n    ro = TrackPath (tCur);\n    vd = normalize (vec3 (0., 0.1, 0.) - ro);\n    az = clamp (az, -0.7 * pi, 0.7 * pi);\n    el = clamp (el, -0.2 * pi, 0.2 * pi);\n    az += 0.5 * pi + atan (- vd.z, vd.x);\n    el += asin (vd.y);\n    zmFac = 1.4 + 0.45 * length (ro.xz);\n  } else {\n    el = min (el, 0.);\n    zmFac = 3.6;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  if (vuMode == 0.) ro = vuMat * vec3 (0., 0.3, -6.);\n  SetState ();\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3XDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3XDl", "name": "Another Another Mobius", "author": "vox", "description": "Another Another Mobius", "tags": ["anotheranothermobius"], "likes": 3, "viewed": 521, "date": "1461963794", "time_retrieved": "2024-06-20T18:35:28.807530", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*iTime/PI/E/GR)\n#define saw(x) (acos(cos(x))/PI)\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\n\nvec2 rotatez( const in vec2 vPos, const in vec2 vSinCos )\n{\n\treturn vPos.xy * mat2(vSinCos.yx, -vSinCos.x, vSinCos.y);\n}\n\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, SinCos(fAngle) );\n}\n\nvec2 mobius(vec2 uv)\n{\n    float turns = saw(time)*3.0+3.0;\n    uv = rotatez(uv.xy, PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    vec2 xy = rotatez(uv.xy, PI*2.0*(rot)+PI/turns).xy;\n    xy = sign(xy)*log(abs(xy));\n    return vec2(saw(theta*turns/2.0), saw(xy.x*PI+iTime));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    uv = normalize(uv)/log(r+1.0);\n    uv += sin(vec2(time, time/PI*E*GR))*4.0*PI;\n    uv = mobius(uv); \n    \n    const int max_iterations =16;\n    \n    \n    float dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n    float map = sqrt(dist)*PI;\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        dist = clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0);\n        map += sqrt(dist)*noise;    \n        noise *= clamp(1.0-length(fwidth(uv)), 0.0 ,1.0)*\n            \t clamp(1.0-fwidth(map), 0.0 ,1.0);\n        \n     \tuv = uv*2.0-1.0;\n        r = length(uv);\n        uv = normalize(uv)/log(r+1.0);\n        \n        uv = rotatez(uv, iteration*2.0*PI+time);\n        //uv += sin(vec2(time+iteration*2.0*PI, time/PI*E*GR+iteration*2.0*PI))*scale*2.0*PI;\n        uv = mobius(uv);\n    }\n\n    \n    fragColor = texture(iChannel0, uv);\n    fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = smoothstep(0.0, .75, map)*vec4(phase(map*2.0+time), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3XDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3XRs", "name": "new retrowave", "author": "serkan3k", "description": "my first attempt, WIP", "tags": ["2d"], "likes": 1, "viewed": 934, "date": "1460751194", "time_retrieved": "2024-06-20T18:35:29.140011", "image_code": "//\n// tutorial:\n// https://www.shadertoy.com/view/Md23DV\n// palette: \n// http://www.colourlovers.com/palette/4162756/RetroWave\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r= vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    vec3 blue = vec3(0.0, 253.0, 241.0);\n    vec3 colpink = vec3(253.0, 0.0, 255.0);\n    vec3 black = vec3(0.0);\n    vec3 bluehue = vec3(0.0, 255.0, 213.0);\n    vec3 levepink = vec3(228.0, 0.0, 247.0);\n    \n    float alpha = 1.0;\n    vec3 pixel;\n    float y = iTime;\n    y = mod(y, 2.0) / 20.0;\n    if(r.y > 0.5){\n    \tpixel = bluehue +vec3(smoothstep(0.8, 0.40, r.y+sin(y)*2.0));\n    }\n    else{\n        pixel = colpink +vec3(smoothstep(0.3, 0.85, sqrt(r.y))); \n    }\n    float offset = -0.20;\n    float lineCoordinate = smoothstep(0.01, 0.5, abs(y));\n    float lineWidth = 0.0035;\n    \n    \n    if(r.y > 0.4 && r.y < 0.5){\n        lineCoordinate = y;\n        if(abs(r.y - 0.5 +lineCoordinate) < lineWidth) pixel = colpink;\n    }\n    else if(r.y > 0.3 && r.y < 0.4){\n        lineCoordinate = y;\n        if(abs(r.y - 0.4 +lineCoordinate) < lineWidth) pixel = colpink;\n    }\n    else if(r.y > 0.2 && r.y < 0.3){\n        lineCoordinate = y;\n        if(abs(r.y - 0.3 +lineCoordinate) < lineWidth) pixel = colpink;\n    }\n    else if(r.y > 0.1 && r.y < 0.2){\n        lineCoordinate = y;\n        if(abs(r.y - 0.2 +lineCoordinate) < lineWidth) pixel = colpink;\n    }\n    else if(r.y > 0.0 && r.y < 0.1){\n        lineCoordinate = y;\n        if(abs(r.y - 0.1 +lineCoordinate) < lineWidth) pixel = colpink;\n    }\n    lineCoordinate = 0.5;\n    // too lazy to loop\n    if(abs(r.x - lineCoordinate) < lineWidth*0.5 && r.y < 0.49) pixel = colpink;\n    if( abs(0.40+r.x - 1.05*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(0.20+r.x - 0.85*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(0.0+r.x - 0.65*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(-0.20+r.x - 0.45*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(-0.80+r.x + 0.45*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(-1.0+r.x + 0.65*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(-1.2+r.x + 0.85*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    if( abs(-1.4+r.x + 1.05*r.y) < lineWidth*0.5 && r.y <0.49 ) pixel = colpink;\n    fragColor = vec4(pixel, alpha);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3XRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3XWS", "name": "ForceField", "author": "Draedrus", "description": "A force shield shader, it needs some optimization by the way ! I will do that soon.", "tags": ["raytracing", "raymarching", "voronoi", "heightmap", "forcefield"], "likes": 6, "viewed": 576, "date": "1461066312", "time_retrieved": "2024-06-20T18:35:31.643418", "image_code": "#define NUM_STEPS 50\n#define CAMDIST 20.0\n#define CAMROTSPEED 0.4\n#define FAR 200.0\n#define NEAR 1.0\n#define DAYNNIGHTSPEED 1.01\n#define DEPTH 1.0\n#define OCTAVES_PERLIN 8\n#define ASTRESIZE 1.8\n#define ANIMATE\n\n#define CAMPOS vec3(0.0, 10.0, 100.0)\n#define FORCEFIELDPOS vec3(0.0, 0.0, 80.0)\n#define CREEPSCALE 2.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight sun = Light(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec4(1.0, 1.0, 0.3, 1.0),\n    2.0,\n    2.0);\nLight moon = Light(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec4(0.9, 0.9, 1.0, 1.0),\n    2.0,\n    0.3);\n\nvec3 dirtColor = vec3(1.0, 0.9, 0.9);\nvec3 grassColor = vec3(0.05, 0.4, 0.09);\nvec3 skyDayColor = vec3(0.4, 0.4, 1.0);\nvec3 skyNightColor = vec3(0.2, 0.2, 0.4);\nvec3 creepColor = vec3(0.6, 0.3, 0.7);\n\nfloat forcefieldRadius = 10.0;\nfloat forcefieldOpacity = 0.6;\nfloat forcefieldIntersectionSize = 0.15;\nfloat forcefieldDiffuseFactor = 1.4;\nfloat forcefieldSpecularFactor = 1.7;\nvec3 forcefieldColor = vec3(0.0, 0.3, 1.0);\nvec3 forcefieldVeinsColor = vec3(0.0, 0.5, 0.7);\n\nfloat hash(vec2 x) {\n    float h = dot(x, vec2(42.69, 51.42));\n\treturn fract(sin(h)*50403.43434);   \n}\n\nfloat noise(vec2 p) {\n    return mix(hash(p), hash(p+vec2(0.001, 0.001)), fract(p.x));\n}\n\nfloat voronoi(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi3( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n+g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n+g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>1.5 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nfloat tiles(vec2 uv) {\n\treturn smoothstep(\n        0.4,\n        0.5,\n        max(\n \t\t\tabs(\n                fract(8.0*uv.x - 0.5*mod(floor(8.0*uv.y), 2.0) ) - 0.5),\n \t\t\tabs(fract(8.0*uv.y) - 0.5)\n        )\n    );\n}\n\n/***************************************\n * Hexagonal tiles thanks to klk from https://www.shadertoy.com/view/lt2SzG\n ***************************************/\n\n#define pi 3.14159\n\n\nfloat vlx(vec2 uv, out float a)\n{\n    float v=0.0;\n    vec2 lp=uv-vec2(-0.5,0.5*tan(pi/6.0));\n    v=length(lp);a=atan(lp.y, lp.x);\n\n    vec2 lp1=uv-vec2(0.5,0.5*tan(pi/6.0));\n    float v1=length(lp1);\n    if(v1<v){v=v1;a=atan(lp1.y, lp1.x);}\n\n    vec2 lp2=uv-vec2( 0.0,-0.5/cos(pi/6.0));\n    float v2=length(lp2);\n    if(v2<v){v=v2;a=atan(lp2.y, lp2.x);}\n    \n    a=(a/pi*0.5+0.5);\n    \n    return v;\n}\n\nvec4 hex(vec2 uv, out float ang1, out float ang2)\n{\n    float x=uv.x;\n    float y=uv.y;\n    float h=1.0/cos(pi/6.0);\n    \n\tx+=(fract(y*h/2.0)>0.5?0.0:0.5);\n    x=fract(x)-0.5;\n    y=fract(y*h)/h-0.5/h;\n    float n=6.0;\n    float a=atan(x,y)/pi/2.0;\n    float v=length(vec2(x,y));\n    vec2 p=vec2(0,0);\n    vec2 p0=vec2(sin(pi/6.0),cos(pi/6.0));\n    if(y<0.0)p0.y=-p0.y;\n    if(x<0.0)p0.x=-p0.x;\n\tfloat v0=length(vec2(x,y)-p0);\n    if(v0<v)\n    {\n        v=v0;p=p0;\n\t    x=x-p.x;\n\t    y=y-p.y;\n    }\n\n    a=atan(x,y);\n    v=length(vec2(x,y))*2.0;\n    v=(v*5.0+a*pi/32.0)*10.0;\n\tfloat v1=0.0;\n    float v2=0.0;\n\n    v1=vlx(vec2(x,y), ang1);\n    v2=vlx(vec2(x,-y), ang2);\n    return vec4(x,y,v1,v2);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES_PERLIN+2;i++) {\n        total += (1.0/float(i))*snoise(V.xz);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdGaussianRadialBlob(vec3 pos, vec3 originalPos, float radius)\n{\n    return (snoise((pos-FORCEFIELDPOS).xz+iTime))*0.2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float d2) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float t = -1.0;\n    float d = -1.0;\n   \td2 = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n            d2 = (-B+sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n            d2 = (-B-sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\nfloat sdTerrain(vec3 p) {\n    float h = 0.0;\n    float f = 0.09;\n    float amp = 3.0;\n    for(int i = 0;i<7;i++) {\n        h+=snoise(p.xz*f)*amp;\n        f *= 1.9;\n        amp *= 0.22;\n    }\n\treturn DEPTH+h;//snoise(p.xz);//cos(p.x)+sin(p.z);\n}\n\nvec2 map(vec3 p) {\n    vec2 ret = vec2(-1.0, -1.0);\n    float t = sdTerrain(p);\n    float rb = sdGaussianRadialBlob(p,FORCEFIELDPOS/*vec3(0.0, 0.0, 60.0)*/, 1.0);\n    if(t<rb)\n  \t\tret.xy = vec2(t, 0.0);\n    else{\n        float s = sdSphere(FORCEFIELDPOS-p, forcefieldRadius);\n        if(min(rb, -s)==-s) {\n        \tret = vec2((t+rb)*CREEPSCALE, 1.0);\n        }else{\n            ret = vec2(t, 0.0);\n        }\n    }\n    //ret.x = max(ret.x, -s);\n    return ret;\n    /*return max(-sdSphere(p, vec3(0.0, 0.0, 80.0), forcefieldRadius),\n               min(sdTerrain(p),\n                   sdGaussianRadialBlob(p, vec3(0.0, 0.0, 60.0), 30.0)\n                   )\n               );*/\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;    \n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    vec2 m;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        m = map(pos);\n\t\tfloat h = pos.y - m.x;\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn vec2(t, m.y);\n}\n\nvec3 TerrainColorMap(vec3 rd, vec3 p, vec3 n, vec3 l, float depth) {\n    float _noise = snoise(p.xz*0.2);\n    float _hash = perlin(p.xyz);\n    \n    float Lambert = max(0.0, dot(n, -l));\n    \n    float depthFactor = (FAR-depth)/(FAR-NEAR);\n    \n    return mix(\n        depthFactor*mix(dirtColor, grassColor, _noise)*(_hash+1.5)*0.2+Lambert*0.3,\n        mix(skyDayColor, skyNightColor, max(0.0, dot(rd, l)))*(1.0-depthFactor),\n        1.0-depthFactor);\n}\n\nvec3 CreepColorMap(vec3 rd, vec3 p, vec3 n, vec3 l, float depth) {\n    float _noise = snoise(p.xz*0.2);\n    float _hash = perlin((p-FORCEFIELDPOS).xyz+vec3(iTime*1.0, iTime, iTime*-1.0));\n    \n    float Lambert = max(0.0, dot(n, -l));\n    \n    float depthFactor = (FAR-depth)/(FAR-NEAR);\n    \n    return mix(\n        depthFactor*creepColor*(_hash+0.8)*0.7+Lambert*0.3,\n        mix(skyDayColor, skyNightColor, max(0.0, dot(rd, l)))*(1.0-depthFactor),\n        1.0-depthFactor);\n}\n\nvec3 SkyColorMap(vec2 pixel, vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 l, float depth) {\n    float _noise = snoise(p.xz*0.000001);\n    float _hash = perlin(vec3(0.0, pixel.x, pixel.y)+p.xyz*0.000001);\n    \n    vec3 color = mix(skyDayColor, skyDayColor*0.8, pixel.y);\n    color = mix(skyDayColor, skyNightColor, max(0.0, dot(rd, l))); \n    // sun\n    float t3 = -1.0;\n    float t2 = IntersectSphere(ro, rd, sun.o, ASTRESIZE, t3);\n    if(t2>0.0) {\n        vec3 intersectP = ro+rd*t2;\n        vec3 normal = normalize(intersectP-sun.o);\n        float gradient = dot(-rd, normal);\n        color = mix(color, sun.diffuseColor.rgb, pow(gradient, sun.shininess)*sun.power);\n    }\n    // moon\n    t2 = IntersectSphere(ro, rd, -sun.o, ASTRESIZE, t3);\n    if(t2>0.0) {\n        vec3 intersectP = ro+rd*t2;\n        vec3 normal = normalize(intersectP+moon.o);\n        float gradient = dot(-rd, normal);\n        color = mix(color, moon.diffuseColor.rgb, pow(gradient, moon.shininess)*moon.power);\n    }\n    \n    \n    return mix(color, vec3(1.0), (1.0+snoise(p.yz*0.01))*0.5*(pixel.y*0.2));\n}\n\nvec3 ForceFieldColorMap(vec2 pixel, vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 l, float depthFF, float depthTerrain) {\n    return vec3(0.0);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;/*+vec3(\n        cos(t)*CAMDIST,\n        0.0,\n        sin(t)*CAMDIST);*///vec3(cos(t), 4.0, sin(t))*CAMDIST;\n\trd = normalize(rdi*rotY);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    lPos = lPos*rotX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n\n    vec3 forcefieldPos = FORCEFIELDPOS;\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(pixel, 1.0);\n\tvec3 lPos = vec3(0.0, 100.0, 100.0);\n    #ifdef oldsys\n    camPos(Time*CAMROTSPEED,\n           rd, vec3(0.0, 4.0, 100.0),\n           ro, rd);\n    //lightPos(Time, forcefieldPos);\n    \n    mat3 ca = setCamera(ro, rd, vec3(0.0, 1.0, 0.0));\n    rd = ca*rd;\n    #else\n    \tro.x = forcefieldPos.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    \tro.z = forcefieldPos.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    \trd = normalize(rd);\n        mat3 ca = setCamera(ro, forcefieldPos, vec3(0.0, 1.0, 0.0));\n        rd = ca*rd;\n    #endif\n    lightPos(Time*DAYNNIGHTSPEED, lPos);\n    \n    vec2 rm = raymarch(ro, rd, 0.0, FAR);\n    float t = rm.x;\n    vec3 p = ro+rd*t;\n    vec3 n = normalize(mapNormal(p, 0.001));\n    vec3 l = normalize(p - lPos);\n    \n    sun.o = lPos;\n    sun.d = l;\n    \n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if(t>0.0 && t<FAR && rm.y==0.0) {\n    \t//color = vec3(1.0/t);\n        color = TerrainColorMap(rd, p, n, l, t);\n    }else if(t>0.0 && t<FAR && rm.y==1.0) {\n        color = CreepColorMap(rd, p, n, l, t);\n    }else{\n    \tcolor = SkyColorMap(pixel, ro, rd, p, n, l, t);\n    }\n    float t3;\n    float t2 = IntersectSphere(ro, rd, forcefieldPos, forcefieldRadius, t3);\n    if(abs(t2-t)<forcefieldIntersectionSize || (t3>=0.0 && abs(t2-t)<forcefieldIntersectionSize)) {\n        color = mix(color, forcefieldColor*(1.0-(abs(t2-t)/forcefieldIntersectionSize)), forcefieldOpacity);\n    }\n    if(t2>0.0 && t2<t) {\n        vec3 p = ro+rd*t2;\n        float v = voronoi3(p.xz).x;\n        vec2 tilesUV = p.xz;\n        tilesUV.y += sin((tilesUV.x+iTime)*10.0)*0.01;\n        float a;\n        vec3 ffn = normalize(p-forcefieldPos)*\n            hex(tilesUV*0.5, a, a).xyz\n            //mix(1.0, 1.0-tiles(tilesUV*0.5)*1.0, max(0.0, dot(rd, l)))\n            ;//smoothstep( 0.01, 0.02, v );//((pow(1.0-v, 0.3)*1.5));\n        vec3 ffc = forcefieldColor;\n    \n        float diffuseTerm = max(0.0, dot(-l, ffn));\n        float specularTerm = max(0.0, dot(-l, reflect(rd, ffn)));\n        ffc += diffuseTerm*forcefieldDiffuseFactor;\n        ffc += specularTerm*forcefieldSpecularFactor*pow(2.0, specularTerm);\n    \n    \tfloat edge = 1.0-(abs(t3-t2))/(forcefieldRadius*2.0);\n        color = mix(color, ffc, forcefieldOpacity*edge);\n        if(t3>=0.0 && t3<t) {\n            vec3 p = ro+rd*t3;\n            float v = voronoi3(p.xz).x;\n        \ttilesUV = p.xz;\n        \ttilesUV.y += sin((tilesUV.x+iTime)*10.0)*0.01;\n\n            ffn = normalize(p-forcefieldPos)*\n            \thex(tilesUV*0.5, a, a).xyz\n                //mix(1.0, tiles(tilesUV*0.5)*1.0, max(0.0, dot(rd, l)))\n                ;//*smoothstep( 0.01, 0.05, v );//((pow(1.0-v, 0.3)*1.5));\n            diffuseTerm = max(0.0, dot(-l, ffn));\n            specularTerm = max(0.0, dot(-l, reflect(rd, ffn)));\n            \n            ffc += diffuseTerm*forcefieldDiffuseFactor;\n        \tffc += specularTerm*forcefieldSpecularFactor*pow(2.0, specularTerm);\n            color = mix(color, ffc, forcefieldOpacity*edge);\n        }\n        color = mix(color, forcefieldVeinsColor, (1.0-smoothstep(0.02, 0.1, v))*forcefieldOpacity);\n    \tcolor = mix(color, vec3(1.0), edge*0.5);\n        //color = mix(color, forcefieldColor, 1.0-max(0.0, 1.0-dot(normalize(ffn), normalize(rd)))); \n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3XWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscSDS", "name": "Spiral Tree", "author": "vox", "description": "Spiral Tree", "tags": ["spiraltree"], "likes": 0, "viewed": 460, "date": "1461082705", "time_retrieved": "2024-06-20T18:35:32.806914", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time (float(__LINE__)+iTime/PI)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 stair(vec2 x)\n{\n    return vec2(stair(x.x), stair(x.y));\n}\n\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(iTime)*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\nvec4 spiral(vec4 uv)\n{\n    //uv = normalize(uv)*log(length(uv)+1.0);\n    float r = length(uv.xy);//log(length(uv)+1.0)*2.0*PI;\n    \n    r = r*2.0;\n    float theta = atan(uv.y, uv.x);\n    \n    float arms = 2.0;\n    float turns = 2.0;\n    float turnage = (r*turns);\n    theta = mod((theta+2.0*PI), 2.0*PI)+turnage*PI;\n    \n    \n    float u = saw(turnage*PI*2.0);\n    float v = saw(theta*arms);\n    /*\n    float tempr = length(vec2(u, v)*2.0-1.0)*4.0*PI;\n    float temptheta = atan(v*2.0-1.0, u*2.0-1.0)+tempr*2.0*PI/turns;\n    \n    u = saw(tempr);\n    v = saw(temptheta);\n    */\n    return vec4(u, v,\n               \tr, theta);\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5*uv.x;\n\telse\n\t\treturn 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 uv = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    float amplitude = 16.0;\n    float scale = pow(E, 0.0);\n    \n\tconst int max_iterations =3;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        uv.xy = tree(uv.xy);\n    }\n    \n    \n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        uv = spiral(uv);\n        map += saw(uv.z+uv.w);\n    }\n    \n    \n    \n    \n    fragColor.rg = uv.rg;//saw(uv.zw);//saw(uv.zw*PI);\n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    \n    map = map*PI + time*PI;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);\n    return;\n/*\n\tconst int max_iterations = 8;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        noise += clamp(1.0-fwidth(map), 0.0, 1.0);\n        \n        uv = tree(uv); \n        \n        map += square(uv, float(i)/float(max_iterations))/noise;\n    } \n    map = map*PI + time;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);*/\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscSW7", "name": "Fractal Experiment 16", "author": "aiekick", "description": "Fractal Experiment 16", "tags": ["fractal", "experiment", "16"], "likes": 6, "viewed": 560, "date": "1459556251", "time_retrieved": "2024-06-20T18:35:33.534337", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on https://www.shadertoy.com/view/4stXR7\n*/\n\nconst vec3 ld = vec3(0.,1., .5);\nfloat dstepf = 0.0;\nfloat t = 0.;\n\nvec2 path(float z){return sin(z*.3 + vec2(1.6,0));}\n\nfloat fractus(vec3 p)\n{\n\tvec2 z = p.xy;\n    vec2 c = vec2(0.28,-0.56) * sin(p.z-cos(p.z));\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<5.;i++)\n    {\n\t\t//if (i/5. > (sin(iTime*.5)*.5+.5)) break;\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n        z = vec2(z.x * z.x - z.y * z.y, 1.5 * z.x * z.y) + c;\n    }\n\treturn 1. - sqrt(k/h)*log(h);   \n}\n\nvec2 df(vec3 p)\n{\n    p.xy += path(p.z);\n\tfloat obj = min(1., fractus(p));\n\tvec2 res = vec2(obj, 1.);\n\treturn res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// from velocibox by zackpudil : https://www.shadertoy.com/view/lsdXD8\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = nor(p, prec);\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.08,0.32,0.47);//vec3(0.2);\n    lin += 1.0*dif*vec3(1,1,0.84);//vec3(1, .97, .85);\n    lin += 2.5*spe*dif*vec3(1,1,0.84);//vec3(1, .97, .85);\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten*calcAO(p, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 g = fragCoord;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tvec4 f = vec4(0);\n\t\n\tt = iTime*2.;\n    \n\tdstepf = 1.5;\n\t\n    vec3 rayOrg = vec3(vec2(0,0),t);\n    rayOrg.xy -= path(t);\n\n    vec3 camUp = vec3(0,1,0);\n    // thanks to shane\n    vec3 camOrg = vec3(vec2(0,0), t+.1);\n\tcamOrg.xy -= path(t+.1);\n\t\n\tfloat fov = 0.8;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tvec2 s = vec2(0.01);\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 40.;\n\tfloat sMin = 0.00001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (s.x<sMin || d>dMax) break;\n\t\ts = df(p);\n\t\td += s.x * 0.3;\n\t\tp = rayOrg + rayDir * d;\t\n        dstepf += 0.005;\n\t}\n\t\n\tfragColor.rgb = vec3(0.89,0.91,1) * lighting(p, rayOrg, rayDir, 0.001) * dstepf; \n\tfragColor.rgb = mix( fragColor.rgb, vec3(0.89,0.91,1), 1.0-exp( -0.007*d*d ) ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscSzj", "name": "simple raymarching tunnel", "author": "flewww", "description": "Simple tunnel. using raymarching for rendering", "tags": ["raymarching", "tunnel", "square"], "likes": 7, "viewed": 723, "date": "1460152453", "time_retrieved": "2024-06-20T18:35:33.534337", "image_code": "float map(vec3 pos) {\n    vec3 tmp = vec3(1.0) - abs(pos);\n    return min(tmp.x, tmp.y);\n}\n\nvec3 color(vec3 pos) {\n    vec3 blue = vec3(0.5, 0.5, 1.0);\n    vec3 red  = vec3(1.0, 0.5, 0.5);\n    return mix(blue, red, step(0.5, fract(pos.z)));\n}\n\nvec3 march(vec2 uv, vec3 cam_pos) {\n    vec3 pos = cam_pos;\n    vec3 dir = normalize(vec3(uv, 1));\n    float d;\n    for (int i=0; i<100; i++){\n        d = map(pos);\n        if (d < 0.01) {\n            return color(pos)*exp(-(pos.z-cam_pos.z)*0.6);\n        }\n        pos += d*dir;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 cam_pos = vec3(sin(iTime)*0.5, sin(iTime*10.0)*0.1, iTime);\n    fragColor = vec4(march(uv, cam_pos), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscSzS", "name": "G1shader", "author": "sreveloa", "description": "movement of a ball", "tags": ["2d"], "likes": 0, "viewed": 85, "date": "1459855259", "time_retrieved": "2024-06-20T18:35:33.534337", "image_code": "#define RADIUS 0.05\nvec2 uv;\nvec4 col;\nvoid drawCircle( vec2 center, float radius )\n{\n\tvec2 dif = center - uv;\n\tif( length(dif)*length(dif) < radius*radius )\n\t{\n\tcol = vec4(1.0);\n\t}\n}\n\nvec2 findCenter()\n{\n\tvec2 start = vec2(0.5,0.5); \n\tfloat y = -0.25;\n\tfloat secs = floor(iTime);\t\n\tfloat dec = fract( iTime );\n\tfloat restant = fract( iTime * 0.5 );\n\tif( restant >= 0.5  )\n\t{\n\t\ty = 0.25 - (restant-0.5);\n\t}\n\telse\n\t{\n\t\ty = -0.25 + restant;\n\t}\n\t\treturn start + vec2(y);\t\n}\n\nbool pincharCirculo(vec2 center, float radius)\n{\n    if(iMouse.z>0.0)\n    {\n        vec2 p=iMouse.xy/iResolution.xy;\n        if (distance(center, p) <= radius)\n        {\n            return true;\n        }\n        }\nreturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tcol = vec4(0);\n\tuv = fragCoord.xy / iResolution.xy;\n\tvec2 center = findCenter();\n\tif (!pincharCirculo(center, RADIUS))\n\t\tdrawCircle( center, RADIUS );\n\t\n\tfragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscXRs", "name": "Clouds with shadow", "author": "afl_ext", "description": "Move mouse with click to move the sun, I love this noise functions and things that can be done with it", "tags": ["procedural", "clouds", "sky"], "likes": 31, "viewed": 1961, "date": "1460756607", "time_retrieved": "2024-06-20T18:35:33.976754", "image_code": "// afl_ext 2016\n\n#define HOW_CLOUDY 0.4\n#define SHADOW_THRESHOLD 0.2\n#define SHADOW 0.2\n#define SUBSURFACE 1.0\n#define WIND_DIRECTION 2.0\n#define TIME_SCALE 0.7\n#define SCALE 0.5\n#define ENABLE_SHAFTS\n\nmat2 RM = mat2(cos(WIND_DIRECTION), -sin(WIND_DIRECTION), sin(WIND_DIRECTION), cos(WIND_DIRECTION));\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t    mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02;\n    f -= 0.25000*noise( p ); p = p*2.03;\n    f += 0.12500*noise( p ); p = p*3.01;\n    f += 0.06250*noise( p ); p = p*3.04;\n    f += 0.03500*noise( p ); p = p*4.01;\n    f += 0.01250*noise( p ); p = p*4.04;\n    f -= 0.00125*noise( p );\n    return f/0.984375;\n}\n\nfloat cloud(vec3 p)\n{\n\tp-=fbm(vec3(p.x,p.y,0.0)*0.5)*1.25;\n\tfloat a = min((fbm(p*3.0)*2.2-1.1), 0.0);\n\treturn a*a;\n}\n\nfloat shadow = 1.0;\n\n\nfloat clouds(vec2 p){\n\tfloat ic = cloud(vec3(p * 2.0, iTime*0.01 * TIME_SCALE)) / HOW_CLOUDY;\n\tfloat init = smoothstep(0.1, 1.0, ic) * 10.0;\n\tshadow = smoothstep(0.0, SHADOW_THRESHOLD, ic) * SHADOW + (1.0 - SHADOW);\n\tinit = (init * cloud(vec3(p * (6.0), iTime*0.01 * TIME_SCALE)) * ic);\n\tinit = (init * (cloud(vec3(p * (11.0), iTime*0.01 * TIME_SCALE))*0.5 + 0.4) * init);\n\treturn min(1.0, init);\n}\nfloat cloudslowres(vec2 p){\n\tfloat ic = 1.0 - cloud(vec3(p * 2.0, iTime*0.01 * TIME_SCALE)) / HOW_CLOUDY;\n\tfloat init = smoothstep(0.1, 1.0, ic) * 1.0;\n\treturn min(5.0, init);\n}\n\nvec2 ratio = vec2(1.0, 1.0);\n\nvec3 getresult(){\n\tvec2 surfacePosition = ((( gl_FragCoord.xy / iResolution.xy ) * vec2(iResolution.x / iResolution.y, 1.0)) * 2.0 - 1.0)*SCALE;\n\tvec2 position = RM*( surfacePosition);\n\tvec2 sun = RM * ((iMouse.xy/ iResolution.xy)* vec2(iResolution.x / iResolution.y, 1.0)*2.0-1.0) * SCALE;\n\tfloat dst = distance(sun * ratio, position * ratio);\n\tfloat suni = pow(dst + 1.0, -10.0);\n\tfloat shaft =0.0;\n\tfloat st = 1.0;\n\tvec2 dir = sun - position;\n\tfloat c = clouds(position);\n\t#ifdef ENABLE_SHAFTS\n\tfor(int i=0;i<20;i++){\n\t\tfloat occl = cloudslowres(position + dir * st);\n\t\tst *= 0.8;\n\t\tshaft += max(0.0, (1.0 - occl));\n\t}\n\t#endif\n    shadow = min(1.0, shadow + suni * suni * 0.2 * SUBSURFACE);\n\tsuni *= (shaft * 0.1);\n\treturn pow(mix(vec3(shadow), pow(vec3(0.23, 0.33, 0.48), vec3(2.2)) + suni, c), vec3(1.0/2.2));\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = getresult().xyzz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscXRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscXz2", "name": "yolo426969", "author": "jakeTboss", "description": "yolo", "tags": ["yolo"], "likes": 0, "viewed": 129, "date": "1460202756", "time_retrieved": "2024-06-20T18:35:33.982601", "image_code": "void mainImage( out vec4 f, in vec2 p )\n{\n    float n = 0.;\n    vec2 c = vec2(-.745,.186) + 3. * (p.xy/iResolution.y-.75)*pow(.01,1.+cos(4 * iTime)*3.), z=c*n;\n   \n    for( int i=0; i<1920; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y ) + c;\n \n        if( dot(z,z)>1e4 ) break;\n \n        n++;\n    }\n   \n    f = .5 + .5*cos( vec4(30,40,110,0) + .05*(n - log2(log2(dot(z,z)))) );\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscXzj", "name": "Ambers First Code", "author": "zackpudil", "description": "My friends first code", "tags": ["newbie"], "likes": 2, "viewed": 155, "date": "1460172994", "time_retrieved": "2024-06-20T18:35:33.982831", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord )\n \n{\n    vec2 COORDINATES = -1. + 2. *(fragCoord.xy/iResolution.xy);\n    COORDINATES.x *= iResolution.x/iResolution.y;\n    COORDINATES.y -= 0.2;\n    float ANGLE = abs (atan (COORDINATES.x, COORDINATES.y) / 3.14);\n    float RADIUS = length (COORDINATES);\n    float SHAPE = (13. * ANGLE - 22. * ANGLE * ANGLE + 10. * ANGLE * ANGLE * ANGLE)/ (6. - 5.* ANGLE); \n    vec3 HCOLOR = mix (vec3 (1, 1, 0.7), vec3 (1, 0, .25) + .3 * cos ( iTime), smoothstep (-0.01, 0.01, SHAPE - RADIUS) );\n    fragColor = vec4 (HCOLOR, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdGzs", "name": "Julia3D", "author": "Varcho", "description": "julia set visualization\n", "tags": ["fractal"], "likes": 3, "viewed": 547, "date": "1461436582", "time_retrieved": "2024-06-20T18:35:35.110239", "image_code": "#define EPSILON 0.01\n#define BOUNDING_RAD 3.0\n#define TEX_SCALE 10.0\n\nvec3 getNormal(vec3 pos, vec4 c, float k);\n\nvec4 quatMultiply(vec4 a, vec4 b) {\n    return vec4(a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w, \n                a.y * b.x + a.x * b.y - a.w * b.z + a.z * b.w, \n                a.z * b.x + a.w * b.y + a.x * b.z - a.y * b.w, \n                a.w * b.x - a.z * b.y + a.y * b.z + a.x * b.w);\n}\n\nfloat intersectJulia(vec3 ro, vec3 rd, vec4 c, float k) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 300; i++) {\n        vec4 z = vec4(ro, k);\n    \tvec4 zp = vec4(1., 0.0, 0.0, 0.0);\n        \n        // iterate to find distance\n        for (int j = 0; j < 15; j++) {\n        \tzp = 2.0 * quatMultiply(z, zp);\n            z = quatMultiply(z, z) + c;\n            if( dot( z, z ) > 100.0 ) {\n            \tbreak; \n            }\n        }\n        float norm_z = length(z);\n    \tt = (.5 * norm_z * log(norm_z)) / length(zp);\n        d+=t;\n        ro += rd * t;\n        if (t < EPSILON || dot(ro, ro) > BOUNDING_RAD) {\n        \tbreak;\n        }\n    }\n    if (t <EPSILON) {\n    \treturn d;\n    } else {\n    \treturn -1.0;\n    }\n}\n\nvec3 getColor(vec3 pos, vec3 view, vec3 n, vec4 c, float k) {\n    vec3 light1 = normalize(vec3(1., 1., 1.));\n    vec3 light2 = vec3(0., 1., 0.);\n    vec3 light3 = vec3(0., 0., 1.);\n    \n    vec3 norm = getNormal(pos, c, k);\n    float t1 = intersectJulia(pos + 10. * EPSILON * light1, \n                              -light1, c, k);\n    float shadowed1 = 1.0;\n    if (t1 < 0.0) {\n    \tshadowed1 = 0.0;\n    } \n    shadowed1 = smoothstep(-0.0, 0.01, t1);\n    \n    return shadowed1 * vec3(max(dot(norm, light1), 0.0)) * vec3(1., 0., 0.)\n        + .6 * abs(n) + .6 *abs(pos);\n}\n\nvec3 getBackgroundColor(vec3 dir) {\n    float n = dot(dir, vec3(0., 1., 0.));\n    vec3 red = smoothstep(.3, .4, n) * vec3(.81, 0.06, 0.15);\n    vec3 white = smoothstep(.4, .3, abs(n)) * vec3(1.0);\n    vec3 green = smoothstep(.3, .4, -n) * vec3(0.0, 0.61, 0.28);\n    return vec3(.1);//red + white + green;\n}\n\nvec3 getNormal(vec3 pos, vec4 c, float k) {\n    \n    vec4 zp = vec4(pos, k);\n\tfloat DELTA = 0.001;\n    \n    // use basic central differences to find normal\n    vec4 nxp = zp + vec4(DELTA, 0.0, 0.0, 0.0);\n    vec4 nxm = zp - vec4(DELTA, 0.0, 0.0, 0.0);\n    vec4 nyp = zp + vec4(0.0, DELTA, 0.0, 0.0);\n    vec4 nym = zp - vec4(0.0, DELTA, 0.0, 0.0);\n    vec4 nzp = zp + vec4(0.0, 0.0, DELTA, 0.0);\n    vec4 nzm = zp - vec4(0.0, 0.0, DELTA, 0.0);\n    \n    // iterate to determine divergence <- need better description\n    for (int i = 0; i < 10; i++) {\n    \tnxp = quatMultiply(nxp, nxp) + c;\n        nxm = quatMultiply(nxm, nxm) + c;\n        nyp = quatMultiply(nyp, nyp) + c;\n        nym = quatMultiply(nym, nym) + c;\n        nzp = quatMultiply(nzp, nzp) + c;\n        nzm = quatMultiply(nzm, nzm) + c;\n    }\n        \n    // grad = length of vectors\n    return normalize(vec3(length(nxp) - length(nxm),\n                         length(nyp) - length(nym),\n                         length(nzp) - length(nzm)));//));\n}\n\n// basic sphere intersection to determine if raymarching necessary\nfloat intersectSphere(in vec3 ro, in vec3 rd) {\n   float B, C, d, t0, t1, t;\n   float radius = BOUNDING_RAD;\n   B = 2. * dot( ro, rd );\n   C = dot( ro, ro ) - radius;\n   d = sqrt( B*B - 4. *C );\n   t0 = ( -B + d ) * 0.5;\n   t1 = ( -B - d ) * 0.5;\n   t = min( t0, t1 );\n   return t;\n}\n\n\n//takes in 3d point (which lies on ray)..\n// and returns closest distance to point\nfloat map( in vec3 p )\n{   \n    // ground plane\n\tfloat plane =  p.y+2.0;\n    return plane;\n}\n\n//start with original poin (ro), and original direction (rd)\n// then iterate the point along the ray \n// with each iteration move the point x units along the ray\n// where x is the distance from the point to the closest object in the scene (via map)\n// once x is small enough, then an intersection can be assumed\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 40.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n    //use epsilon-delta limit to approximate normal\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    float theta = iTime/5.0;\n    mat3 rotMat = mat3(cos(theta), 0.0, sin(theta),\n                      0.0, 1.0, 0.0,\n                      -sin(theta), 0.0, cos(theta));\n    \n    vec3 view = vec3(0.0, 0.0, -1.);\n\tvec3 rd = normalize( vec3(p,-1.) );\n    \n    view = view * rotMat;\n    rd = rd * rotMat;\n    \n    vec3 ro = -3. * view;\n    vec3 eye = ro;\n    vec3 col = getBackgroundColor(rd);\n    vec4 mu = vec4(abs(sin(iTime / 3.0)),\n                       .8 * sin(iTime / 5.0),\n                       .5 * sin(iTime / 7.0),\n                       .5 * sin(iTime / 11.0));\n        \n    mu = vec4(sin(iTime),cos(iTime),.0,.0);\n    float k = 0.0;\n    bool s_inter = false;\n    bool j_inter = false;\n    \n    float t = intersectSphere(ro, rd);\n    if (t > 0.0) {\n        s_inter = true;\n        // update ro to be on radius of bounding sphere\n        ro += t * rd;\n        \n        // k is chosen somewhat arbitrarily to limit 4D quaternion space\n        // to 3D Euclidean\n        t = intersectJulia(ro, rd, mu, k);\n        if (t > 0.0) {\n            j_inter = true;\n        \tro += t * rd;\n            vec3 norm = getNormal(ro, mu, k);\n            col = getColor(ro, eye, norm, mu, k);\n        } \n    } \n   \t\n    // Ground plane coloring\n    if (!j_inter) {\n    \tfloat t = intersect(ro, rd);\n        if (t > 0.) {\n            ro += t * rd;\n            vec3 norm = calcNormal(ro);\n            ro = ro + EPSILON * norm;\n            \n            // trace towards ground plane\n            col = ro;\n            t = intersectJulia(ro, vec3(1., 2., 0.), mu, k);\n            \n            col = texture( iChannel0, ro.xz / TEX_SCALE ).xyz;\n            if (t > -0.1) {\n            \tcol *= .6;\n            }\n            \n        }\n    }\n    fragColor = vec4(col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdSRs", "name": "Boxed In", "author": "Neph", "description": "Experimenting. Still learning so probably a lot wrong.\nNot sure how to avoid recursion between the reflection and refraction functions.", "tags": ["raymarch", "texture", "color", "mirror", "lights", "reflect", "refract"], "likes": 1, "viewed": 140, "date": "1460928243", "time_retrieved": "2024-06-20T18:35:35.116313", "image_code": "#define MAXREFLECTIONS 2\n#define MAXITER 64\n\nstruct color{\n  vec3  c;\n  float d;\n  vec2  m;\n  vec2  r;\n};\n\ncolor map (vec3 p){\n        color final;\n    \tfinal.c = vec3(1.0);\n    \tfinal.d = 1.0;\n    \tfinal.m = vec2(0.0);\n    \tfinal.r = vec2(0.0);\n    \t\n    \tcolor sphere;\n    \tsphere.c = vec3(1.0, 0.0, 0.0);\n    \tsphere.d = length(p + vec3(0.8, -0.8, 0.0)) - 0.2;\n    \tsphere.m = vec2(0.0);\n    \tsphere.r = vec2(0.0);\n    \n    \tcolor msphere;\n    \tmsphere.c = vec3(0.0);\n    \tmsphere.d = length(p + vec3(-0.5, 1.0, 0.0)) - 0.5;\n    \tmsphere.m = vec2(1.0, 0.3);\n    \tmsphere.r = vec2(0.0);\n    \n    \tcolor rsphere;\n    \trsphere.c = vec3(1.0);\n    \trsphere.d = length(p) - 0.5;\n    \trsphere.m = vec2(0.0);\n    \trsphere.r = vec2(1.0, 0.8);\n    \n    \tcolor rceiling;\n    \trceiling.c = vec3(0.2, 0.3, 1.0);\n    \trceiling.d = -p.y + 1.0;\n    \trceiling.m = vec2(1.0, 0.9);\n    \trceiling.r = vec2(0.0);\n    \n        color rfloor;\n    \trfloor.c = vec3(1.0);\n    \trfloor.d = p.y + 1.0;\n    \trfloor.m = vec2(0.0);\n    \trfloor.r = vec2(0.0);\n    \n    \tcolor lwall;\n    \tlwall.c = vec3(1.0, 0.2, 0.2);\n    \tlwall.d = p.x + 1.0;\n    \tlwall.m = vec2(0.0);\n    \tlwall.r = vec2(0.0);\n    \n    \tcolor rwall;\n    \trwall.c = vec3(0.2, 1.0, 0.2);\n    \trwall.d = -p.x + 1.0;\n    \trwall.m = vec2(0.0);\n    \trwall.r = vec2(0.0);\n    \n    \tcolor bwall;\n        vec2 q = fract(p.xy / 2.0 + 0.5);\n        bwall.c = vec3(q, 0.0);\n        bwall.c = texture(iChannel0, bwall.c.xy).xyz;\n    \tbwall.d = -p.z + 0.5;\n    \tbwall.m = vec2(0.0);\n    \tbwall.r = vec2(0.0);\n    \n    \tcolor hwall;\n    \thwall.c = vec3(0.5, 0.5, 0.0);\n    \thwall.d = p.z + 3.5;\n    \thwall.m = vec2(0.0);\n    \thwall.r = vec2(0.0);\n    \n    if(final.d > sphere.d){\n     \tfinal = sphere;   \n    }\n    if (final.d > msphere.d){\n     \tfinal = msphere;   \n    }\n    if (final.d > rsphere.d){\n     \tfinal = rsphere;   \n    }\n    if(final.d > rceiling.d){\n     \tfinal = rceiling;   \n    }\n    if(final.d > rfloor.d){\n     \tfinal = rfloor;   \n    }\n    if(final.d > lwall.d){\n     \tfinal = lwall;   \n    }\n    if(final.d > rwall.d){\n     \tfinal = rwall;   \n    }\n    if(final.d > bwall.d){\n        final = bwall;\n    }\n    if(final.d > hwall.d){\n     \tfinal = hwall;   \n    }\n    \treturn final;\n    }\n\ncolor march(vec3 o, vec3 r){\n \tcolor t;\n    t.c = vec3(0.0);\n    t.d = 0.0;\n    t.m = vec2(0.0);\n    t.r = vec2(0.0);\n    \n    for(int i = 0; i < MAXITER; i++){\n     \tvec3 p = o + r * t.d;\n        color scene = map(p);\n        \n        t.c = scene.c;\n        t.d += scene.d * 0.5;\n        t.m = scene.m;\n        t.r = scene.r;\n    }\n    return t;\n}\nvec3 gradient (vec3 p){\n    const vec3 dx = vec3(0.1, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, 0.1, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, 0.1);\n    \n    return normalize(vec3(\n        \t\tmap(p+dx).d - map(p-dx).d,\n                map(p+dy).d - map(p-dy).d,\n                map(p+dz).d - map(p-dz).d\n    \t\t\t));\n}\nvec3 shade(vec3 n, vec3 pos, color scene){\n\tvec3 iFin = vec3(0.0);\n    {\n     vec3  lipos = vec3(sin(iTime)*0.5, 0.4, -1.0);\n     vec3  licol = vec3(1.0);\n     float lintensity = 1.0;\n     vec3 lidir = normalize((lipos - pos));\n     float libdir = dot(n, lidir);\n     iFin += scene.c * libdir;\n    }\n    return iFin;\n}\nvec3 gloss(color scene, vec3 rd, vec3 p, vec3 nor){\n    color d = scene;\n    vec3 c = scene.c;\n    vec3 r = rd;\n    vec3 pos = p;\n    vec3 n = nor;\n    float amt = 0.0;\n    \n    for (int i = 0; i < MAXREFLECTIONS; i++){\n        if (d.m.x > 0.0){\n            r = reflect(r, n);\n            amt += d.m.y;\n            d = march(pos + r * 0.001, r);\n            pos = pos + r * d.d;\n            n = gradient(pos);\n            vec3 lit = shade(n, pos, d);\n            lit = clamp(lit, 0.0, 1.0);\n            c = mix(c, lit, 1.0 - amt);\n        }\n    }\n    return c;\n}\nvec3 refr (vec3 col, vec3 rd, vec3 p, vec3 nor, color scene){\n    vec3 r = refract(rd, -nor, scene.r.y);\n    color d = march(-p - r * 0.001, -r);\n    vec3 pos = p + r * d.d;\n    vec3 n = gradient(pos);\n    scene.c = shade(n, pos, d);\n    return scene.c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n        \n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3((iMouse.x/iResolution.x)*2.0 - 1.0 + 0.1, 0.0, -(iMouse.y/iResolution.y)*2.0 - 1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    color scene = march(ro, rd);\n    \n    vec3 pos = ro + rd * scene.d;\n    \n    vec3 n = gradient(pos);\n    vec3 lit = shade(n, pos, scene);\n    if(scene.r.x > 0.0){\n     \tlit = refr(lit, rd, pos, n, scene);   \n    }\n    if(scene.m.x > 0.0){\n     \tlit = gloss(scene, rd, pos, n);   \n    }\n    \n    col = vec3(lit);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdSW7", "name": "Fractal Experiment 17", "author": "aiekick", "description": "Change pattern evolution by mouse axis X", "tags": ["fractal", "experiment", "17"], "likes": 10, "viewed": 602, "date": "1459728431", "time_retrieved": "2024-06-20T18:35:35.964799", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0., ts = 0.;\nfloat dstepf = 0.0;\n\nfloat ratio = 0.5;\n\nvec2 path(float z)\n{\n\treturn vec2(cos(z), sin(z));\n}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n//julia fractal\nfloat fractus(vec3 p)\n{\n\tvec2 z = p.xy;\n    vec2 c = vec2(0.28,-0.56) * 2. * ratio;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<7.;i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);\n}\n\nvec2 df(vec3 p)\n{\n    p.xy += path(p.z*0.2)*1.5;\n\tp *= getRotZMat(p.z*0.2);\n\tp = mod(p, 4.) - 2.;\n\tfloat obj = fractus(p);\n\tvec2 res = vec2(obj, 1.);\n\n\treturn res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat cao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float d = max(length(l), 0.01);\n    float atten = exp( -0.0001*d )-0.5;\n    l /= d;\n    \n    vec3 n = nor(p, prec);\n   \tvec3 r = reflect(-l, n);\n    \n    float ao = df(p+n*3.).x;\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    dif *= softshadow(p, l, 0., 1.);\n    \n    vec3 lin = vec3(0.08,0.32,0.47) * ao;\n    lin += 1.0*dif*vec3(1,1,0.84);\n    lin += 2.5*spe*dif*vec3(1,1,0.84);\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin * atten * cao(p, n);\n}\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = iTime * 5.;\n\tts = sin(t)*.5+.5;\n    \n    ratio = 0.5;\n    if (iMouse.z > 0.)\n    \tratio = iMouse.x / si.x;\n    \n    dstepf = 0.5;\n    \n\tvec3 ro = vec3(0,0,t);\n   \n\tvec3 cu = vec3(0,1,0);\n\tvec3 co = ro + vec3(0,0,1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(co - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * uv.x * x + fov * uv.y * y);\n   \n\tvec2 s = vec2(0.01);\n\tfloat d = 0.;\n\tvec3 p = ro;\n\tfloat dMax = 30.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (s.x<0.0025*d || d>dMax) break;\n\t\ts = df(p);\n\t\td += s.x * (s.x>0.1?0.2:0.2);\n\t\tp = ro + rd * d;\t\n        dstepf += 0.002;\n\t}\n\t\n    f.rgb = vec3(0.47,0.6,0.76) * lighting(p, ro, rd, 0.1); \n\tf.rgb = mix( f.rgb, vec3(0.5,0.49,0.72), 1.0-exp( -0.01*d*d ) ); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdXRs", "name": "Efficient Mandelbulb", "author": "Swax97", "description": "Originally posted on Khan Academy CS\nkhanacademy.org/cs/m/4556599124\nThe trend may be seven years old, but I still had fun :D\nBig thanks to igo for the 8th degree non-trigonometric iteration function.\nThe only thing missing are analytic normals.", "tags": ["3d", "distancefield", "raymarch", "khanacademy"], "likes": 20, "viewed": 749, "date": "1460932194", "time_retrieved": "2024-06-20T18:35:35.964799", "image_code": "#define BOUNDING_RADIUS 1.1\n\n#define COLOR1 vec3(1.0, 0.3, 0.0)\n#define COLOR2 vec3(0.0, 0.7, 1.0)\n#define BACKGROUND vec3(0.9, 0.8, 0.8)\n\n#define ir3 0.57735\n\nfloat mandelbulb(vec3 pos){\n    vec3 w = pos;\n    float dr = 1.0,r;\n    vec3 p,p2,p4;\n    float k1,k2,k3,k4,k5;\n\n    for (int i = 0; i < 10; i++){\n        r = dot(w, w);\n        if (r > 4.0) break;\n        dr =  pow(r, 3.5)*8.0*dr + 1.0;\n\n        p = w;\n        p2 = w * w;\n        p4 = p2 * p2;\n\n        k3 = p2.x + p2.z;\n        k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        k1 = dot(p4, vec3(1)) - 6.0 * dot(p2, vec3(p2.y, p2.z, -p2.x / 3.0));\n        k4 = dot(p2, vec3(1, -1, 1));\n        k5 = 8.0*p.y*k4*k1*k2;\n\n        w = pos + vec3(8.0*k5*p.x*p.z*(p2.x-p2.z)*(p4.x-6.0*p2.x*p2.z+p4.z),\n                       -16.0*p2.y*k3*k4*k4 + k1*k1,\n                       -k5*(p4.x*p4.x - 28.0*p4.x*p2.x*p2.z + \n                            70.0*p4.x*p4.z - 28.0*p2.x*p2.z*p4.z + p4.z*p4.z));\n    }\n    return log(r)*sqrt(r)/dr;\n}\n\nfloat dist(vec3 p) {\n    return 0.385*mandelbulb(p);\n}\n\nbool bounding(in vec3 ro, in vec3 rd){\n    float b = dot(rd,ro);\n    return dot(ro,ro) - b*b < BOUNDING_RADIUS * BOUNDING_RADIUS;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    if (bounding(ro, rd)){\n        float t = 0.72, d;\n        for (int i = 0; i < 96; i++){\n            d = dist(ro + rd * t);\n            t += d;\n\n            if (d < 0.002) return vec2(t, d);\n            if (d > 0.4) return vec2(-1.0);\n        }\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 p){\n    const float eps = 0.005;\n    return normalize(vec3(dist(p+vec3(eps,0,0))-dist(p-vec3(eps,0,0)),\n                          dist(p+vec3(0,eps,0))-dist(p-vec3(0,eps,0)),\n                          dist(p+vec3(0,0,eps))-dist(p-vec3(0,0,eps))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float theta = iTime * 0.2;\n    mat2 rot = mat2(+cos(theta), -sin(theta),\n                    +sin(theta), +cos(theta));\n    mat2 rrot = mat2(+cos(theta), +sin(theta),\n                     -sin(theta), +cos(theta));\n    vec2 rxz = vec2(0.0, -1.8) * rot;\n    vec3 ro = vec3(rxz.x, sin(theta*1.61)*0.1, rxz.y);\n    //coordinates of pixel\n    vec2 uv = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n\n\n    vec3 rd = normalize(vec3(uv, 1.1));\n    rd.xz *= rot;\n\n    vec2 res = march(ro, rd);\n\n    if (res.x > 0.0){\n        vec3 end = ro + rd * res.x;\n\n        vec3 norm = normal(end-rd*0.001);\n\n        float ao = clamp((dist(end + norm * 0.02) - res.y) / 0.02, 0.0, 1.0);\n        norm.xz *= rrot;\n\n        float m = clamp(dot(end, end), 0.0, BOUNDING_RADIUS) / BOUNDING_RADIUS;\n        vec3 col = mix(COLOR1, COLOR2, m*m*m);\n\n        float d = max(dot(norm, vec3(-ir3)), 0.0);\n        vec3 light = col * ao + 0.2 * d + 0.4 * d*d*d*d*d*d*d*d;\n\n        fragColor = vec4(light, 1.0);\n    } else {\n        fragColor = vec4(BACKGROUND - length(uv) / 4.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdXRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdXW2", "name": "just boxes - my first raymarcher", "author": "Marqin", "description": "My first raymarcher. With dynamic light, shadows and MSAA.\n\nIf you have low FPS, comment out:\n#define MSAA_4rays\n\ntutorials I've used:\n* http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n* http://iquilezles.org/", "tags": ["raymarching"], "likes": 3, "viewed": 223, "date": "1461586899", "time_retrieved": "2024-06-20T18:35:35.970903", "image_code": "const int MaximumRaySteps = 128;\nconst float MinimumDistance = 0.00001;\n\n// comment this to disable MSAA:\n#define MSAA_4rays\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdBox( vec3 boxpos, vec3 p, vec3 b ) {\n    p -= boxpos;\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat boxLine( vec3 point, float z ) {\n    \n    float bsize = 0.5;\n    \n    vec3 box = vec3(0., bsize, z);\n    \n    float dist = sdBox(box, point, vec3(bsize));\n    \n    for( float i = 1.; i < 4.; i++ ) {\n        vec3 npos = vec3(box.x + i*2.*(bsize+0.05), box.y, box.z);\n        float newBox = sdBox(npos, point, vec3(bsize));\n        dist = min(dist, newBox);\n    }\n    \n    return dist;\n}\n\nfloat DistanceEstimator( vec3 point ) {\n    \n    float dist = min(boxLine(point, 0.), boxLine(point, 2.5));\n\n    return min(dist, sdPlane(point));\n}\n\n\nmat3 lookAt( vec3 origin, vec3 direction, float roll ) {\n    vec3 ww = normalize(direction);\n\tvec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll),0.0)));\n\tvec3 vv = normalize(cross(uu, ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getNormal( in vec3 pos ) {\n// from iq\n\tvec3 eps = vec3( MinimumDistance, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    DistanceEstimator(pos+eps.xyy) - DistanceEstimator(pos-eps.xyy),\n\t    DistanceEstimator(pos+eps.yxy) - DistanceEstimator(pos-eps.yxy),\n\t    DistanceEstimator(pos+eps.yyx) - DistanceEstimator(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nconst float k = 32.;\n\nfloat shadow( Ray r ) {\n    float dist = 2.*MinimumDistance;\n    float sh = 1.0;\n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n        vec3 newLocation = r.origin + dist * r.direction;\n\t\tfloat h = DistanceEstimator(newLocation);\n        if( h < MinimumDistance || dist > 10.)\n            return sh;\n        sh = min( sh, 32.*h/dist );\n        dist += h;\n    }\n    return sh;\n}\n\nvec3 shade(vec3 p) {\n    vec3 lightColor = vec3(0.9, 0.99, 0.99);\n\n    vec3 lightDir = normalize(vec3(sin(iTime/1.0), 0.6, -0.3));\n\n    \n    vec3 normal = getNormal(p);\n    vec3 light = lightColor * dot(normal, lightDir);\n   \n    return light* shadow(Ray(p, normalize(lightDir)));\n}\n\n\nvec3 trace( Ray r ) {\n\tfloat totalDistance = 0.0;\n    \n    float colour = 0.8;\n    \n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n\t\tvec3 newLocation = r.origin + totalDistance * r.direction;\n\t\tfloat distance = DistanceEstimator(newLocation);\n\t\ttotalDistance += distance;\n        if( distance < MinimumDistance ) {\n            if( newLocation.y <= MinimumDistance )\n            \tcolour = 1.0;\n        \tbreak;\n        }\n\t}\n   \n    return colour*shade(r.origin + totalDistance* r.direction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 uv = 2.*gl_FragCoord.xy/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 cam = vec3(2.*sin(iTime/1.5) - 1.0, 3, -3.);\n        \n    vec3 dir = vec3(1.,0.,0.) - cam;\n    \t\n    \n    mat3 cameraMatrix = lookAt( cam, dir, 0.0 );\n    vec3 rd = normalize(lookAt( cam, dir, 0.0 ) * vec3(uv,2.0));\n\n\n    vec2 uvNext = 2.*(gl_FragCoord.xy+vec2(1.,1.))/iResolution.xy - 1.0;\n    uvNext.x *= iResolution.x/iResolution.y;\n    \n    vec2 uvDiff = uvNext - uv;\n    uvDiff /= 3.;\n\n\n    vec3 sum = vec3(0.0);\n    vec3 rd1 = normalize(cameraMatrix * vec3(uv+ vec2( 1.0 * uvDiff.x, 1.0 * uvDiff.y),2.0));\n //   vec3 rd2 = normalize(cameraMatrix * vec3(uv+ vec2( 1.0 * uvDiff.x, 0.0 * uvDiff.y),2.0));\n    vec3 rd3 = normalize(cameraMatrix * vec3(uv+ vec2( 1.0 * uvDiff.x,-1.0 * uvDiff.y),2.0));\n //   vec3 rd4 = normalize(cameraMatrix * vec3(uv+ vec2( 0.0 * uvDiff.x, 1.0 * uvDiff.y),2.0));\n    vec3 rd5 = normalize(cameraMatrix * vec3(uv+ vec2( 0.0 * uvDiff.x, 0.0 * uvDiff.y),2.0));\n //   vec3 rd6 = normalize(cameraMatrix * vec3(uv+ vec2( 0.0 * uvDiff.x,-1.0 * uvDiff.y),2.0));\n    vec3 rd7 = normalize(cameraMatrix * vec3(uv+ vec2(-1.0 * uvDiff.x, 1.0 * uvDiff.y),2.0));\n //   vec3 rd8 = normalize(cameraMatrix * vec3(uv+ vec2(-1.0 * uvDiff.x, 0.0 * uvDiff.y),2.0));\n    vec3 rd9 = normalize(cameraMatrix * vec3(uv+ vec2(-1.0 * uvDiff.x,-1.0 * uvDiff.y),2.0));\n\n    \n    float nr = 1.;\n   // sum += trace(Ray(cam, rd5));   \n#ifdef MSAA_4rays\n    nr = 4.;\n    sum += trace(Ray(cam, rd1));\n    sum += trace(Ray(cam, rd3));\n    sum += trace(Ray(cam, rd7));\n    sum += trace(Ray(cam, rd9));\n#else\n    sum += trace(Ray(cam, rd5));\n#endif\n   \n    vec3 gr = sum/nr;\n    \n    fragColor = vec4(gr, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdXzj", "name": "a bunch of rings", "author": "bostelk", "description": "another sketch", "tags": ["2d"], "likes": 5, "viewed": 136, "date": "1460304229", "time_retrieved": "2024-06-20T18:35:35.970903", "image_code": "#define PI 3.145\n#define TAU 2.*3.145\n\nvec2 rot(vec2 p, float theta)\n{\n\treturn vec2(cos(theta) * p.x - sin(theta) * p.y,\n                sin(theta) * p.x + cos(theta) * p.y);\n}\n\nfloat ring(vec2 p, float r, float t)\n{\n    return smoothstep(r - t, r, length(p)) + (1.- smoothstep(r - t - t, r - t, length(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2. * uv -1.0; \n    uv.y *= iResolution.y / iResolution.x;\n\n    float r = 0.15;\n    float t = 0.01;\n    float k = 2. * r - t;\n    float time = iTime;\n\n    uv *= 1.0 + exp(length(uv));\n    uv = rot(uv, -0.1*time);\n    uv += 2.*iMouse.xy / iResolution.xy ;\n    uv = mod(uv, vec2(3.*k));\n    uv -= vec2(1.5*k);\n\n    r = 0.10 + 0.05*sin(iTime);\n \tk = 2. * r - t;\n\n    float d1 = ring(uv, r, t);\n    float d2 = ring(uv + k * vec2(cos(time),sin(time)), 0.15, 0.01);\n    float d3 = ring(uv + k * vec2(cos(time + TAU*1./6.),sin(time + TAU*1./6.)), 0.15, 0.01);\n    float d4 = ring(uv + k * vec2(cos(time + TAU*2./6.),sin(time + TAU*2./6.)), 0.15, 0.01);\n    float d5 = ring(uv + k * vec2(cos(time + TAU*3./6.),sin(time + TAU*3./6.)), 0.15, 0.01);\n    float d6 = ring(uv + k * vec2(cos(time + TAU*4./6.),sin(time + TAU*4./6.)), 0.15, 0.01);\n    float d7 = ring(uv + k * vec2(cos(time + TAU*5./6.),sin(time + TAU*5./6.)), 0.15, 0.01);\n    \n\tfloat d = d1;\n    d = min(d, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    d = min(d, d6);\n    d = min(d, d7);\n \n\tfragColor = vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XstSDS", "name": "Ball with Noise Displacement", "author": "emh", "description": "Ball with Noise Displacement", "tags": ["procedural", "noise", "raymarch", "hsv"], "likes": 6, "viewed": 973, "date": "1461243240", "time_retrieved": "2024-06-20T18:35:37.286281", "image_code": "// Created by Eivind Magnus Hvidevold emnh/2016 - raymarching by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n//----------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec3 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat snoise2(vec4 x) {\n    /*x *= 4.0;\n    vec3 y = x.xyz;\n    y += x.w;\n    return noise(y);\n\t*/\n    x *= 0.4;\n    vec3 y = x.xyz;\n    y += x.w;\n    return fbm(y);\n}\n\nvec2 map(in vec3 pos) {    \n    vec3 o = pos;\n    \n    pos = pos - vec3(0.0, -1.5, 0.0);\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float ms = 3.14 * 2.0;\n    mat4 mrx = rotationMatrix(vec3(1.0, 0.0, 0.0), mo.y * ms);\n    mat4 mry = rotationMatrix(vec3(0.0, 1.0, 0.0), mo.x * ms);\n    \n    pos = (vec4(pos, 1.0) * mrx * mry).xyz;\n    \n    float scale = 50.0;\n    //float y = pos.y * 0.01 * sin(iTime / 2.0) * sin(scale * pos.x) * sin(scale * pos.y) * sin(scale * pos.z);\n    float speed = 0.1;\n    float y = 0.1 * snoise2(vec4((vec4(pos, 1.0)).xyz * 10.0, iTime * 1.0));\n    //y += 0.05 * snoise2(vec4((vec4(pos, 1.0) * mat_2).xyz, iTime * speed));\n    //y += 0.10 * snoise2(vec4((vec4(pos, 1.0) * mat_3).xyz / 2.0, iTime * speed));\n    \n    //float y = 0.03 * sin(scale * pos.x) * sin(scale * pos.y) * sin(scale * pos.z);\n    //float y2 = (sin(scale * pos.x) * sin(scale * pos.y) * sin(scale * pos.z) + 1.0) / 2.0;\n    //float y2 = abs(pos.x) + abs(pos.y) + abs(pos.z);\n    float y2 = 1.0;\n    //float y2 = (1.0 + snoise(vec4(pos * 2.0, iTime / 10.0))) / 2.0;\n    \n    float ss = 5.0;\n    vec3 sphereO = pos; // - vec3(0.0, 0.25, 1.0);\n    \n    float sd = sdSphere(sphereO / ss, 0.5 + y) * ss;\n    \n    return vec2(sd, sd + iTime / 10.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\t/* col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }*/\n\t\tcol = hsv2rgb(vec3(m, 1.0, 1.0));\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\t// vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n    //vec3 ro = vec3( -0.5+3.5*cos(6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(6.0*mo.x) );\n    vec3 ro = vec3( 3.5, 1.0, 3.5 );\n\tvec3 ta = vec3( -0.5, -2.0, -1.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XstSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XstSRX", "name": "Disco 2000", "author": "finalman", "description": "My shader just wants to party all the time!", "tags": ["raytracing", "music", "volumetric", "lights"], "likes": 41, "viewed": 10289, "date": "1460652084", "time_retrieved": "2024-06-20T18:35:39.019614", "image_code": "const float EXPOSURE = 12.0;\nconst float OMNI_LIGHT = 0.1;\nconst float FLOOR_REFLECTION = 0.15;\n\nconst int NUM_LIGHTS = 10;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\nconst float BIG = 1e30;\nconst float EPSILON = 1e-10;\nconst float THETA = (1.0 + 2.2360679775) / 2.0;\nconst float INV_THETA = 1.0 / THETA;\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Intersection\n{\n    float dist;\n    vec3 normal;\n};\n\nstruct Result\n{\n    Intersection start;\n    Intersection end;\n};\n    \nstruct Range\n{\n\tfloat start;\n    float end;\n};\n    \nstruct Light\n{\n    vec3 d;\n    vec3 c;\n    float a;\n};\n    \nLight lights[NUM_LIGHTS];\n    \nmat4 rotateX(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nfloat insideCone(vec3 direction, float angle, vec3 o)\n{\n    float oz = dot(o, direction);\n    vec3 oxy = o - direction * oz;\n    float c = dot(oxy, oxy) / (angle * angle) - (oz * oz);\n    return smoothstep(20.0, -50.0, c);\n}\n\nRange cone(vec3 direction, float angle, Ray ray)\n{\n    float dz = dot(ray.d, direction);\n    float oz = dot(ray.o, direction);\n    vec3 dxy = ray.d - direction * dz;\n    vec3 oxy = ray.o - direction * oz;\n    \n    float a = dot(dxy, dxy) - (dz * dz * angle * angle);\n    float b = dot(dxy, oxy) - (dz * oz * angle * angle);\n    float c = dot(oxy, oxy) - (oz * oz * angle * angle);\n    \n    float p = 2.0 * b / a;\n    float q = c / a;\n    \n    float r = p * p / 4.0 - q;\n    \n    Range result;\n    result.start = BIG;\n    result.end = -BIG;\n    \n    if (r >= 0.0)\n    {\n        float m = -p / 2.0;\n        float sr = sqrt(r);\n            \n        if (c < 0.0)\n        {\n\t\t\t// Inside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                result.start = 0.0;\n                result.end = BIG;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = 0.0;\n                result.end = m + sr;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = 0.0;\n            \tresult.end = m - sr;\n            }\n        }\n        else\n        {\n            // Outside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                return result;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = m + sr;\n                result.end = BIG;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = m - sr;\n            \tresult.end = m + sr;\n            }\n        }\n    }\n    \n    return result;\n}\n\nResult plane(vec3 pos, vec3 normal, Ray ray)\n{\n    ray.o -= pos;\n    \n    float rdn = dot(ray.d, normal);\n    float ron = dot(ray.o, normal);\n    \n    Result result;\n    result.start.normal = normal;\n    result.end.normal = normal;\n    \n    if (ron > 0.0)\n    {\n        // Outside\n        result.start.dist = BIG;\n        result.end.dist = -BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n            else\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n        }\n    }\n    else\n    {\n        // Inside\n        result.start.dist = -BIG;\n        result.end.dist = BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n            else\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n        }\n    }\n    return result;\n}\n\nfloat inverseSquare(vec3 p)\n{\n    return 1.0 / dot(p, p);\n}\n\nfloat inverseSquareAntiderivative(Ray ray, float t)\n{\n    vec3 o = ray.o;\n    vec3 d = ray.d;\n    \n    // Shoutout to Wolfram Alpha\n    float a = t * dot(d, d) + dot(d, o);\n    float b1 = d.x * d.x * dot(o.yz, o.yz);\n    float b2 = 2.0 * d.x * o.x * dot(o.yz, d.yz);\n    float b3 = o.x * o.x * dot(d.yz, d.yz);\n    float b4 = (o.y * d.z - d.y * o.z) * (o.y * d.z - d.y * o.z);\n    float b = sqrt(b1 - b2 + b3 + b4);\n    return atan(a / b) / b;\n}\n\nfloat inverseSquareIntegral(Ray ray, float start, float end)\n{\n    return inverseSquareAntiderivative(ray, end) - inverseSquareAntiderivative(ray, start);\n}\n\nvec3 getLight(vec3 pos)\n{\n    vec3 color = vec3(inverseSquare(pos) * OMNI_LIGHT * 2.0);\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        color += lights[i].c * inverseSquare(pos) * insideCone(lights[i].d, lights[i].a, pos);\n    }\n    return color;\n}\n\nvec3 renderVolumetric(Ray ray, float maxDist)\n{\n    vec3 color = vec3(inverseSquareIntegral(ray, 0.0, maxDist) * OMNI_LIGHT);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Range r = cone(lights[i].d, lights[i].a, ray);\n        r.end = min(r.end, maxDist);\n        \n        if (r.end > r.start)\n        {\n            float boost = mix(1.0, 18.0, insideCone(lights[i].d, lights[i].a, ray.o));\n            \n            color += inverseSquareIntegral(ray, r.start, r.end) * lights[i].c * boost;\n        }\n    }\n    \n    return color;\n}\n\nvec3 floorTexture(vec3 pos)\n{\n    pos.z += pos.x * 0.25;\n    return fract(pos.x * 0.1) > fract(pos.z * 0.1) ? vec3(1.0) : vec3(0.7);\n}\n\nfloat floorGloss(vec3 pos)\n{\n    pos.x += pos.z * 2.0;\n    return texture(iChannel1, pos.xz * 0.2).x * 0.5 + 0.75;\n}\n\nvec3 renderScene(Ray ray)\n{\n    Result r = plane(vec3(0.0, -18.0, 0.0), vec3(0.0, 1.0, 0.0), ray);\n    \n    if (r.start.dist > 0.0 && r.start.dist < r.end.dist)\n    {\n        vec3 pos = ray.o + ray.d * r.start.dist;\n        \n        Ray reflectedRay;\n        reflectedRay.o = pos;\n        reflectedRay.d = ray.d * vec3(1, -1, 1);\n        \n        vec3 volumetric = renderVolumetric(ray, r.start.dist);\n        vec3 reflectedVolumetric = renderVolumetric(reflectedRay, BIG);\n        \n        vec3 color = -normalize(pos).y * getLight(pos) * 30.0 * floorTexture(pos);\n        float gloss = floorGloss(pos);\n        \n        return volumetric + mix(color, reflectedVolumetric, FLOOR_REFLECTION * gloss);\n    }\n    else\n    {\n    \treturn renderVolumetric(ray, BIG);\n    }\n}\n\nvec3 toneMap(vec3 color)\n{\n    return 1.0 - exp(-color * EXPOSURE);\n}\n\nvoid setUpLights()\n{\n    mat4 m = rotateX(TAU * iTime * 0.05) * rotateY(TAU * iTime * 0.09);\n    \n    lights[0].d = normalize(m * vec4(1, 1, 1, 0)).xyz;\n    lights[1].d = normalize(m * m * vec4(1, 1, -1, 0)).xyz;\n    lights[2].d = normalize(m * vec4(1, -1, 1, 0)).xyz;\n    lights[3].d = normalize(m * m * vec4(1, -1, -1, 0)).xyz;\n    lights[4].d = normalize(m * vec4(0, INV_THETA, THETA, 0)).xyz;\n    lights[5].d = normalize(m * m * vec4(0, INV_THETA, -THETA, 0)).xyz;\n    lights[6].d = normalize(m * vec4(INV_THETA, THETA, 0, 0)).xyz;\n    lights[7].d = normalize(m * m * vec4(INV_THETA, -THETA, 0, 0)).xyz;\n    lights[8].d = normalize(m * vec4(THETA, 0, INV_THETA, 0)).xyz;\n    lights[9].d = normalize(m * m * vec4(-THETA, 0, INV_THETA, 0)).xyz;\n    \n    lights[0].c = normalize(vec3(1, 1, 1) * 0.5 + 0.7);\n    lights[1].c = normalize(vec3(1, 1, -1) * 0.5 + 0.7);\n    lights[2].c = normalize(vec3(1, -1, 1) * 0.5 + 0.7);\n    lights[3].c = normalize(vec3(1, -1, -1) * 0.5 + 0.7);\n    lights[4].c = normalize(vec3(0, INV_THETA, THETA) * 0.5 + 0.7);\n    lights[5].c = normalize(vec3(0, INV_THETA, -THETA) * 0.5 + 0.7);\n    lights[6].c = normalize(vec3(INV_THETA, THETA, 0) * 0.5 + 0.7);\n    lights[7].c = normalize(vec3(INV_THETA, -THETA, 0) * 0.5 + 0.7);\n    lights[8].c = normalize(vec3(THETA, 0, INV_THETA) * 0.5 + 0.7);\n    lights[9].c = normalize(vec3(-THETA, 0, INV_THETA) * 0.5 + 0.7);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        lights[i].a = texture(iChannel0, vec2(float(i) * 0.18, 0.0)).x * 0.3 + 0.05;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    setUpLights();\n    \n    Ray ray;\n    ray.o = vec3(sin(iTime * 0.5) * 5.0, -12.5 + sin(iTime * 0.6) * 2.5, -25.0);\n    ray.d = normalize(rotateX(-sin(iTime * 0.23) * 0.1) *\n                      rotateZ(sin(iTime * 0.33) * 0.1) *\n                      vec4((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.7, 0.0)).xyz;\n    \n   \tvec3 color = renderScene(ray);\n    color = toneMap(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XstSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XstSWS", "name": "Series Length", "author": "loganmcbroom", "description": "This is a function of complex numbers, that function being:\n||f(z)-z|| = a||z||\nwhere f(z) = Sum n = 1 to infinity of z^n\nThe color is given by a.\n", "tags": ["math", "complex", "iteration", "series"], "likes": 0, "viewed": 144, "date": "1461220123", "time_retrieved": "2024-06-20T18:35:39.019614", "image_code": "//||f(z)-z|| = ||f(z)|| * ||z||\n\n\n#define ITERATIONS 1000.0\n#define M_PI 3.1415926535897932384626433832795\n\nvec3 hsv2rgb( vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 complexProduct(vec2 z, vec2 w)\n{\n    return vec2( z.x*w.x - z.y*w.y, z.x*w.y + w.x*z.y );\n}\n\nvec2 complexDivide(vec2 n, vec2 d)\n{\n    float div = d.x*d.x + d.y*d.y;\n    return vec2( (n.x*d.x + n.y*d.y) / div, (n.y*d.x - n.x*d.y) / div );\n}\n\nvec2 series( vec2 z, const float iter )\n{\n    vec2 sum = vec2(0,0);\n    vec2 c = vec2(1,0);\n \tfor( float i = 1.0; i < ITERATIONS; ++i )\n    {\t\n        c = complexProduct(c,z);\n        sum += c;\n        if(i >= iter) break;\n    }\n    return sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = ITERATIONS * (sin( iTime ) + 1.0) / 2.0;\n    \n    vec2 uv = ( fragCoord / (.5*iResolution.y) ) + vec2(-1,-1);\n    \n    if (uv.x*uv.x+uv.y*uv.y > 1.0)\n    {\n        fragColor = vec4(0,0,0,0);\n    }\n    else\n    {\n    vec2 sum = series( uv, t );\n    vec3 color = vec3(\n        length( sum ),\n    \t1,\t     \n        1\t\t\t\t\t\t\t\t\t\n    );\n\tfragColor = vec4( hsv2rgb( color ), 1 );\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XstSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XstXRX", "name": "Vertebrae", "author": "dila", "description": "Some twisted raymarched surfaces with crappy volumetric fog.", "tags": ["raymarch"], "likes": 14, "viewed": 300, "date": "1460719234", "time_retrieved": "2024-06-20T18:35:39.019614", "image_code": "mat2 rot(float t)\n{\n \treturn mat2(cos(t), sin(t), -sin(t), cos(t));   \n}\n\nfloat plane(vec3 o, vec3 r, vec3 p)\n{\n\treturn dot(p - o, r) / dot(r, r);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec4 map(vec3 p)\n{  \n    p.x += sin(p.z);\n    \n    vec3 q = fract(p) - 0.5;\n    \n    vec3 u = vec3(p.xy, q.z);\n    \n    float d = 1000.0;\n    \n    vec3 t = vec3(0.0);\n    \n    u.xy *= rot(1.57 + p.z * 0.25 + iTime * 0.25);\n\n    float f = mix(1.0, 1.0, sin(p.z)*0.5 + 0.5);\n\n    vec2 r = abs(u.xz) - vec2(f, 0.0);\n\n    float a = length(r) - 0.1;\n\n    float fp = fract(u.y) * 2.0 - 1.0;\n\n    vec3 v = vec3(u.z, fp, abs(u.x) - f);\n\n    float br = mix(0.0, 0.45, sin(u.y) * 0.5 + 0.5);\n\n    float b = sdBox(v, br * vec3(1.0,2.0,1.0));\n\n    float c = min(a, b);\n\n\treturn vec4(v, c);\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).w - map(p-o.xyy).w,\n                          map(p+o.yxy).w - map(p-o.yxy).w,\n                          map(p+o.yyx).w - map(p-o.yyx).w));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).w;\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec4 part(vec3 o, mat3 r, vec3 p, float s)\n{\n    float t = plane(o, r[2], p);\n\n    vec3 q = o + r[2] * t;\n\n    vec3 c = q - p;\n\n    float ls = dot(c, c);\n\n    vec3 tv = c;\n\n    vec2 uv = vec2(dot(tv,r[0]), dot(tv,r[1]));\n    \n    uv *= rot((q.z+q.x) * s);\n\n    vec3 tex = texture(iChannel0, uv).xyz;\n    \n    tex *= tex;\n\n    float k = 1.0;\n\n    k *= max((1.0 - sqrt(ls)), 0.0);\n    \n    return vec4(tex * k, t);\n}\n\nvec4 rpart(vec3 o, mat3 r, vec3 p, float to, float s)\n{\n\treturn part(o, r, p, s);\n}\n\nvec3 tex(vec3 p)\n{\n\tvec3 ta = texture(iChannel1, p.yz).xyz;\n    vec3 tb = texture(iChannel1, p.xz).xyz;\n    vec3 tc = texture(iChannel1, p.xy).xyz;\n    return (ta*ta + tb*tb + tc*tc) / 3.0;\n}\n\nvec3 vol(vec3 o, mat3 r)\n{\n    float t = trace(o, r[2]);\n    \n    vec3 w = o + r[2] * t;\n    \n    vec3 n = normal(w);\n    \n    vec3 lp = o + n * 0.5 - r[2] * 0.1;\n    \n    vec3 lv = w + n * 0.01 - lp;\n    \n    float ld = length(lv);\n    \n    lv /= ld;\n    \n    float lt = trace(lp, lv);\n    \n    float lm = max(sign(lt - t), 0.0) / (1.0 + ld * ld * 0.01);\n    \n    float p = max(dot(lv, -n), 0.0);\n    \n    vec4 d = map(w);\n    \n    vec3 c = tex(d.xyz * 0.25);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.01);\n    \n\tvec3 s = c * p * mix(lm, 1.0, 0.2);\n    \n    s += vec3(0.3, 0.6, 0.8) * max(n.y, 0.0) * 0.2;\n    \n    /* thanks Shane :) */\n    s += pow(max(dot(reflect(lv, n), -r[2]), 0.), 8.)*.5;\n    \n    float gt = t;\n    \n    vec3 fg = vec3(0.0);\n    \n    for (int y = -3; y <= 3; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n    \n            vec3 l = vec3(float(x), 0.0, floor(o.z) - float(y));\n            \n            l.y = sin(l.x + l.z) * 0.25;\n\n            vec4 pt = rpart(o, r, l, 0.0, sign(l.x+l.y));\n            float scd = abs(pt.w - t);\n            float sc = 1.0 - 1.0 / (1.0 + scd * 10.0);\n            vec3 mt = pt.xyz * sc;\n            mt *= max(sign(pt.w), 0.0);\n            mt *= max(sign(t - pt.w), 0.0);\n            float fad = min(max(pt.w * 0.5, 0.0), 1.0);\n            mt *= fad * (1.0 - fad) * 4.0;\n            fg += mt;\n            \n            pt = rpart(o, r, l, 0.5, -sign(l.x+l.y));\n            scd = abs(pt.w - t);\n            sc = 1.0 - 1.0 / (1.0 + scd * 10.0);\n            mt = pt.xyz * sc;\n            mt *= max(sign(pt.w), 0.0);\n            mt *= max(sign(t - pt.w), 0.0);\n            fad = min(max(pt.w * 0.5, 0.0), 1.0);\n            mt *= fad * (1.0 - fad) * 4.0;\n            fg += mt;\n            \n            gt = min(gt, pt.w);\n        }\n    }\n\n    s *= fog;\n    \n    s += fg / 16.0;\n\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n\tvec3 o = vec3(0.0, 0.0, iTime);\n    o.x = -sin(o.z);\n    \n    mat3 v;\n    v[2] = r;\n    v[1] = vec3(0.0, 1.0, 0.0);\n    v[0] = normalize(cross(v[1], v[2]));\n    \n    mat2 k = rot(sin(o.z) * 0.5);\n    \n    v[0].xz *= k;\n    v[1].xz *= k;\n    v[2].xz *= k;\n    \n    mat2 j = rot(sin(o.z) * 0.25);\n    \n    v[0].xy *= j;\n    v[1].xy *= j;\n    v[2].xy *= j;\n    \n    \n\tvec3 t = vol(o, v);\n\n\tfragColor = vec4(sqrt(t), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XstXRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
