{"id": "4ddXRr", "name": "Raytraced Rotating Hypercube", "author": "RolandRock", "description": "Just a 4D cube rotating", "tags": ["raytracer"], "likes": 2, "viewed": 172, "published": "Public", "date": "1536109791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float maxVal = 999999999999999999999.;\n\nfloat zoom = 500.;\n//In this case I am using \"threespace\" to refer to a hyperplane in 4-space (i.e. a 3-dimensional subset of 4-space);\nfloat threespaceY = -500.;\nconst int AA_AMOUNT = 4;\n\nmat4 RotXYPlane(float angle)\n{\n    return mat4(cos(angle), -sin(angle), 0, 0,\n                sin(angle),  cos(angle), 0, 0,\n                         0,           0, 1, 0,\n                         0,           0, 0, 1);\n}\nmat4 RotXZPlane(float angle)\n{\n     return mat4( cos(angle), 0, sin(angle), 0,\n                           0, 1,          0, 0,\n                 -sin(angle), 0, cos(angle), 0,\n                 0,           0,          0, 1);\n}\nmat4 RotYZPlane(float angle)\n{\n     return mat4(1, 0,          0,           0,\n                 0, cos(angle), -sin(angle), 0,\n                 0, sin(angle),  cos(angle), 0,\n                 0, 0,          0,           1);\n}\n\nmat4 RotXWPlane(float angle)\n{\n     return mat4(cos(angle), 0, 0, sin(angle),\n                          0, 1, 0,           0,\n                          0, 0, 1,           0,\n                 -sin(angle), 0, 0,  cos(angle));\n}\nmat4 RotYWPlane(float angle)\n{\n     return mat4(1,          0,           0,           0,\n                 0, cos(angle),           0, -sin(angle),\n                 0,          0,           1,           0,\n                 0, sin(angle),           0,  cos(angle));\n}\nmat4 RotZWPlane(float angle)\n{\n     return mat4(1, 0,           0,          0,\n                 0, 1,           0,          0,\n                 0, 0,  cos(angle),  sin(angle),\n                 0, 0, -sin(angle),  cos(angle));\n}\n\n\nvec4 Reflect(vec4 normal, vec4 dir)\n{\n    vec4 n = normalize(normal);\n    return dir - (2.*dot(dir, n))*n;\n}\n\nstruct Ray\n{\n    vec4 origin;\n    vec4 direction;\n};   \nvec4 PointAt(Ray ray, float val)\n{\n    return ray.origin + val * ray.direction;\n}\n\nstruct Hit\n{\n    bool isHit;\n    float dist;\n    vec3 color;\n};\n\nstruct Rect\n{\n    vec4 center;\n    vec4 radii;\n    mat4 rotationMatrix;\n};   \nHit RectHit(Rect cube, Ray ray)\n{\n    ray.direction = cube.rotationMatrix * ray.direction;\n    ray.origin = cube.center + (cube.rotationMatrix * (ray.origin - cube.center));\n    \n    vec4 upperBounds = cube.center + cube.radii;\n    vec4 lowerBounds = cube.center - cube.radii;\n    \n    vec4 vals1 = (upperBounds - ray.origin)/ray.direction;\n    vec4 vals2 = (lowerBounds - ray.origin)/ray.direction;\n    \n    bool hit = false;\n    float closestVal = maxVal;\n    vec3 color = vec3(0.);\n    \n    for(int comp = 0; comp < 4; comp++)\n    {\n        vec2 vals = vec2(vals1[comp], vals2[comp]);\n        //vec4 precolor = vec4(0.);\n        //precolor[comp] = 1.;\n        \n        for(int valNum = 0; valNum < 2; valNum++)\n        {\n            float val = vals[valNum];\n            if(val < closestVal && val > 0.)\n            {\n                vec4 pt = PointAt(ray, val);\n                bvec4 greaterThanLower = greaterThanEqual(pt, lowerBounds);\n                bvec4 lessThanUpper = lessThanEqual(pt, upperBounds);\n                greaterThanLower[comp] = lessThanUpper[comp] = true;\n                if(all(greaterThanLower) && all(lessThanUpper))\n                {\n                    int uid = comp * 2 + valNum;\n                    closestVal = val;\n                    color = vec3(mod(float(uid), 2.), mod(float(uid/2), 2.), mod(float(uid/4), 2.));\n                    //color = vec3(1.) * (pt.w - (cube.center.w - cube.radius)) / (cube.radius * 2.);\n                    hit = true;\n                }\n            }\n        }\n    }\n    \n    return Hit(hit, closestVal, color);\n    \n}\n    \nstruct Sphere\n{\n    vec4 center;\n    float radius;\n    vec3 color;\n};\nHit SphereHit(Sphere sphere, Ray ray)\n{\n    vec4 adjIntercept = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, adjIntercept) * 2.;\n    float c =  dot(adjIntercept, adjIntercept) - (sphere.radius * sphere.radius);\n    \n    if(a < 0.) return Hit(false, 0., vec3(0.)); //No dividing by zero\n    float numToSqrt = b*b - 4.*a*c;\n    if(numToSqrt < 0.) return Hit(false, 0., vec3(0.));\n    float high = (-b + sqrt(numToSqrt))/(2. * a);\n    float low  = (-b - sqrt(numToSqrt))/(2. * a);\n    \n    if(high <= 0. && low <= 0.) return Hit(false, 0., vec3(0.));\n    if (low <= 0.) return Hit(true, high, sphere.color);\n    return Hit(true, low, sphere.color);  \n}\n\nHit ThreespaceHit(Ray ray)\n{\n    float val = (threespaceY - ray.origin.y)/ray.direction.y;\n    if(val > 0. /*&& PointAt(ray, val).w == 0.*/)\n    {\n        vec4 point = PointAt(ray, val);\n\n        vec3 color;\n        point = mod(point/100., 2.);\n        //3-way XOR\n        if (((point.x < 1.) != (point.z < 1.)) != (point.w < 1.)) \n            color = vec3(1.);\n        else\n            color = vec3(0.);\n        \n        return Hit(true, val, color);\n    }\n    else\n    \treturn Hit(false, val, vec3(0)); \n    \n}\n\nvec4 ColorAt(vec2 pixelCoord)\n{\n    float a = iTime / 3.;\n    mat4 rotMatrix = RotYZPlane(0.3) * RotXZPlane(a);\n    \n    //Generate ray\n    vec2 adjPixel = pixelCoord - iResolution.xy/2.;\n    vec4 baseRayDir = vec4(adjPixel/zoom, 1., 0);\n    \n    Ray ray = Ray(vec4(0., 0., -1500., 0.) * rotMatrix, \n                  baseRayDir * rotMatrix);\n        \n    Rect rect = Rect(vec4(0., 0., 0., 0.), \n                     vec4(250., 250., 250., 250.), \n                     RotXWPlane(a * 3.)*RotZWPlane(a * 2.)*RotYWPlane(a * 5.)); \n    \n    Sphere sphere = Sphere(vec4(0., 0., 0., 0.), 250., vec3(1., 0., 0.));\n    \n    Hit nearest = Hit(false, 99999999999999., vec3(0.));\n        \n    //Sphere\n    //Hit sphereHit = SphereHit(sphere, ray);\n    //if(sphereHit.isHit && sphereHit.dist < nearest.dist)\n    //{\n    //   nearest = sphereHit;\n    //   float w = PointAt(ray, nearest.dist).w;\n    //   nearest.color *= (w - (sphere.center.w - sphere.radius)) / (cube.radius * 2.);\n    //}\n    \n    //Cube\n    Hit rectHit = RectHit(rect, ray);\n    if(rectHit.isHit && rectHit.dist < nearest.dist)\n    {\n       nearest = rectHit;\n       //float w = PointAt(ray, nearest.dist).w;\n       //nearest.color = vec3(1.) * (w - (cube.center.w - cube.radius)) / (cube.radius * 2.);\n    }\n    \n    //Checkerboard\n    Hit threespaceHit = ThreespaceHit(ray);\n    if(threespaceHit.isHit && threespaceHit.dist < nearest.dist)\n        nearest = threespaceHit;\n        \n    return vec4(nearest.color, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    zoom *= iResolution.x / 1000.;\n    \n    fragColor = vec4(0.0);\n    \n    //antialiasing\n    for(float x = 0.; x < 1.; x += 1. / float(AA_AMOUNT)){\n    \tfor(float y = 0.; y < 1.; y += 1. / float(AA_AMOUNT)){    \n    \t\tfragColor += ColorAt(fragCoord + vec2(x, y));    \n    \t}\n    }\n    fragColor /= float(AA_AMOUNT * AA_AMOUNT);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 235, 265, 265, 456], [457, 457, 487, 487, 682], [683, 683, 713, 713, 908], [910, 910, 940, 940, 1135], [1136, 1136, 1166, 1166, 1401], [1402, 1402, 1432, 1432, 1629], [1632, 1632, 1669, 1669, 1740], [1798, 1798, 1832, 1832, 1879], [2024, 2024, 2057, 2057, 3608], [3684, 3684, 3723, 3723, 4398], [4400, 4400, 4428, 4428, 4912], [4914, 4914, 4945, 4945, 6395], [6398, 6398, 6453, 6453, 6790]], "test": "valid"}
{"id": "4l3fzn", "name": "Ghost Carousel!", "author": "Doctrometer", "description": "Circle of pacman Ghosts (Not webGL 1.0 compatible :-( will try and fix later)", "tags": ["pixel", "circle", "pacman", "ghost"], "likes": 5, "viewed": 692, "published": "Public API", "date": "1538324317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool circle(vec2 center,vec2 point, float r){\n     \n      if(((point.x-center.x)*(point.x-center.x) + ((point.y-center.y)*(point.y-center.y))) <= (float(r*r))){\n          return true;\n      }\n    \n    return false;\n    \n}\n\n\nbool square(vec2 position,vec2 point,float w, float h){\n       \n    if(point.x > position.x && point.x < position.x+w && point.y > position.y && point.y < position.y+h){\n       return true;\n    } \n    return false;\n}\n\n\n\n    \n    const int blocks2[52] = // positions of blocks x,y,w,h\n        int[](5,12,4,1,\n              3,11,8,1,\n             2,10,10,1,\n             1,7,12,3,\n             0,2,14,6,\n             0,1,2,1,\n             3,1,3,1,\n             8,1,3,1,\n             12,1,2,1,\n             0,0,1,1,\n             4,0,2,1, // 52\n             8,0,2,1,\n             13,0,1,1  \n             );\n\t const int blocks[44] = // 44\n        int[](5,12,4,1,\n              3,11,8,1,\n             2,10,10,1,\n             1,7,12,3,\n             0,2,14,6,\n             0,1,4,1,\n             5,1,4,1,\n             10,1,4,1,\n             1,0,2,1,\n             6,0,2,1,\n             11,0,2,1\n              );\n\n\tconst int eye[12] = \n        int[](1,0,2,1,\n             0,1,4,3,\n             1,4,2,1);\n        \nvoid eyes(vec2 pos,vec2 frag, int scale,vec4 inCol, out vec4 colour){\n    \n    \n    for(int b = 0; b < 12;b+=4){\n        \n        int x = eye[b];\n        int y = eye[b+1];\n        int w = eye[b+2];\n        int h = eye[b+3];\n        \n        //int scale = 10;\n        if(square(vec2(float(x*scale)+pos.x,float(y*scale)+pos.y),frag,float(w*scale),float(h*scale))){\n            colour = vec4(1.0,1.0,1.0,1.0);\n               break;\n        }else{\n        \tcolour = inCol;\n        }\n        \n       \n            \n    } \n    \n}\n\nvoid ghost(vec2 pos,vec2 frag, int scale,vec4 inCol, out vec4 colour, vec4 ghostColour){\n    \n    \n    if(mod(float(iFrame/10),2.0) == 0.0){ // controls the speed of the sprite change\n        \n        for(int b = 0; b < 44;b+=4){\n\n            int x = blocks[b];\n            int y = blocks[b+1];\n            int w = blocks[b+2];\n            int h = blocks[b+3];\n\n            //int scale = 10;\n            if(square(vec2(float(x*scale)+pos.x,float(y*scale)+pos.y),frag,float(w*scale),float(h*scale))){\n                colour = ghostColour;\n                break;\n            }else{\n                colour = inCol;\n            }\n        }\n    \n    }else{\n        for(int b = 0; b < 52;b+=4){\n\n            int x = blocks2[b];\n            int y = blocks2[b+1];\n            int w = blocks2[b+2];\n            int h = blocks2[b+3];\n\n            //int scale = 10;\n            if(square(vec2(float(x*scale)+pos.x,float(y*scale)+pos.y),frag,float(w*scale),float(h*scale))){\n                colour = ghostColour;\n                break;\n            }else{\n                colour = inCol;\n            }\n        }\n    }\n    \n    vec2 rightEye = vec2(pos.x+2.0 * float(scale),pos.y+5.0 * float(scale));\n    vec2 leftEye = vec2(pos.x+8.0 * float(scale),pos.y+5.0 * float(scale));\n    \n    eyes(rightEye,frag,scale,colour,colour);\n    eyes(leftEye,frag,scale,colour,colour);\n    \n    \n    vec2 leftPupil = vec2(rightEye.x+1.0*float(scale),rightEye.y + 2.0 * float(scale));\n     vec2 rightPupil = vec2(leftEye.x+1.0*float(scale),leftEye.y + 2.0 * float(scale));\n    \n    leftPupil = vec2((sin(iTime*4.0)*1.0*float(scale))+leftPupil.x,leftPupil.y);\n    rightPupil = vec2((sin(iTime*4.0)*1.0*float(scale))+rightPupil.x,rightPupil.y);\n    \n    if(square(leftPupil,frag,2.0* float(scale),2.0* float(scale))){\n      colour = vec4(0.0,0.0,1.0,1.0); \n    }\n    \n    if(square(rightPupil,frag,2.0* float(scale),2.0* float(scale))){\n      colour = vec4(0.0,0.0,1.0,1.0); \n    }\n    \n    \n}\n\n\nvec4 colour(float offset){\n    const float PI = 3.1415926535897932384626433832795;\n    \n    float a = 0.5;\n    float b = 0.5;\n    float c = 0.5;\n    float d = 0.0;\n       vec3 color; \n    \n    float i = offset + iTime;\n    a = 0.5;\n    b = 0.5;\n    c = 1.0;\n    d = 0.00;\n        \n        color.r = a + b * cos((2.0 * PI) * (c * i + d));\n    a = 0.5;\n    b = 0.5;\n    c = 1.0;\n    d = 0.330;\n        color.g = a + b * cos((2.0 * PI) * (c * i + d));\n        \n    a = 0.5;\n    b = 0.5;\n    c = 1.0;\n    d = 0.67;\n        \n        color.b = a + b * cos((2.0 * PI) * (c * i + d));\n        \n\treturn vec4(color,1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \n    //background\n\tfragColor = vec4(0);\n    \n    // need to fix scaling\n    int scale = 2;\n    \n    float ringID = 0.0;\n\n    for(float rings = 0.0; rings < 6.0; rings+=2.0){   \n\n        float points = 6.0 * float(rings);\n        ringID++;\n     \n   \tvec2 pos = vec2(iResolution.x/2.0,(iResolution.y/2.0)+ (float(rings)* 20.0)*float(scale));\n   \n     float ghostID = 0.0;\n      for(float i = 0.0; i <= 360.0; i+=360.0/points){\n\n           float speed = iTime *20.0;\n          if(mod(float(ringID), 2.0) == 0.0){\n         \tspeed = speed;\n          }else{\n            speed = -speed;\n          }\n        float s = sin(radians(i+speed));\n        float c = cos(radians(i+speed));\n\n        float xnew = (pos.x-(iResolution.x/2.0)) * c - (pos.y-(iResolution.y/2.0)) * s;\n        float ynew = (pos.x-(iResolution.x/2.0)) * s + (pos.y-(iResolution.y/2.0)) * c;\n\n        vec2 newPos = vec2(xnew +(iResolution.x/2.0),ynew +(iResolution.y/2.0));\n        ghost(newPos,fragCoord,scale,fragColor,fragColor,colour(ghostID));\n          \n          ghostID+= 0.1;\n        \n      }\n    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3fzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 221], [224, 224, 279, 279, 440], [1226, 1226, 1295, 1295, 1748], [1750, 1750, 1838, 1838, 3711], [3714, 3714, 3740, 3740, 4331], [4333, 4333, 4390, 4390, 5512]], "test": "valid"}
{"id": "4ldXzf", "name": "fan/repeat", "author": "bergi", "description": "playing with cartesian and polar modulo \n - till ya get dizzy", "tags": ["lines", "dots", "hypnotic", "pattern", "symmetry", "spacesegmentation"], "likes": 24, "viewed": 963, "published": "Public API", "date": "1538011410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\t\"fan/repeat\" - https://www.shadertoy.com/view/4ldXzf\n\t(c) 2018 bergi\n\t\n\tmodulo in space and time\n\n\tmore precisely, modulo applied to cartesian and polar coordinates\n    distorting \"an image\" consisting of lines and dots.\n\tparameters taken from hand-picked lists of various lengths\n\tusing time modulo pattern length.\n*/\n\n\n/** repeat the position in 'pos' every 'q' degree in polar space */\nvec2 fan(in vec2 pos, in float q) \n{\n    q = q / 180. * 3.14159265;\n    float ang = atan(pos.x, pos.y),\n    len = length(pos.xy);\n    ang = mod(ang + q/2., q) - q/2.;\n    pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\n/** repeat the position in 'pos' every 'q' units */\nvec2 repeat(in vec2 pos, in vec2 q) \n{\n    pos.xy = mod(pos.xy + q/2., q) - q/2.;\n    return pos;\n}\n\n/** combination of fan and repeat calls, controlled by the 'scene' parameter. \n    scene is range 0 to 3*5*6*7*11-1\n*/\nvec2 fan_repeat(in vec2 uv, in int scene) \n{\n    uv = fan(uv, float[5](120., 90., 60., 45., 30.)[scene % 5]);\n    uv = repeat(uv, vec2(\n        float[3](2., 3., 4.)[scene%3],\n        float[7](1., 3., 5., 2., 4., 5., 2.)[scene%7]));\n    uv = fan(uv, float[11](120., 90., 60., 30., 45., 12.5, 120., 180., 60., 30., 45.)[scene % 11]);\n    uv = repeat(uv, vec2(\n        float[6](1., 3., 1., 4., 3., 5.)[scene%6],\n        float[5](1., 4., 1., 3., 2.)[scene%5]));\n    \n\treturn uv;\n}\n\n\n/** a dull image with some variation through 'scene' */\nvec3 img(in vec2 uv, in int scene)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 c1 = vec3[3](\n        vec3(1., .7, .4), vec3(.4, .9, .3), vec3(.2, .5, 1.)\n    )[scene%3];\n    vec3 c2 = vec3[4](\n        vec3(.3, .5, .6), vec3(.4, .2, .3), vec3(.1, 1., .2), vec3(.2, .5, 1.)\n    )[scene%4];\n    vec3 c3 = vec3[5](\n        vec3(.9, .5, .1), vec3(.4, .9, .1), vec3(.1, .6, 1.), vec3(.9, .3, 1.), vec3(.5, .5, .5)\n    )[scene%5];\n    \n    float step1 = float[3](.01, .02, .1)[scene%3];\n    float step2 = float[4](.01, .02, 0.05, .1)[scene%4];\n    float step3 = float[5](.01, .02, 0.2, 0.03, .1)[scene%5];\n    float step4 = float[6](.01, .02, 0.03, 0.04, 0.05, .1)[scene%6];\n    \n    col += c1 * smoothstep(step2,0., length(uv.xy) - float[3](0., 0.1, .2)[scene%3]);\n    col += c1 * smoothstep(step1,0., abs(uv.y-.6)-0.02);\n    col += c2 * smoothstep(step4,0., abs(uv.x)-0.02);\n    col += c3 * smoothstep(step3,0., abs(uv.y-.3)-0.02);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n\t    \n    uv *= 5.;\n    \n    uv = fan_repeat(uv, int(iTime*3.));\n    vec3 col = img(uv, int(iTime*6.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 394, 430, 430, 623], [625, 677, 715, 715, 776], [778, 897, 941, 941, 1373], [1376, 1432, 1468, 1468, 2378], [2380, 2380, 2437, 2437, 2643]], "test": "error"}
{"id": "4lGcRK", "name": "raymarching0913", "author": "ukonpower", "description": "This is my first raymarching shader.", "tags": ["raymarching"], "likes": 1, "viewed": 58, "published": "Public", "date": "1536859698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\n\nvec3 cPos = vec3(0,0,3);\n\nconst float sSize = 0.5;\n\nfloat sphereDF(vec3 p){\n\treturn length(mod(p,2.0) - 1.0) - sSize;\n}\n\nvec3 getNormal(vec3 p){\n    float delta = 0.001;\n\tvec3 dx = vec3(delta,0.0,0.0);\n\tvec3 dy = vec3(0.0,delta,0.0);\n\tvec3 dz = vec3(0.0,0.0,delta);\n    vec3 result;\n    result.x = sphereDF(p + dx) - sphereDF(p - dx);\n    result.y = sphereDF(p + dy) - sphereDF(p - dy);\n    result.z = sphereDF(p + dz) - sphereDF(p - dz);\n    \n    return normalize(result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = (fragCoord * 2.0  - iResolution.xy ) / min(iResolution.x,iResolution.y);\n\tvec3 ray = normalize(vec3(sin(fov) * pos.x,sin(fov) * pos.y,sin(iTime)));\n    \n    float rDistance = 0.0;\n    float rLen = 0.0;\n    cPos.z -= iTime * 10.0;\n    cPos.y = sin(iTime) * 5.0;\n    cPos.x = cos(iTime * 0.5) * 2.0;\n    vec3 rPos = cPos;\n    \n    for(int i = 0; i < 64; i++){\n    \trDistance = sphereDF(rPos);\n        rLen += rDistance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    vec3 col = vec3(0,0,0);\n    if(abs(rDistance) <= 0.01){\n        vec3 normal = getNormal(rPos);\n        float diff = clamp(dot(vec3(0.5,0.5,0.5), normal), 0.1, 1.0);\n        col = vec3(diff);\n        col.x += (sin(iTime) + 1.0 ) / 2.0;\n    }else{\n        col = vec3(0,0,0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 175, 175, 219], [221, 221, 244, 244, 575], [577, 577, 634, 684, 1483]], "test": "valid"}
{"id": "4lGcWK", "name": "Tst", "author": "pixtole", "description": "Test", "tags": ["test"], "likes": 1, "viewed": 344, "published": "Public API", "date": "1537644115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "valid"}
{"id": "4lGcWW", "name": "Birefringence", "author": "zproxy", "description": "Birefringence in a crystal of calcite. Different polarisations\nof light are refracted through the crystal by different amounts,\ngiving rise to a double image.\n\nhttps://www.shadertoy.com/view/Mdtyzj\n", "tags": ["refraction"], "likes": 5, "viewed": 148, "published": "Public", "date": "1536151452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Refraction Exercise\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nSimple example showing refraction and reflection (mousing recommended).\nRepeating sets of three cycles: 1) Vary refractive index. 2) Perturb surface\nnormals by varying amount. 3) Combine both.\n(Uses conditionless normals for block.)\n*/\n\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, blkPos, blkSize, qnBlk[2], qnBall, vnCylOut;\nfloat tCur, dstFar, bCylRad, bCylHt, dCylOut;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 blkSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk[0] = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qnBlk[1] = - sign (rd) * step (tp, tp.zxy) * step (tp, tp.yzx);\n  }\n  return vec2 (dMin, df);\n}\n\nfloat BallHit (vec3 ro, vec3 rd, float rad)\n{\n  float dMin, d, b, w;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w >= 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      qnBall = (ro + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd;\n  rd = normalize (vec3 (rd.x, max (0.001, rd.y), rd.z));\n  ro.xz += tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  return mix (vec3 (0.2, 0.3, 0.65) + 0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.), vec3 (0.9),\n     clamp (3. * (Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz)) - 0.5) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV;\n  InCylHit (ro + vec3 (0., - bCylHt + 1.25, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - 1.75) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (64. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.3) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.8, 0.7, 0.5);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        qw = 16. * vec2 (12. * aa, hy);\n        rg = ShStagGrid (qw);\n        col *= rg.y * (1. - 0.3 * Noisefv2 (8. * qw));\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, sunDir), 0.)) +\n         0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    qh = HexGrid (4. * ro.zx);\n    f = max (length (qh.xy) - 0.5, 0.) * b;\n    vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vn = VaryNf (64. * ro, vn, 0.2 * b);\n    col = vec3 (0.72, 0.75, 0.72) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n       (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    col *= 0.9 + 0.1 * smoothstep (0., 2., BlkHit (ro - blkPos, sunDir, blkSize).x);\n    col *= 0.7 + 0.3 * smoothstep (0., 3., BallHit (ro - blkPos, sunDir, 0.6 * blkSize.y));\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, float rIndx)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, vno, rdo, roo, rdr;\n  vec2 dBlock, a;\n  //  //float dBall, rIndx, nVar, tt, b;\nfloat dBall, nVar, tt, b;\n  bool isBall;\n  blkPos = vec3 (0., bCylHt - 2.5, 0.);\n  blkSize = vec3 (2., 1., 2.);\n  tt = floor (mod (tCur / 10., 3.));\n  b = SmoothBump (0.2, 0.8, 0.1, mod (tCur / 10., 1.));\n  //rIndx = (tt == 1.) ? 1.05 : 1.05 + 2.5 * b * b;\n  //rIndx =   1.05 ;\n\n\n    // anything outside the glass...\n  \n   vec3 col0 = BgCol (ro, rd);\n   \n   col =  col0; // 36fps to  24fps\n    \n  dBlock = BlkHit (ro - blkPos, rd, blkSize);\n  if (dBlock.x < dstFar) {\n      \n//        rIndx =   1.25 ;\n\n    //  nVar = (tt == 0.) ? 0. : 0.5 * b;\n  //nVar =   0.5 ;\n  nVar =   0.01 ;\n      \n    ro += dBlock.x * rd;\n    roo = ro;\n    rdo = rd;\n    vno = VaryNf (ro + 0.1 * tCur, qnBlk[0], nVar);\n    rd = refract (rd, vno, 1. / rIndx);\n    dBlock = BlkHit (ro - blkPos, rd, blkSize);\n//    dBall = BallHit (ro - blkPos, rd, 0.6 * blkSize.y);\n      // lets make the ball go away.\n      // will still be there as a vampire in reflection tho\n          dBall = BallHit (ro - blkPos, rd, 0.0 * blkSize.y);\n\n    if (dBall < dBlock.y) \n    {\n        // this would cut out the ball\n        //isBall = true;\n    }\n    else {\n      ro += dBlock.y * rd;\n      qnBlk[1] = VaryNf (ro + 0.1 * tCur, qnBlk[1], nVar);\n      rdr = refract (rd, qnBlk[1], rIndx);\n      if (length (rdr) > 0.) {\n        rd = rdr;\n        col = vec3 (0.8, 1., 0.8) * BgCol (ro, rd);\n      } else {\n        rd = reflect (rd, qnBlk[1]);\n        dBlock = BlkHit (ro - blkPos, rd, blkSize);\n        //dBall = BallHit (ro - blkPos, rd, 0.6 * blkSize.y);\n                dBall = BallHit (ro - blkPos, rd, 0.0 * blkSize.y);\n\n          if (dBall < dBlock.y) isBall = true;\n        else col = vec3 (0.8, 1., 0.8) * BgCol (ro, rd);\n      }\n    }\n   \n    vec3 col00 = mix (col, BgCol (roo, reflect (rdo, vno)), pow (1. - abs (dot (rdo, vno)), 5.));\n    \n      \n      \n      // and add a secondary ray..\n      \n      \n      \n    col = col00;\n  }\n    \n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 20.;\n  bCylRad = 16.;\n  bCylHt = 3.;\n  az = -0.83 * pi + (1.2/16.) * pi * (floor (0.2 * tCur) +\n     smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.06 * pi;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.03 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -0.75 * bCylRad);\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  fragColor = vec4 (\n      mix(\n      ShowScene (ro, rd,  1.15),\n          // http://www-g.eng.cam.ac.uk/CMMPE/lcintro4.html\n      ShowScene (ro, rd,  1.05),\n           0.5\n         ) , 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGcWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[127, 711, 757, 757, 1263], [1265, 1265, 1310, 1310, 1548], [1550, 1550, 1584, 1584, 2105], [2107, 2107, 2139, 2139, 2458], [2460, 2460, 2486, 2486, 2836], [2838, 2838, 2869, 2869, 5826], [5828, 5828, 5876, 5876, 7923], [7925, 7925, 7981, 7981, 9056], [9058, 9058, 9082, 9082, 9312], [9314, 9314, 9338, 9338, 9398], [9400, 9400, 9423, 9423, 9556], [9558, 9558, 9615, 9615, 9698], [9700, 9700, 9730, 9730, 9804], [9838, 9838, 9862, 9862, 9992], [9994, 9994, 10019, 10019, 10205], [10207, 10207, 10228, 10228, 10383], [10385, 10385, 10414, 10414, 10626], [10628, 10628, 10667, 10667, 10847]], "test": "error"}
{"id": "4lGczG", "name": "Exp.fract", "author": "tqle", "description": "fraction", "tags": ["experiments"], "likes": 1, "viewed": 96, "published": "Public", "date": "1536690812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotate\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n\n// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = 2.5;\n    \n    // Transform coordinate space so spheres repeat\n    //vec3 q = fract(p) * 2.0 - 1.0;\n    float size = 2.;\n    float halfSize = size/2.;\n\tvec3 q = mod(p+halfSize, size)*size-halfSize;\n    \n    // Signed distance of sphere\n    return sphere(q, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 7; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += abs(d)*abs(d) - cos(abs(t+2.0))*7.5;\n        }\n    return t+2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 2.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    ray.yz *= rot(iTime*0.2);\n    ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(0.0, 0.0, sin(iTime));\n    float t = trace(origin, ray);\n    \n    \n    float linearFog = 1.5 / (1.0 - t*0.2);\n    float expFog = 2.0 / (t*t*0.1);\n    \n    vec3 fc = vec3(linearFog);\n\n    // Output pixels to screen\n    //fragColor = vec4(fc,1.0*iTime);\n    \n    // Try oscilating the final pixels\n    fragColor = vec4(cos(fc*fc - 10.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 28, 28, 96], [99, 113, 148, 148, 179], [182, 226, 245, 245, 531], [534, 534, 569, 569, 759], [762, 762, 819, 869, 1542]], "test": "valid"}
{"id": "4lGyWD", "name": "L'oeil du Dragon Bleu", "author": "hamsterNinja", "description": "\n", "tags": ["youpi"], "likes": 3, "viewed": 106, "published": "Public", "date": "1536168998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    return mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n               mix(hash(n+ 57.), hash(n+ 58.),f.x),f.y);\n}\n\nfloat Band(float t, float start, float end, float blur){\n    return smoothstep (start-blur, start+blur, t) * smoothstep (end+blur, end-blur, t);\n}\n\nvec3 clampcolor (vec3 color, float max){ \n\tcolor.x = clamp (color.x,0.,max);\n    color.y = clamp (color.y,0.,max);\n    color.z = clamp (color.z,0.,max);\n    return color;\n}\n\nfloat circle(vec2 uv, float r, float blur){\n    float d = length(uv);\n    return smoothstep(r, r-blur, d);\n}\n\nvec3 line (vec2 uv, vec3 uv3, float tlag, float speed, float clag, float thin, float pos, float blur){        \n    float t = iTime+tlag;\n    vec3 color = 0.5*cos(t+clag+uv3) + 0.5*cos(t+clag+uv3);\n    float parable = (uv.x-0.5)*(uv.x+0.5)*4.;\n\tfloat m = sin(t*speed+uv.x)*.4;\n\tfloat mask = Band(uv.y-m*parable, pos, pos+thin, .1*abs(uv.x)*blur+0.01);\n    color *= mask;\n    return color*noise(vec3(uv*500.,(tlag)));\n}   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 color;\n    color *= vec3 (0.9,0.7,0.7);\n    \n    for (int i = 0; i < 100; i++) {\n        color += line(uv, uv.xxy, float(i), 1., float(i), .01, -.0, .1);\n        color = clampcolor(color, 1.);\n    }\n\tcolor += color;\n    color *= circle(uv, .5, .01);\n    \n    //color = clampcolor(color, 1.);\n\tcolor += circle(uv, .10, .01)*(noise(vec3(uv*500.,iTime))*4.);\n    color.x -= 1.;\n    color.y -= 1.;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 62], [65, 65, 91, 103, 326], [328, 328, 384, 384, 474], [476, 476, 516, 516, 648], [650, 650, 693, 693, 758], [760, 760, 862, 862, 1177], [1183, 1183, 1239, 1239, 1780]], "test": "valid"}
{"id": "4lGyWh", "name": "Pipe Maze", "author": "nr4", "description": "Maze from tiled pipes. 2D for simplicity. Working on drawing connected pipes in the same color :)", "tags": ["2d", "maze", "tiles"], "likes": 5, "viewed": 188, "published": "Public", "date": "1536041748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Pipe Maze\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Simplified line(.) by using dot product with normalized orthogonal projection\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat line(vec2 x, vec2 p1, vec2 p2, float w)\n{\n    vec2 d = normalize(p2-p1);\n    return abs(dot(x-p1, d.yx*c.zx))-w;\n}\n\n// Distance to circle\nfloat circle(vec2 x, float r)\n{\n    return length(x)-r;\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Check if specific connector near y is connected\nvec2 connected(vec2 y, vec2 i)\n{\n    float d1 = .25*pi, d2 = .5*pi,\n        p0 = atan(y.y,y.x),\n        phi = mod(p0+d1, d2)-d1, \n        j = mod(round((p0-phi)/d2), 4.),\n        edge = rand(mod(i,100.)+.5*j);\n    return vec2(j, edge);\n}\n\n// Distance to tiled pipes\nvec4 pipes(vec2 x, float d)\n{\n    x += .25*iTime*c.yx;\n    float cp = .5, co = 0.;\n    \n    // Determine cell coordinates and cell index\n    vec2 y = mod(x, d)-.5*d,\n        i = round((x-y)/d + .5),\n        k = connected(y,i);\n    vec4 sdf = c.xyyy;\n    \n    // Compute pipes\n    if(round(mod(i.x+i.y,2.)) == 0.)\n    {\n        // Half of them can be random!\n        if(k.y >= cp) co = 1.;\n    }\n    else\n    {\n        // Choose orientation and number of connectors matching to neighbours\n        vec2 top = connected(c.yz, i+c.yx),\n            right = connected(c.zy, i+c.xy),\n            bottom = connected(c.yx, i+c.yz),\n            left = connected(c.xy, i+c.zy);\n        if(\n            ((bottom.y >= cp) && (k.x == 3.)) ||\n            ((left.y >= cp) && (k.x == 2.)) ||\n            ((top.y >= cp) && (k.x == 1.)) ||\n            ((right.y >= cp) && (k.x == 0.))\n        )\n            co = 1.;\n    }\n\n    // Draw\n    if(co == 1.)\n    \tsdf = add(sdf, vec4(line(y, c.yy, .5*d*vec2(cos(.5*k.x*pi), sin(.5*k.x*pi)), .175*d), .2*c.xxx));\n    sdf = add(sdf, vec4(circle(y, .25*d), .2*c.xxx));\n    \n    return add(sdf, vec4(stroke(sdf.x, .05*d), c.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    vec4 s = pipes(uv, .025);\n\tvec3 col = s.gba*smoothstep(1.5/iResolution.y, -1.5/iResolution.y, s.x);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGyWh.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[875, 892, 913, 913, 983], [985, 1013, 1060, 1060, 1133], [1135, 1157, 1188, 1188, 1214], [1216, 1253, 1285, 1285, 1308], [1310, 1359, 1389, 1389, 1531], [1533, 1584, 1616, 1616, 1821], [1823, 1850, 1879, 1879, 3002], [3004, 3004, 3059, 3059, 3236]], "test": "error"}
{"id": "4lKcDD", "name": "Sine mountains", "author": "morimea", "description": "[b]Warning code is bad.[/b]\nMade just as try of learning shaders. Has no other use.", "tags": ["2d", "mountain"], "likes": 29, "viewed": 976, "published": "Public API", "date": "1536296307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License - CC0 or use as you wish\n\nfloat xRandom(float x) {\n    return mod(x * 7241.6465 + 2130.465521, 64.984131);\n}\n\nfloat mfunc(float x, float xx, float yy) {\n    x /= .20 * 3.14159;\n    x = mod((x)*2.0, 2.8) - 1.195;\n    x *= 19.0 * 3.14159;\n    return abs(8. + abs(-19.15 + abs(-15.0 + yy + abs(-12.25 - yy + abs(-18.0 + xx + abs(-15.0 - xx + abs(.95 * x + 4.0))))))) / 100.;\n}\n\nfloat hash2(in vec2 p) {\n    return fract(dot(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat noise2(float y, float t) {\n    vec2 fl = vec2(floor(y), floor(t));\n    vec2 fr = vec2(fract(y), fract(t));\n    float a = mix(hash2(fl + vec2(0.0, 0.0)), hash2(fl + vec2(1.0, 0.0)), fr.x);\n    float b = mix(hash2(fl + vec2(0.0, 1.0)), hash2(fl + vec2(1.0, 1.0)), fr.x);\n    return mix(a, b, fr.y);\n}\n\nfloat line(vec2 uv, float width, float center) {\n    float b = (1. - smoothstep(.0, width / 2., (uv.y - center)))*1.; \n    return b;\n}\n\nconst vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 dark = vec3(0x1a, 0x13, 0x21) / float(0xff);\nconst vec3 bluebg = vec3(0x00, 0x19, 0x5e) / float(0xff);\nconst vec3 colsun = vec3(0x07, 0xaf, 0x81) / float(0xff);\nconst vec3 white2 = vec3(0xec, 0xe8, 0x9e) / float(0xff);\n\nconst vec3 l1 = vec3(0x07, 0x27, 0x21) / float(0xff);\nconst vec3 l2 = vec3(0x00, 0x6c, 0xae) / float(0xff);\nconst vec3 l3 = vec3(0x00, 0x48, 0x7f) / float(0xff);\nconst vec3 treecol = vec3(0x12, 0x19, 0x27) / float(0xff);\nconst vec3 watercol = vec3(0xcf, 0xe5, 0xf2) / float(0xff);\n\nconst vec3 traincol = vec3(0x00, 0x6a, 0xb9) / float(0xff);\nconst vec3 trainlcol = vec3(0xef, 0xe8, 0x95) / float(0xff);\nconst vec3 toplvlcol = vec3(0x00, 0x6a, 0x71) / float(0xff);\n\nfloat circle(in vec2 uv, float r1, float r2, bool disk) {\n    float w = 2.0 * fwidth(uv.x);\n    float t = r1 - r2;\n    float r = r1;\n\n    if (!disk)\n        return smoothstep(-w / 2.0, w / 2.0, abs(length(uv) - r) - t / 2.0);\n    else\n        return smoothstep(-w / 3.0, w / 3.0, (length(uv) - r));\n}\n\nfloat circle2(in vec2 uv, float r1, float r2, bool disk) {\n    float w = 2.0 * fwidth(uv.x);\n    float t = r1 - r2;\n    float r = r1;\n    if (!disk)\n        return smoothstep(-w / 2.0, w / 2.0, abs(length(uv) - r) - t / 2.0);\n    else\n        return smoothstep(-w / 3.0, 1.05 + w / 3.0, (length(uv) - r));\n}\n\nfloat w1(float x) {\n    x += -0.45;\n    float iTime = mod(iTime+150.1, 310.);\n    if (iTime > 150.)\n        return 01.5 + 010.15 * mfunc(x * .7, -80. * (cos(0.5 + mod(0. / 150. + 1., 3.))), 0.);\n    else\n        if (iTime > 5.)\n        return 01.5 + 010.15 * mfunc(x * .7, -80. * (cos(0.5 + mod((iTime - 5.) / 140. + 1., 3.))), 0.);\n    else\n        return 01.5 + 010.15 * mfunc(x * .7, -80. * (cos(0.5 + mod((0.) / 140. + 1., 3.))), 0.);\n}\n\nfloat layer(vec2 uv) {\n    float iTime = mod(iTime+150.1, 310.);\n    vec2 ouv = uv;\n    uv *= 0.5;\n    if (iTime > 150.)\n        uv.x += ((iTime - 150.) / 200.);\n    uv.x += 50.;\n    uv.y += -0.21;\n    float Range = 100.;\n    float Line_Smooth = 1.;\n    float Amplitude1 = w1(uv.x);\n    vec2 p = uv;\n    float Light_Track = line(vec2(p.x, p.y * 1.5 + (Amplitude1 - .5)*.12 * Line_Smooth), .005, .0);\n    if (iTime < 150.)\n        return Light_Track * smoothstep(0., 5., iTime);\n    else if (iTime < 300.)\n        return Light_Track * smoothstep(150., 155., iTime);\n    else\n        return Light_Track * smoothstep(305., 300., iTime);\n}\n\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\nfloat shape(vec2 uv, int N, float radius_in, float radius_out, float zoom) {\n    float color = 0.0;\n    float d = 0.0;\n    float a = atan(uv.x, uv.y) + PI;\n    float rx = TWO_PI / float(N);\n    d = cos(floor(.5 + a / rx) * rx - a) * length(uv);\n    color = smoothstep(.44, .44 + (2. + 1.2 * zoom) / iResolution.y, abs(d - radius_in) + radius_out);\n    return (1. - color);\n}\n\nfloat msine(vec2 uv) {\n    float heightA = 0.025;\n    float heightB = 0.025;\n    float heightC = 0.013; //+0.071*sin(iTime/105.); //xD\n    uv.y = sin((uv.x + (1.))*5.0) * heightA;\n    uv.y = uv.y + sin((uv.x + (0. / 5.))*3.0) * heightB;\n    uv.y = uv.y + sin((uv.x + (1.))*2.0) * heightC;\n    return uv.y;\n}\n\nfloat trees(vec2 uv) {\n    float zoom = 10.;\n    uv.x += iTime / 35.;\n    uv *= zoom;\n    vec2 tuvy = vec2(0., 08. * msine(vec2(floor(uv.x / (0.38)), uv.y) / zoom));\n    float rval = xRandom(floor(uv.x / 0.38));\n    float d = 0.;\n    if (rval > (85.) * fract(cos(rval)) + 85. * (sin(rval))) {\n        rval = max(1., 2.5 * abs(sin(rval)));\n        uv.x = mod(uv.x, 0.38) - 0.19;\n        uv += tuvy;\n        uv *= rval;\n        float xval = 1.2 * sin(xRandom(tuvy.y))*0.19 * (1.25 - rval);\n        uv.y += 0.75 / rval;\n        uv.x += xval;\n        vec2 ouv = uv;\n        uv.y *= .85;\n        d = shape(uv, int(3.), -0.380, 0., zoom + rval);\n        uv.y += .12;\n        uv.y *= .75;\n        d = max(d, shape(uv, int(3.), -0.370, 0., zoom + rval));\n        uv.y += .1;\n        uv.y *= 1.2;\n        d = max(d, shape(uv, int(3.), -0.3650, 0., zoom + rval));\n        d = max(d, smoothstep(0.02 + (2. + 1.2 * (zoom + rval)) / iResolution.y, 0.02, abs(uv.x)) * step(ouv.y, 0.)) *\n                step(-0.75 + 0.12 * (2.5 - rval), ouv.y);\n    }\n    return d;\n}\n\nfloat layer_bghills(vec2 uv) {\n    uv.x += iTime / 35.;\n    float d = smoothstep(0.5 + 20. / iResolution.y, 0.5, msine(uv / 0.38 - 0.038)*10. + uv.y * 10. + 01.6);\n    return d;\n}\n\nfloat treex(vec2 uv) {\n    uv.y += 0.08;\n    float d = trees(uv);\n    return d;\n}\n\nfloat water(vec2 uv) {\n    float d;\n    d = step(uv.y, -0.25);\n    return d;\n}\n\n\n#define HASHSCALE1 443.8975\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float t = f * f * (3.0 - 2.0 * f);\n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\n\nfloat fbm(float x, float persistence, int octaves) {\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    for (int i = 0; i < octaves; ++i) {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return (total / maxValue);\n}\n\nfloat msine2(vec2 uv) {\n    return (fbm(uv.x / 10., 0.25, 4)*20. + 0.5);\n}\n\nfloat trees2(vec2 uv) {\n    float zoom = 10.;\n    uv.x += iTime / 45.;\n    uv *= zoom;\n    vec2 tuvy = vec2(0., 0.2 * msine2(vec2(floor(uv.x / 0.38), uv.y)));\n    float rval = xRandom(floor(uv.x / 0.38));\n    float d = 0.;\n    if (rval > (55.) * fract(cos(rval)) + 85. * (sin(rval))) {\n        rval = max(1.5, 2.5 * abs(sin(rval)));\n        uv.x = mod(uv.x, 0.38) - 0.19;\n        uv += tuvy;\n        uv *= rval;\n        float xval = -1.2 * sin(xRandom(tuvy.y))*0.19 * (1.25 - rval);\n        uv.y += -0.25 / rval;\n        uv.x += xval;\n        vec2 ouv = uv;\n        uv.y *= .85;\n        d = shape(uv, int(3.), -0.380, 0., zoom + rval);\n        uv.y += .12;\n        uv.y *= .75;\n        d = max(d, shape(uv, int(3.), -0.370, 0., zoom + rval));\n        uv.y += .1;\n        uv.y *= 1.2;\n        d = max(d, shape(uv, int(3.), -0.3650, 0., zoom + rval));\n        d = max(d, smoothstep(0.02 + (2. + 1.2 * (zoom + rval)) / iResolution.y, 0.02, abs(uv.x)) * step(ouv.y, 0.)) *\n                step(-0.75 + 0.12 * (2.5 - rval), ouv.y);\n    }\n    return d;\n}\n\nfloat layer_bghills2(vec2 uv) {\n    uv.x += 1.2;\n    uv.x += iTime / 45.;\n    float d = smoothstep(5.5 + 20. / iResolution.y, 5.5, msine2(uv / 0.38 - 0.038)*40. + uv.y * 40. + 010.6);\n    d = smoothstep(-0.1555 + 8. / iResolution.y, -0.1555, .2 * msine2((uv * 10.) / 0.38 - 0.038) + uv.y * 11. + 0.86);\n    return d;\n}\n\nfloat treex2(vec2 uv) {\n    uv.x += 1.2;\n    uv.y += 0.08;\n    float d = trees2(uv);\n    return d;\n}\n\nvec3 undw(in vec2 uv, vec3 tc) {\n    vec2 res = iResolution.xy / iResolution.y;\n    uv.x += iTime / 10.;\n    uv += res / 2.;\n    uv.y = 1. - uv.y;\n    uv.y += -0.759;\n    uv.x *= .5;\n    uv *= 5.3;\n    float divs = 5.;\n    float slope = 4.2;\n    float y_off = sin(2. * uv.y + 0. * iTime / 1.73);\n    float vy = (uv.y + (floor(5. - (uv.y + 02.75) / .52) / 5.) * sin(uv.x * 6.28318 + y_off)*.1 - .05);\n    float c = (smoothstep(0., 1., mod(vy*divs, 1.0) * slope) + floor(vy * divs)) / divs;\n    vec2 uv_d = vec2(uv.x * 0.3 + y_off * .01, c);\n    vec2 uv_d2 = vec2(uv.x + y_off * .05, .3 * c + .7 * vy);\n    vec3 fragColor;\n    vec3 gamma = vec3(0.65 * 2.2, .8 * 2.2, 2.2);\n    gamma = tc;\n    fragColor.r = pow(c, 1. / gamma.r);\n    fragColor.g = pow(c, 1. / gamma.g);\n    fragColor.b = pow(c, 1. / gamma.b);\n    fragColor.rgb *= tc * (-noise2(uv_d.x, uv_d.y)*.3 + .7);\n    return max(vec3(0.), fragColor);\n}\n\nfloat trainxl(vec2 uv) {\n    uv.y += 0.3;\n    uv.y += -0.07;\n    vec2 ouv = uv;\n    uv.x = mod(uv.x, 0.01) - 0.005;\n    float d = smoothstep(0.0045 + 2. / iResolution.y, 0.0025, abs(uv.x));\n    d *= step(abs(uv.y), 0.0025);\n    uv.x = ouv.x;\n    uv.x = mod(uv.x, 0.15) - 0.005;\n    d *= step(abs(uv.x), 0.0025 * 50.);\n    d *= step(ouv.x, -0.05);\n    d *= step(-0.50, ouv.x);\n    d += smoothstep(0.0110 + 2. / iResolution.y, .01, abs(ouv.x + 0.021)) * step(abs(uv.y), 0.0025);\n    d += smoothstep(0.025 + 2. / iResolution.y, .024, abs(ouv.x - 0.035)) * step(abs(uv.y), 0.0025);\n    return d;\n}\n\nfloat trainx(vec2 uv) {\n    uv.y += 0.325;\n    float d = 1. - circle(uv, 0.11, 0., true);\n    float stval = step(0.07, uv.y);\n    d *= stval;\n    d = max(d, step(-0.5, uv.x) * step(uv.x, 0.0) * step(uv.y, 0.109)) * stval;\n    d = max(d, 1. - circle(uv + vec2(0.5, 0.), 0.11, 0., true)) * stval;\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res / 2.0;\n    float b = 1. - circle(uv - 0.21, 0.1242, 0.22, true);\n    vec3 col = vec3(bluebg);\n    float b1 = 1. - circle2(uv - 0.21, 0.1242, 0.22, true);\n    float b2 = smoothstep(-01., -0.05, uv.y);\n    float lx1 = layer(uv + vec2(0., -0.152));\n    col = (col - lx1 * l1 * b1);\n    col += (b1) * colsun;\n    col = mix(col, white2, min(b, 1. - lx1));\n    col = mix(col, l2*b1, layer_bghills2(uv + vec2(0., -0.05)));\n    col = mix(col, 3. * treecol*b1, treex2(uv + vec2(0., -0.05)));\n    col = mix(col, l3*b1, layer_bghills(uv + vec2(0., 0.0)));\n    col = mix(col, treecol*b1, treex(uv + vec2(0., 0.0)));\n    vec3 toplvlcol2 = vec3(0.);\n    if ((uv.y<-0.25))\n        toplvlcol2 = undw(uv, watercol);\n    col = mix(col, toplvlcol2 + 0.42 * b2*l2, water(uv));\n    uv.x += 0.3 * (sin(0.5 * sin(iTime / 8.) + cos(iTime / 10.)));\n    float trx = trainx(uv);\n    col = mix(col, traincol*b1, (trx * (1. - water(uv))));\n    col = mix(col, trainlcol, trainxl(uv) * trx);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKcDD.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1, 38, 62, 62, 120], [122, 122, 164, 164, 385], [387, 387, 411, 411, 505], [507, 507, 539, 539, 811], [813, 813, 861, 861, 947], [1702, 1702, 1759, 1759, 2002], [2004, 2004, 2062, 2062, 2311], [2313, 2313, 2332, 2332, 2753], [2755, 2755, 2777, 2777, 3390], [3443, 3443, 3519, 3519, 3817], [3819, 3819, 3841, 3841, 4126], [4128, 4128, 4150, 4150, 5180], [5182, 5182, 5212, 5212, 5361], [5363, 5363, 5385, 5385, 5444], [5446, 5446, 5468, 5468, 5524], [5556, 5556, 5579, 5579, 5699], [5701, 5701, 5740, 5740, 5770], [5772, 5772, 5794, 5794, 5947], [5949, 5949, 6001, 6001, 6325], [6327, 6327, 6350, 6350, 6401], [6403, 6403, 6426, 6426, 7451], [7453, 7453, 7484, 7484, 7771], [7773, 7773, 7796, 7796, 7873], [7875, 7875, 7907, 7907, 8781], [8783, 8783, 8807, 8807, 9376], [9378, 9378, 9401, 9401, 9688], [9690, 9690, 9745, 9745, 10838]], "test": "error"}
{"id": "4lKcDK", "name": "Assignment-2", "author": "elijah_green14", "description": "assignment for class", "tags": ["practice"], "likes": 3, "viewed": 94, "published": "Public", "date": "1537891772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Elijah Green\n//9/24/2018\n//Assignment 2 \nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateZ(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, s, 0.0,\n        -s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t\t\n\t);\n}\n\nfloat kEpsilon = 1e-8;\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+trd = p(u,v) = vo + u(v1-v0) + v(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n\n\n\n\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n    if(t < 0.001)\n        return false;\n    \n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\nbool planeTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\n\n//send a ray toward a sphere?\n//return true if it intersects sphere\n//also set the intersecting 3D Point\n//and reflected Ray direction\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 spherePos, in float sphereRadius,\n\tout vec3 intersectPos, out vec3 intersectDir) {\n\n\t//create a vector from ray Starting Point to Sphere Center\n\tvec3 L = spherePos - rayPos;\n\n\t//project that ray onto my ray direction and get its length\n\tfloat tc = dot(L, rayDirection);\n\n\tif (tc < 0.0)\n\t\treturn false;\n\n\t//float d = sqrt(pow(length(L), 2.0) - pow(tc,2.0));\n\tfloat d = sqrt(dot(L, L) - pow(tc, 2.0));\n\tif (d > sphereRadius)\n\t\treturn false;\n\n\tfloat t1c = sqrt(pow(sphereRadius, 2.0) - pow(d, 2.0));\n\n\t//distance from ray Start to hitting the sphere\n\tfloat t1 = tc - t1c;\n\n\t//results in 3D point where ray hits the sphere\n\tintersectPos = rayPos + rayDirection * t1;\n\n\tvec3 normal = normalize(intersectPos - spherePos);\n\n\tintersectDir = reflect(rayDirection, normal);\n\n\treturn true;\n\n}\n\nconst ivec3 CUBE_INDEX[12] = ivec3[12](\n\tivec3(0, 1, 2),\n\tivec3(2, 1, 3),\n\tivec3(2, 3, 4),\n\tivec3(4, 3, 5),\n\tivec3(4, 5, 6),\n\tivec3(6, 5, 7),\n\tivec3(6, 7, 0),\n\tivec3(0, 7, 1),\n\tivec3(1, 7, 3),\n\tivec3(3, 7, 5),\n\tivec3(6, 0, 4),\n\tivec3(4, 0, 2)\n\t);\n\n\nconst vec3 CUBE_VERTS[8] = vec3[8](\n\tvec3(-0.25, -0.45, 0.35),\n\tvec3(0.35, -0.45, 0.25),\n\tvec3(-0.25, 0.45, 0.35),\n\tvec3(0.35, 0.45, 0.25),\n\tvec3(-0.45, 0.25, -0.35),\n\tvec3(0.35, 0.25, -0.25),\n\tvec3(-0.25, -0.25, -0.25),\n\tvec3(0.35, -0.25, -0.25)\n\t);\n\n\nconst vec3 SPHERE_POS[3] = vec3[3](vec3(2.0, 0.5, -1.0),\n\tvec3(0.5, 0.0, 0.0),\n\tvec3(0.55, 0.25, -1.0)\n\n\t);\n\nconst vec3 SPHERE_COLOR[3] = vec3[3](vec3(0.2, 0.0, 0.0),\n\tvec3(0.8, 0.75, 0.5),\n\tvec3(0.0, 1.0, 0.0)\n\t);\n\nconst float SPHERE_RADIUS[3] = float[3](0.8, 0.25, 0.25\n\t);\n\nconst vec3 LIGHT_POS[3] = vec3[3](vec3(1.0, 10.0, 0.0),\n\tvec3(-5.0, 2.5, 5.0),\n\tvec3(2.5, 2.5, 10.0)\n\n\t);\n\nconst vec3 LIGHT_COLOR[3] = vec3[3](vec3(0.0, 0.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.y*2.0;\n\tuv -= 0.5; //center the uvs\n\n\n\tvec3 cubePos = vec3(0.5, 0.55, -1.0);\n\n\n\tvec3 lightPos = vec3(0, 10, 0);\n\tvec3 lightPos2 = vec3(5, 0, 5);\n\n    vec3 rayPos = vec3(0.0,0.5, 3.0);\n    \n\tvec3 rayDir = normalize(vec3(uv.x*2.0, uv.y*2.0 , -3.0));\n\n\tvec3 planePos = vec3(0.0, -0.25, 0.0);\n\tvec3 planeNormal = vec3(0.0, 1.0, 0.0);\n\n\n\tvec3 newPos;\n\tvec3 newDir;\n\tvec3 currColor;\n\n\tvec3 col = vec3(0.0);\n\n\t//loop for ray bounces\n\tfor (int r = 0; r < 6; r++) {\n\n\n\n\t\tfloat minDist = 999999999.0;\n\t\tvec3 tempNewPos;\n\t\tvec3 tempNewDir;\n\n\t\t//foreach sphere in our scene check if ray hits it\n\t\tfor (int s = 0; s < 3; s++) {\n\n\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\tif (sphereTrace(rayPos, rayDir,\n\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = SPHERE_COLOR[s];\n\n\t\t\t\t}\n\n\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t}\n\n\t\t}\n\t\tfor (int f = 0; f < 12; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CUBE_VERTS[CUBE_INDEX[f].x] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].y] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].z] * rotateY(iTime) + cubePos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(0.5,0.0,1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos, planeNormal,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rrr;//vec3(1.0);\n\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n\n\n        if(planeTrace(rayPos, rayDir,\n                      //planePos, planeNormal,\n                       vec3(15,0,0), vec3(-1,0,0),\n                      tempNewPos, tempNewDir)){\n\n            float dist = distance(rayPos, tempNewPos);\n\n            if(dist < minDist){\n\n                minDist = dist;\n\n                newPos = tempNewPos;\n                newDir = tempNewDir;\n                //texture(sourceImage, 2D location in image to read from)\n                currColor = texture(iChannel2, vec2(newPos.y,newPos.z)/5.0).rgb;\n\n            }\n        }\n\n\t\tif (minDist < 50.0) { \n\n\t\t\trayPos = newPos;\n\t\t\trayDir = newDir;\n\n\n\n\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t//now let's check if this ray can see the light sources\n\n\t\t\t\tvec3 lightDir = normalize(LIGHT_POS[l] - rayPos);\n\t\t\t\tcol += (currColor*0.25 //ambient\n\t\t\t\t\t\t+ clamp(dot(rayDir, lightDir), 0.0, 1.0)*currColor //diffuse\n\t\t\t\t\t\t+ pow(clamp(dot(rayDir, lightDir), 0.0, 1.0), 50.8) * LIGHT_COLOR[l]\n\n\t\t\t\t\t\t) * (1.0/(float(r) + 1.0))\n\t\t\t\t\t\t* 50.0 / pow(distance(rayPos, LIGHT_POS[l]), 2.0);\n\n\t\t\t}\n\t\t}\n\n\t}\n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 68, 68, 173], [175, 175, 200, 200, 314], [340, 340, 497, 497, 1276], [1282, 1282, 1424, 1424, 1760], [1762, 1762, 1906, 1906, 2197], [2200, 2335, 2481, 2542, 3180], [4174, 4174, 4229, 4276, 7507]], "test": "error"}
{"id": "4lKcDt", "name": "Lissajous Table", "author": "halcy", "description": "based on https://www.shadertoy.com/view/XdSGzh by simesgreen\n\ndrag mouse to zoom", "tags": ["lissajouscurves"], "likes": 13, "viewed": 286, "published": "Public", "date": "1538165622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\nconst int steps = 200;\n\n// from https://www.shadertoy.com/view/XdSGzh\nvec2 lissajous(float t, float a, float b, float d) {\n\treturn vec2(sin(a*t+d), sin(b*t));\n}\nfloat lissajous_dist(vec2 uv, float a, float b, float phase) {\n\tfloat d = phase;\n    \n\tfloat m = 1.0;\n\tfloat period = 3.141*2.0;\n    vec2 lp = lissajous(iTime, a, b, d)*0.8;\n    for(int i = 1; i <= steps; i++) \n    {\n        float t = float(i)*period / float(steps);\n\t\tt += iTime;\n        vec2 p = lissajous(t, a, b, d)*0.8;\n\t\t\n\t\t// distance to line\n        vec2 pa = uv - p;\n        vec2 ba = lp - p;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        vec2 q = pa - ba*h;\n        m = min( m, dot( q, q ) );\n\t\t\n        lp = p;\n    }\n    m = sqrt( m );\n\tm = smoothstep(0.05, 0.0, m);\n    \n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float x_steps = floor(iMouse.x * 0.02) + 8.0;\n\tfloat y_steps = floor(iMouse.y * 0.02) + 5.0;\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.x *= x_steps;\n    uv.y *= y_steps;\n    float aorig = floor(uv.x);\n    float borig = y_steps - 1.0 - floor(uv.y);\n    uv = mod(uv, 1.0);\n    uv = (uv - 0.5) * 2.0;\n    float m = 0.0;\n    float fixphase = iTime * 0.2;\n    float speedmult = 0.0;\n    float ljtime = iTime;\n    float a = aorig;\n    float b = borig;\n    if(a == 0.0 || b == 0.0) {\n        ljtime *= max(a, b);\n    \ta = 1.0;\n        b = 1.0;\n    }\n    m = lissajous_dist(uv, a, b, fixphase);\n    \n    vec2 ljpos = lissajous(ljtime, a, b, fixphase) * 0.8;\n    if(length(ljpos - uv) < 0.1) {\n    \tfragColor.rgb = vec3(1.0);\n    }\n    \n    if(aorig != 0.0 && abs(ljpos.x - uv.x) < 0.03) {\n    \tfragColor.rgb = vec3(0.4);\n    }\n    \n    if(borig != 0.0 && abs(ljpos.y - uv.y) < 0.03) {\n\t\tfragColor.rgb = vec3(0.4);\n    }\n    \n    vec4 curveColorA = mix(vec4(255.0, 127.0, 39.0, 0.0), vec4(128.0), aorig / (x_steps / 2.0));\n    vec4 curveColorB = mix(vec4(128.0, 128.0, 255.0, 0.0), vec4(128.0), borig / (y_steps / 2.0));\n    vec4 curveColor = (curveColorA + curveColorB) / (255.0 * 2.0);\n    fragColor = mix(fragColor, curveColor, m);\n    \n    if(aorig == 0.0 && borig == 0.0) {\n    \tfragColor.rgb = vec3(0.0);   \n    }    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 96, 148, 148, 186], [187, 187, 249, 249, 804], [806, 806, 863, 863, 2201]], "test": "valid"}
{"id": "4lKcDw", "name": "Beginning Video Shader Thing", "author": "Shadeyboi", "description": "It's a sine line with blur", "tags": ["beginner"], "likes": 1, "viewed": 88, "published": "Public", "date": "1536586834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    \n    float d = length(uv - p); //distance, -p remaps that to be origin\n    float c = smoothstep(r, r-blur, d); //blurs the edges\n    \n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t); //goes from 0 to one, creates left side\n    float step2 = smoothstep(end+blur, end-blur, t); //inverted b/c would be zero to one\n    return step1*step2; //gives both sides/the intersection\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    float band1 = Band(uv.x, left, right, blur); //defines left and right\n    float band2 = Band(uv.y, bottom, top, blur); //defines top and bottom\n    \n    return band1*band2;\n}\n\n\nfloat Smiley(vec2 uv, vec2 p, float size){//Lets us copy smilies\n    \n    uv -= p; //translates coordinate system\n    uv /= size; //scaling coordinate system, works inversely\n    \n    float mask = Circle(uv, vec2(0.), .4, .01);\n    \n    mask -= Circle(uv, vec2(-.09, .2), .07, .01); //The two eyes being subtracted\n    mask -= Circle(uv, vec2(.09, .2), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0., 0.), .3, .02); //vec2 in method removes need for another variable\n    mouth -= Circle(uv, vec2(0., 0.1), .3, .02);\n    \n    mask -= mouth; //Subtracting the circle makes it black, technically 2 more circles\n    \n    return mask;\n}\n\nfloat remap01(float a, float b, float t){\n \treturn (t-a) / (b-a);   \n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a, b, t) * (d-c) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 to 1.\n    \n    float t = iTime;\n    \n    uv -= .5; //Center of the screen, not the origin, bottom left.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.); //color, not column\n    \n\tfloat mask = 0.;\n    \n\tfloat x = uv.x;\n    \n    float m = sin(t+x*8.)*.1;\n    float y = uv.y-m;\n    \n    float blur = remap(-.5, .5, .01, .25, x);\n    blur = pow(blur*4., 3.);\n    mask = Rect(vec2(x, y), -.5, .5, -.1, .1, blur);\n    \n    col = vec3(1., 1., 1.)*mask; //makes the yellow\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); //putting col in here changes the color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKcDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 206], [208, 208, 264, 264, 512], [514, 514, 596, 596, 775], [778, 778, 820, 842, 1415], [1417, 1417, 1458, 1458, 1487], [1489, 1489, 1546, 1546, 1589], [1591, 1591, 1648, 1648, 2286]], "test": "valid"}
{"id": "4lKcWV", "name": "Star 210", "author": "nr4", "description": "Stars with logo. ", "tags": ["raymarching", "stars"], "likes": 8, "viewed": 351, "published": "Public", "date": "1538170225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Star 210\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Edit 1: Remove Polygon SDF, as there are no polygons in the scene.\n// Edit 2: Optimized to <=300 raymarching iterations\n// Edit 3: Added abs(.) to dot(re,v) to fix lighting\n\nfloat iScale;\nfloat iNBeats;\nfloat iHighScale;\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\nvec2 ind;\n\n// hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// value noise\nfloat vnoise(vec2 x)\n{\n    vec2 y = floor(x);\n    x = fract(x);\n    float r00 = -1.+2.*rand(y),\n        r10 = -1.+2.*rand(y+c.xy),\n        r01 = -1.+2.*rand(y+c.yx),\n        r11 = -1.+2.*rand(y+c.xx);\n    return mix(\n        mix(r00, r10, x.x),\n        mix(r01, r11, x.x),\n        x.y\n    );\n}\n\nfloat mfvnoise(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*vnoise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\n// compute distance to regular star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d),\n        i = mod(round((p-p0)/d),2.);\n    x = length(x)*vec2(cos(p),sin(p));\n    vec2 a = mix(R,R.yx,i),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n   \tff = ff.yx*c.zx;\n    return dot(x-p1,ff)/length(ff);\n}\n\nfloat zextrude(float z, float d2d, float h)\n{\n    vec2 d = abs(vec2(min(d2d, 0.),z))-h*c.yx;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat cr(vec2 x, float r, float w)\n{\n    return abs(length(x)-r)-w;\n}\n\nfloat cs(vec2 x, float r0, float w, float p0, float p1)\n{\n    float r = length(x), p = acos(x.x/r)*step(0.,x.y)-acos(x.x/r)*step(x.y,0.);\n    p = clamp(p, p0, p1);\n    vec2 y = r0*vec2(cos(p), sin(p));\n    return length(x-y)-w;\n}\n\nfloat b(vec2 x, vec2 a, vec2 b, float w)\n{\n    vec2 d = b-a;\n    return length(x-mix(a, b, clamp(dot(x-a, d)/dot(d,d), 0., 1.)))-w;\n}\n\nvec2 rot(vec2 x, float p)\n{\n    return mat2(cos(p), sin(p), -sin(p), cos(p))*x;\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nvec2 scene(vec3 x)\n{\n    \n    float dr = .03, d, dh, h;\n    vec3 y = vec3(mod(x.xy, dr)-.5*dr, x.z), index = x-y;\n    \n    vec2 z = (index.xy-c.yx)*(.5);\n    float sd = min(cr(z-.125*c.xy, .125, .04), cs(z+.125*c.xy, .125, .04, -pi/2., pi/2.));\n    sd = min(sd, b(z, -.125*c.yx, .125*c.yx, .04));\n    \n    dh = .05*mfvnoise(index.xy-.5*iTime, 8., 100., .45)+.1*iScale*rand(index.xy);\n    h = .1+dh+(.1+iScale*.1)*step(sd,0.);\n    d = zextrude(y.z, dstar(rot(y.xy, 5.*iTime), 5.+5.*round(rand(3.*index.xy)), vec2(.2+.1*rand(2.*index.xy),.4+.1*rand(index.xy))*dr), h)-.001;\n    \n    ind = index.xy;\n    \n    if((sd < 0.) || (x.z < .5))\n    {\n    \tfloat guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .45),0.));\n        guard = abs(guard)+dr*.1;\n        d = min(d, guard);\n    }\n    \n    vec2 sdf = vec2(d, 1.+step(sd, 0.)), sda = vec2(x.z, 1.);\n    return mix(sdf, sda, step(sda.x, sdf.x));\n}\n\nconst float dx = 1.e-3;\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(scene(x+dx*c.xyy).x-s, scene(x+dx*c.yxy).x-s, scene(x+dx*c.yyx).x-s));\n}\n\nvec3 background(vec2 x)\n{\n    return c.yyy;\n}\n\nvec3 synthcol(float scale, float phase)\n{\n    vec3 c2 = .5*vec3(rand(phase*c.xx), rand(phase*c.xx+1.), rand(phase*c.xx+2.))+.5;\n    mat3 r1 = rot((5.e-1*phase)*vec3(1.1,1.3,1.5));\n    float sc = rand(phase*c.xx);\n    if(abs(sc) < .2)\n        sc = sign(sc)*.2;\n    return \n        (\n            sc*1.1*mix\n            (\n                mix(-(cross(c2, r1*c2)),c.yyy, .5*scale),\n                mix(c.yyy, -(r1*c2), .5*scale), \n                scale\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tiScale = mod(iTime, .5)/.5;\n \tiNBeats = floor(iTime*2.);\n \tiHighScale = mod(iTime, .5)/.5;\n    \n    vec2 uv = fragCoord/iResolution.yy-.5, s;\n    uv.x += .1*vnoise(uv+iTime);\n    vec3 or = rot(c.yyx*iTime)*(c.yyx-.2*c.yxy)+.5*c.yxy, ta = c.yxy, r = c.xyy, u = cross(r, normalize(ta-or)),\n        rt = ta+uv.x*r+uv.y*u, rd = normalize(rt-or), x, col;\n    \n    //Initialize rays with intersection distance of ray and plane above scene\n    float d = -(or.z-.45)/rd.z;\n    \n   \t//Interval approximation root solving\n   \tfloat D = -(or.z+.1)/rd.z, dm;\n\n    for(int i=0; i<300; ++i)\n    {\n        x = or + d * rd;\n        s = scene(x);\n        \n        if(s.x < 1.e-4) break;\n        if(i==299)\n        {\n            fragColor = vec4(background(uv), 1.);\n            return;\n        }\n        \n        d += s.x;\n    }\n\n    vec3 n = normal(x), l = 2.*c.yyx, re = normalize(reflect(-l, n)), v = normalize(or-x);\n    \n    if(s.y == 1.)\n    {\n        vec3 c1 = abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+1.1*ind.x*ind.y)), c2 = .1*abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+ind.x*ind.y));\n        col = .3*c1+.3*c1*abs(dot(l, n))+c2*abs(dot(re,v));\n    }\n    else if(s.y == 2.)\n    {\n        l = c.xxx;\n        vec3 c1 = abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+1.1*ind.x*ind.y+20.)), c2 = .2*abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+ind.x*ind.y+20.));\n        c1 += .1*mfvnoise(x.xz, 1., 100., .45);\n        col = .3*c1+.3*c1*abs(dot(l, n))+c2*abs(dot(re,v));\n    }\n    \n    fragColor = vec4(col, 1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKcWV.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1026, 1043, 1064, 1064, 1134], [1136, 1151, 1173, 1173, 1444], [1446, 1446, 1501, 1501, 1671], [1673, 1709, 1747, 1747, 2049], [2051, 2051, 2096, 2096, 2196], [2198, 2198, 2234, 2234, 2267], [2269, 2269, 2326, 2326, 2498], [2500, 2500, 2542, 2542, 2633], [2635, 2635, 2662, 2662, 2716], [2718, 2718, 2736, 2736, 2986], [2988, 2988, 3008, 3008, 3875], [3901, 3901, 3922, 3922, 4047], [4049, 4049, 4074, 4074, 4094], [4096, 4096, 4137, 4137, 4570], [4572, 4572, 4629, 4629, 6146]], "test": "error"}
{"id": "4lKyDm", "name": "kraft", "author": "k0rzun1n", "description": "kraft paper texture procedural shader", "tags": ["procedural", "texture", "paper", "dirt", "fibers"], "likes": 10, "viewed": 167, "published": "Public", "date": "1536598710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2 mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat sdLine( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvec2 opRep( vec2 p, vec2 c )\n{ \n    return mod(p,c)-0.5*c;\n}\nvec2 opRepFlip( vec2 p, vec2 c )\n{ \n    vec2 fpc = floor(p/c);\n    float flip = mod((fpc.x + fpc.y), 2.);\n    vec2 ret = p - c*(fpc + 0.5);\n    if(flip >= 1.)return ret.yx;\n    return ret;\n}\nvec2 opWarp( vec2 p )\n{ \n// return vec2(sin(p.x+2.*p.y),sin(p.y+p.x));\nreturn vec2(p.x+0.1*sin(20.*p.y),p.y);\n}\n\nfloat nnoise( in vec2 uv ){return 0.5 + 0.5*snoise(uv);} //norm [0,1]\nfloat rnoise( in vec2 uv ){return 1. - abs(snoise(uv));} //ridge\nfloat fbm( vec2 x , int oct ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = .9;\n    for( int i=0; i < 10; i++ )\n    {\n        if(i >= oct) break;\n        float n = nnoise(x);\n        a += b * n;          // accumulate values\t\t\n        b *= s;\n        x *= f;\n    }\n    return a;\n}\nfloat fbmr( vec2 x, int oct ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.9;  // could be 0.5\n    float a = 0.0;\n    float b = .4; //0.5\n    for( int i=0; i < 10; i++ )\n    {\n        if(i >= oct) break;\n        float n = rnoise(x);\n        a += b * n;          // accumulate values\t\t\n        b *= s;\n        x *= f;\n    }\n    return a;\n}\nfloat fbm2( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ,2 ),\n                    fbm( p + vec2(5.2,1.3) ,2) );\n\n    return fbmr( p + 2.9*q ,3); //4.0\n}\nfloat fbm3( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ,2),\n                    fbm( p + vec2(5.2,1.3) ,2) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ,2), //4q\n                    fbm( p + 4.0*q + vec2(8.3,2.8) ,2) );\n    // r = normalize(r);\n    return fbmr( p*2.0 + .4*r , 3); //4.0\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x/iResolution.y;\n    float nVal, n, len;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 vUv = uv;\n    vUv *= iResolution.y/666.;\n    vUv.x *= aspect;\n    vUv.x += iTime/50.;\n    vec2 c,luv,nuv = vUv*7.;\n    //nuv += rnd;\n\n    //background\n    n = fbm3(nuv);\n    nVal = 2.9*(n-0.06);\n    // nVal = 2.5*(n-0.2);\n    nVal *= 1.-0.35*clamp(abs(vUv.y-0.5)-0.1,0.,1.);\n    nVal *= 1.-0.65*smoothstep(0.27,0.45,(clamp(snoise(3.9*nuv)*nnoise(12.2*nuv)*rnoise(9.2*nuv),0.,1.)));\n    n = nVal = clamp(nVal,0.,1.);\n    nVal *= 1.14-1.5*clamp(abs(uv.y-0.5)-0.25,0.,1.);\n    // nVal *= (0.85+.1*rnoise(21.*nuv)*rnoise(17.*nuv));\n    nVal *= (0.9+.1*abs(snoise(14.*nuv)));\n    nVal *= (0.9+.1*abs(snoise(24.*nuv)));\n    nVal *= (0.86+.14*nnoise(41.*nuv));\n    // nVal *= (0.87+0.04*nnoise(0.6*nuv));\n    nVal *= (0.95+0.05*fbm(1.2*nuv,2));\n    \n    //white spots\n    // nVal += (1.-n)*2.7*nnoise(3.*nuv)*clamp(snoise(1.3*nuv),0.,1.); \n    // nVal += (1.-n)*1.72*nnoise(4.*nuv)*nnoise(6.3*nuv); \n    nVal += (1.-n)* smoothstep(0.5,1.,1.72*nnoise(3.*nuv)*nnoise(4.3*nuv)); \n\n    vec2 d1,d2;\n    d1 = vec2(rnoise(1.45*nuv),rnoise(1.45*nuv+vec2(-7.2,6.9)));\n    \n    nuv+=22.;\n    float lm = 0.6;\n    //lines 1\n    luv = nuv;\n    luv += 0.08*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(4.2,-9.1)));\n    c = vec2(1.585);\n    len = 0.04;\n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,-len),vec2(c.x*len,len),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    //lines 2\n    luv = nuv + vec2(-13.2,15.1);\n    luv += 0.09*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(11.2,-9.1)));\n    c = vec2(1.79);\n    len = 0.04; \n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,len),vec2(c.x*len,-len),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    //lines 3\n    luv = nuv + vec2(27.2,-21.5);\n    luv += 0.09*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(-17.2,8.7)));\n    c = vec2(2.07);\n    len = 0.085; \n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,0),vec2(c.x*len,0),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    //lines 3.2\n    luv = nuv + vec2(-17.8,-28.5);\n    luv += 0.09*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(-17.2,8.7)));\n    c = vec2(1.87);\n    len = 0.095; \n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,0),vec2(c.x*len,0),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    vec3 tint = vec3(1.,0.9,0.7);\n    fragColor = vec4(vec3(nVal)*tint,1.);//vec4(vUv, 0.0, 1.0);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKyDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 66], [67, 67, 88, 88, 133], [134, 134, 156, 156, 189], [190, 190, 212, 212, 1811], [1812, 1812, 1861, 1861, 1988], [1989, 1989, 2019, 2019, 2049], [2050, 2050, 2084, 2084, 2240], [2241, 2241, 2264, 2311, 2352], [2354, 2354, 2381, 2381, 2410], [2411, 2424, 2451, 2451, 2480], [2481, 2489, 2521, 2521, 2833], [2834, 2834, 2866, 2866, 3183], [3184, 3184, 3209, 3209, 3348], [3349, 3349, 3374, 3374, 3659], [3661, 3661, 3718, 3718, 6305]], "test": "valid"}
{"id": "4lKyzd", "name": "Linear motion", "author": "ABizard", "description": "Reference : [url]https://9gag.com/gag/a6oYxdN[/url]\n\nEvery dot is moving only on a line, there is no circular motion.", "tags": ["opticalillusion"], "likes": 5, "viewed": 463, "published": "Public API", "date": "1537656585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define POW2(A) ((A)*(A))\n\n#define R iResolution\n\nvec2 dot_pos(float r, float t){\n    return (POW2(sin(t-r*9.42))+.2)*cos(r*6.28-vec2(0,33));\n}\n\nfloat draw_dot(vec2 uv, float r, float t){\n    return smoothstep(10./R.y,.0,length(uv-dot_pos(r,t)) - .022);\n}\n\n// Rainbow color mapping from angle r in [0,1]\nvec3 dot_color(float r){\n    float a=(1.-r)*6.;\n    return clamp(vec3(abs(a-3.)-1., 2.-abs(a-2.), 2.-abs(a-4.)),\n                 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = 1.3*(2.*fragCoord-R.xy)/R.y;\n    vec3 col = vec3(0);\n    \n    float t = iTime*2.;\n    \n    float r = round(fract(atan(uv.y,uv.x)/6.28) * 16.)/16.;\n    vec3 c = dot_color(r);\n    col += c * min(1.,draw_dot(uv,r,t)\n                      // Motion blur\n                      + .5 * draw_dot(uv,r,t-.04)\n                      + .2 * draw_dot(uv,r,t-.08));\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKyzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 144], [146, 146, 188, 188, 256], [258, 305, 329, 329, 444], [446, 446, 500, 500, 902]], "test": "valid"}
{"id": "4lVcWc", "name": "AA Plasmoid", "author": "thugcee", "description": "My first shader.", "tags": ["plasma", "antialiasing", "fwidth"], "likes": 7, "viewed": 101, "published": "Public", "date": "1538074368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 bg = vec3(0.2, 0.1, 0.1);\nvec3 fg = vec3(0.7, 0.7, 0.6);\nvec3 fg2 = vec3(0.5, 0.2, 0.2);\nfloat baseWidth = .05;\n\n// just a scaled sinus curve\nvec2 fun1(in vec2 uv) {\n    return vec2(uv.x, sin(uv.x * 12.0) * .3 + 0.5);\n}\n\n// some crazy animated curve\nvec2 fun2(in vec2 uv) {\n    return vec2(uv.x, sin(uv.x * (cos((uv.x + iTime/3.0) * 4.0) * 12.0) \n                          + iTime) * .1 + 0.5) + fun1(uv)/1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // compute a point on line (currently depends on x position only)\n    vec2 pp = fun2(uv)/2.0;\n    \n\t// compute derivative of distance to the current point on the line (for AA)\n    float d = length(uv - pp);\n    float w = fwidth(d)/2.0;\n    \n    // randomize width of the line\n    float width = baseWidth/3.0 + .2 * fun2(uv).y;\n    \n\t// add gradient to the background\n    float grad = .1 * length(uv - vec2(.5,.5));\n    \n\t// compute color based on distance from pp\n    vec3 c = mix(fg, bg - grad, smoothstep(-w, w, d - width));\n\tc = mix(fg2, c, smoothstep(-w, w, d - width + .02));\n        \n    // Output to screen\n    fragColor = vec4(c ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 147, 170, 170, 224], [226, 255, 278, 278, 416], [418, 418, 475, 525, 1216]], "test": "valid"}
{"id": "4lVcWy", "name": "Endless Marbles 2", "author": "yx", "description": "Forked from [url]https://www.shadertoy.com/view/XlVcWy[/url]", "tags": ["loop"], "likes": 14, "viewed": 545, "published": "Public API", "date": "1537549061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\n// I changed the timing slightly for shadertoy so it loops at exactly 5 seconds - I got the math wrong on stream\n#define iTime (iTime * pi * .4)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat tick()\n{\n    float a = iTime/pi-.5;\n    float b = floor(a);\n    float c = fract(a);\n    c = smoothstep(0.,1.,c);\n    return 2. * (b + c+.5);\n    float t = sin(iTime)*.5+.5;\n    return t*2.-1.;\n}\n\nvec2 halfScene(vec3 p)\n{\n    p.x = mod(p.x+2., 4.)-2.;\n    float env = max(\n        max(p.y,-p.z),\n        -sdTorus(p, vec2(1,.25))\n    );\n\n    env = max(env,sdTorus(p,vec2(1,.35)));\n    \n    p.xz = rotate(p.xz, iTime);\n    p.z -= step(0.,cos(iTime))*2.-1.; // tweaked this line - sign(x) and step(0,x)*2-1 are not the same when x is zero\n\n    float ball = sdSphere(p,.25);\n\n    return vec2(min(env,ball), env<ball?1:0);\n}\n\nvec2 scene(vec3 p)\n{\n    vec3 pA = p;\n    vec3 pB = p;\n\n    pA.x += tick();\n    pB.x -= tick();\n    pB.z *= -1.;\n\n    vec2 a = halfScene(pA);\n    vec2 b = halfScene(pB);\n    return vec2(min(a.x,b.x),a.x<b.x?a.y:b.y);\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    for(int bounce=0;bounce<3;++bounce)\n    {\n        float t;\n        vec2 k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k.x;\n            if (k.x < .001 || k.x > 10.)\n                break;\n        }\n\n        // sky hack\n        if (k.x > 10.)\n            k.y = 2.;\n\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy).x-scene(h-o.xyy).x,\n            scene(h+o.yxy).x-scene(h-o.yxy).x,\n            scene(h+o.yyx).x-scene(h-o.yyx).x\n        ));\n\n        if (k.y == 2.)\n        {\n            // sky\n            // tweaked - I forgot to include the accumulation term on stream\n            return vec3(dir.y*.15+.1) * vec3(30.) * accum;\n        }\n        if (k.y == 1.)\n        {\n            float A = .1;\n            float B = scene(h+n*A).x;\n            float fakeAO = clamp(B/A,0.,1.);\n            fakeAO = pow(fakeAO,.6)*.2+.8;\n\n            float light = n.y*.5+.5;\n\n            vec3 color = vec3(.8);\n\n            h.x += tick() * sign(h.z);\n\n            // floor\n            return light * fakeAO * accum * color;\n        }\n        else\n        {\n            // balls\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel = mix(.0016,1.,fresnel);\n            accum *= fresnel;\n            cam = h + n*.0015;\n            dir = reflect(dir, n);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(uv*3.,-5.);\n    vec3 dir = vec3(0,0,1);\n\n    cam.yz = rotate(cam.yz, atan(1.,sqrt(2.)));\n    dir.yz = rotate(dir.yz, atan(1.,sqrt(2.)));\n\n    cam.xz = rotate(cam.xz, pi/4.);\n    dir.xz = rotate(dir.xz, pi/4.);\n\n    out_color.rgb = pow(trace(cam,dir),vec3(.45));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 170, 200, 200, 323], [325, 325, 358, 358, 427], [429, 429, 462, 462, 488], [490, 490, 504, 504, 690], [692, 692, 716, 716, 1114], [1116, 1116, 1136, 1136, 1334], [1336, 1336, 1368, 1368, 2812], [2814, 2814, 2866, 2866, 3242]], "test": "error"}
{"id": "4lVczK", "name": "Vein Pipeline", "author": "Shadeyboi", "description": "based off of sphere project", "tags": ["beginner"], "likes": 3, "viewed": 78, "published": "Public", "date": "1537287938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), sin(a),\n                sin(a), cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n    pMod3(q, vec3(.75, .75, .2));\n    pMod3(q, vec3(0.75, 1., 0.6));\n    \n    pMod1(p.x, 1.);\n    \t//q.y = abs(q.y)-0.1;\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.5);\n    \n    float disp = min(2. * (abs(sin(p.x*iTime/2.)) *\n                       abs(sin(p.y*iTime/2.)) *\n                       (sin(p.z*15.)) ), 30.);\n    \ts1 += disp;\n    \ts2 -= disp;\n    \ts3 *= disp;\n    \t//s1 -= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2); // Union\n    float df2 = max(s2, s1); // Intersection\n    float df3 = max(s1, s3); // Difference\n    \n    return df2;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*.5;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(.9, -abs(sin(iTime)), 0.3);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    ray.xy *= abs(sin(iTime)) * .25;\n    \n    \n    vec3 origin = vec3(-iTime*.5, 0., -1.75);\n    float t = trace(origin, ray);\n    \n    float expFog = .3 / (t* t* 0.4);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    //fragColor = vec4((fc+color),1.0);\n    fragColor = vec4(tan(fc+color),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 85], [87, 87, 126, 126, 196], [198, 198, 235, 235, 278], [280, 280, 315, 315, 347], [350, 350, 369, 369, 993], [996, 996, 1031, 1031, 1187], [1190, 1190, 1247, 1247, 1792]], "test": "error"}
{"id": "4lVyDz", "name": "Assignment1 - CSC550", "author": "richardMartin", "description": "First assignment\n5 shapes, 2 need to be animated, 1 needs to be controlled by mouse ", "tags": ["shapes", "school"], "likes": 2, "viewed": 76, "published": "Public", "date": "1536192396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//c1 is coordinate 1, c2 is coordinate 2, p is pixel\nfloat rectangle(in vec2 c1, in vec2 c2, in vec2 p)\n{\n\tvec2 v1 = c2 - c1;\n    vec2 v2 = p - c1;\n    \n    return dot(v1, v2);\n}\n\n// a is point a, b is point b, c is point c, p is pixel\nbool triangle(in vec2 a, in vec2 b, in vec2 c, in vec2 p)\n{\n    //math thanks to\n    //http://blackpawn.com/texts/pointinpoly/\n    \n    // define edges of triangle\n\tvec2 vac = c - a;\n    vec2 vab = b - a;\n    vec2 vap = p - a;\n    \n    // define dotproducts we need\n    float dotVac = dot(vac, vac);\n    float dotVacab = dot(vac, vab);\n    float dotVacap = dot(vac, vap);\n    float dotVab = dot(vab, vab);\n    float dotVabap = dot(vab, vap);\n    \n    // compute missing variables u and v\n    float u = ((dotVab * dotVacap) - (dotVacab * dotVabap)) / \n        ((dotVac * dotVab) - (dotVacab * dotVacab));\n    \n    float v = ((dotVac * dotVabap) - (dotVacab * dotVacap)) / \n        ((dotVac * dotVab) - (dotVacab * dotVacab));\n    \n    // if u and v are greater than 0 but combined less than 1\n    // point is inside triangle\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    p*=2.0;\n    \n    // rectangle\n    // the pixel(P) will be in the square iff \n    // 0 < dot(ap, ab) < 1\n    // and\n    // 0 < dot(ap, ac) < 1\n    vec3 col = vec3(0.0);\n    vec2 a = cos(vec2 (0,0));// point a\n    vec2 b = cos(vec2 (0,1.5));// point b\n    vec2 c = cos(vec2 (1,0));// point c\n    \n    float r1 = rectangle(a, b, p);\n    float r2 = rectangle(a, c, p);\n    // checkered pattern from class thanks to Dr Landon\n    // my modifications in comments\n    vec3 checkCol = vec3(0.0);\n    \n    // checkersize scales with resolution\n    float checkerSize = float(0.025*iResolution);\n    \n    if(int(fragCoord.x/checkerSize) % 2 == 0)\n    {\n        if(int(fragCoord.y/checkerSize) % 2 == 0)\n        \tcheckCol = vec3(1.0);\n    }\n    else\n    \tif(int(fragCoord.y/checkerSize) % 2 == 1)\n       \tcheckCol = vec3(1.0);\n        \n    // if the pixel is inside the rectangle\n    // checkers come and go inside the rectangle\n    if( (r1 > 0.0 && r1 < 1.0) && (r2 > 0.0 && r2 < 1.0) ) \n       col = checkCol * cos(5.0*iTime+p.xxx);    \n        \n    // circle\n    float distFromCircle = distance(p,vec2(-2.0+(iMouse.x/iResolution.x), -1.5+(iMouse.y/iResolution.y)));\n    float radius = 0.5;\n    \n    if(distFromCircle < radius)\n        col = vec3(1.0,0,0);\n    \n    // rectangle2\n    a = cos(iTime + vec2 (2,2));// point a\n    b = cos(iTime + vec2 (0,1));// point b\n    c = cos(iTime + vec2 (3,0));// point c\n    \n    float r3 = rectangle(a, b, p);\n    float r4 = rectangle(a, c, p);\n    \n    if( (r3 > 0.0 && r3 < 1.0) && (r4 > 0.0 && r4 < 1.0) ) \n       col = vec3(0,1.0,0);\n    \n    // triangle \n    a = sin(vec2 (1,1)+3.0);// point a\n    b = sin(vec2 (0,1)+3.0);// point b\n    c = sin(vec2 (1,3)+3.0);// point c\n    bool Triangle = triangle(a,b,c,p);\n    \n    if(Triangle)\n        col = vec3(0,0,1.0);\n    // triangle \n    a = cos(vec2 (1,1)+1.0);// point a\n    b = cos(vec2 (0,-4)+3.0);// point b\n    c = cos(vec2 (2,0)+4.0);// point c\n    Triangle = triangle(a,b,c,p);\n    \n    if(Triangle)\n        col = vec3(0,1.0,1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 105, 105, 178], [180, 236, 295, 399, 1120], [1122, 1122, 1179, 1179, 3327]], "test": "valid"}
{"id": "4lVyRR", "name": "[ZMB] Voronoi (Distance types)", "author": "ZiMMaBuE", "description": "Voronoi distances:\nCell, Standard, Chebyshev, Minkowski", "tags": ["voronoi", "noise", "distance"], "likes": 5, "viewed": 1643, "published": "Public", "date": "1536190622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n//------VORONOI---------------------------------------\n//------by-ZiMMaBuE--------(@zimmabue Twitter)--------\n//----------------------------------------------------\n//\tHold left mouse button and\n//\tMove the mouse to see the differences\n//\tTopLeft: \tdistance difined by the MODE parameter\n//\t\t\t\t0: Chebyshev distance\n//\t\t\t\t1: Triangular distance [by iq!]\n//\tTopRight:\tstandard voronoi\n//\tBottom:\t\tcell subdivisions\n//\n//\tComment the RGB to see the distance\n//\n//\tUncomment MINKOWSKI_DISTANCE and move the mouse on\n//\tthe x axis to see how the Minkowski distance works\n//\thttps://en.wikipedia.org/wiki/Minkowski_distance\n\n#define RGB\n#define MODE 0\n//#define MINKOWSKI_DISTANCE\n#define ANIMATE\n\n//----------------------------------------------------\n//----------------------------------------------------\n//----------------------------------------------------\n\nvec2 hash(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi(vec2 pos, float u, float v)\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n    \n    float minDist = 8.0;\n    vec2 val = vec2(0.);\n    for(int j = -2; j <= 2; j++)\n    {\n    \tfor(int i = -2; i <= 2; i++)\n    \t{\n    \t\tvec2 id = vec2(float(i), float(j));\n            vec2 point = hash(id + p);\n            vec2 realPoint = id + point - f;\n            \n            float d = 0.0;\n            #ifndef MINKOWSKI_DISTANCE\n            \trealPoint = mix(id - f, realPoint, v);\n            \td = dot(realPoint, realPoint);\n                #if MODE == 0\n                \td = mix(max(abs(realPoint.x), abs(realPoint.y)), d, u);\n                #endif\n            \n                #if MODE >= 1\n                \td = mix(max(abs(realPoint.x)*0.866025+realPoint.y*0.5,-realPoint.y), d, u);\n                #endif\n            #endif\n            \n            #ifdef MINKOWSKI_DISTANCE\n                float p = pow(2.0, u * 4.);\n                d = pow(abs(realPoint.x), p) + pow(abs(realPoint.y), p);\n                d = pow(d, 1.0 / p);\n            #endif\n            \n            \n            if(d < minDist){\n            \tminDist = d;\n                val = point;\n            }\n    \t}\n    }\n    \n    return vec3(val * (1.-minDist), minDist);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    uv *= 10.;\n    #ifdef ANIMATE\n    \tuv += vec2(iTime * .5, iTime*.3);\n    #endif\n    \n    float inputX = 1.0;\n\tfloat inputY = 1.0;\n    \n    if(iMouse.z > 0.0){\n    \tinputX = iMouse.x / iResolution.x;\n    \tinputY = iMouse.y / iResolution.y;\n    }\n    \n    #ifdef RGB\n    \tvec3 col = vec3(voronoi(uv, inputX, inputY).xy, 0.);\n\t#else\n    \tvec3 col = vec3(voronoi(uv, inputX, inputY).z);\n    #endif\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[748, 914, 933, 933, 1023], [1025, 1025, 1067, 1067, 2271], [2275, 2275, 2332, 2332, 2813]], "test": "valid"}
{"id": "4lVyzK", "name": "Exp.cross", "author": "tqle", "description": "cross", "tags": ["experiments"], "likes": 1, "viewed": 66, "published": "Public", "date": "1536940846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotate\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n\n// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = .5;\n\n    \n    // Transform coordinate space so spheres repeat\n    //vec3 q = fract(p) * 2.0 - 1.0;\n    vec3 q = fract(p)-.65;\n\n    // Signed distance of sphere\n    return sphere(q, radius);\n}\nfloat mapOthers(vec3 z) {\n    float radius = 1.5;\n    vec3 w = fract(z) - .1;\n    return sphere(w, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        \n        t += d;\n        }\n    return t;\n}\nfloat traceOthers (vec3 og, vec3 beam) {\n\tfloat t = 0.0;\n    for(int i = 0; i < 16428; ++i) {\n        vec3 w = og + beam*t;\n        float f = mapOthers(w);\n        t *= f;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    vec3 beam = normalize(vec3(uv*.5, .5));\n    \n    // Rotate Y towards Z\n    ray.yz *= rot(iTime*0.1);\n    //ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(0.0, 0.0, iTime);\n    vec3 og = vec3(iResolution.x, iResolution.y, iTime);\n    float t = trace(origin, ray);\n    float e = trace(og, beam);\n    \n    float linearFog = 2.0 / (1.0 - t*0.2);\n    float expFog = 2.0 / (t*t*0.1);\n    \n    vec3 fc = vec3(expFog);\n\n    // Output pixels to screen\n    fragColor = vec4(fc,1.0);\n    \n    // Try oscilating the final pixels\n    //fragColor = vec4(cos(fc),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 28, 28, 96], [99, 113, 148, 148, 180], [183, 227, 246, 246, 457], [458, 458, 483, 483, 567], [570, 570, 605, 605, 767], [768, 768, 808, 808, 961], [964, 964, 1021, 1071, 1849]], "test": "valid"}
{"id": "4lycD3", "name": "Water Ripple Effect", "author": "Shadeyboi", "description": "Wave Ripples! (Nature project 1/3)", "tags": ["natureproject"], "likes": 2, "viewed": 294, "published": "Public", "date": "1538006156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract((dot(v*0.1, vec2(324.654, 156.546)))*46556.2*2.);\n}\n\nmat2 rot(float a){\n  float r = sin(a)*cos(a); //Makes specific pattern of ripples\n  float f = sin(a)*sin(a); //Smooths out background effects\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n/*float sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy)-r, abs(v.z)-m);\n}\n*/\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*(2.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){\n  Shape shape;\n  float vine;\n  shape.dist = 10.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 10.; // Ripple Repeat\n  float vineOffset = 5.; // Ripple Offset\n\n\n  // Stems\n  vec3 i = c;\n    i.xy *= rot(c.y*0.1+iTime*0.2); //Bends the Water Ripples\n    i.xz *= rot(c.y*.02); //Adds to Bending Effect\n    float detail = pModPolar(i.xz, twist); //Flattens the vines into smooth pattern\n    float x = mix(0., abs(sin(iTime)*.5)*.5, mod(detail*2., 20.)); // Small Ripples\n    i.x -= vineOffset* 4.; // Offset Ripples\n  \tfloat stemWidth = 0.3; //Gradually defines ripples more\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x)); //Smooth out the ripples\n\n\n  vec4 color = vec4(0.5, .7, 1., 1.);\n\n  shape.dist = vine;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c);\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -10.); //Trig functions make the movements more realistic\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lycD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 426], [429, 429, 457, 457, 481], [482, 626, 669, 669, 712], [714, 714, 757, 757, 821], [823, 823, 862, 862, 1018], [1019, 1046, 1066, 1066, 1868], [1871, 1871, 1889, 1889, 1933], [1935, 1935, 1992, 1992, 2455]], "test": "valid"}
{"id": "4lycDc", "name": "hallway", "author": "jes5199", "description": "minkowski distances", "tags": ["moire", "pseudofractal"], "likes": 2, "viewed": 79, "published": "Public", "date": "1537912274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 140. * (fragCoord-iResolution.xy/2.)/(iResolution.y);\n\n    float minkowskiDistanceOrder = pow(2., 4.); \n   \tvec2 p = pow(abs(uv), vec2(minkowskiDistanceOrder));\n\tfloat d = pow(p.x + p.y, 2. / minkowskiDistanceOrder);\n    \n    float color = sin(d - iTime);\n    \n    // Output to screen\n    fragColor = vec4(color, color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lycDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 406]], "test": "valid"}
{"id": "4lycDm", "name": "Practice#1", "author": "lambmeow", "description": "idk what this is", "tags": ["kaleidoscope", "polar", "practice", "killme"], "likes": 2, "viewed": 132, "published": "Public", "date": "1536462930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv *= 2.;\n     uv.x += sin(uv.y  / 100. + time ) ;\n    vec2 pos = vec2(0.5)-uv;\nfloat r = length(pos)*2.0;\nfloat a = atan(pos.y,pos.x);\n    vec3 res= vec3(0.);\n    for(int i = 0; i < 3; i++){\n    float c = r * sin(a - time+ float(i)); \n    float x = (r - c * sin(uv.x * a / c -time ));\n    float y = fract(c - x + float(i) -time/10.) * 10. - 3.7;\n    res += 1./vec3(tan(y + time), atan(c-y + x), x);\n    }   \n\tfragColor = vec4(res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lycDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 126, 607]], "test": "valid"}
{"id": "4lycWw", "name": "Simple Ray March With Shadow", "author": "Bridgy", "description": "Simple ray marching with solid shading (no penumbra). Used the distance functions from iquilezles.org", "tags": ["raymarch", "shading"], "likes": 3, "viewed": 191, "published": "Public", "date": "1536407446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 128;\nconst float MAX_DIST = 10000.0;\nconst float MIN_HIT_DIST = 0.001;\n\nvec3 color = vec3(0.2, 0.5, 0.8);\nvec3 specMat = vec3(1.0, 1.0, 1.0);\nint object = 0;\n\nvec3 rotateX(vec3 pos, float angle)\n{\n    vec4 p = vec4(pos, 0.0);\n    \n    mat4 rotX = mat4(\n        1.0, \t\t0.0,        0.0,0.0,\n        0.0, cos(angle), sin(angle),0.0,\n        0.0,-sin(angle), cos(angle),0.0,\n        0.0,\t\t0.0, \t\t0.0,1.0\n    );\n    \n    p *= rotX;\n    \n    return p.xyz;\n}\n\nvec3 rotateY(vec3 pos, float angle)\n{\n    vec4 p = vec4(pos, 0.0);\n    \n    mat4 rotY = mat4(\n        \tcos(angle), 0.0, -sin(angle), \t0.0,\n        \t0.0, \t\t1.0, 0.0, \t\t\t0.0,\n        \tsin(angle), 0.0, cos(angle), \t0.0,\n        \t0.0,\t\t0.0, 0.0,\t\t\t1.0\n    );\n    \n    p *= rotY;\n    \n    return p.xyz;\n}\n\nvec3 rotateZ(vec3 pos, float angle)\n{\n    vec4 p = vec4(pos, 0.0);\n    \n    mat4 rotZ = mat4(\n        cos(angle), sin(angle), 0.0, \t0.0,\n        -sin(angle),cos(angle), 0.0, \t0.0,\n        0.0,  \t\t0.0, \t\t1.0, \t0.0,\n        0.0,\t\t0.0, \t\t0.0,\t1.0\n    );\n    \n    p *= rotZ;\n    \n    return p.xyz;\n}\n\nfloat distFromSphere(vec3 pos, vec3 center, float radius)\n{\n    pos = rotateY(pos, iTime);\n    \n\treturn length(pos - center) - radius;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h, vec3 c)\n{   \n    p = rotateZ(p, iTime);\n    p= rotateY(p, iTime);\n    \n\tvec3 q = abs(p - c);\n    \n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h, vec3 c)\n{\n    p= rotateY(p, iTime);\n    \n    vec3 q = abs(p - c);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\t\t\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat mapTheWorld(vec3 pos)\n{   \n    float hitObj = sdHexPrism(pos, vec2(1.5, 0.8), vec3(0.0, 0.0, 0.0));\n\tif(hitObj < MIN_HIT_DIST)\n    {\n        object = 0;\n    \treturn hitObj;\n    }\n    \n    hitObj = min(hitObj,distFromSphere(pos, vec3(7.0, 0.0, 0.0), 2.0));\n    if(hitObj < MIN_HIT_DIST)\n    {\n        object = 1;\n    \treturn hitObj;\n    }\n    \n    hitObj = min(hitObj,sdTriPrism(pos, vec2(2.0, 1.0), vec3(-7.0, 0.0, 0.0)));\n    if(hitObj < MIN_HIT_DIST)\n    {\n      \tobject = 2;\n    \treturn hitObj;\n    }\n    \n    hitObj = min(hitObj,udQuad(pos,vec3(-100.0,-3.5,-100.0),vec3(-100.0,-3.5,100.0),vec3(100.0,-3.5,100.0),vec3(100.0,-3.5,-100.0)));\n\tif(hitObj < MIN_HIT_DIST)\n    {\n        object = 3;\n    \treturn hitObj;\n    }\n    \n    return hitObj;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapTheWorld(p + small_step.xyy) - mapTheWorld(p - small_step.xyy);\n    float gradient_y = mapTheWorld(p + small_step.yxy) - mapTheWorld(p - small_step.yxy);\n    float gradient_z = mapTheWorld(p + small_step.yyx) - mapTheWorld(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nbool inShade(vec3 lightPos, vec3 pos)\n{\n\tvec3 toLight = lightPos - pos;\n    float distanceToLight = length(toLight);\n    float distTravelled = 0.01;\n    toLight = normalize(toLight);\n    \n    for(int i = 0; i < RAY_STEPS; i++)\n    {\n        vec3 currentPos = pos + distTravelled * toLight;\n        \n        float distToClosest = mapTheWorld(currentPos);\n        \n        if(distToClosest < MIN_HIT_DIST)\n        {\n            return true;\n        }\n        \n        if(distTravelled > distanceToLight)\n        {\n        \tbreak;\n        }\n        \n        distTravelled += distToClosest;\n    }\n    \n    return false;\n}\n\nvoid setColor()\n{\n\n    if(object == 0){ color = vec3(1.0,0.0,0.0); }\n    else if(object == 1){ color = vec3(1.0,0.0,1.0); }\n    else if(object == 2){ color = vec3(0.0,0.0,1.0); }\n    else if(object == 3)\n    { \n        color = vec3(0.5,1.0,0.0);\n        specMat = vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 rayMarch(vec3 rayOrigin, vec3 direction)\n{    \n    float distTravelled = 0.0;\n    \n    for(int i = 0; i < RAY_STEPS; i++)\n    {\n    \tvec3 currentPos = rayOrigin + distTravelled * direction;\n        \n        float distToClosest = mapTheWorld(currentPos);\n        \n        if(distToClosest < MIN_HIT_DIST)\n        {\n\t\t\tvec3 norm = calculate_normal(currentPos);\n            vec3 lightPos = vec3(10.0, 10.0, -10.0);\n            \n            vec3 lightDirection = normalize(lightPos - currentPos);\n            \n            //calculate shadow\n            if(inShade(lightPos, currentPos))\n            {\n                return color * 0.05;\n            }\n            else\n            {\n                setColor();\n                \n                float diffuseIntensity = max(dot(norm, lightDirection), 0.0); \n                vec3 diffuseColor = color * diffuseIntensity;\n\n                //specular\n                vec3 toEye = normalize(currentPos - rayOrigin); \n                vec3 reflectLight = normalize(reflect(lightDirection, norm));\n                float specPower = 70.0;\n\n                vec3 specColor = specMat * pow(max(dot(toEye, reflectLight), 0.0), specPower);\n\n                return diffuseColor + specColor;\n            }\n        }\n        \n        if(distTravelled > MAX_DIST)\n        {\n        \tbreak;\n        }\n        \n        distTravelled += distToClosest;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CAMERA_POS = vec3(0.0, 6.0, -10.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to -1 to 1 range\n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    rayDirection = rotateX(rayDirection, 3.141 * -0.2);\n   \t\n    vec3 col = rayMarch(CAMERA_POS, rayDirection);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lycWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 218, 218, 473], [475, 475, 512, 512, 774], [776, 776, 813, 813, 1071], [1073, 1073, 1132, 1132, 1209], [1211, 1211, 1254, 1254, 1405], [1407, 1407, 1450, 1450, 1572], [1576, 1576, 1601, 1601, 1620], [1621, 1621, 1677, 1677, 2317], [2319, 2319, 2348, 2348, 3072], [3074, 3074, 3108, 3108, 3524], [3526, 3526, 3565, 3565, 4143], [4145, 4145, 4162, 4162, 4437], [4439, 4439, 4486, 4486, 5855], [5857, 5857, 5914, 5914, 6369]], "test": "valid"}
{"id": "4lyyDy", "name": "Cannabis Curve Plasma", "author": "pettert", "description": "Plasma in the shape of a cannabis leaf ", "tags": ["plasma", "cannabis"], "likes": 6, "viewed": 530, "published": "Public API", "date": "1537441505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cannabis curve plasma shader\n\nvec3 hsv2rgb(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n        pos.x *= iResolution.x/iResolution.y;\n        pos.y += 0.6;\n        \n        float r = length(pos);\n        float th = atan(pos.y, pos.x);\n        \n        \n        float color = 1.0/((r*2.0) - pow(1.5*(1.0+sin(th))*(1.0+0.9*cos(8.0*th))*(1.0+0.1*cos(24.0*th))*(0.5+0.05*cos(140.0*th)), sin(iTime)*0.3+0.8));\n        fragColor = vec4(hsv2rgb(((color+iTime/1.5) - th * 1.114), 1.0, clamp(5.0 - abs(color), 0.0, 1.0)) * (color < 0.01 ? vec3(0.0, 1.0, 0.0) : vec3(1.0))\n                        + (color < 0.01 ? vec3(0.0, smoothstep(-5.0, 0.0, color), 0.0) : vec3(0.0)), 1.0 );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 72, 72, 157], [160, 160, 217, 217, 873]], "test": "valid"}
{"id": "4lyyWG", "name": "Sphere Project - Chameleon", "author": "rlarp", "description": "Sphere Project #1- An arrangement of spheres that change color according to the most previous background color. (like a chameleon). ", "tags": ["sphere", "color", "spheres", "chameleon", "hypnosis", "changing", "mindtwister"], "likes": 1, "viewed": 536, "published": "Public", "date": "1537401389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\nfloat map(vec3 p)\n{\n    float radius = 0.25;\n    vec3 q = fract(p) * 1.5 - 0.5;\n    \n    return sphere(q, radius);\n}\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 128; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d * 0.5;\n        }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *2.-2.; \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(sin(iTime), cos(iTime), 0.7);\n    \n   \tfloat FOV = 3.;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    ray.yz *= rot(iTime*0.1);\n    ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(0.0, 0.0, iTime);\n    float t = trace(origin, ray);\n    \n    \n    float linearFog = 2.0 / (1.0 - t*0.2);\n    float expFog = 3. / (t*t*0.1);\n    \n    vec3 fc = vec3(expFog);\n    \n    fragColor = vec4(fc,0.5);\n    \n    fragColor = vec4((fc+color),3.0);\n    fragColor = vec4(cos(fc+color),sin(iTime));\n    \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 123, 123, 154], [156, 156, 175, 175, 272], [274, 274, 309, 309, 469], [471, 471, 528, 528, 1188]], "test": "valid"}
{"id": "4lyyWw", "name": "3D curves: spiral on sphere", "author": "FabriceNeyret2", "description": "Several variants in comments", "tags": ["3dcurves"], "likes": 9, "viewed": 523, "published": "Public API", "date": "1536402568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(d,r) smoothstep( r*3./R.y, 0., d)   // antialiased draw\n\n// --- line segment with disc ends: seamless distance to segment https://www.shadertoy.com/view/4dcfW8 \nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\n// --- rotation https://www.shadertoy.com/view/XlsyWX\n#define rot(a) mat2(cos( a + vec4(0,33,11,0)))\n    \n// --- 3D->2D\nvec2 proj( vec3 P ) {\n    return 2. * P.xy / (3.+P.z);\n}\n#define dist(P) ( 2.5+P.z )          // for darken & thickness\n\n// --- 3D curve drawing\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    \n    vec3 P, Pm; \n    vec2 _p, p;\n    float d = 1e9, d0,   a=0.,b=0., dl=.03, da=.2;\n    \n    for (float i=0.; i<1e3; i++, _p=p) { // --- draw curve\n\n        // --- 3D equation\n        P = vec3(cos(b)*sin(a), cos(a), sin(b)*sin(a)); // live on sphere\n      //da = 6.28*dl / (.1+sin(a));  // optim: const size segments\n        b += da; \n        a += .25/6.28 *da; if (a>3.14) break;\n      //a = i*dl; P = vec3(cos(a),cos(2.73*a),cos(5.91*a)); // simple curve\n\n        // --- to screen \n        P.xz *= rot(-2.*iTime);                   // rotation\n        P.yz *= rot(-.8);                         // tilt\n        p = proj(P);                              // screen projection\n\n      //if (mod(i,2.)==0.) continue; // display 1 segment / 2\n        if (i==0.) continue;         // skip 1st point (1st seg unfinished)\n        d0 = line( U, _p, p);                     // cur segment\n        d0 /= 5./dist(P);                         // thicken when near\n        if (d0<d) { d=d0; Pm = P; }               // if closest to pix, memo\n      //O +=  vec4( S(d0, 1.) ) *2./ dist(P);     // direct draw\n    }\n    d = S(d, 1.);                                 // 1 pixel-thick line\n    O = vec4( d ) *2./ dist(Pm)\n                  * mix(vec4(1,.8,.8,0),vec4(.8,1,.8,0),.5+.5*Pm.y);\n               // * vec4(normalize(.5+.5*Pm),1);  // color\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 171, 206, 206, 372], [480, 494, 515, 515, 550], [615, 639, 677, 677, 2075]], "test": "error"}
{"id": "4lyyzt", "name": "Test SoundEclipse", "author": "VIPeR2511", "description": "A test of changed variables in SoundEclipse by sclavel", "tags": ["test"], "likes": 6, "viewed": 1029, "published": "Public API", "date": "1537277469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.0, 0.0, 0.0));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.1, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 2.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.9 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.001, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.4 + iTime * 0.9, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.01);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 0.01, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5\n             ) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 489], [491, 491, 520, 520, 613], [615, 615, 651, 651, 862], [864, 864, 899, 899, 963], [965, 965, 1007, 1007, 1474], [1476, 1476, 1527, 1527, 1779], [1782, 1782, 1839, 1839, 2281]], "test": "error"}
{"id": "4tGyDw", "name": "Spiral Ribbons", "author": "amagitakayosi", "description": "The code is written with VEDA and compiled by glslify", "tags": ["raymarching", "glslify"], "likes": 5, "viewed": 133, "published": "Public", "date": "1536413717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n#define GLSLIFY 1\n\nvec2 doModel(vec3 p);\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 300; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = doModel(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest * .5;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec2 squareFrame(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you I??igo :)\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * doModel( pos + v1*eps ).x +\n                    v2 * doModel( pos + v2*eps ).x +\n                    v3 * doModel( pos + v3*eps ).x +\n                    v4 * doModel( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length( p.xz - c.xy ) - c.z;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289_0(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nfloat permute_0(float x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt_0(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise_0(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289_0(i);\n  float j0 = permute_0( permute_0( permute_0( permute_0(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute_0( permute_0( permute_0( permute_0 (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0_0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0_0,p0_0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt_0(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0_0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2(vec4 x) {\n     return mod289_2(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2(i);\n  vec4 p = permute_2( permute_2( permute_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1(vec4(dot(p0_1,p0_1), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_1(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_1(vec3 x) {\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_1(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_1(i); // Avoid truncation effects in permutation\n  vec3 p = permute_1( permute_1( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n#define PI 3.141593\n\nvec2 rot(vec2 st, float t){\n  float c = cos(t), s = sin(t);\n  return mat2(c, -s, s, c) * st;\n}\n\nvec2 doModel(vec3 p) {\n  float blockSize = 3. + sin(iTime);\n\n  // p.xy = rot(p.xy, floor(p.z / blockSize) * 3.14);\n  p.xy = rot(p.xy, p.z * .2);\n  p.xz = rot(p.xy, p.y * .3);\n\n  p.x += sin(iTime * .2) * 20.;\n\n  p = mod(p, blockSize) - (blockSize / 2.);\n  p /= (blockSize / 2.);\n\n  vec2 m = vec2(99999);\n  m = opU(m, vec2(sdBox(p, vec3(1., .1, .1)), 0));\n  m = opU(m, vec2(sdBox(p, vec3(.1, 1., .1)), 2));\n  m = opU(m, vec2(sdBox(p, vec3(.1, .1, 1.)), 1));\n\n  vec3 p1 = p;\n  p1.x -= p1.z;\n  p1.x -= p1.y;\n  // m = opU(m, vec2(sdBox(p1, vec3(.1, 1., .1)), 2));\n  // m = opU(m, vec2(sdBox(p1, vec3(.1, .1, 1.)), 1));\n\n  // holes\n  p = mod(p, .4) - .2;\n  p *= 1. + sin(iTime) * .2;\n  p.xy = rot(p.xy, iTime);\n\n  float h = .15;\n  m.x = opS(sdBox(p, vec3(h, 1., h)), m.x);\n  m.x = opS(sdBox(p, vec3(h, h, 1.)), m.x);\n  m.x = opS(sdBox(p, vec3(1., h, h)), m.x);\n\n  return m;\n}\n\nvec3 doMaterial(vec3 pos, vec3 nor, float materialId) {\n  if (materialId == 0.0) {\n    return vec3(0, .3, 1);\n  }\n  // else if (materialId == 1.0) {\n  //   return vec3(1, .4, .2)* .5;\n  // }\n  else {\n    return vec3(1, .04, .3);\n  }\n}\n\nvec3 doLighting(vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n  vec3 lin = vec3(0.0);\n\n  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n  float dif = max(dot(nor,lig),0.0);\n\n  lin += dif*vec3(2);\n  lin += vec3(0.05);\n\n  return mal*lin;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float cameraAngle  = 0.5 * iTime;\n  vec3 rayOrigin = vec3(3.5 * sin(cameraAngle), 3.0, 3.5 * cos(cameraAngle));\n  vec3 rayTarget = vec3(0, 0, 0);\n  vec2 screenPos = squareFrame(iResolution.xy);\n\n  vec3 rayDirection = getRay(rayOrigin, rayTarget, screenPos, .4);\n\n  vec3 col = vec3(0.015);\n  vec2 t = calcRayIntersection(rayOrigin, rayDirection, 13., 0.003);\n\n  if (t.x > -0.5) {\n    vec3 pos = rayOrigin + t.x * rayDirection;\n    vec3 nor = calcNormal(pos);\n    vec3 mal = doMaterial(pos, nor, t.y);\n\n    col = doLighting(pos, nor, rayDirection, t.x, mal);\n    col *= t.x;\n  }\n  else {\n    col = vec3(1, .5, 0) * .8;\n  }\n\n  // Color grading\n  col = pow(clamp(col,0.0,1.0), vec3(0.4));\n\n\n  fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 148, 148, 545], [547, 547, 602, 602, 666], [668, 668, 703, 703, 834], [836, 836, 883, 883, 1007], [1009, 1009, 1070, 1070, 1261], [1263, 1263, 1323, 1323, 1383], [1385, 1385, 1458, 1458, 1563], [1565, 1654, 1692, 1692, 2068], [2070, 2070, 2097, 2097, 2132], [2134, 2134, 2167, 2167, 2232], [2234, 2234, 2265, 2265, 2361], [2363, 2363, 2399, 2399, 2439], [2441, 2441, 2474, 2474, 2499], [2501, 2501, 2530, 2530, 2567], [2569, 2569, 2602, 2602, 2628], [2630, 2630, 2669, 2669, 2768], [2770, 3162, 3185, 3185, 3234], [3236, 3236, 3261, 3261, 3310], [3312, 3312, 3336, 3336, 3378], [3380, 3380, 3406, 3406, 3448], [3450, 3450, 3480, 3480, 3532], [3534, 3534, 3566, 3566, 3618], [3620, 3620, 3652, 3652, 3914], [3916, 3990, 4016, 4016, 6350], [6352, 6744, 6767, 6767, 6816], [6818, 6818, 6841, 6841, 6890], [6892, 6892, 6916, 6916, 6958], [6960, 6960, 6990, 6990, 7042], [7044, 7044, 7070, 7070, 9239], [9241, 9609, 9632, 9632, 9681], [9683, 9683, 9706, 9706, 9755], [9757, 9757, 9781, 9781, 9820], [9822, 9822, 9848, 9848, 11362], [11385, 11385, 11412, 11412, 11479], [11481, 11481, 11503, 11503, 12350], [12352, 12352, 12407, 12407, 12586], [12588, 12588, 12655, 12655, 12826], [12828, 12828, 12883, 12883, 13606]], "test": "error"}
{"id": "4tKcDD", "name": "perlin noise test3", "author": "teebnike", "description": "perlin noise test", "tags": ["noise"], "likes": 1, "viewed": 366, "published": "Public API", "date": "1536294972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int[512] p  = int[](151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n                    \n   151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n   );\n\n\nfloat fade(float t){\n\treturn t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat grad(int hash,float x,float y){\n\tint h = hash & 1;\n    float u = h == 1 ? x : y;\n    float v = h == 0 ? y : x;\n    \n    return ( ( h & 1) == 0 ? u : -u ) + ( ( h & 1 ) == 0 ? u :-v );\n}\n\nfloat noise(float x, float y){\n\tint X = int(floor(x)) & 255;\n    int Y = int(floor(y)) & 255;\n    \n    x -= floor(x);\n    y -= floor(y);\n    \n    float u = fade(x);\n    float v = fade(y);\n    \n    int A = p[X    ] + Y;\n    int B = p[X + 1] + Y;\n    \n    int AA = p[A];\n    int AB = p[A + 1];\n    int BB = p[B + 1];\n    int BA = p[B];\n    \n   \tfloat b  = grad(p[AA] , x      , y     );\n    float b1 = grad(p[BA] , x - 1. , y     );\n    float b2 = grad(p[AB] , x      , y - 1.);\n    float b3 = grad(p[BB] , x - 1. , y - 1.);\n    \n    float u1 = mix(b,b1,u);\n    float u2 = mix(b2,b3,u);\n    \n    float v1 = mix(u1,u2,v);\n    \n    return v1;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    // Time varying pixel color\n    float scale = 0.09;\n    \n    vec3 lightColor = vec3(0.7,0.3,0.1);\n    \n    vec3 col = vec3(noise(uv.x*scale+iTime,uv.y*scale +iTime ));\n\n    col = 1.0 -lightColor *col;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2007, 2007, 2027, 2027, 2077], [2079, 2079, 2116, 2116, 2270], [2272, 2272, 2302, 2302, 2917], [2919, 2919, 2976, 3026, 3314]], "test": "valid"}
{"id": "4tKczK", "name": "Audio Shader", "author": "rlarp", "description": "Shader with audio", "tags": ["audio"], "likes": 5, "viewed": 146, "published": "Public", "date": "1536942032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere - Signed Distance Function\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n\n\n// Locate objects\nfloat map(vec3 p)\n{    \n    // Sphere radius\n    float sphereSize = 0.5;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n     int tx = int(q.x);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\tfft *= 2.5;\n    // Signed distance of sphere\n    float s = sphere(q, sphereSize);\n    \n    float d = 0.1 * (cos(q.x*5.*fft) * cos(q.y*5.*fft) * cos(q.z*5.*fft) );\n    //return s +wave;\n    return s+d;\n}\n\n\n// Trace rays\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0; // Distance Traveled\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p); // Locate object\n        t += d * 0.5; // Step along the ray\n    }\n    return t; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(3., 0.1, 0.4);\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n\n   \t// Create ray to fire into scene\n   \tvec3 ray = normalize(vec3(uv, -4.0));\n    \n    // Create origin of scene\n    vec3 origin = vec3(1., 1.,iTime);\n   \n    \n    // Trace any objects in the scene\n    float t = trace(origin, ray);\n    \n    // Generate fog based on distance from t\n    float fog = 1. / (1.0 + sin(t) * cos(t) * 1.);\n    \n    // Final color with includes sdf + fog\n    vec3 fc = vec3(fog);\n\n\t\n    //fc /= cos(log(color*fft)*0.5);\n    fc -= tan(color);\n    // Output to screen\n    fragColor = vec4(fc, tan(t));\n}\n\t\n\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 72, 72, 103], [108, 126, 145, 170, 584], [587, 601, 636, 636, 852], [855, 855, 912, 962, 1667]], "test": "error"}
{"id": "4tKyWw", "name": "Funky Spiralzzz", "author": "domorin", "description": "Funky Spiral", "tags": ["spiral"], "likes": 1, "viewed": 56, "published": "Public", "date": "1536562694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589\n\nfloat in_angle_range(float a, float a1, float a2) {\n    a1 = mod(a1, PI * 2.);\n    a2 = mod(a2, PI * 2.);\n       \n    float f1 = a - a1;\n    float f2 = a2 - a1;\n    if(f1 < .0) {\n        f1 += 2. * PI;\n    }\n    if(f2 < 0.) {\n        f2 += 2. * PI;\n    }\n    \n    return 1.-step(f2, f1);    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy * 2.) - 1.;\n    \n    \n    //(sqrt(2)) i.e. max length(uv) can be\n    float R = 1.41421356237;\n    \n    // sin(iTime) makes it zoom in and shit its funky as fuck\n    float r = length(uv) * sin(iTime/2.);\n    float b = 0.5 + abs(r/R) * (PI-0.5);\n    float a = atan(uv.y, uv.x) + PI * iTime * 5.;\n    \n    //r/f = a (equation of a spiral)\n    float desired_angle = mod(r/0.025, 2.*PI);\n    \n    // See if the desired angle is within the current angle (a)\n    float result = in_angle_range(desired_angle, a-b, a+b);   \n    fragColor = (vec4(0,0,1,1) * (1.-abs(r/R)) + (abs((r/R)) * vec4(0,1,0,1))) * result + vec4(.25,0,.5,1) * (1.-result);   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 78, 78, 325], [327, 327, 384, 384, 1071]], "test": "valid"}
{"id": "4tKyWy", "name": "Sphere Project- Time Travel", "author": "tiff", "description": "sphere project- mimicking objects traveling through a tunnel in super speed", "tags": ["sphereproject"], "likes": 1, "viewed": 91, "published": "Public", "date": "1537671704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = 0.7;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p) * 2.5 - 1.;\n\n\n    // Signed distance of sphere\n    return sphere(q, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d/0.7;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y; // Correct aspect ratio\n    \n    vec3 color = -1.0 + -0.5*cos(iTime+uv.xyx+vec3(0,0,1));\n\n   \tvec3 ray = normalize(vec3(uv, 1.5));\n    vec3 origin = vec3(0, sin(iTime/8.0), tan(iTime/3.0)); //iTime creates the movement\n    float t = trace(origin, ray);\n    float linearFog =  1.0 / (0.7 - t*0.25);\n    \n    vec3 fc = vec3(t/linearFog)/abs(tan(color));\n    // Output pixels to screen\n    fragColor = vec4(fc, -cos(color));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 49, 49, 80], [82, 126, 145, 145, 327], [330, 330, 365, 365, 518], [521, 521, 578, 628, 1185]], "test": "valid"}
{"id": "4tKyzc", "name": "phone sphere", "author": "wangyue66", "description": "phone", "tags": ["tutorial"], "likes": 0, "viewed": 361, "published": "Public API", "date": "1537172264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 AMBIENT = vec3(0.2, 0.2, 0.2);\nconst vec3 LIGHT_DIR = vec3(1.0, -1.0, -0.1);\nconst vec3 LIGHT_COL = vec3(1.0, 0.0,0.0);\n\nvec3 DrawSphere(vec2 uv, vec2 p, float r)\n{\n    float dis = length(uv - p);\n    if(dis < r)\n    {\n        float z = sqrt(r*r - uv.x*uv.x - uv.y* uv.y);\n        vec3 n = normalize(vec3(uv,z));\n        vec3 rotDir = vec3(sin(iTime), -0.4, cos(iTime));\n        vec3 dir = normalize(rotDir);\n        float diffuse = max(dot(dir, n),0.0);\n        return diffuse * LIGHT_COL + AMBIENT;\n    }\n    return vec3(0.0,0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n//    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 sphereCol = DrawSphere(uv, vec2(0.0,0.0) , 0.5);\n    \n    vec3 col =  sphereCol;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 176, 176, 550], [552, 552, 609, 792, 1063]], "test": "valid"}
{"id": "4tVcD3", "name": "Signed Distance to Polyspline", "author": "nr4", "description": "Filled true type glyphs. Suggestions for optimization welcome :)\nLinear version: https://www.shadertoy.com/view/MtGyW3\n", "tags": ["2d", "sdf", "bezier", "spline", "polygon"], "likes": 18, "viewed": 502, "published": "Public", "date": "1537980384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Signed Distance to Polyspline\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Got rid of the if(.) by using step functions\n// Update 2: Removed degenerate case (it is invisible).\n\n// (Un)Comment this for different look\n#define DRAW_GEOMETRY\n// More Segments = cooler; choose min. 2\n#define N 32\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Standard shadertoy fill color\nvec3 col(vec2 uv, float o)\n{\n    return 0.5 + 0.5*cos(o+uv.xyx+vec3(0,2,4));\n}\n\n//distance to quadratic bezier spline with parameter t\nfloat dist(vec2 p0,vec2 p1,vec2 p2,vec2 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n//minimum distance to quadratic bezier spline\nfloat spline2(vec2 p0, vec2 p1, vec2 p2, vec2 x)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.) \n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return dist(p0,p1,p2,x,ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    return min(\n        dist(p0,p1,p2,x, t.x),\n        min(\n            dist(p0,p1,p2,x,t.y),\n            dist(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\n// Distance to specific polygon\nfloat polygon(vec2 x)\n{\n    vec2 pts[2*N];\n\tfloat ret = 1., n = 0.;\n    \n    for(float i=0.; i<float(2*N); i+=1.)\n    \tpts[int(i)] = -.5*c.xx+vec2(1.5*rand(i*c.xx)+.25*cos(rand(3.*i*c.xx)*iTime), rand(2.*i*c.xx)+.25*sin(rand(3.*i*c.xx)*iTime));\n    \n    for(int i=0; i<N/2; ++i)\n    {\n        vec2 p0 = pts[2*i], p1 = pts[2*i+1], p2 = pts[int(mod(float(2*i+2),float(N)))];\n        \n        // Compute coefficients for quadratic equation\n        float a = p2.y-2.*p1.y+p0.y, b = 2.*p1.y-2.*p0.y, C = p0.y-x.y;\n        \n        // Discriminant\n        float dis = b*b-4.*a*C;\n        \n        // Solution\n        if(dis == 0.)\n        {\n            float t = -b/2./a, \n                alpha = pow(1.-t,2.)*p0.x+2.*(1.-t)*t*p1.x+t*t*p2.x-x.x;\n            n += step(0., t)*step(t, 1.)*step(0., alpha);\n        }\n        else if(dis > 0.)\n        {\n            vec2 t = (-b*c.xx+c.xz*sqrt(dis))/2./a,\n                alpha = (c.xx-t)*(c.xx-t)*p0.x+2.*(c.xx-t)*t*p1.x+t*t*p2.x-x.x;\n            t = step(c.yy, t)*step(t, c.xx)*step(c.yy, alpha);\n            n += t.x+t.y;\n        }\n        \n        ret = min(ret, spline2(p0, p1, p2, x));\n    }\n    \n    return mix(ret, -ret, mod(n, 2.));\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Add the polygon to a scene\nvec4 scene(vec2 x)\n{\n    vec4 sdf = vec4(polygon(x), col(x, 3.+iTime));\n    sdf = add(sdf, vec4(stroke(sdf.x, .003), col(x, 5.+iTime)));\n    return sdf;\n}\n\n// Draw everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    vec4 s = scene(uv);\n\tvec3 col = \n#ifdef DRAW_GEOMETRY\n        mix(s.gba,\n#endif\n            mix(col(uv, iTime), col(uv, 1.+iTime), .5+.5*sign(s.x))\n            *smoothstep(1.5/iResolution.y, -1.5/iResolution.y, .001*sin(2.*pi*50.*s.x))\n#ifdef DRAW_GEOMETRY\n            , \n            smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, s.x)\n           )\n#endif\n    \t;\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVcD3.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1054, 1071, 1092, 1092, 1162], [1164, 1192, 1233, 1233, 1325], [1327, 1364, 1396, 1396, 1419], [1421, 1454, 1482, 1482, 1532], [1534, 1589, 1641, 1641, 1729], [1731, 1777, 1827, 1880, 2619], [2621, 2653, 2676, 2676, 3836], [3838, 3887, 3917, 3917, 4059], [4061, 4091, 4111, 4111, 4245], [4247, 4266, 4321, 4321, 4764]], "test": "error"}
{"id": "4tVyDK", "name": "Floating Point Grid", "author": "DMGregory", "description": "Visualizing the rounding error in a 2D floating point vector as it moves away from the origin.\nGrid lines = x & y values for a float with a 4-bit mantissa\nBlue dot = desired vector\nBlack dot = closest representable point", "tags": ["math", "diagram", "floatingpoint"], "likes": 17, "viewed": 3153, "published": "Public", "date": "1537806958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int mantissaBits = 4;\n\nfloat toDot(vec2 uv) {\n   return clamp(50000.0 * (dot(uv, uv) - 0.0001), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    vec2 truePoint = (exp(0.7 * fract(iTime/20.0)) - 1.0) * vec2(1.0, 0.7)* 10.0;\n    \n    vec2 shadePoint = uv + truePoint;\n    \n    vec2 exponent = log2(abs(shadePoint));\n    vec2 band = floor(exponent);\n    \n    vec2 delta = 0.5 - abs(exponent - band - 0.5);\n    vec2 speed = vec2(dFdx(exponent.x), dFdy(exponent.y));\n    \n    delta = abs(delta/speed);       \n    \n    \n    fragColor = vec4(clamp(min(delta.x, delta.y) - 0.5, 0.0, 1.0) * vec3(1,1,1),1);\n    \n    vec2 bandDenom = pow(vec2(2,2), vec2(mantissaBits, mantissaBits) - band);\n    \n    vec2 prec = shadePoint*bandDenom;\n    \n    delta = 0.5 - abs(fract(prec) - 0.5);\n    speed = vec2(dFdx(prec.x), dFdy(prec.y));\n    \n    delta = clamp(abs(delta/speed) - 0.25, vec2(0,0), vec2(1,1));\n    \n    fragColor.gb *= delta.x;\n    \n    fragColor.rb *= delta.y;\n    fragColor.g *= mix(delta.y, 1.0, 0.9);\n    \n    fragColor.rg *= toDot(uv);\n    \n    vec2 rounded = round(truePoint * bandDenom)/bandDenom;\n    \n    fragColor.rgb *= toDot(shadePoint - rounded);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 114], [116, 116, 173, 173, 1286]], "test": "valid"}
{"id": "4tVyDR", "name": "lonelytree.txt", "author": "Kali", "description": "A shader from 2013, one of my firsts. It was missing and I've just found it on an old hard drive with that filename.", "tags": ["lonely"], "likes": 32, "viewed": 455, "published": "Public", "date": "1535808711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n---------------------------------------------------------------------------------------\n\n \"Lonely Tree\" by Pablo Roman Andrioli (Kali)\n \n Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Please report any problems (I'm aware this shader could work slow on some systems)\n\n--------------------------------------------------------------------------------------- \n*/\n\n\n// Params to play with:\n\n// Raytracer \n\nconst float viewsize=.5;    // reduced raytracing area for speeding up (>1 for full view)\nconst float zoom=1.1; \nconst float detail=.02;    // distance to stop tracing\nconst float maxdist=28.;    // scene depth\nconst int maxsteps=100;      // max ray steps\n\n// Light \n\nconst vec3 lightdir=vec3(1,-.6,0.); \nconst float diffuse=.75;\nconst float specular=.8;\nconst float specularexp=5.;\nconst float ambient=.2;\n\n// Tree shape\n// you can try to find better trees or even some really weird ones.\n\nconst float inititer=37.;   // Iterations to do at first run\nconst float maxiter=50.;    // Max iterations to reach with mouse\nconst float leavestart=29.; // Iteration to stop texturing and start green coloring\nconst float width=0.55; \nconst float height=0.62;\nconst float branchsegments=3.; // Number of segments for each branch\nconst float scaling=0.90;\t   // Scaling factor at each iteration\nconst vec3 rotvector=vec3(-0.3,-1.,0.2); // IFS rotation vector\nconst float rotangle=85.;      // IFS rotation angle\nconst float anglevary=-0.2;    // Angle variation at each iteration\n\n// Animation \n\nconst float amplitude=.1;   \nconst float speed=0.8;\nconst float dynscaling=0.8; // Scaling factor for the dynamic fractal animation\n\n\n//-------------------------------------------------------------------------------------------\n\nvec3 dir;\nvec2 pix;\nvec2 coord;\n\n\n// Rotation function included in MathUtils.frag of Syntopia's Fragmentarium \nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\n// Terrain heightmap\nfloat terrain(vec3 p){\n\tp.x+=1.5;\n\tfloat h=(sin(p.x)+cos(p.z))*.25;\n\tfloat l=length(p.xz);\n\tp.xz*=2.3;\n\tp.x+=l*.5;\n\th+=(cos(p.x)+sin(p.z))*.1;\n\tp.xz*=1.3;\n\tp.z+=l*.7;\n\th+=(cos(p.x)+sin(p.z))*.08;\n\th+=texture(iChannel0,p.xz*.4).z*.2; //texture displacement\n\treturn p.y-h;\n}\n\nfloat totalit;\n\n// Scene DE\nvec2 DE(vec3 pos){\n\tvec3 p=pos;\n\tint n = 0;\n\tfloat sc=1.;\n\tfloat time=iTime*speed;\n\tfloat amp=sin(time/2.)*amplitude;\n\tfloat angle=radians(rotangle)/branchsegments;\n\tbool rotstart=false;\n\tfloat dtree;\n\tfloat minit=maxiter;\n\tvec3 minp=pos;\n\tfloat mouseit=iMouse.y/iResolution.y*maxiter; //mouse iterations\n\tbool mouse=length(iMouse.xy)>0.; //see if mouse was used\n\ttotalit=0.;\n\tfor (float n=0.; n < maxiter; n++) {\n\t\ttotalit++; //iter count\n\t\tif ((n>mouseit && mouse) ||\n\t\t  (!mouse && n>inititer)) break;\n\t\tfloat d=length((p+vec3(0,sc,0))*vec3(1,.3,1))-width*sc; //branch segment\n\t\tif (n<1.) dtree=d;\n\t\tif (d<=dtree) { //test min distance and save iteration & vector\n\t\t\tdtree=d;\n\t\t\tminit=n;\n\t\t\tminp=p;\n\t\t}\n\t\tif (mod(n,branchsegments) > branchsegments-2.) { \n\t\t\tp.x=abs(p.x); // fold after max segments reached for each branch\n\t\t\trotstart=true; // start rotating at first fold\n\t\t}\n\t\tif (rotstart) { // rotate and animate rotation\n\t\t\tp*=rotationMat(normalize(rotvector),angle+sin(time)*amp);\n\t\t}\n\t\tp.y-=height*sc; // go up\n\t\tsc*=scaling; // scale size\n\t\tamp*=dynscaling; // scale amplitude\n\t\ttime/=dynscaling; // scale time\n\t\tangle+=radians(anglevary); // vary rotation\n\t}\n\tif (minit<leavestart){ //apply texture displacement\n\t\tdtree+=length(texture(iChannel1,vec2(minp.y*2.,atan(minp.x,minp.z)*1.)).xyz)*.04;\n\t} \n\t\n\tfloat dterr=terrain(pos);\n\tfloat de=min(dterr,dtree);\n\tfloat col;\n\tif (de==dterr) col=0.; else col=minit+1.; // return coloring parameter\n\treturn vec2(de,col);\n}\n\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx).x-DE(pos-e.yxx).x,\n\t\t\tDE(pos+e.xyx).x-DE(pos-e.xyx).x,\n\t\t\tDE(pos+e.xxy).x-DE(pos-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\n// coloring\nvec3 color(float obj, vec3 p) {\n\n\tif (obj<1.) { //terrain texture\n\t\tvec3 tex=texture(iChannel0,p.xz*.4).xyz;\n\t\treturn mix(vec3(.55,.7,.3),tex,.75)*(.5+smoothstep(0.,1.0,length(p.xz)*.35));\n\t} \n\telse if (obj>0. && obj<leavestart) { //branches\n\t\treturn vec3(.55,.4,.25);\n\t} else { //leaves (vary brightness by iteration, kind of fake AO)\n\t\treturn vec3(.80,1,.6)*1.1*(1.-.7*(totalit-obj)/(totalit-leavestart));\n\t}\n\t\n}\n\n//lighting\nvec3 light(vec3 p) {\nvec3 ldir=normalize(lightdir);\nvec3 n=normal(p);\nfloat diff=max(max(0.0,dot(-n, ldir))*diffuse,ambient);\nvec3 r = reflect(ldir,n);\nfloat spec=max(0.,dot(dir,-r));\nreturn vec3(diff+pow(spec,specularexp)*specular);\t\n}\n\n//raytracing\nvec3 trace(vec3 from, vec3 dir) {\n\tvec3 p;\n\tfloat totdist=0.;\n\tvec3 col;\n\tvec2 d;\n\tfor (int i=1; i<maxsteps; i++) {\n\t\tp=from+totdist*dir;\n\t\td=DE(p);\n\t\tif (d.x<detail || totdist>maxdist) break;\n\t\ttotdist+=d.x; \n\t}\n\tvec3 back=mix(vec3(.9),vec3(.6,.7,.8),clamp((dir.y+.15)*6.,0.,1.)); //background gradient\n\tif (d.x<detail) {\n\t\tcol=color(d.y,p)*light(p-detail*dir*.5); //apply color+light\n\t\tcol=mix(col,back,smoothstep(0.,1.,totdist*totdist/maxdist*.03)); //a bit of fog\n\t} else { //background sky with moving clouds (and some contrails? :D)\n\t\tcol=back+vec3(1,.9,.6)*texture(iChannel1,\n\t\tvec2(dir.y*4.,atan(dir.z,dir.x)*1.5+iTime*.02)*.15).g*(dir.y*.7+.15);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Camera\n\t//limited view angle to reduce symmetry appreciation\n\t//(introducing assymmetry breaks the distance field, any suggestions?)\n\tpix=fragCoord.xy / iResolution.xy;\n\tfloat viewangle=-135.+(iMouse.x/iResolution.x)*90.; \n\tmat3 rotview=rotationMat(vec3(0.,1.,0.),radians(viewangle));\n\tcoord = pix-vec2(.5);\n\tcoord.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,0.,7.5)*rotview*zoom;\n\tfrom+=vec3(0.,3,0.);\n\tdir=normalize(vec3(coord*2.,-1.))*rotview;\n\tvec3 col=vec3(0.);\n\tfloat view=length(coord*vec2(.8,1.)*4.);\n\tif (view<viewsize*2.) col=trace(from,dir); \t//trace only inside view area\n\tcol=col*.9+vec3(.1); //desaturate a bit\n\tcol = mix(col, vec3(0.73), smoothstep(0.5,1.,view*view/pow(viewsize*2.,2.))); //smooth edges\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1789, 1866, 1905, 1905, 2255], [2258, 2279, 2301, 2301, 2551], [2569, 2581, 2599, 2599, 4057], [4060, 4088, 4111, 4111, 4289], [4291, 4303, 4334, 4334, 4717], [4719, 4730, 4750, 4750, 4966], [4968, 4981, 5014, 5014, 5653], [5655, 5655, 5712, 5848, 6469]], "test": "error"}
{"id": "4tVyRK", "name": "Flames-CO", "author": "cake7914", "description": "FIRE", "tags": ["fire"], "likes": 2, "viewed": 49, "published": "Public", "date": "1536933173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere - Signed Distance Function\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n\n\n// Locate objects\nfloat map(vec3 p)\n{    \n    // Sphere radius\n    float sphereSize = 0.8;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p) * 4.0 - 1.0;\n    \n     int tx = int(q.x);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\tfft *= 2.5;\n    // Signed distance of sphere\n    float s = sphere(q, sphereSize);\n    \n    float d = 0.9 * (sin(q.x*5.*fft) * cos(q.y*5.*fft) * sin(q.z*5.*fft) );\n    //return s +wave;\n    return s+d;\n}\n\n\n// Trace rays\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0; // Distance Traveled\n    for (int i = 0; i < 25; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p); // Locate object\n        t += d * .5; // Step along the ray\n    }\n    return t; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(1.15, 0.7, 0.1);\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n\n   \t// Create ray to fire into scene\n   \tvec3 ray = normalize(vec3(uv, .5));\n    \n    // Create origin of scene\n    vec3 origin = vec3(0., 0.,iTime);\n   \n    \n    // Trace any objects in the scene\n    float t = trace(origin, ray);\n    \n    // Generate fog based on distance from t\n    float fog = 1.0 / (1.0 + t * t * 0.8);\n    \n    // Final color with includes sdf + fog\n    vec3 fc = vec3(fog);\n\n\t\n    //fc /= cos(log(color*fft)*0.5);\n    fc -= cos(color);\n    // Output to screen\n    fragColor = vec4(fc,5.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 72, 72, 103], [108, 126, 145, 170, 584], [587, 601, 636, 636, 851], [854, 854, 911, 961, 1654]], "test": "error"}
{"id": "4tVyWw", "name": "4D Cube", "author": "iq", "description": "Another 4D cube. For the 4D->3D projection, you can switch between orthographic and perspective projections, in line 9.", "tags": ["3d", "4d", "hypercube"], "likes": 26, "viewed": 1117, "published": "Public API", "date": "1536573849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Another 4D cube. For the 4D->3D proection, you can switch between \n// orthographic and perspective projections, in line 9.\n   \n// 0 = orthographics\n// 1 = perspective\n#define PROJECTION 1\n\n    \n#define AA 3   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\nvec3 nCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (pa - h*ba)/r;\n}\n\nvec3 dCapsule( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb, float rad )\n{\n\tvec3 ba = pb - pa;\n\tvec3 oa = ro - pa;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p = pa + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q )-rad, th );\n}\n\n\n\nint objA, objB;\n\nconst float rad = 0.07;\n\nfloat intersect( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float tmp;\n    \n    float res = 1e10;\n\n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )          // skip edge if already visited\n        {\n            tmp = iCapsule( ro, rd, v[a], v[b], rad );\n            if( tmp>0.0 && tmp<res )\n            {\n                res = tmp; \n                objA = a; \n                objB = b;\n            }\n        }\n    }\n\n    return (res<1e9)?res:-1.0;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 v[16] )\n{\n    return nCapsule( pos, v[objA], v[objB], rad );\n}\n\nfloat softShadowCapsule( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    const float k = 16.0;\n    vec3 t = dCapsule( ro, rd, a, b, r );\n    return clamp( k*t.x/max(t.z,0.0001), 0.0, 1.0 );\n}\n\n\n// soft shadows\nfloat calcShadow( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float t = 1.0;\n    \n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )           // skip edge if already visited\n        {\n            t = min( t, softShadowCapsule( ro, rd, v[a], v[b], rad ) );\n        }\n    }    \n\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float seed, in vec3 v[16] )\n{\n    return 1.0;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, in float seed, in vec3 v[16] )\n{ \n    vec3 col = vec3(0.04) + 0.03*rd.y;\n\n    float t = intersect(ro,rd,v);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, v );\n            \n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = vec3(0.4);\n\n        // lighting        \n        float occ = calcAO( pos, nor, seed, v )*(0.7+0.3*nor.y);\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        float sha = (dif>0.001) ? calcShadow( pos+0.02*nor, lig, v ) : 0.0;\n\n\t\tfloat spe = pow( clamp( dot(nor,hal), 0.0, 1.0 ),16.0)*dif*sha*\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.20,0.80,0.65)*vec3(sha,0.5*sha+0.5*sha*sha,sha*sha);\n        lin += 0.70*amb*vec3(0.70,0.80,1.00)*occ;\n        lin += 1.00*fre*vec3(1.20,1.10,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 15.00*spe*vec3(1.00,0.90,0.70);\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 transform( in vec4 p )\n{\n    p.xw *= rot(iTime*0.41);\n    p.yw *= rot(iTime*0.23);\n    p.xy *= rot(iTime*0.73);\n    p.wz *= rot(iTime*0.37);\n    \n    // orthogonal projection\n    #if PROJECTION==0\n    return p.xyz;\n    #else\n    // perspective projection\n\treturn 2.5*p.xyz/(3.0+p.w);\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 v[16];\n\n    // rotate 4D cube\n    v[ 0] = transform( vec4(-1,-1,-1,-1));\n    v[ 1] = transform( vec4(-1,-1,-1, 1));\n    v[ 2] = transform( vec4(-1,-1, 1,-1));\n    v[ 3] = transform( vec4(-1,-1, 1, 1));\n    v[ 4] = transform( vec4(-1, 1,-1,-1));\n    v[ 5] = transform( vec4(-1, 1,-1, 1));\n    v[ 6] = transform( vec4(-1, 1, 1,-1));\n    v[ 7] = transform( vec4(-1, 1, 1, 1));\n    v[ 8] = transform( vec4( 1,-1,-1,-1));\n    v[ 9] = transform( vec4( 1,-1,-1, 1));\n    v[10] = transform( vec4( 1,-1, 1,-1));\n    v[11] = transform( vec4( 1,-1, 1, 1));\n    v[12] = transform( vec4( 1, 1,-1,-1));\n    v[13] = transform( vec4( 1, 1,-1, 1));\n    v[14] = transform( vec4( 1, 1, 1,-1));\n    v[15] = transform( vec4( 1, 1, 1, 1));\n    \n    \n    // camera (static)\n    vec3 ro = vec3( 4.5, 1.5, 0.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime + 17.1*float(m) + 37.4*float(n);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, seed, v );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // cheap dither to remove banding from background\n    tot += 0.5*sin(fragCoord.x)*sin(fragCoord.y)/256.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[363, 433, 511, 511, 1242], [1244, 1244, 1306, 1306, 1419], [1421, 1421, 1491, 1491, 1883], [1929, 1929, 1987, 1987, 2543], [2545, 2545, 2592, 2592, 2645], [2647, 2647, 2732, 2732, 2855], [2858, 2874, 2933, 2933, 3329], [3331, 3331, 3403, 3403, 3421], [3424, 3424, 3493, 3493, 4641], [4643, 4643, 4695, 4695, 4872], [4874, 4874, 4893, 4893, 4966], [4968, 4968, 4997, 4997, 5269], [5272, 5272, 5329, 5329, 7199]], "test": "valid"}
{"id": "4tVyzK", "name": "Heartbeat Pulse", "author": "eclmist", "description": "Pulsing Heart", "tags": ["pulse", "beat", "heart"], "likes": 2, "viewed": 211, "published": "Public", "date": "1536940450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 pos, vec2 uv, float rad) {\n\treturn smoothstep(rad, rad - 0.1, length(pos - uv));\n\n}\n\nfloat ring(vec2 pos, vec2 uv, float rad) {\n    float length = length(pos - uv);\n    return smoothstep(rad - 0.5, rad, length) * smoothstep(rad + 0.25, rad, length);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.9);    \n\t\n\tcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    float size = sin(iTime) + sin(iTime * 2.0) + sin(iTime*5.0);\n    size = abs(size) * 0.02 + 0.2;\n    float c = circle(vec2(0, -1.05), vec2(uv.x, uv.y - sqrt(abs(uv.x) + 1.0)), size);\n   \n    \n    float pulse = ring(vec2(0), uv, (iTime / 2.0 - floor(iTime * 0.5)) * 2.0);\n    \n    col += c * 2.0;\n    col += pulse;\n    col = vec3(col.r, col.g * (uv.x + 0.5), col.b * (uv.y + 0.5));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 101], [103, 103, 145, 145, 269], [271, 271, 328, 378, 971]], "test": "valid"}
{"id": "4tycDm", "name": "Dirigible 1k", "author": "DSoM", "description": "The shader source for my entry for the Assembly 2018 1k intro compo where it reached the 7th place out of 13.\nOnly changes made were those required to get it running in Shadertoy.\nhttp://www.pouet.net/prod.php?which=77487", "tags": ["intro", "1k", "assembly", "dirigible"], "likes": 7, "viewed": 174, "published": "Public", "date": "1536460702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time mod(iTime,50.)/64.\n\nfloat h(vec3 x){\n    vec3 y=vec3(7,26,3);\n    vec4 m=vec4(0,y.yz,y.y+y.z)+dot(floor(x),y);\n    x=(x-=floor(x))*x*(3.-2.*x);\n    m=mix(fract(sin(m)*437.),fract(sin(m+y.x)*437.),x.x);\n    m.xy=mix(m.xz,m.yw,x.y);\n    return mix(m.x,m.y,x.z);\n}\n\nfloat r(vec3 y){\n    float m=0.;\n    float v=1.;\n    float f=2.;\n    m+=(v/=2.)*h((f*=2.)*y);\n    m+=(v/=2.)*h((f*=2.)*y);\n    m+=(v/=2.)*h((f*=2.)*y);\n    m+=(v/=2.)*h((f*=2.)*y);\n    m+=(v/=2.)*h((f*=2.)*y);\n    return m;\n}\n\nfloat d(vec3 y){\n    return min(y.y+7.-r(y/10.)*2.-h(y.xzz*20.)/3.,\n               min(max(max(min(abs(y.y)-.01,abs(y.x)-.01),-(y.z-=time*80.)-.1),length(y)-.4),length(y.xy)+(y.z-=.8)*y.z*.4-.4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 f=vec3(1,2,time*60.+1.);\n    //Originally hardcoded for 1080p\n    vec3 a=vec3(fragCoord/iResolution.y-vec2(1,1.3),1)/length(vec3(fragCoord/iResolution.y-vec2(1,1.3),1));\n    vec3 z=f+a/-a.y;\n    float l=0.;\n    while(l++<64.)f+=a*d(f)/2.;\n    while(l++<100.&&max(time*2.,0.)>(r(z/3.)-abs(z.y+.5))&&f.y<(z+=a/-a.y*(1./32.+h(z*10000.)*.03)).y)\n        fragColor.xyz=max(time*2.,0.)<(r(z/3.)-abs(z.y+.5))?vec3(((r(z/3.)-abs(z.y+.5))-(r(z/3.+.05)-abs(z.y+.5)))/.6+.6):vec3((d(f+.4)-d(f))*2.*(f.y<-1.?vec3(.4,.5,.2):vec3(.5)));\n    fragColor.x+=max(-f.y*3.-27.+time*15.,0.),fragColor+=h(f*10.-f.z*5.-time*200.)/4.*max(-f.y*3.-27.+time*15.,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tycDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 49, 49, 274], [276, 276, 292, 292, 501], [503, 503, 519, 519, 701], [703, 703, 760, 760, 1410]], "test": "valid"}
{"id": "4tycRK", "name": "Okonomiyaki", "author": "FMS_Cat", "description": "shitpost", "tags": ["3d", "raymarcher", "food"], "likes": 9, "viewed": 308, "published": "Public", "date": "1536851251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://twitter.com/FMS_Cat\n\n// ------\n\n#define MARCH_ITER 50\n#define INIT_LEN 0.01\n#define MARCH_MULT 0.8\n\n#define material float\n#define MTL_NONE 0.0\n#define MTL_BASE 1.0\n#define MTL_HAPPA 3.0\n#define MTL_KATSUO 5.0\n#define MTL_MAYO 192.0\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n\n// ------\n\n// \nmat2 rotate2D( float _t ) {\n  return mat2(\n    cos( _t ), sin( _t ),\n    -sin( _t ), cos( _t )\n  );\n}\n\n// smooth minimum : http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float _a, float _b, float _k, out float h ) {\n  h = clamp( 0.5 + 0.5 * ( _b - _a ) / _k, 0.0, 1.0 );\n  return mix( _b, _a, h ) - _k * h * ( 1.0 - h );\n}\n\nfloat smin( float _a, float _b, float _k ) {\n  float h;\n  return smin( _a, _b, _k, h );\n}\n\nfloat random( vec2 _uv ) {\n  return fract( sin( dot( vec2( 12.563, 21.864 ), _uv ) ) * 19934.54 );\n}\n\nfloat iRandom( vec2 _uv ) {\n  float v00 = random( floor( _uv + V.xx ) );\n  float v10 = random( floor( _uv + V.yx ) );\n  float v01 = random( floor( _uv + V.xy ) );\n  float v11 = random( floor( _uv + V.yy ) );\n  return mix(\n    mix( v00, v10, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    mix( v01, v11, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    smoothstep( 0.0, 1.0, fract( _uv.y ) )\n  );\n}\n\nfloat noise( vec2 _uv ) {\n  float sum = 0.0;\n  for ( int i = 0; i < 4; i ++ ) {\n    float p = pow( 2.0, float( i ) + 1.0 );\n    sum += iRandom( _uv * p * 4.0 ) / p;\n  }\n  return sum;\n}\n\nvec3 rainbow( vec3 _i, float _p ) {\n  float p = fract( _p );\n  return mix(\n    mix(\n      mix(\n        _i.xyz,\n        _i.yzx,\n        saturate( p * 3.0 )\n      ),\n      _i.zxy,\n      saturate( p * 3.0 - 1.0 )\n    ),\n    _i.xyz,\n    saturate( p * 3.0 - 2.0 )\n  );\n}\n\n// ------\n\n// \nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 sid;\n  vec3 top;\n  float fov;\n};\n\n// \nstruct Ray {\n  vec3 dir;\n  vec3 ori;\n};\n\n// ------\n\n// \nCamera camInit( in vec3 _pos, in vec3 _tar, in float _fov ) {\n  Camera cam;\n  cam.pos = _pos;\n  cam.dir = normalize( _tar - _pos );\n  cam.sid = normalize( cross( cam.dir, V.xyx ) );\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.fov = _fov;\n\n  return cam;\n}\n\n// \nRay rayInit( in vec3 _ori, in vec3 _dir ) {\n  Ray ray;\n  ray.dir = _dir;\n  ray.ori = _ori;\n  return ray;\n}\n\n// \nRay rayFromCam( in vec2 _p, in Camera _cam ) {\n  vec3 dir = normalize(\n    _p.x * _cam.sid\n    + _p.y * _cam.top\n    + _cam.dir / tan( _cam.fov * PI / 360.0 ) // Is this correct?\n  );\n  return rayInit( _cam.pos, dir );\n}\n\n// ------\n\n// \nfloat distFuncSphere( vec3 _p, float _r ) {\n  return length( _p ) - _r;\n}\n\n// \nfloat distFuncBox( vec3 _p, vec3 _s ) {\n  vec3 d = abs( _p ) - _s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// \nfloat distFuncTorus( vec3 _p, float _r, float _R ) {\n  vec2 q = vec2( length( _p.xz ) - _R, _p.y );\n  return length( q ) - _r;\n}\n\n// \nfloat distFuncPillar( vec3 _p, float _r, float _t ) {\n  return max( abs( _p.y ) - _t, length( _p.xz ) - _r );\n}\n\n// xzRepetition\nvec3 circleRep( vec3 _p, float _r, float _c ) {\n  vec3 p = _p;\n  float intrv = PI * 2.0 / _c;\n  p.zx = rotate2D( floor( atan( p.z, p.x ) / intrv ) * intrv ) * p.zx;\n  p.zx = rotate2D( intrv / 2.0 ) * p.zx;\n  p.x -= _r;\n  return p;\n}\n\n// \nfloat distFunc( vec3 _p, out material mtl ) {\n  vec3 p = _p;\n  float dist = HUGE;\n    \n  vec3 pBase = p + ( vec3(\n        noise( p.yz * 0.5 - 0.2 ),\n        noise( p.xz * 0.5 - 0.4 ),\n        noise( p.xy * 0.5 - 0.7 )\n    ) - 0.5 ) * 0.1;\n  \n  { // base\n    vec3 p = pBase;\n    float distt = distFuncPillar( p, 0.85, 0.05 );\n    distt = smin( distt, distFuncTorus( p, 0.05, 0.9 ), 0.1 );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n    \n  { // mayo\n    vec3 p = pBase - vec3( 0.0, 0.06, 0.0 );\n    p.z += ( noise( p.xz * 0.5 - 0.2 ) - 0.5 ) * 0.3;\n    float d = length( p.zx ) - 0.85;\n    p.z = mod( p.z - 0.1, 0.2 ) - 0.1;\n    d = max( d, length( p.yz ) - 0.01 );\n    float distt = smin( dist, d, 0.02 );\n    mtl = distt < dist ? MTL_MAYO : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n    \n  { // happa\n    vec3 p = pBase - vec3( 0.0, 0.06, 0.0 );\n    float d = length( p.zx ) - 0.85;\n    d = max( d, length( p.y ) - 0.04 );\n    d += noise( p.xz * 5.0 ) * 0.14;\n    float distt = smin( dist, d, 0.02 );\n    mtl = distt < dist ? MTL_HAPPA : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n    \n  { // katsuo\n    vec3 p = pBase - vec3( 0.0, 0.06, 0.0 );\n    float d = length( p.zx ) - 0.5;\n    d = max( d, length( p.y ) - 0.05 );\n    d += noise( p.xz * 3.0 ) * 0.13;\n    float distt = smin( dist, d, 0.02 );\n    mtl = distt < dist ? MTL_KATSUO : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  return dist;\n}\n\nfloat distFunc( vec3 _p ) {\n  material dummy = MTL_NONE;\n  return distFunc( _p, dummy );\n}\n\n// \nvec3 normalFunc( in vec3 _p ) {\n  vec2 d = V * 1E-3;\n  return normalize( vec3(\n    distFunc( _p + d.yxx ) - distFunc( _p - d.yxx ),\n    distFunc( _p + d.xyx ) - distFunc( _p - d.xyx ),\n    distFunc( _p + d.xxy ) - distFunc( _p - d.xxy )\n  ) );\n}\n\n// ------\n\nvec4 draw( vec2 p, float time ) { \n  // \n  Camera cam = camInit(\n    vec3( cos( time ) * 3.0, 2.0, sin( time ) * 3.0 ),\n    vec3( 0.0, -0.2, 0.0 ),\n    50.0\n  );\n  Ray ray = rayFromCam( p, cam );\n\n  // ------\n\n  float rayLen = INIT_LEN; // \n  vec3 rayPos = ray.ori + rayLen * ray.dir; // \n  float rayDist = 0.0; // \n  material mtl = MTL_NONE;\n\n  // raymarch\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    rayDist = distFunc( rayPos, mtl );\n    rayLen += rayDist * MARCH_MULT;\n    rayPos = ray.ori + rayLen * ray.dir;\n    if ( 10.0 < rayLen ) { break; }\n    if ( abs( rayDist ) < 1E-4 ) { break; }\n  }\n\n  vec4 col = V.xxxx; // \n  if ( abs( rayDist ) < 1E-1 ) { // \n    // \n    vec3 normal = normalFunc( rayPos );\n    vec3 camDir = normalize( rayPos - cam.pos );\n    vec3 ligPos = cam.pos + cam.sid + cam.top * 1.0 - cam.dir;\n    vec3 ligDir = normalize( rayPos - ligPos );\n\n    // \n    float dif = 0.5 + 0.5 * dot( -normal, ligDir );\n    float spe = pow( dot( normalize( camDir - normal ), ligDir ), 40.0 );\n    \n    // \n    vec3 mtlCol = vec3( 0.0 );\n    float mtlSpe = 0.0;\n\t  \n    if ( floor( mtl ) == MTL_BASE ) {\n      float sauce = smoothstep( 0.9, 0.8, length( rayPos ) );\n      mtlCol = mix(\n        vec3( 1.0, 0.7, 0.2 ),\n        vec3( 0.4, 0.2, 0.1 ),\n        sauce\n      );\n      mtlSpe = mix( 0.1, 0.9, sauce );\n\t    \n    } else if ( floor( mtl ) == MTL_HAPPA ) {\n      float c = smoothstep( 0.4, 0.6, noise( rayPos.xz * 6.0 ) );\n      mtlCol = mix(\n        vec3( 0.2, 0.6, 0.1 ),\n        vec3( 0.1, 0.3, 0.02 ),\n        c\n      );\n      mtlSpe = 0.1;\n\n    } else if ( floor( mtl ) == MTL_KATSUO ) {\n      float c = smoothstep( 0.4, 0.6, noise( rayPos.xz * 6.0 ) );\n      mtlCol = mix(\n        vec3( 0.6, 0.3, 0.1 ),\n        vec3( 0.8, 0.7, 0.5 ),\n        c\n      );\n      mtlSpe = 0.3;\n\t  \n    } else if ( floor( mtl ) == MTL_MAYO ) {\n      mtlCol = vec3( 0.9, 0.8, 0.7 );\n      mtlSpe = 0.8;\n    }\n\n    // \n    col.xyz += mtlCol * dif;\n    col.xyz += mtlSpe * spe;\n    col.w = 1.0;\n\t  \n    return col;\n\n  } else { // \n    return mix(\n      vec4( 0.9, 0.1, 0.3, 1.0 ),\n      vec4( 0.7, 0.9, 0.2, 1.0 ),\n      p.y + 0.5\n    );\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n  fragColor = draw( p, iTime );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tycRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 409, 436, 436, 510], [512, 581, 638, 638, 745], [747, 747, 791, 791, 836], [838, 838, 864, 864, 938], [940, 940, 967, 967, 1333], [1335, 1335, 1360, 1360, 1519], [1521, 1521, 1556, 1556, 1786], [1979, 2004, 2065, 2065, 2272], [2274, 2296, 2339, 2339, 2402], [2404, 2447, 2493, 2493, 2667], [2680, 2705, 2748, 2748, 2778], [2780, 2802, 2841, 2841, 2946], [2948, 2979, 3031, 3031, 3107], [3109, 3134, 3187, 3187, 3245], [3247, 3272, 3319, 3319, 3504], [3506, 3522, 3567, 3567, 4982], [4984, 4984, 5011, 5011, 5074], [5076, 5116, 5147, 5147, 5361], [5363, 5374, 5407, 5441, 7854], [7856, 7856, 7913, 7913, 8015]], "test": "valid"}
{"id": "4tycWd", "name": "audio envelope canvas", "author": "ollj", "description": "framing contexts get confusing really fast.\ntook me WAY too long to figure this one out and debug it confidently.\nthings correlated to [viewZoom] point you towards scaling modifiers.\n\nred projects a yellow dot into green\nmagenta projects uv into white", "tags": ["zoom", "envelope", "project", "pip", "bijection", "pictureinpucture"], "likes": 4, "viewed": 403, "published": "Public API", "date": "1538072801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n<html><style>body{padding:0;margin:0;position:absolute;width:100%;height:100%;}\n#ID{color:#000;top:0px;left:0px;position:absolute;;width:100%;height:100%}\n#IF{color:#FFF;top:0px;left:0px;position:absolute;pointer-events:none;text-shadow:0 0 9px #000;}\n</style><head></head><script>var w2,wMs=[\"experimental-webgl\",\"webgl\",\"webgl2\"]\n,wM=3//<---wM sets the webGL version,points at wMs[];[ wM=2 ] sets it to [version300es],(w2==true),\"webgl2\",all others are(w2==false)\n</script><script id=\"e\">\nuniform int iFrame;\nuniform float iTime;\nuniform vec3 iResolution;//.z is set to 1,initially for projection mapping (to project on house walls),later mostly for smaller shaders.\nuniform vec4 iMouse;\nuniform vec4 iDate;\nuniform sampler2D backbuffer;\n</script><script id=\"h\">\n    /**/\n//mousedown state fixed\nvec2 v1u;\n//alphacompositing fixed\n//lacks root-solving shapes (parabola-ellipse)\n//canvas \"TinyBri300OHGDAPo14\"\n//lots of code from [inogo quilez] [mercury] [dr2] [David Hoskins]\n//has iFrame fixed\n//has unified smin() smooth-Boolean-fuzzy-logic variants\n//has complex 2d transforms (possibly buggy,checked as much as i care and know this stuff)\n//has some rgba-colorspace-gradients/indicators (but surely not all that i care for,cieluelch is missing)\n//has noise (upper ones are better for (hyperplanes of) less domains\n//- tri,which is food for very fast volumetric storms\n//- h41=[fastest fbm with normals],that is just fast fbm noise with (poorly estimated) 3d normals\n//- hfd=[hash(fract(dot()))],that does not use sin(fract(a)),by David Hopkins\n//- cel=cellular noise,parallelized/fast vorley noise with 2 shortest distances in 2d or 3d,with hash as additional static domain.\n//- s13=[simplex],highest quality/performance noise,generally too slow for 3d spheretracking (as displacement or heightmap)\n//- - lacks bayerMatrix,blueHash<-part of higher-domain content.\n//has DA derivative arithmetic\n//- has issues with Param2:\n//- - decapitated filling lists with zeroes,seems VERY nonsensical\n//- - DA mixing differs from MAT mixin,not just in structure.\n//- - ... previous DA shaders made the error od declaring DA-mixing as MAT-mixind with DA-parameters?\n//- - ... or was that just cases where MAT is identical to DA?\n//has alias-folds fixed,with mercury.sexy/hg_sdf\n//- are declared as defines,for\n//- - N-dimensional inputs,where that function still makes sense in higher dimensions\n//- - uses the same labels as DA,so depending on input it can also calculate derivatives\n//- Includes minified HG_SDF by Mercury mercury.sexy/hg_sdf\n//- omitted platonic solids because the original code uses arrays\n//- Some functions are converted to macros because they would be even smaller when preprocessed.\n//- Another macro,_M,is really filling up almost identical code as to make the result even smaller,\n\n//has AD=automatic Differentiation via chain rule but only demoes it in 1d\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n\n#define vec1 float\n#define norma normalize\n//#define ss smoothstep\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.) could need benchmarking\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1 //https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define cl(a,b,c) mi(ma(a,0.),1.)//till i define this for AD\n#define sat(x) cl(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define u5cos(a) u5(cos(a))\nstruct v11{vec1 a;vec1 b;};\nstruct v22{vec2 a;vec2 b;};\nstruct v33{vec3 a;vec3 b;};//for 2 domains(density/distance field)\nstruct v44{vec4 a;vec4 b;};\nstruct v444{vec4 a;vec4 b;vec4 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v333{vec3 a;vec3 b;vec3 c;};\nstruct v3333{vec3 a;vec3 b;vec3 c;vec3 d;};\nstruct v222{vec2 a;vec2 b;vec2 c;};\n//v222 g222(vec3 a,vec3 b){return v222(vec2(a.x,b.x),vec2(a.y,b.y),vec2(a.z,b.z));}\nv222 g222(v33 a){return v222(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv3333 muv(v3333 a,vec4 b){return v3333(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nvec4 ddv(v3333 a){return vec4(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD,wherelater spaces are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\nstruct DAm2{w13 x;w13 y;w13 z;};//for 3 domains (density/distance field) \nstruct DAm1{w12 x;w12 y;};//for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w11 x;};//for 2 domains (heightmap,isoline,contour)\n\n\n\n\n\nw11 ma(w11 a,vec1 b){return w11(max(a.a,b),max(a.b,b));}\nw11 mi(w11 a,vec1 b){return w11(min(a.a,b),min(a.b,b));}\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define viewZoom 6.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/viewZoom)\n#define fra(u)(u-.5*iResolution.xy)*viewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n//DAm2 maxdm(DAm2 a,v2 p){return DAm2(maxd(a.a,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\n//DAm2 mindm(DAm2 a,v2 p){return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\n//DAm2 maxdm(DAm2 a,vec1 p){return maxdm(a,v2(p));}\n//DAm2 mindm(DAm2 a,vec1 p){return mindm(a,v2(p));}//needed for fast clamping\n//w13 maxdm(w13 a,w13 b,w13 c){return maxd(maxd(a,b),c);}\n//w13 maxdm(DAm2 a){return maxdm(a.a,a.y,a.z);}\n//The 3(or 2)dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN p)]:\n//where N=number of domains,range [0..3]\nv444 da_domain(vec3 p){return v444(vec4(p.x,1,0,0),vec4(p.y,0,1,0),vec4(p.z,0,0,1));}\nv33 da_domain(vec2 p){return v33(vec3(p.x,1,0),vec3(p.y,0,1));}\nvec2 da_domain(vec1 p){return vec2(p,1);}//for 1 domain(linear equation)\n//vNN() declares c11() c22() c33() c44()... for implicit typecasting into structs; v11 v22 v33 v44\nv11 c11(vec1 a,vec1 b){return v11(a,b);}\nv11 c11(vec1 a){return v11(a,a);}\n#define vNNv(z,x) {return z(x(a),x(b));}\n#define vNNu(z,x,y) z x(vec1 a,y b)vNNv(z,y) z x(y a,vec1 b)vNNv(z,y) z x(vec1 a,vec1 b)vNNv(z,y)\n#define vNN(z,y,x) vNNu(z,y,x) z y(x a,x b){return z(a,b);} z y(x a){return z(a,a);}\nvNN(v22,c22,vec2)\nvNN(v33,c33,vec3)\nvNN(v44,c44,vec4)\n\n\n//param1MAT dreaming of vec5 and vec2x2,also,this keeps define-namespace unused,by declating function sets!\n//lets me type \" a=min(vec3(a),float(b)) a=pow(vec3(a),float(b)) \" with less explicit typecasting and shorter aliases:\n//negate,reciprocal,abs,log,sin,asin,cos,acos,tan,atan,fract,floor\n#define NE(y,z) z ne(z a){return -a;}y ne(y a){return y(-a.a,-a.b);}\nNE(v11,vec1)NE(v22,vec2)NE(v33,vec3)NE(v44,vec4)\nw13 ne(w13 a){return w13(-a.a,-a.b);}\nw12 ne(w12 a){return w12(-a.a,-a.b);}\nw11 ne(w11 a){return w11(-a.a,-a.b);}\n#define def1E(z,y,x) x z(x a){return y(a);}\n#define def1(a,b) def1E(a,b,vec1) def1E(a,b,vec2) def1E(a,b,vec3) def1E(a,b,vec4)\n#define re(a) di(1.,b)\ndef1(ab,abs)def1(sg,sign)def1(sq,sqrt)\ndef1(ln,log)def1(ex,exp)\ndef1(si,sin)def1(asi,asin)\ndef1(co,cos)def1(aco,acos)\ndef1(ta,tan)def1(ata,atan)\ndef1(fr,fract)\ndef1(fl,floor)\n//----param2MAT\n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(ne(a)))\n#define def2U(z,y,x) x z(vec1 a,x b){return y(x(a),b);} x z(x a,vec1 b){return y(a,x(b));}\n#define def2E(z,y,x) x z(x a,x b){return y(a,b);}\n#define def2(a,b) def2E(a,b,vec1) def2E(a,b,vec2) def2E(a,b,vec3) def2E(a,b,vec4)\n#define defU(a,b) def2(a,b) def2U(a,b,vec2) def2U(a,b,vec3) def2U(a,b,vec4)\n#define sub(a,b) ((a)-(b))\n#define add(a,b) ((a)+(b))//sub(a,ne(b))\n#define div(a,b) ((a)/(b))\n#define mul(a,b) ((a)*(b)) //di(a,re(b)) reciprocal define may lose time&precision\n//a lot of these just reserve namespaces //dot() is special for folding to a vec1 uses defD()\n#define def2D(z,y,x) vec1 z(vec1 a,x b){return y(x(a),b);} vec1 z(x a,vec1 b){return y(a,x(b));}\n#define def2F(z,y,x) vec1 z(x a,x b){return y(a,b);}\n#define defF(a,b) def2F(a,b,vec1) def2F(a,b,vec2) def2F(a,b,vec3) def2F(a,b,vec4)\n#define defD(a,b) defF(a,b) def2D(a,b,vec2) def2D(a,b,vec3) def2D(a,b,vec4)\n//vNN operands foldlike this:\n#define vXX(z,y) z(y(a.a,b),y(a.b,b))\n#define vXY(z,y) z(y(a.a,b.a),y(a.b,b.a))\n#define vvZ(z,w,v,y) w z(w a,v b){return y(w,z);}w z(w a,vec1 b){return y(w,z);}w z(v11 a,v b){return y(w,z);}\n#define vvY(z,w,v,y) w z(w a,v b){return y(w,z);}w z(v a,w b){return y(w,z);}w z(w a,w b){return y(w,z);}\n#define vvX(y,w,v) vvZ(y,w,v,vXX) vvY(y,w,v11,vXY)\n#define vMM(z) vvX(z,v22,vec2)vvX(z,v33,vec3)vvX(z,v44,vec4)v11 z(v11 a,v11 b){return vXY(v11,z);}v11 z(v11 a,vec1 b){return vXX(v11,z);}\n//alias2_NinputAsVec; due to symmetrically defined alising,in favor of min() max() functions (previously called miv() mav()):\n//note that dt(vec4 a)==dot(dot(a.x,a.y),dot(a.z,a.w)),equivalent to ad(vec4 a)\n//note that po(vec4 a)==pow(pow(a.x,a.y),pow(a.z,a.w)),which is quite silly\n//note that su(vec4 a)==(a.x-a.y)-(a.z-a.w)=a.x+a.w-a.y-a.z=a.x+a.w-(a.y+a.z)\n//note that di(vec4 a)==(a.x/a.y)/(a.z/a.w)=a.x*a.w/a.y/a.z=a.x*a.w-(a.y*a.z)\n//alternatively fo() couls also be defined as dot(a,1.),where parts of a are negated or reciprocal\n#define Fo1(u,t) vec1 u(t a){return u(a.x,a.y);}\n#define Fo2(u,t) vec1 u(t a){return u(u(a.xy),a.z);}\n#define Fo3(u,t) vec1 u(t a){return u(u(a.xy),u(a.zw));}\n#define Fon(u) Fo1(u,vec2) Fo2(u,vec3) Fo3(u,vec4)\n#define defM(a,b) defU(a,b) vMM(a) Fon(a)\ndefM(po,pow)\ndefM(mi,min)defM(ma,max)\ndefM(su,sub)defM(di,div)\ndefM(ad,add)defM(mu,mul)\ndefM(mo,mod)\ndefM(st,step)\n//higher domains for high-domain-permutations/zOrder/Noise\n//v33 su(vec3 a,v33 b){return v33(a-b.a,a-b.b);}\nv33 g33(vec2 a){return v33(vec3(a.x),vec3(a.y));}\nv333 su(vec3 a,v333 b){return v333(a-b.a,a-b.b,a-b.c);}\nv333 g333(v33 a,vec3 b){return v333(a.a,a.b,b);}\nv3333 g3333(vec3 a,v333 b){return v3333(a,b.a,b.b,b.c);}\nv44 fl(v44 a){return v44(fl(a.a),fl(a.b));}\nv44 fr(v44 a){return v44(fr(a.a),fr(a.b));}\n//polar Complex dot()\nconst vec3 vs=vec3(-1,0,1);\n#define le(a) sq(dd(a))\ndefD(dt,dot)\n#define dd(a) dot(a,a)\n//vMM(dt)//breaks a pattern,due to being a foldingprojection\nFon(dt)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n//\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(vec1 a){return cs(vec2(a,a));}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)-(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(vec1 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(vec1 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n\n\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(le(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 sqc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}//vec2 po2c(vec2 a){return muc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nvec2 lgc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 lgc(vec4 a){return vec4(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nvec2 suc(vec2 a,vec2 b){return a-b;}vec2 adc(vec2 a,vec2 b){return a+b;}///complex addition is trivial\nvec2 muc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 muc(vec2 a,vec2 b,vec2 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 muc(vec4 a){return muc(a.xy,a.zw);}//parallel mult\nvec2 dic(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nvec2 lgc(vec2 a,vec2 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 lgc(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nvec2 exc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//vec2 lgc(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 poc(vec2 a,vec2 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 poc(vec2 w,vec2 z,float c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nvec2 lgc(vec2 a,vec2 b,float c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nvec2 wrtc(vec2 a,vec2 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtc(vec2 a,vec2 b,float c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//vec2 sqc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\nvec2 sic(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sic(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sic(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 coc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n\n//obsoleted vec2 coc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 coc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tac(vec2 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nvec2 cotc(vec2 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sihc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 cohc(vec2 z){return coc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 vec2 tahc(vec2 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 vec2 cothc(vec2 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(vec2 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 vec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nvec2 arsic(vec2 z){return c2(lgc(perp(z)+sqc(c2(po2c(z.yx)))+vec2(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsic(vec2 z){vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcoc(vec2 z){return-c2(lgc(z+c2(sqc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcoc(vec2 z){ vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=lgc(vec2(p+q-z.y,-z.x)/r);vec2 b=lgc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nvec2 artac(vec2 z){return sub2(c4(lgc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artac(vec2 z){ vec2 a=lgc(vec2(1.0+z.y,-z.x));vec2 b=lgc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(sub2(c4(vec4(z,sqc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=su(u);return lgc(c2(z)+sqc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r+p-q,-2.0*z.x*z.y));a=lgc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return lgc(z+sqc(po2c(z)+vec2(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return lgc(z+muc(sqc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-su(z*z);z*=2.;return .5*lgc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return lgc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return lgc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=su(z*z);return lgc(c2(z)+muc(sqc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n\n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a\n ;}\n \n//---param3MAT\n//SF3() is a hot mess to be simplified a lot! //only allows for vec1 ot vecmax\n//explicit namespace fold for scalar operations\n#define fi3(m,z,a,b,c) {return z(m(a),m(b),m(c));}\n#define Q3(z,a,b,c){return z(a,b,c);}\n#define SF3(n,y,z,a,b,c) n y(n a,n b,n c)fi3(n,z,a,b,c) n y(n a,n b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,n b,n c)fi3(n,z,a,b,c) n y(vec1 a,n b,vec1 c)fi3(n,z,a,b,c)\n#define scalar3(y,z) vec1 y(vec1 a,vec1 b,vec1 c)Q3(z,a,b,c) SF3(vec2,y,z,a,b,c) SF3(vec3,y,z,a,b,c) SF3(vec4,y,z,a,b,c)\nscalar3(mx,mix)\n//---param1AD Automatic Differenciation (needs param2MAT)\n//todo AD for;tan,asin,acos,atan,reciprocal\n//memo museum: for consistency structure changed: d->v00->v11;d1->v01->w12;d2->v02->w13\n//...the swivels oof d; are .xd ,the swivels of v0N (and [w*]) are .ab\nvec1 rec(float a){return(a==0.)?a:1./a;}//return [1/a] ,work safe//sqrt()and divisions require a worksave reciprocal operator:\n#define sqD(h)h sq(h a){vec1 q=sq(a.a);return h(q,.5*rec(q)*a.b);}\n#define cmD(h,i) h cmd(w11 a,i b){return h(a.a,mu(a.b,b));}\ncmD(w11,vec1)cmD(w12,vec2)cmD(w13,vec3)cmD(w14,vec4)//cmd() is special case of component-wise-multiplication,special because a.x==1: is subroutine of abs()\n//i am not too sure about my implementation on fr();\n//the hell,just use mo()instead,mo()has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)-=.0)\nvec1 jud(vec1 a){return mx(a,-1.,st(fr(a),0.)*st(0.,fract(a)));}\nvec2 jud(vec2 a){return vec2(jud(a.x),jud(a.y));}\nvec3 jud(vec3 a){return vec3(jud(a.x),jud(a.y),jud(a.z));}\nvec4 jud(vec4 a){return vec4(jud(a.x),jud(a.y),jud(a.z),jud(a.w));}\n//i should definitely define this by fract,and not by floor.\n//because fm-modulation taught me that i need fract()a lot more than floor()\n#define frD(h)h fr(h a){return h(fl(a.a),jud(a.b));}\n#define abD(h)h ab(h a){return cmd(w11(ab(a.a),sg(a.a)),a.b);}//w13(abs(a.x),sign(a.x)*a.d);}\n#define siD(h)h si(h a){return h(si(a.a),mu(co(a.a),a.b));}\n#define coD(h)h co(h a){return h(co(a.a),mu(ne(si(a.a)),a.b));}\n#define lgD(h)h ln(h a){return h(ln(a.a),di(a.b,a.a));}\n#define exD(h)h ex(h a){vec1 x=exp(a.a);return h(x,x*a.b);}\n#define DA1(h)h(w11)h(w12)h(w13)h(w14)\nDA1(abD)DA1(siD)DA1(coD)DA1(lgD)DA1(exD)DA1(sqD)DA1(frD)//because different functions have unique derivatives,\n//fl(a)=a-fr(a); hasvery slightly lower precision?rarely relevant.fract()has great precision on float!\n#define fl(a) su(a,fr(a))\n//---Param2AD are trickier: https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mo()mx()mi()ma()\n//AD_mo() ideally should be replaced by fr(),but that adds 1dvd()and 1mu(),BUT DA_mo(a,b) outperforms mu(fr(di(a,b)),b),via [reciprocal product rule]\n#define moD(h,i)h mo(h a,i b){return h(mo(a.a,b  ),fr(a.b));}\n#define moE(h,i)h mo(h a,i b){return h(mo(a.a,b.a),fr(a.b));}\n#define moF(h,i)h(w11,i)h(w12,i)h(w13,i)h(w14,i)\nmoF(moD,vec1)moF(moE,w11)\n#define miG(r,h,j) r mo(h a,r b){return r(mod(a.a,b.a),j(0));}\nmiG(w14,w13,vec4)miG(w14,w12,vec4)miG(w14,w11,vec4)miG(w13,w11,vec3)miG(w13,w12,vec3)\nw13 mo(vec1 a,w13 b){return w13(mod(a,b.a),vec3(0));}\nw12 mo(vec1 a,w12 b){return w12(mod(a,b.a),vec2(0));}\nw11 mo(vec1 a,w11 b){return w11(mod(a,b.a),0.);}\n//substraction is simple,because \"differentiation is integration\"; https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for; https://en.wikipedia.org/wiki/Translation_(geometry)\n//BUT if we substract a struct da from a vec1 or w11,we must negate the .b part.\n//i possibly messed this one up by not flipping the .a part,but i an not sure there.\n#define suNN(h,i,j)h su(i a,j b){return h(su(a.a,b.a),a.b);}h su(j a,i b){return h(su(a.a,b.a),-b.b);}\nsuNN(w12,w12,w11)suNN(w13,w13,w11)suNN(w13,w13,w12)//the leftmost param equals the larger param of the other 2 params\nsuNN(w14,w14,w11)suNN(w14,w14,w12)suNN(w14,w14,w13)//..the rightmost param is always smaller than the middle param\n#define suNM(t)t su(t a,vec1 b){return t(su(a.a,b),a.b);}t su(vec1 a,t b){return t(su(a,b.a),-b.b);}\n#define suMM(t)suNM(t)t su(t a,t b){return t(su(a.a,b.a),su(a.b,b.b));}\nsuMM(w11)suMM(w12)suMM(w13)suMM(w14)\n//in the end mix() has an identity,and that identity does translate into DA:\n#define mixd(a,b,c) ad(mu(c,su(a,b),a)\n//a big issue of this is that mixd() and mind() where defined as MAT-functions,vut using the AD-labeling\n//so is just deleted that junk code\n//I define mind()and=maxd(-,-)instead of maxd()and=mind(-,-)\n//because min()is far more common than max(),for z-buffering.\n//negation identity:max(a,b)--min(-a,-b),requires struct negation\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n//AD_mu simplifies contextually ,scalar multiplication is tautological product_rule.\n#define adM2(h) h mu(h a,vec1 b){return h(mu(a.a,b),mu(a.b,b));}\n#define adM1(h) adM2(h)h mu(vec1 a,h b){return mu(b,a);}\n#define atta(h,i,j) h mu(i a,j b){return h(mu(a.a,b.a),ad(mu(a.b,b.a),mu(a.a,b.b)));}\n#define attA(h) atta(h,h,w11)atta(h,h,h)atta(h,w11,h)\nadM1(w11)adM1(w12)adM1(w13)adM1(w14)\natta(w11,w11,w11)attA(w12)attA(w13)attA(w14)//oh i really like this attA()-way of folding it\nDAm2 mu(DAm2 p,vec3 s){return DAm2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nDAm1 mu(DAm1 p,vec2 s){return DAm1(mu(p.x,s.x),mu(p.y,s.y));}\nDAm0 mu(DAm0 p,vec1 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define rXX(h) h di(h a,vec1 b){return h(di(a.a,b),di(a.b,b));}h di(vec1 a,h b){return h(di(a,b.a),di((mu(ne(a),b.b)),mu(b.a,b.a)));}\nrXX(w11)rXX(w12)rXX(w13)rXX(w14)\n//inverse scalar multiplication is a tautolotgy.\n//some of these may be nonsensical\n#define rXY(h,i,j) i di(h a,i b){return i(di(a.a,b.a),di((mu(ne(a.a),b.b)),(b.a*b.a)));}i di(i a,j b){return i(di(a.a,b.a),di((su(mu(a.b,b.a),mu(a.a,b.b))),(mu(b.a,b.a))));}\nrXY(w13,w12,w11)\nrXY(w11,w13,w13)\nrXY(w12,w13,w11)\nrXY(w11,w14,w14)//just guessing this line\nrXY(w12,w14,w11)//just guessing this line\n//All exponential functions utilize their Base_E_identity:...which is still not efficient,but comes down to O(exp(n*log(n)))\n//pow (x,y)-=exp(log(x)*y)//baseE exponential and logarythmic functions.\n#define po(x,y)ex(mu(ln(x),x))\n/*\n//It gets trickier with functions that take 3 parameters:,applying the\n//https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem)with first derivatives.\n#define v0q vec1 q=length(vec2(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nw11 le(w11 x,w11 y){v0q;return w11(ll2\nw12 le(w12 x,w12 y){v0q;return w12(ll2\nw13 le(w13 x,w13 y){v0q;return w13(ll2\nw13 lengthw13(DAm2 u){return le(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters.below is 3d length.\nw13 le(w13 x,w13 y,w13 z){float q=length(vec3(x.a,y.a,z.a));return w13(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nw13 le(DAm2 u){return le(u.x,u.y,u.z);}//3*3domain\n//the utility of a length()function is clear.*/\n//su(ab(p),s)equals a translation away from the origin by [s] AND mirroring at origin,via abs()\n//...so it it clamps a an implicit surface to a limited \"thickness\" (in 3 domains),also translating its first derivatives.\nw12 suab(w12 p,vec1 s){return su(ab(p),s);}\nw11 suab(w11 p,vec1 s){return su(ab(p),s);}\nw13 suab(w13 p,vec1 s){return su(ab(p),s);}\nDAm2 suab(DAm2 p,vec3 s){return DAm2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nDAm1 suab(DAm1 p,vec2 s){return DAm1(suab(p.x,s.x),suab(p.y,s.y));}\nDAm0 suab(DAm0 p,vec1 s){return DAm0(suab(p.x,s));}\n\n\n//spheretracker /ePr is referenced by bicapsule() and other unsigned distances\n//ideally only a 4d marcher is defined,with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\nconst float iterRm=256.;\nconst float eRm=.0001;\nconst float zFar=200000.;\nconst vec2 EN=vec2(.005,0);\nvec2 df(vec3 p);\nfloat dFb(vec3 p);\n#define dNdom(u,a,b) (a(u+EN.b).x-a(u-EN.b).x)\n#define dNormal3X(u,a) normalize(vec3(dNdom(u,a,xyy),dNdom(u,a,yxy),dNdom(u,a,yyx)))\n \nvec4 trace(vec3 ray_start,vec3 ray_dir\n){//vec3 ray_start=a.a;vec3 ray_dir=a.b\n ;float ray_len=0.\n ;vec3 p=ray_start\n ;for(float i=0.; i<iterRm;++i\n){float dist=df(p).x\n  ;if (dist < eRm) break\n  ;if (ray_len > zFar) return vec4(0)\n  ;p +=dist*ray_dir\n  ;ray_len +=dist;}return vec4(p,1);}\n//vec4 trace(vec3 a,vec3 b){return trace(v33(b,a));}//legacy compatible\n/*\nvec4 trace(v33 a\n){float t=0.\n ;for(float i=0.;i<iterRm;++i\n ){float d=df(a.a).x\n  ;if(d<eRm)return vec4(a.a,i);\n  ;if(t>zFar)return vec4(0)\n  ;a.a+=d*a.b*.5//this marther has its first step overstep way too often,doubling lipschitz evades this(poorly)\n  ;t+=d;}return vec4(a.a,iterRm);}\nvec4 trace(vec3 a,vec3 b){return trace(v33(a,b));}//legacy compatible\n*/\n\n//spheretracker\n//ideally only a 4d marcher is defined, with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\n//const float iterRm=160.;\n//const float eRm=.001;\n//const float zFar=20000.;\n\n\n\n//\"crossproduct\" and \"determinant\" are related,cross() is the bilin()* of a lin()_determinant()\n//therefore i can fold the detemrinant() mnamespace onto the cross() namespace.\n//a cross() has 2 inpouts,where a determinant() has 1 input\n//we generalize \"crossproduct\" into its ternary: \"find the only vector that in a 90deg angle to all inputs\"\nvec2 cr(vec2 a){return a.yx*vec2(-1,1);}//rotBy4\nvec3 cr(vec3 a,vec3 b){return cross(a,b);}\n//vec4 cr(vec4 a,vec4 b,vec4 c){\n//solve LinearEquation for   dot(a,d)=0;dot(b,d)=0;dot(c,d)=0;with additional constrains to length(d)==1\n//}\n//[a bilinear (2 input vectors) product with a vector result only exists in 3d and 7d,in 7f it has more than 2 results (handedness,signs)\n//7d_dotproduct() is the octonion_pairing to 3d_quaternion.\nfloat det2d(vec2 a,vec2 b){return dot(a,cr(b));}//a.x*b.y-a.y*b.x//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct perpdot dotperp\n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos,p.zy),perm2(u5cos,p.zx),perm2(u5cos,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//noronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 su(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 mu(float a,v33 b){return v33(a*b.a,a*b.b);}\nmat3 su(mat3 a,mat3 b){return a-b;}\nmat3 addf(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n\n//fast cellular noise,optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares,1 is maximum jitter. (known bug,iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend,is ideally 1/7,but others can be fine too.use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime.\n//the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1,.y is L2 according to [worley noise]\n//this uses a lot of mat2,or the v33 struct,and permute()functions similar to ahsima-simplex noise,defers the sorting,for performance.\n//Cellular noise (\"Worley noise\")in 3D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license.\n//See LICENSE file for details.\n//https://github.com/stegu/webgl-noise\n#define mous (iResolution.xyxy-iMouse.xyzw)//flip mouse everywhere,for shadertoy fun\nmat3 fr(mat3 a){return mat3(fr(a[0]),fr(a[1]),fr(a[2]));}\n//mat3 fl(mat3 a){return mat3(fl(a[0]),fl(a[1]),fl(a[2]));}\nmat3 addd(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n//th7 is for the 2d noise,should be (iResolution.y/7.),BUT i managed to make other values look fine,too\n#define th7 (mous.y/iResolution.y)//usually==1./7.,because mod(a,7)is famous for old LCGs.\n//th8 is for the 3d noise,should be (iResolution.y/7.),other values may work,but they tend to barely work at all,try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))//seems to be fine bounds,not too sure.\nvec3 mod2893d(vec3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}//Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n//Permutation polynomial:(34x^2+x)mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n#define Kcel 1./th8//1/7\n#define Kcel2 1./th8/th8//1/(7*7)\n#define Kcelo (1.-Kcel)*.5//1/2-Kcel/2\n#define Kcelz 1./(th8-1.)//1/6\n#define Kcelzo .5-2./(th8-1.)//0.416666666667//1/2-1/6*2\n#define jitter mous.x/iResolution.x//smaller jitter gives more regular pattern\nmat3 perM3(vec3 p){return mat3(permute3d(p-1.),permute3d(p),permute3d(p+1.));}\nmat3 perM3(vec3 p,vec3 b){vec3 p1=permute3d(p+b.x-1.);vec3 p2=permute3d(p+b.y);vec3 p3=permute3d(p+b.z+1.);return mat3(p1,p2,p3);}\n#define maa(a,b,c) ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a)a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c)mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n//todo,make it traversable bny getting distance2Border.\nvec2 cellular(vec3 P,float m//not to be confuced with a voronoi3d,but can look similar.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=addf(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perM3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perM3(pp[0]+p.z)\n ;mat3 p2=perM3(pp[1]+p.z)\n ;mat3 p3=perM3(pp[2]+p.z)\n ;mat3 ox=fr(p1*Kcel)-Kcelo\n ;mat3 ox2=fr(p2*Kcel)-Kcelo\n ;mat3 ox3=fr(p3*Kcel)-Kcelo \n ;mat3 oz=fl(p1*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz2=fl(p2*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz3=fl(p3*Kcel2)*Kcelz-Kcelzo \n ;mat3 oy=mod73d(fl(p1*Kcel))*Kcel-Kcelo\n ;mat3 oyy=mod73d(fl(p2*Kcel))*Kcel-Kcelo\n ;mat3 oy3=mod73d(fl(p3*Kcel))*Kcel-Kcelo\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=addf(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=addf(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n ;mat3 a\n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared==is dot(r,r)\n //Sort out the two smallest distances (F1,F2)\n #if 0\n ;vec3 d1=min(min(d11,d12),d13) //sort out only F1\n ;vec3 d2=min(min(d21,d22),d23)\n ;vec3 d3=min(min(d31,d32),d33)\n ;vec3 d=min(min(d1,d2),d3)//shortest of 9 distances,except its 9*vec3()\n ;d.x=min(min(d.x,d.y),d.z)\n ;return vec2(sqrt(d.x));}//F1 F1\n #else\n ;vec3 d1a=min(d11,d12)//sort out F1 and F2\n ;d12=max(d11,d12)\n ;d11=min(d1a,d13)//Smallest now not in d12 or d13\n ;d13=max(d1a,d13)\n ;d12=min(d12,d13)//2nd smallest now not in d13\n ;vec3 d2a=min(d21,d22)\n ;d22=max(d21,d22)\n ;d21=min(d2a,d23)//Smallest now not in d22 or d23\n ;d23=max(d2a,d23)\n ;d22=min(d22,d23)//2nd smallest now not in d23\n ;vec3 d3a=min(d31,d32)\n ;d32=max(d31,d32)\n ;d31=min(d3a,d33)//Smallest now not in d32 or d33\n ;d33=max(d3a,d33)\n ;d32=min(d32,d33)//2nd smallest now not in d33\n ;vec3 da=min(d11,d21)\n ;d21=max(d11,d21)\n ;d11=min(da,d31)//Smallest now in d11\n ;d31=max(da,d31)//2nd smallest now not in d31\n ;d11.xy=(d11.x<d11.y)?d11.xy:d11.yx\n ;d11.xz=(d11.x<d11.z)?d11.xz:d11.zx//d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy)//nor in d12.yz\n ;d11.y=min(d11.y,d12.z)//Only two more to go\n ;d11.y=min(d11.y,d11.z)//Done! (Phew!)\n ;return sqrt(d11.xy);}//F1,F2\n#endif\n//crunched by ollj\n//Cellular noise (\"Worley noise\")in 2D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license of://https://github.com/stegu/webgl-noise\n//mod(a,289.)without a division (only multiplications),because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}//Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}//Permutation polynomial:(34x^2+x)mod 289\n#define tt3(p,f,j,m,a)square(su(j,su(v33(vec3(a),f),mu(m,mu(m,modth7(ff(p*th7)))))))\n#define permi(c)p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c)r[d]=tt3(p,f,k.a,m,e);permi(c)\n//Cellular noise,returning F1 and F2 in a vec2//3x3-hood reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity)m=1./7.,by sqiveling this parameter,you get+0.7 domain very cheaply\n//as in by making m a 3rd parameter,you ALMMOST get cheap cellular3d noise,BUT it is likely a bit flawed,more repetitive,shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop.the permute()function marks+1 iteration/tap//is 4tap voronoi in O(3)\n){v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1),f=o+.5,px=permute(o+k.b.x),permi(x)\n ;mat3 r\n ;ppm(0,-.5,y)//it seems that the loop got unrolled and al lits min()fucntions fold into the below\n ;ppm(1,+.5,z)//...//which is quite a lot of symmetry folding,surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line ,because r[0].y is a return value.\n ;r[0].y=min(mi(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n//simplex noise3d (simplex noise is worth it for higher dimensions)\n//Original:https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute(vec4 x){return mod(x*x*34.+x,289.);}\nfloat simplex1(vec3 v//ashima simplex3d,early optimizations by @makio64,structure by @ollj  https://www.shadertoy.com/view/Xd3GRf\n){const vec2 C=1./vec2(6,3);const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy)),x0=v-i+dot(i,C.xxx),g=step(x0.yzx,x0.xyz),l=1.-g//is a sequence of 4,no parallelization\n ;v33 f=v33(min(g.xyz,l.zxy),max(g.xyz,l.zxy));v3333 d=g3333(x0,su(x0,g333(su(f,g33(C)),D.yyy)))\n ;i=mod(i,289.);v222 F=g222(f);vec3 ns=.142857142857*D.wyz-D.xzx\n ;vec4 p=permute(permute(permute(i.z+vec4(0,F.c,1))+i.y+vec4(0,F.b,1))+i.x+vec4(0,F.a,1)),j=p-49.*floor(p*ns.z*ns.z),k=floor(j*ns.z)\n ;v44 t=ad(mu(v44(k,floor(j-7.*k)),ns.x),ns.y)\n ;vec4 h=1.-abs(t.a)-abs(t.b),a=-step(h,vec4(0))\n ;v44 b=v44(vec4(t.a.xy,t.b.xy),vec4(t.a.zw,t.b.zw))\n ;b=ad(v44(b.a.xzyw,b.b.xzyw),mu(v44(a.xxyy,a.zzww),ad(mu(fl(v44(b.a.xzyw,b.b.xzyw)),2.),1.)))\n ;v3333 q=v3333(vec3(b.a.xy,h.x),vec3(b.a.zw,h.y),vec3(b.b.xy,h.z),vec3(b.b.zw,h.w))\n ;q=muv(q,inversesqrt(ddv(q)));vec4 m=max(.6-ddv(d),0.)\n ;return .5+12.*dot(m*m*m,vec4(dot(q.a,d.a),dot(q.b,d.b),dot(q.c,d.c),dot(q.d,d.d)));}\n\n//fbm of dr2 noise (with multitap normals),is a bit crude,in favor for fast normals.\n#define fBm(a) vec2 b=vec2(0,1);for(int i=0;i<a;i++){b=vec2(b.x,0)+vec2(noise1(p),.5)*b.y;p*=2.;}return b.x/(2.-b.y);}\nvec1 fbm(vec1 p){fBm(5)vec1 fbm(vec2 p){fBm(5)vec1 fbm(vec3 p){fBm(5)vec1 fbms(vec3 p){fBm(3)\nvec1 fbmn(vec3 p,vec3 n){vec4 r=vec4(0,0,0,1);for(int i=0;i<4;i++\n){r=vec4(r.xyz,0)+r.w*vec4(vec3(noise1(p.yz),noise1(p.zx),noise1(p.xy)),.5);p*=2.;}return dot(r.xyz,abs(n));}\nvec3 VaryNf(vec3 p,vec3 n,vec1 f\n){vec2 e=vec2(.1,0);vec3 g=vec3(fbmn(p+e.xyy,n),fbmn(p+e.yxy,n),fbmn(p+e.yyx,n))-fbmn(p,n)\n ;return norma(n+f*(g-n*dot(n,g)));}\nfloat fbma(vec3 p//fbm of ashima simplex (no normals,duh)\n){float f\n ;f=.5*(simplex1(p));p=p*2.01\n ;f+=.25*(simplex1(p));p=p*2.02\n ;f+=.125*(simplex1(p));p=p*2.03\n ;f+=.0625*(simplex1(p));p=p*2.04\n ;f+=.03125*(simplex1(p));return f;}\n\n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\nfrflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)frflpm(v44,c44)\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\nfloat Blob(vec3 p){p=ab(p);p=mx(p,p.yzx,st(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))//boxf(point-boxcenter,boxsize)\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a))//i am not convinced by this one\n#define box(a,b) roundit(abm(a,b))\nfloat fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}\n\n#define tiny .000001\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sq(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}//beware, this is .y distance in 1d! it can make nice \"curtains\" but you likely want il()\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat il(vec2 u,vec2 m){return abs(dot(m,vec2(-u.y,u.x)));}//infinite line trough 2 points\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return il(u,m);                 abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define ilN(u,m)   il(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n//earvageg is still far from standardized. rac is the central radius, should be parametric.\nfloat EarVagEgg(vec2 u,vec3 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (lineInfbbb(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(lineInfbbb(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\nfloat EarVagEgg(vec2 u,vec2 m){return EarVagEgg(u,vec3(m,mix(.5,3.,sin(iTime)*.5+.5)));}\n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(EarVagEgg(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(EarVagEgg(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\n//CylEarVagEgg() is capped cylinder to extrude it to 3d.\nfloat CylEarVagEgg(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(EarVagEgg(u.xy,m))-.05)-.02);}\n//todo lathe this one for a 3d ear-shape\n\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n\nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}\n\n\n\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\nstruct v21{vec2 a;vec1 b;};//currently only for alpha compositing plans\nstruct v31{vec3 a;vec1 b;};//...for MAT arithmetic\nstruct v41{vec4 a;vec1 b;};\nv21 su(v21 a,v21 b){return v21(a.a-b.a,a.b-b.b);}\nv21 mu(v21 a,v21 b){return v21(a.a*b.a,a.b*b.b);}\nv21 mu(v21 a,vec1 b){return v21(a.a*b,a.b*b);}\nv31 su(v31 a,v31 b){return v31(a.a-b.a,a.b-b.b);}\nv31 mu(v31 a,v31 b){return v31(a.a*b.a,a.b*b.b);}\nv31 mu(v31 a,vec1 b){return v31(a.a*b,a.b*b);}\nv41 su(v41 a,v41 b){return v41(a.a-b.a,a.b-b.b);}\nv41 mu(v41 a,v41 b){return v41(a.a*b.a,a.b*b.b);}\nv41 mu(v41 a,vec1 b){return v41(a.a*b,a.b*b);}\n//generalizing alpha-compositing functions,named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent,.W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes],this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions,that return a or b,for simplicity\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a){return rainbowt(-a,1./3.);}\nvec3 rainbows(float a,float b){return u5cos(2.*pi*ab012(a,b));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbows(float a){return rainbows(-a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 rainbows(vec3 c){ToRgb(rainbows)//cos-mix\nvec3 rainbowt(vec3 c){ToRgb(rainbowt)//linear-mix not identical to the below,but close\n\n#define hsv2rgb(c) c.z*mx(1.,sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\nvec4 demoRainbow(vec2 u,vec2 m,vec2 n\n){vec4 r=vec4(0)\n ;//r.xyz=ab012(u.y*6.,u.x*6.)//this subroutine doesnt make for a useful standalone\n ;//r.xyz=rainbow(u.x,m.x)\n ;//r.xyz=ToRgb(vec3(u.x,1,1))//nope this takes complex input\n ;      if(u.y> .75)r.xyz=rainbowt(u.x,m.x)//is linear, which makes it most blurry\n ;else if(u.y> .25)r.xyz=rainbowt(vec3(-u.x,1,1))   //uses rainbow2() , but .x must be negated\n ;else if(u.y>-.25)r.xyz=rainbows(u.x,m.x)\n ;else if(u.y>-.75)r.xyz=angleToColor(vec3(-u.x,1,1))//uses rainbow(), but .x must be negated\n ;else             r.xyz=hsv2rgb(vec3(u.x,1,1))//is sharpest (6 clear colors) has inverse, but no shifting!\n ;//r.xyz=hsv2rgb(rgb2hsv(vec3(u.x,u.y,abs(m.x))))//inversion test passed\n ;vec3 a=abs(hsv2rgb(vec3(u.x,1,1))-u.y*2.-2.)\n ;vec4 s=vec4(r.xyz,1.)\n ;a=smoothstep(.01,-.01,a-.1)\n ;r=pdOver(vec4(1,0,0,1)*a.x,vec4(0,1,0,1)*a.y)\n ;s=pdOver(vec4(0,0,1,1)*a.z,s)\n ;r=pdOver(r,s)\n ;return r;}\n\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n\n\n\n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\nw11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nfloat recsum(vec2 a){return 1./(su(1./a));}\n\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(iTime*vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\nvec4 demoSmin(vec2 u,vec2 m,vec2 n//smin (exponential and polinomial) , with automativDifferenciation\n){w11 a=w11(u.x-m.x*9.,1.)\n ;w11 b=w11(u.x-m.x*9.,1.)\n ;m.x=abs(m.x)+.2//optional evasion of very short wavelength\n ;vec4 c=vec4(0)\n ;float amp=1.//m.y\n ;a=   mu(co(di(a,di(m.x,mu(pi,.5)))),amp)//a.b is analytic first derivative of a.a\n ;b=ad(mu(si(di(b,di(m.x,mu(pi,.5)))),amp),mu(si(b),.3))//b.b is analytic first derivative of b.a\n ;a=su(co(mu(a,2.)),mu(a,.2))\n ;b=su(si(mu(b,2.)),mu(b,.561))\n ;w11 d=mae(a,b,1./m.y)\n ;w11 e=mae(a,b,1./m.y)\n ;w11 f=mas(a,b,3.*m.y)\n ;c.y=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.x=abs(b.a-u.y)/sqrt(1.+b.b*b.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.z=abs(d.a-u.y)/sqrt(1.+d.b*d.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.w=abs(f.a-u.y)/sqrt(1.+f.b*f.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;//c=abs(c-.2)-.1//optional shows how this is NOT distance2Sin()\n ;c=abs(c-aaa*2.)-aaa*.5//optional double line\n ;c=smoothstep(aaa,-aaa,c)\n ;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n ;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec4 y=vec4(angleToColor(vec3(rainb.y,1,1)),c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(angleToColor(vec3(rainb.z,1,1)),c.z)//coordinate system in magenta/pink\n ;vec4 w=vec4(angleToColor(vec3(rainb.w,1,1)),c.w)//coordinate system in magenta/pink\n ;x.xyz*=x.w;y.xyz*=y.w;z.xyz*=z.w;w.xyz*=w.w//alpha premultiplied\n ;x=pdOver(y,x)\n ;x=pdOver(z,x)\n ;x=pdOver(w,x)\n ;return x;}\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n\n \n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n//https://www.shadertoy.com/view/ldSBR3\n//return distance to sideways.horse-silhouette,optimized for speed.\nfloat silHorse(vec2 u//main plan is to use something common with low symmetry, to demo folding patterns.\n){//u-=m.xy;//move by m.xy\n ;float t=length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))+.5//tail\n ;float r=length(vec2(-1.5-u.x,mStretchP(u.y,4.)))+.5\n ;float l=length(vec2(1.5-u.x,mStretchP(u.y,7.5)))+.5//front\n ;u.y-=3.5\n ;vec2 n=vec2(2.25-u.x,u.y-2.5)\n ;float h=length(n)-.5//head\n ;n+=vec2(1.3,.7)\n ;h=min(h,length(n)+.3)\n ;u.x=mStretch(u.x,1.1)\n ;float b=length(u)-.2\n ;//h=length()\n ;//vec2 v=abs(u-vec2(.5))\n ;//return b\n ;return min(min(min(h,b),min(l,r)),t)\n ;return ellipseCheap(u)-1.5\n ;return length(u);}\nfloat CylSilHorse(vec3 u,float h){return ma(abs(u.z)-h,(silHorse(u.xy*3.)-1.)/3.);}\n\n\nfloat legs4(vec3 u,vec3 d //distance to the 4 legs of a table d.y=tableHeight. d.xz=distancesBetweenLegs.\n){u.y=mStretchP(u.y,d.y)\n ;u.xz=abs(u.xz)-d.xz\n ;return le(u)\n ;}\nfloat horseBody(vec3 u\n){u.x=mStretch(u.x,.45)\n ;return length(u-vec3(0,1.1,0))\n ;}\n\n//accidental vulalike, due to 2x -.5 offset\n// ;r=length(vec2(u.z,length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))-.5))-.5  //tail\n\nfloat horseTail(vec3 u\n){return (length(vec2(u.z,length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))))+.2)*.5;}\n\nfloat horseAnus(vec3 u){return torus((u.yxz+vec3(-1.3,.82,0)),.06);}\nfloat horseVag(vec3 u\n){u.z=mStretch(u.z,.2)\n ;u.xy-=vec2(1,0)\n ;float scale=3.2\n ;return length(vec2(u.z,EarVagEgg(u.xy*scale,vec3(.01,.25,1.2))/scale)-.01)\n ;}//CylEarVagEgg(((u.zyx-vec3(1,.8,.25)))*2.,.5*iMouse.xy/iResolution.xy,.2)\nfloat horseButt(vec3 u){\n ;u.z=abs(u.z)-.2\n ;return length(u-vec3(-.57,1.1,0))-.2\n ;}\n\nfloat SilHorse(vec3 u\n){float r=legs4(u,vec3(.5,1,.26))-.18\n ;r=mis(r,horseBody(u)-.4,.3)//torso\n ;r=mis(r,le(u-vec3(.5,1.4,0))-.05,.2)//neck\n ;r=mis(r,le(u-vec3(.8,1.9,0))-.5,.2)//head\n ;r=mis(r,horseButt(u),.3)\n ;float s=mis(horseVag(u.zyx-vec3(-1,.9,-.65))-.03,horseAnus(u)-.03,.05)\n ;r=mis(r,s,.05)\n ;r=mis(r,(horseTail(u*2.3+vec3(-.1,.9,0))+u.x*.3+.1),.6)//tail has some tricky lipschitz tweaks\n ;return r;\n ;}\n\nvec2 FactorioFurnace(vec3 u){\n ;float d=length(u)\n ;return vec2(d,1)\n ;}\n \n\n\nvec2 debugHg2(vec3 u){\n ;vec2 r=vec2(zFar,0.)\n ;float t=cos(iTime)*.4+.5\n ;r=minx(r,FactorioFurnace(u))\n ;//r=minx(r,CoordCross(u))//coordinate crosses\n ;u.x=1.-u.x//flip towards light source\n ;//r=minx(r,vec2(CylEarVagEgg(((u.zyx-vec3(1,.8,.25)))*2.,.5*iMouse.xy/iResolution.xy,.2),13))\n ;float h=CylSilHorse(u-vec3(1,0,3),.4)\n ;r=minx(r,vec2(h,13))\n ;r=minx(r,vec2(SilHorse(u-vec3(1,0,0)),14))\n ;//r=box(u,vec3(1))-t\n ;//r=length(u-bicapsule3(u,vec3(-.5,0,2),vec3(.5,0,2),.7,.2))-.1\n ;//bicapsule(u,vec3(1,0,0),vec3(0,0,1),.5,2.)\n ;//r=Blob(u)\n ;//r=fPlane(abs(u),vec3(1,1,1),-1.5)//the raymarcher is not ideal for this one,with its alpha fadeout.\n ;//r=boxf(u,vec3(1))-.5\n ;//r=corner(u.xy)\n ;//r=cylinder(u,1.,1.)\n ;//failed to make a rounded cylinder via roundit()\n ;//r=ls(u,vec3(0),vec3(1,2,3))-t\n ;//r=lsY(u,vec2(1,2))//could not get it to work instantly\n ;//r=torus(u,1.)-1.\n ;//r=disc(u,vec2(1.))-2.//could not get it to work instantly\n ;//r=hexCircum(u,1.)-1.\n ;//r=fCone(u,1.,2.)\n ;return r;}\n//2-distance input unions\n//note,for higher dimensions,i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances,b is a radius //todo,compare with mima()\n#define miRound(a,b) mi(ma0(a),-b)+le(ma0(b+a))//is likely wrong\n#define maRound(a,b) -fOpRoundMin(-a,b)//is likely wrong\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}//is likely wrong\n/*\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat micolumns _M(1.)\n ;p.x+=sqrt(.5)*-r+c*sqrt(2.)\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b)\n ;}\n\nfloat macolumns _M(-1.)\n p.y+=c;p.x=sqrt(.5)*(r+c)/p.x\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=-mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b);}//fails on its own\n#define mecolumns(a,b,r,n) -macolumns(a,-b,r,n)/**/\n\n\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return mi(mi(a,b),.5*(u+a+abs(mo(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\nvec2 debugHg(vec3 u){\n ;return debugHg2(u)\n ;float r=0.\n ;u.z-=1.\n ;float t=cos(iTime)*.4+.5\n ;float a=box(u   ,vec3(1))-t\n ;//u.xy*=r2(1.)\n ;float b=box(u-1.,vec3(1))-.2\n ;//return mi(a,b)\n ;//return ma(a,b)\n ;//return ma(a,-b)\n ;//return miChamfer(a,b,0.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return miChamfer(a,b,3.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return maChamfer(a,b,.5)//not sure if broken or tracer issue\n ;//return meChamfer(a,b,.5)\n ;//return chamfer180(a,b,.5)//round chamfer is best\n ;//return -chamfer180(-a,-b,.5)//max() round chamfer is weird but fun\n ;//return -chamfer180(-a,b,.23)//max(a,-b) round chamfer easily gets discotinuous\n ;//return chamfer180(a,b,3.5)//overchamfering round is bumpy\n ;//return miRound(a,b)//todo fixme\n ;//return mistairs(a,b,.5,13.)\n ;//return mistairs(a,b,.5,13.)\n ;//return mestairs(a,b,.5,13.)\n ;a=micolumns(a,b,.5,4.)\n ;//return mecolumns(a,b,.5,4.)\n ;//return mucolumns(a,b,.5,4.) \n ;//return macolumns(a,b,.5,4.)//macolumns fails\n ;//return mecolumns(a,b,.5,4.)\n ;//return pipe(a,b,.2)\n ;//return engrave(a,b,.5)\n ;//return -groove(-a,b,.5,.1)\n ;//return tongue(a,b,.5,.1)\n ;return vec2(a,1);}\n\n\n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his mit licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n\n//The MIT License\n//Copyright  2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 v0,vec3 v1,vec3 v2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=v0-v1\n ;vec3 b=v2-v0\n ;vec3 p=v0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright  2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\n\n\n//someone overthought checkerboard patterns\n//float xnor(float x,float y){return abs(x+y-1.);}// abs(0+0-1)-1 abs(1+0-1)-0 abs(0+1-1)-0 abs(1+1-1)-1\n//xnor(xnor(e.x,e.y),e.z)//checkerboard3d\n\n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(mi(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n#define fsaa (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n\n//float gm3(mat3 a,int n){return a[n/3][n%3];}//use a matrix as if it is a list.\n\n\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump is very common\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n#define sm(a,b)smoothstep(a-10./iResolution.y,a,b)\nfloat PatternCircles(vec2 p,float m//https://www.shadertoy.com/view/MsSyRz\n){p.x-=m*.5*step(0.,sin(pi*p.y/m))\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n\n\n\n//where .a is a distance .b is intended to be a colorCode. if(any(.b<0)) it encodes a 4d textureID;else ist is a texturte.rgba\nstruct v14{vec1 a;vec4 b;};\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n \n//these likely have simpler expressions,its too late timeofday for me to bother now.\nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\nfloat fTruncatedOctahedronB(vec3 u,float r){return max(box(u,r),fOctahedron(u,r));}\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\nfloat fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//todo,  define a mix for struct v14\n\nv14 demoSpheroid(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 d=v14(zFar,vec4(0))\n ;vec4 c=vec4(-5,0,0,0)\n ;d=minxb(d,v14(box                   (u,vec3(1.)      ),c))\n ;d=minxb(d,v14(fOctahedron           (u-vec3(3,0,3),1.),c))\n ;d=minxb(d,v14(fTruncatedOctahedron  (u-vec3(3,0,0),1.),c))\n ;d=minxb(d,v14(fTruncatedOctahedronB (u-vec3(0,0,3),1.),c))\n ;u+=vec3(6,0,0)\n ;c=vec4(-6,0,0,0)\n ;d=minxb(d,v14(fDodecahedron         (u            ,1.),c))\n ;d=minxb(d,v14(fIcosahedron          (u-vec3(3,0,3),1.),c))\n ;d=minxb(d,v14(fTruncatedIcosahedron (u-vec3(3,0,0),1.),c))//==c60 soccer ball\n ;d=minxb(d,v14(fTruncatedIcosahedronB(u-vec3(0,0,3),1.),c))\n ;return v14(d.a*scale,d.b);}\nv14 demoSpheroidB(vec3 u\n){float scale=.5\n ;float tt=mix(3.,105.,u5(cos(iTime)))//i found this range to be continuous, and outOfRange not.\n ;u/=scale\n ;v14 d=v14(zFar,vec4(0))\n ;vec4 c=vec4(-7,0,0,0)\n ;d=minxb(d,v14(box                   (u,vec3(1.)         ),c))\n ;d=minxb(d,v14(fOctahedron           (u-vec3(3,0,3),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedOctahedron  (u-vec3(3,0,0),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedOctahedronB (u-vec3(0,0,3),1.,tt),c))\n ;u+=vec3(6,0,0)\n ;c=vec4(-8,0,0,0)\n ;d=minxb(d,v14(fDodecahedron         (u            ,1.,tt),c))\n ;d=minxb(d,v14(fIcosahedron          (u-vec3(3,0,3),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedIcosahedron (u-vec3(3,0,0),1.,tt),c))//==c60 soccer ball\n ;d=minxb(d,v14(fTruncatedIcosahedronB(u-vec3(0,0,3),1.,tt),c))\n ;return v14(d.a*scale,d.b);}\n\n\n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv33 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*iTime)//autopilot\n ;m=mx(n,m,step(0.,iMouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v33(pos,dir);}\n\n\n\n//Phong+debugPlanes\n//\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n#define tracePlane(po,pd,o,d) dot(po-(o),pd)/dot(d,pd)\n//traceR if(t<0) return -1; return t;\n#define traceR(t) mix(-1.,t,step(t,0.))\n#define raytrace_plane(po,pd,o,d) traceR(tracePlane2(po,pd,o,d))\nvec1 planeDebug2(vec3 o,vec3 d,vec3 c,inout float t,vec2 n//ray,ray,curPlane,time,domainLengths\n){if(n.x<length(c)&&n.y>0.//debug plane //n.x=o.y n.y=d.y\n ){float p=tracePlane(c,c*t,o,d)//;if(abs(p)<9.){\n  ;p=df(o+d*p).x\n  ;float q=fract(p*8.)/(p*p*p*p+4.)\n  ;p=mix(q,mix(1.,.5,q),step(p,0.))\n  ;return p*.5;}//}\n ;return 0.;}\n//x can be y,beware that z may be hidden from some cameras,need to rotate camera asound.\n//d is linked to e; e=x f=0 ; e=y f=1 ; e=z f=2 (; e=w f=3)\n#define planeDebug(a,b,c,d,e) planeDebug2(a,b,c,d,vec2(a.e,b.e))\n\nvec4 DebugPlanes(vec3 o,vec3 d,float t\n){float c0=u5(sin(iTime*.1))*2.\n ;vec4 a=planeDebug(o,d,(c0*vec3(1,0,0)),t,x)*vec4(0,1,.5,1)\n ;vec4 b=planeDebug(o,d,(c0*vec3(0,1,0)),t,y)*vec4(.5,0,1,1)\n ;vec4 c=planeDebug(o,d,(c0*vec3(0,0,1)),t,z)*vec4(1,.5,0,1)\n ;return sat((a+b+c)*2.);}\nvec3 tex(vec3 u//textureid is 2 integers, .x one sets hue, .y sets saturation.\n){float i=df(u).y;\n ;vec3 r=hsv2rgb(vec3(fract(i*phi),1,1))\n //;if (i<0.)\n ;//r=mix(r,dNormal3X(u.xyz,df)*.5+.5,.7)\n ;//r=mix(r,vec3(checkerSignSt(u-1.,.5+.5*cos(-iTime)*vec3(1,1,1))*.5+.75),.5)\n ;//r=po(r,1.4)//gamma\n ;return r\n //return cellular(u*5.,iTime).xyx\n //;return fract(u*4.+cos(iTime))\n ;}\n\n\n\n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(iTime*.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1]);y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(ma(dt(p,y))-o.x*3.,sq(mi(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n\nvec2 demohh(vec3 u\n){float scale=1.\n ;u*=scale\n ;//;float dodec=fDodecahedron(p-vec3(-9,2,-4)/4.,.7)//i like how this is placed n the mirroring plane\n ;float b=fBox(u-vec3(0,-.1,0),vec3(1))\n ;float s=length(u-vec3(1.+sin(iTime*.25)*.2,.8,1))-1.//sphere\n ;s=min(b,s)\n //;return s;\n ;float d=mistairs(b,s,.7,4.)\n ;u.xz*=r1(iTime*.041);u.zy*=r1(iTime*.021)//lazy small rotation\n ;//vec2 n=cellular(u*5.61,1./7.)\n ;//d-=(n.y-n.x)*.05//too much foreach march iteration.\n ;return vec2(d/scale,1);}\n\n\nvec2 df(vec3 u//.x=distance .y=textureId\n){float scale=1.\n ;u*=scale\n#if 0\n //;u.xz=-u.xz;\n //;vec2 q=pModMirror2(u.xz,vec2(4.5))//offset repetition doesnt go well with the camera transform\n#endif\n ;v14 d=v14(zFar,vec4(0));\n ;d=minxb(d,demoSpheroid (u-vec3(.5,0,5.5)))//spheroid shit\n ;d=minxb(d,demoSpheroidB(u-vec3(.5,0,2)))//spheroid shit exponential\n ;d=minxb(d,dfPoly(u+vec3(0,0,2)))//array of 16 different spheroids,slow due to 4x4 lattice.\n ;//d=min(d,demohh(u-vec3(3,0,0)).x)//old decapitated basis for scale\n ;//d=min(d,debugHg(u-vec3(0,0,3)).x)//hg_sdf debug playgound\n ;return vec2(d.a/scale,d.b);}\n //;return min(d,dodec);}\n\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n\n\nvec4 demo2NoiseCel(vec2 u,vec2 m\n){vec3 o=vec3(u*6.,cos(iTime)*4.)\n ;o.xz*=r1(iTime*.041);o.zy*=r1(iTime*.021)//lazy small rotation\n ;return vec4(cellular(o,iTime*.161),0,1);}\n\nvec4 demoAd2d(vec2 u,vec2 m//deomes 1d automatic differentiation\n){vec3 c=vec3(0)\n ;w11 a=w11(u.x*9.,1.)\n ;a=w11(u.x,1.)\n ;a=si(ex((a)))//a.b is analytic first derivative of a.a\n //;a=(si(fr(a)))\n ;c.x=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float o=c.x\n ;c.y=a.b\n ;c.yz-=u.y\n ;c.yz=abs(c.yz)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;c=smoothstep(aaa,-aaa,c-aaa)\n ;if(abs(a.b)<aaa*50.)c.z=max(c.z,pow(1.-abs(a.b)*2.,4.))//mark local extrema with vertical lines (better line width would need 2nd derivative)\n ;c=c.zyx//;c=mix(c,c.yzx,iMouse.x/iResolution.x)*2.#\n ;vec4 x=vec4(0  ,c.x,c.x,c.x)//first derivative\n ;vec4 y=vec4(c.y,0  ,c.y,c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(c.z,c.z,0  ,c.z)//coordinate system in magenta/pink\n ;x=pdOver(y,x)//2 graphs,one is 1st derivative  in cyan/blue\n ;x=pdOver(z,x)//add coordinate system that highlights loccal extrema\n ;return x;}\n\nvec4 demo2d1(vec2 u,vec2 m,vec2 n\n){vec2 i=mix(n,m,abs(cos(iTime*2.)))\n ;vec4 c=sqrt(vec4(dd    (m-u) ,dd    (n-u) ,dd    (u) ,dd    (i-u)))//abs(cos())bounce for direction\n ;vec4 d=     vec4(ma(abs(m-u)),ma(abs(n-u)),ma(abs(u)),ma(abs(i-u)))\n ;c=mix(c,d,2.*(cos(iTime)))\n ;float thick=.005,diam=.1\n ;c=smoothstep(.01,-.01,abs(abs(c-diam)-diam+thick)-thick)//i know theres better ways to do this abs(abs())identities...\n ;c.xy+=c.w;return vec4(c.xyz,ma(c.xyz))\n ;vec4 a=pdOver(vec4(0,c.y,0,c.y),vec4(c.x,0,0,c.x))//green over red\n ;c     =pdOver(vec4(c.w,c.w,0,c.w),vec4(0,0,c.z,c.z))//yellow over blue\n ;c     =pdOver(a,c)//green over red over yellow over blue\n ;return c;}\n\nvec3 sspm(float a,vec3 b){return smoothstep(a,-a,b);}\n\nvec4 pd(vec2 u\n){vec2 m=fra(iMouse.xy)\n ;if(iMouse.z<.0)m=-vec2(.5)//while(mouse up)simulate mouse down.\n ;vec2 s=-vec2(1.,sin(iTime))//vector moves over time.\n ;vec3 e=vec3(dd(u)\n ,dd(u-m)\n ,dd(u-s))//eucliden distance projection.\n ;e=sqrt(e)//delayed square root\n ;e-=.5//circle radius\n ;e=abs(e)-.2;//turn cirlce into ring\n ;float SSAA=(cos(iTime)+1.25)*12./min(iResolution.x,iResolution.y);//screen-space-anti-aliasing\n ;e=sspm(SSAA,e)\n ;e=sat(e)\n ;vec3 g=vec3(.96,.25,.05)//color ramp equals cheap colorblind mode.\n ;vec4 c0=vec4(g,e.x)\n ;vec4 c1=vec4(g.yzx,e.y)\n ;vec4 c2=vec4(g.zxy,e.z)//some colors with e.rgb as alpha channel.\n ;c0.rgb*=c0.w//general form scales .rgb by alpha,\n ;c1.rgb*=c1.w//...this acoids some division by 0 cases\n ;c2.rgb*=c2.w\n ;vec4 O=pdOver(c0,c1);O=pdOver(O,c2)\n ;//O=sXor(c0,c1);O=sXor(O,c2)\n ;//O=sAtop(c0,c1);O=sAtop(O,c2)\n ;vec4 bg=vec4(vec3((checkerBool2(u))),u.y)\n //;bg.rgb=pow(bg.rgb,vec3(2.2))\n ;if(O.w!=0.)O.rgb/=O.w\n ;O=pdOver(O,bg);\n ;O.rgb=pow(O.rgb,vec3(1./2.2))/**/\n ;return O;}\n\n/*\nvec4 demoshit(vec2 fragCoord\n){vec2 uv=(fragCoord.xy-iResolution.xy*0.5)/iResolution.y\n ;vec3 lir=normalize(vec3(.5,1.0,-.25))\n ;// Simple model-view matrix:\n ;v33 ray=cam(uv)\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return vec4(c);}*/\n\nvec4 demoHg3d(vec2 u\n){vec3 lir=norma(vec3(.5,1.0,-.25))\n ;v33 ray=cam(u)\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return c;}\n\n//solve 2 limb-IK and paint it,red&green=limbs; Yellow=ellbow and hand ; blue= handRange \n#define eIK .001\nvec4 demoIkX(vec2 u,vec2 m,vec2 l//2 limb IK along x-axis (circleCircleIntersection)\n){vec2 i=1.+vec2(1,-1)*eIK//evade rounding errors from moving the boal out too far (overlapping limbs\n ;vec2 L=l.y+l.x*vec2(-1,1);m.x=clamp(m.x,abs(L.x)*i.x,L.y*i.y)//move goalspost within limb range\n ;vec2 e=vec2(0)//ellbow position\n ;e.x=cci(vec3(l.xy,m.x))\n ;e.y=sq(l.x*l.x-e.x*e.x)//point.y on left circle\n //you possibly just want to return [e] (likely rotated back by an angle)\n ;vec4 a=vec4(0)//the rest is \"just\" for visualization\n ;vec1 aaa=2./min(iResolution.x,iResolution.y)\n ;vec1 j=aaa*7.//make outer circle withs j thinner than line segments\n ;a.w=sq(mi(dd(le(u-e)),dd(u-vec2(m.x,0))))-.1//pointAt-Ellbow/Hand\n ;a.w=ab(a.w)+j*.5//turn into \"rings\"\n ;a=vec4(ls(u,e,vec2(0))\n        ,ls(u,e,vec2(m.x,0))\n        ,mi(ab(le(u)-abs(L.yx)))+j\n        ,a.w)\n ;vec2 p=ab(vec2(le(u)-l.x,le(u-vec2(m.x,0))-l.y))+j\n ;a.xy=mi(ab(ab(ab(a.xy)-aaa*14.)-aaa*3.)-aaa*2.,p.xy-aaa*9.)\n ;vec2 mr=(ab(L.x)-vec2(-1,1)*L.y)*.5\n ;a.z=ab(le(u)-mr.x)+mr.y\n ;a.w-=aaa*9.//thicker lines\n ;a=smoothstep(aaa,-aaa,a)\n ;return pdOver\n (pdOver(vec4(1,0,0,1)*a.x,vec4(0,1,0,1)*a.y)\n ,pdOver(vec4(1,1,0,1)*a.w,vec4(0,0,1,1)*a.z*.5));}\n//m is handTarget, n.xy are limb lengths\n//for a planar visualization, we just rotate all inputs by matrix[b]\n//if we wanted the ellbow position, we would have that to be returned and then; return \nvec4 demoIk(vec2 u,vec2 m,vec2 n//2 limb IK along x-axis (circleCircleIntersection)\n){if(iMouse.z<=0.\n ){n=mix(vec2(1,0),vec2(0,1),u5(co(iTime*vec2(.5,.61))))+.5//auromatic limg lengths\n  ;}\n ;//n=vec2(0.61,1.61)//limb lengths\n ;//n=mix(vec2(1,0),vec2(0,1),u5(cos(iTime*vec2(.5,.61))))+.5//optionally change over time\n ;mat2 b=r1(AngleBetween(m));return demoIkX(u*b,m*b,n)\n ;}\n\n\n//https://www.shadertoy.com/view/4l2BRD\n#define dimu(a,b,c) di(mu(a,b),c)\n// remap v from range [min1,max1] to range [min2,max2]// this is unlerp+lerp combined//\n//i call bullshit on this function, no clue what its meant to do, sure not what it says it does.\n//#define remap(v,min1,max1,min2,max2) ((min2)+(max2-(min2))*((v)-(min1))/(max1-(min1)))\n//#define remap(v,min1,max1,min2,max2) mix()\n//#define remap2(v    ,max1,max2,min2) ad(min2,dimu(su(max2,min2),v,max1))\n//#define remap(v,min1,max1,min2,max2) remap2(su(v,min1),su(max1,min1),max2,min2)\nfloat bias(float x,float b){return pow(x,log(b)/log(0.5));}\nfloat gain(float x,float g){return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.;}\n// aaFloor is similar to floor() but has a 2-pixel wide gradient between clamped steps\n// to allow the edges in the result to be anti-aliased.\n//assume u is between s1 and s2, prohect it to a bijective point betweeen t1 and t2\n#define biject(u,s1,s2, t1, t2) mix(t1,t2,(u)/(s2-(s1)))\n/*\nfloat aaFloor(float x\n){float dx=2.*length(vec2(dFdx(x),dFdy(x)))\n ;float fx=fract(x),idx=1.-dx\n ;return (fx < idx) ? x - fx : remap(fx,idx,1.,x-fx,x);}\n// Same as aaFloor;clamp except for a 2-pixel wide gradient along the edge\nfloat aaFract(float x\n){float dx=2.*length(vec2(dFdx(x),dFdy(x)))\n ;float fx=fract(x),idx=1.-dx\n ;return (fx<idx) ? fx : remap(fx,idx,1.,fx,0.);}\n// escalator() is similar to aaFloor(),but takes a phase offset for animating\nfloat escalator(float x,float steps,float o\n){float dx=1./steps\n ;x=remap(x,0.,1.,-dx/2.,1.+dx/2.)+dx/2.\n ;float ex=(x - o*dx)*steps\n ;float ey=(aaFloor(ex)+o)*dx\n ;return clamp(ey,0.,1.);}\n*/\n\n//;return pdOver(pdOver(a[0],a[1]),pdOver(a[2],a[3]));}//matrix sets a tree of pdOver()\nvec4 pdOver4(mat4 a       ){vec4 r=pdOver(a[0],a[1]);if(r.w<1.)r=pdOver(r,pdOver(a[2],a[3]));return r;}\nvec4 pdOver4(mat4 a,mat4 b){vec4                               r=pdOver(a[0],a[1]) ;if(r.w<1.)r=pdOver(r,pdOver(a[2],a[3]))\n                                           ;if(r.w<1.)r=pdOver(r,pdOver(b[0],b[1]));if(r.w<1.)r=pdOver(r,pdOver(b[2],b[3]));return r;}\nvec4 pdOver4(vec4 a       ){return pdOver4(mat4(a.x,0  ,0  ,a.x ,0  ,a.y,0  ,a.y, 0,0,a.z,a.z, a.w,a.w,0  ,a.w));}//example matrix\nvec4 pdOver4(vec4 a,vec4 b){return pdOver4(mat4(a.x,0  ,0  ,a.x ,0  ,a.y,0  ,a.y, 0,0,a.z,a.z, a.w,a.w,0  ,a.w)\n                                           ,mat4(0  ,b.x,b.x,b.x ,b.y,0  ,b.y,b.y, 0,0,0  ,a.z, a.w,a.w,a.w,a.w));}\n\n\nvec4 betaRemap(vec2 u,vec2 m,vec2 s1,vec2 s2,vec2 t1,vec2 t2\n){vec2 v=biject(m-s1,s1,s2,t1,t2)\n ;vec4 c=mix(vec4(s1.x,t1.x,s1.y,t1.y)\n            ,vec4(s2.x,t2.x,s2.y,t2.y),.5)\n ;vec4 d=abs(vec4(vec2(s1.x,t1.x)-c.xy,vec2(s1.y,t1.y)-c.zw))//InStartX,InEndX,InStartY,InEndY\n ;d.xy=abs(vec2(boxf(u-c.xz,d.xz),boxf(u-c.yw,d.yw)))-.01//2 vis boxes\n ;d.z=min(length(u-m),length(u-v))-.1//source and target point indicator\n ;d.xyz=smoothstep(.05,-.05,d.xyz-.01)\n ;d.xy+=d.z;d.z=0.\n ;d.w=mi(d.xyz)\n ;return d;}\nvec4 demoRemap(vec2 u,vec2 m,vec2 n){\n ;vec2 s1=vec2(-1)//source, lower left corner\n ;vec2 s2=vec2(1)//source, top right corner\n ;vec2 t1=vec2(1.1,1.3)//targer, lower left corner\n ;vec2 t2=vec2(2,1.8)//tarhet, top right corner\n ;return betaRemap(u,m,s1,s2,t1,t2);}//great\n //funally got it to wirk and now i remember\n //that this is a VERY simple thing\n //that is doable by a very simple complex function.\n\n\n\n\n\n//http://www.iquilezles.org/www/articles/functions/functions.htm\n//https://www.shadertoy.com/view/lslBzS\n#define sscc(a)(a)*(a)*(3.-2.*(a))\n//grow fast and slowly decay,for triggering behaviours or making envelopes for music or animation,\nfloat impulse(float k,float x){k=k*x;return k*exp(1.-k);}//by iq\nfloat impulse(vec2 p){return p.y-impulse(p.x,5.);}//basic demo of a general parametric\nfloat impulse(vec2 p,vec2 m){return .5*p.y/m.y-impulse(p.x,.5/m.x);}//basic demo of a general parametric\n//instead of filtering features via smoothstep(c-w,c,x)-smoothstep(c,c+w,x)\n//,this cubicPulse()is your friend.Also,why not,you can use it as a cheap replacement for a gaussian.\nfloat cubicPulse(float x,float c,float w){x=abs(x-c);if(x>=w)return 0.;return 1.-sscc(x/w);}//by iq\nfloat cubicPulse(vec2 p){return p.y-cubicPulse(p.x,.5,.2);}//basic demo of a general parametric\nfloat cubicPulse(vec2 p,vec2 m){return p.y-cubicPulse(p.x,m.x*2.,abs(m.y));}//basic demo of a general parametric\n//A nice choice to remap the 0..1 interval into 0..1,such that the corners are remapped to 0.\n//Very useful to skew the shape one side or the other in order to make leaves,eyes,and many other interesting shapes\nfloat pcurve(float x,float a,float b){float k=pow(a+b,a+b)/(pow(a,a)*pow(b,b));return k*pow(x,a)*pow(1.-x,b);}//by iq\nfloat pcurve(vec2 p){ return p.y-pcurve(p.x,1.,2.);}\nfloat pcurve(vec2 p,vec2 m){ return p.y-pcurve(p.x,m.y,m.x*2.);}\n//natural attenuation is an exponential of a linearly decaying quantity\nfloat expStep(float n,float x,float k){return exp(-k*pow(x,n));}//by iq\nfloat expStep(vec2 p){return p.y-expStep(p.x,.00005,.005);}//basic demo of a general parametric\nfloat expStep(vec2 p,vec2 m){return p.y-expStep(p.x,abs(m.y)*.00005,abs(m.x)*.005);}//basic demo of a general parametric\n//f(0)-f(1)-0;f(.5)-1;f'(0)-f'(.5)-f'(1)-0 ;cheap estimate for a normal distribution\nfloat parabola(float x,float k){return pow(4.*x*(1.-x),k);}//by iq\nfloat parabola(vec2 p){ return p.y-parabola(p.x,5.);}//basic demo of a general parametric\nfloat parabola(vec2 p,vec2 m){return p.y-parabola(p.x,m.x*.5);}//basic demo of a general parametric\n\n//linear envelope by ollj ,this is a VERY naive thing,its likely much easier to just multiply an easein with an easeout\n//kinda like the smoothbump() function\nvec4 crunchmiddle(float e,float d,float i,float h2,float h1//middle part crrunched to singularity.\n){float b=d+i-e\n ;float c=smoothstep(1.,0.,-b*2.5+.5)//this easing function mostly fails me\n ;//b=step(0.,b)//b is either 0 or 1 ,as alternative to c\n ;i =mix(i ,i*e/(i+d)    ,c);d =mix(d ,e-i,c)\n ;h1=mix(h1,mix(h1,h2,.5),c);h2=mix(h2,h1 ,c);return vec4(i,d,h1,h2);}\nfloat InouL(float x,float e,float i,float d,float h1,float h2//uv,length,easeInd,easeOutd, 2 heights\n){vec4 j=crunchmiddle(e,d,i,h2, h1)\n ;float h=mix(i,e-d,.5)\n ;if(abs(x-h)<h-i)return smoothstep(0.,e-j.y-j.x,x-j.x)*(j.w-j.z)+j.z\n ;return mix(smoothstep(j.y,0.,x-(e-j.y))*j.w, smoothstep(0.,j.x,x)*j.z,step(x,j.x))\n //;if(x<  j.x)return smoothstep(0.,j.x,x)*j.z;return smoothstep(j.y,0.,x-(e-j.y))*j.w\n ;}\n\n\nvec4 demoEnvBasic(vec2 u,vec2 m,vec2 n\n){vec4 a=vec4(0)\n ;w11 red=w11(u.x,1.)\n ;red= co(mu(red,128.))\n ;a.x= co(mu(u.x,128.))\n ;a.y= sin(u.x)\n ;a.z=-cos(u.x*8.)\n ;a.w=-sin(u.x)\n ;a=su(a,u.y)\n ;//a.x=abs(a.x)\n ;//red=su(red,u.y)\n ;//red=ab(red)\n //the only problem here is within an area that gets blurred\n //for being too far away, and that distance loses precision.\n ;//a.x=(a.x+.5)/(abs(dFdx((a.x)))+.5)-.1\n ;//a.x=(a.x+.5)/(abs(dFdx((a.x)))+.5)-.1\n //from the other shader\n //yeah i am tired of this one ocne again!\n ;//a.x=abs(red.a-u.y)/sqrt(red.b*red.b+2.)+1.//euclidean_scale by first derivative. (bad near very thin extrema)//(red.a+.5)/(red.b+.5)-.1\n ;a.x  =a.x  /fwidth(a.x)  //only works iff a is signed AFTER this\n ;a.yzw=a.yzw/fwidth(a.yzw)//only works iff a is signed AFTER this\n ;a.yzw=abs(a.yzw)\n ;a.x=abs(a.x)\n\n    //;a.x=abs(a.x)\n ;a=ss(1.1,-1.1,a-1.)\n ;return pdOver4(a);}\n\nvec4 demoEnv(vec2 u,vec2 m,vec2 n){\n ;vec2 t=vec2(m.x,n.x)//t is start and end position of an interval\n ;t=cs(iTime)*1.5+1.6\n ;//u.x+=t.x;m.x+=t.x;n.x+=t.x//a lot of fucntions are better with null offset from start. just remap fto that!\n ;//...yes it is better practice to move a canvas, than to inserrt the movement into it!\n ;t.x=0.//because it sets t.x=0.\n ;t=vec2(min(t.x,t.y),max(t.x,t.y))//sorting\n ;vec2 center=vec2(mix(t.x,t.y,.5),0)\n ;vec2 size=vec2(abs(t.x-t.y)*.5,1)\n ;vec4 r=vec4(1)\n ;r.w=boxf(u-center,size)\n ;float frequency=pi/m.x\n ;r.z=sin(u.x*frequency)\n ;//vec2 v=u*vec2(16.,2)//.5*v.y-impulse(v.x,.5/t.y)-u.y//works//=impulse(u.x-t.x,10./t.y)\n ;//r.y=cubicPulse(u*vec2(2,1),vec2(t.y/2.,t.y))-u.y//works\n ;//r.y=InouL(u.x,t.y,1.3,.3,.9,.5)//works,kinda\n ;r.y=sbump(u.x,u.x,t.y,t.y)*4.//works, and sure can be less symmetrical\n ;//r.y=sat(r.y)\n ;r.x=r.z*r.y\n ;r.xyz-=u.y\n ;r.xy=.1*r.xy/iResolution.y/dFdy(r.xy)//doesnt work well for short wavelenghts\n ;r.xyz=abs(r.xyz)\n ;//float d=ma(ab(u-m))\n ;//i know this uses fwidth badly:\n ;float aas=.5/min(iResolution.x,iResolution.y)\n ;r=smoothstep(aas,-aas,r-aas*vec4(0,1,3,0))\n ;r.xyz*=r.w\n ;return r\n ;}\n\nfloat remapollj(float u,float min2,float max2,float min1,float max1){\n ;float s=(max1-min1)/(max2-min2)//scaling factor\n ;float m=min2-min1//movement factor\n ;u=u+m\n ;return u;}\n\n//remap v from range [min1,max1] to range [min2,max2]// this is unlerp+lerp combined\n//float remap(float v,float min1,float max1,float min2,float max2\n//min2 max2 set a target frame\n//min1 max1 are source coords\nvoid demoRemapSS(inout vec2 u,vec2 s1,vec2 s2,vec2 t1,vec2 t2,inout float f){\n ;vec2 g=vec2(f)\n ;vec2 center=mix(t1,t2,.5)\n ;vec2 size=center-min(t1,t2)\n ;f=boxf(u-center,size)\n ;f=abs(f)\n ;f=smoothstep(.01,-.01,f-.01)\n ;if(0.>t1.x-u.x&&0.<t2.x-u.x)g.x=1.\n ;if(0.>t1.y-u.y&&0.<t2.y-u.y)g.y=1.\n ;g.x=mi(g)\n ;if(g.x==1.)u=biject(u-t1,t1,t2,s1,s2);}\n\nvoid mainImage(out vec4 O,vec2 u\n){O=vec4(0)\n ;vec2 auto=(cs(iTime*.5)+vec2(.8,0))*1.2+cs(iTime*3.61)*.2\n ;vec2 m=mix(auto,fra(iMouse.xy),sign(iMouse.z))\n ;vec2 n=mix(auto.yx,fra(iMouse.zw),sign(iMouse.z))\n ;float zoo=viewZoom*.5\n ;vec2 topRight  =vec2( 1)*zoo;topRight.x*=iResolution.x/iResolution.y\n ;vec2 bottomleft=vec2(-1)*zoo;bottomleft.x*=iResolution.x/iResolution.y\n ;u=fra(u)\n ;float scalex=4.\n ;vec2 sourcea=vec2(bottomleft.x,bottomleft.y)\n ;vec2 sourceb=vec2(topRight.x  ,0)\n ;vec2 targeta=vec2(bottomleft.x,0.)*scalex-vec2(3,0)\n ;vec2 targetb=vec2(topRight.x,topRight.y)*vec2(scalex,1)\n ;targetb=abs(targetb)+.1\n ;vec2 center=mix(sourcea,sourceb,.5)\n ;vec2 size=center-min(sourcea,sourceb)\n ;float g=(boxf(u-center,size));g=smoothstep(.1,-.1,abs(g)-.01);vec4 pip2=vec4(g,0,g,g)\n ;if(O.w>=1.)return;O=pdOver(O,pip2)//purple frame shows source of white pip to debug.\n ;float f=0.//for a white frame on the PiP\n ;demoRemapSS(u.xy,sourcea,sourceb,targeta,targetb,f)\n ;u.y+=viewZoom*.25\n ;m.y+=viewZoom*.25\n ;u*=2.\n ;m*=2.\n ;if(O.w>=1.)return;O=pdOver(O,demoRemap(u,m,n))\n ;O=pdOver(O,demo2d1(u,m,n))//mouseCoords is a reasonable top layer\n ;vec4 pip=vec4(f)\n ;if(O.w>=1.)return;O=pdOver(O,pip)//target pip frame\n //you may want to comment out somelayers for performand over seizures.\n ;if(O.w>=1.)return;O=pdOver(O,demoEnv(u,m,n))\n //;if(O.w>=1.)return;O=pdOver(O,demoAd2d(u,m))//ad 1d\n //;if(O.w>=1.)return;O=pdOver(O,demoHg3d(u))//hg_sdf,u-scaling sets camera distance to center\n //;if(O.w>=1.)return;O=pdOver(O,demoIk(u,m,u5(n/2.)))\n //;if(O.w>=1.)return;O=pdOver(O,demoSmin(u,m,n))//ad 1d smin\n //;if(O.w>=1.)return;O=pdOver(O,demoSminBone3(u,m,n))//muscles around a bone, kinda\n //;if(O.w>=1.)return;O=pdOver(O,demoComplex(u,m,n))\n ;//if(O.w>=1.)return ;float c=checkerBoolT(u*1.61)\n ;//if(c<.5)  O=pdOver(O,demo2NoiseCel(u,m)*vec4(.3,.3,.3,1.))//celularNoise\n ;//else  O=pdOver(O,demoRainbow(u,m,n))//hue gradients \n ;O=pdOver(O,vec4(checkerBoolT(u*1.61)*.25+.25))\n ;}\n\n\n\n\n\n\n\n\n\n\n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dls(a,b,c) ls(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return lsY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return ls(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\n\n\n\n/*\nvoid main(){vec4 o=vec4(1);mainImage(o,v1u*iResolution.xy);\n//Tiny Bridge300 O Mouse5small,fixes iResolution.z iMouse and iTime shadertoy compatibility\n</script><script id=\"i\">=o;}</script><script>//body for all vertex shader versions\n//boilerplate based on piLibs 2015-2017@ http://www.iquilezles.org/www/material/piLibs/piLibs.htm\nwindow.requestAnimFrame=(function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame\n||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(cb){window.setTimeout(cb,16);};})();\nvar mF32Textures=mF16Textures=mDerivatives=mDrawBuffers=mDepthTextures=mHaderTextureLOD=true//assimilateds \nvar mC,mS={},par={startTime:Date.now(),t:0,f:0,MX:0,MY:0,MZ:0,MW:0,SX:0,SY:0}//uniforms,timestamp,mouse,canvasSize\n,sB=null,mR,vA,mS\nfunction gei(a){return document.getElementById(a).textContent;}\nfunction cul(p,l){if(p.uniformsCache===undefined)p.uniformsCache={};p.uniformsCache[l]=m.getUniformLocation(p,l);}\nfunction SetShaderConstant1I(u,x){m.uniform1i(m.getUniformLocation(sB.mProgram,u),x);}\nfunction SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant1F(u,x){m.uniform1f(m.getUniformLocation(sB.mProgram,u),x);}//fine\nfunction SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\nfunction SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\nfunction SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\ndocument.addEventListener('mousedown' ,function(e){par.MZ=e.clientX/window.innerWidth;par.MW=1-e.clientY/window.innerHeight;},false)\ndocument.addEventListener('mouseup' ,function(e){par.MZ=0.;par.MW=0.;},false)\ndocument.addEventListener('mousemove' ,function(e){par.MX=e.clientX/window.innerWidth;par.MY=1-e.clientY/window.innerHeight;},false)\nvar fpsTo,fpsA,pL=pN=fl=mi=mis=0\nfunction rAf(\n){pL=pN;pN=performance.now()//2 frame timestamps\n ;par.t=Date.now()-par.startTime\n ;var now=new Date();sec=now.getHours()*3600+now.getMinutes()*60+now.getSeconds();//;SetRenderTarget(null)\n ;sB=mS;m.useProgram(mS.mProgram);\n ;SetShaderConstant1I(\"iFrame\",par.f)//older error was:wrong type\n ;SetShaderConstant1F(\"iTime\",par.t*0.001)//error runs too fast?\n ;SetShaderConstant4F(\"iMouse\",[par.MX*mD.width,par.MY*mD.height,par.MZ*mD.width,par.MW*mD.height])\n ;SetShaderConstant4F(\"iDate\",[now.getFullYear(),now.getMonth(),now.getDate(),sec])\n ;SetShaderConstant3F(\"iResolution\",[mD.width,mD.height,1])\n ;m.drawElements(m.TRIANGLES,3,m.UNSIGNED_SHORT,0);par.f=par.f+1.0;fpsA++;var te=(pN-pL).toFixed(2)\n ;if(te>mi)mi=te//mis shows the largest sime it took for the last M-frames to render,doubles on frame skips/hickups.\n ;document.getElementById(\"IF\").innerHTML=wMs[wM]+\"-\"+(par.f).toFixed(0)+\"<br>fps:\"+fl+\"<br>ms \"+mis+\"<br>tB-o300\"\n ;if((pN-fpsTo)>250){fl=(1000.*fpsA/(pN-fpsTo)).toFixed(2);mis=te;mi=0.;fpsA=0;fpsTo=pN;};requestAnimFrame(rAf);}\nvar mF32Textures=mF16Textures=mDerivatives=mDrawBuffers=mDepthTextures=mHaderTextureLOD=mRenderToFloat32F=false\nfunction extendGL(//optional openGL_ES extensions\n){if(w2//not all extensions exist in all versions of OpenGL_ES,webgl is a patchwork of extensions prior to version300es:\n){mDerivatives=m.getExtension('OES_standard_derivatives')\n  ;mHaderTextureLOD=mF32Textures=m.getExtension('OES_texture_float')//these extensions were optional prior to version300es\n  ;mF16Textures=m.getExtension('OES_texture_half_float')//...and are included in version 300es\n  ;mDrawBuffers=m.getExtension('WEBGL_draw_buffers') ;mDepthTextures=m.getExtension('WEBGL_depth_texture')\n  ;mHaderTextureLOD=m.getExtension('EXT_shader_texture_lod');}else mRenderToFloat32F=m.getExtension('EXT_color_buffer_float')//version300es exclusive extension\n ;mF32Filter=m.getExtension('OES_texture_float_linear')//but these 3 extensions persist as extensions\n ;mF16Filter=m.getExtension('OES_texture_half_float_linear');mAnisotropic=m.getExtension('EXT_texture_filter_anisotropic');}\nfunction sh(a,b){alert(a+\"\\n\"+m.getShaderInfoLog(b));}\nfunction cs(v,h,b){m.shaderSource(v,h);m.compileShader(v);if(!m.getShaderParameter(v,m.COMPILE_STATUS)){sh(b,v);}}\n;function pIn(\n){par.MX=(e.clientX/window.innerWidth);par.MY=(1-e.clientY/window.innerHeight);par.MZ=0.;par.MW=0.//optional clean mouse init\n ;mD=document.getElementById(\"ID\");mD.width=mD.offsetWidth;mD.height=mD.offsetHeight;m=false;while(wM>-1&&!m\n){m=mD.getContext(wMs[wM--]\n,{alpha:false,depth:false,stencil:false,premultipliedAlpha:false,antialias:false,preserveDrawingBuffer:false,powerPreference:\"high-performance\"})}\n ;wM++;w2=(m instanceof WebGLRenderingContext);extendGL()\n ;var j=\"\\n#ifdef GL_ES\\nprecision highp float;precision highp int;\\n#endif\\n\",hF,hV=(w2)?j:\"#version 300 es\\n\"+j\n ;if(w2//hV,hF puzzle concatenate a string for 2 shader shader programs;vertex,fragment\n){hF=j\n  ;if(mDerivatives)hF+=\"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives:enable\\n#endif\\n\"\n  ;if(mHaderTextureLOD)hF+=\"#extension GL_EXT_shader_texture_lod:enable\\n\"\n  ;if(mHaderTextureLOD){hF+=\"vec4 textureLod(sampler2D s,vec2 c,float b){return texture2DLodEXT(s,c,b);}\\n\"\n  ;hF+=\"vec4 textureGrad(sampler2D s,vec2 c,vec2 dx,vec2 dy){return texture2DGradEXT(s,c,dx,dy);}\\n\";}\n ;}else hF=hV\n ;var a=w2?\"attribute vec2 iPo;varying vec2 v1u;\":\"layout(location=0)in vec2 iPo;out vec2 v1u;\"\n ;hV+=j+\"uniform float iTime;uniform vec4 iMouse;\"+a+\"void main(){v1u=iPo*.5+.5;gl_Position=vec4(iPo,0,1);}\"\n ;var b=w2?\"varying \"+gei('h')+\"gl_FragColor\":\"out vec4 outColor;in \"+gei('h')+\"outColor\"\n ;hF+=gei('e')+b+gei('i');m.bindBuffer(m.ARRAY_BUFFER,m.createBuffer())\n ;m.bufferData(m.ARRAY_BUFFER,new Float32Array([-1,3,0,0,0,0,3,-1,0,-1,-1,0]),m.DYNAMIC_DRAW);m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,m.createBuffer())\n ;m.bufferData(m.ELEMENT_ARRAY_BUFFER,new Uint16Array([2,3,0]),m.STATIC_DRAW);m.vertexAttribPointer(m.enableVertexAttribArray(vA),3,m.FLOAT,false,0,0)\n//;m.vertexAttribPointer(svp,2,m.FLOAT,false,0,0)\n ;var v=m.createShader(m.VERTEX_SHADER),f=m.createShader(m.FRAGMENT_SHADER)\n ;cs(v,hV,\"v\");cs(f,hF,\"f\");mS.mProgram=m.createProgram();var p=mS.mProgram;pc=p;m.attachShader(p,v);m.attachShader(p,f)\n ;m.linkProgram(p);cul(p,'iFrame');cul(p,'iTime');cul(p,'iMouse');cul(p,'iDate');cul(p,'iResolution')\n ;if(!m.getProgramParameter(p,m.LINK_STATUS))sh(lp,p);to=performance.now();fpsTo=performance.now();par.f++;rAf();}\n</script><body onload=\"pIn()\"><canvas id=\"ID\"></canvas><div id=\"IF\"></div></body></html>\n    /**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tycWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4129, 4213, 4230, 4230, 4298], [4299, 4299, 4325, 4325, 4372], [4373, 4373, 4391, 4391, 4437], [4791, 4972, 4993, 4993, 5028], [5029, 5029, 5050, 5050, 5085], [5086, 5174, 5191, 5191, 5214], [5214, 5214, 5231, 5231, 5254], [5254, 5254, 5271, 5271, 5287], [5673, 6211, 6234, 6234, 6296], [6297, 6297, 6319, 6319, 6360], [6361, 6361, 6384, 6384, 6402], [6402, 6533, 6556, 6556, 6573], [6574, 6574, 6590, 6590, 6607], [7300, 7300, 7314, 7314, 7337], [7338, 7338, 7352, 7352, 7375], [7376, 7376, 7390, 7390, 7413], [9203, 10215, 10231, 10231, 10264], [10265, 10265, 10288, 10288, 10320], [10321, 10321, 10345, 10345, 10369], [10370, 10370, 10397, 10397, 10426], [10427, 10427, 10441, 10441, 10470], [10471, 10471, 10485, 10485, 10514], [10625, 10686, 10712, 10712, 10731], [10732, 10863, 10892, 10892, 10915], [10915, 11002, 11018, 11018, 11050], [11051, 11051, 11067, 11067, 11089], [11090, 11090, 11108, 11108, 11126], [11126, 11465, 11489, 11489, 11499], [11500, 11500, 11524, 11524, 11542], [11543, 11543, 11567, 11567, 11591], [11592, 11592, 11615, 11615, 11633], [11633, 11664, 11689, 11689, 11713], [11929, 11977, 12007, 12007, 12039], [12039, 12059, 12083, 12083, 12115], [12115, 12150, 12166, 12166, 12207], [12207, 12251, 12267, 12267, 12308], [12308, 12348, 12382, 12382, 12446], [12446, 12493, 12576, 12576, 12627], [12630, 12669, 12687, 12687, 12709], [12710, 12710, 12727, 12727, 12754], [12755, 12755, 12772, 12772, 12806], [12807, 12807, 12826, 12826, 12862], [12863, 12863, 12882, 12882, 12918], [12920, 12920, 12938, 12938, 12966], [12966, 13033, 13066, 13066, 13103], [13156, 13283, 13300, 13300, 13353], [13353, 13435, 13452, 13452, 13517], [13517, 13536, 13554, 13554, 13598], [13598, 13685, 13703, 13703, 13759], [13759, 13810, 13828, 13828, 13877], [13877, 13939, 13956, 13956, 13988], [13988, 14026, 14043, 14043, 14077], [14077, 14094, 14118, 14118, 14130], [14130, 14130, 14154, 14154, 14166], [14166, 14197, 14221, 14221, 14247], [14247, 14304, 14335, 14335, 14359], [14359, 14417, 14434, 14434, 14457], [14457, 14473, 14497, 14497, 14561], [14561, 14615, 14639, 14639, 14666], [14666, 14728, 14753, 14753, 14794], [14794, 14881, 14898, 14898, 14923], [14923, 15066, 15090, 15090, 15117], [15117, 15179, 15211, 15211, 15240], [15240, 15265, 15297, 15297, 15326], [15326, 15398, 15423, 15423, 15450], [15450, 15492, 15525, 15525, 15554], [15554, 15703, 15720, 15720, 15767], [15767, 15977, 15995, 15995, 16077], [16078, 16078, 16095, 16095, 16143], [16145, 16368, 16386, 16386, 16488], [16489, 16489, 16506, 16506, 16533], [16533, 16580, 16598, 16598, 16625], [16625, 16736, 16754, 16754, 16801], [16801, 17091, 17109, 17109, 17131], [17131, 17695, 17714, 17714, 17772], [17772, 17957, 17976, 17976, 18031], [18031, 18216, 18234, 18234, 18255], [18255, 18325, 18343, 18343, 18364], [18364, 18653, 18673, 18673, 18763], [18763, 19071, 19090, 19090, 19149], [19149, 19400, 19420, 19420, 19537], [19537, 19828, 19848, 19848, 19949], [19949, 20208, 20228, 20228, 20307], [20307, 20531, 20551, 20551, 20589], [20589, 20697, 20717, 20717, 20764], [20764, 20969, 20989, 20989, 21051], [21051, 21272, 21292, 21292, 21366], [21366, 21559, 21579, 21579, 21665], [21676, 21730, 21756, 21756, 21797], [21798, 21869, 21896, 21896, 21963], [21964, 21964, 21992, 21992, 22073], [22074, 22126, 22153, 22153, 22235], [22236, 22236, 22263, 22263, 22355], [22490, 22591, 22631, 22631, 23397], [23400, 24298, 24316, 24316, 24338], [24338, 24915, 24932, 24932, 24979], [24980, 24980, 24997, 24997, 25029], [25030, 25030, 25047, 25047, 25088], [25089, 25089, 25106, 25106, 25156], [25157, 25721, 26284, 26284, 26315], [26602, 26602, 26623, 26623, 26655], [26656, 26656, 26677, 26677, 26709], [26710, 26710, 26731, 26731, 26758], [26759, 27675, 28340, 28340, 28371], [28569, 28569, 28722, 28722, 28772], [28773, 28773, 28796, 28796, 28834], [28835, 28835, 28858, 28858, 28882], [28883, 29062, 29212, 29212, 29267], [29717, 30654, 30677, 30677, 30697], [30698, 30698, 30721, 30721, 30741], [30742, 30742, 30765, 30765, 30785], [30786, 30786, 30811, 30811, 30867], [30868, 30868, 30893, 30893, 30935], [30936, 30936, 30961, 30961, 30987], [30990, 31486, 31527, 31564, 31775], [32456, 32800, 32816, 32816, 32840], [32840, 32849, 32872, 32872, 32891], [32892, 33232, 33259, 33259, 33280], [33380, 33634, 33650, 33650, 33666], [33667, 33667, 33683, 33683, 33697], [33698, 33698, 33714, 33714, 33724], [33725, 33725, 33741, 33741, 33757], [33758, 33758, 33774, 33774, 33789], [33790, 33790, 33806, 33806, 33821], [33822, 33822, 33838, 33838, 33848], [34887, 35009, 35032, 35032, 35055], [35056, 35056, 35082, 35082, 35125], [35458, 35498, 35517, 35517, 35560], [35561, 35561, 35580, 35580, 35624], [35625, 35625, 35644, 35644, 35683], [35684, 35684, 35703, 35703, 35778], [35779, 35779, 35798, 35798, 35934], [35935, 35935, 35954, 35954, 35989], [35990, 35990, 36010, 36010, 36055], [36056, 36056, 36076, 36076, 36164], [36165, 36165, 36185, 36185, 36279], [36280, 36280, 36300, 36300, 36516], [36517, 36742, 36760, 36760, 36828], [36829, 36829, 36893, 36893, 37251], [37251, 37718, 37733, 37733, 37764], [37764, 37840, 37855, 37855, 37886], [37887, 37887, 37904, 37904, 37936], [37937, 37937, 37958, 37958, 37987], [37988, 37988, 38010, 38010, 38035], [38036, 38036, 38059, 38059, 38071], [38072, 38072, 38097, 38097, 38138], [38140, 39189, 39205, 39205, 39246], [39247, 39307, 39332, 39332, 39373], [39374, 39465, 39498, 39498, 39530], [39726, 39972, 39994, 39994, 40025], [40025, 40080, 40102, 40102, 40133], [40133, 40188, 40208, 40208, 40241], [40241, 40271, 40291, 40291, 40321], [40322, 40364, 40387, 40387, 40419], [40420, 40420, 40443, 40443, 40475], [40741, 40741, 40760, 40760, 40819], [40820, 40820, 40846, 40846, 40950], [41123, 41123, 41142, 41142, 41166], [44033, 44380, 44399, 44399, 44433], [44434, 44434, 44453, 44453, 44487], [44488, 44488, 44507, 44507, 44554], [44554, 44578, 44598, 44598, 44649], [44649, 44673, 44693, 44693, 44720], [44720, 44750, 44770, 44770, 44816], [44816, 44845, 44866, 44866, 44894], [45110, 45487, 45617, 45617, 46265], [46266, 46412, 46433, 46433, 46461], [46462, 46462, 46594, 46594, 47533], [47535, 47833, 47858, 47858, 48008], [48009, 48009, 48044, 48044, 48169], [48170, 48170, 48230, 48230, 48403], [48405, 48539, 48576, 48576, 48628], [48629, 48629, 48673, 48673, 48752], [48753, 48753, 48797, 48797, 48913], [48914, 49403, 49441, 49441, 49486], [49487, 49487, 49525, 49525, 49569], [49570, 49570, 49629, 49629, 49705], [49706, 49706, 49747, 49747, 49824], [49825, 49825, 49864, 49864, 50021], [50022, 50022, 50062, 50062, 50205], [50317, 50317, 50336, 50336, 50520], [50521, 50989, 51015, 51015, 51080], [51103, 51103, 51144, 51144, 51390], [51390, 51530, 51563, 51563, 51960], [52324, 52678, 52703, 52703, 52965], [52965, 53067, 53093, 53093, 53122], [53122, 53273, 53297, 53297, 53332], [53332, 53446, 53471, 53553, 53647], [53648, 53817, 53852, 53852, 54211], [54907, 55270, 55305, 55305, 55345], [55345, 55942, 55960, 55960, 56003], [56004, 56140, 56208, 56208, 56432], [56433, 56557, 56651, 56651, 57155], [57155, 57220, 57273, 57273, 57344], [57906, 57998, 58093, 58093, 58995], [58995, 59074, 59105, 59105, 59162], [59163, 59450, 59492, 59492, 59551], [59552, 59594, 59619, 59619, 60279], [60281, 60281, 60298, 60298, 60325], [60329, 60548, 60568, 60568, 60597], [60598, 60598, 60618, 60618, 60647], [60648, 60648, 60669, 60669, 60694], [60695, 60695, 60715, 60715, 60744], [60745, 60745, 60765, 60765, 60794], [60795, 60795, 60816, 60816, 60841], [60842, 60842, 60862, 60862, 60891], [60892, 60892, 60912, 60912, 60941], [60942, 60942, 60963, 60963, 60988], [60989, 61627, 61650, 61650, 61667], [61667, 61667, 61688, 61688, 61709], [61710, 61710, 61733, 61733, 61750], [61750, 61750, 61771, 61771, 61792], [61793, 61793, 61816, 61816, 61833], [61833, 61833, 61854, 61854, 61875], [61876, 61876, 61899, 61899, 61916], [61916, 61916, 61937, 61937, 61958], [62063, 62205, 62231, 62231, 62249], [62250, 62250, 62277, 62277, 62297], [62298, 62298, 62325, 62325, 62349], [62350, 62350, 62376, 62376, 62404], [62405, 62405, 62430, 62430, 62444], [62444, 63059, 63139, 63139, 63303], [63304, 63304, 63334, 63334, 63498], [63699, 63812, 63843, 63843, 63878], [63878, 63941, 63964, 63964, 63991], [63992, 63992, 64023, 64023, 64055], [64055, 64114, 64137, 64137, 64164], [65159, 65223, 65263, 65263, 66157], [66160, 66160, 66216, 66216, 66415], [66851, 67057, 67092, 67092, 67128], [67735, 67842, 67868, 67868, 67993], [68414, 68608, 68625, 68625, 68673], [69076, 69430, 69465, 69465, 69499], [69500, 69529, 69564, 69564, 69599], [69599, 69628, 69663, 69663, 69698], [69698, 69728, 69749, 69749, 69771], [70156, 70266, 70382, 70382, 72286], [72288, 72288, 72392, 72392, 73950], [73951, 73951, 74026, 74026, 74124], [74125, 74218, 74253, 74253, 74307], [74384, 74831, 74856, 74856, 74950], [74951, 74984, 75011, 75011, 75079], [75081, 75189, 75296, 75320, 75801], [75802, 75802, 75836, 75836, 75885], [75888, 75888, 75996, 75996, 76059], [76060, 76060, 76085, 76085, 76143], [76145, 76270, 76295, 76295, 76371], [76373, 76373, 76397, 76397, 76441], [76442, 76442, 76466, 76466, 76603], [76603, 76678, 76702, 76702, 76763], [76765, 76765, 76789, 76789, 77180], [77182, 77182, 77211, 77211, 77254], [77259, 77259, 77281, 77281, 78263], [79535, 79607, 79655, 79655, 79730], [79974, 80155, 80210, 80210, 80366], [80367, 80367, 80422, 80422, 80578], [80579, 80579, 80634, 80634, 80662], [80710, 80710, 80746, 80746, 80770], [80771, 80991, 81012, 81012, 82213], [82411, 82483, 82556, 82556, 82670], [82672, 82672, 82731, 82731, 82891], [83152, 83192, 83246, 83246, 83359], [83360, 83360, 83445, 83445, 83619], [83620, 83620, 83697, 83697, 83923], [83924, 83953, 84053, 84053, 84745], [84746, 84746, 84837, 84837, 85411], [85414, 86463, 86572, 86572, 86821], [86824, 86885, 86981, 86981, 87860], [87863, 89006, 89116, 89116, 89938], [90168, 90213, 90293, 90478, 91352], [91352, 91395, 91439, 91439, 91691], [91693, 91693, 91765, 91885, 92229], [92319, 92500, 92546, 92546, 92796], [92797, 92797, 92829, 92829, 92870], [92871, 92871, 92903, 92903, 93004], [93057, 93057, 93078, 93133, 93225], [93226, 93226, 93255, 93255, 93279], [93280, 93280, 93310, 93310, 93336], [93337, 93391, 93413, 93413, 93436], [93437, 93561, 93590, 93590, 93659], [93660, 93660, 93689, 93689, 93744], [93920, 94114, 94152, 94152, 94185], [94263, 94337, 94429, 94429, 94562], [94567, 94608, 94627, 94627, 94763], [94764, 94764, 94792, 94792, 95190], [95243, 95243, 95320, 95320, 95412], [95416, 95572, 95628, 95628, 95762], [95765, 95850, 95873, 95873, 95923], [95924, 95924, 95948, 95948, 95989], [95990, 95990, 96007, 96007, 96030], [97911, 97933, 97976, 97976, 98079], [98080, 98080, 98125, 98125, 98275], [98320, 98320, 98601, 98601, 98765], [98819, 98819, 99210, 99210, 99298], [99299, 99299, 99336, 99336, 99465], [99502, 99502, 99742, 99742, 99882], [99928, 99928, 100278, 100278, 100328], [100329, 100329, 100373, 100373, 100412], [100413, 100413, 100466, 100466, 100520], [100521, 100521, 100573, 100573, 100614], [100615, 100657, 100680, 100680, 100710], [100710, 100748, 100774, 100774, 101422], [101423, 101423, 101450, 101450, 102219], [102222, 102237, 102257, 102257, 102332], [102333, 102333, 102353, 102353, 102428], [102429, 102429, 102449, 102449, 102472], [102473, 102473, 102493, 102493, 102516], [102517, 102534, 102551, 102551, 102930], [103131, 103274, 103372, 103372, 103600], [103601, 103816, 103857, 103857, 104096], [104097, 104097, 104178, 104178, 104477], [104481, 104580, 104651, 104651, 105500], [105502, 105502, 105526, 105526, 106312], [106315, 106315, 106382, 106382, 106755], [106757, 106757, 106785, 106785, 106828], [106830, 106830, 106850, 106850, 108177], [108180, 108180, 108201, 108201, 108671], [108674, 108674, 108717, 108717, 109283], [109285, 109311, 109344, 109376, 110268], [110269, 110269, 110328, 110328, 110516], [110519, 110519, 110554, 110554, 110694], [110696, 110696, 110763, 110763, 111644], [111646, 111646, 111682, 111682, 112320], [112322, 112322, 112348, 112348, 112375], [112377, 112377, 112394, 112394, 113404], [113406, 113696, 113719, 113719, 113871], [113873, 113980, 114067, 114067, 115178], [115179, 115377, 115463, 115463, 115753], [115830, 116306, 116334, 116334, 116365], [116366, 116366, 116394, 116394, 116460], [117394, 117482, 117510, 117510, 117585], [117586, 117586, 117614, 117614, 117844], [117845, 117845, 117873, 117873, 117959], [117959, 117976, 118004, 118004, 118203], [118206, 118206, 118269, 118269, 118708], [118709, 118709, 118746, 118746, 118973], [119260, 119359, 119390, 119390, 119416], [119416, 119424, 119446, 119446, 119474], [119474, 119511, 119540, 119540, 119579], [119579, 119794, 119836, 119836, 119886], [119886, 119894, 119919, 119919, 119953], [119953, 119990, 120022, 120022, 120066], [120066, 120314, 120352, 120352, 120424], [120424, 120432, 120453, 120453, 120484], [120485, 120485, 120513, 120513, 120549], [120550, 120622, 120661, 120661, 120686], [120686, 120694, 120716, 120716, 120753], [120753, 120790, 120819, 120819, 120874], [120874, 120996, 121028, 121028, 121055], [121055, 121063, 121086, 121086, 121116], [121116, 121153, 121183, 121183, 121216], [121254, 121413, 121514, 121514, 121778], [121779, 121779, 121882, 121882, 122185], [122188, 122188, 122229, 122229, 123079], [123081, 123081, 123116, 123116, 124247], [124249, 124249, 124318, 124318, 124426], [124428, 124640, 124717, 124717, 124986], [124988, 124988, 125023, 125023, 126970]], "test": "error"}
{"id": "4tycWV", "name": "Cellar", "author": "dila", "description": "I spent a while tweaking this. I still think it's a bit dark but I wanted to experiment with shadows.", "tags": ["raymarch"], "likes": 8, "viewed": 262, "published": "Public", "date": "1537865515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat box(vec3 p) {\n\tvec3 q = abs(p);\n   \tfloat d = max(q.x, max(q.y, q.z)) - 1.0;\n    d = max(d, 0.8 - max(q.y, q.z));\n    d = max(d, 0.9 - max(q.x, q.z));\n    d = max(d, 0.95 - max(q.x, q.y));\n    return d;\n}\n\nfloat mapmat = 0.0;\n\nfloat map(vec3 p) {\n    p.z = (fract(p.z / 3.0) - 0.5) * 3.0;\n    float k = 3.0;\n    vec3 q = p - vec3(0.5, 0.0, 0.0);\n    q.x = (fract(q.x / k) - 0.5) * k;\n    q.xz *= rot(3.141592 * 0.25);\n\tfloat a = box(q);\n    q = p + vec3(1.0, 0.0, 0.0);\n    q.x = (fract(q.x / k) - 0.5) * k;\n    q.xz *= rot(3.141592 * 0.5);\n    a = min(a, box(q));\n    float f = -abs(p.y) + 1.01;\n    mapmat = 0.0;\n    if (f < a) {\n        mapmat = 1.0;\n        a = f;\n    }\n    return a;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.2));\n    vec3 o = vec3(iTime, 0.0, -1.3);\n\n    float t = trace(o, r);\n    float mat = mapmat;\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n    float gt = iTime * 3.141592 * 0.25;\n    vec3 lp = vec3(o.x + sin(gt), sin(gt) * 0.25, 0.35);\n    vec3 ld = lp - w;\n    float ll = length(ld);\n    ld /= ll;\n    float lt = trace(w + sn * 0.01, ld);\n    float m = max(sign(lt - ll), 0.0);\n    m *= max(dot(sn, ld), 0.0);\n    \n    vec3 lv = lp - o;\n    float lvl = length(lv);\n    lv /= lvl;\n    float lf = trace(o, normalize(lv + r * 0.01));\n    float lfm = max(sign(lf - lvl), 0.0);\n\n    vec3 sc = vec3(1.0, 0.5, 0.5) * 2.0;\n    \n    vec3 f = vec3(1.0);\n\tif (mat == 1.0) {\n        vec2 tuv = w.xz;\n    \tf = texture(iChannel0, tuv * 0.5).xyz;\n        f *= f;\n        f = mix(f, vec3(dot(f, vec3(0.33))), .5);\n\t} else { /* thanks Shane */\n        vec3 tuv = w.yxz * 0.5;\n        vec3 ta = texture(iChannel1, tuv.yz).xyz;\n        vec3 tb = texture(iChannel1, tuv.xz).xyz;\n        vec3 tc = texture(iChannel1, tuv.xy).xyz;\n        vec3 asn = max(abs(sn) - .1, .0001);\n        asn /= length(asn);\n        f = (ta * ta*asn.x + tb * tb*asn.y + tc * tc*asn.z);\n        f *= sc;\n\t}\n    \n    vec3 lcol = vec3(1.0, 1.0, 1.0);//vec3(1.0, 0.75, 0.25);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    f *= fog * (0.8 * (abs(sn.y + sn.z)) + m);\n    f *= lcol / (1.0 + ll * ll * 0.01);\n    f *= map(w + sn * 1.3);\n    \n    float sp = pow(max(dot(reflect(sn, lv), -r) - 0.1, 0.0), 8.0);\n    sp *= 1.0 - mat;\n    \n    f += lcol * sc * sp / (1.0 + ll * ll * 0.1) * fog;\n    f /= 1.0 + map(w) * 100.0;\n    \n    float ls = 0.0;\n    for (int i = 0; i < 8; ++i) {\n        vec3 p = o + r * ls;\n        ls += length(p - lp) - 0.01;\n    }\n    ls = 1.0 / (1.0 + ls * ls * 0.01) * 1.5;\n    \n    f += lcol * ls * lfm;\n    \n    fragColor = vec4(sqrt(f), 1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tycWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [73, 73, 92, 92, 283], [306, 306, 325, 325, 769], [771, 771, 792, 792, 994], [996, 996, 1025, 1025, 1130], [1132, 1132, 1189, 1189, 3193]], "test": "error"}
{"id": "4tyyDD", "name": "Homework 1", "author": "clayton_redmon7", "description": "Hw1", "tags": ["simple", "eku"], "likes": 1, "viewed": 64, "published": "Public", "date": "1536182168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float PI = 3.14159265359; //a tasty dinner meal\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //setup for circle positions and size later\n    vec2 p = (2.0 *fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 m = (2.0 *iMouse.xy - iResolution.xy)/iResolution.y;\n    float dist = distance(p*1.5,m*1.5);\n    float rad = 2.0f;\n    \n  /*  colors  */\n    \n    vec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 col = black;\n    vec3 rainbow = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 checkCol = black; //checker color\n    \n  /*  https://www.shadertoy.com/view/llsXzn  */\n    \n    //Triangle barycentric coordinates defined on screen space\n    vec2 t0 = vec2(0.75+(cos(iTime+(2.0*PI/3.0))/5.0), 0.25+(sin(iTime+(2.0*PI/3.0))/5.0));\n\tvec2 t1 = vec2(0.75+(cos(iTime+(4.0*PI/3.0))/5.0), 0.25+(sin(iTime+(4.0*PI/3.0))/5.0));\n\tvec2 t2 = vec2(0.75+(cos(iTime-(6.0*PI/3.0))/5.0), 0.25+(sin(iTime-(6.0*PI/3.0))/5.0));   \n    \n    //Compute UV coordinates\n    \n    vec2 v0 = t2 - t0; vec2 v1 = t1 - t0; vec2 v2 = uv - t0;\n\t\n    //Compute barycentric coordinates \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0/(dot00 * dot11 - dot01 * dot01);\n    float baryX = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float baryY = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    if((baryX >= 0.0) && (baryY >= 0.0) && (baryX + baryY <= 1.0))\n    \tfragColor = vec4(rainbow, 1.0);\n    else\n        fragColor = vec4(black, 0.0);\n    \n  /*  circles from https://www.shadertoy.com/view/llGcWz  */\n    \n    //bigger first circle\n    if(dist > rad)\n        col = texture(iChannel0, uv).xyz;\n    \n    //setup for funky changing color for checker\n    uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tuv.y = sin(((uv.x+iTime)*10.0)*0.1);\n\n\tvec3 p1 = black; //color positioning magic\n \n\tp1.x = uv.x-cos(iTime)/10.0;\n\tp1.y = uv.y-sin(iTime)/20.0;\n\tp1.z = uv.x-tan(iTime)/30.0;\n    \n    // changing checkerboard\n    float checker = max(max(cos(iTime/4.0)*20.0,-cos(iTime/4.0)*20.0),5.0);\n    \n    //revolving circle\n    p = ((2.0 *fragCoord.xy - iResolution.xy)/iResolution.xy)*vec2(16, 9); //fix size\n    dist = distance(p,vec2(sin(iTime)*16.0,cos(iTime)*9.0));\n    rad = 4.0f;\n    \n    //checker checker adapted from https://www.shadertoy.com/view/Mts3D7\n    if(int(fragCoord.x/checker) % 2 == 0)\n        if(int(fragCoord.y/checker) % 2 == 0) checkCol = -p1;\n        else checkCol = p1;\n    else if (int(fragCoord.x/checker) % 2 == 1)\n    \tif(int(fragCoord.y/checker) % 2 == 1) checkCol = -p1;\n        else checkCol = p1;\n    else checkCol = p1;\n    \n       if(dist < rad)\n        col = checkCol;\n    \n    // repeating rectangle drawing\n    float size = 0.05;\n    float smoothness = 1.0/iResolution.x;\n    for (int i = 1;i<10;i++){\n        int j = i%3+1;\n        //really funky line that controls size and rotation variation\n        uv = abs(((fragCoord.xy -vec2(0.1*float(i),0.1*float(i)) * iResolution.xy) * rotate(iTime*sin(float(i)))/(iResolution.xy/sin(float(i*6)))));\n        float d = max(uv.x, uv.y);\n        if (i%3 == 1) fragColor += vec4(smoothstep(size, size - smoothness, d)/float(j),0,0,0);\n        if (i%3 == 2) fragColor += vec4(0.0,smoothstep(size, size - smoothness, d)/float(j),0,0);\n        if (i%3 == 0) fragColor += vec4(0.0,0.0,smoothstep(size, size - smoothness, d)/float(j),0);\n    }\n    fragColor += vec4(col,0.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 113, 3603]], "test": "error"}
{"id": "4tyyDm", "name": "wavy01", "author": "teraspora", "description": "My first shader!   Uses trig functions to make a simple animation", "tags": ["triganimation"], "likes": 1, "viewed": 284, "published": "Public API", "date": "1536448911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Wavy01 - My first OpenGL shader;\n// Author: John Lynch (teraspora);\n// Date: 09 SEP 2018.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const float PI = 3.141592654;\n    const float TWO_PI = 6.283185307;\n    const vec4 colours[3] = vec4[3](vec4(1., 0.5, 0., 1.), vec4(0., 0.7, 1., 1.), vec4(0.8, 0., 1., 1.)); \n\n    float px = fragCoord.x;\n    float py = fragCoord.y;\n    float w = iResolution.x;\n    float h = iResolution.y;\n\n    vec2 wh2 = vec2(px - w / 2., py - h / 2.);\n\n    // rotate each point\n    float phi = mod(iTime, TWO_PI);\n    float c = cos(phi);\n    float s = sin(phi);\n    float x = wh2.x * c - wh2.y * s + w / 2.;\n    float y = wh2.x * s + wh2.y * c + h / 2.;\n    \n    wh2 = vec2(x - w / 2., y - h / 2.);\n    \n    fragColor = vec4(2. * cos(iTime * 0.2)  * x / w, 0., iMouse.y / h, 1.);\n    float factor = mod(iTime, 40.);\n    float yt = 100. + 50. * (sin(factor * x * 13. / w) * cos(factor * x * 1.3 / w));\n    float yu = h - yt;\n    \n    if (y < yt || y > yu) fragColor = vec4(sin(float(iFrame) / 100.), cos(iTime) / 4., 0.5, 1.);      \n    \n    float r2 = wh2.x * wh2.x + wh2.y * wh2.y;\n    // radius determined by elapsed time (cyclically) and angle\n    if (r2 < 20000. - mod(iTime * 8000., 40000.) + mod(atan(wh2.y, wh2.x), PI / 16.) * r2 * 6.) {\n    \tfragColor = colours[int(mod(float(iFrame) / 120., 3.))];\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyyDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 151, 151, 1356]], "test": "valid"}
{"id": "4tyyDw", "name": "Down the creepy rabbit hole", "author": "Emil", "description": "continuation from my previous experiment where I realised how \"easy\" it was to do 3D planes.", "tags": ["plane", "fake3d", "mode7"], "likes": 5, "viewed": 656, "published": "Public", "date": "1536415140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y; // thanks FabriceNeyret2!\n    vec2 uv_01 = (fragCoord- .5*iResolution.xy )/iResolution.xy;\n    float newTime = iTime*0.1;\n    \n    ///// Start Creepy stuff\n    float rotStrength = (0.06*sin(newTime))/length(uv);\n    float sinX = sin ( rotStrength + newTime);\n    float cosX = cos ( rotStrength + newTime);\n    float sinY = sin ( rotStrength + newTime);\n    mat2 rotMatrix = mat2( cosX, -sinX, sinY, cosX);\n    \n    \n    vec2 twistedUV = uv * rotMatrix;\n    twistedUV.x /= 1.8*(1.0-0.2*sin(newTime));\n    ///// End Creepy stuff\n    \n    vec3 viewDir = normalize(vec3(twistedUV,0.4 + 0.1*sin(newTime*3.0)));\n    \n    vec2 planarUV_y = viewDir.xz/abs(viewDir.y);\n    vec2 planarUV_x = viewDir.yz/abs(viewDir.x);\n    \n    float depth = min(planarUV_y.y, planarUV_x.y);\n    planarUV_y += vec2(0.0, newTime*1.6);\n    planarUV_x += vec2(0.0, newTime*1.6);\n    \n    vec3 albedo = \ttexture( iChannel0, planarUV_y).rgb*step(abs(planarUV_y.x),0.99)\n        \t\t+\ttexture( iChannel0, planarUV_x).rgb*step(abs(planarUV_x.x),1.01);\n    \n    float light = (1.1)/(depth*depth)*viewDir.z*(0.5+0.2*(sin(newTime*5.0)));\n    \n    float fog = clamp(depth*0.02,0.0,0.6);\n    \n    fragColor = vec4(light*albedo+vec3(2.0+sin(newTime*6.0),0.0,0.2)*fog,1.0);\n    fragColor *= 2.5-4.0*max(abs(uv_01.x),abs(uv_01.y)); // square vignette\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1431]], "test": "error"}
{"id": "4tyyzy", "name": "Raymarching trus twist", "author": "uynet", "description": "twist", "tags": ["volumerendering"], "likes": 0, "viewed": 58, "published": "Public", "date": "1536816708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Trus{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n struct Sphere{\n     vec3 pos;\n     float r;\n };\nstruct Ray{\n    vec3 orig;\n    vec3 dist;\n};\n struct Metaball{\n     vec3 pos;\n};\n\n vec3 L =normalize(vec3(1));\nconst float EPS = 0.001;\nTrus trus;\n\n//trus distancefield\nfloat dist(vec3 p,Trus trus){\n  float d;\n   p -= trus.pos;\n   vec3 p_proj = p-trus.dir*(dot(p,trus.dir));\n   p_proj = trus.r * normalize(p_proj);\n   d = length(p_proj - p)-trus.s;\n   return d;\n}\nfloat dist_twist(vec3 p ,Trus trus){\n    float pich = 100.0*sin(iTime);\n    float c = cos(p.y*pich);\n    float s = sin(p.y*pich);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xz,p.y);\n    return dist(q,trus);\n}\n\nfloat dist_s(vec3 p,Sphere sphere){\n   return length(p-sphere.pos)-sphere.r;\n}\n\n\n\n\nRay march(Ray ray, float dist){\n                        //distance / distination\n    Ray r = ray;\n    r.orig = ray.orig + dist*ray.dist;\n    return r;\n}\n\nvec3 rotX(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x,\n\t\tv.y * c - v.z * s,\n\t\tv.z * c + v.y * s\n\t);\n}\n\n// \nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n    dist(p + vec3(EPS, 0.0, 0.0),trus) - dist(p + vec3(0),trus),\n    dist(p + vec3(0.0, EPS, 0.0),trus) - dist(p + vec3( 0),trus),\n    dist(p + vec3(0.0, 0.0, EPS),trus) - dist(p + vec3(0),trus)\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    trus.dir = normalize(vec3(1));\n    //trus.dir = rotX(trus.dir,iTime*100.0);\n    trus.pos = vec3(0,0,0);\n    trus.r = 0.1;\n    trus.s = trus.r/4.0;\n   \n    \n    Sphere sphere;\n    sphere.pos = vec3(sin(iTime)*0.1,0,0);\n    sphere.r = 0.1;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.y*=asp;\n    \n    Ray ray;\n    ray.orig = vec3(0,0,-1);\n    ray.dist = vec3(uv,1);\n    \n    float d1;\n    float d2;\n    \n    float d = 100.0;\n    int t = 0;\n    vec3 col = vec3(0);\n    \n    while(d > EPS){\n        \n        d1 = dist_s(ray.orig,sphere);\n        d2 = dist_twist(ray.orig,trus);\n        //d = min(d1,d2);\n        d = d2;\n        ray = march(ray,d);\n        if(t++>10)break;\n        \n    }\n    if(d<=0.01){\n        vec3 norm =  getNormal(ray.orig);\n        float dif = max(dot(L,norm),0.0);\n        float spe = max(dot(L,reflect(ray.dist,norm)),0.0);\n        float amb = 0.4;\n        col = vec3(dif+spe+amb);\n        //col = norm;\n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyyzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 288, 317, 317, 482], [483, 483, 519, 519, 699], [701, 701, 736, 736, 779], [784, 784, 815, 864, 936], [938, 938, 966, 966, 1095], [1097, 1116, 1140, 1140, 1368], [1370, 1370, 1427, 1427, 2524]], "test": "valid"}
{"id": "ldGfDG", "name": "Stereogram attempt", "author": "trisslotten", "description": "Testing stereogram stuff", "tags": ["stereogram"], "likes": 13, "viewed": 228, "published": "Public", "date": "1536158144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// http://www.techmind.org/stereo/stech.html\nconst float XDPI = 200.;\nconst float EYE_SEP = XDPI*5.0;\nconst float OBS_DIST = XDPI*12.;\n\n//const float REPEAT = 100.;\n\nconst float BASE_DEPTH = 150.;\nconst float BASE_SEP = EYE_SEP*BASE_DEPTH/(BASE_DEPTH + OBS_DIST);\n\nfloat repHash(vec2 coord)\n{\n    //coord.x = mod(coord.x, REPEAT);\n    return hash12(coord + iTime);\n}\n\n\n\nfloat depthMap(vec2 coord)\n{\n    vec2 v = sin(coord*0.02 + 3.*iTime);\n    \n    return BASE_DEPTH + 20. * v.x*v.y;\n}\n\nvec3 genColor(vec2 fragCoord)\n{\n    vec2 currCoord = fragCoord;\n    for(int i = 0; i < 64; i++)\n    {\n        // http://www.techmind.org/stereo/stech.html \n     \tfloat depth = depthMap(currCoord);\n        float sep = EYE_SEP*depth/(depth + OBS_DIST);\n        sep = floor(sep);\n        if(sep < 1.0 || currCoord.x < 0.0)\n            break;\n        currCoord.x -= sep;\n        currCoord.x = floor(currCoord.x);\n    }\n    return vec3(repHash(currCoord));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = genColor(fragCoord);\n    \n    \n    vec2 hori_center = vec2(iResolution.x*0.5, iResolution.y*0.9);\n    float dist_l = length(hori_center - vec2(BASE_SEP/2., 0) - fragCoord);\n    float dist_r = length(hori_center + vec2(BASE_SEP/2., 0) - fragCoord);\n    col = mix(col, vec3(1,0,0), smoothstep(6., 4., dist_l));\n    col = mix(col, vec3(1,0,0), smoothstep(6., 4., dist_r));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 88, 88, 210], [348, 477, 504, 542, 578], [582, 582, 610, 610, 697], [699, 699, 730, 730, 1152], [1154, 1154, 1211, 1211, 1640]], "test": "valid"}
{"id": "llGcDW", "name": "N-gon Distance", "author": "TDM", "description": "Signed distance to n-gon.", "tags": ["circle", "distance", "segmented"], "likes": 10, "viewed": 605, "published": "Public API", "date": "1536236687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Copyright  Alexander Alekseev aka TDM - 2018\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    Thanks to iq for optimization advice\n*/\n\n//#define FAST\n\nconst float PI = 3.141592;\nconst float PI2 = PI * 2.0;\n\n/*\n * distance to segmented circle\n */\n\nfloat distanceNGon(vec2 uv, const float N, const float R) {\n    uv = -uv.yx; \t\t\t\t\t\t\t\t // if you want the corner to be up\n    float sa = PI2 / N; \t\t\t\t\t\t // segment angle\n    float a = floor(atan(uv.y,uv.x)/sa+0.5)*sa;  // round current angle to closest segment angle\n        \n    vec2 p1 = vec2(cos(a),sin(a)); \t\t\t\t // plane to find distance to\n    float distr = dot(uv,p1) - R; \t\t\t\t // signed distance to edge\n#ifndef FAST\n    float hw = R * tan(sa * 0.5); \t\t\t\t // half-width of the edge\n    float disth = abs(dot(uv,vec2(-p1.y,p1.x))); // horizontal distance to the middle of the edge\n    return length(vec2(min(hw-disth,0.0),distr))*sign(distr); // distance to the edge or corner point\n#endif\n    return distr;\n}\n\n/*\n * main\n */\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // get the distance\n    float d = distanceNGon(uv,\n                             floor(5.0 + sin(iTime)*1.999),\n                             0.5 + sin(iTime)*0.2);\n    \n    // colorize it\n    float level = 100.0 / iResolution.x;\n    float cm = smoothstep(-level,level,sin(d*50.0));\n    vec3 col = (d > 0.0) ? \n        \tmix(vec3(0.4,0.2,0.2),vec3(0.7,0.4,0.4)*0.85, cm) :\n    \t\tmix(vec3(0.3,0.5,0.5),vec3(0.4,0.7,0.6), cm);\n    col *= pow(min(abs(d)*20.0, 1.0), 0.333) * 0.75 + 0.25;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGcDW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[257, 297, 356, 356, 1011], [1013, 1033, 1090, 1090, 1710]], "test": "valid"}
{"id": "llGczy", "name": "real quad mapping", "author": "thewhiteambit", "description": "Trying out how Shadertoy works with quad mapping, minor changes only", "tags": ["quad"], "likes": 1, "viewed": 93, "published": "Public", "date": "1536771033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original from https://www.shadertoy.com/view/lsBSDm\n\n// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Inverse bilinear interpolation: given four points defining a quadrilateral, compute the uv\n// coordinates of any point in the plane that would give result to that point as a bilinear \n// interpolation of the four points.\n//\n// The problem can be solved through a quadratic equation. More information in this article:\n//\n// http://www.iquilezles.org/www/articles/ibilinear/ibilinear.htm\n\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    //!!!!!!!!!!!!!!!!!!!!!!!!\n    /*fix from page https://www.shadertoy.com/view/lsBSDm\n\t\tHackerham, 2017-08-07\n\t\tMade a fix: https://gist.github.com/ivanpopelyshev/2a75479075286deb8ee5dc1fb2e07f09\n\t*/\n    //!!!!!!!!!!!!!!!!!!!!!!!!\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    float k2u = cross2d( e, g );\n    float k1u = cross2d( e, f ) + cross2d( g, h );\n    float k0u = cross2d( h, f);    \n   \n    float v1, u1, v2, u2;\n    \n\n    float w = k1*k1 - 4.0*k0*k2;\n\n    //if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n\n    v1 = (-k1 - w)/(2.0*k2);    \n    u1 = (-k1u - w)/(2.0*k2u);        \n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    if(  b1/* && !b2 */) \n        return vec2( u1, v1 );\n    \n    v2 = (-k1 + w)/(2.0*k2);\n    u2 = (-k1u + w)/(2.0*k2u);\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;        \n    if( /*!b1 &&  */b2 ) \n        return vec2( u2, v2 )*.5;\n    \n    return vec2(-1.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n//added for dithering\nbool even(float a) { return fract(a/2.0) <= 0.5; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // background\n    vec3 bg = vec3(sin(iTime+(fragCoord.y * .01)),sin(3.0*iTime+2.0+(fragCoord.y * .01)),sin(5.0*iTime+4.0+(fragCoord.y * .01)));\n    vec3 col = bg;\n\n    \n    // move points\n    vec2 a = sin( 0.11*iTime + vec2(0.1,4.0) );\n    vec2 b = sin( 0.13*iTime + vec2(1.0,3.0) );\n    vec2 c = cos( 0.17*iTime + vec2(2.0,2.0) );\n    vec2 d = cos( 0.15*iTime + vec2(3.0,1.0) );\n\n    // area of the quad\n    vec2 uv = invBilinear( p, a, b, c, d );\n    if( uv.x>-0.5 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    \n    \n    //mesh or screen door or dithering like in many sega saturn games\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGczy.jpg", "access": "shaders20k", "license": "mit", "functions": [[1134, 1525, 1564, 1564, 1592], [1594, 1764, 1839, 2073, 2923], [2925, 2925, 2977, 2977, 3097], [3099, 3099, 3123, 3123, 3179], [3181, 3203, 3223, 3223, 3253], [3255, 3255, 3312, 3312, 4024]], "test": "error"}
{"id": "llGyRK", "name": "Shader #3", "author": "jkashimura", "description": "Hw #3", "tags": ["beginner"], "likes": 1, "viewed": 60, "published": "Public", "date": "1536877438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere - Signed Distance Function\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n\n\n// Locate objects\nfloat map(vec3 p)\n{    \n    // Sphere radius\n    float sphereSize = 0.7;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p*sin(iTime)) * cos(iTime);\n    \n     int tx = int(q.x);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\tfft *= 5.;\n    // Signed distance of sphere\n    float s = sphere(q, sphereSize);\n    \n    float d = 0.1 * (cos(q.x*5.*fft) * cos(q.y*5.*fft) * cos(q.z*5.*fft) );\n    //return s +wave;\n    return s+d;\n}\n\n\n// Trace rays\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0; // Distance Traveled\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p); // Locate object\n        t += d * cos(iTime)*10.; // Step along the ray\n    }\n    return t; \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(tan(iTime), cos(iTime*0.4), -sin(iTime)+3.);\n  \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n\n   \t// Create ray to fire into scene\n   \tvec3 ray = normalize(vec3(uv, 1.0));\n    \n    // Create origin of scene\n    vec3 origin = vec3(0., 0.,iTime);\n   \n    \n    // Trace any objects in the scene\n    float t = trace(origin*cos(iTime), ray*-sin(iTime));\n    \n    t += smoothstep(-sin(iTime),-tan(iTime),cos(iTime));\n    \n    // Generate fog based on distance from t\n    float fog = 10. / (1.0 + t * t * 0.3);\n    float expFog = 2.0 / (t*t*0.1);\n    // Final color with includes sdf + fog\n    vec3 fc = vec3(expFog*7.);\n     //vec3 fc = vec3(expFog*7.,iTime/uv.xy-vec2(-cos(iTime),0));\n\t\n    //fc /= cos(log(color*fft)*0.5);\n    fc -= tan(color);\n    // Output to screen\n    fragColor = vec4(-tan(fc*0.7)+-sin(fc*0.7),cos(fc*0.3));\n}\n\n\n\n\n\n\n\n", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 72, 72, 103], [108, 126, 145, 170, 595], [598, 612, 647, 647, 874], [878, 878, 935, 985, 1933]], "test": "error"}
{"id": "llGyRt", "name": "pulsating circle", "author": "elianaPerez", "description": "blah", "tags": ["circ"], "likes": 1, "viewed": 83, "published": "Public", "date": "1537297942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 pos = vec2 (.5, .5);\nfloat radius = .125;\nfloat freq = 3.0;\nfloat amp = .3;\nfloat change = .5;\nvec4 newColor = vec4(.5, 0.0, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio =iResolution.y / iResolution.x;\n    uv.y = uv.y * aspectRatio;\n    pos.y *= aspectRatio;\n    \n    float colorVal = abs(sin(iTime*freq) * change);\n    \n    \n    newColor +=vec4(colorVal, colorVal, colorVal, 0.0);\n    \n    \n    \n    pos.y += sin(iTime* freq) * amp;\n    \n    if(length(pos - uv) < radius)\n    {\n        fragColor = newColor;\n    }\n\telse\n\t{\n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 199, 249, 715]], "test": "valid"}
{"id": "llGyzG", "name": "Capsule - occlusion", "author": "iq", "description": "Fake occlusion from an ellipsoids (into any surface)", "tags": ["3d", "occlusion", "capsule"], "likes": 16, "viewed": 933, "published": "Public API", "date": "1536740318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Fake occlusion from a capsule into arbitrary surfaces.\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n\n// Other shaders with analytical occlusion or approximations:\n// \n// Box:                        https://www.shadertoy.com/view/4djXDy\n// Box with horizon clipping:  https://www.shadertoy.com/view/4sSXDV\n// Triangle:                   https://www.shadertoy.com/view/XdjSDy\n// Sphere:                     https://www.shadertoy.com/view/4djSDy\n// Ellipsoid (approximation):  https://www.shadertoy.com/view/MlsSzn\n// Capsule (approximation):    https://www.shadertoy.com/view/llGyzG\n\n\n\n// define this to compare to grount truth\n//#define SHOW_REAL_OCCLUSION\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r )\n{\n    // closest sphere\n    vec3  ba = b - a, pa = p - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    vec3  d = pa - h*ba;\n    float l = length(d);\n    float o = dot(-d,n)*r*r/(l*l*l); // occlusion of closest sphere\n    o *= 1.0 + r*(l-r)/(l*l);  // multiplier\n    return clamp(1.0-o,0.0,1.0);\n}\n\n\n// intersect capsule\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.5, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n        vec4 rrr = texture( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n\n        vec3  capA = vec3(0.0,0.3,0.0) + vec3(0.5,0.15,0.5)*cos( iTime*1.1 + vec3(0.0,1.0,4.0) );\n        vec3  capB = vec3(0.0,0.3,0.0) + vec3(0.5,0.15,0.5)*cos( iTime*1.7 + vec3(2.0,5.0,3.0) );\n        const float capR = 0.15;\n        \n    \tvec3 col = vec3(0.0);\n\n        const vec3 lig = normalize(vec3(-0.8,0.8,0.2));\n    \n        // capsule\n        float tmin = 1e20;\n        float occ = 1.0;\n        vec3 nor;\n    \n        {\n            float t = capIntersect( ro, rd, capA, capB, capR );\n            if( t>0.0 )\n            {\n                tmin = t;\n                vec3 pos = ro + t*rd;\n                nor = capNormal(pos, capA, capB, capR );\n                col = vec3( 0.5 + 0.5*nor.y );\n            }\n        }\n        // plane (floor)\n        {\n            float t = (-0.0-ro.y)/rd.y;\n            if( t>0.0 && t<tmin )\n            {\n                tmin = t;\n                vec3 pos = ro + t*rd;\n                nor = vec3(0.0,1.0,0.0);\n                \n                #ifndef SHOW_REAL_OCCLUSION    \n                \n                occ = capOcclusion( pos, nor, capA, capB, capR ); \n                \n                #else\n                vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n                vec3  rv  = normalize( cross( ru, nor ) );\n    \n                occ = 0.0;\n                for( int i=0; i<256; i++ )\n                {\n                    vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                    float ra = sqrt(aa.y);\n                    float rx = ra*cos(6.2831*aa.x); \n                    float ry = ra*sin(6.2831*aa.x);\n                    float rz = sqrt( 1.0-aa.y );\n                    vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                    float res = capIntersect( pos, dir, capA, capB, capR );\n                    occ += step(0.0,res);\n                }\n                occ = 1.0 - occ/256.0;\n                #endif\n    \n                col = vec3(occ);\n            }\n        }\n\t\n        col = sqrt( col );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGyzG.jpg", "access": "shaders20k", "license": "mit", "functions": [[1980, 1998, 2076, 2098, 2382], [2385, 2406, 2488, 2488, 3219], [3221, 3239, 3304, 3304, 3430], [3434, 3434, 3457, 3457, 3527], [3544, 3544, 3601, 3626, 6537]], "test": "error"}
{"id": "llKcDc", "name": "Visions", "author": "Simplyfire", "description": "Experimenting with shaping functions", "tags": ["distance", "trippy", "symmetry", "mandala"], "likes": 3, "viewed": 470, "published": "Public", "date": "1538046090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision highp float;\n#endif\n\n#define pi 3.14159265359\n\nvec3 hsb2rgb( in vec3 c){\n vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n rgb = rgb*rgb*(3.0-2.0*rgb);  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 rect(vec2 uv, vec2 c, vec2 s, vec2 off){\n  float p = max(smoothstep(c.x+s.x,c.x+s.x+off.x, uv.x), smoothstep(c.y+s.y,c.y+s.y+off.y,uv.y));\n  float q = max(smoothstep(c.x-s.x,c.x-s.x-off.x, uv.x), smoothstep(c.y-s.y,c.y-s.y-off.y,uv.y));\n  return vec3(1.-max(p,q));\n}\n\nfloat map(float x, float a1, float a2, float b1, float b2){\n  return b1 + (b2-b1) * (x-a1) / (a2-a1);\n}\n\nvec3 ellipse(vec2 uv, vec2 c, float r){\n  float d = distance(uv,c);\n  return vec3(1.-smoothstep(r, r+0.08, d));\n}\n\nvec3 shape(vec2 st, int N, float scl, float smth, float rot){\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+pi+iTime*rot;\n  float r = pi*2./float(N);\n  // Shaping function that modulate the distance\n  float d = cos(floor(.5+a/r)*r-a)*length(st*2.)/scl;\n  return vec3(1.0-smoothstep(r,r+smth,d));\n}\n\nfloat maxrect(vec2 uv, vec2 c){\n\treturn max(abs(c.x-uv.x), abs(c.y-uv.y));\n}\n\nfloat minrect(vec2 uv, vec2 c){\n\treturn min(abs(c.x-uv.x), abs(c.y-uv.y));\n}\n\nfloat dist(vec2 uv, vec2 c){\n\treturn distance(uv,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 c = vec2(.5);\n    float d0 = dist(uv, c);\n    float d1 = maxrect(uv, c);\n    float d2 = minrect(uv, c);\n    vec3 color = vec3(0.,0.,1.);\n    float v = .5+.5*sin(d1/d0/d2*10.-(t*5.));\n    color.r = .5+v;\n    color.g = 1.;\n    color.b -= d0+v;\n    fragColor = vec4(hsb2rgb(color),1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 192, 192, 344], [346, 346, 391, 391, 617], [619, 619, 678, 678, 722], [724, 724, 763, 763, 837], [839, 839, 900, 934, 1215], [1217, 1217, 1248, 1248, 1293], [1295, 1295, 1326, 1326, 1371], [1373, 1373, 1401, 1401, 1427], [1429, 1429, 1486, 1486, 1849]], "test": "valid"}
{"id": "llKcR3", "name": "Football", "author": "CLPB", "description": "Some solid modelling practice.", "tags": ["3d"], "likes": 9, "viewed": 625, "published": "Public API", "date": "1537283657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modified from https://www.shadertoy.com/view/Xds3zN by iq.\n\n// Face coloring was a little more complicated than expected, \n// so I'm leaving the pentagons colored as circles for now.\n\n#define AA 1\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat lpnorm(vec3 p, float s){\n    return pow(\n        (\n         pow(abs(p.x),s)+\n         pow(abs(p.y),s)+\n         pow(abs(p.z),s)), \n        1.0/s);\n}\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\n// HG_SDF Icosahedron but truncated and rounded\n// Optimized by iq (see comments)\nvec2 football(vec3 p, float s)\n{\n    float d = 0.0;\n    float M = 2.5;\n    \n    p = abs(p);\n    \n    d = max(d, dot(p, normalize(vec3(1.0,1,1))));\n    d = max(d, dot(p, normalize(vec3(0,1,PHI+1.))));\n    d = max(d, dot(p, normalize(vec3(PHI+1.,0,1))));\n    d = max(d, dot(p, normalize(vec3(1,PHI+1.,0))));\n    \n    // Truncation\n    // FIXME: planarity not maintained when projecting M onto rounded surface.\n    //        May have to defer this to the material stage?\n    float si = s*.04;\n    \n    float rnd = length(p);\n    float rdg = 0.35;\n    float ort = 0.49;\n    \n    float dprod = dot( p, normalize(vec3(PHI+1.0,PHI,0) ) );\n    d = max(d, dprod - si);\n    M = dprod>ort?3.5:M;\n    dprod = dot(p, normalize(vec3(0,PHI,1.0)) );\n    d = max(d, dprod - si);\n    M = dprod>ort?3.5:M;\n    dprod = dot(p, normalize(vec3(1.0,0,PHI)) );\n    d = max(d, dprod -si);\n    M = dprod>ort?3.5:M;\n    \n    //return vec2(d-s+abs(d-rnd)*1.5, M);\n    return vec2(d-s+pow(abs(d-rnd)*8.0,2.0)*rdg, M);\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// http://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 axis2quat(vec3 a, float angle){\n    float hlf = (angle * 0.5) * 3.14159 / 180.0;\n    return vec4(\n    \ta.x * sin(hlf),\n        a.y * sin(hlf),\n        a.z * sin(hlf),\n        cos(hlf)\n    );\n}\n\nvec4 quat_conj(vec4 q){\n    return vec4(-q.x,-q.y,-q.z, q.w);\n}\n\nvec4 quat_mul(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\n//------------------------------------------------------------------\n\nvec3 fbpos(){\n    return vec3(sin(iTime*.8)*1.5,\n                        abs(sin(iTime*3.1))*.7+.5,\n                        0.0);\n}\n\n/*\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528); // pi/5: cos, sin, tan\n\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    \n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\nfloat sdPenta(vec3 p){\n    p.x += sin(70.0);\n    p.z += cos(30.0);\n    float d = sdPentagon(p.xz, 0.1);\n    return d;\n}*/\n\nvec2 map_shapes( vec3 pos ) {\n    \n    vec3 p = pos - fbpos();\n    \n    vec4 qr = axis2quat(normalize(vec3(cos(iTime+PHI),0.0,sin(iTime+PHI))), mod(-iTime,1000.0)*150.0);\n    vec4 qr_conj = quat_conj(qr);\n    vec4 q_pos = vec4(p.xyz, 0.0);\n    \n    qr = quat_mul(quat_mul(qr, q_pos), qr_conj);\n    vec3 q = vec3(qr.x, qr.y, qr.z);\n    \n    vec2 res = football(\n        q, .5);\n    \n    //res = opU(res, vec2(sdPenta(p)));\n    \n    return res;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(pos), 1.0 );\n    \n    res = opU(res, map_shapes(pos));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 30.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<80; i++ )\n    {\n\t    float precis = 0.0001*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*.7;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 1.2*pos.xz+iTime*3.0 );\n            col = 0.3 + f*vec3(0.3);\n        }\n        if (m >= 2.0 ){\n            col = vec3(0.6);\n        }\n        if (m >= 3.0){\n            col = vec3(0.07);\n        }\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.2, 0.7, 0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.20*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.35*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), \n                       2.0 + 2.0*mo.y, \n                       0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3(0.0, 0.7, 0.0);\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy, 2.5) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 271, 296, 296, 311], [313, 313, 343, 343, 467], [557, 639, 671, 671, 1628], [1630, 1700, 1730, 1730, 1763], [1765, 1848, 1884, 1884, 2045], [2047, 2047, 2070, 2070, 2110], [2112, 2112, 2145, 2145, 2460], [2462, 2532, 2545, 2545, 2663], [2665, 3151, 3180, 3180, 3595], [3597, 3597, 3622, 3622, 3729], [3731, 3731, 3771, 3771, 4101], [4104, 4104, 4182, 4182, 4444], [4446, 4446, 4478, 4478, 4686], [4688, 4688, 4730, 4730, 5029], [5031, 5107, 5143, 5164, 5387], [5389, 5389, 5428, 5428, 7264], [7266, 7266, 7318, 7318, 7495], [7497, 7497, 7554, 7554, 8568]], "test": "valid"}
{"id": "llKcRc", "name": "3 circles animation", "author": "averyfollett", "description": "3 animated circles, could be used as a loading animation", "tags": ["circle", "animation", "material"], "likes": 3, "viewed": 384, "published": "Public API", "date": "1537216303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 circlePos1 = vec2(0.3,0.5);\nvec2 circlePos2 = vec2(0.5,0.5);\nvec2 circlePos3 = vec2(0.7,0.5);\nfloat radius1 = 0.15;\nfloat radius2 = 0.15;\nfloat radius3 = 0.15;\nvec4 FG1 = vec4(0.301, 0.670, 0.960,1.0);\nvec4 FG2 = vec4(0.129, 0.588, 0.952,1.0);\nvec4 FG3 = vec4(0.090, 0.411, 0.666,1.0);\nvec4 BG = vec4(1.0,1.0,1.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n float aspectRatio = iResolution.y / iResolution.x;\n uv.y = uv.y * aspectRatio;\n \n circlePos1.y = circlePos1.y * aspectRatio;\n circlePos2.y = circlePos2.y * aspectRatio;\n circlePos3.y = circlePos3.y * aspectRatio;\n    \n circlePos1 += sin(iTime) * 0.1;\n radius2 += sin(iTime) * 0.05;\n circlePos3 -= sin(iTime) * 0.1;\n \n fragColor = mix(FG3, BG, smoothstep(radius3 - 2e-3, radius3, length(circlePos3 - uv)));\n fragColor = mix(FG2, fragColor, smoothstep(radius2 - 2e-3, radius2, length(circlePos2 - uv)));\n fragColor = mix(FG1, fragColor, smoothstep(radius1 - 2e-3, radius1, length(circlePos1 - uv)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKcRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[325, 325, 382, 382, 1025]], "test": "valid"}
{"id": "llVczG", "name": "bubbles or what?", "author": "reven86", "description": "Cells or bubbles, I dunno.", "tags": ["voronoi", "worley"], "likes": 1, "viewed": 193, "published": "Public", "date": "1536825841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// modification of https://www.shadertoy.com/view/MstGRl\n\n\n// Determines how many cells there are\n#define NUM_CELLS 16.0\n\n// Arbitrary random, can be replaced with a function of your choice\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 463.5453);\n}\n\n// Returns the point in a given cell\nvec2 get_cell_point(ivec2 cell) {\n\tvec2 center = vec2(0.5, 0.5f * iResolution.y / iResolution.x);\n\tvec2 cell_base = vec2(cell);\n    float d = length(cell_base - center * NUM_CELLS);\n    cell_base /= NUM_CELLS;\n\tfloat noise_x = rand(vec2(cell) + d * vec2(0.0, (iTime * 0.25)* 0.00001));\n    float noise_y = rand(vec2(cell.yx) +  d * vec2(0.0, (iTime * 0.15)* 0.00001));\n    return cell_base + (0.5 + 1.5 * vec2(noise_x, noise_y)) / NUM_CELLS;\n}\n\n// Performs worley noise by checking all adjacent cells\n// and comparing the distance to their points\nfloat worley(vec2 coord) {\n\tvec2 center = vec2(0.5, 0.5f * iResolution.y / iResolution.x);\n    ivec2 cell = ivec2(coord * NUM_CELLS);\n    float dist = 1.0;\n    float dist2 = 1.0;\n    \n    // Search in the surrounding 5x5 cell block\n    for (int x = 0; x < 5; x++) { \n        for (int y = 0; y < 5; y++) {\n        \tvec2 cell_point = get_cell_point(cell + ivec2(x-2, y-2)) - coord;\n            float lenSq = dot(cell_point, cell_point);\n            dist = min(dist, lenSq);\n            dist2 = min(dist2, sqrt(lenSq));\n        }\n    }\n        \n    dist *= NUM_CELLS * NUM_CELLS;// * 0.707;\n    dist2 *= NUM_CELLS;\n    dist2 = max(0.6, dist2);\n    \n    dist += dist2;\n            \n    coord = 2.0 * (coord - center);\n    float t = 1.0 - dot(coord, coord);\n    dist *= t * t;\n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n\tfragColor = vec4(worley(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 190, 210, 210, 280], [282, 319, 352, 352, 762], [764, 866, 892, 892, 1656], [1659, 1659, 1716, 1716, 1834]], "test": "valid"}
{"id": "llVyWt", "name": "ts-template", "author": "teraspora", "description": "This shader  is fundamentally a template for slotting shader code into.\nYou get normalised coordinates, borders and tiling for free.\n", "tags": ["template"], "likes": 5, "viewed": 162, "published": "Public", "date": "1538197226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ts-template - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Date: 29 SEP 2018.\n\n// NOTE: This shader  is fundamentally a template for slotting shader code into.\n// You get normalised coordinates, borders and tiling.\n\n// It contains a number of functions not currently used;\n// they are there for ease of adaptation and in the spirit of FOSS;\n// also because I am passionate about discovering, inventing and\n// adapting ideas which I can fashion into useful tools and \n// so am startng to build up a toolset I can use intuitively.\n\n// I want to have them always available, so I am (for now, anyway) building every\n// shader in this template, in which I have to an extent factored out the\n// tiling code and border code into separate functions.\n\n// -----------------------------------------------------------------------------\n\n// Copyright  2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// -----------------------------------------------------------------------------\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\nconst float HALF_PI = 1.5707963267948966;\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\nfloat tileIndex;\n\n// My inline library of useful functions:\n\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n// =======================================\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 3.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    \n    \n    \n    // ===============================================================\n    \n    // Normalisation and tiling:\n    // ========================\n    \n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // Offset the start of each rendition:\n    float time = tile * 32. + iTime;\n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    float scaleFactor = 20.0 * nsin(time * 0.125);\n    q /= scaleFactor;\n    \n    // variation...\n    if (toe < 0.) {\n        q = q.yx;\n    }\n    if (tile == 1.) {\n    \tq = rotate(q, HALF_PI);\n    }\n    \n    // ===============================================================================================\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Main code for the shader goes here:\n    // ===============================================================================================\n    \n    vec3 col = vec3(0.);\n    if (tile == 4.) {\n        //q = mod(q, 0.333333333334);\n        time = sqrt(time);\n    }\n    q *= vec2(ncos(ncos(time)), nsin(ncos(time)));\n    col = vec3(nsin(time), nsin(length(q) * time * 25.), ncos(q.x + q.y));\n    if (tile == 4.) {\n    \tcol = col.brg;\n    }\n    \n    if (toe < 0.) {\n        col = col.bgr;    \t\n    }\n    \n    // ===============================================================================================\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Border code:    \n    // ===============================================================================================\n    \n    float borderWidth = 3.;\n    vec3 borderInsetLineColour = white;\n \t\n    col = drawBorder(col, borderWidth, borderInsetLineColour, pp, hr, tile);\n    // finally return the colour to caller(mainImage()):     \n    return col;\n}\t// END doStuff()\n    // ===============================================================================\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = doStuff(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}\n    \n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVyWt.jpg", "access": "shaders20k", "license": "mit", "functions": [[2766, 2975, 3000, 3000, 3158], [3160, 3224, 3248, 3301, 3584], [3586, 3621, 3645, 3645, 3765], [3767, 3802, 3826, 3826, 3978], [4041, 4085, 4104, 4104, 4133], [4135, 4135, 4167, 4167, 4214], [4216, 4216, 4244, 4244, 4309], [4311, 4311, 4343, 4343, 4384], [4386, 4386, 4405, 4405, 4423], [4425, 4425, 4442, 4442, 4460], [4462, 4462, 4481, 4481, 4499], [4501, 4501, 4522, 4522, 4550], [4552, 4552, 4573, 4573, 4601], [4603, 4603, 4625, 4625, 4659], [4661, 4661, 4692, 4692, 4764], [4766, 4766, 4807, 4807, 4846], [4848, 4848, 4863, 4863, 4901], [4902, 4946, 5035, 5271, 5808], [5810, 5827, 5863, 6069, 8880], [8881, 8987, 9044, 9044, 9336]], "test": "error"}
{"id": "llVyWw", "name": "10092018", "author": "edapx", "description": "noised st coords, mouse input", "tags": ["vectorfield"], "likes": 7, "viewed": 173, "published": "Public", "date": "1536616544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 vectorField(vec2 uv){\n  vec2 res = uv;\n  float n = noise(res*vec2(3.0));\n  res.y -= iTime*0.05;\n  res += sin(res.yx*40.) * 0.02;\n  res += vec2(n);\n  return res;\n}\n\nfloat plot(float val, float c, float t){\n  float l = smoothstep(c,c-t,val);\n  float r = smoothstep(c,c-t/5.,val);\n  return r-l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec4 m = iMouse / iResolution.xxxx;\n  vec2 st = fragCoord/iResolution.xy;\n  st.y *= iResolution.y / iResolution.x;\n  st = vectorField(st);\n\n  float cell = 0.2 + m.y*0.3;\n  vec2 modSt = mod(st, vec2(cell));\n\n  float x = plot(modSt.x, cell, 0.1);\n  float y = plot(modSt.y, cell, 0.1);\n    \n  vec3 bgCol = vec3(0.1,0.9,0.9);\n  vec3 col = vec3(0.9,0.5,0.03) * x;\n  col     += vec3(0.95,0.3,0.) * y;\n  col     += bgCol*vec3(smoothstep(1.7, .01,x+y));\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 40, 40, 157], [159, 246, 272, 272, 788], [790, 790, 816, 816, 957], [959, 959, 999, 999, 1088], [1090, 1090, 1146, 1146, 1626]], "test": "valid"}
{"id": "llycDD", "name": "bitwise", "author": "maeln", "description": "bitwise", "tags": ["bitwise"], "likes": 2, "viewed": 332, "published": "Public API", "date": "1536839223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float propx = iResolution.x/iResolution.y;\n    float cellx = floor(propx * 64.0);\n    \n    float propy = 1.0/propx;\n    float celly = floor(propy * 64.0);\n    \n    //int c1 = int(floor((uv.y*celly)) + floor(iTime * 4.0));\n    //int xo = c1 & 32;\n    \n    //int c2 = int(floor((uv.x*cellx)) + floor(iTime * 4.0));\n    //xo = (c2 & 1) >> (c1 & 8);\n    \n    \n    int counter1 = int(floor(iTime*14.0) \n                      - floor(uv.x * cellx) \n                      + floor(uv.y * celly)) \n                      & 23;\n    \n    int counter2 = int(floor(iTime*12.0) \n                      + floor(uv.x * cellx)) \n                      & 234;\n    \n    int counter3 = int(floor(uv.x * cellx)) \n        \t\t\t  & 234;\n    \n    int shift1 = (int(floor(uv.x * cellx) \n                     + floor(uv.y * celly))) \n        \t\t\t & 9;\n    \n    int shift2 = (int(floor(uv.x * cellx) \n                     - ceil(uv.y * celly))) \n        \t\t\t & 7;\n    \n    int on = (counter1 >> shift1) & 12;\n    int no = (counter2 << shift2) & 13;\n    int xo = no ^ on;\n    \n    xo = xo ^ counter3 & counter2;\n\t\n\n    fragColor = vec4(vec3(1.0-float(xo)),1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llycDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1235]], "test": "valid"}
{"id": "llycDV", "name": "over inverse kinematic", "author": "ollj", "description": "2 limb inverse kinematics is as simple as circleCircle intersection within rotation.\n\nif(mouse down) limb lengths are set by where you klicked. \ndrag mouse to place handTarget\n\nblue area shows what HandTargets are reachable by the current LimbLengths.\n", "tags": ["intersection", "circle", "ik", "robot", "inverse", "library", "kinematics", "arm"], "likes": 9, "viewed": 478, "published": "Public API", "date": "1537775803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n/* html boilerplate + canvas\n<html><style>body{padding:0;margin:0;position:absolute;width:100%;height:100%;}\n#ID{color:#000;top:0px;left:0px;position:absolute;;width:100%;height:100%}\n#IF{color:#FFF;top:0px;left:0px;position:absolute;pointer-events:none;text-shadow:0 0 9px #000;}\n</style><head></head><script>var w2,wMs=[\"experimental-webgl\",\"webgl\",\"webgl2\"]\n,wM=3//<---wM sets the webGL version,points at wMs[];[ wM=2 ] sets it to [version300es],(w2==true),\"webgl2\",all others are(w2==false)\n</script><script id=\"e\">\nuniform int iFrame;\nuniform float iTime;\nuniform vec3 iResolution;//.z is set to 1,initially for projection mapping (to project on house walls),later mostly for smaller shaders.\nuniform vec4 iMouse;\nuniform vec4 iDate;\nuniform sampler2D backbuffer;\n</script><script id=\"h\">\n//mousedown state fixed\nvec2 v1u;\n/**/\n\n\n\n//alphacompositing fixed\n//lacks root-solving shapes (parabola-ellipse)\n//canvas \"TinyBri300OHGDAPo14\"\n//lots of code from [inogo quilez] [mercury] [dr2] [David Hoskins]\n//has iFrame fixed\n//has unified smin() smooth-Boolean-fuzzy-logic variants\n//has complex 2d transforms (possibly buggy,checked as much as i care and know this stuff)\n//has some rgba-colorspace-gradients/indicators (but surely not all that i care for,cieluelch is missing)\n//has noise (upper ones are better for (hyperplanes of) less domains\n//- tri,which is food for very fast volumetric storms\n//- h41=[fastest fbm with normals],that is just fast fbm noise with (poorly estimated) 3d normals\n//- hfd=[hash(fract(dot()))],that does not use sin(fract(a)),by David Hopkins\n//- cel=cellular noise,parallelized/fast vorley noise with 2 shortest distances in 2d or 3d,with hash as additional static domain.\n//- s13=[simplex],highest quality/performance noise,generally too slow for 3d spheretracking (as displacement or heightmap)\n//- - lacks bayerMatrix,blueHash<-part of higher-domain content.\n//has DA derivative arithmetic\n//- has issues with Param2:\n//- - decapitated filling lists with zeroes,seems VERY nonsensical\n//- - DA mixing differs from MAT mixin,not just in structure.\n//- - ... previous DA shaders made the error od declaring DA-mixing as MAT-mixind with DA-parameters?\n//- - ... or was that just cases where MAT is identical to DA?\n//has alias-folds fixed,with mercury.sexy/hg_sdf\n//- are declared as defines,for\n//- - N-dimensional inputs,where that function still makes sense in higher dimensions\n//- - uses the same labels as DA,so depending on input it can also calculate derivatives\n//- Includes minified HG_SDF by Mercury mercury.sexy/hg_sdf\n//- omitted platonic solids because the original code uses arrays\n//- Some functions are converted to macros because they would be even smaller when preprocessed.\n//- Another macro,_M,is really filling up almost identical code as to make the result even smaller,\n\n//has AD=automatic Differentiation via chain rule but only demoes it in 1d\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n\n#define vec1 float\n#define norma normalize\n//#define ss smoothstep\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define cl(a,b,c) mi(ma(a,0.),1.)//till i define this for AD\n#define sat(x) cl(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define u5cos(a) u5(cos(a))\nstruct v11{vec1 a;vec1 b;};\nstruct v22{vec2 a;vec2 b;};\nstruct v33{vec3 a;vec3 b;};//for 2 domains(density/distance field)\nstruct v44{vec4 a;vec4 b;};\nstruct v444{vec4 a;vec4 b;vec4 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v333{vec3 a;vec3 b;vec3 c;};\nstruct v3333{vec3 a;vec3 b;vec3 c;vec3 d;};\nstruct v222{vec2 a;vec2 b;vec2 c;};\n//v222 g222(vec3 a,vec3 b){return v222(vec2(a.x,b.x),vec2(a.y,b.y),vec2(a.z,b.z));}\nv222 g222(v33 a){return v222(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv3333 muv(v3333 a,vec4 b){return v3333(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nvec4 ddv(v3333 a){return vec4(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD,wherelater spaces are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\nstruct DAm2{w13 x;w13 y;w13 z;};//for 3 domains (density/distance field) \nstruct DAm1{w12 x;w12 y;};//for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w11 x;};//for 2 domains (heightmap,isoline,contour)\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n\n\n\n\n\n\n\nw11 ma(w11 a,vec1 b){return w11(max(a.a,b),max(a.b,b));}\nw11 mi(w11 a,vec1 b){return w11(min(a.a,b),min(a.b,b));}\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define viewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/viewZoom)\n#define fra(u)(u-.5*iResolution.xy)*viewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n//DAm2 maxdm(DAm2 a,v2 p){return DAm2(maxd(a.a,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\n//DAm2 mindm(DAm2 a,v2 p){return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\n//DAm2 maxdm(DAm2 a,vec1 p){return maxdm(a,v2(p));}\n//DAm2 mindm(DAm2 a,vec1 p){return mindm(a,v2(p));}//needed for fast clamping\n//w13 maxdm(w13 a,w13 b,w13 c){return maxd(maxd(a,b),c);}\n//w13 maxdm(DAm2 a){return maxdm(a.a,a.y,a.z);}\n//The 3(or 2)dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN p)]:\n//where N=number of domains,range [0..3]\nv444 da_domain(vec3 p){return v444(vec4(p.x,1,0,0),vec4(p.y,0,1,0),vec4(p.z,0,0,1));}\nv33 da_domain(vec2 p){return v33(vec3(p.x,1,0),vec3(p.y,0,1));}\nvec2 da_domain(vec1 p){return vec2(p,1);}//for 1 domain(linear equation)\n//vNN() declares c11() c22() c33() c44()... for implicit typecasting into structs; v11 v22 v33 v44\nv11 c11(vec1 a,vec1 b){return v11(a,b);}\nv11 c11(vec1 a){return v11(a,a);}\n#define vNNv(z,x) {return z(x(a),x(b));}\n#define vNNu(z,x,y) z x(vec1 a,y b)vNNv(z,y) z x(y a,vec1 b)vNNv(z,y) z x(vec1 a,vec1 b)vNNv(z,y)\n#define vNN(z,y,x) vNNu(z,y,x) z y(x a,x b){return z(a,b);} z y(x a){return z(a,a);}\nvNN(v22,c22,vec2)\nvNN(v33,c33,vec3)\nvNN(v44,c44,vec4)\n\n\n//param1MAT dreaming of vec5 and vec2x2,also,this keeps define-namespace unused,by declating function sets!\n//lets me type \" a=min(vec3(a),float(b)) a=pow(vec3(a),float(b)) \" with less explicit typecasting and shorter aliases:\n//negate,reciprocal,abs,log,sin,asin,cos,acos,tan,atan,fract,floor\n#define NE(y,z) z ne(z a){return -a;}y ne(y a){return y(-a.a,-a.b);}\nNE(v11,vec1)NE(v22,vec2)NE(v33,vec3)NE(v44,vec4)\nw13 ne(w13 a){return w13(-a.a,-a.b);}\nw12 ne(w12 a){return w12(-a.a,-a.b);}\nw11 ne(w11 a){return w11(-a.a,-a.b);}\n#define def1E(z,y,x) x z(x a){return y(a);}\n#define def1(a,b) def1E(a,b,vec1) def1E(a,b,vec2) def1E(a,b,vec3) def1E(a,b,vec4)\n#define re(a) di(1.,b)\ndef1(ab,abs)def1(sg,sign)def1(sq,sqrt)\ndef1(ln,log)def1(ex,exp)\ndef1(si,sin)def1(asi,asin)\ndef1(co,cos)def1(aco,acos)\ndef1(ta,tan)def1(ata,atan)\ndef1(fr,fract)\ndef1(fl,floor)\n//----param2MAT\n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(ne(a)))\n#define def2U(z,y,x) x z(vec1 a,x b){return y(x(a),b);} x z(x a,vec1 b){return y(a,x(b));}\n#define def2E(z,y,x) x z(x a,x b){return y(a,b);}\n#define def2(a,b) def2E(a,b,vec1) def2E(a,b,vec2) def2E(a,b,vec3) def2E(a,b,vec4)\n#define defU(a,b) def2(a,b) def2U(a,b,vec2) def2U(a,b,vec3) def2U(a,b,vec4)\n#define sub(a,b) ((a)-(b))\n#define add(a,b) ((a)+(b))//sub(a,ne(b))\n#define div(a,b) ((a)/(b))\n#define mul(a,b) ((a)*(b)) //di(a,re(b)) reciprocal define may lose time&precision\n//a lot of these just reserve namespaces //dot() is special for folding to a vec1 uses defD()\n#define def2D(z,y,x) vec1 z(vec1 a,x b){return y(x(a),b);} vec1 z(x a,vec1 b){return y(a,x(b));}\n#define def2F(z,y,x) vec1 z(x a,x b){return y(a,b);}\n#define defF(a,b) def2F(a,b,vec1) def2F(a,b,vec2) def2F(a,b,vec3) def2F(a,b,vec4)\n#define defD(a,b) defF(a,b) def2D(a,b,vec2) def2D(a,b,vec3) def2D(a,b,vec4)\n//vNN operands foldlike this:\n#define vXX(z,y) z(y(a.a,b),y(a.b,b))\n#define vXY(z,y) z(y(a.a,b.a),y(a.b,b.a))\n#define vvZ(z,w,v,y) w z(w a,v b){return y(w,z);}w z(w a,vec1 b){return y(w,z);}w z(v11 a,v b){return y(w,z);}\n#define vvY(z,w,v,y) w z(w a,v b){return y(w,z);}w z(v a,w b){return y(w,z);}w z(w a,w b){return y(w,z);}\n#define vvX(y,w,v) vvZ(y,w,v,vXX) vvY(y,w,v11,vXY)\n#define vMM(z) vvX(z,v22,vec2)vvX(z,v33,vec3)vvX(z,v44,vec4)v11 z(v11 a,v11 b){return vXY(v11,z);}v11 z(v11 a,vec1 b){return vXX(v11,z);}\n//alias2_NinputAsVec; due to symmetrically defined alising,in favor of min() max() functions (previously called miv() mav()):\n//note that dt(vec4 a)==dot(dot(a.x,a.y),dot(a.z,a.w)),equivalent to ad(vec4 a)\n//note that po(vec4 a)==pow(pow(a.x,a.y),pow(a.z,a.w)),which is quite silly\n//note that su(vec4 a)==(a.x-a.y)-(a.z-a.w)=a.x+a.w-a.y-a.z=a.x+a.w-(a.y+a.z)\n//note that di(vec4 a)==(a.x/a.y)/(a.z/a.w)=a.x*a.w/a.y/a.z=a.x*a.w-(a.y*a.z)\n//alternatively fo() couls also be defined as dot(a,1.),where parts of a are negated or reciprocal\n#define Fo1(u,t) vec1 u(t a){return u(a.x,a.y);}\n#define Fo2(u,t) vec1 u(t a){return u(u(a.xy),a.z);}\n#define Fo3(u,t) vec1 u(t a){return u(u(a.xy),u(a.zw));}\n#define Fon(u) Fo1(u,vec2) Fo2(u,vec3) Fo3(u,vec4)\n#define defM(a,b) defU(a,b) vMM(a) Fon(a)\ndefM(po,pow)\ndefM(mi,min)defM(ma,max)\ndefM(su,sub)defM(di,div)\ndefM(ad,add)defM(mu,mul)\ndefM(mo,mod)\ndefM(st,step)\n//higher domains for high-domain-permutations/zOrder/Noise\n//v33 su(vec3 a,v33 b){return v33(a-b.a,a-b.b);}\nv33 g33(vec2 a){return v33(vec3(a.x),vec3(a.y));}\nv333 su(vec3 a,v333 b){return v333(a-b.a,a-b.b,a-b.c);}\nv333 g333(v33 a,vec3 b){return v333(a.a,a.b,b);}\nv3333 g3333(vec3 a,v333 b){return v3333(a,b.a,b.b,b.c);}\nv44 fl(v44 a){return v44(fl(a.a),fl(a.b));}\nv44 fr(v44 a){return v44(fr(a.a),fr(a.b));}\n//polar Complex dot()\nconst vec3 vs=vec3(-1,0,1);\n#define le(a) sq(dd(a))\ndefD(dt,dot)\n#define dd(a) dot(a,a)\n//vMM(dt)//breaks a pattern,due to being a foldingprojection\nFon(dt)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n//\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(vec1 a){return cs(vec2(a,a));}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)-(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(vec1 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(vec1 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n\n\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(le(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 sqc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}//vec2 po2c(vec2 a){return muc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nvec2 lgc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 lgc(vec4 a){return vec4(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nvec2 suc(vec2 a,vec2 b){return a-b;}vec2 adc(vec2 a,vec2 b){return a+b;}///complex addition is trivial\nvec2 muc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 muc(vec2 a,vec2 b,vec2 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 muc(vec4 a){return muc(a.xy,a.zw);}//parallel mult\nvec2 dic(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nvec2 lgc(vec2 a,vec2 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 lgc(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nvec2 exc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//vec2 lgc(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 poc(vec2 a,vec2 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 poc(vec2 w,vec2 z,float c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nvec2 lgc(vec2 a,vec2 b,float c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nvec2 wrtc(vec2 a,vec2 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtc(vec2 a,vec2 b,float c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//vec2 sqc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\nvec2 sic(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sic(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sic(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 coc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n\n//obsoleted vec2 coc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 coc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tac(vec2 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nvec2 cotc(vec2 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sihc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 cohc(vec2 z){return coc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 vec2 tahc(vec2 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 vec2 cothc(vec2 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(vec2 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 vec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nvec2 arsic(vec2 z){return c2(lgc(perp(z)+sqc(c2(po2c(z.yx)))+vec2(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsic(vec2 z){vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcoc(vec2 z){return-c2(lgc(z+c2(sqc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcoc(vec2 z){ vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=lgc(vec2(p+q-z.y,-z.x)/r);vec2 b=lgc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nvec2 artac(vec2 z){return sub2(c4(lgc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artac(vec2 z){ vec2 a=lgc(vec2(1.0+z.y,-z.x));vec2 b=lgc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(sub2(c4(vec4(z,sqc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=su(u);return lgc(c2(z)+sqc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r+p-q,-2.0*z.x*z.y));a=lgc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return lgc(z+sqc(po2c(z)+vec2(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return lgc(z+muc(sqc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-su(z*z);z*=2.;return .5*lgc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return lgc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return lgc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=su(z*z);return lgc(c2(z)+muc(sqc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n\n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a\n ;}\n \n//---param3MAT\n//SF3() is a hot mess to be simplified a lot! //only allows for vec1 ot vecmax\n//explicit namespace fold for scalar operations\n#define fi3(m,z,a,b,c) {return z(m(a),m(b),m(c));}\n#define Q3(z,a,b,c){return z(a,b,c);}\n#define SF3(n,y,z,a,b,c) n y(n a,n b,n c)fi3(n,z,a,b,c) n y(n a,n b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,n b,n c)fi3(n,z,a,b,c) n y(vec1 a,n b,vec1 c)fi3(n,z,a,b,c)\n#define scalar3(y,z) vec1 y(vec1 a,vec1 b,vec1 c)Q3(z,a,b,c) SF3(vec2,y,z,a,b,c) SF3(vec3,y,z,a,b,c) SF3(vec4,y,z,a,b,c)\nscalar3(mx,mix)\n//---param1AD Automatic Differenciation (needs param2MAT)\n//todo AD for;tan,asin,acos,atan,reciprocal\n//memo museum: for consistency structure changed: d->v00->v11;d1->v01->w12;d2->v02->w13\n//...the swivels oof d; are .xd ,the swivels of v0N (and [w*]) are .ab\nvec1 rec(float a){return(a==0.)?a:1./a;}//return [1/a] ,work safe//sqrt()and divisions require a worksave reciprocal operator:\n#define sqD(h)h sq(h a){vec1 q=sq(a.a);return h(q,.5*rec(q)*a.b);}\n#define cmD(h,i) h cmd(w11 a,i b){return h(a.a,mu(a.b,b));}\ncmD(w11,vec1)cmD(w12,vec2)cmD(w13,vec3)cmD(w14,vec4)//cmd() is special case of component-wise-multiplication,special because a.x==1: is subroutine of abs()\n//i am not too sure about my implementation on fr();\n//the hell,just use mo()instead,mo()has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)-=.0)\nvec1 jud(vec1 a){return mx(a,-1.,st(fr(a),0.)*st(0.,fract(a)));}\nvec2 jud(vec2 a){return vec2(jud(a.x),jud(a.y));}\nvec3 jud(vec3 a){return vec3(jud(a.x),jud(a.y),jud(a.z));}\nvec4 jud(vec4 a){return vec4(jud(a.x),jud(a.y),jud(a.z),jud(a.w));}\n//i should definitely define this by fract,and not by floor.\n//because fm-modulation taught me that i need fract()a lot more than floor()\n#define frD(h)h fr(h a){return h(fl(a.a),jud(a.b));}\n#define abD(h)h ab(h a){return cmd(w11(ab(a.a),sg(a.a)),a.b);}//w13(abs(a.x),sign(a.x)*a.d);}\n#define siD(h)h si(h a){return h(si(a.a),mu(co(a.a),a.b));}\n#define coD(h)h co(h a){return h(co(a.a),mu(ne(si(a.a)),a.b));}\n#define lgD(h)h ln(h a){return h(ln(a.a),di(a.b,a.a));}\n#define exD(h)h ex(h a){vec1 x=exp(a.a);return h(x,x*a.b);}\n#define DA1(h)h(w11)h(w12)h(w13)h(w14)\nDA1(abD)DA1(siD)DA1(coD)DA1(lgD)DA1(exD)DA1(sqD)DA1(frD)//because different functions have unique derivatives,\n//fl(a)=a-fr(a); hasvery slightly lower precision?rarely relevant.fract()has great precision on float!\n#define fl(a) su(a,fr(a))\n//---Param2AD are trickier: https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mo()mx()mi()ma()\n//AD_mo() ideally should be replaced by fr(),but that adds 1dvd()and 1mu(),BUT DA_mo(a,b) outperforms mu(fr(di(a,b)),b),via [reciprocal product rule]\n#define moD(h,i)h mo(h a,i b){return h(mo(a.a,b  ),fr(a.b));}\n#define moE(h,i)h mo(h a,i b){return h(mo(a.a,b.a),fr(a.b));}\n#define moF(h,i)h(w11,i)h(w12,i)h(w13,i)h(w14,i)\nmoF(moD,vec1)moF(moE,w11)\n#define miG(r,h,j) r mo(h a,r b){return r(mod(a.a,b.a),j(0));}\nmiG(w14,w13,vec4)miG(w14,w12,vec4)miG(w14,w11,vec4)miG(w13,w11,vec3)miG(w13,w12,vec3)\nw13 mo(vec1 a,w13 b){return w13(mod(a,b.a),vec3(0));}\nw12 mo(vec1 a,w12 b){return w12(mod(a,b.a),vec2(0));}\nw11 mo(vec1 a,w11 b){return w11(mod(a,b.a),0.);}\n//substraction is simple,because \"differentiation is integration\"; https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for; https://en.wikipedia.org/wiki/Translation_(geometry)\n//BUT if we substract a struct da from a vec1 or w11,we must negate the .b part.\n//i possibly messed this one up by not flipping the .a part,but i an not sure there.\n#define suNN(h,i,j)h su(i a,j b){return h(su(a.a,b.a),a.b);}h su(j a,i b){return h(su(a.a,b.a),-b.b);}\nsuNN(w12,w12,w11)suNN(w13,w13,w11)suNN(w13,w13,w12)//the leftmost param equals the larger param of the other 2 params\nsuNN(w14,w14,w11)suNN(w14,w14,w12)suNN(w14,w14,w13)//..the rightmost param is always smaller than the middle param\n#define suNM(t)t su(t a,vec1 b){return t(su(a.a,b),a.b);}t su(vec1 a,t b){return t(su(a,b.a),-b.b);}\n#define suMM(t)suNM(t)t su(t a,t b){return t(su(a.a,b.a),su(a.b,b.b));}\nsuMM(w11)suMM(w12)suMM(w13)suMM(w14)\n//in the end mix() has an identity,and that identity does translate into DA:\n#define mixd(a,b,c) ad(mu(c,su(a,b),a)\n//a big issue of this is that mixd() and mind() where defined as MAT-functions,vut using the AD-labeling\n//so is just deleted that junk code\n//I define mind()and=maxd(-,-)instead of maxd()and=mind(-,-)\n//because min()is far more common than max(),for z-buffering.\n//negation identity:max(a,b)--min(-a,-b),requires struct negation\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n//AD_mu simplifies contextually ,scalar multiplication is tautological product_rule.\n#define adM2(h) h mu(h a,vec1 b){return h(mu(a.a,b),mu(a.b,b));}\n#define adM1(h) adM2(h)h mu(vec1 a,h b){return mu(b,a);}\n#define atta(h,i,j) h mu(i a,j b){return h(mu(a.a,b.a),ad(mu(a.b,b.a),mu(a.a,b.b)));}\n#define attA(h) atta(h,h,w11)atta(h,h,h)atta(h,w11,h)\nadM1(w11)adM1(w12)adM1(w13)adM1(w14)\natta(w11,w11,w11)attA(w12)attA(w13)attA(w14)//oh i really like this attA()-way of folding it\nDAm2 mu(DAm2 p,vec3 s){return DAm2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nDAm1 mu(DAm1 p,vec2 s){return DAm1(mu(p.x,s.x),mu(p.y,s.y));}\nDAm0 mu(DAm0 p,vec1 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define rXX(h) h di(h a,vec1 b){return h(di(a.a,b),di(a.b,b));}h di(vec1 a,h b){return h(di(a,b.a),di((mu(ne(a),b.b)),mu(b.a,b.a)));}\nrXX(w11)rXX(w12)rXX(w13)rXX(w14)\n//inverse scalar multiplication is a tautolotgy.\n//some of these may be nonsensical\n#define rXY(h,i,j) i di(h a,i b){return i(di(a.a,b.a),di((mu(ne(a.a),b.b)),(b.a*b.a)));}i di(i a,j b){return i(di(a.a,b.a),di((su(mu(a.b,b.a),mu(a.a,b.b))),(mu(b.a,b.a))));}\nrXY(w13,w12,w11)\nrXY(w11,w13,w13)\nrXY(w12,w13,w11)\nrXY(w11,w14,w14)//just guessing this line\nrXY(w12,w14,w11)//just guessing this line\n//All exponential functions utilize their Base_E_identity:...which is still not efficient,but comes down to O(exp(n*log(n)))\n//pow (x,y)-=exp(log(x)*y)//baseE exponential and logarythmic functions.\n#define po(x,y)ex(mu(ln(x),x))\n/*\n//It gets trickier with functions that take 3 parameters:,applying the\n//https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem)with first derivatives.\n#define v0q vec1 q=length(vec2(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nw11 le(w11 x,w11 y){v0q;return w11(ll2\nw12 le(w12 x,w12 y){v0q;return w12(ll2\nw13 le(w13 x,w13 y){v0q;return w13(ll2\nw13 lengthw13(DAm2 u){return le(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters.below is 3d length.\nw13 le(w13 x,w13 y,w13 z){float q=length(vec3(x.a,y.a,z.a));return w13(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nw13 le(DAm2 u){return le(u.x,u.y,u.z);}//3*3domain\n//the utility of a length()function is clear.*/\n//su(ab(p),s)equals a translation away from the origin by [s] AND mirroring at origin,via abs()\n//...so it it clamps a an implicit surface to a limited \"thickness\" (in 3 domains),also translating its first derivatives.\nw12 suab(w12 p,vec1 s){return su(ab(p),s);}\nw11 suab(w11 p,vec1 s){return su(ab(p),s);}\nw13 suab(w13 p,vec1 s){return su(ab(p),s);}\nDAm2 suab(DAm2 p,vec3 s){return DAm2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nDAm1 suab(DAm1 p,vec2 s){return DAm1(suab(p.x,s.x),suab(p.y,s.y));}\nDAm0 suab(DAm0 p,vec1 s){return DAm0(suab(p.x,s));}\n\n\n//spheretracker /ePr is referenced by bicapsule() and other unsigned distances\n//ideally only a 4d marcher is defined,with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\nconst float iterRm=256.;\nconst float eRm=.0001;\nconst float zFar=200000.;\nconst vec2 EN=vec2(.005,0);\nvec2 df(vec3 p);\nfloat dFb(vec3 p);\n#define dNdom(u,a,b) (a(u+EN.b).x-a(u-EN.b).x)\n#define dNormal3X(u,a) normalize(vec3(dNdom(u,a,xyy),dNdom(u,a,yxy),dNdom(u,a,yyx)))\n \nvec4 trace(vec3 ray_start,vec3 ray_dir\n){//vec3 ray_start=a.a;vec3 ray_dir=a.b\n ;float ray_len=0.\n ;vec3 p=ray_start\n ;for(float i=0.; i<iterRm;++i\n){float dist=df(p).x\n  ;if (dist < eRm) break\n  ;if (ray_len > zFar) return vec4(0)\n  ;p +=dist*ray_dir\n  ;ray_len +=dist;}return vec4(p,1);}\n//vec4 trace(vec3 a,vec3 b){return trace(v33(b,a));}//legacy compatible\n/*\nvec4 trace(v33 a\n){float t=0.\n ;for(float i=0.;i<iterRm;++i\n ){float d=df(a.a).x\n  ;if(d<eRm)return vec4(a.a,i);\n  ;if(t>zFar)return vec4(0)\n  ;a.a+=d*a.b*.5//this marther has its first step overstep way too often,doubling lipschitz evades this(poorly)\n  ;t+=d;}return vec4(a.a,iterRm);}\nvec4 trace(vec3 a,vec3 b){return trace(v33(a,b));}//legacy compatible\n*/\n\n//spheretracker\n//ideally only a 4d marcher is defined, with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\n//const float iterRm=160.;\n//const float eRm=.001;\n//const float zFar=20000.;\n\n\n\n//\"crossproduct\" and \"determinant\" are related,cross() is the bilin()* of a lin()_determinant()\n//therefore i can fold the detemrinant() mnamespace onto the cross() namespace.\n//a cross() has 2 inpouts,where a determinant() has 1 input\n//we generalize \"crossproduct\" into its ternary: \"find the only vector that in a 90deg angle to all inputs\"\nvec2 cr(vec2 a){return a.yx*vec2(-1,1);}//rotBy4\nvec3 cr(vec3 a,vec3 b){return cross(a,b);}\n//vec4 cr(vec4 a,vec4 b,vec4 c){\n//solve LinearEquation for   dot(a,d)=0;dot(b,d)=0;dot(c,d)=0;with additional constrains to length(d)==1\n//}\n//[a bilinear (2 input vectors) product with a vector result only exists in 3d and 7d,in 7f it has more than 2 results (handedness,signs)\n//7d_dotproduct() is the octonion_pairing to 3d_quaternion.\nfloat det2d(vec2 a,vec2 b){return dot(a,cr(b));}//a.x*b.y-a.y*b.x//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct perpdot dotperp\n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos,p.zy),perm2(u5cos,p.zx),perm2(u5cos,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//noronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 su(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 mu(float a,v33 b){return v33(a*b.a,a*b.b);}\nmat3 su(mat3 a,mat3 b){return a-b;}\nmat3 addf(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n\n//fast cellular noise,optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares,1 is maximum jitter. (known bug,iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend,is ideally 1/7,but others can be fine too.use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime.\n//the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1,.y is L2 according to [worley noise]\n//this uses a lot of mat2,or the v33 struct,and permute()functions similar to ahsima-simplex noise,defers the sorting,for performance.\n//Cellular noise (\"Worley noise\")in 3D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license.\n//See LICENSE file for details.\n//https://github.com/stegu/webgl-noise\n#define mous (iResolution.xyxy-iMouseZwFix(iMouse,true))//flip mouse everywhere,for shadertoy fun\nmat3 fr(mat3 a){return mat3(fr(a[0]),fr(a[1]),fr(a[2]));}\n//mat3 fl(mat3 a){return mat3(fl(a[0]),fl(a[1]),fl(a[2]));}\nmat3 addd(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n//th7 is for the 2d noise,should be (iResolution.y/7.),BUT i managed to make other values look fine,too\n#define th7 (mous.y/iResolution.y)//usually==1./7.,because mod(a,7)is famous for old LCGs.\n//th8 is for the 3d noise,should be (iResolution.y/7.),other values may work,but they tend to barely work at all,try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))//seems to be fine bounds,not too sure.\nvec3 mod2893d(vec3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}//Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n//Permutation polynomial:(34x^2+x)mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n#define Kcel 1./th8//1/7\n#define Kcel2 1./th8/th8//1/(7*7)\n#define Kcelo (1.-Kcel)*.5//1/2-Kcel/2\n#define Kcelz 1./(th8-1.)//1/6\n#define Kcelzo .5-2./(th8-1.)//0.416666666667//1/2-1/6*2\n#define jitter mous.x/iResolution.x//smaller jitter gives more regular pattern\nmat3 perM3(vec3 p){return mat3(permute3d(p-1.),permute3d(p),permute3d(p+1.));}\nmat3 perM3(vec3 p,vec3 b){vec3 p1=permute3d(p+b.x-1.);vec3 p2=permute3d(p+b.y);vec3 p3=permute3d(p+b.z+1.);return mat3(p1,p2,p3);}\n#define maa(a,b,c) ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a)a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c)mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n//todo,make it traversable bny getting distance2Border.\nvec2 cellular(vec3 P,float m//not to be confuced with a voronoi3d,but can look similar.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=addf(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perM3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perM3(pp[0]+p.z)\n ;mat3 p2=perM3(pp[1]+p.z)\n ;mat3 p3=perM3(pp[2]+p.z)\n ;mat3 ox=fr(p1*Kcel)-Kcelo\n ;mat3 ox2=fr(p2*Kcel)-Kcelo\n ;mat3 ox3=fr(p3*Kcel)-Kcelo \n ;mat3 oz=fl(p1*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz2=fl(p2*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz3=fl(p3*Kcel2)*Kcelz-Kcelzo \n ;mat3 oy=mod73d(fl(p1*Kcel))*Kcel-Kcelo\n ;mat3 oyy=mod73d(fl(p2*Kcel))*Kcel-Kcelo\n ;mat3 oy3=mod73d(fl(p3*Kcel))*Kcel-Kcelo\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=addf(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=addf(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n ;mat3 a\n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared==is dot(r,r)\n //Sort out the two smallest distances (F1,F2)\n #if 0\n ;vec3 d1=min(min(d11,d12),d13) //sort out only F1\n ;vec3 d2=min(min(d21,d22),d23)\n ;vec3 d3=min(min(d31,d32),d33)\n ;vec3 d=min(min(d1,d2),d3)//shortest of 9 distances,except its 9*vec3()\n ;d.x=min(min(d.x,d.y),d.z)\n ;return vec2(sqrt(d.x));}//F1 F1\n #else\n ;vec3 d1a=min(d11,d12)//sort out F1 and F2\n ;d12=max(d11,d12)\n ;d11=min(d1a,d13)//Smallest now not in d12 or d13\n ;d13=max(d1a,d13)\n ;d12=min(d12,d13)//2nd smallest now not in d13\n ;vec3 d2a=min(d21,d22)\n ;d22=max(d21,d22)\n ;d21=min(d2a,d23)//Smallest now not in d22 or d23\n ;d23=max(d2a,d23)\n ;d22=min(d22,d23)//2nd smallest now not in d23\n ;vec3 d3a=min(d31,d32)\n ;d32=max(d31,d32)\n ;d31=min(d3a,d33)//Smallest now not in d32 or d33\n ;d33=max(d3a,d33)\n ;d32=min(d32,d33)//2nd smallest now not in d33\n ;vec3 da=min(d11,d21)\n ;d21=max(d11,d21)\n ;d11=min(da,d31)//Smallest now in d11\n ;d31=max(da,d31)//2nd smallest now not in d31\n ;d11.xy=(d11.x<d11.y)?d11.xy:d11.yx\n ;d11.xz=(d11.x<d11.z)?d11.xz:d11.zx//d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy)//nor in d12.yz\n ;d11.y=min(d11.y,d12.z)//Only two more to go\n ;d11.y=min(d11.y,d11.z)//Done! (Phew!)\n ;return sqrt(d11.xy);}//F1,F2\n#endif\n//crunched by ollj\n//Cellular noise (\"Worley noise\")in 2D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license of://https://github.com/stegu/webgl-noise\n//mod(a,289.)without a division (only multiplications),because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}//Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}//Permutation polynomial:(34x^2+x)mod 289\n#define tt3(p,f,j,m,a)square(su(j,su(v33(vec3(a),f),mu(m,mu(m,modth7(ff(p*th7)))))))\n#define permi(c)p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c)r[d]=tt3(p,f,k.a,m,e);permi(c)\n//Cellular noise,returning F1 and F2 in a vec2//3x3-hood reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity)m=1./7.,by sqiveling this parameter,you get+0.7 domain very cheaply\n//as in by making m a 3rd parameter,you ALMMOST get cheap cellular3d noise,BUT it is likely a bit flawed,more repetitive,shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop.the permute()function marks+1 iteration/tap//is 4tap voronoi in O(3)\n){v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1),f=o+.5,px=permute(o+k.b.x),permi(x)\n ;mat3 r\n ;ppm(0,-.5,y)//it seems that the loop got unrolled and al lits min()fucntions fold into the below\n ;ppm(1,+.5,z)//...//which is quite a lot of symmetry folding,surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line ,because r[0].y is a return value.\n ;r[0].y=min(mi(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n//simplex noise3d (simplex noise is worth it for higher dimensions)\n//Original:https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute(vec4 x){return mod(x*x*34.+x,289.);}\nfloat simplex1(vec3 v//ashima simplex3d,early optimizations by @makio64,structure by @ollj  https://www.shadertoy.com/view/Xd3GRf\n){const vec2 C=1./vec2(6,3);const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy)),x0=v-i+dot(i,C.xxx),g=step(x0.yzx,x0.xyz),l=1.-g//is a sequence of 4,no parallelization\n ;v33 f=v33(min(g.xyz,l.zxy),max(g.xyz,l.zxy));v3333 d=g3333(x0,su(x0,g333(su(f,g33(C)),D.yyy)))\n ;i=mod(i,289.);v222 F=g222(f);vec3 ns=.142857142857*D.wyz-D.xzx\n ;vec4 p=permute(permute(permute(i.z+vec4(0,F.c,1))+i.y+vec4(0,F.b,1))+i.x+vec4(0,F.a,1)),j=p-49.*floor(p*ns.z*ns.z),k=floor(j*ns.z)\n ;v44 t=ad(mu(v44(k,floor(j-7.*k)),ns.x),ns.y)\n ;vec4 h=1.-abs(t.a)-abs(t.b),a=-step(h,vec4(0))\n ;v44 b=v44(vec4(t.a.xy,t.b.xy),vec4(t.a.zw,t.b.zw))\n ;b=ad(v44(b.a.xzyw,b.b.xzyw),mu(v44(a.xxyy,a.zzww),ad(mu(fl(v44(b.a.xzyw,b.b.xzyw)),2.),1.)))\n ;v3333 q=v3333(vec3(b.a.xy,h.x),vec3(b.a.zw,h.y),vec3(b.b.xy,h.z),vec3(b.b.zw,h.w))\n ;q=muv(q,inversesqrt(ddv(q)));vec4 m=max(.6-ddv(d),0.)\n ;return .5+12.*dot(m*m*m,vec4(dot(q.a,d.a),dot(q.b,d.b),dot(q.c,d.c),dot(q.d,d.d)));}\n\n//fbm of dr2 noise (with multitap normals),is a bit crude,in favor for fast normals.\n#define fBm(a) vec2 b=vec2(0,1);for(int i=0;i<a;i++){b=vec2(b.x,0)+vec2(noise1(p),.5)*b.y;p*=2.;}return b.x/(2.-b.y);}\nvec1 fbm(vec1 p){fBm(5)vec1 fbm(vec2 p){fBm(5)vec1 fbm(vec3 p){fBm(5)vec1 fbms(vec3 p){fBm(3)\nvec1 fbmn(vec3 p,vec3 n){vec4 r=vec4(0,0,0,1);for(int i=0;i<4;i++\n){r=vec4(r.xyz,0)+r.w*vec4(vec3(noise1(p.yz),noise1(p.zx),noise1(p.xy)),.5);p*=2.;}return dot(r.xyz,abs(n));}\nvec3 VaryNf(vec3 p,vec3 n,vec1 f\n){vec2 e=vec2(.1,0);vec3 g=vec3(fbmn(p+e.xyy,n),fbmn(p+e.yxy,n),fbmn(p+e.yyx,n))-fbmn(p,n)\n ;return norma(n+f*(g-n*dot(n,g)));}\nfloat fbma(vec3 p//fbm of ashima simplex (no normals,duh)\n){float f\n ;f=.5*(simplex1(p));p=p*2.01\n ;f+=.25*(simplex1(p));p=p*2.02\n ;f+=.125*(simplex1(p));p=p*2.03\n ;f+=.0625*(simplex1(p));p=p*2.04\n ;f+=.03125*(simplex1(p));return f;}\n\n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\nfrflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)frflpm(v44,c44)\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\nfloat Blob(vec3 p){p=ab(p);p=mx(p,p.yzx,st(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a))//i am not convinced by this one\n#define box(a,b) roundit(abm(a,b))\nfloat fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define segment2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,segment()sub ,is squared distance\n#define segment(a,b,c) sq(segment2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n#define segmentY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\n//note that a torus can not be mStretch()ed into a tube\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both chicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u,vec4 m){\n//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x);//calculate dorated differential\n return dot(u-m.xy,(f));//signed distance to line \n//more generally,f should be normalized here for proper caling.\n//but scaling is irrelevant as we only care fror the sign \n}\n//earvageg is still far from standardized. rac is the central radius, should be parametric.\nfloat EarVagEgg(vec2 u,vec2 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=mix(.5,3.,sin(iTime)*.5+.5)\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (sd2l(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(sd2l(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\nfloat EarVagEgg(vec2 u,vec3 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (sd2l(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(sd2l(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\n \n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(EarVagEgg(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(EarVagEgg(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\nfloat CylEarVagEgg(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(EarVagEgg(u.xy,m))-.05)-.02);}\n\n\n#define tiny .000001\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5cos(2.*pi*ab012(a,b));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below,but close\nvec3 hsv2rgb(const vec3 c){return c.z*mx(1.,sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n\n\n\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\nstruct v21{vec2 a;vec1 b;};//currently only for alpha compositing plans\nstruct v31{vec3 a;vec1 b;};//...for MAT arithmetic\nstruct v41{vec4 a;vec1 b;};\nv21 su(v21 a,v21 b){return v21(a.a-b.a,a.b-b.b);}\nv21 mu(v21 a,v21 b){return v21(a.a*b.a,a.b*b.b);}\nv21 mu(v21 a,vec1 b){return v21(a.a*b,a.b*b);}\nv31 su(v31 a,v31 b){return v31(a.a-b.a,a.b-b.b);}\nv31 mu(v31 a,v31 b){return v31(a.a*b.a,a.b*b.b);}\nv31 mu(v31 a,vec1 b){return v31(a.a*b,a.b*b);}\nv41 su(v41 a,v41 b){return v41(a.a-b.a,a.b-b.b);}\nv41 mu(v41 a,v41 b){return v41(a.a*b.a,a.b*b.b);}\nv41 mu(v41 a,vec1 b){return v41(a.a*b,a.b*b);}\n//generalizing alpha-compositing functions,named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent,.W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes],this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions,that return a or b,for simplicity\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n\n\n\n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\nw11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nfloat recsum(vec2 a){return 1./(su(1./a));}\n\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(iTime*vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\nvec4 demoSmin(vec2 u,vec2 m,vec2 n//smin (exponential and polinomial) , with automativDifferenciation\n){return demoSminBone3(u,m,n)\n ;w11 a=w11(u.x-m.x*9.,1.)\n ;w11 b=w11(u.x-m.x*9.,1.)\n ;m.x=abs(m.x)+.2//optional evasion of very short wavelength\n ;vec4 c=vec4(0)\n ;float amp=1.//m.y\n ;a=   mu(co(di(a,di(m.x,mu(pi,.5)))),amp)//a.b is analytic first derivative of a.a\n ;b=ad(mu(si(di(b,di(m.x,mu(pi,.5)))),amp),mu(si(b),.3))//b.b is analytic first derivative of b.a\n ;a=su(co(mu(a,2.)),mu(a,.2))\n ;b=su(si(mu(b,2.)),mu(b,.561))\n ;w11 d=mae(a,b,1./m.y)\n ;w11 e=mae(a,b,1./m.y)\n ;w11 f=mas(a,b,3.*m.y)\n ;c.y=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.x=abs(b.a-u.y)/sqrt(1.+b.b*b.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.z=abs(d.a-u.y)/sqrt(1.+d.b*d.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.w=abs(f.a-u.y)/sqrt(1.+f.b*f.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;//c=abs(c-.2)-.1//optional shows how this is NOT distance2Sin()\n ;c=abs(c-aaa*2.)-aaa*.5//optional double line\n ;c=smoothstep(aaa,-aaa,c)\n ;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n ;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec4 y=vec4(angleToColor(vec3(rainb.y,1,1)),c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(angleToColor(vec3(rainb.z,1,1)),c.z)//coordinate system in magenta/pink\n ;vec4 w=vec4(angleToColor(vec3(rainb.w,1,1)),c.w)//coordinate system in magenta/pink\n ;x.xyz*=x.w;y.xyz*=y.w;z.xyz*=z.w;w.xyz*=w.w//alpha premultiplied\n ;x=pdOver(y,x)\n ;x=pdOver(z,x)\n ;x=pdOver(w,x)\n ;return x;}\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n\n \n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n//https://www.shadertoy.com/view/ldSBR3\n//return distance to sideways.horse-silhouette,optimized for speed.\nfloat silHorse(vec2 u//main plan is to use something common with low symmetry, to demo folding patterns.\n){//u-=m.xy;//move by m.xy\n ;float t=length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))+.5//tail\n ;float r=length(vec2(-1.5-u.x,mStretchP(u.y,4.)))+.5\n ;float l=length(vec2(1.5-u.x,mStretchP(u.y,7.5)))+.5//front\n ;u.y-=3.5\n ;vec2 n=vec2(2.25-u.x,u.y-2.5)\n ;float h=length(n)-.5//head\n ;n+=vec2(1.3,.7)\n ;h=min(h,length(n)+.3)\n ;u.x=mStretch(u.x,1.1)\n ;float b=length(u)-.2\n ;//h=length()\n ;//vec2 v=abs(u-vec2(.5))\n ;//return b\n ;return min(min(min(h,b),min(l,r)),t)\n ;return ellipseCheap(u)-1.5\n ;return length(u);}\nfloat CylSilHorse(vec3 u,float h){return ma(abs(u.z)-h,(silHorse(u.xy*3.)-1.)/3.);}\n\n\nfloat legs4(vec3 u,vec3 d //distance to the 4 legs of a table d.y=tableHeight. d.xz=distancesBetweenLegs.\n){u.y=mStretchP(u.y,d.y)\n ;u.xz=abs(u.xz)-d.xz\n ;return le(u)\n ;}\nfloat horseBody(vec3 u\n){u.x=mStretch(u.x,.45)\n ;return length(u-vec3(0,1.1,0))\n ;}\n\n//accidental vulalike, due to 2x -.5 offset\n// ;r=length(vec2(u.z,length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))-.5))-.5  //tail\n\nfloat horseTail(vec3 u\n){return (length(vec2(u.z,length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))))+.2)*.5;}\n\nfloat horseAnus(vec3 u){return torus((u.yxz+vec3(-1.3,.82,0)),.06);}\nfloat horseVag(vec3 u\n){u.z=mStretch(u.z,.2)\n ;u.xy-=vec2(1,0)\n ;float scale=3.2\n ;return length(vec2(u.z,EarVagEgg(u.xy*scale,vec3(.01,.25,1.2))/scale)-.01)\n ;}//CylEarVagEgg(((u.zyx-vec3(1,.8,.25)))*2.,.5*iMouse.xy/iResolution.xy,.2)\nfloat horseButt(vec3 u){\n ;u.z=abs(u.z)-.2\n ;return length(u-vec3(-.57,1.1,0))-.2\n ;}\n\nfloat SilHorse(vec3 u\n){float r=legs4(u,vec3(.5,1,.26))-.18\n ;r=mis(r,horseBody(u)-.4,.3)//torso\n ;r=mis(r,le(u-vec3(.5,1.4,0))-.05,.2)//neck\n ;r=mis(r,le(u-vec3(.8,1.9,0))-.5,.2)//head\n ;r=mis(r,horseButt(u),.3)\n ;float s=mis(horseVag(u.zyx-vec3(-1,.9,-.65))-.03,horseAnus(u)-.03,.05)\n ;r=mis(r,s,.05)\n ;r=mis(r,(horseTail(u*2.3+vec3(-.1,.9,0))+u.x*.3+.1),.6)//tail has some tricky lipschitz tweaks\n ;return r;\n ;}\n\nvec2 FactorioFurnace(vec3 u){\n ;float d=length(u)\n ;return vec2(d,1)\n ;}\n \n\n\nvec2 debugHg2(vec3 u){\n ;vec2 r=vec2(zFar,0.)\n ;float t=cos(iTime)*.4+.5\n ;r=minx(r,FactorioFurnace(u))\n ;//r=minx(r,CoordCross(u))//coordinate crosses\n ;u.x=1.-u.x//flip towards light source\n ;//r=minx(r,vec2(CylEarVagEgg(((u.zyx-vec3(1,.8,.25)))*2.,.5*iMouse.xy/iResolution.xy,.2),13))\n ;float h=CylSilHorse(u-vec3(1,0,3),.4)\n ;r=minx(r,vec2(h,13))\n ;r=minx(r,vec2(SilHorse(u-vec3(1,0,0)),14))\n ;//r=box(u,vec3(1))-t\n ;//r=length(u-bicapsule3(u,vec3(-.5,0,2),vec3(.5,0,2),.7,.2))-.1\n ;//bicapsule(u,vec3(1,0,0),vec3(0,0,1),.5,2.)\n ;//r=Blob(u)\n ;//r=fPlane(abs(u),vec3(1,1,1),-1.5)//the raymarcher is not ideal for this one,with its alpha fadeout.\n ;//r=boxf(u,vec3(1))-.5\n ;//r=corner(u.xy)\n ;//r=cylinder(u,1.,1.)\n ;//failed to make a rounded cylinder via roundit()\n ;//r=segment(u,vec3(0),vec3(1,2,3))-t\n ;//r=segmentY(u,vec2(1,2))//could not get it to work instantly\n ;//r=torus(u,1.)-1.\n ;//r=disc(u,vec2(1.))-2.//could not get it to work instantly\n ;//r=hexCircum(u,1.)-1.\n ;//r=fCone(u,1.,2.)\n ;return r;}\n//2-distance input unions\n//note,for higher dimensions,i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances,b is a radius //todo,compare with mima()\n#define miRound(a,b) mi(ma0(a),-b)+le(ma0(b+a))//is likely wrong\n#define maRound(a,b) -fOpRoundMin(-a,b)//is likely wrong\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}//is likely wrong\n/*\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat micolumns _M(1.)\n ;p.x+=sqrt(.5)*-r+c*sqrt(2.)\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b)\n ;}\n\nfloat macolumns _M(-1.)\n p.y+=c;p.x=sqrt(.5)*(r+c)/p.x\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=-mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b);}//fails on its own\n#define mecolumns(a,b,r,n) -macolumns(a,-b,r,n)/**/\n\n\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return mi(mi(a,b),.5*(u+a+abs(mo(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\nvec2 debugHg(vec3 u){\n ;return debugHg2(u)\n ;float r=0.\n ;u.z-=1.\n ;float t=cos(iTime)*.4+.5\n ;float a=box(u   ,vec3(1))-t\n ;//u.xy*=r2(1.)\n ;float b=box(u-1.,vec3(1))-.2\n ;//return mi(a,b)\n ;//return ma(a,b)\n ;//return ma(a,-b)\n ;//return miChamfer(a,b,0.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return miChamfer(a,b,3.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return maChamfer(a,b,.5)//not sure if broken or tracer issue\n ;//return meChamfer(a,b,.5)\n ;//return chamfer180(a,b,.5)//round chamfer is best\n ;//return -chamfer180(-a,-b,.5)//max() round chamfer is weird but fun\n ;//return -chamfer180(-a,b,.23)//max(a,-b) round chamfer easily gets discotinuous\n ;//return chamfer180(a,b,3.5)//overchamfering round is bumpy\n ;//return miRound(a,b)//todo fixme\n ;//return mistairs(a,b,.5,13.)\n ;//return mistairs(a,b,.5,13.)\n ;//return mestairs(a,b,.5,13.)\n ;a=micolumns(a,b,.5,4.)\n ;//return mecolumns(a,b,.5,4.)\n ;//return mucolumns(a,b,.5,4.) \n ;//return macolumns(a,b,.5,4.)//macolumns fails\n ;//return mecolumns(a,b,.5,4.)\n ;//return pipe(a,b,.2)\n ;//return engrave(a,b,.5)\n ;//return -groove(-a,b,.5,.1)\n ;//return tongue(a,b,.5,.1)\n ;return vec2(a,1);}\n\n\n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his mit licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n\n//The MIT License\n//Copyright  2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 v0,vec3 v1,vec3 v2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=v0-v1\n ;vec3 b=v2-v0\n ;vec3 p=v0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright  2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\n\n\n//someone overthought checkerboard patterns\n//float xnor(float x,float y){return abs(x+y-1.);}// abs(0+0-1)-1 abs(1+0-1)-0 abs(0+1-1)-0 abs(1+1-1)-1\n//xnor(xnor(e.x,e.y),e.z)//checkerboard3d\n\n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(mi(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n#define fsaa (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n\n//float gm3(mat3 a,int n){return a[n/3][n%3];}//use a matrix as if it is a list.\n\n\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}\nfloat lineN(vec2 u,vec2 m){return line(u,normalize(m));}\n//https://www.shadertoy.com/view/4dBfzG\n//return unsigned distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat lsa(vec2 u,vec2 m){return abs(line(u,m));}\nfloat lsaN(vec2 u,vec2 m){return abs(line(u,normalize(m)));}\n//return distance of [u] to ray from(0,0)trough [m],m must be normalized.\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\nfloat ilsN(vec2 u,vec2 m){return ils(u,normalize(m));}\n//return distance of [u] to line_segment from(0,0)to [m],m must be normalized!\n//this line segment has a length of 1.\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\nfloat ls1N(vec2 u,vec2 m){return ls1(u,normalize(m));}\n//return distance of [u] to line_segment from(0,0)to [m],m must be normalized\n//[m] must NOT be normalized!\nfloat ls(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lsN(vec2 u,vec2 m){return ls(u,normalize(m),m);}\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lssN(vec2 u,vec2 n,float a){return lss13(u,normalize(n),a);}\n//signed infionite line\nfloat lineInf(vec2 p,vec2 a,vec2 b){vec2 d=b-a;return(dot(normalize(vec2(d.y,-d.x)),p-a));}\n\n\n\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n#define sm(a,b)smoothstep(a-10./iResolution.y,a,b)\nfloat PatternCircles(vec2 p,float m//https://www.shadertoy.com/view/MsSyRz\n){p.x-=m*.5*step(0.,sin(pi*p.y/m))\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n\nfloat DistanceYtoLine(vec2 u,vec2 m,vec2 n\n){;m=m-n;;return (u.x-n.x)*m.y/m.x-u.y+n.y;}\n\n\n\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\n/**/\n\n\n\n\n\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\nfloat fTruncatedOctahedronB(vec3 u,float r){return max(box(u,r),fOctahedron(u,r));}\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\nfloat fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n//where .a is a distance .b is intended to be a colorCode. if(any(.b<0)) it encodes a 4d textureID;else ist is a texturte.rgba\nstruct v14{vec1 a;vec4 b;};\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//todo,  define a mix for struct v14\n\nv14 demoSpheroid(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 d=v14(zFar,vec4(0))\n ;vec4 c=vec4(-5,0,0,0)\n ;d=minxb(d,v14(box                   (u,vec3(1.)      ),c))\n ;d=minxb(d,v14(fOctahedron           (u-vec3(3,0,3),1.),c))\n ;d=minxb(d,v14(fTruncatedOctahedron  (u-vec3(3,0,0),1.),c))\n ;d=minxb(d,v14(fTruncatedOctahedronB (u-vec3(0,0,3),1.),c))\n ;u+=vec3(6,0,0)\n ;c=vec4(-6,0,0,0)\n ;d=minxb(d,v14(fDodecahedron         (u            ,1.),c))\n ;d=minxb(d,v14(fIcosahedron          (u-vec3(3,0,3),1.),c))\n ;d=minxb(d,v14(fTruncatedIcosahedron (u-vec3(3,0,0),1.),c))//==c60 soccer ball\n ;d=minxb(d,v14(fTruncatedIcosahedronB(u-vec3(0,0,3),1.),c))\n ;return v14(d.a*scale,d.b);}\n\nv14 demoSpheroidB(vec3 u\n){float scale=.5\n ;float tt=mix(3.,105.,u5(cos(iTime)))//i found this range to be continuous, and outOfRange not.\n ;u/=scale\n ;v14 d=v14(zFar,vec4(0))\n ;vec4 c=vec4(-7,0,0,0)\n ;d=minxb(d,v14(box                   (u,vec3(1.)         ),c))\n ;d=minxb(d,v14(fOctahedron           (u-vec3(3,0,3),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedOctahedron  (u-vec3(3,0,0),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedOctahedronB (u-vec3(0,0,3),1.,tt),c))\n ;u+=vec3(6,0,0)\n ;c=vec4(-8,0,0,0)\n ;d=minxb(d,v14(fDodecahedron         (u            ,1.,tt),c))\n ;d=minxb(d,v14(fIcosahedron          (u-vec3(3,0,3),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedIcosahedron (u-vec3(3,0,0),1.,tt),c))//==c60 soccer ball\n ;d=minxb(d,v14(fTruncatedIcosahedronB(u-vec3(0,0,3),1.,tt),c))\n ;return v14(d.a*scale,d.b);}\n\n\n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv33 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*iTime)//autopilot\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;m=mx(n,m,step(0.,mouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v33(pos,dir);}\n\n\n\n//Phong+debugPlanes\n//\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n#define tracePlane(po,pd,o,d) dot(po-(o),pd)/dot(d,pd)\n//traceR if(t<0) return -1; return t;\n#define traceR(t) mix(-1.,t,step(t,0.))\n#define raytrace_plane(po,pd,o,d) traceR(tracePlane2(po,pd,o,d))\nvec1 planeDebug2(vec3 o,vec3 d,vec3 c,inout float t,vec2 n//ray,ray,curPlane,time,domainLengths\n){if(n.x<length(c)&&n.y>0.//debug plane //n.x=o.y n.y=d.y\n ){float p=tracePlane(c,c*t,o,d)//;if(abs(p)<9.){\n  ;p=df(o+d*p).x\n  ;float q=fract(p*8.)/(p*p*p*p+4.)\n  ;p=mix(q,mix(1.,.5,q),step(p,0.))\n  ;return p*.5;}//}\n ;return 0.;}\n//x can be y,beware that z may be hidden from some cameras,need to rotate camera asound.\n//d is linked to e; e=x f=0 ; e=y f=1 ; e=z f=2 (; e=w f=3)\n#define planeDebug(a,b,c,d,e) planeDebug2(a,b,c,d,vec2(a.e,b.e))\n\nvec4 DebugPlanes(vec3 o,vec3 d,float t\n){float c0=u5(sin(iTime*.1))*2.\n ;vec4 a=planeDebug(o,d,(c0*vec3(1,0,0)),t,x)*vec4(0,1,.5,1)\n ;vec4 b=planeDebug(o,d,(c0*vec3(0,1,0)),t,y)*vec4(.5,0,1,1)\n ;vec4 c=planeDebug(o,d,(c0*vec3(0,0,1)),t,z)*vec4(1,.5,0,1)\n ;return sat((a+b+c)*2.);}\nvec3 tex(vec3 u//textureid is 2 integers, .x one sets hue, .y sets saturation.\n){float i=df(u).y;\n ;vec3 r=hsv2rgb(vec3(fract(i*phi),1,1))\n //;if (i<0.)\n ;//r=mix(r,dNormal3X(u.xyz,df)*.5+.5,.7)\n ;//r=mix(r,vec3(checkerSignSt(u-1.,.5+.5*cos(-iTime)*vec3(1,1,1))*.5+.75),.5)\n ;//r=po(r,1.4)//gamma\n ;return r\n //return cellular(u*5.,iTime).xyx\n //;return fract(u*4.+cos(iTime))\n ;}\n\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n \n//these likely have simpler expressions,its too late timeofday for me to bother now.\nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n\n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(iTime*.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1])\n ;y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(ma(dt(p,y))-o.x*3.,sq(mi(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n\nvec2 demohh(vec3 u\n){float scale=1.\n ;u*=scale\n ;//;float dodec=fDodecahedron(p-vec3(-9,2,-4)/4.,.7)//i like how this is placed n the mirroring plane\n ;float b=fBox(u-vec3(0,-.1,0),vec3(1))\n ;float s=length(u-vec3(1.+sin(iTime*.25)*.2,.8,1))-1.//sphere\n ;s=min(b,s)\n //;return s;\n ;float d=mistairs(b,s,.7,4.)\n ;u.xz*=r1(iTime*.041);u.zy*=r1(iTime*.021)//lazy small rotation\n ;//vec2 n=cellular(u*5.61,1./7.)\n ;//d-=(n.y-n.x)*.05//too much foreach march iteration.\n ;return vec2(d/scale,1);}\n\n\nvec2 df(vec3 u//.x=distance .y=textureId\n){float scale=1.\n ;u*=scale\n#if 0\n //;u.xz=-u.xz;\n //;vec2 q=pModMirror2(u.xz,vec2(4.5))//offset repetition doesnt go well with the camera transform\n#endif\n ;v14 d=v14(zFar,vec4(0));\n ;d=minxb(d,demoSpheroid (u-vec3(.5,0,5.5)))//spheroid shit\n ;d=minxb(d,demoSpheroidB(u-vec3(.5,0,2)))//spheroid shit exponential\n ;d=minxb(d,dfPoly(u+vec3(0,0,2)))//array of 16 different spheroids,slow due to 4x4 lattice.\n ;//d=min(d,demohh(u-vec3(3,0,0)).x)//old decapitated basis for scale\n ;//d=min(d,debugHg(u-vec3(0,0,3)).x)//hg_sdf debug playgound\n ;return vec2(d.a/scale,d.b);}\n //;return min(d,dodec);}\n\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n\n\n\n\nvec4 demo2NoiseCel(vec2 u,vec2 m\n){vec3 o=vec3(u*6.,cos(iTime)*4.)\n ;o.xz*=r1(iTime*.041);o.zy*=r1(iTime*.021)//lazy small rotation\n ;return vec4(cellular(o,iTime*.161),0,1);}\n\nvec4 demoAd2d(vec2 u,vec2 m//deomes 1d automatic differentiation\n){vec3 c=vec3(0)\n ;w11 a=w11(u.x*9.,1.)\n ;a=w11(u.x,1.)\n ;a=si(ex((a)))//a.b is analytic first derivative of a.a\n //;a=(si(fr(a)))\n ;c.x=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float o=c.x\n ;c.y=a.b\n ;c.yz-=u.y\n ;c.yz=abs(c.yz)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;c=smoothstep(aaa,-aaa,c-aaa)\n ;if(abs(a.b)<aaa*50.)c.z=max(c.z,pow(1.-abs(a.b)*2.,4.))//mark local extrema with vertical lines (better line width would need 2nd derivative)\n ;c=c.zyx//;c=mix(c,c.yzx,iMouse.x/iResolution.x)*2.#\n ;vec4 x=vec4(0  ,c.x,c.x,c.x)//first derivative\n ;vec4 y=vec4(c.y,0  ,c.y,c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(c.z,c.z,0  ,c.z)//coordinate system in magenta/pink\n ;x=pdOver(y,x)//2 graphs,one is 1st derivative  in cyan/blue\n ;x=pdOver(z,x)//add coordinate system that highlights loccal extrema\n ;return x;}\n\nvec4 demo2d1(vec2 u,vec2 m,vec2 n\n){vec2 i=mix(n,m,abs(cos(iTime*2.)))\n ;vec4 c=sqrt(vec4(dd    (m-u) ,dd    (n-u) ,dd    (u) ,dd    (i-u)))//abs(cos())bounce for direction\n ;vec4 d=     vec4(ma(abs(m-u)),ma(abs(n-u)),ma(abs(u)),ma(abs(i-u)))\n ;c=mix(c,d,2.*(cos(iTime)))\n ;float thick=.005,diam=.1\n ;c=smoothstep(.01,-.01,abs(abs(c-diam)-diam+thick)-thick)//i know theres better ways to do this abs(abs())identities...\n ;c.xy+=c.w;return vec4(c.xyz,ma(c.xyz))\n ;vec4 a=pdOver(vec4(0,c.y,0,c.y),vec4(c.x,0,0,c.x))//green over red\n ;c     =pdOver(vec4(c.w,c.w,0,c.w),vec4(0,0,c.z,c.z))//yellow over blue\n ;c     =pdOver(a,c)//green over red over yellow over blue\n ;return c;}\n\nvec3 sspm(float a,vec3 b){return smoothstep(a,-a,b);}\n\nvec4 pd(vec2 u\n){vec2 m=fra(iMouse.xy)\n ;if(iMouse.z<.0)m=-vec2(.5)//while(mouse up)simulate mouse down.\n ;vec2 s=-vec2(1.,sin(iTime))//vector moves over time.\n ;vec3 e=vec3(dd(u)\n ,dd(u-m)\n ,dd(u-s))//eucliden distance projection.\n ;e=sqrt(e)//delayed square root\n ;e-=.5//circle radius\n ;e=abs(e)-.2;//turn cirlce into ring\n ;float SSAA=(cos(iTime)+1.25)*12./min(iResolution.x,iResolution.y);//screen-space-anti-aliasing\n ;e=sspm(SSAA,e)\n ;e=sat(e)\n ;vec3 g=vec3(.96,.25,.05)//color ramp equals cheap colorblind mode.\n ;vec4 c0=vec4(g,e.x)\n ;vec4 c1=vec4(g.yzx,e.y)\n ;vec4 c2=vec4(g.zxy,e.z)//some colors with e.rgb as alpha channel.\n ;c0.rgb*=c0.w//general form scales .rgb by alpha,\n ;c1.rgb*=c1.w//...this acoids some division by 0 cases\n ;c2.rgb*=c2.w\n ;vec4 O=pdOver(c0,c1);O=pdOver(O,c2)\n ;//O=sXor(c0,c1);O=sXor(O,c2)\n ;//O=sAtop(c0,c1);O=sAtop(O,c2)\n ;vec4 bg=vec4(vec3((checkerBool2(u))),u.y)\n //;bg.rgb=pow(bg.rgb,vec3(2.2))\n ;if(O.w!=0.)O.rgb/=O.w\n ;O=pdOver(O,bg);\n ;O.rgb=pow(O.rgb,vec3(1./2.2))/**/\n ;return O;}\n\n/*\nvec4 demoshit(vec2 fragCoord\n){vec2 uv=(fragCoord.xy-iResolution.xy*0.5)/iResolution.y\n ;vec3 lir=normalize(vec3(.5,1.0,-.25))\n ;// Simple model-view matrix:\n ;v33 ray=cam(uv)\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return vec4(c);}*/\n\nvec4 demoHg3d(vec2 u\n){vec3 lir=norma(vec3(.5,1.0,-.25))\n ;v33 ray=cam(u)\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return c;}\n\n//solve 2 limb-IK and paint it,red&green=limbs; Yellow=ellbow and hand ; blue= handRange \n#define eIK .001\nvec4 demoIkX(vec2 u,vec2 m,vec2 l//2 limb IK along x-axis (circleCircleIntersection)\n){vec2 i=1.+vec2(1,-1)*eIK//evade rounding errors from moving the boal out too far (overlapping limbs\n ;vec2 L=l.y+l.x*vec2(-1,1);m.x=clamp(m.x,abs(L.x)*i.x,L.y*i.y)//move goalspost within limb range\n ;vec2 e=vec2(0)//ellbow position\n ;e.x=cci(vec3(l.xy,m.x))\n ;e.y=sqrt(l.x*l.x-e.x*e.x)//point.y on left circle\n //you possibly just want to return [e] (likely rotated back by an angle)\n ;vec4 a=vec4(0)//the rest is \"just\" for visualization\n ;a.x=segment(u,vec2(0),e)\n ;a.y=segment(u,e,vec2(m.x,0))\n ;float aaa=2./min(iResolution.x,iResolution.y)\n ;float j=aaa*7.//make outer circle withs j thinner than line segments\n ;vec2 p=abs(vec2(length(u)-l.x,length(u-vec2(m.x,0))-l.y))+j\n ;a.xy=min(abs(abs(abs(a.xy)-aaa*14.)-aaa*3.)-aaa*2.,p.xy-aaa*9.)\n ;a.w=length(u-e)-.1//pointAtEllbow\n ;a.w=min(a.w,length(u-vec2(m.x,0))-.1)//pointAtHand\n ;a.w=abs(a.w)+j*.5//turn into \"rings\"\n ;a.z=abs(length(u)-L.y)+j\n ;a.z=min(a.z,abs(length(u)-abs(L.x))+j)\n ;float mid=(abs(L.x)+L.y)*.5\n ;float range=(abs(L.x)-(L.y))*.5\n ;a.z=abs(length(u)-mid)+range\n ;a.w-=aaa*9.//thicker lines\n\n ;a=smoothstep(aaa,-aaa,a)\n ;vec4 r=vec4(0)\n ;r=pdOver(r,vec4(1,0,0,1)*a.x)\n ;r=pdOver(r,vec4(0,1,0,1)*a.y)\n ;r=pdOver(r,vec4(1,1,0,1)*a.w)\n ;r=pdOver(r,vec4(0,0,1,1)*a.z*.5)\n ;return r;}\n//m is handTarget, n.xy are limb lengths\n//for a planar visualization, we just rotate all inputs by matrix[b]\n//if we wanted the ellbow position, we would have that to be returned and then; return \nvec4 demoIk(vec2 u,vec2 m,vec2 n//2 limb IK along x-axis (circleCircleIntersection)\n){if(iMouse.z<=0.\n ){n=mix(vec2(1,0),vec2(0,1),u5(cos(iTime*vec2(.5,.61))))+.5//auromatic limg lengths\n  ;}\n ;//n=vec2(0.61,1.61)//limb lengths\n ;//n=mix(vec2(1,0),vec2(0,1),u5(cos(iTime*vec2(.5,.61))))+.5//optionally change over time\n ;mat2 b=r1(AngleBetween(m));return demoIkX(u*b,m*b,n)\n ;}\n\n\n\nvoid mainImage(out vec4 O,vec2 u\n){O=vec4(0)\n ;//O=pdOver(O,demoshit(u))//mouseCoords\n ;u=fra(u)\n ;vec2 auto=(cs(iTime)+vec2(.8,0))*1.2+cs(iTime*6.*1.61)*.2\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 m=mix(auto,fra(mouse.xy),sign(mouse.z))\n ;vec2 n=mix(auto.yx,fra(mouse.zw),sign(mouse.z))\n ;O=pdOver(O,demoIk(u,m,u5(n/2.)))\n ;O=pdOver(O,demo2d1(u,m,n))//mouseCoords\n ;//O=pdOver(O,demoAd2d(u,m))//ad 1d\n ;//O=pdOver(O,demoSmin(u,m,n))//ad 1d smin\n ;//O=pdOver(O,demoHg3d(u))//hg_sdf,u-scaling sets camera distance to center\n ;//O=pdOver(O,demoComplex(u,m,n))\n ;//O=pdOver(O,demo2NoiseCel(u,m)*vec4(.3,.3,.3,1.))//celularNoise\n ;O=pdOver(O,vec4(vec3((checkerBoolT(u*1.61))*.5+.25),u.y))//checkerboard background\n ;}\n\n\n\n\n\n\n\n\n\n\n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dSegment(a,b,c) segment(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return segmentY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return segment(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\n\n\n/*\n//html boilerplate\n\n\nvoid main(){vec4 o=vec4(1);mainImage(o,v1u*iResolution.xy);\n//Tiny Bridge300 O Mouse5small,fixes iResolution.z iMouse and iTime shadertoy compatibility\n\n</script><script id=\"i\">=o;}</script><script>//body for all vertex shader versions\n//boilerplate based on piLibs 2015-2017@ http://www.iquilezles.org/www/material/piLibs/piLibs.htm\nwindow.requestAnimFrame=(function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame\n||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(cb){window.setTimeout(cb,16);};})();\nvar mF32Textures=mF16Textures=mDerivatives=mDrawBuffers=mDepthTextures=mHaderTextureLOD=true//assimilateds \nvar mC,mS={},par={startTime:Date.now(),t:0,f:0,MX:0,MY:0,MZ:0,MW:0,SX:0,SY:0}//uniforms,timestamp,mouse,canvasSize\n,sB=null,mR,vA,mS\nfunction gei(a){return document.getElementById(a).textContent;}\nfunction cul(p,l){if(p.uniformsCache===undefined)p.uniformsCache={};p.uniformsCache[l]=m.getUniformLocation(p,l);}\nfunction SetShaderConstant1I(u,x){m.uniform1i(m.getUniformLocation(sB.mProgram,u),x);}\nfunction SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant1F(u,x){m.uniform1f(m.getUniformLocation(sB.mProgram,u),x);}//fine\nfunction SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\nfunction SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\nfunction SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\ndocument.addEventListener('mousedown' ,function(e){par.MZ=e.clientX/window.innerWidth;par.MW=1-e.clientY/window.innerHeight;},false)\ndocument.addEventListener('mouseup' ,function(e){par.MZ=0.;par.MW=0.;},false)\ndocument.addEventListener('mousemove' ,function(e){par.MX=e.clientX/window.innerWidth;par.MY=1-e.clientY/window.innerHeight;},false)\nvar fpsTo,fpsA,pL=pN=fl=mi=mis=0\nfunction rAf(\n){pL=pN;pN=performance.now()//2 frame timestamps\n ;par.t=Date.now()-par.startTime\n ;var now=new Date();sec=now.getHours()*3600+now.getMinutes()*60+now.getSeconds();\n//;SetRenderTarget(null)\n ;sB=mS;m.useProgram(mS.mProgram);\n ;SetShaderConstant1I(\"iFrame\",par.f)//older error was:wrong type\n ;SetShaderConstant1F(\"iTime\",par.t*0.001)//error runs too fast?\n ;SetShaderConstant4F(\"iMouse\",[par.MX*mD.width,par.MY*mD.height,par.MZ*mD.width,par.MW*mD.height])\n ;SetShaderConstant4F(\"iDate\",[now.getFullYear(),now.getMonth(),now.getDate(),sec])\n ;SetShaderConstant3F(\"iResolution\",[mD.width,mD.height,1])\n ;m.drawElements(m.TRIANGLES,3,m.UNSIGNED_SHORT,0);\n ;par.f=par.f+1.0\n ;fpsA++\n ;var te=(pN-pL).toFixed(2)\n ;if(te>mi)mi=te//mis shows the largest sime it took for the last M-frames to render,doubles on frame skips/hickups.\n ;document.getElementById(\"IF\").innerHTML=wMs[wM]+\"-\"+(par.f).toFixed(0)+\"<br>fps:\"+fl+\"<br>ms \"+mis+\"<br>tB-o300\"\n ;if((pN-fpsTo)>250\n ){fl=(1000.*fpsA/(pN-fpsTo)).toFixed(2)\n  ;mis=te;\n  ;mi=0.\n  ;fpsA=0\n  ;fpsTo=pN;}\n ;requestAnimFrame(rAf);}\nvar mF32Textures=mF16Textures=mDerivatives=mDrawBuffers=mDepthTextures=mHaderTextureLOD=mRenderToFloat32F=false\nfunction extendGL(//optional openGL_ES extensions\n){if(w2//not all extensions exist in all versions of OpenGL_ES,webgl is a patchwork of extensions prior to version300es:\n){mDerivatives=m.getExtension('OES_standard_derivatives')\n  ;mHaderTextureLOD=mF32Textures=m.getExtension('OES_texture_float')//these extensions were optional prior to version300es\n  ;mF16Textures=m.getExtension('OES_texture_half_float')//...and are included in version 300es\n  ;mDrawBuffers=m.getExtension('WEBGL_draw_buffers')\n  ;mDepthTextures=m.getExtension('WEBGL_depth_texture')\n  ;mHaderTextureLOD=m.getExtension('EXT_shader_texture_lod')\n ;}else mRenderToFloat32F=m.getExtension('EXT_color_buffer_float')//version300es exclusive extension\n ;mF32Filter=m.getExtension('OES_texture_float_linear')//but these 3 extensions persist as extensions\n ;mF16Filter=m.getExtension('OES_texture_half_float_linear')\n ;mAnisotropic=m.getExtension('EXT_texture_filter_anisotropic');}\nfunction sh(a,b){alert(a+\"\\n\"+m.getShaderInfoLog(b));}\nfunction cs(v,h,b){m.shaderSource(v,h);m.compileShader(v);if(!m.getShaderParameter(v,m.COMPILE_STATUS)){sh(b,v);}}\n;function pIn(\n){par.MX=(e.clientX/window.innerWidth);par.MY=(1-e.clientY/window.innerHeight)\n ;par.MZ=0.;par.MW=0.//optional clean mouse init\n ;mD=document.getElementById(\"ID\")\n ;mD.width=mD.offsetWidth;mD.height=mD.offsetHeight//optional aspect ratio scaling\n ;m=false\n ;while(wM>-1&&!m\n){m=mD.getContext(wMs[wM--]\n,{alpha:false,depth:false,stencil:false,premultipliedAlpha:false,antialias:false,preserveDrawingBuffer:false,powerPreference:\"high-performance\"})}\n ;wM++\n ;w2=(m instanceof WebGLRenderingContext)\n ;extendGL()\n ;var j=\"\\n#ifdef GL_ES\\nprecision highp float;precision highp int;\\n#endif\\n\",hF,hV=(w2)?j:\"#version 300 es\\n\"+j\n ;if(w2//hV,hF puzzle concatenate a string for 2 shader shader programs;vertex,fragment\n){hF=j\n  ;if(mDerivatives)hF+=\"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives:enable\\n#endif\\n\"\n  ;if(mHaderTextureLOD)hF+=\"#extension GL_EXT_shader_texture_lod:enable\\n\"\n  ;if(mHaderTextureLOD){hF+=\"vec4 textureLod(sampler2D s,vec2 c,float b){return texture2DLodEXT(s,c,b);}\\n\"\n  ;hF+=\"vec4 textureGrad(sampler2D s,vec2 c,vec2 dx,vec2 dy){return texture2DGradEXT(s,c,dx,dy);}\\n\";}\n ;}else hF=hV\n ;var a=w2?\"attribute vec2 iPo;varying vec2 v1u;\":\"layout(location=0)in vec2 iPo;out vec2 v1u;\"\n ;hV+=j+\"uniform float iTime;uniform vec4 iMouse;\"+a+\"void main(){v1u=iPo*.5+.5;gl_Position=vec4(iPo,0,1);}\"\n ;var b=w2?\"varying \"+gei('h')+\"gl_FragColor\":\"out vec4 outColor;in \"+gei('h')+\"outColor\"\n ;hF+=gei('e')+b+gei('i')\n ;m.bindBuffer(m.ARRAY_BUFFER,m.createBuffer())\n ;m.bufferData(m.ARRAY_BUFFER,new Float32Array([-1,3,0,0,0,0,3,-1,0,-1,-1,0]),m.DYNAMIC_DRAW)\n ;m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,m.createBuffer())\n ;m.bufferData(m.ELEMENT_ARRAY_BUFFER,new Uint16Array([2,3,0]),m.STATIC_DRAW)\n ;m.vertexAttribPointer(m.enableVertexAttribArray(vA),3,m.FLOAT,false,0,0)\n//;m.vertexAttribPointer(svp,2,m.FLOAT,false,0,0)\n ;var v=m.createShader(m.VERTEX_SHADER),f=m.createShader(m.FRAGMENT_SHADER)\n ;cs(v,hV,\"v\");cs(f,hF,\"f\")\n ;mS.mProgram=m.createProgram();var p=mS.mProgram;pc=p//alias\n ;m.attachShader(p,v);m.attachShader(p,f)\n ;m.linkProgram(p);cul(p,'iFrame');cul(p,'iTime');cul(p,'iMouse');cul(p,'iDate');cul(p,'iResolution')\n ;if(!m.getProgramParameter(p,m.LINK_STATUS))sh(lp,p);\n ;to=performance.now()\n ;fpsTo=performance.now()\n ;par.f++\n ;rAf();}\n</script><body onload=\"pIn()\"><canvas id=\"ID\"></canvas><div id=\"IF\"></div></body></html>\n    /**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llycDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 382], [4211, 4295, 4312, 4312, 4380], [4381, 4381, 4407, 4407, 4454], [4455, 4455, 4473, 4473, 4519], [5269, 5363, 5384, 5384, 5419], [5420, 5420, 5441, 5441, 5476], [5477, 5565, 5582, 5582, 5605], [5605, 5605, 5622, 5622, 5645], [5645, 5645, 5662, 5662, 5678], [6064, 6602, 6625, 6625, 6687], [6688, 6688, 6710, 6710, 6751], [6752, 6752, 6775, 6775, 6793], [6793, 6924, 6947, 6947, 6964], [6965, 6965, 6981, 6981, 6998], [7691, 7691, 7705, 7705, 7728], [7729, 7729, 7743, 7743, 7766], [7767, 7767, 7781, 7781, 7804], [9594, 10606, 10622, 10622, 10655], [10656, 10656, 10679, 10679, 10711], [10712, 10712, 10736, 10736, 10760], [10761, 10761, 10788, 10788, 10817], [10818, 10818, 10832, 10832, 10861], [10862, 10862, 10876, 10876, 10905], [11016, 11077, 11103, 11103, 11122], [11123, 11254, 11283, 11283, 11306], [11306, 11393, 11409, 11409, 11441], [11442, 11442, 11458, 11458, 11480], [11481, 11481, 11499, 11499, 11517], [11517, 11856, 11880, 11880, 11890], [11891, 11891, 11915, 11915, 11933], [11934, 11934, 11958, 11958, 11982], [11983, 11983, 12006, 12006, 12024], [12024, 12055, 12080, 12080, 12104], [12320, 12368, 12398, 12398, 12430], [12430, 12450, 12474, 12474, 12506], [12506, 12541, 12557, 12557, 12598], [12598, 12642, 12658, 12658, 12699], [12699, 12739, 12773, 12773, 12837], [12837, 12884, 12967, 12967, 13018], [13021, 13060, 13078, 13078, 13100], [13101, 13101, 13118, 13118, 13145], [13146, 13146, 13163, 13163, 13197], [13198, 13198, 13217, 13217, 13253], [13254, 13254, 13273, 13273, 13309], [13311, 13311, 13329, 13329, 13357], [13357, 13424, 13457, 13457, 13494], [13547, 13674, 13691, 13691, 13744], [13744, 13826, 13843, 13843, 13908], [13908, 13927, 13945, 13945, 13989], [13989, 14076, 14094, 14094, 14150], [14150, 14201, 14219, 14219, 14268], [14268, 14330, 14347, 14347, 14379], [14379, 14417, 14434, 14434, 14468], [14468, 14485, 14509, 14509, 14521], [14521, 14521, 14545, 14545, 14557], [14557, 14588, 14612, 14612, 14638], [14638, 14695, 14726, 14726, 14750], [14750, 14808, 14825, 14825, 14848], [14848, 14864, 14888, 14888, 14952], [14952, 15006, 15030, 15030, 15057], [15057, 15119, 15144, 15144, 15185], [15185, 15272, 15289, 15289, 15314], [15314, 15457, 15481, 15481, 15508], [15508, 15570, 15602, 15602, 15631], [15631, 15656, 15688, 15688, 15717], [15717, 15789, 15814, 15814, 15841], [15841, 15883, 15916, 15916, 15945], [15945, 16094, 16111, 16111, 16158], [16158, 16368, 16386, 16386, 16468], [16469, 16469, 16486, 16486, 16534], [16536, 16759, 16777, 16777, 16879], [16880, 16880, 16897, 16897, 16924], [16924, 16971, 16989, 16989, 17016], [17016, 17127, 17145, 17145, 17192], [17192, 17482, 17500, 17500, 17522], [17522, 18086, 18105, 18105, 18163], [18163, 18348, 18367, 18367, 18422], [18422, 18607, 18625, 18625, 18646], [18646, 18716, 18734, 18734, 18755], [18755, 19044, 19064, 19064, 19154], [19154, 19462, 19481, 19481, 19540], [19540, 19791, 19811, 19811, 19928], [19928, 20219, 20239, 20239, 20340], [20340, 20599, 20619, 20619, 20698], [20698, 20922, 20942, 20942, 20980], [20980, 21088, 21108, 21108, 21155], [21155, 21360, 21380, 21380, 21442], [21442, 21663, 21683, 21683, 21757], [21757, 21950, 21970, 21970, 22056], [22067, 22121, 22147, 22147, 22188], [22189, 22260, 22287, 22287, 22354], [22355, 22355, 22383, 22383, 22464], [22465, 22517, 22544, 22544, 22626], [22627, 22627, 22654, 22654, 22746], [22881, 22982, 23022, 23022, 23788], [23791, 24689, 24707, 24707, 24729], [24729, 25306, 25323, 25323, 25370], [25371, 25371, 25388, 25388, 25420], [25421, 25421, 25438, 25438, 25479], [25480, 25480, 25497, 25497, 25547], [25548, 26112, 26675, 26675, 26706], [26993, 26993, 27014, 27014, 27046], [27047, 27047, 27068, 27068, 27100], [27101, 27101, 27122, 27122, 27149], [27150, 28066, 28731, 28731, 28762], [28960, 28960, 29113, 29113, 29163], [29164, 29164, 29187, 29187, 29225], [29226, 29226, 29249, 29249, 29273], [29274, 29453, 29603, 29603, 29658], [30108, 31045, 31068, 31068, 31088], [31089, 31089, 31112, 31112, 31132], [31133, 31133, 31156, 31156, 31176], [31177, 31177, 31202, 31202, 31258], [31259, 31259, 31284, 31284, 31326], [31327, 31327, 31352, 31352, 31378], [31381, 31877, 31918, 31955, 32166], [32847, 33191, 33207, 33207, 33231], [33231, 33240, 33263, 33263, 33282], [33283, 33623, 33650, 33650, 33671], [33771, 34025, 34041, 34041, 34057], [34058, 34058, 34074, 34074, 34088], [34089, 34089, 34105, 34105, 34115], [34116, 34116, 34132, 34132, 34148], [34149, 34149, 34165, 34165, 34180], [34181, 34181, 34197, 34197, 34212], [34213, 34213, 34229, 34229, 34239], [35278, 35400, 35423, 35423, 35446], [35447, 35447, 35473, 35473, 35516], [35849, 35889, 35908, 35908, 35951], [35952, 35952, 35971, 35971, 36015], [36016, 36016, 36035, 36035, 36074], [36075, 36075, 36094, 36094, 36169], [36170, 36170, 36189, 36189, 36325], [36326, 36326, 36345, 36345, 36380], [36381, 36381, 36401, 36401, 36446], [36447, 36447, 36467, 36467, 36555], [36556, 36556, 36576, 36576, 36670], [36671, 36671, 36691, 36691, 36907], [36908, 37133, 37151, 37151, 37219], [37220, 37220, 37284, 37284, 37642], [37642, 38109, 38124, 38124, 38155], [38155, 38231, 38246, 38246, 38277], [38278, 38278, 38295, 38295, 38327], [38328, 38328, 38349, 38349, 38378], [38379, 38379, 38401, 38401, 38426], [38427, 38427, 38450, 38450, 38462], [38463, 38463, 38488, 38488, 38529], [38531, 39593, 39609, 39609, 39650], [39651, 39711, 39736, 39736, 39777], [39778, 39869, 39902, 39902, 39934], [40130, 40376, 40398, 40398, 40429], [40429, 40484, 40506, 40506, 40537], [40537, 40592, 40612, 40612, 40645], [40645, 40675, 40695, 40695, 40725], [40726, 40768, 40791, 40791, 40823], [40824, 40824, 40847, 40847, 40879], [41145, 41145, 41164, 41164, 41223], [41224, 41224, 41250, 41250, 41354], [41527, 41527, 41546, 41546, 41570], [44437, 44784, 44803, 44803, 44837], [44838, 44838, 44857, 44857, 44891], [44892, 44892, 44911, 44911, 44958], [44958, 44982, 45002, 45002, 45053], [45053, 45077, 45097, 45097, 45124], [45124, 45154, 45174, 45174, 45220], [45220, 45249, 45270, 45270, 45298], [45514, 45891, 46021, 46021, 46669], [46670, 46816, 46837, 46837, 46865], [46866, 46866, 46998, 46998, 47937], [47939, 48237, 48262, 48262, 48412], [48413, 48413, 48448, 48448, 48573], [48574, 48574, 48634, 48634, 48807], [48809, 48943, 48980, 48980, 49032], [49033, 49033, 49077, 49077, 49156], [49157, 49157, 49201, 49201, 49317], [49318, 49807, 49845, 49845, 49890], [49891, 49891, 49929, 49929, 49973], [49974, 49974, 50033, 50033, 50109], [50110, 50110, 50151, 50151, 50228], [50229, 50229, 50268, 50268, 50425], [50426, 50426, 50466, 50466, 50609], [50721, 50721, 50740, 50740, 50924], [50925, 51362, 51388, 51388, 51453], [51930, 52494, 52562, 52562, 52786], [52787, 52911, 53005, 53005, 53509], [53509, 53574, 53627, 53627, 53698], [53698, 54259, 54277, 54277, 54320], [54321, 54457, 54483, 54592, 54836], [54837, 54929, 55024, 55024, 55938], [55938, 56017, 56112, 56112, 57002], [57083, 57313, 57355, 57355, 57414], [57438, 57438, 57479, 57479, 57725], [57725, 57865, 57898, 57898, 58295], [58295, 58355, 58380, 58380, 59040], [59146, 59259, 59289, 59289, 59321], [59321, 59380, 59411, 59411, 59446], [59446, 59509, 59531, 59531, 59556], [59557, 59557, 59580, 59580, 59606], [59694, 59694, 59833, 59833, 59901], [59902, 59902, 59923, 59923, 60197], [60198, 60314, 60370, 60370, 60569], [61005, 61211, 61246, 61246, 61282], [61285, 61504, 61524, 61524, 61553], [61554, 61554, 61574, 61574, 61603], [61604, 61604, 61625, 61625, 61650], [61651, 61651, 61671, 61671, 61700], [61701, 61701, 61721, 61721, 61750], [61751, 61751, 61772, 61772, 61797], [61798, 61798, 61818, 61818, 61847], [61848, 61848, 61868, 61868, 61897], [61898, 61898, 61919, 61919, 61944], [61945, 62583, 62606, 62606, 62623], [62623, 62623, 62644, 62644, 62665], [62666, 62666, 62689, 62689, 62706], [62706, 62706, 62727, 62727, 62748], [62749, 62749, 62772, 62772, 62789], [62789, 62789, 62810, 62810, 62831], [62832, 62832, 62855, 62855, 62872], [62872, 62872, 62893, 62893, 62914], [63019, 63161, 63187, 63187, 63205], [63206, 63206, 63233, 63233, 63253], [63254, 63254, 63281, 63281, 63305], [63306, 63306, 63332, 63332, 63360], [63361, 63361, 63386, 63386, 63400], [63400, 64015, 64095, 64095, 64259], [64260, 64260, 64290, 64290, 64454], [65154, 65261, 65287, 65287, 65412], [65833, 66027, 66044, 66044, 66092], [66495, 66849, 66884, 66884, 66918], [66919, 66948, 66983, 66983, 67018], [67018, 67047, 67082, 67082, 67117], [67117, 67147, 67168, 67168, 67190], [67575, 67685, 67801, 67801, 69705], [69707, 69707, 69811, 69811, 71399], [71400, 71400, 71475, 71475, 71573], [71574, 71667, 71702, 71702, 71756], [71833, 72280, 72305, 72305, 72399], [72400, 72433, 72460, 72460, 72528], [72530, 72638, 72745, 72769, 73250], [73251, 73251, 73285, 73285, 73334], [73337, 73337, 73445, 73445, 73508], [73509, 73509, 73534, 73534, 73592], [73594, 73719, 73744, 73744, 73820], [73822, 73822, 73846, 73846, 73890], [73891, 73891, 73915, 73915, 74052], [74052, 74127, 74151, 74151, 74212], [74214, 74214, 74238, 74238, 74629], [74631, 74631, 74660, 74660, 74703], [74708, 74708, 74730, 74730, 75722], [76994, 77066, 77114, 77114, 77189], [77433, 77614, 77669, 77669, 77825], [77826, 77826, 77881, 77881, 78037], [78038, 78038, 78093, 78093, 78121], [78169, 78169, 78205, 78205, 78229], [78230, 78450, 78471, 78471, 79672], [79870, 79942, 80015, 80015, 80129], [80131, 80131, 80190, 80190, 80350], [80611, 80651, 80705, 80705, 80818], [80819, 80819, 80904, 80904, 81078], [81079, 81079, 81156, 81156, 81382], [81383, 81412, 81512, 81512, 82204], [82205, 82205, 82296, 82296, 82870], [82873, 83922, 84031, 84031, 84280], [84283, 84344, 84440, 84440, 85319], [85322, 86465, 86575, 86575, 87397], [87627, 87672, 87752, 87937, 88811], [88811, 88854, 88898, 88898, 89150], [89152, 89152, 89224, 89344, 89688], [89778, 89959, 90005, 90005, 90255], [90256, 90256, 90288, 90288, 90329], [90330, 90330, 90362, 90362, 90463], [90516, 90516, 90537, 90592, 90684], [90685, 90685, 90714, 90714, 90738], [90739, 90739, 90769, 90769, 90795], [90796, 90850, 90872, 90872, 90895], [90896, 91020, 91049, 91049, 91118], [91119, 91119, 91148, 91148, 91203], [91379, 91573, 91611, 91611, 91644], [91722, 91781, 91873, 91873, 92006], [92010, 92156, 92182, 92182, 92221], [92222, 92222, 92249, 92249, 92278], [92279, 92402, 92427, 92427, 92450], [92451, 92451, 92477, 92477, 92511], [92512, 92586, 92611, 92693, 92762], [92763, 92763, 92789, 92789, 92817], [92818, 92936, 92961, 92961, 93174], [93174, 93193, 93219, 93219, 93247], [93248, 93356, 93387, 93387, 93615], [93615, 93637, 93662, 93662, 93691], [93692, 93774, 93809, 93809, 94168], [94168, 94190, 94224, 94224, 94256], [94257, 94281, 94317, 94317, 94372], [94377, 94418, 94437, 94437, 94573], [94574, 94574, 94602, 94602, 95000], [95053, 95053, 95130, 95130, 95222], [95224, 95224, 95269, 95269, 95311], [97195, 97217, 97260, 97260, 97363], [97364, 97364, 97409, 97409, 97559], [97604, 97604, 97885, 97885, 98049], [98103, 98103, 98494, 98494, 98582], [98583, 98583, 98620, 98620, 98749], [98786, 98786, 99026, 99026, 99166], [99167, 99167, 99212, 99212, 99516], [99517, 99527, 99572, 99572, 99622], [99623, 99623, 99667, 99667, 99706], [99707, 99707, 99760, 99760, 99814], [99815, 99815, 99867, 99867, 99908], [99951, 100107, 100130, 100130, 100160], [100160, 100198, 100224, 100224, 100872], [100874, 100874, 100901, 100901, 101670], [101673, 101688, 101708, 101708, 101783], [101784, 101784, 101804, 101804, 101879], [101880, 101880, 101900, 101900, 101923], [101924, 101924, 101944, 101944, 101967], [101968, 101985, 102002, 102002, 102418], [102619, 102762, 102860, 102860, 103088], [103089, 103304, 103345, 103345, 103584], [103585, 103585, 103666, 103666, 103965], [103968, 103968, 104024, 104024, 104158], [104161, 104246, 104269, 104269, 104319], [104320, 104320, 104344, 104344, 104385], [104386, 104386, 104403, 104403, 104426], [104429, 104528, 104599, 104599, 105450], [105452, 105452, 105476, 105476, 106262], [106265, 106265, 106332, 106332, 106705], [106707, 106707, 106735, 106735, 106778], [106780, 106780, 106800, 106800, 108127], [108130, 108130, 108151, 108151, 108621], [108624, 108624, 108667, 108667, 109233], [109235, 109261, 109294, 109326, 110218], [110219, 110219, 110278, 110278, 110466], [110471, 110471, 110506, 110506, 110646], [110648, 110648, 110715, 110715, 111596], [111598, 111598, 111634, 111634, 112272], [112274, 112274, 112300, 112300, 112327], [112329, 112329, 112346, 112346, 113356], [113358, 113648, 113671, 113671, 113823], [113825, 113932, 114019, 114019, 115271], [115272, 115470, 115556, 115556, 115847], [115851, 115851, 115886, 115886, 116568]], "test": "error"}
{"id": "llyyDG", "name": "Dot Motion", "author": "yx", "description": ".", "tags": ["pattern"], "likes": 23, "viewed": 776, "published": "Public API", "date": "1537470086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\nconst float RADIUS = .1;\nconst float SIZE = 7.;\nconst float BLURSTEPS = 30.;\nconst float SPEED = 1.5;\nconst bool SQUARE = false;\nconst bool RING = true;\nconst float RINGRADIUS = .2;\nconst float RINGTHICKNESS = .025;\nconst bool SMOOTH = true;\nconst bool RIPPLE = false;\nconst float RIPPLESCALE = .2;\n\nvec2 rotate(vec2 p,float a)\n{\n    return cos(a)*p+sin(a)*vec2(-p.y,p.x);\n}\n\nfloat noise(float x)\n{\n    return fract(x*7.3737);\n}\n\nfloat tick(float t)\n{\n    if (SMOOTH)\n    {\n    \t// multiple smoothsteps to get a more snappy motion\n    \tt = smoothstep(0.,1.,t);\n    \tt = smoothstep(0.,1.,t);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= SIZE;\n    \n    float time = iTime * SPEED;\n    \n    if (RIPPLE)\n    {\n    \ttime -= length(uv)*RIPPLESCALE;\n    }\n\n    float color = 0.;\n    \n    vec2 baseUV = uv;\n    for (float i = 0.; i < BLURSTEPS; ++i)\n    {\n        // offset time by a fraction of a frame\n        time += (SPEED/BLURSTEPS)/60.;\n        \n        uv = baseUV;\n        vec2 cell = floor(uv+.5);\n\n        float t = tick(fract(time));\n\n        float mode = noise(floor(time))*7.;\n        float dir = step(.01,mod(mode,.02))*2.-1.;\n        t *= dir;\n        \n        if (mode < 1.)\n        {\n            // vertical shear\n            uv.y += cell.x * t;\n        }\n        else if (mode < 2.)\n        {\n            // horizontal shear\n            uv.x += cell.y * t;\n        }\n        else if (mode < 3.)\n        {\n            // rotate\n            uv = rotate(uv, t*PI*.5);\n        }\n        else if (mode < 4.)\n        {\n            // vertical interleaving\n            uv.y += (mod(cell.x,2.)*2.-1.) * t;\n        }\n        else if (mode < 5.)\n        {\n            // horizontal interleaving\n            uv.x += (mod(cell.y,2.)*2.-1.) * t;\n        }\n        else if (mode < 6.)\n        {\n            // vertical translation\n\t\t\tuv.y += t;\n        }\n        else if (mode < 7.)\n        {\n            // horizontal translation\n\t\t\tuv.x += t;\n        }\n\n        // modulo space to get the grid\n        uv = fract(uv+.5)-.5;\n\n        // signed distance\n        float d = 0.;\n        if (RING)\n        {\n            d = RINGTHICKNESS-abs(length(uv)-RINGRADIUS);\n        }\n        else\n        {\n\t\t\td = RADIUS-length(uv);\n        }\n        \n        // smoothed edge\n        color += smoothstep(.0,2.*SIZE/iResolution.y,d);\n    }\n    \n    // divide to account for multiple blur samples\n    color /= BLURSTEPS;\n    \n    // gamma correction\n    color = pow(color, .45);\n    \n    // cull the sides with a soft falloff\n    if (SQUARE)\n    {\n    \tcolor *= smoothstep(SIZE*.5+.25,SIZE*.5-.25,max(baseUV.x,-baseUV.x));\n    }\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyyDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 321, 350, 350, 395], [397, 397, 419, 419, 449], [451, 451, 472, 472, 633], [635, 635, 692, 692, 2800]], "test": "valid"}
{"id": "llyyDy", "name": "Sphere Project- Northern Lights", "author": "rlarp", "description": "Sphere project inspired by the northern lights. ", "tags": ["light", "spheres", "education", "school", "homework", "project", "northernlights", "northern"], "likes": 1, "viewed": 392, "published": "Public", "date": "1537492806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\nfloat map(vec3 p)\n{\n    float radius = 0.; // or change to 0.1 for carpet like look\n    vec3 q = fract(p*=2.5) * 1.5 - 0.5;\n    \n    return sphere(q, radius);\n}\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.2;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d * 0.1;\n        }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *3.-2.; \n    uv.x *= iResolution.y/iResolution.x;\n    \n    vec3 color = vec3(sin(iTime), 0.0, cos(iTime));\n    \n   \tfloat FOV = 10.;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    ray.yx *= rot(iTime*0.2);\n    //ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(1.5, 0.75, 0.0);\n    float t = trace(origin, ray);\n    \n    float expFog = 9. / (t*t*0.1);\n    \n    vec3 fc = vec3(expFog);\n\n    \n    fragColor = vec4(cos(fc+color),0.0);\n    \n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 123, 123, 154], [156, 156, 175, 175, 316], [318, 318, 353, 353, 513], [515, 515, 572, 572, 1107]], "test": "valid"}
{"id": "llyyWD", "name": "Neon spiral", "author": "murazaki", "description": "neon effect over spiral", "tags": ["retro", "snippets"], "likes": 5, "viewed": 442, "published": "Public", "date": "1536243788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy,\n         pos = (2.*fragCoord - R ) / min(R.x,R.y);\n    vec3 color = vec3(0.0);\n    \n    float factor = 30.;\n    float nb_spirals = 3.;\n    \n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n\n    float f = mod(a, 2. * PI / nb_spirals) / factor;\n    \n    float looped_time = fract(iTime / 4.);\n    \n    float thickness = 12./min(R.x,R.y);\n\n    float spiral = smoothstep(thickness / 2., 0., abs(mod(r - f, 2. * PI / (nb_spirals * factor)) - thickness / 2.));\n    \n    float circle = smoothstep(0.8 + 0.02, 0.8, r);\n    \n    float green_loop_time = 1. / 4.;\n    \n    vec3 funky_color = vec3(cos(3. * a + looped_time * 2. * PI),\n                            abs(mod(r - looped_time, green_loop_time) - green_loop_time / 2.) / green_loop_time,\n                            1. - sin(2. * a + looped_time * 2. * PI));\n\n    color = spiral * circle * funky_color;\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 83, 83, 1012]], "test": "valid"}
{"id": "ltBSzm", "name": "Color interpolation on triangles", "author": "nide", "description": "Left: quad, right: quad from 2 triangles.\nRight side shows the result of interpolation on 3 barycentric coordinates. Only 3 colors are taken into consideration for each of the triangles.\nJust something beginners in graphics programming stumble across", "tags": ["triangles", "beginner", "opengl"], "likes": 1, "viewed": 161, "published": "Public", "date": "1537862162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat bilinearTriangle(vec2 texcoord, float sample0, float sample1, float sample2, float sample3)\n{\n    float x1 = texcoord.x;\n    float x2 = 1.0 - texcoord.x;\n    float y1 = texcoord.y;\n    float y2 = 1.0 - texcoord.y;\n    \n    float fsample = 0.0;\n    float side = step(1.0, texcoord.x+texcoord.y);\n    float side1 = 1.0-side;\n    \n    fsample += sample2*x2*y1*(side1);\n    fsample += sample0*x2*y2*(side1);\n    fsample += sample1*x1*y2*(side1);\n    \n    fsample += sample3*x1*y1*(side);\n    fsample += sample2*x2*y1*(side);\n    fsample += sample1*x1*y2*(side);\n    return fsample;\n}\nfloat bilinearQuad(vec2 texcoord, float sample0, float sample1, float sample2, float sample3)\n{\n    float x1 = texcoord.x;\n    float x2 = 1.0 - texcoord.x;\n    float y1 = texcoord.y;\n    float y2 = 1.0 - texcoord.y;\n    \n    float fsample = 0.0;\n    \n    fsample += sample3*x1*y1;\n    fsample += sample2*x2*y1;\n    fsample += sample0*x2*y2;\n    fsample += sample1*x1*y2;\n    \n    return fsample;\n}\n\nfloat isInside(vec2 pos, vec2 bottomLeft, vec2 topRight) {\n    vec2 v = step(bottomLeft, pos)-step(topRight, pos);\n    return v.x*v.y;\n}\nvoid quad(in vec2 fragCoord, in vec2 uv, vec2 pos, float size, out float inside, out vec2 quadUv) {\n    float aspectRatio = iResolution.y/iResolution.x;\n    vec2 vsize = vec2(size*aspectRatio, size);\n    vec2 v0 = pos + vsize;\n    quadUv = (uv-pos) / vsize;\n    inside = isInside(uv, pos, v0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y/iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float inside1;\n    vec2 quadUV1;\n    quad(fragCoord, uv, vec2(0.1, 0.25), 0.5, inside1, quadUV1);\n    float inside2;\n    vec2 quadUV2;\n    quad(fragCoord, uv, vec2(0.6, 0.25), 0.5, inside2, quadUV2);\n    \n    \n    float timebase = iTime;\n    float time = iTime*2.15;\n    float time2 = iTime*0.55;\n    float sampleTL = clamp(sin(time+0.0), 0.0, 1.0);\n    float sampleTR = clamp(sin(time+3.14*0.5), 0.0, 1.0);\n    float sampleBR = clamp(sin(time+3.14*0.5*2.0), 0.0, 1.0);\n    float sampleBL = clamp(sin(time+3.14*0.5*3.0), 0.0, 1.0);\n    \n    \n    float interpolated1 = bilinearQuad(quadUV1, sampleBL, sampleBR, sampleTL, sampleTR);\n    float interpolated2 = bilinearTriangle(quadUV2, sampleBL, sampleBR, sampleTL, sampleTR);\n    \n    vec3 background = vec3(0,0,1);\n    vec3 outColor = mix(background, vec3(interpolated1), inside1); \n    outColor = mix(outColor, vec3(interpolated2), inside2); \n    \n\tfragColor = vec4(outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 100, 100, 586], [587, 587, 682, 682, 984], [986, 986, 1044, 1044, 1122], [1123, 1123, 1222, 1222, 1418], [1419, 1419, 1476, 1476, 2509]], "test": "valid"}
{"id": "ltGcDc", "name": "Hot Plasma", "author": "Teqqles", "description": "Experiment for illustrating liquid motion with generated colour", "tags": ["plasma", "fluid"], "likes": 8, "viewed": 307, "published": "Public", "date": "1537964121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on oil move https://www.shadertoy.com/view/MtGcD3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfor(int i=1;i<10;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.6/float(i)*sin(float(i)*p.y+iTime+0.3*float(i))+1.0;\n\t\tnewp.y+=0.6/float(i)*sin(float(i)*p.x+iTime+0.3*float(i+10))-1.4;\n\t\tp=newp;\n\t}\n\tvec3 col=vec3(1.0,1.0-(sin(p.y)),sin(p.x+p.y));\n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 116, 116, 457]], "test": "valid"}
{"id": "ltGcDy", "name": "Oscillation of a Rope", "author": "Shadeyboi", "description": "Based off of sphere project, working with colors instead of the shapes themselves.", "tags": ["beginner"], "likes": 1, "viewed": 81, "published": "Public", "date": "1537493715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), -cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n    pMod3(q, vec3(.75, .6, .15));\n    pMod3(q, vec3(0.9, 1., 0.6));\n    \n    pMod1(p.x, 1.);\n    \tq.y = abs(sin(iTime))-0.1;\n    \n    float s1 = sphere(p, .65); \n    float s2 = sphere(q, .5);\n    float s3 = sphere(q, 1.);\n    \n    float disp = min(0.5 * (sin(p.x/3.) *\n                       sin(p.y) *\n                       (sin(p.z*10.)) ), 50.);\n    \ts1 -= disp;\n    \ts2 *= disp;\n    \ts3 *= disp;\n    \t//s1 -= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2); // Union\n    float df2 = max(s2, s1); // Intersection\n    float df3 = max(max(s1, s3), min(s1, s2)); // Difference\n    \n    return df3;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*0.3;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3((sin(iTime) * .3), -abs(cos(iTime))* .25, .5);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    ray.xy *= rot(iTime);\n    //ray.yz *= abs(sin(iTime));\n    \n    \n    vec3 origin = vec3(iTime, sin(iTime)*.1, -1.3);\n    float t = trace(origin, ray);\n    \n    float expFog = sin(iTime) / (t* t* 0.4);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    //fragColor = vec4((fc+color),1.0);\n    fragColor = vec4(tan(fc+color),sin(iTime)*.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 87], [89, 89, 128, 128, 198], [200, 200, 237, 237, 280], [282, 282, 317, 317, 349], [352, 352, 371, 371, 990], [993, 993, 1028, 1028, 1185], [1188, 1188, 1245, 1245, 1862]], "test": "error"}
{"id": "ltGyW3", "name": "Question: Sphere Base", "author": "pyBlob", "description": "base shader for testing texturing of spheres, suggestions for making it simpler are welcome.\nQuestion: is it possible to use \"Cube A\" to refer to itself for simulations like it is possible with \"Buffer A-D\"?", "tags": ["sphere"], "likes": 6, "viewed": 449, "published": "Public API", "date": "1537914348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 Q(vec3 v)\n{\n    float a = length(v) + 1e-3;\n    return vec4(v / a * sin(a * .5), cos(a * .5));\n}\n\nvec3 R(vec4 q, vec3 v)\n{\n    vec3 t = 2. * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 view(vec3 v)\n{\n    v = R(Q(vec3(sin(iTime * 1.) * .5, 0, 0)), v);\n    v = R(Q(vec3(0, iTime * .1, 0)), v);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n\t\n    vec3 p = view(vec3(0, 0, -3));\n    vec3 v = view(normalize(vec3(uv, 1)));\n\n    for (int i=0 ; i<60 ; i++)\n        p += v * length(p) - v;\n    p = normalize(p);\n    \n    vec3 col = vec3(0);\n    p = cos(p * 3.14e1 + iTime);\n    col = vec3(p.x*p.y*p.z);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 101], [103, 103, 127, 127, 206], [208, 208, 227, 227, 335], [337, 337, 394, 394, 753]], "test": "valid"}
{"id": "ltKcDc", "name": "CircleCheck", "author": "kanechan", "description": " Based on the shader Cellular Noise from The Book of Shader (https://thebookofshaders.com/12/)", "tags": ["check"], "likes": 0, "viewed": 95, "published": "Public", "date": "1538050055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nfloat randomCheck() {\n    return 0.2 + 0.8*abs(cos(iTime*0.1));\n}\n\nfloat randomRadius( vec2 p ) {\n    return 0.1 * cos(p.x) + 0.1 * sin(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = 20.0 * fragCoord/iResolution.y;\n   \n    vec2 floor_st = floor(st);\n    vec2 frac_st = fract(st);\n    \n    float randCheck = randomCheck();\n    float randRadius = randomRadius( floor_st );\n    float sumRand = randCheck + randRadius;\n    \n    fragColor = vec4(0.9,0.4,0.,1.);\n    \n    for(int y = -1; y <= 1; y++){\n    \tfor(int x = -1; x <= 1; x++){\n            \n    \t\tvec2 neighbor = vec2(x,y);\n            vec2 idx = floor_st + neighbor;\n            vec2 pointInCell = random2(idx);\n            \n            vec2 movingPoint = 0.5 + 0.5*sin(iTime*0.1*log(iTime*iTime)+6.2831*pointInCell);\n            \n            vec2 vecDiff = movingPoint + neighbor - frac_st;\n            float dist = length(vecDiff);\n            \n            vec4 newColor = vec4(sumRand,sumRand*0.1,sumRand*0.3,1.);\n                \n            if(mod(idx.x, 4.) == 0.0 && mod(idx.y, 8.) == 0.){\n                    \n            \tnewColor = cos(iTime + idx.x + idx.y)+vec4(sumRand,sumRand*0.1,1.-sumRand*0.1,1.);\n            \n            } else if(mod(idx.x, 7.) == 0.0 && mod(idx.y, 3.) == 0.){\n                    \n              \tnewColor = cos(iTime+ idx.x + idx.y)+vec4(sumRand*0.7,sumRand*0.1,sumRand*0.5,1.);\n            }\t\n            \n             float mixAlpha = 0.0;\n            if(dist - sumRand < 1.0){\n                mixAlpha = dist - randCheck + 0.2;\n            }\n            else mixAlpha = dist - sumRand;\n            \n            \n            fragColor = mix( fragColor, newColor, smoothstep(20./iResolution.y,-20./iResolution.y,mixAlpha));\n         }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [118, 118, 139, 139, 183], [185, 185, 215, 215, 261], [263, 263, 320, 320, 1886]], "test": "valid"}
{"id": "ltKcDt", "name": "tiny crepuscularity", "author": "ollj", "description": "this tries to make believable crepuscularity with as few hyperplanes as possible, to a point where buffering a texture for the hyperplanes becomes a hassle that you may not bother with, so you get decent bufferless crepuscularity.", "tags": ["fog", "lighthouse", "crepuscularity"], "likes": 6, "viewed": 443, "published": "Public API", "date": "1538225641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//goal is to overlap noise/bayer in a way \n//that only 3-5 hyperplanes are needed for believabple crepuscularity.\n//by doing interpolation by dithering a gradient of the tapped source.\n//and hoping that no distracting hyperplane [moire] patterns EVER emerge\n//- the last one is the tricky part\n//, done by scaling the hyperplane exposure parametrically\n//, so that moire patterns bet blended into each other over parameters\n//, to make most moise patterns blur out, even wioth only 3 planes.\n//, and by rotating it a bit.\n\n//todo, learn how to evade noticable moire , by applying Galois-fields of\n//https://www.shadertoy.com/view/XsScD1\n//that clearly show moire in some cases, but less noticable moire in other cases\n\n//the average or min or max of 3 planes usually has\n//stronger moire than averaging 8 or more planes.\n\n//scaling brighness/exposure/gamma/decay nicely is a subset of that issue.\n\n//green shapes are occluders, the oval is a bit transparent\n//the purple circle is a negative-occluder, equivalent to an emmitter.\n\n/*\nad 2d crepuscular occlusion dither bayer eclipse\n//this is a very reduced version,for performance\n\nparent:https://www.shadertoy.com/view/4dyXWy\nself:https://www.shadertoy.com/view/ltsyWl\n\nInstead of reading from a bitmap,this uses one of 2 bayer matrix generators.\nParents bufferA is a subroutine here:BuffA.mainImage()<-BA()\n-no buffers(Bayer matrix bitmap is very optional)\n-generalize to be more parametric,maybe?\n*/\n#define DITHER//Dithering toggle\n#define ViewZoom 3.\n//crepuscular hyperslices ,multiplier to [n] of O(n)complexity\n#define iterCrep 3.\n//1.-fog\n#define DECAY   .8\n//anti-foggyness(is a quadratic fog cunction?)should be ~=DECAY\n#define WEIGHT   .6\n//(1-range)to spread hyperslices overshould be(length(lightSource-surface))\n#define DENSITY  .9\n//final multiplier\n#define EXPOSURE .5\n//min(iResolution.x,iResolution.y)\n#define fsaa min(iResolution.x,iResolution.y)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n//using 2 buffers,1 for a bayer matrix,one for the luminosity that gets multi sampled,would be faster\n//this is a bufferless version,calculating the same bayer matrix and luminosity many times.\n/*#define iterBayerMat 1\n#define bayer2x2(a)(4-(a).x-((a).y<<1))%4\nfloat GetBayerFromCoordLevel(vec2 pixelpos){ivec2 p=ivec2(pixelpos);int a=0//https://www.shadertoy.com/view/XtV3RG\n ;for(int i=0;i<iterBayerMat;i++){a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i);}return float(a)/float(2<<(iterBayerMat*2-1));}*///integer_bayer\nmat2 r2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\nfloat bayer2(vec2 a,vec2 n){a=mod(a*r2((sqrt(5.)*.5+.5)),iResolution.x)//i prefer the float_bayer matrix for being more transformable.\n;return fract(dot((a+n.y)*r2(n.x+n.x),a*vec2((sqrt(5.)*.5+.5),(sqrt(5.)*.5-.5))));}\nfloat bayer4(vec2 a,vec2 n){return bayer2(.5*a,n)*.25+bayer2(a,n);}float bayer8(vec2 a,vec2 n){return bayer4(.5*a,n)*.25+bayer2(a,n);}\nfloat bayer16(vec2 a,vec2 n){return bayer4(.25*a,n)*.0625+bayer4(a,n);}float bayer32(vec2 a,vec2 n){return bayer8(.25*a,n)*.0625+bayer4(a,n);}\n//float bayer64(vec2 a,vec2 n){return bayer8(.125*a,n)*.015625+bayer8(a,n);}\nfloat circle(vec2 p,float r){return smoothstep(r+.01,r-.01,length(p));}\nvec3 sun(vec2 uv){\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n    \n ;vec2 p=fra(mouse.zw)*.666;if(iMouse.z<=0.)p=vec2(sin(iTime),sin(iTime*.5)*.5)\n ;float di=distance(uv,p);vec3 res;res.x=di<=.3333?sqrt(1.-di*3.):0.;res.yz=p\n ;res.y/=(iResolution.x/iResolution.y);res.yz=(res.yz+1.)*.5;return res;}\nvec4 BA(in vec2 uv){uv=uv*2.-1.;float aspect=iResolution.x/iResolution.y;uv.x*=aspect;vec2 mousep=(iMouse.xy/iResolution.xy)*2.-1.;mousep.x*=aspect\n ;float o=.3-min(length(uv-vec2(.7,0)),.8-(length(uv-vec2(.6,.1))))//circle with non-central hole\n ;o=min(o,abs(abs((.2-abs(length(uv-mousep))))-.03)-.01)//mouse cursor circle\n ;o=smoothstep(.001,-.001,o)\n ;o=max(o,smoothstep(.001,-.001,length(uv+vec2(.5,.2))+length(uv+vec2(.5,-.2))-.6)*.5)//oval is its own smoothstep,because it is semi-transparent\n ;o-=smoothstep(.001,-.001,length(uv-vec2(0,.7))-.2)//negative occluder is an emmitterbut this union cancels out 2 types to 0\n ;vec3 light=min(sun(uv),1.);float col=max(light.x-o,0.)\n ;return vec4(col,o,light.yz);}\nvoid mainImage(out vec4 o,vec2 I){\n #ifdef DITHER\n ;float h=bayer32(I,iMouse.xz+1./iResolution.y)//larger base-bayer-matrix (with offset)\n ;vec2 J=I\n #endif\n ;I/=iResolution.xy;vec4 c=BA(I);vec2 d=(I-c.zw)*(DENSITY/iterCrep);float l=1.,n=c.x,obj=c.y\n ;for(float i=0.;i<iterCrep;i++){I-=d\n  #ifdef DITHER\n  ;float h2=bayer8(J*.5-I,iMouse.yw)//resample a small bayer matrix [iterCrep] times,without offset,to lerp,to de-patternize\n  ;float s=BA(I+d*mix(h,h2,i/iterCrep)).x\n  #else\n  ;float s=BA(I).x\n  #endif\n  ;s*=l*WEIGHT;n+=s;l*=DECAY;}\n ;o=vec4(vec3(.5,.7,.1)*obj/3.+n*EXPOSURE,1.0);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 382], [2863, 2879, 2896, 2896, 2943], [2944, 2944, 2972, 2972, 3162], [3163, 3163, 3191, 3191, 3230], [3230, 3230, 3258, 3258, 3297], [3298, 3298, 3327, 3327, 3369], [3369, 3369, 3398, 3398, 3440], [3441, 3518, 3547, 3547, 3589], [3590, 3590, 3608, 3608, 3883], [3884, 3884, 3904, 3904, 4597], [4598, 4598, 4632, 4632, 5184]], "test": "valid"}
{"id": "ltKcW1", "name": "btree", "author": "dahart", "description": "Not a btree :P, a zooming binary tree, golfed, probably badly. (edit: very badly by me, but fabulously by others in the comments.) Inspired by jt's polar sine tree https://www.shadertoy.com/view/ll2XDV", "tags": ["2d", "tree", "zooming", "binarytree", "golf", "btree"], "likes": 11, "viewed": 216, "published": "Public", "date": "1536117644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Fabrice's 9/6 golfed version. 176 chars(!)\n//*\nvoid mainImage(out vec4 o, vec2 c) { \n    vec2 t = fract(iTime) *c/c,\n         w = 2. * c/iResolution.xy - 1.,\n         l = w * w * 5. - t,\n         m = exp2( ceil(l) ) * ++t;\n    o += ( m/5e2 / abs( sign(w = fract(w.x * m) - .5)/4. * smoothstep(0., 1., fract(l)) - w) ).y; }\n//*/\n\n\n// Fabrice's 9/5 golfed version is SO much smaller than mine!\n// +edits by @GregRostami 186 chars\n/*\n#define mainImage(o,c)                            \\\n    vec2 w = 2. * c/iResolution.xy - 1.;          \\\n    float t = fract(iTime),                       \\\n          l = w.y * w.y * 5. - t,                 \\\n          m = exp2( ceil(l) ) * ++t,              \\\n          f = fract(w.x * m);                     \\\n    o += 1. - abs( .5-f + sign(f-.5)/4. * smoothstep(0., 1., fract(l)) ) / m /.01\n//*/\n\n\n// My original version. 278 chars. So fat.\n/*\n#define f fract\n#define s smoothstep\nvoid mainImage( out vec4 o, in vec2 c ) \n{\n    vec2 w = 2.1*(c/iResolution.xy - .5);\n    float t = f(iTime), T = t + 1.,\n    \tu = w.x*T, v = w.y * w.y - t / 4.,\n     \tl = v * 4., m = pow(2., floor(l) + 1.), b = u * m, \n        x = (floor(b) + .5 + .25 * sign(f(b) - .5) * s(0., 1., f(l))) / m / T,\n        d = abs(x - w.x) - .01;\n    o = o-o+s(0., -.01, d);\n}\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKcW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 51, 87, 87, 326]], "test": "valid"}
{"id": "ltKcWh", "name": "More Accurate Iridescence", "author": "JuliaPoo", "description": "Slightly more accurate. Thickness of film varies through cube. Did not account for interference from the reflection due to the 2 light sources, and function still not dependent on reflected ray.", "tags": ["raytracing", "cube", "iridescence"], "likes": 7, "viewed": 682, "published": "Public API", "date": "1536079948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///////////////////////////////Iridescence/////////////////////////////////\n// based on the picture in                                               //\n// http://home.hiroshima-u.ac.jp/kin/publications/TVC01/examples.pdf     //\n// Copied from paniq: https://www.shadertoy.com/view/Ms33zj              //\n///////////////////////////////////////////////////////////////////////////\nvec2 mp;\n\n// ratio: 1/3 = neon, 1/4 = refracted, 1/5+ = approximate white\nvec3 physhue2rgb(float hue, float ratio) {\n    return smoothstep(\n        vec3(0.0),vec3(1.0),\n        abs(mod(hue + vec3(0.0,1.0,2.0)*ratio,1.0)*2.0-1.0));\n}\n        \nvec3 iridescence (float angle, float thickness) {\n    // typically the dot product of normal with eye ray\n    float NxV = cos(angle);\n    \n    // energy of spectral colors\n    float lum = 0.05064;\n    // basic energy of light\n    float luma = 0.01070;\n    // tint of the final color\n    //vec3 tint = vec3(0.7333,0.89804,0.94902);\n    vec3 tint = vec3(0.49639,0.78252,0.88723);\n    // interference rate at minimum angle\n    float interf0 = 2.4;\n    // phase shift rate at minimum angle\n    float phase0 = 1.0 / 2.8;\n    // interference rate at maximum angle\n    float interf1 = interf0 * 4.0 / 3.0;\n    // phase shift rate at maximum angle\n    float phase1 = phase0;\n    // fresnel (most likely completely wrong)\n    float f = (1.0 - NxV) * (1.0 - NxV);\n    float interf = mix(interf0, interf1, f);\n    float phase = mix(phase0, phase1, f);\n    float dp = (NxV - 1.0) * 0.5;\n    \n    // film hue\n    vec3 hue = \n    \t\t// fade in higher frequency at the right end\n        \tmix(\n                physhue2rgb(thickness * interf0 + dp, thickness * phase0),\n    \t\t\tphyshue2rgb(thickness * interf1 + 0.1 + dp, thickness * phase1),\n                f);\n    \n    vec3 film = hue * lum + vec3(0.49639,0.78252,0.88723) * luma;\n    \n    \n    return vec3((film * 3.0 + pow(f,12.0))) * tint;\n}\n\nvec3 srgb2lin(vec3 color) {\n    return color * (color * (\n        color * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 lin2srgb(vec3 color) {\n    vec3 S1 = sqrt(color);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////Iridescence end///////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n//Smooth min from iq: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n//Distance function\nfloat SDMere(vec3 pos, vec3 p, float r, float t){\n    return\n    smin(\n    smin(\n    length(max(abs(p-pos)-r,0.0)),\n    distance(p,pos+.35*vec3(sin(2.5*t+.2),sin(5.*t),cos(3.*t)))-.1*r,\n    20.),\n    distance(p,pos+.35*vec3(cos(5.*t+.7),cos(2.*t),sin(3.5*t)))-.1*r,\n    20.)\n    ;\n}\n\nfloat SDscene(vec3 p, float t){\n\tfloat d = SDMere(vec3(0,0,0),p,.2,t);\n\treturn d;\n}\n\n//SD normal\nvec3 SDn(vec3 p, float t){\n    float ep = 0.01;\n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z),t)-SDscene(vec3(p.x-ep,p.y,p.z),t),\n    SDscene(vec3(p.x,p.y+ep,p.z),t)-SDscene(vec3(p.x,p.y-ep,p.z),t),\n    SDscene(vec3(p.x,p.y,p.z+ep),t)-SDscene(vec3(p.x,p.y,p.z-ep),t)\n    ));\n}\n\n//phong shading\nvec3 phong(vec3 p, float t){\n    \n    //Lights:\n    //Lights position\n    vec3 L1 = 3.*vec3(sin(2.5*t),cos(t),sin(t));\n    float dt = t+2.;\n    vec3 L2 = 3.*vec3(sin(2.5*dt),cos(dt),sin(dt));\n    //Lights intensity\n    vec3 i1s = vec3(1.);\n    vec3 i1d = vec3(1.);\n    vec3 ia = .4*vec3(1.);\n    \n    //Material:\n    //Spectral lighting\n    vec3 Tks = vec3(.7);\n    //Diffuse lighting\n    vec3 Tkd = .5*vec3(.9);\n    vec3 Tka = 3.*vec3(.45);\n    float alp = 100.;\n    \n    vec3 L1v = normalize(L1-p);\n    vec3 L2v = normalize(L2-p);\n    vec3 N = SDn(p, t);\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 R2 = normalize(reflect(L2v,N));\n    vec3 J,Q,Ir;\n    float temp = dot(L1v,N);\n    float stemp = dot(R1,L1v);\n    if(temp>0.){J = Tkd*i1d*temp;}\n    if(stemp>0.){Q = Tks*i1d*pow(stemp,alp);}\n    float temp2 = dot(L2v,N);\n    float stemp2 = dot(R2,L2v);\n    if(temp2>0.){J += Tkd*i1d*temp2;}\n    if(stemp2>0.){Q += Tks*i1d*pow(stemp2,alp);}\n    \n    //Iridescence:\n    //Thickness of film (thickness = k*500nm)\n    float k = (p.x+p.y+p.z+.6)/2.;\n    Ir=lin2srgb(iridescence(asin(temp),k));\n    Ir+=lin2srgb(iridescence(asin(temp2),k));\n    vec3 ir = Tka*ia*(1.*Ir) + .1;\n    \n    vec3 I = ir + J + Q;\n    return I;\n}\n\n\n//raytracing\nfloat end = 10.;\nfloat depth(vec3 ro, vec3 rd, float t){\n    float dist=0., d;\n    int max=200;\n    float ep = 0.0001;\n    for (int i=0; i<max; i++){\n    d = SDscene(ro + dist*rd, t);\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > end){\n        return end;\n    }\n  }\n}\n\nvoid mainImage(out vec4 C, in vec2 S ) {\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (S / R-.5)*.75;\n    uv.y *= R.y/R.x;\n    vec2 T = iMouse.xy/R*5.;\n    float t = .2*iTime - 20.;\n\t\n    //Camera setup\n  \tfloat zoom = 5.;\n  \tvec3 ro = 2.*vec3(sin(T.x+t*.2)*cos(T.y+t*.3),sin(T.x+t*.2)*sin(T.y+t*.3),cos(T.x+t*.2));\n  \tvec3 lookat = vec3(0,0,0);\n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw + up*0.;\n  \tvec3 scrP = scrC + 4.*(uv.x*r + uv.y*up);\n  \tvec3 rd = normalize(scrP - ro);\n  \tvec4 Color;\n  \tfloat d = depth(ro,rd,t);\n  \tif (d<end){\n  \t\tvec3 p = d*rd + ro;\n  \t\tColor = vec4(phong(p,t),1.);\n  \t}\n  \telse{Color = 2.*vec4(.9,.8,.8,1.);}\n\n  \t//vigillant\n  \tColor *= sqrt(.65-1.*length(uv));\n  \t\n    C = Color;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 454, 496, 496, 612], [622, 622, 671, 727, 1900], [1902, 1902, 1929, 1929, 2020], [2022, 2022, 2049, 2049, 2193], [2423, 2499, 2540, 2540, 2614], [2616, 2636, 2685, 2685, 2918], [2920, 2920, 2951, 2951, 3003], [3005, 3017, 3043, 3043, 3307], [3309, 3325, 3353, 3394, 4546], [4549, 4579, 4618, 4618, 4855], [4857, 4857, 4897, 4921, 5700]], "test": "error"}
{"id": "ltKcWm", "name": "Raymarching Torus test", "author": "uynet", "description": "tanoC", "tags": ["raymarching"], "likes": 3, "viewed": 196, "published": "Public", "date": "1536668658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Trus{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n struct Sphere{\n     vec3 pos;\n     float r;\n };\nstruct Ray{\n    vec3 orig;\n    vec3 dist;\n};\n    \n    \nvec3 L = normalize(vec3(1,0,-1));\nconst float EPS = 0.001;\nTrus trus;\n\n//trus distancefield\nfloat dist(vec3 p,Trus trus){\n  float d;\n   p -= trus.pos;\n   vec3 p_proj = p-trus.dir*(dot(p,trus.dir));\n   p_proj = trus.r * normalize(p_proj);\n   d = length(p_proj - p)-trus.s;\n   return d;\n}\n\nfloat dist_s(vec3 p,Sphere sphere){\n   return length(p-sphere.pos)-sphere.r;\n}\n\nRay march(Ray ray, float dist){\n                        //distance / distination\n    Ray r = ray;\n    r.orig = ray.orig + dist*ray.dist;\n    return r;\n}\n\nvec3 rotX(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x,\n\t\tv.y * c - v.z * s,\n\t\tv.z * c + v.y * s\n\t);\n}\nvec3 rotY(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x * c + v.z * s,\n\t\tv.y,\n\t\tv.z * c - v.x * s\n\t);\n}\nvec3 rotZ(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x * c - v.y * s,\n\t\tv.y * c + v.x * s,\n\t\tv.z\n\t);\n}\n\n// \nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n    dist(p + vec3(EPS, 0.0, 0.0),trus) - dist(p + vec3(-EPS,  0.0,  0.0),trus),\n    dist(p + vec3(0.0, EPS, 0.0),trus) - dist(p + vec3( 0.0, -EPS,  0.0),trus),\n    dist(p + vec3(0.0, 0.0, EPS),trus) - dist(p + vec3( 0.0,  0.0, -EPS),trus)\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    trus.dir = normalize(vec3(1));\n    trus.dir = rotX(trus.dir,iTime*111.0);\n    trus.dir = rotY(trus.dir,iTime*83.0);\n    trus.dir = rotZ(trus.dir,iTime*93.0);\n    trus.pos = vec3(0,0,0);\n    trus.r = 0.1;\n    trus.s = trus.r/4.0;\n   \n    \n    Sphere sphere;\n    sphere.pos = vec3(sin(iTime)*0.1,0,0);\n    sphere.r = 0.1;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.y*=asp;\n    \n    Ray ray;\n    ray.orig = vec3(0,0,-1);\n    ray.dist = vec3(uv,1);\n    \n    //float d = dist_s(ray.orig,sphere);\n    float d2 = dist(ray.orig,trus);\n    int t = 0;\n    vec3 col = vec3(0);\n    \n    while(d2 > EPS){\n    \tray = march(ray,d2);\n        //d = dist_s(ray.orig,sphere);\n        d2 = dist(ray.orig,trus);\n        if(t++>10)break;\n    }\n    if(d2<=0.01){\n        L = rotX(L,iTime*171.0);\n        vec3 norm =  getNormal(ray.orig);\n        //col = norm;\n        //col = .6-col*0.5;\n        float dif = max(0.0,dot(norm,L));\n        dif*=0.5;\n        float spe = max(0.0,dot(reflect(ray.dist,norm),L));\n        spe*=spe;\n        spe*=0.1;\n        float amb = 0.3;\n        \n        float b = dif+spe+amb;\n     \n        //col.x += dif*7.0+norm.y*norm.x;\n        //col.y += spe*2.0;\n        //col.z += spe*2.0+norm.x*norm.z;\n        //col = 1.0-col;\n         col = vec3(b)*vec3(dif*8.0 ,0.6+spe*5.0,1.0-dif*9.0);\n\t\t        \n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKcWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 266, 295, 295, 460], [462, 462, 497, 497, 540], [542, 542, 573, 622, 694], [696, 696, 724, 724, 853], [854, 854, 882, 882, 1011], [1012, 1012, 1040, 1040, 1169], [1171, 1190, 1214, 1214, 1486], [1488, 1488, 1545, 1545, 3021]], "test": "valid"}
{"id": "ltKcz3", "name": "essence of helix", "author": "cmarangu", "description": "not much to be said", "tags": ["spiral", "blue", "helix", "cyan"], "likes": 0, "viewed": 118, "published": "Public", "date": "1537204504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// current code\n// /*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // 3.14159265358979323846264338327950288419716939937\n    // 5105820974944592307816406286208998628034825342117\n    // 0679821480865132823066470938446095505822317253594\n    // 08128481117450284102701938521iforget\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.x;\n\tfloat t = atan(p.y, p.x);\n    float r = log2(length(p));\n    float a_ = +iTime*2.+t*2.+r*7.;\n    float b_ = -iTime*5.+t*6.+r*12.+45.;\n    float a = 0.5+0.5*sin(a_);\n    float b = 0.5+0.5*sin(b_);\n    fragColor =  vec4(min(a, b), a, max(a, b), 1.);\n}\n/**/\n\n\n\n// old code\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 3.14159265358979323846264338327950288419716939937\n    // 5105820974944592307816406286208998628034825342117\n    // 0679821480865132823066470938446095505822317253594\n    // 0812848111745028410270193852110555964462294895493\n    // 0381964428810975665IMessedup\n    \n    float PI = 3.14159265358979323;\n    \n    vec2 pxy = fragCoord/iResolution.xy;\n    \n    vec2 rxy = fragCoord;\n    \n    float x = rxy.x-iResolution.x/2.0;\n    \n    float y = rxy.y-iResolution.y/2.0;\n\n    float r = sqrt(x*x+y*y);\n    \n    float z = log2(r);\n    \n    float theta = atan(y/x);\n\n    // Time varying pixel color\n    vec3 col = vec3(0, 0.5+0.5*sin(-z*PI*3.0+theta*6.0+iTime*23.0), 1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKcz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 79, 294, 603]], "test": "valid"}
{"id": "ltKczt", "name": "What Even Is Domain Repetition", "author": "Dghelneshi", "description": "When you have no idea how repeating SDF space works and try to figure something out on your own instead of looking it up. This is just two spheres garnished with generous amounts of WTF.", "tags": ["raymarching", "sdf"], "likes": 3, "viewed": 502, "published": "Public", "date": "1537389606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nfloat intersect(float a, float b) {\n    return max(a,b);\n}\n\n#define MIN_DIST 1.1 // used for both ray marching threshold and gradient!\n#define MAX_DIST 100.\n#define MAX_STEP 100\n\nfloat wtf1(float f) { // works best for MIN_DIST < 0.2\n    return mod(10000.0, f);\n}\nfloat wtf2(float f) { // works best for MIN_DIST ~ 1.0\n    return mod(6.0, f);\n}\nfloat wtf3(float f) { // works best for MIN_DIST > 0.1\n    return mod(f, 1000000.0);\n}\nfloat wtf4(float f) { // works best for MIN_DIST < 0.2\n    return mod(f, abs(sin(iTime)*2.5) + 1.0);\n}\nfloat wtf5(float f) { // works best for MIN_DIST > 0.5\n    return fract(f) * wtf3(f);\n}\n\nfloat SDF(vec3 p) {\n    float s1 = sphere(p, vec3(sin(iTime), cos(iTime), 5.), 2.);\n    float s2 = sphere(p, vec3(cos(iTime)*2., sin(iTime)*2., cos(iTime) + 8.), 4.);\n\n    return wtf2(intersect(s1,s2)); // try replacing with wtf1-5 and adjust MIN_DIST\n}\n\nvec3 grad(vec3 p) {\n  return normalize(vec3(SDF(p + vec3(MIN_DIST,0,0)) - SDF(p - vec3(MIN_DIST,0,0)),\n                        SDF(p + vec3(0,MIN_DIST,0)) - SDF(p - vec3(0,MIN_DIST,0)),\n                        SDF(p + vec3(0,0,MIN_DIST)) - SDF(p - vec3(0,0,MIN_DIST))));\n}\n\nvec3 shade(vec3 p, vec3 light) {\n  vec3 n = grad(p);\n  vec3 l = normalize(light - p);\n  return max(vec3(0), l * n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 light = vec3(1,1,0);\n\n    vec3 cam = vec3(0.0, 0.0, -5.0);\n    vec3 dir = vec3(uv, 1.0);\n    vec3 p = cam;\n    vec3 c = vec3(0);\n\n    for (int i = 0; i < MAX_STEP; i++) {\n        \n        float d = SDF(p);\n        \n        if (d < MIN_DIST) {\n            c = shade(p, light);\n            break;\n        }\n        else if (d > MAX_DIST)\n            break;\n        p += d * dir;\n    }\n\n    fragColor = vec4(c,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 91], [92, 92, 127, 127, 150], [271, 271, 292, 325, 355], [356, 356, 377, 410, 436], [437, 437, 458, 491, 523], [524, 524, 545, 578, 626], [627, 627, 648, 681, 714], [716, 716, 735, 735, 969], [971, 971, 990, 990, 1243], [1245, 1245, 1277, 1277, 1362], [1364, 1364, 1421, 1421, 1990]], "test": "valid"}
{"id": "ltKyRK", "name": "Tribute to ZX Spectrum", "author": "SergeyMakeev", "description": "My Shadertoy tribute to ZX Spectrum! It was amazing times!\n\n- Sometimes music (SoundCloud) doesn't play and I don't know why\n- It is better to watch on fullscreen\n", "tags": ["retro", "zx"], "likes": 3, "viewed": 202, "published": "Public", "date": "1537342813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pixels: 256  192\n// Attributes: 32  24\n// Colors: 15\n\n// https://shadertoyunofficial.wordpress.com/2016/07/21/usual-tricks-in-shadertoyglsl/\n\nconst float kRefreshRate = 25.0;\nconst vec2 kResolution = vec2(256.0, 192.0);\nconst vec2 kMinVirtualPixelSize = vec2(1.0, 1.0);\n\nfloat hash(vec2 p)\n{\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nint imod(int a, int b)\n{\n    return a-a/b*b;\n    //return a % b;\n}\n\nfloat saturate(float v)\n{\n   return min(1.0, max(0.0, v));\n}\n\nhighp float pexp2(int i)\n{\n    //return exp2(-float(i));\n    \n    //workaround for precission issue on ios\n    if (i == 0) return 1.0;\n    if (i == 1) return 0.5;\n    if (i == 2) return 0.25;\n    if (i == 3) return 0.125;\n    if (i == 4) return 0.0625;\n    if (i == 5) return 0.03125;\n    if (i == 6) return 0.015625;\n    if (i == 7) return 0.0078125;\n    if (i == 8) return 0.00390625;\n    if (i == 9) return 0.001953125;\n    if (i == 10) return 0.0009765625;\n    \n    return exp2(-float(i));\n\n    \n    \n/*    \n    if (i == 0) return 1.0;\n    if (i == 1) return 0.5;\n    if (i == 2) return 0.25;\n    if (i == 3) return 0.125;\n    if (i == 4) return 0.0625;\n    if (i == 5) return 0.03125;\n    if (i == 6) return 0.015625;\n    if (i == 7) return 0.0078125;\n    if (i == 8) return 0.00390625;\n    if (i == 9) return 0.001953125;\n    if (i == 10) return 0.0009765625;\n    if (i == 11) return 0.00048828125;\n    if (i == 12) return 0.000244140625;\n    if (i == 13) return 0.0001220703125;\n    if (i == 14) return 0.00006103515625;\n    if (i == 15) return 0.000030517578125;\n    if (i == 16) return 0.0000152587890625;\n    if (i == 17) return 0.00000762939453125;\n    if (i == 18) return 0.000003814697265625;\n    if (i == 19) return 0.0000019073486328125;\n    if (i == 20) return 0.00000095367431640625;\n    if (i == 21) return 0.000000476837158203125;\n    if (i == 22) return 0.0000002384185791015625;\n    if (i == 23) return 0.00000011920928955078125;\n    if (i == 24) return 0.000000059604644775390625; \n  */  \n    return 1.0;\n\n}\n\nfloat bitTest(float bits, int index)\n{\n    // 2^24 integers can be represented in single float\n    \n    // shift integer right\n    //highp float t = bits * exp2(-float(index));\n    //highp float t = 48.0 * exp2(-float(index));\n    \n    //highp float fi = float(index);\n    \n    float t = bits * pexp2(index);\n    t -= fract(t);\n    \n    //check the lowest bit\n    return (fract(t * 0.5) > 0.0) ? 1.0 : 0.0;\n}\n\n// get pixel value (charBits = 8x8 char)\n// .x = 8x2 pixels\n// .y = 8x2 pixels\n// .z = 8x2 pixels\n// .w = 8x2 pixels\nfloat getCharPixel(int x, int y, vec4 charBits)\n{\n    int _y = (y/2);\n    float lineBits = charBits.x;\n    lineBits = (_y == 1) ? charBits.y : lineBits;\n    lineBits = (_y == 2) ? charBits.z : lineBits;\n    lineBits = (_y == 3) ? charBits.w : lineBits;\n    int shift = (imod(y, 2) == 0) ? 0 : 8;\n    return bitTest(lineBits, x + shift);\n}\n\n// get pixel value for 24x8 sprite\n// .x = 24x1 pixels\n// .y = 24x1 pixels\n// ...\n// .w = 24x1 pixels\nfloat getSpritePixel(int x, int y, vec4 line1234, vec4 line4567)\n{\n    float lineBits = line1234.x;\n    lineBits = (y == 1) ? line1234.y : lineBits;\n    lineBits = (y == 2) ? line1234.z : lineBits;\n    lineBits = (y == 3) ? line1234.w : lineBits;\n    lineBits = (y == 4) ? line4567.x : lineBits;\n    lineBits = (y == 5) ? line4567.y : lineBits;\n    lineBits = (y == 6) ? line4567.z : lineBits;\n    lineBits = (y == 7) ? line4567.w : lineBits;\n    return bitTest(lineBits, x);\n}\n\n// Speccy font\n#define _0 vec4(26172.0, 32374.0, 26222.0, 60.0)\n#define _1 vec4(7192.0, 6168.0, 6168.0, 126.0)\n#define _2 vec4(26172.0, 12384.0, 3096.0, 126.0)\n#define _3 vec4(26172.0, 14432.0, 26208.0, 60.0)\n#define _4 vec4(14384.0, 13884.0, 12414.0, 48.0)\n#define _5 vec4(1662.0, 24638.0, 26208.0, 60.0)\n#define _6 vec4(3128.0, 15878.0, 26214.0, 60.0)\n#define _7 vec4(24702.0, 6192.0, 3084.0, 12.0)\n#define _8 vec4(26172.0, 15462.0, 26214.0, 60.0)\n#define _9 vec4(26172.0, 31846.0, 12384.0, 28.0)\n#define _A vec4(26172.0, 32358.0, 26214.0, 102.0)\n#define _B vec4(26174.0, 15974.0, 26214.0, 62.0)\n#define _C vec4(26172.0, 1542.0, 26118.0, 60.0)\n#define _D vec4(13854.0, 26214.0, 13926.0, 30.0)\n#define _E vec4(1662.0, 15878.0, 1542.0, 126.0)\n#define _F vec4(1662.0, 15878.0, 1542.0, 6.0)\n#define _G vec4(26172.0, 30214.0, 26214.0, 60.0)\n#define _H vec4(26214.0, 32358.0, 26214.0, 102.0)\n#define _I vec4(6270.0, 6168.0, 6168.0, 126.0)\n#define _J vec4(12412.0, 12336.0, 13872.0, 28.0)\n#define _K vec4(13926.0, 3614.0, 13854.0, 102.0)\n#define _L vec4(1542.0, 1542.0, 1542.0, 126.0)\n#define _M vec4(30563.0, 27519.0, 25451.0, 99.0)\n#define _N vec4(26214.0, 32366.0, 26230.0, 102.0)\n#define _O vec4(26172.0, 26214.0, 26214.0, 60.0)\n#define _P vec4(26174.0, 15974.0, 1542.0, 6.0)\n#define _Q vec4(26172.0, 26214.0, 13910.0, 108.0)\n#define _R vec4(26174.0, 15974.0, 26166.0, 102.0)\n#define _S vec4(26172.0, 15366.0, 26208.0, 60.0)\n#define _T vec4(6270.0, 6168.0, 6168.0, 24.0)\n#define _U vec4(26214.0, 26214.0, 26214.0, 60.0)\n#define _V vec4(26214.0, 26214.0, 15462.0, 24.0)\n#define _W vec4(25443.0, 27499.0, 30591.0, 99.0)\n#define _X vec4(26214.0, 6204.0, 26172.0, 102.0)\n#define _Y vec4(26214.0, 15462.0, 6168.0, 24.0)\n#define _Z vec4(24702.0, 6192.0, 1548.0, 126.0)\n#define _COMMA vec4(0.0, 0.0, 6144.0, 3096.0)\n#define _DOT vec4(0.0, 0.0, 6144.0, 24.0)\n#define _EX vec4(6168.0, 6168.0, 24.0, 24.0)\n#define _BRL vec4(6192.0, 3084.0, 6156.0, 48.0)\n#define _BRR vec4(6156.0, 12336.0, 6192.0, 12.0)\n#define _MINUS vec4(0.0, 32256.0, 0.0, 0.0)\n#define _HEART vec4(26112.0, 65535.0, 32511.0, 6204.0)\n\n//Sprites (each sprite 24x8)\n#define _S0 vec4(0.0, 0.0, 32256.0, 43776.0), vec4(34176.0, 1637248.0, 3949952.0, 8314240.0)\n#define _S1 vec4(16557440.0, 16054656.0, 7996352.0, 2441184.0), vec4(169744.0, 85512.0, 44552.0, 450328.0)\n#define _S2 vec4(650692.0, 1169378.0, 1235906.0, 843138.0), vec4(188164.0, 117784.0, 52768.0, 44640.0)\n#define _S3 vec4(32736.0, 32640.0, 17088.0, 24000.0), vec4(19136.0, 22976.0, 21376.0, 30080.0)\n#define _S4 vec4(25344.0, 26368.0, 27392.0, 17920.0), vec4(19968.0, 22016.0, 19968.0, 32256.0)\n#define _S5 vec4(16896.0, 82560.0, 311104.0, 753312.0), vec4(393024.0, 699040.0, 349504.0, 174720.0)\n#define _S6 vec4(0.0, 0.0, 15872.0, 24320.0), vec4(32512.0, 15232.0, 17280.0, 20928.0)\n#define _S7 vec4(8640.0, 9440.0, 15840.0, 21008.0), vec4(19464.0, 16648.0, 16760.0, 28552.0)\n#define _S8 vec4(18680.0, 51336.0, 84040.0, 84232.0), vec4(50792.0, 16656.0, 13024.0, 16352.0)\n#define _S9 vec4(16320.0, 17088.0, 24000.0, 39616.0), vec4(43456.0, 72384.0, 80320.0, 88768.0)\n#define _S10 vec4(145856.0, 162496.0, 179648.0, 288480.0), vec4(320864.0, 354016.0, 518112.0, 271392.0)\n#define _S11 vec4(271392.0, 6024176.0, 3667944.0, 6291444.0), vec4(2796200.0, 1398096.0, 0.0, 0.0)\n#define _S12 vec4(0.0, 0.0, 16128.0, 32384.0), vec4(32512.0, 29184.0, 24320.0, 21760.0)\n#define _S13 vec4(16896.0, 20992.0, 515584.0, 582912.0), vec4(1080576.0, 1075456.0, 1635680.0, 2353616.0)\n#define _S14 vec4(4707720.0, 4450760.0, 4584944.0, 3107136.0), vec4(1979776.0, 272640.0, 161024.0, 261632.0)\n#define _S15 vec4(130560.0, 106752.0, 122112.0, 108800.0), vec4(118016.0, 58624.0, 55040.0, 25344.0)\n#define _S16 vec4(29440.0, 27392.0, 12544.0, 14592.0), vec4(13568.0, 14592.0, 16128.0, 8448.0)\n#define _S17 vec4(41280.0, 97936.0, 180072.0, 98256.0), vec4(174760.0, 87376.0, 43680.0, 0.0)\n#define _S18 vec4(16228351.0, 16238590.0, 14926840.0, 14934512.0), vec4(14934512.0, 14934512.0, 14934512.0, 14934512.0)\n#define _S19 vec4(14934512.0, 14934512.0, 14934512.0, 14934512.0), vec4(14934512.0, 14934512.0, 14934512.0, 14934512.0)\n#define _S20 vec4(14934520.0, 14934524.0, 14934526.0, 14934527.0), vec4(14934526.0, 14934524.0, 14934520.0, 14934512.0)\n#define _S21 vec4(14934512.0, 14934512.0, 14934512.0, 14934512.0), vec4(14926320.0, 16237040.0, 16220656.0, 496.0)\n#define _S22 vec4(12582908.0, 4136945.0, 397281.0, 395203.0), vec4(198595.0, 198595.0, 100291.0, 100291.0)\n#define _S23 vec4(100291.0, 51139.0, 51139.0, 26563.0), vec4(26563.0, 14275.0, 14275.0, 16323.0)\n#define _S24 vec4(16323.0, 16323.0, 16323.0, 32707.0), vec4(65475.0, 131011.0, 260035.0, 518083.0)\n#define _S25 vec4(1034179.0, 2066371.0, 4130755.0, 8259523.0), vec4(16519137.0, 16261105.0, 15761404.0, 0.0)\n#define _S26 vec4(16579583.0, 15856126.0, 14803196.0, 12706040.0), vec4(12706040.0, 12706040.0, 12632312.0, 12583160.0)\n#define _S27 vec4(12583160.0, 12583160.0, 12583160.0, 12583160.0), vec4(12583160.0, 12583160.0, 12583160.0, 12590840.0)\n#define _S28 vec4(12590840.0, 12590840.0, 12583160.0, 12583160.0), vec4(12583160.0, 12583160.0, 12583160.0, 12583160.0)\n#define _S29 vec4(12632312.0, 12706040.0, 12706040.0, 12706040.0), vec4(14803192.0, 15856125.0, 16579583.0, 0.0)\n#define _S30 vec4(991.0, 1927.0, 3843.0, 7939.0), vec4(7939.0, 7939.0, 7939.0, 7939.0)\n#define _S31 vec4(7939.0, 7939.0, 7939.0, 7939.0), vec4(7939.0, 7939.0, 7939.0, 3843.0)\n#define _S32 vec4(3843.0, 26499.0, 61927.0, 61927.0), vec4(25539.0, 1923.0, 3971.0, 3971.0)\n#define _S33 vec4(3843.0, 3843.0, 3843.0, 3843.0), vec4(7943.0, 7951.0, 7999.0, 7936.0)\n#define _S34 vec4(496.0, 496.0, 496.0, 496.0), vec4(496.0, 496.0, 496.0, 496.0)\n#define _S35 vec4(496.0, 504.0, 510.0, 255.0), vec4(127.0, 62.0, 0.0, 0.0)\n#define _S36 vec4(7936.0, 7936.0, 7936.0, 7936.0), vec4(7936.0, 7936.0, 7936.0, 7936.0)\n#define _S37 vec4(7936.0, 7936.0, 16128.0, 15872.0), vec4(31744.0, 30720.0, 0.0, 0.0)\n#define _S38 vec4(0.0, 241376.0, 174720.0, 174720.0), vec4(240352.0, 141856.0, 141856.0, 241376.0)\n#define _S39 vec4(0.0, 128.0, 0.0, 128.0), vec4(2184.0, 128.0, 672.0, 448.0)\n#define _S40 vec4(24573.0, 448.0, 672.0, 128.0), vec4(2184.0, 128.0, 0.0, 128.0)\n#define _S41 vec4(0.0, 0.0, 0.0, 128.0), vec4(128.0, 1168.0, 672.0, 448.0)\n#define _S42 vec4(8188.0, 448.0, 672.0, 1168.0), vec4(128.0, 128.0, 0.0, 0.0)\n#define _S43 vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 128.0, 128.0, 448.0)\n#define _S44 vec4(2032.0, 448.0, 128.0, 128.0), vec4(0.0, 0.0, 0.0, 0.0)\n#define _S45 vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 128.0)\n#define _S46 vec4(448.0, 128.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)\n#define _S47 vec4(0.0, 2048.0, 2048.0, 7168.0), vec4(7168.0, 15872.0, 524272.0, 262112.0)\n#define _S48 vec4(65408.0, 32512.0, 32512.0, 65408.0), vec4(58240.0, 115136.0, 65600.0, 0.0)\n\n// ZX palette\nvec3 getColorFromPalette(int v)\n{\n    const float lbc = 0.752;\n    const float hbc = 1.0;\n    \n    if (v == 0)\n        return vec3(0.0, 0.0, 0.0);   // 0 black\n    else if (v == 1)\n        return vec3(0.0, 0.0, lbc);   // 1 blue  \n    else if (v == 2)\n        return vec3(lbc, 0.0, 0.0);   // 2 red\n    else if (v == 3)    \n        return vec3(lbc, 0.0, lbc);   // 3 magenta\n    else if (v == 4)\n        return vec3(0.0, lbc, 0.0);   // 4 green\n    else if (v == 5)\n        return vec3(0.0, lbc, lbc);   // 5 blue\n    else if (v == 6)\n        return vec3(lbc, lbc, 0.0);   // 6 yellow\n    else if (v == 7)\n        return vec3(lbc, lbc, lbc);   // 7 gray\n    else if (v == 8)\n        return vec3(0.0, 0.0, 0.0);   // 8 black\n    else if (v == 9)\n        return vec3(0.0, 0.0, hbc);   // 9 blue  \n    else if (v == 10)\n        return vec3(hbc, 0.0, 0.0);   // 10 red\n    else if (v == 11)    \n        return vec3(hbc, 0.0, hbc);   // 11 magenta\n    else if (v == 12)\n        return vec3(0.0, hbc, 0.0);   // 12 green\n    else if (v == 13)\n        return vec3(0.0, hbc, hbc);   // 13 blue\n    else if (v == 14)\n        return vec3(hbc, hbc, 0.0);   // 14 yellow\n    else\n        return vec3(hbc, hbc, hbc);   // 15 white        \n}\n\nvec4 getAttrCharByIndex(int idx)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    res = (idx == 36) ? _T : res;\n    res = (idx == 37) ? _H : res;\n    res = (idx == 38) ? _I : res;\n    res = (idx == 39) ? _S : res;\n    // 40\n    res = (idx == 41) ? _D : res;\n    res = (idx == 42) ? _E : res;\n    res = (idx == 43) ? _M : res;\n    res = (idx == 44) ? _O : res;\n    // 45\n    res = (idx == 46) ? _D : res;\n    res = (idx == 47) ? _E : res;\n    res = (idx == 48) ? _D : res;\n    res = (idx == 49) ? _I : res;\n    res = (idx == 50) ? _C : res;\n    res = (idx == 51) ? _A : res;\n    res = (idx == 52) ? _T : res;\n    res = (idx == 53) ? _E : res;\n    res = (idx == 54) ? _D : res;\n    // 55\n    res = (idx == 56) ? _T : res;\n    res = (idx == 57) ? _O : res;\n    // 58\n    res = (idx == 59) ? _A : res;\n    res = (idx == 60) ? _L : res;\n    res = (idx == 61) ? _L : res;\n    // 62\n    res = (idx == 63) ? _R : res;\n    res = (idx == 64) ? _E : res;\n    res = (idx == 65) ? _N : res;\n    res = (idx == 66) ? _D : res;\n    res = (idx == 67) ? _E : res;\n    res = (idx == 68) ? _R : res;\n    res = (idx == 69) ? _I : res;\n    res = (idx == 70) ? _N : res;\n    res = (idx == 71) ? _G : res;\n    // 72\n    res = (idx == 73) ? _P : res;\n    res = (idx == 74) ? _E : res;\n    res = (idx == 75) ? _O : res;\n    res = (idx == 76) ? _P : res;\n    res = (idx == 77) ? _L : res;\n    res = (idx == 78) ? _E : res;\n    // 79\n    res = (idx == 80) ? _I : res;\n    res = (idx == 81) ? _N : res;\n    // 82\n    res = (idx == 83) ? _T : res;\n    res = (idx == 84) ? _H : res;\n    res = (idx == 85) ? _E : res;\n    // 86\n    res = (idx == 87) ? _W : res;\n    res = (idx == 88) ? _O : res;\n    res = (idx == 89) ? _R : res;\n    res = (idx == 90) ? _L : res;\n    res = (idx == 91) ? _D : res;\n    res = (idx == 92) ? _EX : res;\n    // 93\n    // 94\n    res = (idx == 95) ? _HEART : res;\n    // 96\n    // 97\n    res = (idx == 98) ? _T : res;\n    res = (idx == 99) ? _H : res;\n    res = (idx == 100) ? _A : res;\n    res = (idx == 101) ? _N : res;\n    res = (idx == 102) ? _K : res;\n    // 103\n    res = (idx == 104) ? _Y : res;\n    res = (idx == 105) ? _O : res;\n    res = (idx == 106) ? _U : res;\n    // 107\n    res = (idx == 108) ? _F : res;\n    res = (idx == 109) ? _O : res;\n    res = (idx == 110) ? _R : res;\n    // 111\n    res = (idx == 112) ? _I : res;\n    res = (idx == 113) ? _N : res;\n    res = (idx == 114) ? _S : res;\n    res = (idx == 115) ? _P : res;\n    res = (idx == 116) ? _I : res;\n    res = (idx == 117) ? _R : res;\n    res = (idx == 118) ? _I : res;\n    res = (idx == 119) ? _N : res;\n    res = (idx == 120) ? _G : res;\n    // 121\n    res = (idx == 122) ? _M : res;\n    res = (idx == 123) ? _E : res;\n    res = (idx == 124) ? _EX : res;\n    // 125\n    // 126\n    res = (idx == 127) ? _HEART : res;\n    // 128\n    // 129\n    // 130\n    res = (idx == 131) ? _U : res;\n    // 132\n    res = (idx == 133) ? _R : res;\n    res = (idx == 134) ? _O : res;\n    res = (idx == 135) ? _C : res;\n    res = (idx == 136) ? _K : res;\n    res = (idx == 137) ? _S : res;\n    res = (idx == 138) ? _EX : res;\n    // 139\n    // 140\n    // 141\n    res = (idx == 142) ? _HEART : res;\n    // 143\n    // 144\n    res = (idx == 145) ? _HEART : res;\n    // 146\n    // 147\n    res = (idx == 148) ? _HEART : res;\n    \n    return res;\n}\n\nint getAttributeScroller(int ax, int ay, int frame)\n{\n    frame = frame;\n    frame = imod(frame, 1216);\n    \n    ax = ax + frame;\n    \n    int lx = imod(ax, 8);\n    int ly = ay - 8;\n    \n    int chPos = ax / 8;\n    \n    vec4 bits = getAttrCharByIndex(chPos);\n    \n    int clr = 4;\n    if (chPos == 95|| chPos == 127 || chPos == 142 || chPos == 145 || chPos == 148)\n    {\n        clr = 2;\n    }\n    \n    int res = (getCharPixel(lx, ly, bits) > 0.0) ? clr : 0;\n\n    return res;\n}\n\n// Get current attribute value\nvoid getAttributeColors(int ax, int ay, int frame, inout int background, inout int foreground)\n{\n    background = 0;\n    foreground = 7;\n    \n    if (ax > 8 && ax < 22 && ay > 0 && ay <= 7)\n    {\n      background = 0;\n      foreground = imod(frame,7);        \n    }\n    \n    if (ay >= 8 && ay < 16)\n    {\n      background = getAttributeScroller(ax, ay, frame);\n      foreground = 0;    \n    }\n   \n    \n    if (ay >= 16)\n    {\n      background = 0;\n      foreground = 6;        \n    }\n    \n    return;\n}\n\n//\nfloat getTopSprites(int x, int y, int frame)\n{\n    int _x = x;\n    \n    x = x + int(cos(float(frame+y) * 0.05) * 8.0);\n    \n    int kOffset = 80;\n    int kHOffset = 14;\n    \n    // joker\n    int lx = x - kOffset;\n    int ly = y - kHOffset;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S18);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S19);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S20);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S21);\n        }\n        \n        if (ly >= 32 && ly < 40)\n        {\n          return getSpritePixel(lx, ly-32, _S34);\n        }\n        if (ly >= 40 && ly < 48)\n        {\n          return getSpritePixel(lx, ly-40, _S35);\n        }\n        \n    }\n    \n    lx = x - kOffset - 24;\n    ly = y - kHOffset;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S22);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S23);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S24);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S25);\n        }\n    }\n\n    lx = x - kOffset - 24 - 24;\n    ly = y - kHOffset;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S26);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S27);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S28);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S29);\n        }\n    }\n\n    lx = x - kOffset - 24 - 24 - 24;\n    ly = y - kHOffset;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S30);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S31);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S32);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S33);\n        }\n        \n        if (ly >= 32 && ly < 40)\n        {\n          return getSpritePixel(lx, ly-32, _S36);\n        }\n        if (ly >= 40 && ly < 48)\n        {\n          return getSpritePixel(lx, ly-40, _S37);\n        }\n       \n    }\n    \n    lx = _x - 108;\n    ly = y - 0;\n    \n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S38);\n        }\n    }\n    \n    // star \n    int pFrameX = imod((frame / 32), 4);\n    int pFrameY = imod(frame / 32, 3);\n    \n    int px = 16;\n    px = (pFrameX == 0) ? 39 : px;\n    px = (pFrameX == 1) ? 180 : px;\n    px = (pFrameX == 2) ? 220 : px;\n    \n    int py = 4;\n    py = (pFrameY == 0) ? 30 : py;\n    py = (pFrameY == 1) ? 16 : py;\n    \n    int sFrame = imod((frame/4), 16);\n    //sFrame = 3;\n    lx = _x - px;\n    ly = y - py;\n    \n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n            if (sFrame == 0)\n              return getSpritePixel(lx, ly, _S43);\n            if (sFrame == 1)\n              return getSpritePixel(lx, ly, _S41);\n            if (sFrame == 2)\n              return getSpritePixel(lx, ly, _S39);\n            if (sFrame == 3)\n              return getSpritePixel(lx, ly, _S41);\n            if (sFrame == 4)\n              return getSpritePixel(lx, ly, _S43);\n            \n        }\n        if (ly >= 8 && ly < 16)           \n        {\n            if (sFrame == 0)\n              return getSpritePixel(lx, ly-8, _S44);\n            if (sFrame == 1)\n              return getSpritePixel(lx, ly-8, _S42);\n            if (sFrame == 2)\n              return getSpritePixel(lx, ly-8, _S40);\n            if (sFrame == 3)\n              return getSpritePixel(lx, ly-8, _S42);\n            if (sFrame == 4)\n              return getSpritePixel(lx, ly-8, _S44);\n        }\n        \n    }\n\n    return 0.0;\n}\n\n\nfloat getSprites(int x, int y, int frame)\n{\n    // sprite 1\n    int lx = x - 10;\n    int ly = y - 64;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S0);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S1);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S2);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S3);\n        }\n        if (ly >= 32 && ly < 40)\n        {\n          return getSpritePixel(lx, ly-32, _S4);\n        }\n        if (ly >= 40 && ly < 48)\n        {\n          return getSpritePixel(lx, ly-40, _S5);\n        }\n    }\n    \n    // sprite 2\n    lx = x - 48;\n    ly = y - 72;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S6);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S7);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S8);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S9);\n        }\n        if (ly >= 32 && ly < 40)\n        {\n          return getSpritePixel(lx, ly-32, _S10);\n        }\n        if (ly >= 40 && ly < 48)\n        {\n          return getSpritePixel(lx, ly-40, _S11);\n        }\n    }\n\n    // sprite 3\n    lx = x - 196;\n    ly = y - 64;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S12);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S13);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S14);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S15);\n        }\n        if (ly >= 32 && ly < 40)\n        {\n          return getSpritePixel(lx, ly-32, _S16);\n        }\n        if (ly >= 40 && ly < 48)\n        {\n          return getSpritePixel(lx, ly-40, _S17);\n        }\n    }\n\n    // sprite 4\n    lx = x - 132;\n    ly = y - 68;\n    if (lx >= 0 && lx < 24)\n    {\n        if (ly >= 0 && ly < 8)\n        {\n          return getSpritePixel(lx, ly, _S6);\n        }\n        if (ly >= 8 && ly < 16)\n        {\n          return getSpritePixel(lx, ly-8, _S7);\n        }\n        if (ly >= 16 && ly < 24)\n        {\n          return getSpritePixel(lx, ly-16, _S8);\n        }\n        if (ly >= 24 && ly < 32)\n        {\n          return getSpritePixel(lx, ly-24, _S9);\n        }\n        if (ly >= 32 && ly < 40)\n        {\n          return getSpritePixel(lx, ly-32, _S10);\n        }\n        if (ly >= 40 && ly < 48)\n        {\n          return getSpritePixel(lx, ly-40, _S11);\n        }\n    }\n\n    return 0.0;\n}\n\n\nvec4 getCharBitsByIndex(int idx)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    res = (idx == 36) ? _H : res;\n    res = (idx == 37) ? _E : res;\n    res = (idx == 38) ? _L : res;\n    res = (idx == 39) ? _L : res;\n    res = (idx == 40) ? _O : res;\n    res = (idx == 41) ? _EX : res;\n    // 42\n    res = (idx == 43) ? _H : res;\n    res = (idx == 44) ? _O : res;\n    res = (idx == 45) ? _L : res;\n    res = (idx == 46) ? _A : res;\n    res = (idx == 47) ? _EX : res;\n    // 48\n    res = (idx == 49) ? _S : res;\n    res = (idx == 50) ? _E : res;\n    res = (idx == 51) ? _R : res;\n    res = (idx == 52) ? _G : res;\n    res = (idx == 53) ? _E : res;\n    res = (idx == 54) ? _Y : res;\n    // 55\n    res = (idx == 56) ? _M : res;\n    res = (idx == 57) ? _A : res;\n    res = (idx == 58) ? _K : res;\n    res = (idx == 59) ? _E : res;\n    res = (idx == 60) ? _E : res;\n    res = (idx == 61) ? _V : res;\n    // 62\n    res = (idx == 63) ? _I : res;\n    res = (idx == 64) ? _S : res;\n    // 65\n    res = (idx == 66) ? _P : res;\n    res = (idx == 67) ? _R : res;\n    res = (idx == 68) ? _O : res;\n    res = (idx == 69) ? _U : res;\n    res = (idx == 70) ? _D : res;\n    // 71\n    res = (idx == 72) ? _T : res;\n    res = (idx == 73) ? _O : res;\n    // 74\n    res = (idx == 75) ? _P : res;\n    res = (idx == 76) ? _R : res;\n    res = (idx == 77) ? _E : res;\n    res = (idx == 78) ? _S : res;\n    res = (idx == 79) ? _E : res;\n    res = (idx == 80) ? _N : res;\n    res = (idx == 81) ? _T : res;\n    // 82\n    res = (idx == 83) ? _A : res;\n    // 84\n    res = (idx == 85) ? _S : res;\n    res = (idx == 86) ? _H : res;\n    res = (idx == 87) ? _A : res;\n    res = (idx == 88) ? _D : res;\n    res = (idx == 89) ? _E : res;\n    res = (idx == 90) ? _R : res;\n    res = (idx == 91) ? _T : res;\n    res = (idx == 92) ? _O : res;\n    res = (idx == 93) ? _Y : res;\n    // 94\n    res = (idx == 95) ? _T : res;\n    res = (idx == 96) ? _R : res;\n    res = (idx == 97) ? _I : res;\n    res = (idx == 98) ? _B : res;\n    res = (idx == 99) ? _U : res;\n    res = (idx == 100) ? _T : res;\n    res = (idx == 101) ? _E : res;\n    // 102\n    res = (idx == 103) ? _T : res;\n    res = (idx == 104) ? _O : res;\n    // 105\n    res = (idx == 106) ? _Z : res;\n    res = (idx == 107) ? _X : res;\n    // 108\n    res = (idx == 109) ? _S : res;\n    res = (idx == 110) ? _P : res;\n    res = (idx == 111) ? _E : res;\n    res = (idx == 112) ? _C : res;\n    res = (idx == 113) ? _T : res;\n    res = (idx == 114) ? _R : res;\n    res = (idx == 115) ? _U : res;\n    res = (idx == 116) ? _M : res;\n    res = (idx == 117) ? _EX : res;\n    // 118\n    // 119\n    // 120\n    // 121\n    // 122\n    // 123\n    // 124\n    res = (idx == 125) ? _S : res;\n    res = (idx == 126) ? _P : res;\n    res = (idx == 127) ? _E : res;\n    res = (idx == 128) ? _C : res;\n    res = (idx == 129) ? _C : res;\n    res = (idx == 130) ? _Y : res;\n    // 131\n    res = (idx == 132) ? _R : res;\n    res = (idx == 133) ? _U : res;\n    res = (idx == 134) ? _L : res;\n    res = (idx == 135) ? _E : res;\n    res = (idx == 136) ? _Z : res;\n    // 137\n    res = (idx == 138) ? _4 : res;\n    res = (idx == 139) ? _E : res;\n    res = (idx == 140) ? _V : res;\n    res = (idx == 141) ? _E : res;\n    res = (idx == 142) ? _R : res;\n    res = (idx == 143) ? _EX : res;\n    // 144\n    // 145\n    // 146\n    // 147\n    // 148\n    // 149\n    // 150\n    res = (idx == 151) ? _K : res;\n    res = (idx == 152) ? _U : res;\n    res = (idx == 153) ? _D : res;\n    res = (idx == 154) ? _O : res;\n    res = (idx == 155) ? _S : res;\n    // 156\n    res = (idx == 157) ? _T : res;\n    res = (idx == 158) ? _O : res;\n    // 159\n    res = (idx == 160) ? _R : res;\n    res = (idx == 161) ? _O : res;\n    res = (idx == 162) ? _B : res;\n    res = (idx == 163) ? _L : res;\n    res = (idx == 164) ? _O : res;\n    res = (idx == 165) ? _X : res;\n    // 166\n    res = (idx == 167) ? _R : res;\n    res = (idx == 168) ? _E : res;\n    res = (idx == 169) ? _N : res;\n    res = (idx == 170) ? _D : res;\n    res = (idx == 171) ? _E : res;\n    res = (idx == 172) ? _R : res;\n    res = (idx == 173) ? _I : res;\n    res = (idx == 174) ? _N : res;\n    res = (idx == 175) ? _G : res;\n    // 176\n    res = (idx == 177) ? _T : res;\n    res = (idx == 178) ? _E : res;\n    res = (idx == 179) ? _A : res;\n    res = (idx == 180) ? _M : res;\n    res = (idx == 181) ? _EX : res;\n    // 182\n    res = (idx == 183) ? _Z : res;\n    res = (idx == 184) ? _E : res;\n    res = (idx == 185) ? _U : res;\n    res = (idx == 186) ? _X : res;\n    res = (idx == 187) ? _COMMA : res;\n    // 188\n    res = (idx == 189) ? _K : res;\n    res = (idx == 190) ? _A : res;\n    res = (idx == 191) ? _S : res;\n    res = (idx == 192) ? _COMMA : res;\n    // 193\n    res = (idx == 194) ? _A : res;\n    res = (idx == 195) ? _N : res;\n    res = (idx == 196) ? _G : res;\n    res = (idx == 197) ? _E : res;\n    res = (idx == 198) ? _L : res;\n    res = (idx == 199) ? _O : res;\n    res = (idx == 200) ? _COMMA : res;\n    // 201\n    res = (idx == 202) ? _W : res;\n    res = (idx == 203) ? _R : res;\n    res = (idx == 204) ? _A : res;\n    res = (idx == 205) ? _I : res;\n    res = (idx == 206) ? _T : res;\n    res = (idx == 207) ? _H : res;\n    res = (idx == 208) ? _COMMA : res;\n    // 209\n    res = (idx == 210) ? _B : res;\n    res = (idx == 211) ? _O : res;\n    res = (idx == 212) ? _N : res;\n    res = (idx == 213) ? _I : res;\n    res = (idx == 214) ? _COMMA : res;\n    // 215\n    res = (idx == 216) ? _J : res;\n    res = (idx == 217) ? _O : res;\n    res = (idx == 218) ? _S : res;\n    res = (idx == 219) ? _E : res;\n    res = (idx == 220) ? _P : res;\n    res = (idx == 221) ? _H : res;\n    res = (idx == 222) ? _COMMA : res;\n    // 223\n    res = (idx == 224) ? _M : res;\n    res = (idx == 225) ? _I : res;\n    res = (idx == 226) ? _C : res;\n    res = (idx == 227) ? _H : res;\n    res = (idx == 228) ? _A : res;\n    res = (idx == 229) ? _L : res;\n    res = (idx == 230) ? _COMMA : res;\n    // 231\n    res = (idx == 232) ? _L : res;\n    res = (idx == 233) ? _U : res;\n    res = (idx == 234) ? _N : res;\n    res = (idx == 235) ? _A : res;\n    res = (idx == 236) ? _COMMA : res;\n    // 237\n    res = (idx == 238) ? _R : res;\n    res = (idx == 239) ? _Y : res;\n    res = (idx == 240) ? _A : res;\n    res = (idx == 241) ? _N : res;\n    res = (idx == 242) ? _DOT : res;\n    // 243\n    // 244\n    // 245\n    // 246\n    res = (idx == 247) ? _H : res;\n    res = (idx == 248) ? _E : res;\n    res = (idx == 249) ? _L : res;\n    res = (idx == 250) ? _L : res;\n    res = (idx == 251) ? _O : res;\n    // 252\n    res = (idx == 253) ? _A : res;\n    res = (idx == 254) ? _N : res;\n    res = (idx == 255) ? _D : res;\n    // 256\n    res = (idx == 257) ? _G : res;\n    res = (idx == 258) ? _R : res;\n    res = (idx == 259) ? _E : res;\n    res = (idx == 260) ? _E : res;\n    res = (idx == 261) ? _T : res;\n    res = (idx == 262) ? _I : res;\n    res = (idx == 263) ? _N : res;\n    res = (idx == 264) ? _G : res;\n    res = (idx == 265) ? _S : res;\n    // 266\n    res = (idx == 267) ? _T : res;\n    res = (idx == 268) ? _O : res;\n    // 269\n    res = (idx == 270) ? _A : res;\n    res = (idx == 271) ? _R : res;\n    res = (idx == 272) ? _U : res;\n    res = (idx == 273) ? _S : res;\n    res = (idx == 274) ? _L : res;\n    res = (idx == 275) ? _A : res;\n    res = (idx == 276) ? _N : res;\n    res = (idx == 277) ? _COMMA : res;\n    // 278\n    res = (idx == 279) ? _S : res;\n    res = (idx == 280) ? _I : res;\n    res = (idx == 281) ? _M : res;\n    res = (idx == 282) ? _0 : res;\n    res = (idx == 283) ? _N : res;\n    res = (idx == 284) ? _S : res;\n    res = (idx == 285) ? _A : res;\n    res = (idx == 286) ? _Y : res;\n    res = (idx == 287) ? _S : res;\n    res = (idx == 288) ? _COMMA : res;\n    // 289\n    res = (idx == 290) ? _L : res;\n    res = (idx == 291) ? _O : res;\n    res = (idx == 292) ? _O : res;\n    res = (idx == 293) ? _K : res;\n    res = (idx == 294) ? _4 : res;\n    res = (idx == 295) ? _A : res;\n    res = (idx == 296) ? _W : res;\n    res = (idx == 297) ? _H : res;\n    res = (idx == 298) ? _I : res;\n    res = (idx == 299) ? _L : res;\n    res = (idx == 300) ? _E : res;\n    res = (idx == 301) ? _COMMA : res;\n    // 302\n    res = (idx == 303) ? _A : res;\n    res = (idx == 304) ? _N : res;\n    res = (idx == 305) ? _D : res;\n    res = (idx == 306) ? _S : res;\n    res = (idx == 307) ? _O : res;\n    res = (idx == 308) ? _F : res;\n    res = (idx == 309) ? _T : res;\n    res = (idx == 310) ? _COMMA : res;\n    // 311\n    res = (idx == 312) ? _S : res;\n    res = (idx == 313) ? _H : res;\n    res = (idx == 314) ? _O : res;\n    res = (idx == 315) ? _D : res;\n    res = (idx == 316) ? _A : res;\n    res = (idx == 317) ? _N : res;\n    res = (idx == 318) ? _COMMA : res;\n    // 319\n    res = (idx == 320) ? _T : res;\n    res = (idx == 321) ? _A : res;\n    res = (idx == 322) ? _G : res;\n    res = (idx == 323) ? _V : res;\n    res = (idx == 324) ? _A : res;\n    res = (idx == 325) ? _R : res;\n    res = (idx == 326) ? _D : res;\n    res = (idx == 327) ? _COMMA : res;\n    // 328\n    res = (idx == 329) ? _R : res;\n    res = (idx == 330) ? _U : res;\n    res = (idx == 331) ? _D : res;\n    res = (idx == 332) ? _Y : res;\n    res = (idx == 333) ? _B : res;\n    res = (idx == 334) ? _E : res;\n    res = (idx == 335) ? _A : res;\n    res = (idx == 336) ? _R : res;\n    res = (idx == 337) ? _COMMA : res;\n    // 338\n    res = (idx == 339) ? _I : res;\n    res = (idx == 340) ? _R : res;\n    res = (idx == 341) ? _O : res;\n    res = (idx == 342) ? _N : res;\n    res = (idx == 343) ? _P : res;\n    res = (idx == 344) ? _E : res;\n    res = (idx == 345) ? _T : res;\n    res = (idx == 346) ? _E : res;\n    res = (idx == 347) ? _R : res;\n    res = (idx == 348) ? _COMMA : res;\n    // 349\n    res = (idx == 350) ? _D : res;\n    res = (idx == 351) ? _D : res;\n    res = (idx == 352) ? _I : res;\n    res = (idx == 353) ? _M : res;\n    res = (idx == 354) ? _A : res;\n    res = (idx == 355) ? _COMMA : res;\n    // 356\n    res = (idx == 357) ? _L : res;\n    res = (idx == 358) ? _O : res;\n    res = (idx == 359) ? _Y : res;\n    res = (idx == 360) ? _S : res;\n    res = (idx == 361) ? _O : res;\n    res = (idx == 362) ? _COMMA : res;\n    // 363\n    res = (idx == 364) ? _W : res;\n    res = (idx == 365) ? _A : res;\n    res = (idx == 366) ? _T : res;\n    res = (idx == 367) ? _COMMA : res;\n    // 368\n    res = (idx == 369) ? _T : res;\n    res = (idx == 370) ? _O : res;\n    res = (idx == 371) ? _D : res;\n    res = (idx == 372) ? _A : res;\n    res = (idx == 373) ? _C : res;\n    res = (idx == 374) ? _E : res;\n    res = (idx == 375) ? _COMMA : res;\n    // 376\n    res = (idx == 377) ? _D : res;\n    res = (idx == 378) ? _A : res;\n    res = (idx == 379) ? _G : res;\n    res = (idx == 380) ? _G : res;\n    res = (idx == 381) ? _E : res;\n    res = (idx == 382) ? _R : res;\n    res = (idx == 383) ? _COMMA : res;\n    // 384\n    res = (idx == 385) ? _A : res;\n    res = (idx == 386) ? _R : res;\n    res = (idx == 387) ? _T : res;\n    res = (idx == 388) ? _3 : res;\n    res = (idx == 389) ? _2 : res;\n    res = (idx == 390) ? _1 : res;\n    res = (idx == 391) ? _COMMA : res;\n    // 392\n    res = (idx == 393) ? _C : res;\n    res = (idx == 394) ? _O : res;\n    res = (idx == 395) ? _O : res;\n    res = (idx == 396) ? _P : res;\n    res = (idx == 397) ? _E : res;\n    res = (idx == 398) ? _R : res;\n    res = (idx == 399) ? _F : res;\n    res = (idx == 400) ? _E : res;\n    res = (idx == 401) ? _E : res;\n    res = (idx == 402) ? _T : res;\n    res = (idx == 403) ? _COMMA : res;\n    // 404\n    res = (idx == 405) ? _B : res;\n    res = (idx == 406) ? _O : res;\n    res = (idx == 407) ? _M : res;\n    res = (idx == 408) ? _B : res;\n    res = (idx == 409) ? _O : res;\n    res = (idx == 410) ? _M : res;\n    res = (idx == 411) ? _COMMA : res;\n    // 412\n    res = (idx == 413) ? _Z : res;\n    res = (idx == 414) ? _E : res;\n    res = (idx == 415) ? _M : res;\n    res = (idx == 416) ? _I : res;\n    res = (idx == 417) ? _N : res;\n    res = (idx == 418) ? _COMMA : res;\n    // 419\n    res = (idx == 420) ? _Z : res;\n    res = (idx == 421) ? _COMMA : res;\n    // 422\n    res = (idx == 423) ? _B : res;\n    res = (idx == 424) ? _A : res;\n    res = (idx == 425) ? _H : res;\n    res = (idx == 426) ? _O : res;\n    res = (idx == 427) ? _COMMA : res;\n    // 428\n    res = (idx == 429) ? _S : res;\n    res = (idx == 430) ? _P : res;\n    res = (idx == 431) ? _A : res;\n    res = (idx == 432) ? _W : res;\n    res = (idx == 433) ? _N : res;\n    res = (idx == 434) ? _G : res;\n    res = (idx == 435) ? _A : res;\n    res = (idx == 436) ? _R : res;\n    res = (idx == 437) ? _R : res;\n    res = (idx == 438) ? _E : res;\n    res = (idx == 439) ? _T : res;\n    res = (idx == 440) ? _COMMA : res;\n    // 441\n    res = (idx == 442) ? _A : res;\n    res = (idx == 443) ? _S : res;\n    res = (idx == 444) ? _T : res;\n    res = (idx == 445) ? _R : res;\n    res = (idx == 446) ? _O : res;\n    res = (idx == 447) ? _L : res;\n    res = (idx == 448) ? _O : res;\n    res = (idx == 449) ? _G : res;\n    res = (idx == 450) ? _E : res;\n    res = (idx == 451) ? _R : res;\n    res = (idx == 452) ? _COMMA : res;\n    // 453\n    res = (idx == 454) ? _B : res;\n    res = (idx == 455) ? _A : res;\n    res = (idx == 456) ? _N : res;\n    res = (idx == 457) ? _D : res;\n    res = (idx == 458) ? _U : res;\n    res = (idx == 459) ? _R : res;\n    res = (idx == 460) ? _E : res;\n    res = (idx == 461) ? _S : res;\n    res = (idx == 462) ? _COMMA : res;\n    // 463\n    res = (idx == 464) ? _B : res;\n    res = (idx == 465) ? _I : res;\n    res = (idx == 466) ? _N : res;\n    res = (idx == 467) ? _S : res;\n    res = (idx == 468) ? _T : res;\n    res = (idx == 469) ? _R : res;\n    res = (idx == 470) ? _E : res;\n    res = (idx == 471) ? _A : res;\n    res = (idx == 472) ? _M : res;\n    res = (idx == 473) ? _COMMA : res;\n    // 474\n    res = (idx == 475) ? _M : res;\n    res = (idx == 476) ? _U : res;\n    res = (idx == 477) ? _X : res;\n    res = (idx == 478) ? _A : res;\n    res = (idx == 479) ? _H : res;\n    res = (idx == 480) ? _U : res;\n    res = (idx == 481) ? _K : res;\n    res = (idx == 482) ? _COMMA : res;\n    // 483\n    res = (idx == 484) ? _D : res;\n    res = (idx == 485) ? _A : res;\n    res = (idx == 486) ? _R : res;\n    res = (idx == 487) ? _K : res;\n    res = (idx == 488) ? _M : res;\n    res = (idx == 489) ? _I : res;\n    res = (idx == 490) ? _K : res;\n    res = (idx == 491) ? _E : res;\n    res = (idx == 492) ? _COMMA : res;\n    // 493\n    res = (idx == 494) ? _F : res;\n    res = (idx == 495) ? _R : res;\n    res = (idx == 496) ? _U : res;\n    res = (idx == 497) ? _S : res;\n    res = (idx == 498) ? _T : res;\n    res = (idx == 499) ? _U : res;\n    res = (idx == 500) ? _M : res;\n    res = (idx == 501) ? _COMMA : res;\n    // 502\n    res = (idx == 503) ? _M : res;\n    res = (idx == 504) ? _A : res;\n    res = (idx == 505) ? _X : res;\n    // 506\n    res = (idx == 507) ? _P : res;\n    res = (idx == 508) ? _E : res;\n    res = (idx == 509) ? _R : res;\n    res = (idx == 510) ? _M : res;\n    res = (idx == 511) ? _I : res;\n    res = (idx == 512) ? _N : res;\n    res = (idx == 513) ? _O : res;\n    res = (idx == 514) ? _V : res;\n    res = (idx == 515) ? _COMMA : res;\n    // 516\n    res = (idx == 517) ? _M : res;\n    res = (idx == 518) ? _A : res;\n    res = (idx == 519) ? _X : res;\n    res = (idx == 520) ? _X : res;\n    res = (idx == 521) ? _COMMA : res;\n    // 522\n    res = (idx == 523) ? _D : res;\n    res = (idx == 524) ? _W : res;\n    res = (idx == 525) ? _A : res;\n    res = (idx == 526) ? _L : res;\n    res = (idx == 527) ? _X : res;\n    // 528\n    res = (idx == 529) ? _A : res;\n    res = (idx == 530) ? _N : res;\n    res = (idx == 531) ? _D : res;\n    // 532\n    res = (idx == 533) ? _M : res;\n    res = (idx == 534) ? _A : res;\n    res = (idx == 535) ? _N : res;\n    res = (idx == 536) ? _Y : res;\n    res = (idx == 537) ? _MINUS : res;\n    res = (idx == 538) ? _M : res;\n    res = (idx == 539) ? _A : res;\n    res = (idx == 540) ? _N : res;\n    res = (idx == 541) ? _Y : res;\n    // 542\n    res = (idx == 543) ? _O : res;\n    res = (idx == 544) ? _T : res;\n    res = (idx == 545) ? _H : res;\n    res = (idx == 546) ? _E : res;\n    res = (idx == 547) ? _R : res;\n    res = (idx == 548) ? _S : res;\n    // 549\n    res = (idx == 550) ? _W : res;\n    res = (idx == 551) ? _H : res;\n    res = (idx == 552) ? _O : res;\n    res = (idx == 553) ? _M : res;\n    // 554\n    res = (idx == 555) ? _I : res;\n    // 556\n    res = (idx == 557) ? _F : res;\n    res = (idx == 558) ? _O : res;\n    res = (idx == 559) ? _R : res;\n    res = (idx == 560) ? _G : res;\n    res = (idx == 561) ? _O : res;\n    res = (idx == 562) ? _T : res;\n    // 563\n    res = (idx == 564) ? _T : res;\n    res = (idx == 565) ? _O : res;\n    // 566\n    res = (idx == 567) ? _M : res;\n    res = (idx == 568) ? _E : res;\n    res = (idx == 569) ? _N : res;\n    res = (idx == 570) ? _T : res;\n    res = (idx == 571) ? _I : res;\n    res = (idx == 572) ? _O : res;\n    res = (idx == 573) ? _N : res;\n    res = (idx == 574) ? _DOT : res;\n    // 575\n    // 576\n    // 577\n    // 578\n    // 579\n    // 580\n    // 581\n    // 582\n    // 583\n    // 584\n    // 585\n    res = (idx == 586) ? _S : res;\n    res = (idx == 587) ? _P : res;\n    res = (idx == 588) ? _E : res;\n    res = (idx == 589) ? _C : res;\n    res = (idx == 590) ? _I : res;\n    res = (idx == 591) ? _A : res;\n    res = (idx == 592) ? _L : res;\n    // 593\n    res = (idx == 594) ? _T : res;\n    res = (idx == 595) ? _H : res;\n    res = (idx == 596) ? _A : res;\n    res = (idx == 597) ? _N : res;\n    res = (idx == 598) ? _K : res;\n    res = (idx == 599) ? _S : res;\n    // 600\n    res = (idx == 601) ? _T : res;\n    res = (idx == 602) ? _O : res;\n    // 603\n    res = (idx == 604) ? _M : res;\n    res = (idx == 605) ? _Y : res;\n    // 606\n    res = (idx == 607) ? _F : res;\n    res = (idx == 608) ? _A : res;\n    res = (idx == 609) ? _M : res;\n    res = (idx == 610) ? _I : res;\n    res = (idx == 611) ? _L : res;\n    res = (idx == 612) ? _Y : res;\n    res = (idx == 613) ? _EX : res;\n    // 614\n    // 615\n    res = (idx == 616) ? _HEART : res;\n    // 617\n    res = (idx == 618) ? _HEART : res;\n    // 619\n    res = (idx == 620) ? _HEART : res;\n    // 621\n    res = (idx == 622) ? _A : res;\n    res = (idx == 623) ? _I : res;\n    res = (idx == 624) ? _D : res;\n    res = (idx == 625) ? _A : res;\n    res = (idx == 626) ? _COMMA : res;\n    // 627\n    res = (idx == 628) ? _A : res;\n    res = (idx == 629) ? _R : res;\n    res = (idx == 630) ? _S : res;\n    res = (idx == 631) ? _E : res;\n    res = (idx == 632) ? _N : res;\n    res = (idx == 633) ? _I : res;\n    res = (idx == 634) ? _I : res;\n    // 635\n    res = (idx == 636) ? _A : res;\n    res = (idx == 637) ? _N : res;\n    res = (idx == 638) ? _D : res;\n    // 639\n    res = (idx == 640) ? _M : res;\n    res = (idx == 641) ? _A : res;\n    res = (idx == 642) ? _T : res;\n    res = (idx == 643) ? _V : res;\n    res = (idx == 644) ? _E : res;\n    res = (idx == 645) ? _I : res;\n    // 646\n    res = (idx == 647) ? _HEART : res;\n    // 648\n    res = (idx == 649) ? _HEART : res;\n    // 650\n    res = (idx == 651) ? _HEART : res;\n    // 652\n    // 653\n    // 654\n    // 655\n    // 656\n    // 657\n    res = (idx == 658) ? _T : res;\n    res = (idx == 659) ? _H : res;\n    res = (idx == 660) ? _A : res;\n    res = (idx == 661) ? _T : res;\n    // 662\n    res = (idx == 663) ? _A : res;\n    res = (idx == 664) ? _L : res;\n    res = (idx == 665) ? _L : res;\n    // 666\n    res = (idx == 667) ? _F : res;\n    res = (idx == 668) ? _O : res;\n    res = (idx == 669) ? _L : res;\n    res = (idx == 670) ? _K : res;\n    res = (idx == 671) ? _S : res;\n    res = (idx == 672) ? _EX : res;\n    // 673\n    res = (idx == 674) ? _T : res;\n    res = (idx == 675) ? _H : res;\n    res = (idx == 676) ? _A : res;\n    res = (idx == 677) ? _N : res;\n    res = (idx == 678) ? _K : res;\n    // 679\n    res = (idx == 680) ? _Y : res;\n    res = (idx == 681) ? _O : res;\n    res = (idx == 682) ? _U : res;\n    // 683\n    res = (idx == 684) ? _F : res;\n    res = (idx == 685) ? _O : res;\n    res = (idx == 686) ? _R : res;\n    // 687\n    res = (idx == 688) ? _W : res;\n    res = (idx == 689) ? _A : res;\n    res = (idx == 690) ? _T : res;\n    res = (idx == 691) ? _C : res;\n    res = (idx == 692) ? _H : res;\n    res = (idx == 693) ? _I : res;\n    res = (idx == 694) ? _N : res;\n    res = (idx == 695) ? _G : res;\n    res = (idx == 696) ? _EX : res;\n    res = (idx == 697) ? _EX : res;\n    res = (idx == 698) ? _EX : res;\n    \n    return res;\n}\n\n\n\nfloat getBottomScroller(int x, int y, int frame)\n{\n    frame = imod(frame, 2816);\n    \n    // left to right offset\n    int sx = x +(frame * 2);\n    \n    //linear scroller\n    //int kJumpSpeed = 100;\n    int kJumpSpeed = 1;\n    \n    int chPos = sx / 8;\n    \n    // cosine height\n    float _x = float(chPos + (frame * kJumpSpeed));\n    _x = _x * 0.09;\n    \n    //linear scroller\n    //_x = _x * 0.001;\n\n    //get character local x,y\n    int _y = int(164.0 + cos(_x) * 28.0);\n    \n    int local_y = (y+8) - _y;\n    int local_x = imod(sx, 8);\n    \n    float ch_pixel = 0.0;\n    if (local_y >= 0 && local_y < 8)\n    {\n        vec4 ch_bits = getCharBitsByIndex(chPos);\n        ch_pixel = getCharPixel(local_x, local_y, ch_bits);\n    }\n\n //  return ch_pixel;\n    \n    // scroll grid\n    vec2 ab = (imod(frame,2) == 0) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n\n    int iy = imod(frame+1, 8);\n    int ix = -imod(frame+1, 8);\n    \n    float grid_pixel = 0.0;\n    if (imod(iy+y, 8) == 0)\n    {\n        grid_pixel = ((imod(x, 2) > 0) ? ab.y : ab.x);\n    }\n    \n    if (imod(ix+x, 8) == 0)\n    {\n        grid_pixel = ((imod(y, 2) > 0) ? ab.y : ab.x);\n     }\n        \n    return max(grid_pixel, ch_pixel);\n}\n\n\n// border (multi-color effect)\nint getBorderColor(int x, int y, int frame)\n{\n    y = y + (frame*5);\n    int v = (y/4);\n    \n    int vv = 13 + int(55.0 * hash(vec2(v, v)));\n    \n    return 1 + imod(vv, 7);\n}\n\n//\nvec3 getColor(vec2 fragCoord)\n{\n    float fFrame = (iTime * kRefreshRate);\n    fFrame = fFrame - fract(fFrame);\n    int frame = int(fFrame);\n    \n    float aspect = iResolution.x / iResolution.y;\n    float zxAspect = (kResolution.x / kResolution.y);\n    \n    vec2 borderMul = vec2((zxAspect / aspect), 1);\n    borderMul = borderMul * 0.95;\n    \n    // screen size in pixels (without border)\n    vec2 screenSize = (iResolution.xy * borderMul);\n    \n    // virtual pixel size in real pixels\n    vec2 vPixelSize = screenSize / kResolution;\n    \n    // virtual pixel size to integers\n    vPixelSize = vPixelSize - fract(vPixelSize);\n    vPixelSize = max(vPixelSize, kMinVirtualPixelSize);\n    //vPixelSize = kMinVirtualPixelSize;\n    \n    // compute border offset\n    vec2 borderOffset = (iResolution.xy - vPixelSize * kResolution) * 0.5; \n    \n    // swap horizontal\n    fragCoord.y = iResolution.y - fragCoord.y;\n    \n    // apply border offset\n    fragCoord.xy -= borderOffset;\n    \n    // convert fragment coordinates to virtual pixel coords\n    vec2 v = fragCoord / vPixelSize;\n    v = v - fract(v);\n    \n    // attrbute coordinate\n    vec2 av = v / vec2(8.0, 8.0);\n    av = av - fract(av);\n    \n    // \n    int px = int(v.x);\n    int py = int(v.y);\n    \n    int ax = int(av.x);\n    int ay = int(av.y);\n    \n    // get border color\n    if (v.x >= kResolution.x || v.y >= kResolution.y || v.x < 0.0 || v.y < 0.0)\n    {\n        vec3 borderClr = getColorFromPalette(getBorderColor(px, py, frame));\n        \n        const float ml = 0.1;\n        float v0 = saturate((v.x - 286.0) * -ml);\n        float v1 = saturate((v.x + 30.0) * ml);\n        float v2 = saturate((v.y + 30.0) * ml);\n        float v3 = saturate((v.y - 222.0) * -ml);\n        //float vig = min(min(min(v0, v1), v2), v3);\n        float vig = v0*v1*v2*v3;\n        \n        return borderClr * vig;\n    }\n\n    // get pixel bit\n    float pixelBit = 0.0;\n\n    if (py >= 0 && py < 64)\n    {\n        pixelBit = max(pixelBit, getTopSprites(px, py, frame));\n    }\n    \n    if (py >= 64 && py < 128)\n    {\n        pixelBit = max(pixelBit, getSprites(px, py, frame));\n    }\n    \n    if (py >= 128)\n    {\n        pixelBit = max(pixelBit, getBottomScroller(px, py, frame));\n    }\n\n    int background = 0;\n    int foreground = 15;\n    getAttributeColors(ax, ay, frame, background, foreground);\n    \n    int clr = (pixelBit > 0.0) ? foreground : background;\n    \n    return getColorFromPalette(clr);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = getColor(fragCoord.xy);    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": "llf3DB", "previewfilepath": "https://soundcloud.com/user-794660217/zx-spectrum-bzyk-startrip", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-794660217/zx-spectrum-bzyk-startrip", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 278, 298, 298, 365], [367, 367, 391, 391, 433], [435, 435, 460, 460, 495], [2028, 2028, 2066, 2296, 2436], [2438, 2555, 2604, 2604, 2893], [2895, 2997, 3063, 3063, 3474], [10272, 10286, 10319, 10319, 11513], [11515, 11515, 11549, 11549, 14807], [14809, 14809, 14862, 14862, 15286], [15288, 15319, 15415, 15415, 15821], [15823, 15826, 15872, 15872, 20071], [20074, 20074, 20117, 20133, 22943], [22946, 22946, 22980, 22980, 43375], [43379, 43379, 43429, 43429, 44566], [44569, 44600, 44645, 44645, 44775], [44777, 44780, 44811, 44811, 47228], [47232, 47232, 47289, 47289, 47365]], "test": "valid"}
{"id": "ltKyRy", "name": "Wave test 2", "author": "budsan", "description": "Second version of the ps3 menu waving thing in the background, but my color selection.", "tags": ["2d", "wave"], "likes": 0, "viewed": 75, "published": "Public", "date": "1536826265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mn = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/mn;\n\n    vec3 col1 = vec3(uv.x, 0.0, uv.y);\n    vec3 col2 = vec3(0.0, 0.5 + uv.y * 0.5, uv.x);\n    float s1 = 0.1 * sin(iTime + (uv.x * 5.0)) + 0.5 - uv.y;\n    float s2 = 0.2 * cos(iTime * 0.5 + (uv.x *2.0)) + 0.5 - uv.y;\n    \n    float m = smoothstep(0.0001, -0.0001, s1 * s2);\n    vec3 col = mix(col1, col2, m);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 479]], "test": "valid"}
{"id": "ltKyWG", "name": "Uncoiling", "author": "PianiGiani", "description": "This is my very first shader code.  Possibly not the most efficient code but - hey!, I'm still learning.  ", "tags": ["lines", "spirograph", "coils"], "likes": 4, "viewed": 126, "published": "Public", "date": "1537564996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define DST 0.001\n#define WD 1.5\n#define STP 5.\n#define RES 500.\n\nfloat Dline(vec2 p, vec2 a, vec2 b) {\n\t// line drawing function from BigWings\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.1);\n    return length(pa-ba*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float va = (cos(iTime/6.)+.5)*20.;\n    float shape = 3.+(cos(iTime/35.)*2.);\n    \n    float col=0.0;\n    float i=0.0;\n    for(int i2=0;i2<1000;i2++)\n    {\n        i+=shape;\n        if (i >= 100.) {break;}\n        float r=va;\n        float rr=120.;\n        float p=va;\n        float ii=i+shape;\n    \tvec2 myA = vec2((r+rr)*cos(i)+p*cos(r+rr)*i/r,(r+rr)*sin(i)+p*sin(r+rr)*i/r);\n    \tvec2 myB = vec2((r+rr)*cos(ii)+p*cos(r+rr)*ii/r,(r+rr)*sin(ii)+p*sin(r+rr)*ii/r);\n    \n    \tfloat d = Dline(uv, myA/RES, myB/RES);\n   \t \tfloat m = S(WD/200., (WD/200.)-(0.02-(i/9000.)), d)*WD;\n    \tcol = max(m,col);\t\n    }\n    fragColor = vec4(vec3(col*(cos(iTime/15.)/2.+1.2),col*(sin(iTime/23.)/2.+1.2), col*(sin(iTime/10.)/2.+1.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 138, 178, 300], [303, 303, 360, 360, 1155]], "test": "valid"}
{"id": "ltKyz3", "name": "rings of sin(r)", "author": "cmarangu", "description": "not sure how to describe this other than it is my first [successful] shader", "tags": ["blue", "pattern", "first", "cyan"], "likes": 2, "viewed": 79, "published": "Public", "date": "1537202664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pxy = fragCoord/iResolution.xy;\n    \n    vec2 rxy = fragCoord;\n\n    float r = sqrt(rxy.x*rxy.x+rxy.y*rxy.y)*3.14/iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = vec3(0, 0.5+0.5*sin(r*r*iResolution.x+iTime*3.0), 1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 404]], "test": "valid"}
{"id": "ltVcDG", "name": "Amsterdam", "author": "tqle", "description": "Project on Spheres", "tags": ["spheres"], "likes": 3, "viewed": 429, "published": "Public", "date": "1537580812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Rotation\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n//Changing vector p\nvoid pMod(inout vec3 p, vec3 rad) {\n\tp = mod(p + rad*0.5, rad) - rad*.5;\n}\n//Create spheres\nfloat sphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\n//Map distance\nfloat map(vec3 p) {\n    vec3 q = p;\n\n    pMod(q, vec3(0.75, 1., 0.8));\n    \n    float s1 = sphere(p, sin(iTime)); \n    float s2 = sphere(q, .5);\n    \n    float disp = .75 * (p.x *\n                       p.y *\n                       p.z);\n    s1 += disp;\n\treturn min(s1, s2); //return union    \n}\n\n//Trace\nfloat trace(vec3 origin, vec3 ray) \n{\n  float disp = 0.0;\n    for (int i = 0; i < 128; ++i) {\n        vec3 p = origin + ray * disp;\n        float d = map(p);\n        disp += d*.05;\n        }\n    return disp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.924, 0.24, 0.336);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = cos(iTime)*.75;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 og = vec3(iTime, 0.0, -1.75);\n    float tr = trace(og, ray);\n    //Other experiments\n    //tr -= smoothstep(.5, tan(iTime), sin(iTime)*length(uv));\n    //tr *= 1.- smoothstep(.1, sin(iTime), length(uv));\n    float expFog = 0.5 / (tr*tr* 0.45); //fog\n    vec3 fc = vec3(expFog); //instantiating fog\n    \n    fragColor = vec4(cos(fc*cos(iTime)+color),sin(iTime)*1.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVcDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 11, 30, 30, 98], [99, 119, 154, 154, 193], [194, 211, 244, 244, 274], [276, 291, 310, 310, 586], [588, 596, 633, 633, 805], [808, 808, 865, 865, 1512]], "test": "valid"}
{"id": "ltVcRG", "name": "Spiral Circle", "author": "tiff", "description": "Rainbow Spiral, Circle", "tags": ["circle"], "likes": 2, "viewed": 90, "published": "Public", "date": "1536942118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float tau = 3.1415926535*3.0;\n    float a = atan(p.x,p.y);\n    float r = length(p)*0.75;\n    vec2 uv = vec2(a/tau,r);\n\t\n\t//get the color\n\tfloat xCol = (uv.x - (iTime / 5.0)) * 10.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += cos(1.0 - xCol);\n\t\thorColour.g += cos(xCol);\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\n\t// draw color beam\n\tuv = (1.5 * uv) - 0.75;\n\tfloat beamWidth = (0.7+0.5*sin(uv.x*10.0*tau*0.25*clamp(floor(5.0 + 10.0*cos(iTime)), 2.0, 20.0))) * cos(5.0 / (50.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\tfragColor = vec4((( horBeam) * horColour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 894]], "test": "valid"}
{"id": "ltVczc", "name": "Assignment 2 - CSC 550", "author": "richardMartin", "description": "Assignment 2 for CSC 550, 3 planes, 2 shapes, 1 shape made of triangles with 10 unique vertices  and tectures applied to at least one shape.", "tags": ["raytracing", "ray", "sphere", "plane"], "likes": 2, "viewed": 95, "published": "Public", "date": "1537543263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://github.com/yuichiroharai/glsl-y-rotate/blob/master/rotateY.glsl\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateX(float rad)\n{\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3\n    (\n\t\t1.0, 0.0, 0.0,\n        0.0, c, s,\n\t\t0.0, -s, c\n\t\t\n\t);\n}\n\n// plane trace from class\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection, \n                 in vec3 planePos, in vec3 planeNormal, \n               out vec3 intersectPos, out vec3 intersectDir)\n{\n    float denom = dot(-rayDirection, planeNormal);\n    \n    if(denom < 0.0001)\n        return false;\n        \n    float t = dot(rayPos - planePos, planeNormal)/denom;\n        \n    //the point on the plane is...\n    intersectPos = rayPos + rayDirection *t;\n    \n    intersectDir = reflect ( rayDirection, planeNormal);\n    \n    return true;\n        \n}\n\n// sphere trace from class\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection, \n                 in vec3 spherePos, in float sphereRadius, \n                 out vec3 intersectPos, out vec3 intersectDir )\n{\n    /*\n\t\tmath from Dr Landon and\n\t\thttps://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\t*/\n    \n    // vector between center and ray origin \n    vec3 L = spherePos - rayPos;\n    \n    // through geometry and trig\n    // A dot B = abs(a)*abs(b)Cos(angle between them)\n    // because the projection of vector B onto A will give us the length of AB\n    // the length of AB is tca\n    // let L = A and D = B\n    float tca = dot (L, rayDirection);\n    \n    // the only way tca is negative is\n    // if the two vectors are going in opposite dirrections\n    if(tca < 0.0)\n        return false;\n    \n    // altered pathagorean theorem\n    float d = sqrt(dot(L,L) - pow(tca,2.0));\n    \n    // if d is less than the sphere radius then it intersected.\n    if(d > sphereRadius)\n    \treturn false;\n    \n    float thc = sqrt(pow(sphereRadius, 2.0) - pow(d,2.0));\n    \n    // distance from ray Start to hitting the sphere\n    float t1 = tca - thc;\n    \n    // results in 3D point where ray hits the sphere\n    intersectPos = rayPos + rayDirection*t1;\n    \n    vec3 normal = normalize(intersectPos - spherePos);\n    \n    intersectDir = reflect(rayDirection, normal);\n    \n    return true;\n    \n}\n\nconst vec3 plane_Pos[3] = vec3[3](vec3(0.0),\n                                 \tvec3(10.0,0.0,0.0),\n                                 \tvec3(10,0.0,0.0)\n                                 );\n\nconst vec3 plane_Norms[3] = vec3[3](vec3(0.0,1.0,0.0),\n                                   \tvec3(1.0,0.0,0.0),\n                                   \tvec3(-1.0,0.0,0.0)\n                                   );\n\nconst vec3 plane_Col[3] = vec3[3](vec3(0.02),\n                                  vec3(0.25),\n                                  vec3(0.3)\n                                 );\n\nconst vec3 sphere_Pos[3] = vec3[3](vec3(0.5,2.0,0.0),\n                                   vec3(-1.0,2.0,3.0),\n                                   vec3(0.5,0.2,0.5)\n                                   );\n\nconst float sphere_Radius[3] = float[3](float(0.7),\n                                        float(0.25),\n                                        float(0.1)\n                                        );\n\nconst vec3 sphere_Col[3] = vec3[3]( vec3(0.5, 0.5, 0.0),\n                                    vec3(0.2, 0.2, 1.0),\n                                    vec3(1.0)                                    \n    \t\t\t\t\t\t\t\t);\n\nconst vec3 CUBE0_VERTS[12] = vec3[12](\nvec3( -2.69549430482 ,  0.0 ,  -1.0 ), \nvec3( -1.97188747995 ,  0.525731086731 ,  -0.447213590145 ), \nvec3( -2.97188756935 ,  0.850650906563 ,  -0.44721364975 ), \nvec3( -3.58992160432 ,  -7.81933167104e-08 ,  -0.44721364975 ), \nvec3( -2.97188759915 ,  -0.850650787354 ,  -0.447213590145 ), \nvec3( -1.97188753955 ,  -0.525731146336 ,  -0.447213590145 ), \nvec3( -1.80106700532 ,  0.0 ,  0.44721364975 ), \nvec3( -2.4191011297 ,  0.850650846958 ,  0.447213590145 ), \nvec3( -3.4191011893 ,  0.525731086731 ,  0.44721364975 ), \nvec3( -3.41910107009 ,  -0.52573120594 ,  0.447213590145 ), \nvec3( -2.41910098068 ,  -0.850650787354 ,  0.447213590145 ), \nvec3( -2.69549430482 ,  0.0 ,  1.0 ) \n);\nconst ivec3 CUBE0_INDEX[20] = ivec3[20](\nivec3( 0 ,  2 ,  1 ), \nivec3( 0 ,  3 ,  2 ), \nivec3( 0 ,  4 ,  3 ), \nivec3( 0 ,  5 ,  4 ), \nivec3( 0 ,  1 ,  5 ), \nivec3( 1 ,  2 ,  7 ), \nivec3( 2 ,  3 ,  8 ), \nivec3( 3 ,  4 ,  9 ), \nivec3( 4 ,  5 ,  10 ), \nivec3( 5 ,  1 ,  6 ), \nivec3( 1 ,  7 ,  6 ), \nivec3( 2 ,  8 ,  7 ), \nivec3( 3 ,  9 ,  8 ), \nivec3( 4 ,  10 ,  9 ), \nivec3( 5 ,  6 ,  10 ), \nivec3( 6 ,  7 ,  11 ), \nivec3( 7 ,  8 ,  11 ), \nivec3( 8 ,  9 ,  11 ), \nivec3( 9 ,  10 ,  11 ), \nivec3( 10 ,  6 ,  11 ) \n);\n\nconst vec3 CUBE1_VERTS[32] = vec3[32](\nvec3( 0.0 ,  2.09963607621 ,  -1.0 ), \nvec3( 0.723606824875 ,  2.62536716294 ,  -0.447213590145 ), \nvec3( -0.276393264532 ,  2.95028698277 ,  -0.44721364975 ), \nvec3( -0.8944272995 ,  2.09963599802 ,  -0.44721364975 ), \nvec3( -0.276393294334 ,  1.24898528886 ,  -0.447213590145 ), \nvec3( 0.72360676527 ,  1.57390492988 ,  -0.447213590145 ), \nvec3( 0.8944272995 ,  2.09963607621 ,  0.44721364975 ), \nvec3( 0.276393175125 ,  2.95028692317 ,  0.447213590145 ), \nvec3( -0.72360688448 ,  2.62536716294 ,  0.44721364975 ), \nvec3( -0.72360676527 ,  1.57390487027 ,  0.447213590145 ), \nvec3( 0.276393324137 ,  1.24898528886 ,  0.447213590145 ), \nvec3( 0.0 ,  2.09963607621 ,  1.0 ), \nvec3( 0.187592461705 ,  2.67698627543 ,  -0.794654488564 ), \nvec3( -0.491123467684 ,  2.45645811987 ,  -0.794654488564 ), \nvec3( -0.491123467684 ,  1.74281400275 ,  -0.794654488564 ), \nvec3( 0.187592402101 ,  1.52228587699 ,  -0.794654488564 ), \nvec3( 0.607061982155 ,  2.09963605121 ,  -0.794654488564 ), \nvec3( 0.303530991077 ,  3.0338084085 ,  -0.187592476606 ), \nvec3( -0.794654488564 ,  2.67698621583 ,  -0.187592461705 ), \nvec3( -0.794654488564 ,  1.52228575778 ,  -0.187592461705 ), \nvec3( 0.30353102088 ,  1.16546374392 ,  -0.187592476606 ), \nvec3( 0.982246935368 ,  2.09963605121 ,  -0.187592461705 ), \nvec3( 0.794654488564 ,  2.67698633504 ,  0.187592476606 ), \nvec3( -0.30353102088 ,  3.0338084085 ,  0.187592476606 ), \nvec3( -0.982246994972 ,  2.0996359762 ,  0.187592491508 ), \nvec3( -0.303530961275 ,  1.16546374392 ,  0.187592476606 ), \nvec3( 0.794654488564 ,  1.52228581738 ,  0.187592476606 ), \nvec3( 0.491123437881 ,  2.45645817947 ,  0.794654488564 ), \nvec3( -0.187592476606 ,  2.67698627543 ,  0.794654428959 ), \nvec3( -0.607061982155 ,  2.0996360012 ,  0.794654428959 ), \nvec3( -0.187592417002 ,  1.52228581738 ,  0.794654488564 ), \nvec3( 0.491123467684 ,  1.74281403255 ,  0.794654428959 ) \n);\n\nconst ivec3 CUBE1_INDEX[60] = ivec3[60](\nivec3( 0 ,  2 ,  12 ), \nivec3( 2 ,  1 ,  12 ), \nivec3( 1 ,  0 ,  12 ), \nivec3( 0 ,  3 ,  13 ), \nivec3( 3 ,  2 ,  13 ), \nivec3( 2 ,  0 ,  13 ), \nivec3( 0 ,  4 ,  14 ), \nivec3( 4 ,  3 ,  14 ), \nivec3( 3 ,  0 ,  14 ), \nivec3( 0 ,  5 ,  15 ), \nivec3( 5 ,  4 ,  15 ), \nivec3( 4 ,  0 ,  15 ), \nivec3( 0 ,  1 ,  16 ), \nivec3( 1 ,  5 ,  16 ), \nivec3( 5 ,  0 ,  16 ), \nivec3( 1 ,  2 ,  17 ), \nivec3( 2 ,  7 ,  17 ), \nivec3( 7 ,  1 ,  17 ), \nivec3( 2 ,  3 ,  18 ), \nivec3( 3 ,  8 ,  18 ), \nivec3( 8 ,  2 ,  18 ), \nivec3( 3 ,  4 ,  19 ), \nivec3( 4 ,  9 ,  19 ), \nivec3( 9 ,  3 ,  19 ), \nivec3( 4 ,  5 ,  20 ), \nivec3( 5 ,  10 ,  20 ), \nivec3( 10 ,  4 ,  20 ), \nivec3( 5 ,  1 ,  21 ), \nivec3( 1 ,  6 ,  21 ), \nivec3( 6 ,  5 ,  21 ), \nivec3( 1 ,  7 ,  22 ), \nivec3( 7 ,  6 ,  22 ), \nivec3( 6 ,  1 ,  22 ), \nivec3( 2 ,  8 ,  23 ), \nivec3( 8 ,  7 ,  23 ), \nivec3( 7 ,  2 ,  23 ), \nivec3( 3 ,  9 ,  24 ), \nivec3( 9 ,  8 ,  24 ), \nivec3( 8 ,  3 ,  24 ), \nivec3( 4 ,  10 ,  25 ), \nivec3( 10 ,  9 ,  25 ), \nivec3( 9 ,  4 ,  25 ), \nivec3( 5 ,  6 ,  26 ), \nivec3( 6 ,  10 ,  26 ), \nivec3( 10 ,  5 ,  26 ), \nivec3( 6 ,  7 ,  27 ), \nivec3( 7 ,  11 ,  27 ), \nivec3( 11 ,  6 ,  27 ), \nivec3( 7 ,  8 ,  28 ), \nivec3( 8 ,  11 ,  28 ), \nivec3( 11 ,  7 ,  28 ), \nivec3( 8 ,  9 ,  29 ), \nivec3( 9 ,  11 ,  29 ), \nivec3( 11 ,  8 ,  29 ), \nivec3( 9 ,  10 ,  30 ), \nivec3( 10 ,  11 ,  30 ), \nivec3( 11 ,  9 ,  30 ), \nivec3( 10 ,  6 ,  31 ), \nivec3( 6 ,  11 ,  31 ), \nivec3( 11 ,  10 ,  31 ) \n);\n\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+trd = p(u,v) = vo + u(v1-v0) + v(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= 0.6;\n  \tvec3 col = vec3(0.0);// set background to black \n    \n    vec3 lightDir = vec3(0,1,0);\n    vec3 lightDir2 = normalize(vec3(1,-1,1));\n\n    vec3 rayPos = vec3(-1,4, 6);// position of initial ray\n    vec3 rayDir = normalize(vec3(uv.x - 0.0, uv.y - 0.2, -0.9));// dirrection of initial ray\n    \n    vec3 newPos;\n    vec3 newDir;\n    vec3 currCol;\n    float currSpec;\n    \n    vec3 starPos = vec3(1,2,2);\n     \n    vec3 tempPos = sphere_Pos[1]*rotateY(iTime/1.5*float(1));\n    \n    // loop for ray bouncing\n    for(int r = 0; r < 3; ++r)\n    {\n        // variables from class\n    \tfloat minDist = 999999999.0;\n        vec3 tempNewPos;\n        vec3 tempNewDir;\n        \n        \n        \n        // loop for each plane\n        for(int p = 0; p < 3; ++p)\n        {\n        \tif(planeTrace(rayPos, rayDir,\n                          plane_Pos[p], plane_Norms[p],\n                          tempNewPos, tempNewDir))\n            {\n            \tfloat dist = distance(rayPos, tempNewPos);\n             \t\n                if(dist < minDist)\n                {\n                    minDist = dist;\n                    \n                    newPos = tempNewPos;\n                    newDir = tempNewDir;\n                    {\n                    \tcurrCol = vec3(0.0);\n                    }\n                }\n            }\n            \n        }\n        // cube0\n        for (int f = 0; f < 20; ++f) \n        {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  ((CUBE0_VERTS[CUBE0_INDEX[f].x]/5.0) * rotateY(iTime*float(-3))) + tempPos,\n                              ((CUBE0_VERTS[CUBE0_INDEX[f].y]/5.0) * rotateY(iTime*float(-3))) + tempPos,\n                              ((CUBE0_VERTS[CUBE0_INDEX[f].z]/5.0) * rotateY(iTime*float(-3))) + tempPos,\n\t\t\t\ttempNewPos, tempNewDir)) \n            {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist)\n                {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrCol = currCol = texture(iChannel2, vec2(newPos.y,newPos.z)).rgb;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        // cube1\n        for (int f = 0; f < 60; ++f) \n        {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  ((CUBE1_VERTS[CUBE1_INDEX[f].x]/1.5) * rotateX(iTime*float(2)) + (sphere_Pos[0])),\n                              ((CUBE1_VERTS[CUBE1_INDEX[f].y]/1.5) * rotateX(iTime*float(2)) + (sphere_Pos[0])),\n                              ((CUBE1_VERTS[CUBE1_INDEX[f].z]/1.5) * rotateX(iTime*float(2)) + (sphere_Pos[0])),\n\t\t\t\ttempNewPos, tempNewDir)) \n            {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist)\n                {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrCol = texture(iChannel1, vec2(newPos.y,newPos.z)).rgb;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        // loop for sphere 0 and 1\n        for(int s = 0; s < 2; ++s)\n        {\n           if(sphereTrace(rayPos, rayDir,\n              \tsphere_Pos[s]*rotateY(iTime/1.5*float(s)), sphere_Radius[s],\n            \ttempNewPos, tempNewDir))\n           {\n            \tfloat dist = distance(rayPos, tempNewPos);\n\n                if(dist < minDist)\n                {\n                     minDist = dist;\n\n                     newPos = tempNewPos;\n                     newDir = tempNewDir;\n\n                     currCol = sphere_Col[s];\n\n                     currSpec = 0.1;\n                 }\n             }\n        }\n        \n        // check for sphere 3 to make sure it stays around sphere 2\n        if(sphereTrace(rayPos, rayDir,\n           rotateY(iTime*float(4))*sphere_Pos[2] + tempPos, sphere_Radius[2],\n           tempNewPos, tempNewDir))\n                {\n\n                    float dist = distance(rayPos, tempNewPos);\n\n                    if(dist < minDist)\n                    {\n\n                        minDist = dist;\n\n                        newPos = tempNewPos;\n                        newDir = tempNewDir;\n\n                        currCol = sphere_Col[2];\n\n                        currSpec = 0.1;\n\n                    }\n                }\n       \n        rayPos = newPos;\n        rayDir = newDir;\n        \n        if(r == 0)\n        {\n        \tcol += currCol*0.2 \n            + clamp(dot(rayDir, lightDir),0.0,1.0)*vec3(0.4) //diffuse\n            ;\n        }\n        else \n        {\n        \tcol += (currCol*0.2 \n            + clamp(dot(rayDir, lightDir),0.0,1.0)*vec3(0.5)) //diffuse\n            *currSpec\n           ;\n        }\n\t}\n    \n    \n    \n\t// Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 100, 100, 205], [207, 207, 232, 232, 351], [353, 379, 553, 553, 904], [906, 933, 1114, 1327, 2365], [8220, 8220, 8377, 8377, 9156], [9159, 9159, 9216, 9266, 13827]], "test": "error"}
{"id": "ltVyD1", "name": "Terrain first test", "author": "saidwho12", "description": "saf", "tags": ["terraub"], "likes": 2, "viewed": 153, "published": "Public", "date": "1536194705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float RAY_T_MAX = 50.0;\nconst float RAY_T_MIN = 1e-1;\nconst float EPSILON = 1e-2;\nconst int   MARCH_STEPS_MAX = 200;\n/*\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n*/\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 fade(in vec2 p) {\n\treturn 6.0*pow(p,vec2(5.0)) - 15.0*pow(p,vec2(4.0)) + 10.0*pow(p,vec2(3.0));\n}\n\nfloat perlin(in vec2 p) {\n\tvec2 a = floor(p), b = a + 1.0;\n    vec2 s = fade(p-a);\n    \n    float a1 = hash12(a)  * radians(360.0);\n    vec2 v1 = vec2(cos(a1), sin(a1));\n    \n    vec2 p2 = vec2(b.x, a.y);\n    float a2 = hash12(p2) * radians(360.0);\n    vec2 v2 = vec2(cos(a2), sin(a2));\n    \n    vec2 p3 = vec2(a.x, b.y);\n    float a3 = hash12(p3) * radians(360.0);\n    vec2 v3 = vec2(cos(a3), sin(a3));\n    \n    float a4 = hash12(b) * radians(360.0);\n    vec2 v4 = vec2(cos(a4), sin(a4));\n    \n    vec2 d1 = normalize(v1-p);\n    vec2 d2 = normalize(v2-p);\n    vec2 d3 = normalize(v3-p);\n    vec2 d4 = normalize(v4-p);\n    \n    float g1 = dot(d1, v1);\n    float g2 = dot(d2, v2);\n    float g3 = dot(d3, v3);\n    float g4 = dot(d4, v4);\n    \n    return mix(mix(g1, g2, s.x), mix(g3, g4, s.x), s.y);\n}\n\nfloat sdSphere(in vec3 p, in float r) { return length(p)-r; }\nfloat udBox(in vec3 p, in vec3 b) { return length(max(abs(p)-b, 0.0)); }\n\nmat2 rotate(in float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat f(in vec3 p) {\n    p.xz *= 0.5;\n    //p.xz = rotate(0.1 * iTime * radians(360.0)) * p.xz;\n    \n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n    float q = 0.5;\n    \n    //p.xz = abs(p.xz);\n    \n    float h = 0.0;\n    for(int i = 0; i < 6; ++i) {\n    \th += q * perlin(p.xz);\n    \tp.xz = m * p.xz;\n        q *= 0.4;\n    }\n    \n    float w = p.y + 0.25;\n    \n    return 0.5 * (p.y - h);\n    \n    //return p.y - 0.1*sin((length(p.xz) - iTime) * radians(360.0));\n    /*\n    p.xz = rotate(iTime) * p.xz;\n    vec2 uv = vec2((atan(p.y, p.x) + radians(180.0)) / radians(360.0),\n                   acos(p.z / length(p)) / radians(180.0));\n    \n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n    float q = 0.5;\n    \n    uv = uv * 2.0 - 1.0;\n    float h = 0.0;\n    for(int i = 0; i < 1; ++i) {\n    \th += q * perlin(uv);\n    \tuv = m * uv;\n        q *= 0.5;\n    }\n    \n    return sdSphere(p, 1.0) - 0.05*h;*/\n}\n\nvec3 n(in vec3 p) {\n\treturn normalize(vec3(\n    \tf(vec3(p.x + EPSILON, p.yz)) - f(vec3(p.x - EPSILON, p.yz)),\n        f(vec3(p.x, p.y + EPSILON, p.z)) - f(vec3(p.x, p.y - EPSILON, p.z)),\n        f(vec3(p.xy, p.z + EPSILON)) - f(vec3(p.xy, p.z - EPSILON))\n    ));\n}\n\nstruct Camera {\n\tvec3 pos;\n\tvec3 forward;\n    vec3 up;\n    vec3 right;\n};\n\nfloat trace(in vec3 ro, in vec3 rd) {\n\tfloat t = RAY_T_MIN;\n    int j = 0;\n    for(int i = 0; i < MARCH_STEPS_MAX; i++) {\n        vec3 p = ro + rd * t;\n    \tfloat r = f(p);\n        if(r < EPSILON || t > RAY_T_MAX) {\n            j = i;\n        \tbreak;\n        }\n        \n        t += r;\n    }\n    \n    if(j == MARCH_STEPS_MAX || t > RAY_T_MAX) {\n    \treturn RAY_T_MAX;\n    }\n    \n    return t;\n    \n}\n\nstruct PhongMaterial {\n    vec3 diffuse;\n    vec3 specular;\n    float a;\n};\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    Camera cam;\n    cam.pos = vec3(0.0, 4.0, -mod(iTime, 100.0));\n    cam.forward = vec3(0,0,-1);\n    cam.up = vec3(0,1,0);\n    cam.right = normalize(cross(cam.forward, cam.up));\n    vec3 rd = normalize(cam.forward + p.x * cam.right + p.y * cam.up);\n    \n    vec3 color = vec3(0);\n   \n    const vec3 skyblue = vec3(235.0, 255.0, 255.0) / 255.0;\n    const vec3 white = vec3(255.0, 255.0, 255.0) / 255.0;\n    float t = trace(cam.pos, rd);\n    if(t != RAY_T_MAX) {\n        vec3 p = cam.pos + rd * t;\n        vec3 normal = n(p);\n        \n    \t//color = vec3(t / RAY_T_MAX);\n    \t\n        float fogDist = 25.0;\n        float elevation = clamp(2.0*p.y * 0.5 + 0.5, 0.0, 1.0);\n        vec3 lightPos = vec3(1250.0, 2000.0, 500.0);\n        vec3 L = normalize(lightPos - p);\n        vec3 V = normalize(p - cam.pos);\n        vec3 R = reflect(L, normal);\n        float dotNL = max(dot(normal, L),0.0);\n        float dotNU = max(dot(normal, vec3(0,1,0)),0.0);\n        \n        vec3 snow = vec3(1.0) * clamp(pow(dotNU, 2.0),0.0,1.0);\n        \n        vec3 brown = vec3(237.0, 201.0, 175.0) / 255.0;\n        vec3 dirt = mix(brown, vec3(0.25),\n                        0.25 *\n                        (cos(radians(360.0) * (elevation*2.0 - 1.0)*0.5) * 0.5 + 0.5) *\n                        (sin(radians(360.0) * elevation * 20.0) * 0.5 + 0.5) *\n                       \t(perlin(p.xz) * 0.5 + 0.5)\n                       );\n        \n        color = dotNL * mix(dirt, mix(vec3(0.4,0.6,0.3), snow, elevation), pow(dotNU,4.0));\n        //color = dirt;\n        \n        float fog = /*(1.0 - 0.25*elevation) * */ min(exp(-3.0 * (1.0 - t/fogDist)),1.0);\n        color = mix(color, skyblue, fog);\n        \n        //color = normal * 0.5 + 0.5;\n    \n    \t//color += 0.25*dotNL;\n    } else {\n    \tcolor = mix(skyblue, white, p.y);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 392, 414, 414, 536], [538, 538, 560, 560, 640], [642, 642, 667, 667, 1441], [1443, 1443, 1482, 1482, 1504], [1505, 1505, 1540, 1540, 1577], [1579, 1579, 1608, 1608, 1689], [1691, 1691, 1711, 1711, 2584], [2586, 2586, 2605, 2605, 2850], [2927, 2927, 2964, 2964, 3326], [3405, 3405, 3460, 3460, 5414]], "test": "valid"}
{"id": "ltVyD3", "name": "Periodic2D Seeded Cellular Noise", "author": "Markyparky56", "description": "Adapted from Brian Sharpe's Cellular Noise Function", "tags": ["noise", "cellular", "periodic"], "likes": 4, "viewed": 149, "published": "Public", "date": "1538008493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from Brian Sharpe's Cellular Noise from https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvoid FAST32_hash_2D( vec2 gridcell, const float seed, float period, out vec4 hash_0, out vec4 hash_1 )\t//\tgenerates 2 random numbers for each of the 4 cell corners\n{    \n    const vec2 OFFSET = vec2( 26.0, 161.0 );\n    const float DOMAIN = 71.0;\n    const vec2 SOMELARGEFLOATS = vec2( 951.135664, 642.949883 );\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n        \n    // Wrap by period\n    P = mod(P, period);\n    \n    P = P - floor(P * ( 1.0 / (DOMAIN + seed) )) * (DOMAIN + seed);\n    P += OFFSET.xyxy + vec4(seed);\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 / SOMELARGEFLOATS.y ) );\n}\n\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\n//\n//\tCellular Noise 2D\n//\tBased off Stefan Gustavson's work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//\thttp://briansharpe.files.wordpress.com/2011/12/cellularsample.jpg\n//\n//\tSpeed up by using 2x2 search window instead of 3x3\n//\tproduces a range of 0.0->1.0\n//\nfloat Cellular2D(vec2 P, const float seed, float period)\n{\n    //\testablish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec2 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_x, hash_y;\n    FAST32_hash_2D( Pi, seed, period, hash_x, hash_y );\n    //SGPP_hash_2D( Pi, hash_x, hash_y );\n\n    //\tgenerate the 4 random points\n#if 1\n    //\trestrict the random point offset to eliminate artifacts\n    //\twe'll improve the variance of the noise by pushing the points to the extremes of the jitter window\n    const float JITTER_WINDOW = 0.25;\t// 0.25 will guarentee no artifacts.  0.25 is the intersection on x of graphs f(x)=( (0.5+(0.5-x))^2 + (0.5-x)^2 ) and f(x)=( (0.5+x)^2 + x^2 )\n    hash_x = Cellular_weight_samples( hash_x ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y = Cellular_weight_samples( hash_y ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n#else\n    //\tnon-weighted jitter window.  jitter window of 0.4 will give results similar to Stefans original implementation\n    //\tnicer looking, faster, but has minor artifacts.  ( discontinuities in signal )\n    const float JITTER_WINDOW = 0.4;\n    hash_x = hash_x * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y = hash_y * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n#endif\n\n    //\treturn the closest squared distance\n    vec4 dx = Pf.xxxx - hash_x;\n    vec4 dy = Pf.yyyy - hash_y;\n    vec4 d = dx * dx + dy * dy;\n    d.xy = min(d.xy, d.zw);\n    return min(d.x, d.y) * ( 1.0 / 1.125 );\t//\tscale return value from 0.0->1.125 to 0.0->1.0  ( 0.75^2 * 2.0  == 1.125 )\n}\n\nvec3 renderGrid(vec2 pos, float period, vec3 gridCol, vec3 colIn)\n{\n    pos.x = mod(pos.x, period*1.0);\n    pos.y = mod(pos.y, period*1.0);\n    float aa = 0.0000000025;\n    \n    vec2 toGrid = pos - round(pos);\n    if(pos.x > (toGrid.x - aa) && pos.x < (toGrid.x + aa)) return gridCol;\n    else if(pos.y > (toGrid.y - aa) && pos.y < (toGrid.y + aa)) return gridCol;\n   \telse return colIn;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    const float period = 7.0;\n    const float seed = 41.0;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    uv *= 16.0;\n    uv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));    \n\n    vec3 col = vec3(Cellular2D(uv, seed, period));    \n   \n    vec2 griduv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    griduv *= 16.0;\n    griduv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));\n    col = renderGrid(griduv, period, vec3(1.0,0.0,0.0), col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 292, 292, 802], [804, 804, 850, 850, 1041], [1043, 1311, 1369, 1418, 3037], [3039, 3039, 3106, 3106, 3428], [3430, 3430, 3484, 3484, 4061]], "test": "valid"}
{"id": "ltVyWh", "name": "Fake Iridescence (Thin oil film)", "author": "JuliaPoo", "description": "Iridescence is a phenomenal that causes a material to appear to be of a different colour depending on the direction at which you look at it. Here I approximated that effect with a simple function that involves dot(incident ray, normal vector).", "tags": ["raytracing", "cube", "metal", "iridescent"], "likes": 11, "viewed": 695, "published": "Public API", "date": "1536076402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Smooth min from iq: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n//Distance function\nfloat SDMere(vec3 pos, vec3 p, float r, float t){\n    return\n    smin(\n    smin(\n    length(max(abs(p-pos)-r+.05,0.0))-.05,\n    distance(p,pos+.35*vec3(sin(2.5*t+.2),sin(5.*t),cos(3.*t)))-.1*r,\n    20.),\n    distance(p,pos+.35*vec3(cos(5.*t+.7),cos(2.*t),sin(3.5*t)))-.1*r,\n    20.)\n    ;\n}\n\nfloat SDscene(vec3 p, float t){\n\tfloat d = SDMere(vec3(0,0,0),p,.2,t);\n\treturn d;\n}\n\n//SD normal\nvec3 SDn(vec3 p, float t){\n    float ep = 0.01;\n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z),t)-SDscene(vec3(p.x-ep,p.y,p.z),t),\n    SDscene(vec3(p.x,p.y+ep,p.z),t)-SDscene(vec3(p.x,p.y-ep,p.z),t),\n    SDscene(vec3(p.x,p.y,p.z+ep),t)-SDscene(vec3(p.x,p.y,p.z-ep),t)\n    ));\n}\n\n//phong shading (currenty broken)\nvec3 phong(vec3 p, float t){\n    \n    //Lights:\n    //Lights position\n    vec3 L1 = 3.*vec3(sin(2.5*t),cos(t),sin(t));\n    float dt = t+2.;\n    vec3 L2 = 3.*vec3(sin(2.5*dt),cos(dt),sin(dt));\n    //Lights intensity\n    vec3 i1s = vec3(1.);\n    vec3 i1d = vec3(1.);\n    vec3 ia = .4*vec3(1.);\n    \n    //Material:\n    //Spectral lighting\n    vec3 Tks = vec3(.7);\n    //Diffuse lighting\n    vec3 Tkd = .5*vec3(.9);\n    vec3 Tka = 3.*vec3(.45);\n    float alp = 100.;\n    \n    \n    vec3 L1v = normalize(L1-p);\n    vec3 L2v = normalize(L2-p);\n    vec3 N = SDn(p, t);\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 R2 = normalize(reflect(L2v,N));\n    vec3 J,Q;\n    float temp = dot(L1v,N);\n    float stemp = dot(R1,L1v);\n    if(temp>0.){J = Tkd*i1d*temp;}\n    if(stemp>0.){Q = Tks*i1d*pow(stemp,alp);}\n    float temp2 = dot(L2v,N);\n    float stemp2 = dot(R2,L2v);\n    if(temp2>0.){J += Tkd*i1d*temp2;}\n    if(stemp2>0.){Q += Tks*i1d*pow(stemp2,alp);}\n    \n    //Iridescence: IN reality it should be a function of dot(incident,reflected), and is much more complex\n    //\"Thickness\" of film\n    float k = 10.;\n    vec3 ir = Tka*ia*(.15*\n         vec3(\n         sin(k*temp)+sin(k*temp2),\n         sin(k*temp+.75)+sin(10.*temp2+.75),\n         cos(k*temp)+cos(k*temp2))\n         +1.3);\n    \n    vec3 I = ir + J + Q;\n    return I;\n}\n\n\n//raytracing\nfloat end = 10.;\nfloat depth(vec3 ro, vec3 rd, float t){\n    float dist=0., d;\n    int max=200;\n    float ep = 0.0001;\n    for (int i=0; i<max; i++){\n    d = SDscene(ro + dist*rd, t);\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > end){\n        return end;\n    }\n  }\n}\n\nvoid mainImage(out vec4 C, in vec2 S ) {\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (S / R-.5)*.75;\n    uv.y *= R.y/R.x;\n    vec2 T = iMouse.xy/R*5.;\n    float t = .2*iTime - 20.;\n\t\n    //Camera setup\n  \tfloat zoom = 5.;\n  \tvec3 ro = 2.*vec3(sin(T.x+t*.2)*cos(T.y+t*.3),sin(T.x+t*.2)*sin(T.y+t*.3),cos(T.x+t*.2));\n  \tvec3 lookat = vec3(0,0,0);\n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw + up*0.;\n  \tvec3 scrP = scrC + 4.*(uv.x*r + uv.y*up);\n  \tvec3 rd = normalize(scrP - ro);\n  \tvec4 Color;\n  \tfloat d = depth(ro,rd,t);\n  \tif (d<end){\n  \t\tvec3 p = d*rd + ro;\n  \t\tColor = vec4(phong(p,t),1.);\n  \t}\n  \telse{Color = 2.*vec4(.9,.8,.8,1.);}\n\n  \t//vigillant\n  \tColor *= sqrt(.65-1.*length(uv));\n  \t\n    C = Color;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 117, 117, 191], [193, 213, 262, 262, 503], [505, 505, 536, 536, 588], [590, 602, 628, 628, 892], [894, 928, 956, 997, 2251], [2254, 2284, 2323, 2323, 2560], [2562, 2562, 2602, 2626, 3405]], "test": "error"}
{"id": "ltycR3", "name": "Total Fail", "author": "Minus256", "description": "I tried to make something but failed perfectly\ncubes are supposed to spin! not distort!", "tags": ["raymarching"], "likes": 1, "viewed": 186, "published": "Public", "date": "1537108243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//raymarching\nconst float err = 0.0001;\nconst float sta = 0.0;\nconst float end = 100.0;\nconst int mxmrch = 255;\n\nfloat spheresdf(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat planesdf( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox(q,vec3(2.0,2.0,2.0));\n}\n\nfloat scenesdf(vec3 p)\n{\n    vec3 damn = vec3(20.0,20.0,20.0);\n    return opRep(p,damn);\n}\n\nvec3 raydir(float fov,vec2 res,vec2 pos)\n{\n    vec2 dir = pos - res/2.0 + 3.0*sin(iTime);\n    float depth = (res.y/2.0)/tan(radians(fov/2.0));\n    return normalize(vec3(dir.x-(4.0*sin(((dir.x+0.5)*2.0*3.1415)*3.0+iTime)),\n                          dir.y+(4.0*cos(((dir.x+0.5)*2.0*3.1415)*3.0+iTime)),\n                          -depth));\n}\n\nmat4 viewmat(vec3 pos, vec3 centerdir, vec3 roll) {\n    vec3 f = normalize(centerdir - pos);\n    vec3 s = normalize(cross(f, roll));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        scenesdf(vec3(p.x + err,p.y,p.z)) - scenesdf(vec3(p.x - err,p.y,p.z)),\n        scenesdf(vec3(p.x,p.y + err,p.z)) - scenesdf(vec3(p.x,p.y - err,p.z)),\n        scenesdf(vec3(p.x,p.y,p.z + err)) - scenesdf(vec3(p.x,p.y,p.z - err))\n        ));\n}\n\nfloat dirlength(vec3 p,vec3 raydir)\n{\n    float depth = sta;\n    for(int i = 0; i < mxmrch; i++)\n    {\n        float dist = scenesdf(p + raydir * depth);\n            if(dist < err)\n            {\n                return depth;\n            }\n        depth += dist;\n        if(depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 light(vec3 lightpos,vec3 point,vec3 rgb,float ext,float strongness)\n{\n    vec3 L = normalize(lightpos - point);\n    vec3 N = normal(point);\n    float A = length(L-N)/2.0;\n    float B = ((pow(A,ext)*2.0)-1.0)*strongness;\n    float DI = length(lightpos - point);\n    float DL = scenesdf(lightpos);\n    float ratio = DL/DI;\n    float C = -ratio + B;\n    return vec4(rgb*(C),0);\n}\n\nvec4 Minresetnor(vec3 lightpos,vec3 normalo,vec3 eye,vec3 rgb,float ext,float strongness)\n{\n    vec3 dir = normalo;\n    vec3 point = eye;\n    vec3 altp = dir*dirlength(eye,normalo);\n    float altl = dirlength(eye,normalo);\n    \n    for(int i = 0;i>2;i++)\n    {\n        altp = dir*altl;\n        dir = reflect(dir,normal(altp));\n        altl = dirlength(altp,dir);\n    }\n    return light(lightpos,altp,rgb,ext,strongness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 background = vec4(0.5,0.5,0.5,1.0);\nvec3 lightpos = vec3(12.0*sin(iTime),13.0*cos(iTime),(14.0*cos(iTime)));\nvec3 lightrgb = vec3(1.0,1.0,1.0);\n    vec3 viewDir = raydir(45.0, iResolution.xy, fragCoord);\n    vec3 pointt = vec3(sin(iTime*0.1),max(40.0*sin(iTime*0.1),10.0),cos(iTime*0.1));\n    mat4 viewToWorld = viewmat(pointt, vec3(sin(iTime)), vec3(0.0, 1.0, 0.0));   \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = dirlength(pointt, worldDir);\n    vec3 eye = pointt + dist * worldDir;\nvec3 ambient = vec3(1.0,1.0,1.0);\nvec3 raydirc = raydir(90.0,vec2(iResolution),vec2(fragCoord));\nfloat dirlen = dirlength(eye,raydirc);\nvec3 point = raydirc*dirlen;\nif(dirlen >= 100.0-err)\n{\n    fragColor = background;\n}\nelse\n{\n    vec4 hell = Minresetnor(lightpos.zxy,raydirc,eye,vec3(0.0,0.0,1.0),10.0,0.5);\nvec4 wtf = Minresetnor(lightpos.yzx,raydirc,eye,vec3(0.0,1.0,0.0),10.0,0.5);\nvec4 color = Minresetnor(lightpos.xyz,raydirc,eye,vec3(1.0,0.0,0.0),10.0,0.5);\nfragColor = color + wtf + hell;\n}   \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltycR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 146, 146, 174], [176, 176, 207, 207, 245], [247, 247, 281, 281, 312], [314, 314, 345, 345, 415], [417, 417, 441, 441, 507], [509, 509, 551, 551, 847], [849, 849, 900, 900, 1131], [1133, 1133, 1154, 1154, 1431], [1433, 1433, 1470, 1470, 1787], [1789, 1789, 1863, 1863, 2170], [2172, 2172, 2263, 2263, 2594], [2596, 2596, 2653, 2653, 3690]], "test": "valid"}
{"id": "ltycRG", "name": "polygon distance", "author": "magician0809", "description": "distance and direction of polygon", "tags": ["distance", "polygon"], "likes": 5, "viewed": 98, "published": "Public", "date": "1536737529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DENS 16.\n#define ROT_SPEED 0.1\n\n#define POLY_EDGE 4\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat cross2(vec2 v0, vec2 v1)\n{\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\nfloat proj01(vec2 src, vec2 dst)\n{\n    return dot(src, dst) / dot2(dst);\n}\n\nvec2 segmentDistance(vec2 dp, vec2 sd)\n{\n    float lp = proj01(dp, sd);\n    lp = clamp(lp, 0.0, 1.0);\n    return dp - lp * sd;\n}\n\nvec2 polygonDistance(vec2 p, vec2 poly[POLY_EDGE])\n{\n    vec2 dn, n;\n    dn = segmentDistance(p - poly[POLY_EDGE-1], poly[0] - poly[POLY_EDGE-1]);\n    for (int i = 0; i < POLY_EDGE-1; i++)\n    {\n        n = segmentDistance(p - poly[i], poly[i + 1] - poly[i]);\n        if (dot2(n) < dot2(dn)) dn = n;\n    }\n    return dn;\n}\n\nbool inConvexPolygon(vec2 p, vec2 poly[POLY_EDGE])\n{\n    float lc = cross2(p - poly[POLY_EDGE-1], p - poly[0]);\n    for (int i = 0; i < POLY_EDGE-1; i++)\n    {\n        float c = cross2(p - poly[i], p - poly[i + 1]);\n        if (c * lc < 0.0) return false;\n        lc = c;\n    }\n    return true;\n}\n\nfloat drawSegment(vec2 uv, vec2 sp, vec2 sq, float thinkness)\n{\n    vec2 pp = uv - sp;\n    vec2 pq = sq - sp;\n    float lp = proj01(pp, pq);\n    vec2 dn = pp - lp * pq;\n    float sw = dot2(dn);\n    return step(sw, thinkness * thinkness)\n         * step(0.0, lp)\n         * step(lp, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 cp = vec2((aspect - 1.0) * 0.5 + 0.5, 0.5);\n    float pu = 1.0 / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 ms = iMouse.xy / iResolution.y;\n    \n    //generate polygon\n    float cs = cos(iTime * ROT_SPEED);\n    float sn = sin(iTime * ROT_SPEED);\n    mat2 mr = mat2(cs,sn,-sn,cs);\n    vec2 poly[POLY_EDGE];\n    poly[0] = mr * vec2(-0.25, 0.35) + cp;\n    poly[1] = mr * vec2(-0.25, -0.25) + cp;\n    poly[2] = mr * vec2(0.35, -0.25) + cp;\n    poly[3] = mr * vec2(0.2, 0.2) + cp;\n    \n    //distance per pixel\n    bool inConvex = inConvexPolygon(uv, poly);\n    float dist = length(polygonDistance(uv, poly));\n    float fd = fract(dist * DENS);\n    vec4 col = inConvex ? vec4(0.35, 0.5, 0.65, 1.0) : vec4(0.5, 0.5, 0.5, 1.0);\n    col.r = smoothstep(col.a, 0.0, abs(fd - col.r));\n    col.g = smoothstep(col.a, 0.0, abs(fd - col.g));\n    col.b = smoothstep(col.a, 0.0, abs(fd - col.b));\n    col *= 1.0 - step(dist, pu) * 0.5;\n    \n    //distance segment\n    vec2 dn = polygonDistance(ms, poly);\n    float s = drawSegment(uv, ms, ms - dn, pu);\n    col *= 1.0 - s * 0.5;\n    \n    //vignette effect\n    col *= smoothstep(0.7, 0.1, length(vec2(0.5) - ouv));\n    \n    //final\n    fragColor = vec4(col.rgb, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltycRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 81, 81, 105], [107, 107, 139, 139, 179], [181, 181, 215, 215, 255], [257, 257, 297, 297, 385], [387, 387, 439, 439, 709], [711, 711, 763, 763, 1007], [1009, 1009, 1072, 1072, 1298], [1300, 1300, 1357, 1357, 2681]], "test": "valid"}
{"id": "ltycRm", "name": "underwater experimenting", "author": "uqone", "description": "testing", "tags": ["underwater"], "likes": 26, "viewed": 1531, "published": "Public API", "date": "1536879024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// GLOBALS\n\n// colors\nvec3 col_water = vec3(.3, .7, 1.);\nfloat t = 20.;\n\n// marching\nfloat maxdist = 5.;\nfloat det = .001;\n\n\n\n// USEFUL LITTLE FUNCTIONS\n\n// 2D rotation\nmat2 rot2D(float a) {\n  a = radians(a);\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\n// Align vector\nmat3 lookat(vec3 fw, vec3 up) {\n  fw = normalize(fw);\n  vec3 rt = normalize(cross(fw, normalize(up)));\n  return mat3(rt, cross(rt, fw), fw);\n}\n\n\n// Tile fold \nfloat fmod(float p, float c) { return abs(c - mod(p, c * 2.)) / c; }\n\n// Smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Smooth max\nfloat smax(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// BACKGROUND AND FOREGROUND FRACTAL\n\nfloat fractal(vec3 p, float time) {\n  p += cos(p.z * 3. + time * 4.) * .02;\n  float depth = smoothstep(0., 6., -p.z + 5.);\n  p *= .3;\n  p = abs(2. - mod(p + vec3(0.4, 0.7, time * .07), 4.));\n  float ls = 0.;\n  float c = 0.;\n  for (int i = 0; i < 6; i++) {\n    p = abs(p) / min(dot(p, p), 1.) - .9;\n    float l = length(p);\n    c += abs(l - ls);\n    ls = l;\n  }\n  return .15 + smoothstep(0., 50., c) * depth * 4.;\n}\n\n// RAY MARCHING AND SHADING\n\nvec3 march(vec3 from, vec3 dir, vec3 dir_light, float time) {\n  vec3 odir = dir;\n  vec3 p = from + dir * 2.;\n  float fg = fractal(p + dir, time) * .55;\n  vec3 col = vec3(0.);\n  float totdist = 0.;\n  float d;\n  float v = 0.;\n  \n  float fade = smoothstep(maxdist * .2, maxdist * .9, maxdist - totdist);\n  float ref = 1.;\n  if (d < det * 2.) {\n    p -= (det - d) * dir;\n    col = mix(col_water * .15, col, fade);\n  }\n  col *= normalize(col_water + 1.5) * 1.7;\n  p = maxdist * dir;\n  vec3 bk = fractal(p, time) * ref * col_water;\n  float glow = pow(max(0., dot(dir, -dir_light)), 1.5);\n  vec3 glow_water = normalize(col_water+1.);\n  bk += glow_water*(glow+ pow(glow, 8.) * 1.5) * ref;\n  col += v * .06 * glow * ref * glow_water;\n  col += bk + fg * col_water;\n  return col;\n}\n\n// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n  // Set globals\n  float time = mod(iTime, 600.);\n  vec3 dir_light = normalize(vec3(-.3, 0.2, 1.));\n\n  // Pixel coordinates\n  vec2 uv = fragCoord / iResolution.xy - .5;\n  vec2 uv2 = uv;\n  float ar = iResolution.x / iResolution.y; \n  uv.x *= ar;\n\n  // Camera\n  vec2 mouse = (iMouse.xy / iResolution.xy - .5) * 4.;\n  float tcam = (time+67.)*.05;\n  float zcam = smoothstep(.7, 1., cos(tcam)) * 1.8 - .3;\n  zcam -= smoothstep(.7, 1., -cos(tcam)) * 1.6;\n  if (iMouse.z < .1) mouse = vec2(sin(time * .15)*ar, zcam);\n  vec3 dir = normalize(vec3(uv, .9));\n  vec3 from = vec3(1., 0., -0.5 + mouse.y) * 1.25;\n  from.xy *= rot2D(-mouse.x * 40.);\n  dir = lookat(normalize(-from+vec3(sin(time*.5)*.3,cos(time*.25)*.1,0.)), vec3(0., 0., -1.)) * dir;\n\n  // March and color\n  vec3 col = march(from, dir, dir_light, time);\n  col *= vec3(1.1, .9, .8);\n  col += dot(uv2, uv2) * vec3(0., 0.6, 1.) * .8;\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltycRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 170, 191, 191, 279], [281, 297, 328, 328, 439], [442, 456, 486, 486, 524], [526, 540, 579, 579, 678], [680, 694, 733, 733, 832], [834, 872, 907, 907, 1286], [1288, 1317, 1378, 1378, 2087], [2089, 2098, 2154, 2171, 3091]], "test": "valid"}
{"id": "ltycWy", "name": "School of Fish", "author": "cake7914", "description": "Fishies! (sphere project)", "tags": ["beginner"], "likes": 1, "viewed": 59, "published": "Public", "date": "1537485402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//mat2 rot(float a){\n    //return mat2(sin(a), -sin(a),\n                //cos(a), -cos(a));\n//}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n    //pMod3(q, vec3(0.75, 1., 0.8));\n    pMod3(q, vec3(1.0, 0., 1.0));\n    \n    \n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.7);\n    \n    float disp = 0.5 * (abs(cos(p.x*10.)) *\n                       abs(cos(p.y*16.)) *\n                       abs(-cos(p.z*12.)) );\n    \ts1 += disp;\n    \t//s1 -= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2+.5); // Union\n    float df2 = max(s1, s2); // Intersection\n    float df3 = max(s1, -s3); // Difference\n    \n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 40; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*0.3;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.1, 0.1, .8);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = .5;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime*1.50, 0.1, .3);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.5 / (t*t* .8);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    fragColor = vec4(tan(fc*color),1.0);\n    //fragColor = vec4((fc+color)*1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltycWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 97, 136, 136, 207], [209, 209, 246, 246, 289], [291, 291, 326, 326, 358], [361, 361, 380, 380, 939], [942, 942, 977, 977, 1134], [1137, 1137, 1194, 1194, 1692]], "test": "error"}
{"id": "ltyczc", "name": "Vorukannikus_A.txt", "author": "Kali", "description": "Not much time lately for new shaders, but this is another of the old ones that I've found as txt files. I removed it because it wasn't compiling back then for most people and also I wasn't too happy with the result. One of the few times I used noise. ", "tags": ["noise", "terrain"], "likes": 33, "viewed": 887, "published": "Public", "date": "1537131055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define RAY_STEPS 80\n\n#define detail .01\n#define ldir normalize(vec3(-0.25,-1.,-0.2))\n\nmat2 rot;\nfloat maxdist=30.;\n\nfloat inside, zoom;\nfloat nebli=0.;\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*4358.54568768763);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nfloat terrain( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.0547;\n    f += 0.2500*noise( p ); p = m*p*2.0334;\n    f += 0.1250*noise( p ); p = m*p*2.0121;\n    f += 0.0625*noise( p ); \n\tp=m*p*.04;\n\tf+=pow(noise(p),2.)*2.5;\t\n\tf+=noise(p*30.)*.03;\n\treturn f;\n}\n\n// 2D rotation function\nmat2 rot2D(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat lg=0.;\n\n// Distance function\nfloat de(vec3 pos) {\n\tfloat disp=terrain(pos);\n\tnebli=disp;\n\tfloat h=max(0.,sin(pos.y*.2));\n\tfloat md=pos.z-disp;\n\tfloat no=noise(pos*6.-vec3(0.,0.,mod(iTime*4.,1000.)));\n\tlg+=pow(max(0.,1.-(pos.z-h-no*.1+.05)),5.);\n\treturn md*.4;\n}\n\n\n\nvec3 normal(vec3 p) { ;\n\tvec3 e = vec3(0.0,detail,0.0);\n\tvec3 norm=vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t);\n\treturn normalize(norm);\n}\n\n\nfloat calcao(vec3 pos, vec3 nor) {\n\tconst float stps=5.;\n\tfloat aodet=.25;\n\taodet/=stps;\n\tfloat totao = 0.0;\n    float sca = 1.;\n    for( float aoi=0.; aoi<stps; aoi++ ) {\n        float hr = aodet*aoi*aoi;\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos );\n        totao += (hr-dd)*sca;\n\t\tsca*=.6;\n    }\n    return clamp( 1.0 - stps*totao, 0., 1.0 );\n}\n\n\n\n\nvec3 colorize(vec3 p){\n\tfloat n=texture(iChannel0,p.xy*.1).x;\n\t\t n+=texture(iChannel0,p.xy*.2).y;\n\t\tn*=clamp(p.z,0.1,2.)-0.1;\n\treturn min(1.,.15/abs(1.-n)+.2)*vec3(1.,.7,.5)*(.3+noise(p*5.));\t\n}\n\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tvec3 p, p2, p3, norm;\n\tfloat d=100., g=0.;\n\tfloat totdist=0.,totdist2=0., totdist3=0.;\n\tvec3 cdir=dir;\n\tfloat hit=0.;\n\tp=from;\n\tfloat sh=1.;\n\tfloat det=detail;\n\tfloat neb=0.;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tdet*=1.+totdist*.001;\n\t\tif (d>det && totdist<maxdist) {\n\t\t\td=de(p);\n\t\t\tp+=d*dir;\n\t\t\tg+=max(0.,.1+det*3.-d);\n\t\t\ttotdist+=d;\n\t\t}\n\t}\n\tp-=(det-d)*dir;\n\tfloat ref=0.;\n\tnorm=normal(p);\n\n\n\tfloat ldot=max(0.,dot(dir,ldir));\n\tfloat bdot=max(0.,dot(-dir,ldir));\n\tfloat lglow=pow(ldot,8.);\n\tfloat backg=lglow*.7+.3+max(0.,.2-p.z*.2)*3.;\n\tbackg+=pow(texture(iChannel1,dir.xz*vec2(1.,3.)+iTime*.02).x,.5)*clamp(dir.z+.1,0.,.1)*ldot*ldot;\n\tbackg=min(1.,backg)-smoothstep(0.,1.,bdot)*.2;\n\tbackg=clamp(backg,0.,1.);\n\tvec3 color=vec3(backg);\n\tif (d<.1) {\n\t\tcolor=colorize(p)*1.5;\n\t\tcolor=mix(color,1.5*vec3(1.,.6,.5),max(0.,1.3-p.z));\n\t\tfloat ao=calcao(p, norm);\n\t\tfloat amb=max(0.,dot(norm,-dir));\t\t\n\t\tfloat dif=max(0.,dot(norm,ldir))*sh;\n\t\tfloat spec=pow(max(0.,dot(reflect(dir,norm),ldir)),20.)*dif;\n\t\tcolor=(amb*ao+dif*.5)*color+spec*.5+g*(1.-exp(-.05*totdist))*noise(p*2.+iTime*.5);\n\t\tcolor=max(color,max(0.,1.-length(color))*pow(max(0.,dot(norm,normalize(vec3(0.,1.,-1.5)))),.5)*vec3(1.,.4,.2));\t\t\n\t\tcolor=mix(color,vec3(.5,.4,.3),min(1.,lg*.02));\n\t\tcolor+=lg*vec3(1.,.25,.1)*.1*(1.-sqrt(ao));\n\t\tcolor=mix(color,vec3(backg),1.-exp(-.0005*pow(totdist,3.)));\n\n\t} else {\n\t\tvec3 planetpos=normalize(vec3(.8,-1.,0.));\n\t\tfloat planet=dot(dir,planetpos); \n\t\tfloat hidefog=clamp(dir.z+.07,0.,.05)/.05*max(0.02,1.-pow(abs(dir.x+.35),3.))*.02;\n\t\tif (planet>.97) {\n\t\t\tvec3 planetshade=vec3(1.,.9,.8)*50.;\n\t\t\tvec2 no=(texture(iChannel0,dir.xz*1.5).xy-.5)*1.5;\n\t\t\tplanetshade*=1.-pow(abs(.5-fract(dir.z*20.+no.x)),2.);\n\t\t\tplanetshade*=1.-pow(abs(.5-fract(dir.z*20.+no.x)),.5)*.7;\n\t\t\tplanetshade+=vec3(1.,.5,.2)*pow(texture(iChannel1,dir.xz).x,3.)*100.;\n\t\t\tcolor=mix(color,planetshade*.7,hidefog);\n\t\t} else {\n\t\t    vec3 st = (dir * 2.+ vec3(1.3,2.5,1.25)) * .3;\n\t\t\tfor (int i = 0; i < 13; i++) st = abs(st) / dot(st,st) - .9;\n\t\t\tcolor+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 )*1.5;\n\t\t}\n\t\t\tcolor+=max(0.,.007-abs(planet-.97))*hidefog*2000.;\n\t\t\tcolor+=pow(ldot,100.);\n\t}\t\t\n\treturn color;\n}\n\n\nfloat move(float t) {\n\treturn sin(t*1.6258)+cos(t*.7489)*10.;\t\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec2 uvo=(uv-.5)*2.;\n\tvec2 oriuv=uv;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tuv.y-=.03;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tmouse.y-=2.;\n\tif (iMouse.z<1.) mouse=vec2(0.,-2.);\n\tvec3 dir=normalize(vec3(uv,.8));\n\tmat2 camrot1=rot2D(mouse.y);\n\tmat2 camrot2=rot2D(mouse.x);\n\tdir.yz*=camrot1;\n\tdir.xy*=camrot2;\n\tfloat m=move(iTime*.25);\n\tfloat m2=move(iTime*.25+.05);\n\tdir.xz*=rot2D(m2-m);\n    float t = mod(iTime*2., 200.);\n\tvec3 from=vec3(3.+m,-t,4.);\n\tvec3 color=raymarch(from,dir);\n\tfloat col=0.;\n\tfloat iwidth=1./16.;\n\tcolor=clamp(color,vec3(0.),vec3(1.));\n\tcolor*=vec3(1.2,1.1,.95);\n\tcolor*=1.-pow(max(abs(uvo.x),abs(uvo.y)),30.);\n    color*=smoothstep(0.,2.,t);\n    color*=1.-smoothstep(198.,200.,t);\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdSSWt", "previewfilepath": "https://soundcloud.com/andreas-wendland/vulkan", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/andreas-wendland/vulkan", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 307, 307, 352], [353, 353, 379, 379, 746], [749, 749, 774, 774, 1049], [1051, 1075, 1096, 1096, 1143], [1159, 1180, 1200, 1200, 1412], [1416, 1416, 1437, 1437, 1604], [1607, 1607, 1641, 1641, 1978], [1983, 1983, 2005, 2005, 2177], [2181, 2181, 2225, 2225, 4413], [4416, 4416, 4437, 4437, 4480], [4482, 4482, 4536, 4536, 5337]], "test": "error"}
{"id": "ltyyDy", "name": "Soap Bubbles!!!!!-Sphere Project", "author": "cake7914", "description": "bubblesssss (sphere project)", "tags": ["beginners"], "likes": 1, "viewed": 95, "published": "Public", "date": "1537491169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n    pMod3(q, vec3(0.75, 1., 0.8));\n    //pMod3(q, vec3(1., 0., 0.));\n    \n    \n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.72); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.7);\n    \n    float disp = 0.5 * (abs(cos(p.x*10.)) *\n                       abs(cos(p.y*10.)) *\n                       abs(cos(p.z*10.)) );\n    \t//s1 += disp;\n    \ts1 /= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2); // Union\n    float df2 = max(-s1, s2); // Intersection\n    float df3 = max(-s1, -s3); // Difference\n    \n    return df3;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*0.3;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //0.59, 0.75, 0.9\n    vec3 color = vec3(0.59, 0.75, 0.9);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, 0.0, -.75);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.5 / (t*t* .75);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    //fragColor = vec4((fc+color),1.0);\n    fragColor = vec4(tan(fc+color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 127, 127, 198], [200, 200, 237, 237, 280], [282, 282, 317, 317, 349], [352, 352, 371, 371, 926], [929, 929, 964, 964, 1121], [1124, 1124, 1181, 1181, 1699]], "test": "error"}
{"id": "MlGcDw", "name": "Mandy!", "author": "teraspora", "description": "Zoom into the Mandelbrot set...", "tags": ["mandelbrotfractal"], "likes": 3, "viewed": 469, "published": "Public API", "date": "1536519619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mandelbrot Set in GLSL\n// Created by John Lynch - Sep 2018;\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float PI = 3.141592653589793234;\nconst float SCALE_PER_FRAME = 1.003;\nconst vec4 white = vec4(1., 1., 1., 1.);\nconst vec4 black = vec4(0., 0., 0., 1.);\nconst vec4 orange = vec4(1.0, 0.4, 0., 1.);\nconst vec4 cyan = vec4(0., 0.4, 1.0, 1.);\nconst vec4 magenta = vec4(1.0, 0., 1.0, 1.);\nconst vec4 gold = vec4(1.0, 0.84, 0.66, 1.);\n\nvec4[] cols = vec4[](black, gold, black, gold, black, orange, black, white, black, orange, black);\nint numFirstColours = 12;\nbool modifiedColours = true;\n\nfloat aspectRatio;\nhighp vec2 zMin;    // corners of the region of the Complex plane we're looking at\nhighp vec2 zMax;\nhighp vec2 zSpan;\nhighp vec2 zIncr;\n\nconst float escapeRadius = 6.0;\nconst float escapeRadius2 = 36.0;\nfloat exponent = 2.;\nint maxIterations = 1024;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// ======================== USEFUL FUNCTIONS ========================\nvoid updateGeometryVars() {\n    zSpan = zMax - zMin;\n    zIncr = zSpan / iResolution.xy;\n}\n\nvec2 xyToPixel(vec2 z, vec2 zMin, vec2 zMax) {\n    return (z - zMin) / (zMax - zMin) * iResolution.xy;\n}\n\nvec2 pixelToXy(vec2 pixel, vec2 zMin, vec2 zMax) {\n    return pixel / iResolution.xy * (zMax - zMin) + zMin;\n}\n\nvoid scale(float factor) {\n    highp vec2 halfDiag = (zMax - zMin) / 2.0;\n    highp vec2 centre = zMin + halfDiag;\n    zMin = centre - halfDiag / factor;\n    zMax = centre + halfDiag / factor;\n    updateGeometryVars();\n}\n\n// some complex functions for later use...\nfloat modc(vec2 z) {\n    return length(z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 boxFold(vec2 z, float fold) {\n    return vec2(z.x > fold ? 2. * fold - z.x : (z.x < -fold ? -2. * fold - z.x : z.x),\n                z.y > fold ? 2. * fold - z.y : (z.y < -fold ? -2. * fold - z.y : z.y));\n}\n\nvec2 ballFold(vec2 z, float r, float bigR) {\n    float zAbs = modc(z);\n    r = abs(r);\n    return zAbs < r ? z / (r * r) : (zAbs < abs(bigR)) ?\n            z / (zAbs * zAbs)\n            : z;\n}\n\n// ======================= The functions to iterate ======================\n\nhighp vec2 f0(vec2 z, vec2 w) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + w;\n}\n\n// ======================= The grindstone ================================\nfloat iterate(vec2 z) {\n    int numIts = 0;\n    float realIts = 0.;\n    vec2 z0 = z;\n    float zAbs = z.x * z.x + z.y * z.y;\n    float zAbsPrevious = zAbs;\n    while (numIts < maxIterations && zAbs < escapeRadius) {\n        numIts++;\n        // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n        z = f0(z, z0); // iterate the fn\n        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n        zAbsPrevious = zAbs;\n        zAbs = z.x * z.x + z.y * z.y;\n    }\n    if (zAbs < escapeRadius) {\n        realIts = float(numIts + 1) - (log(log(zAbs + 1.) + 1.) / log(log(escapeRadius + 1.) + 1.));\n    }\n    else {\n        float far = max(exponent, log(zAbs) / log(zAbsPrevious));\n        realIts = float(numIts) - (log(log(zAbs)) - log(log(escapeRadius))) / log(far);\n    }\n    return ++realIts;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // I'd like to declare these three outside of this main method, but can't find a \n    // way to keep the compiler happy. :(\n    aspectRatio = iResolution.x / iResolution.y;\n    zMin = vec2(-1.2 * aspectRatio - 1.6, -1.2);    // corners of the region of the Complex plane we're looking at\n    zMax = vec2(1.2* aspectRatio - 1.6, 1.2);\n        \n    scale(pow(SCALE_PER_FRAME, float(iFrame)));\n           \n    vec2 z = pixelToXy(fragCoord.xy, zMin, zMax);\n    float its = iterate(z);\n    float nfc = float(numFirstColours);\n    float colourMappingFactor = (nfc - 1.) / float(maxIterations); \n    \n    float colourIndex = modifiedColours ? mod(its, nfc) : mod(its * colourMappingFactor, nfc); // map iteration count to a colour\n    int firstColourIndex = int(floor(colourIndex));\n    float interpolationFactor = mod(colourIndex, 1.);\n    \n    // Slight precautionary hack!    Or let's call it clamping!\n    if (firstColourIndex >= numFirstColours) {\n        firstColourIndex = numFirstColours - 1;\n        interpolationFactor = 1.;\n    }    \n    if (firstColourIndex < 0) {\n        firstColourIndex = 0;\n    }\n\n    vec4 col = mix(cols[firstColourIndex], cols[int(mod(float(firstColourIndex + 1), float(cols.length())))], interpolationFactor);\n    if (iTime > 64.) {\n        col -= vec4(0.1, 0.1, 0.1, 0.00) * (iTime - 64.0);  // fade when losing resolution \n    }\n    \n    // =================== Change hue... =========================\n    vec3 c = rgb2hsl(col.rgb);\n    c.s = mod(c.s - iTime / 21., 1.0);\t// so hue rotates\n    col = vec4(hsl2rgb(c), 1.);    \n    // ===========================================================\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGcDw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[910, 1119, 1144, 1144, 1302], [1304, 1368, 1392, 1445, 1728], [1730, 1765, 1789, 1789, 1909], [1911, 1946, 1970, 1970, 2122], [2124, 2194, 2221, 2221, 2284], [2286, 2286, 2332, 2332, 2390], [2392, 2392, 2442, 2442, 2502], [2504, 2504, 2530, 2530, 2724], [2726, 2769, 2789, 2789, 2813], [2815, 2815, 2834, 2834, 2863], [2865, 2865, 2897, 2897, 2944], [2946, 2946, 2980, 2980, 3157], [3159, 3159, 3203, 3203, 3351], [3524, 3599, 3622, 3622, 4361], [4363, 4363, 4418, 4546, 6073]], "test": "error"}
{"id": "MlGcDz", "name": "Triangle - intersection", "author": "iq", "description": "Different methods to intersect a triangle and a ray", "tags": ["3d", "triangle", "intersection", "analytic"], "likes": 46, "viewed": 3667, "published": "Public API", "date": "1536740556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// Other triangle functions:\n//\n// Occlusion:    https://www.shadertoy.com/view/XdjSDy\n// Distance:     https://www.shadertoy.com/view/4sXXRN\n// Intersection: https://www.shadertoy.com/view/MlGcDz\n// Closest:      https://www.shadertoy.com/view/ttfGWl\n\n\n//=====================================================\n\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+trd = p(u,v) = vo + u(v1-v0) + v(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = normalize(v0-pos);\n    vec3 b = normalize(v1-pos);\n    vec3 c = normalize(v2-pos);\n\n    float s = -sign(dot(v0-pos,cross(v0-v1,v2-v1))); // other side of the triangle\n    \n    // page 300 in http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.466.963&rep=rep1&type=pdf\n    float r = dot(nor,normalize(cross(a,b))) * acos(dot(a,b)) +\n              dot(nor,normalize(cross(b,c))) * acos(dot(b,c)) +\n              dot(nor,normalize(cross(c,a))) * acos(dot(c,a));\n    \n    return 1.0-max(0.0,s*r)/6.2831;\n}\n\n//=====================================================\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec3 ro = vec3(0.0, 0.0, 4.0 );\n        vec3 rd = normalize( vec3(p,-2.0) );\n\t\n        // triangle animation\n        vec3 v1 = cos( iTime*1.0 + vec3(2.0,1.0,1.0) + 1.0 )*vec3(1.5,1.0,1.0);\n\t    vec3 v2 = cos( iTime*1.0 + vec3(5.0,2.0,3.0) + 2.0 )*vec3(1.5,1.0,1.0);\n\t    vec3 v3 = cos( iTime*1.2 + vec3(1.0,3.0,5.0) + 4.0 )*vec3(1.5,1.0,1.0);\n\n        vec3 col = vec3(0.08) + 0.02*rd.y;\n\n        float tmin = 1e10;\n    \n        float t1 = iPlane( ro, rd );\n        if( t1>0.0 )\n        {\n            tmin = t1;\n            vec3 pos = ro + tmin*rd;\n            vec3 nor = vec3(0.0,1.0,0.0);\n            float occ = triOcclusion( pos, nor, v1, v2, v3 );\n            col = mix( col*3.0*occ*occ, col, 1.0-exp(-0.02*tmin) );\n        }\n        \n        col *= 1.0-0.3*length(p);\n\n        vec3 res = triIntersect( ro, rd, v1, v2, v3 );\n        float t2 = res.x;\n        if( t2>0.0 && t2<tmin )\n        {\n            tmin = t2;\n            float t = t2;\n            vec3 pos = ro + t*rd;\n            vec3 nor = normalize( cross( v2-v1, v3-v1 ) );\n            col = pattern(64.0*res.yz);\n            col *= 0.55 + 0.45*faceforward(-nor, -rd, nor).y;\n        }\n\n        \n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGcDz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1547, 1593, 1674, 1674, 2641], [2645, 2686, 2770, 2770, 3291], [3293, 3350, 3390, 3390, 3423], [3425, 3482, 3510, 3510, 3700], [3717, 3717, 3774, 3774, 5589]], "test": "valid"}
{"id": "MlGcWw", "name": "try volumetric sphere", "author": "cailuming", "description": "try constant density volumetric sphere", "tags": ["volumetricconstantdensity"], "likes": 3, "viewed": 117, "published": "Public", "date": "1536842179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 64\n#define PI 3.1415926\nstruct Ray {\n   vec3 o;\n   vec3 d;\n};\n\nmat2 rot2D(float arc){\n    float c = cos(arc);\n    float s = sin(arc);\n    return mat2(c,s,-s,c);\n}\n \n\nvec2 sphere(vec3 p,vec3 c){\n    p-=c;\n    p.z+=iTime;\n    float mdr = 1.5;\n    \n    p.xz=mod(p.xz,mdr);\n    p.xz-=(mdr*0.5);\n  \n    return vec2(length(p)-1.0,0.0);\n}\n\nvec2 sphere1(vec3 p,vec3 c){\n    p-=c;\n     \n    return vec2(length(p)-2.0,0.0);\n}\n\nvec2 box(vec3 p,vec3 c){\n    p-=c;\n    p.xz*=rot2D(iTime);\n    p.xy*=rot2D(iTime);\n    \n    float arc = atan(p.y,p.x);\n    float v = max(max(abs(p.x),abs(p.y)),abs(p.z))-1.0;\n    float v1 = length(p)-1.0;\n    \n    float ts = clamp(cos(iTime*6.0),0.,1.0);\n    ts = pow(ts,3.0);\n    v = mix(v,v1,ts);\n    return vec2(v,1.0);\n}\n\n\nvoid cmp(vec2 a,inout vec2 r){\n    r=r.x>a.x?a:r;\n}   \n \nvec2 map(vec3 p){\n   vec2 ref = vec2(1000);\n   \n   cmp(sphere(p,vec3(0,0,5)),ref);\n   cmp(box(p,vec3(0.0,3.0,16.0)),ref);\n\n   return ref;\n}\n\nvec2 rayHit(Ray r){\n    vec2 h = vec2(0);\n    float t = 1.0;\n    \n    for (int i=0;i<FAR;i++){\n        h= map(r.o+t*r.d);\n        if(h.x<=0.005){\n           break;\n        }else{\n           t+=h.x;\n        }\n    }\n    return vec2(t,h.y);\n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 dir,vec2 uv){\n    vec3 look  = normalize(dir-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up    = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right+uv.y*up+look);\n}\n\n//evaluate the gradient\nvec3 getNormal(vec3 p,float t){\n   vec2 e = vec2(1,0)*0.01*t;\n   float m = map(p).x;\n   return normalize(\n       vec3(\n        map(p+e.xyy).x-m,\n        map(p+e.yxy).x-m,\n        map(p+e.yyx).x-m\n       )\n     ); \n}\n       \nvoid doShade(inout vec3 col,Ray r,vec3 lp,vec2 sv){\n    vec3 hp    = r.o+sv.x*r.d; \n    vec3 ld    = normalize(lp-hp);\n    vec3  n    = getNormal(hp,sv.x);\n    vec3 rd    = reflect(ld,n);\n    vec3 lkdir = normalize(hp-r.o);\n    float nl   = smoothstep(-1.0,1.0,dot(n,ld));\n    float nr   = smoothstep(-1.0,1.0,dot(lkdir,rd));\n    \n    float nn   = 1.0;\n   \n    nl+=pow(nr,50.0)*0.3;\n    if(sv.y == 0.){\n       \n        nn = smoothstep(-0.1,1.,pow(dot(lkdir,n),2.0));\n        col = mix(col,vec3(nl),nn);\n    }else if(int(sv.y) == 1){\n       \n        col = mix(col,vec3(nl),0.7)*vec3(cos(iTime)*0.2+0.8,sin(iTime)*0.3+0.8,cos(iTime*0.4)*0.5+0.6);\n    } \n    col = mix(col,vec3(0.6,0.7,0.8),1.-exp(-sv.x*sv.x*0.0002)); \n}\n\nvoid drawVolumeSphere(Ray r,float refz,vec3 lp,vec3 eye,inout vec3 col)\n{\n    float t = 0.;\n    float d = 0.;\n    float freq = texture(iChannel2,vec2(0.5,0.0)).x;\n    vec3 c = vec3(10.0*sin(iTime),2.0+freq*6.0,20.0+10.0*cos(iTime));\n    \n    for (int i=0;i<32;i++){\n       d = sphere1(r.o+r.d*t,c).x;      \n        if(d<=0.0001){\n          break;     \n        }\n        t+=d;\n    }\n\n    if(refz>=t){\n       vec3 hp = r.o+t*r.d;\n       hp-= c;\n       vec3 n = normalize(hp);\n       vec3 spColor = vec3(0.9,1.0,0.3);\n       vec3 ld    = normalize(lp-hp);\n       vec3 rd    = reflect(-ld,n);\n       float scatter = clamp(dot(n,normalize(eye-c)),0.0,1.);\n       scatter = smoothstep(0.,1.,scatter);\n       scatter = pow(scatter,10.);\n       float nl =smoothstep(-2.0,1.0,dot(n,ld));\n       \n       float nr = max(0.3,dot(n,rd));\n       float rnl = clamp(1.0-nl,0.,1.);\n       \n       col = mix(col,spColor*nl,scatter);\n       col = mix(col,spColor*rnl,-pow(nr,3.0));\n       \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec2 cuv = uv-vec2(0.5,0.5);\n    vec2 sv  = vec2(0);\n    vec3 col = vec3(.5,0.6,0.7);\n    vec3 lp  = vec3(10.0*cos(iTime),10,10.0*sin(iTime));\n    vec3 eye = vec3(0,5,-2);\n    vec3 dir = vec3(0,3.5,3.0);\n    \n    float as = iResolution.x/iResolution.y;\n  \n    Ray r;\n  \n    cuv.x*=as;\n    \n    setCamera(r,eye,dir,cuv);\n  \n    sv=rayHit(r);\n    \n    doShade(col,r,lp,sv);     \n   \n    drawVolumeSphere(r,sv.x,lp,eye,col);\n    //color correction\n    col.x = pow(col.x,0.8);\n    col.y = pow(col.y,0.9);\n    col.z = pow(col.z,0.6);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 97, 97, 174], [178, 178, 205, 205, 343], [345, 345, 373, 373, 427], [429, 429, 453, 453, 753], [756, 756, 786, 786, 807], [813, 813, 830, 830, 952], [954, 954, 973, 973, 1193], [1195, 1195, 1249, 1249, 1454], [1456, 1480, 1511, 1511, 1695], [1704, 1704, 1755, 1755, 2422], [2424, 2424, 2497, 2497, 3402], [3404, 3404, 3461, 3511, 4123]], "test": "error"}
{"id": "MlGyDK", "name": "Dark HeartBeat", "author": "cold_code", "description": "Experimenting with transparent materials.\n\nRefraction from tdhooper's Dispersion: https://www.shadertoy.com/view/XlscDH\nThe heart comes from iq: https://www.shadertoy.com/view/4lK3Rc", "tags": ["refraction", "glass", "heart"], "likes": 1, "viewed": 475, "published": "Public API", "date": "1537732768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Patryk Ozga\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or\n// substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",\n// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n// THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst vec3[4] palette = vec3[4](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                                vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));\nconst vec3[4] spectrum = vec3[4](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                                 vec3(1.0, 1.0, 1.0), vec3(0.0, 0.33, 0.67));\nconst float _2PI = 6.28318;\nconst float _PI_2 = 1.570796;\n\nstruct Hit {\n  float dist;\n  int object;\n  vec3 normal;\n  vec3 pos;\n};\n\nstruct Material {\n  bool transparent;\n  float refractiveIndex;\n  vec3 color;\n  float dispersion;\n};\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(in float t, in vec3[4] pal) {\n  return pal[0] + pal[1] * cos(_2PI * (pal[2] * t + pal[3]));\n}\n\nMaterial getMaterial(int object) {\n  switch (object) {\n  case 0:\n    return Material(false, 0., vec3(0.), 0.);\n  case 1:\n    return Material(true, 1. / 1.6, vec3(0.), .85);\n  case 2:\n    return Material(false, 0.,\n                    pal(_2PI * sin(iTime * _2PI / 100.) + 1., palette), 0.);\n  }\n}\n\nstruct Shape {\n  float dist;\n  int object;\n};\n\nShape opU(Shape h1, Shape h2) {\n  if (h1.dist < h2.dist) {\n    return h1;\n  }\n  return h2;\n}\n\n// https://www.shadertoy.com/view/4lK3Rc\nShape sdHeart(vec3 p) {\n  vec3 q = p * 50.;\n  float r = 15.;\n  q.y -= r;\n  float ani = pow(0.5 + 0.5 * sin(_2PI * iTime + q.y / 25.0), 4.0);\n  q *= 1.0 - 0.2 * vec3(1.0, 0.5, 1.0) * ani;\n  q.y -= 1.5;\n  q.x = abs(q.x);\n  q.y = 4. + 1.2 * q.y - q.x * sqrt(max((20. - q.x) / 15., 0.));\n  q.z *= 2.0 - q.y / 15.;\n  float d = sqrt(q.x * q.x + q.y * q.y + q.z * q.z) - r;\n  d /= 3.;\n  d /= 100.;\n  vec3 normal = normalize(p);\n  return Shape(d, 1);\n}\n\nShape sdCylinder(vec3 p, float r) {\n  float d = length(p.xz) - r;\n  vec3 normal = normalize(p * vec3(1., 0., 1.));\n  return Shape(d, 2);\n}\n\nShape repCylinder(vec3 p, in vec3 c) {\n  vec3 q = mod(p, c) - .5 * c;\n  return sdCylinder(q, .1);\n}\n\nHit map(in vec3 pos) {\n  Shape res = sdHeart(pos - vec3(0., 2., 0.));\n  res = opU(res, repCylinder(pos - vec3(0., .0, 0.), vec3(4., 0., 4.)));\n\n  return Hit(res.dist, res.object, vec3(0.), pos);\n}\n\nvec3 calcNormal(in vec3 pos) {\n  vec3 eps = vec3(0.005, 0.0, 0.0);\n  return normalize(vec3(map(pos + eps.xyy).dist - map(pos - eps.xyy).dist,\n                        map(pos + eps.yxy).dist - map(pos - eps.yxy).dist,\n                        map(pos + eps.yyx).dist - map(pos - eps.yyx).dist));\n}\n\nHit castRay(vec3 ro, vec3 rd) {\n  float precis = .0005;\n  float sceneDist = 2. * precis;\n  float maxRayDist = 20.;\n  Hit rayHit = Hit(0., 0, vec3(0.), ro);\n\n  for (int i = 0; i < 128; ++i) {\n    if (sceneDist < precis || rayHit.dist > maxRayDist)\n      break;\n    rayHit.pos = ro + rd * rayHit.dist;\n    Hit lhit = map(rayHit.pos);\n    sceneDist = lhit.dist;\n    rayHit.dist += sceneDist;\n    rayHit.object = lhit.object;\n  }\n  if (rayHit.dist > maxRayDist) {\n    rayHit.dist = maxRayDist;\n    rayHit.object = 0;\n    rayHit.normal = vec3(0.);\n  }\n\n  rayHit.normal = calcNormal(rayHit.pos);\n  return rayHit;\n}\n\n#define DISPERSION_SAMPLES 40.\n#define REFRACTION_BOUNCES 3.\n\nHit marchTransparent(Hit hit, float wavelength, Material mat, vec3 rd,\n                     vec3 nor) {\n  vec3 rayDirection = rd;\n  vec3 normal = nor;\n  Material material = mat;\n  for (float i = 0.; i < REFRACTION_BOUNCES; ++i) {\n    if (!material.transparent) {\n      return hit;\n    }\n    // Adjust refractive index for wavelength and dispersion amount\n    float refractiveIndex = material.refractiveIndex;\n    float riMin = refractiveIndex;\n    float riMax = refractiveIndex * (1. + mat.dispersion);\n    refractiveIndex = mix(riMin, riMax, wavelength);\n    refractiveIndex = 1. / refractiveIndex;\n\n    vec3 rayDirection = refract(rayDirection, normal, refractiveIndex);\n\n    // Move away from the surface before marching\n    float separation = 0.01;\n    float startDistance = separation / abs(dot(rayDirection, normal));\n\n    vec3 rayOrigin = hit.pos + startDistance * rayDirection;\n    hit = castRay(rayOrigin, rayDirection);\n    material = getMaterial(hit.object);\n  }\n}\n\n// https://www.shadertoy.com/view/XlscDH\n#define WAVELENGTH_BLEND_MULTIPLIER 100.\nvec3 shadeTransparent(Hit hit, Material mat, vec3 rd, vec3 nor) {\n  float wavelength;\n  vec3 sampleColor;\n  vec3 color = vec3(0);\n\n  // March for each wavelength and blend together\n  for (float r = 0.; r < DISPERSION_SAMPLES; r++) {\n    wavelength = r / DISPERSION_SAMPLES;\n    Hit hit2 = marchTransparent(hit, wavelength, mat, rd, nor);\n    sampleColor = getMaterial(hit2.object).color * pal(wavelength, spectrum);\n    // I don't have a model for correctly blending wavelengths together\n    // so there's a fudge multiplier to stop the result going grey\n    sampleColor /= DISPERSION_SAMPLES / WAVELENGTH_BLEND_MULTIPLIER;\n    color += sampleColor;\n  }\n\n  return color;\n}\n\n// https://www.shadertoy.com/view/Xs3GRB\nvec3 sky_color(vec3 ray_dir, vec3 light_dir) {\n  float d = max(0., dot(ray_dir, light_dir));\n  float d2 = light_dir.y * .7 + .3;\n  vec3 base_col;\n  base_col = mix(vec3(.3), vec3((ray_dir.y < 0.) ? 0. : 1.), abs(ray_dir.y));\n  return base_col * d2;\n}\n\nconst float fog_density = .15;\n\nvec3 render(vec3 ro, vec3 rd, vec3 ta) {\n  Hit hit = castRay(ro, rd);\n  vec3 nor = hit.normal;\n  Material mat = getMaterial(hit.object);\n  if (hit.object == 2)\n    return vec3(0.);\n  vec3 col = vec3(0.);\n  if (!mat.transparent) {\n    col = mat.color;\n  } else {\n    col = shadeTransparent(hit, mat, rd, nor);\n  }\n  vec3 lig = rd;\n  vec3 fog_color = sky_color(rd, lig);\n\n  float dif = clamp(dot(nor, -lig), 0.0, 1.0);\n  vec3 lin = vec3(0.);\n  lin += dif;\n\n  float fog_dist = hit.dist;\n  float fog = 1.0 - 1.0 / exp(fog_dist * fog_density *\n                              pow(dot(normalize(ta - ro), rd), 50.));\n  col *= lin;\n  col = mix(col, fog_color, fog);\n\n  return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0);\n  vec3 cu = normalize(cross(cw, cp));\n  vec3 cv = normalize(cross(cu, cw));\n  return mat3(cu, cv, cw);\n}\n\nfloat gain(float x, float k) {\n  float a = 0.5 * pow(2.0 * ((x < 0.5) ? x : 1.0 - x), k);\n  return (x < 0.5) ? a : 1.0 - a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n  float mouse =\n      _2PI * gain(fract(iTime / 5.),\n                  2.); // 7. * iMouse.x / iResolution.x; // - vec2(.5);\n  float r = 2.5;\n\n  vec3 ro = vec3(r * sin(mouse), 2., r * cos(mouse));\n  vec3 ta = vec3(0., 2.50, 0.);\n  mat3 ca = setCamera(ro, ta, 0.);\n  vec3 rd = ca * normalize(vec3(uv.xy, 3.5));\n\n  fragColor = vec4(render(ro, rd, ta), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGyDK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1652, 1693, 1731, 1731, 1795], [1797, 1797, 1831, 1831, 2093], [2142, 2142, 2173, 2173, 2234], [2236, 2277, 2300, 2300, 2721], [2723, 2723, 2758, 2758, 2861], [2863, 2863, 2901, 2901, 2962], [2964, 2964, 2986, 2986, 3160], [3162, 3162, 3192, 3192, 3457], [3459, 3459, 3490, 3490, 4067], [4131, 4131, 4234, 4234, 5106], [5108, 5190, 5255, 5255, 5862], [5864, 5905, 5951, 5951, 6154], [6188, 6188, 6228, 6228, 6861], [6863, 6863, 6907, 6907, 7083], [7085, 7085, 7115, 7115, 7210], [7212, 7212, 7267, 7267, 7689]], "test": "error"}
{"id": "MlGyWz", "name": "Shooting the Moon", "author": "dreamur", "description": "I'm sure I'm not the only one this has happened to", "tags": ["moon", "hearts", "cards", "spades"], "likes": 5, "viewed": 127, "published": "Public", "date": "1537643370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n// concept from \"The Book of Shaders\"\n//  Chapter 7: Shapes\n//  https://thebookofshaders.com/07/\nfloat lamp( in vec2 _st, in float edges )\n{   \n    float a = atan(_st.x, _st.y) + .2;\n    float b = PI * 2.0 / edges;\n    \n    return cos( floor(0.5 + a / b) * b - a ) * \n           length( _st * 0.83 / cos(length(_st * 2.75)) );\n}\n\nvec2 rotate( in vec2 _st, in float angle )\n{\n\treturn mat2( cos(angle * PI), -sin(angle * PI),\n                 sin(angle * PI), cos(angle * PI) ) * _st;    \n}\n\nfloat circle( in vec2 _st, in float radius, in float inner, in float outer )\n{\n\tvec2 dist = _st - vec2(0.5);\n    return 1.0 - smoothstep( radius * inner, radius * outer, dot(dist, dist) * 4.0 );  \n}\n\nfloat rect( in vec2 _st, in vec2 xCoords, in vec2 yCoords )\n{\n    vec2 bl = step( vec2(xCoords.x, yCoords.x), _st );\n    vec2 tr = step( vec2(xCoords.y, yCoords.y), 1.0 - _st );\n    \n\treturn bl.x * bl.y * tr.x * tr.y;   \n}\n\nfloat smoothRect( in vec2 _st, in vec2 xCoords, in vec2 yCoords, in vec2 shading )\n{\n    vec2 bl = smoothstep( vec2(xCoords.x, yCoords.x) * shading.x, vec2(xCoords.x, yCoords.x) * 1.01, _st );\n    vec2 tr = smoothstep( vec2(xCoords.y, yCoords.y) * shading.y, vec2(xCoords.y, yCoords.y) * 1.01, _st );\n    \n\treturn bl.x * bl.y * tr.x * tr.y;\n}\n\n// concept from \"The Book of Shaders\"\n//  Chapter 7: Shapes\n//  https://thebookofshaders.com/07/\nfloat rect2( in vec2 _st, in vec2 scale, in vec2 offset, in float roundedPct )\n{\n\tfloat tmp = length(max( abs(_st * scale - offset) - 0.45  , 0.0));\n  \treturn 1.0 - step(roundedPct, tmp);  \n}\n\n// from \"The Book of Shaders\"\n//  Chapter 11: Noise\n//  https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// from \"The Book of Shaders\"\n//  Chapter 11: Noise\n//  https://thebookofshaders.com/11/\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n// concept from \"The Book of Shaders\"\n//  Chapter 7: Shapes\n//  https://thebookofshaders.com/07/\nfloat heart( in vec2 _st, in float innerBlur, in float outerBlur )\n{\n    \n\tfloat r = length(_st) * 2.0;\n    float a = atan(_st.x, _st.y);\n    \n    float pct = cos(r * a);\n    \t  pct = cos( pct * cos( a * 0.99 * (pct * r - 1.45) ) * sin(a * 2.2 - a * 3.6) );\n    \n    return 1.0 - smoothstep(pct - innerBlur, pct + outerBlur, r);\n}\n\n//----------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st    = fragCoord / iResolution.xy;\n    \t \n    \t st   -= 0.5;\n    \t st.x *= iResolution.x / iResolution.y;\n    \t st   += 0.5;\n    \n\n    float pct, res, sinusoidalTime = sin(iTime), tmp1;\n    vec2 tmp2  = vec2(0.0);\n    vec3 col   = vec3(0.047, 0.22, 0.341), tmp3 = vec3(0.0);\n    \n    \t // jitter\n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\n    \t \n    \n         // wall design\n    \t res = 0.0, pct = 0.0;\n    \t for(int i = 0; i < 5; i++)\n         {\n             pct += rect( tmp2 + vec2(0.75 - res, 0.0), vec2(0.491), vec2(0.0) );      \t \n             res += 0.37; \n         }    \n    \t col  = mix(col, vec3(0.0, 0.45, 0.8), pct);\n    \n    \t res = 0.0, pct = 0.0;\n    \t for(int i = 0; i < 8; i++)\n         {\n             pct += rect( tmp2 + vec2(0.76 - res, 0.0), vec2(0.4965), vec2(0.0) );         \t \n             res += 0.28 * 0.78; \n         }\n    \t col  = mix(col, vec3(0.0, 0.45, 0.8), pct);\n    \n    \t res = 0.0, pct = 0.0;\n    \t for(int i = 0; i < 5; i++)\n         {\n             pct += rect( tmp2 + vec2(0.624 - res, 0.0), vec2(0.4952), vec2(0.0) );         \t \n             res += 0.32 * 1.02; \n         }\n    \t col  = mix(col, vec3(0.494, 0.78, 1.), pct);\n    \n\n    \t // blood splatter(s) \t     \n    \t pct   = smoothstep(0.68, 0.68, noise(tmp2.yx * 31.0));\n    \t tmp3  = mix(col, vec3(0.95, 0.0, 0.0), pct);\n    \n    \t pct  *= smoothstep(0.62, 0.62, noise(tmp2 * 35.0 + tmp2 * 28.0));\n    \t col   = mix(col, tmp3, pct); \n    \n    \n         // bullet holes  - add variance to y pos\n    \t res = -0.75;\n    \t pct = 0.0;\n    \t tmp1 = 0.21;\n         pct += circle(tmp2 - vec2(res, tmp1), 0.0007, 0.35, 1.1);                                 \n    \t res += 0.56;\n    \t tmp1 += 0.17;   \n    \t pct += circle(tmp2 - vec2(res, tmp1), 0.0007, 0.35, 1.1);                                 \n    \t res += 0.27;\n\t\t tmp1 -= 0.24;\n\t\t pct += circle(tmp2 - vec2(res, tmp1), 0.0007, 0.35, 1.1);   \n    \t res += 0.6;\n\t\t tmp1 += 0.31;\n\t\t pct += circle(tmp2 - vec2(res, tmp1), 0.0007, 0.35, 1.1);   \n    \t col   = mix(col, vec3(0.0), pct);\n    \n    \n    \t // picture\n    \t tmp2  = fragCoord / iResolution.xy;    \t \n    \t tmp2 -= 0.5;    \t \n    \t tmp2.y += mod(tmp2.y + iTime * 2.5 - 4.5, 12.5); \n    \t tmp2.x *= iResolution.x / iResolution.y;    \n    \t tmp2  = rotate(tmp2, -0.08);    \n    \t tmp2 += 0.5;    \n    \t tmp2  = tmp2 + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 ) - vec2(0.25, 0.9);        \n             \n             \n     \t pct   = rect( tmp2, vec2(0.25), vec2(0.15) );\n    \t col   = mix( col, vec3(0.4, 0.2, 0.2), pct );    \n    \t pct   = rect( tmp2, vec2(0.29), vec2(0.20) );\n    \t col   = mix( col, vec3(0.71), pct );    \n    \t pct   = circle( tmp2, 0.14, 1.0, 1.0 );\n    \t col   = mix( col, vec3(0.98, 0.98, 0.824), pct );       \n\t \t pct  *= circle( tmp2 - vec2(0.055, 0.0), 0.1, 0.67, 1.37 );\n    \t col   = mix( col, vec3(0.71), pct);    \n    \t pct  *= circle(tmp2 - vec2(0.0), 0.0007, 0.35, 1.1);   \n    \t col   = mix(col, vec3(0.0), pct);\n    \n\n    \t // floor lights\n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\n    \t pct   = circle(st - vec2(0.8, -0.25), 0.62, - 3.0, 2.00);\n    \t col   = mix( col, vec3(0.98, 0.98, 0.824), pct ); \n    \n    \t pct   = circle(st - vec2(-0.8, -0.25), 0.62, - 3.0, 2.00);\n    \t col   = mix( col, vec3(0.98, 0.98, 0.824), pct ); \n    \n    \t pct   = circle(st - vec2(0.0, -0.25), 0.48, - 3.0, 2.00);\n    \t col   = mix( col, vec3(0.98, 0.98, 0.824), pct ); \n    \n    \n         // table\n    \t pct   = 1.0 - step( 0.475, tmp2.y );\n    \t col   = mix( col, vec3(.055, .475, .616),  pct );\n     \n    \n         // table edge\n    \t pct   = rect( tmp2 + vec2(0.0, 0.075), vec2(-0.39, -0.50), vec2(0.5, 0.40) );\n    \t col   = mix( col, vec3(.02, .32, .32), pct );\n\n    \t pct  *= 1.0 - smoothRect( tmp2 + vec2(0.5, 0.0270), vec2(0.1, 0.1), vec2(0.49999, 0.49999), vec2(0.987, 0.65) );\n    \t col   = mix( col, vec3(0.012, 0.176, 0.176), pct );\n    \n    \t res   = 0.0, pct = 0.0;\n    \t for(int i = 0; i < 12; i++)\n         {           \n             pct += circle( tmp2 - vec2(res - 0.825, 0.0), 0.00025, 0.244, 0.245 );             \n             res += 0.15;\n         }\n    \t col  = mix( col, vec3(0.42, 0.75, 0.18),  pct );\n    \t \n\n         // pockets  \n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\n    \t tmp2.y = tmp2.y / 0.472 - 0.5;  \n    \t pct   = circle(tmp2, 0.05, 0.244, 0.245);        \t \n    \t res   = rect( st + vec2(0.0, 0.050), vec2(0.445, 0.445), vec2(0.475, 0.475) );\n    \t pct  += res - (pct * res);   \n    \t res   = circle(tmp2 + vec2(0.0, 0.083), 0.05, 0.244, 0.245);\n    \t pct  += res - (pct * res);  \n    \n    \t tmp2  += vec2(0.915, 0.0);\n    \t pct  += circle(tmp2, 0.05, 0.244, 0.245);        \t \n    \t res   = rect( st + vec2(0.915, 0.050), vec2(0.445, 0.445), vec2(0.475, 0.475) );\n    \t pct  += res - (pct * res);    \t \n    \t res   = circle(tmp2 + vec2(0.0, 0.083), 0.05, 0.244, 0.245);\n    \t pct  += res - (pct * res);\n    \n    \t tmp2  -= vec2(1.83, 0.0);\n    \t pct  += circle(tmp2, 0.05, 0.244, 0.245);         \t \n    \t res   = rect( st + vec2(-0.915, 0.050), vec2(0.445, 0.445), vec2(0.475, 0.475) );\n    \t pct  += res - (pct * res);   \n    \t res   = circle(tmp2 + vec2(0.0, 0.083), 0.05, 0.244, 0.245);\n    \t pct  += res - (pct * res);\n    \t col   = mix(col, vec3(0.05, 0.05, 0.05), pct);  \n    \n         // playing cards\n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\n    \t tmp2  = tmp2 * 2.0 - 1.0;\t\t \n    \t pct   = smoothstep( -2.5, 1.5, -tmp2.y );       \n    \t tmp2 /= pct; \n    \t\n    \t \t// shadows -- lower layer\n    \t pct   = rect2( rotate(tmp2 - vec2(-1.8, -0.34), -0.5), vec2(10.0, 3.45), vec2(0.0), 0.08 ); \t\t\n    \t pct  += rect2( rotate(tmp2 - vec2(-0.87, -0.28), -0.49), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n    \t pct  += rect2( rotate(tmp2 - vec2(-0.14, -0.36), -0.49), vec2(10.0, 3.45), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(0.641, -0.412), -0.51), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n    \t pct  += rect2( rotate(tmp2 - vec2(0.687, -0.28), -0.49), vec2(10.0, 3.45), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(1.01, -0.34), -0.5), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n    \t pct  += rect2( rotate(tmp2 - vec2(1.45, -0.32), -0.49), vec2(10.0, 3.45), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(2., -0.34), -0.51), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\t\n    \t col   = mix(col, vec3(0.25), pct);\n    \n\t\t\t// cards -- lower layer\n\t\t pct   = rect2( rotate(tmp2 - vec2(-1.8, -0.34), -0.5), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n\t     pct  += rect2( rotate(tmp2 - vec2(-0.87, -0.28), -0.49), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(-0.14, -0.36), -0.49), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(0.641, -0.412), -0.51), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(0.687, -0.28), -0.49), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(1.01, -0.34), -0.5), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(1.45, -0.32), -0.49), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(2., -0.34), -0.51), vec2(10.5, 3.5), vec2(0.0), 0.08 );   \n    \t col   = mix(col, vec3(1.0), pct);\n    \t \n    \t \t// shadows -- mid layer\n    \t pct   = rect2( rotate(tmp2 - vec2(-1.58, -0.31), -0.5), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n    \t pct  += rect2( rotate(tmp2 - vec2(-1.1, -0.36), -0.51), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n    \t pct  += rect2( rotate(tmp2 - vec2(-0.77, -0.38), -0.52), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n\t \t pct  += rect2( rotate(tmp2 - vec2(1.67, -0.37), -0.52), vec2(10.0, 3.45), vec2(0.0), 0.08 );\t\t\n    \t col   = mix(col, vec3(0.25), pct);\n    \n    \t\t// cards -- mid layer\n    \t pct   = rect2( rotate(tmp2 - vec2(-1.58, -0.31), -0.5), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(-1.1, -0.36), -0.51), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(-0.77, -0.38), -0.52), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t pct  += rect2( rotate(tmp2 - vec2(1.67, -0.37), -0.52), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t col   = mix(col, vec3(1.0), pct);\n    \n    \t\t// shadow -- upper\n    \t pct   = rect2( rotate(tmp2 - vec2(-0.47, -0.34), -0.51), vec2(10.0, 3.45), vec2(0.0), 0.08 );\n    \t col   = mix(col, vec3(0.25), pct);\n    \n    \t\t// card -- upper\n    \t pct   = rect2( rotate(tmp2 - vec2(-0.47, -0.34), -0.51), vec2(10.5, 3.5), vec2(0.0), 0.08 );\n    \t col   = mix(col, vec3(1.0), pct);   \n    \t\n    \n         // card details\t-- |shape_rotation| < |card_rotation|\n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\n    \t tmp2  = rotate(tmp2, 0.49);\n    \t tmp2  = tmp2 * 29.0;\n    \n    \t\t// rotation -- card [50]\n    \t pct   = heart(tmp2 - vec2(10.45, 5.95), 0.0, 0.0);   \n    \t pct  += heart(tmp2 - vec2(10.95, 3.15), 0.0, 0.0); \n      \t pct  += heart(tmp2 - vec2(11.45, -25.65), 0.0, 0.0);\n    \n    \t\t// rotation -- card [51]\n    \t tmp2  = rotate(tmp2, 0.01);\n    \t pct  += heart(tmp2 - vec2(9.75, -21.85), 0.0, 0.0);\n\t\t pct  += heart(tmp2 - vec2(10.65, -37.05), 0.0, 0.0);    \n    \t pct  += heart(tmp2 - vec2(10.35, -2.25), 0.0, 0.0);  \n    \t    \n    \t\t// rotation -- card [52]\n    \t tmp2  = rotate(tmp2, -0.03);\n    \t pct  += heart(tmp2 - vec2(10.55, -4.75), 0.0, 0.0);\n    \t pct  += heart(tmp2 - vec2(13.35, -32.45), 0.0, 0.0);\n    \n    \t \t// rotation -- card [49]\n    \t tmp2  = rotate(tmp2, 0.04);\n    \t pct  += heart(tmp2 - vec2(11.25, -5.35), 0.0, 0.0);\n    \t pct  += heart(tmp2 - vec2(10.0, -13.35), 0.0, 0.0);\n    \t pct  += heart(tmp2 - vec2(10.65, -22.55), 0.0, 0.0);\n    \t pct  += heart(tmp2 - vec2(9.95, -31.0), 0.0, 0.0);\n    \n    \t col   = mix(col, vec3(0.82, 0.0, 0.0), pct);\n   \n    \t\t// spade\n\t\t tmp2  = rotate(tmp2, -0.01);\n    \t pct   = heart(tmp2 - vec2(10.65, -8.95), 0.0, 0.0);\n    \t pct  += step(lamp( ( rotate(tmp2, 0.25) - vec2(0.70, -14.35)) / 1.33, 3.0), 0.25);    \n    \t col   = mix(col, vec3(0.0), pct);\n    \n    \n         // billiard balls\n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\t\t\t\t\t\t\t\t\t\t\t// 8\n    \t tmp2.y = st.y / 0.38 + 0.2;\n    \t pct   = circle(tmp2, 0.0041, - 1.65, 2.00);\n    \t col   = mix(col, vec3(0.0) + cos(iTime * 2.0) / 2.5, pct);\n    \n    \t tmp2  = st / vec2(1.0, 0.38) + vec2( sin(iTime * 100.0) / 500.0, cos(iTime * 100.0) / 500.0 ) - vec2(-0.18, 0.02);\n    \t pct   = circle(tmp2, 0.0041, - 1.65, 2.00);\n    \t col   = mix(col, vec3(0.0) + cos(iTime * 2.0) / 2.5, pct);\n    \n    \t tmp2  = st / vec2(1.0, 0.38) + vec2( sin(iTime * 100.0) / 500.0, cos(iTime * 100.0) / 500.0 ) - vec2(0.4, 0.475);\n    \t pct   = circle(tmp2, 0.0041, - 1.65, 2.00);\n    \t col   = mix(col, vec3(0.0), pct);        \n    \n    \t tmp2  = st + vec2( sin(iTime * 100.0) / 500.0, cos(iTime * 100.0) / 500.0 );\n    \t pct   = circle(tmp2 + vec2(0.0, 0.35), 0.027, 0.244, 0.245); \n    \t col   = mix( col, vec3(0.0), pct );\n    \n    \t pct   = circle(tmp2 + vec2(0.18, 0.27), 0.02, 0.244, 0.245);\t\n    \t col   = mix( col, vec3(0.85), pct );\n    \t pct   = rect( tmp2 + vec2(0.18, 0.27), vec2(0.465, 0.465), vec2(0.488, 0.488) );\n    \t col   = mix( col, vec3(0.7, 0.0, 0.0), pct );\n    \n\t\t pct   = circle(tmp2 + vec2(-0.4, 0.1), 0.018, 0.244, 0.245);\n    \t col   = mix( col, vec3(0.85), pct );\n        \n    \t tmp2.x = tmp2.x / 0.472 * 1.15;\n    \t tmp2.y = tmp2.y / 0.472;\n         pct   = circle(tmp2 + vec2(-0.7, 0.16), 0.018, 0.244, 0.245);\n    \t col   = mix( col, vec3(0.85), pct );\n    \n    \n         // lamp body & movement      \n     \t tmp2 = st + vec2( sin(iTime * 100.0) / 650.0, cos(iTime * 100.0) / 650.0 );\n\t     tmp2.x = tmp2.x + sinusoidalTime - 0.5;\n    \t tmp2.y = tmp2.y / sin(2.64) - 2.9 + abs(cos(iTime)); \n    \t pct   = step(lamp(rotate(tmp2, .27 - sin(iTime * 1.0) / 10. ), 3.0), .25);\n    \t col   = mix(col, vec3(0.537, 0.502, 0.278), pct);   \n\n         // darken everything\n    \t col  *= vec3(0.5);\n       \n         // lamp's glow & movement\n    \t tmp2.x = st.x + sinusoidalTime + sinusoidalTime / 2.5;\n    \t tmp2.y = st.y / 0.30;\t\t\n    \t pct   = circle(tmp2, 0.34, - 2.65, 2.00);\n    \t col   = mix( col, vec3(0.98, 0.98, 0.824), pct );   \n       \n    \t // grain\n    \t tmp2  = rotate((tmp2 * 1.5 - vec2(-0.75, 0.0)), iTime) * 20.0 * mod(0.627, 1.0) ;\n    \t pct   = smoothstep(0.88, 0.88, noise( tmp2 ));\n    \t tmp3  = mix(col, vec3(0.0, 0.0, 0.0), pct);   \n    \t pct  *= smoothstep(0.81, 0.82, noise( st * 27.0 * mod( (st.x - 12.0) * sin(iTime * 4.8) * cos(iTime * 3.4), 1.0) ));    \t\n    \t col   = mix(col, tmp3, pct);\n    \n    \t // colorize - grayscale\n \t\t vec4 c4 = mat4( 0.35,\t0.35, \t0.35,  \t0.0,\n                        0.35, \t0.35, \t0.35, \t0.0,\n                        0.35, \t0.35,\t0.35, \t0.0,\n                        0.0,\t0.0,\t0.0, \t0.0 ) * vec4(col, 1.0);\n    \n    \t //vec4 c4 = vec4( vec3(dot(vec3(0.35), col)), 1.0);\t\t//<< a terse-syntax for the above*/\n    \n    \t //vec4 c4 = mat4(1.0) * vec4(col, 1.0);\n\n    \n    fragColor = vec4(c4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 120, 163, 163, 351], [353, 353, 397, 397, 511], [513, 513, 591, 591, 711], [713, 713, 774, 774, 935], [937, 937, 1021, 1021, 1279], [1281, 1378, 1458, 1458, 1569], [1571, 1660, 1687, 1687, 1804], [1806, 1895, 1921, 1921, 2257], [2260, 2357, 2425, 2425, 2687], [2689, 2753, 2810, 2810, 15907]], "test": "valid"}
{"id": "MlGyzc", "name": "Fractal emoji", "author": "Aspect", "description": "A Julia set that really makes you think. ", "tags": ["fractal", "juliaset", "thinking"], "likes": 3, "viewed": 271, "published": "Public", "date": "1537212088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A julia set combined with a \"thinking emoji\" procedural orbit trap. Dedicated to kisamegr\n//The code is a mess. I'm going to clean up the leftovers later. It was supposed to be a quick fun little thing\n//but it ended up being a pain to finish.\n\n#define PI 3.1415926535\nfloat fun2(in vec2 z)\n{\nreturn length(max(abs(z+texture(iChannel0,z).xy*0.1)-(+vec2(0.14*(1.0),0.14)),0.0))   ;\n}\n\nmat2 rot( in float a,in vec2 p ) \n{\n    float c = cos(a*p.y);\n    float s = sin(a*p.y);\n\treturn mat2(c,-s,s,c);\t\n}\n\nmat2 rotf( in float a) \n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,-s,s,c);\t\n}\n\nfloat sminc( float a, float b,float k )\n{\n   \n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return (length(p) - r);\n}\n\nfloat udSquare( vec2 p, float s )\n{\n  return length( max(abs(p)-s,vec2(0)) );\n}\n\nfloat sdcLine( in vec2 p, in vec2 a, in vec2 b )\n{\n  \tp=rot(-0.85,p)*p;\n    a=rot(-0.85,a)*a;\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n   float dist=(length( pa - (ba)*h ))-0.15;\n\treturn dist*0.25;\n}\n\nfloat sdccLine( in vec2 p, in vec2 a, in vec2 b )\n{\n  \tp=rot(-0.85,p)*p*1.6;\n    a=rot(-1.15,a)*a*1.;\n    b*=1.0;\n\tvec2 pa = p-a;\n    vec2  ba = b-a;\n    ba=rot(-0.425,ba)*ba*1.2;\n    pa=rot(-0.325,pa)*pa*1.5;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn (length( pa - (ba)*h )-1.0);\n}\n\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn 1.0*(abs(length( pa - (ba)*h )-0.1)-0.25);\n}\n\n\n\n\n\n\n\n\nfloat fun1(in vec2 p)\n{\n    const float k = sqrt(0.040);\n    \n     p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -3.0, 0.0 );\n   return -length(p)*sign(p.y)*0.01;\n   \n}\n\nfloat fun3(in vec2 p)\n{\n  const float r=0.04;\n  const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);   \n}\nfloat annularfun3(in vec2 p)\n{\n return abs(fun3(p))-0.01;\n}\n\nfloat annularCircle(in vec2 p,float r)\n{\n return abs(sdCircle(p,r)-0.02);\n}\n\nfloat opu(float d1,float d2)\n{\n    return (d1<d2) ? d1:d2;\n}\nfloat ops( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat thinking(in vec2 p,in vec2 uv)\n{\n    //mouth\n    vec2 linea= vec2(0.0,0.0);\n    vec2 lineb= vec2(0.7,0.7);\n      \n    \n    //brows\n    vec2 linea1= vec2(0.0,0.0);\n    vec2 lineb1= vec2(0.6,0.6);\n    \n    vec2 linea2= vec2(0.0,0.0);\n    vec2 lineb2= vec2(0.6,0.6);\n    \n    //fingers\n    vec2 lineaz= vec2(0.0,0.0);\n    vec2 linebz= vec2(1.3,1.3);\n    \n    vec2 lineazz= vec2(0.0,0.0);\n    vec2 linebzz= vec2(1.6,1.6);\n    \n    \n  //head\n   float mini= opu(sdCircle(p+vec2(-0.025,-0.13),0.03),sdCircle(p+vec2(0.085,-0.05),0.03));\n   mini=opu(mini,annularCircle(p,0.262));\n   mini=opu(mini, sdcLine((p+vec2(-0.015,0.030))*8.1,lineb,linea)); //mouth\n   mini=opu(mini, sdcLine((rotf(0.24)*p+vec2(-0.015,-0.12))*10.1,lineb1,linea1)); //brows\n   mini=opu(mini, sdcLine((p+vec2(0.19,-0.065))*10.1,lineb2,linea2));\n\n    \n    //hand\n    p+=vec2(-0.06,0.08);\n    vec2 finoffs1=vec2(0.07,0.220);\n    vec2 finoffs2=vec2(0.06,0.28);\n    vec2 finoffs3=vec2(0.045,0.3);\n    \n    \n   p= rotf(0.45)*p;\n   mini=sminc(mini,sdCircle(p+vec2(0.1,0.215),0.10),0.1);\n   mini=sminc(mini,sdLine((rotf(-0.14)*p+vec2(0.085,0.140))*9.5,linebzz,lineazz),0.5);\n    mini=sminc(mini,sdccLine((rotf(-2.64)*p+vec2(-0.195,0.040))*10.,linebz,lineaz),1.1);\n   mini=sminc(mini,sdLine((rotf(-0.19)*p+finoffs1)*11.1,linebz,lineaz),0.5);\n   mini=sminc(mini,sdLine((rotf(-0.14)*p+finoffs2)*11.6,linebz,lineaz),0.5);\n    mini=sminc(mini,sdLine((rotf(-0.19)*p+finoffs3)*14.1,linebz,lineaz),0.2);\n   \n    \n    \n  return abs(mini)*15.5;   \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\t\t\n    float tz = 22.5+0.5*cos(0.0024*(iTime)*(iTime));\n    vec2 c = vec2(0.8-0.07*tz,0.1500);\n    vec2 z = vec2((screenPos*0.7*cos(sqrt(0.1*iTime))+vec2(1.25-0.2,-0.2-0.03*cos(sqrt(iTime)))))+vec2(-1.21,0.10);\n\tvec2 zder = vec2(texture(iChannel0,z).xy*0.06);\t\n    float howclose=0.;\nfloat modsquared=dot(z,z);\n        float fracdist=0.;\n    float fracdistg=999.;\n    float fracdistb=0.;\n    float flagd=0.0;\n    \n    vec2 v0 = vec2(1.3,0.9)*cos(iTime*1.1 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*1.2 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*1.3 + vec2(2.0,1.0) );\n\n\tfor(int i=0;i<60;++i)\n    {\n\t    if(sqrt(modsquared)>2.0)\n        {\n\t\t\thowclose=float(i);\n\t\t\tbreak;\n            flagd+=1.;\n\n        }\n\t\t\n        zder=2.*vec2(z.x*zder.x-z.y*zder.y,+z.x*zder.y+z.y*zder.x)+vec2(1.0,0.0);\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y) + c;\n        z = z;\n\t\t modsquared=dot(z,z);\n        \n        \n       \tfloat epsd=1.5; \n        //vec2 bpoint=0.095*tz*(z-vec2(0.01))+0.01*texture(iChannel0,z*tz).xy;\n      //  vec2 bpoint=((z+vec2(epsd,epsd))+(z+vec2(epsd,-epsd))+(z+vec2(-epsd,epsd))+(z+vec2(-epsd,-epsd)))/2.5;\n        fracdistg=min(fracdistg*0.85,1.15*thinking(z*2.26,screenPos));\n \n    }\n    fracdist=sqrt((modsquared)/(0.5*dot(zder,zder)))*log(modsquared);\n    //fracdistg= fracdist + tz* texture(iChannel0,screenPos).x;\n    fracdistb= fracdist + tz*texture(iChannel0,screenPos).y; \n    \n    howclose=3.5*exp(howclose/32.);\n    \n    fracdistg=sqrt(fracdistg);\n    \n    \n    if(flagd>0.)\n    {\n     fracdistg+=   tz*0.1*texture(iChannel0,screenPos).y;\n    }\n    \n    \n    fracdist= clamp( fracdist*(0.45*tz*pow(iTime*15.1,0.95)), 0.0, 1.0 );\n    fracdistg=clamp( fracdistg*((tz)*0.1*pow(iTime*0.65,0.15)), 0.0, 1.0 );\n    fracdistb=clamp( fracdistb*(tz*pow(iTime+10.,0.65)), 0.0, 1.0 );\n    float colr=fracdist*(howclose/66.);\n    float colg=fracdistg*(howclose/27.);\n    float colb=fracdistb;\n\t\n    \n    vec3 col =vec3(colr*4.1,(colg*1.15+colr)/2.,colg*4.11159);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 271, 294, 294, 384], [386, 386, 421, 421, 500], [502, 502, 527, 527, 598], [600, 600, 641, 641, 727], [729, 729, 764, 764, 792], [794, 794, 829, 829, 873], [875, 875, 925, 925, 1112], [1114, 1114, 1165, 1165, 1415], [1419, 1419, 1468, 1468, 1600], [1609, 1609, 1632, 1632, 1870], [1872, 1872, 1895, 1895, 2189], [2190, 2190, 2220, 2220, 2249], [2251, 2251, 2291, 2291, 2326], [2328, 2328, 2358, 2358, 2388], [2389, 2389, 2422, 2422, 2448], [2451, 2451, 2489, 2501, 3951], [3957, 3957, 4014, 4064, 6237]], "test": "error"}
{"id": "MlKcDD", "name": "Quadratic Bezier - distance 2D", "author": "iq", "description": "Distance to a quadratic Bezier segment, which can be computer analytically by solving a cubic equation.", "tags": ["2d", "distancefield", "sdf", "bezier", "cubic", "quadratic"], "likes": 44, "viewed": 5979, "published": "Public API", "date": "1536382634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=(q+4p)=q(1+4p/q)=q(1+w) instead. Now we approximate\n        //  by a linear Taylor expansion into hq(1+w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p/q,-p/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p/q)p/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    \n    float d = sdBezier( p, v0,v1,v2 ); \n    \n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdBezier(m, v0,v1,v2 ); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n \n    if( cos(0.5*iTime)<-0.5 )\n    {\n        d = min( udSegment(p,v0,v1),\n                 udSegment(p,v1,v2) );\n        d = min( d, length(p-v0)-0.02 );\n        d = min( d, length(p-v1)-0.02 );\n        d = min( d, length(p-v2)-0.02 );\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcDD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1168, 1325, 1350, 1350, 1369], [1370, 1370, 1408, 1408, 1436], [1439, 1480, 1544, 1544, 3448], [3450, 3450, 3502, 3502, 3622], [3624, 3624, 3681, 3681, 4877]], "test": "valid"}
{"id": "MlKcDm", "name": "ShaderToy Tutorial CS", "author": "jkashimura", "description": "HW for 9/11", "tags": ["education"], "likes": 1, "viewed": 60, "published": "Public", "date": "1536683554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){ //return value \n    float d = length(uv-p); //distance - remaps point p to 0\n    float c = smoothstep(r,r-blur,d); //can replace with blur\n    \n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur,t);\n    float step2 = smoothstep(end+blur, end-blur,t); //switch signs too\n\n    return step1*step2; //gets both ends to make band\n}\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){ //take 2d input\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n\n    return band1*band2;//multiply bands to make rectangle\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size){ //smiley face function\n    uv -= p; //translate coordinate system\n    uv /= size; //scaling coordinate system\n    \n    float mask = Circle(uv, vec2(0.), 0.4, 0.01); //different c\n    \n    mask -= Circle(uv, vec2(-0.13,0.2), 0.07, 0.01); //subtract so the circle is missing - left eye\n    mask -= Circle(uv, vec2(0.13,0.2), 0.07, 0.01); //subtract so the circle is missing - right eye\n\n    float mouth = Circle(uv, vec2(0.), 0.3, 0.02);\n    mouth -= Circle(uv, vec2(0.,0.1), 0.3, 0.02);//subtract a circle out for the mouth\n    \n    mask -= mouth; //they're some -1 so the eyes are droopy\n    \n    return mask;\n}\n\nfloat remap01(float a, float b, float t){\n    return (t-a)/(b-a);//return number depending on the distance a-b (a=0,b=1)\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a,b,t)*(d-c)+ c; //remap according to distance\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat t = iTime; //number of seconds since started\n    \n    uv -= 0.5; //-0.5<x<0.5\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 col = vec3(0.);//color\n    \n    float mask = 0.;\n    \n    //Smiley(uv, vec2(0.), 1.); //we can move things around\n    \n    float x = uv.x; //split x and y\n    \n    float m = sin(t+x*8.)*0.1;//squeeze the sin graph and move it\n    float y = uv.y-m; //subtract magic value\n\n    float blur = remap(-.5,0.5,0.01,0.25,x);//function of x,gets blurrier\n    blur=pow(blur*4.,2.);//non-linear\n    mask = Rect(vec2(x,y),-.5, .5,-0.1, 0.1, blur); //horizontal\n\tcol = vec3(1.,1.,1.)*mask; //multiply by mask\n    \n    fragColor = vec4(col,1.0); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 67, 211], [213, 213, 269, 269, 453], [454, 454, 536, 552, 708], [710, 710, 752, 775, 1364], [1366, 1366, 1407, 1407, 1488], [1490, 1490, 1547, 1547, 1615], [1617, 1617, 1674, 1724, 2460]], "test": "valid"}
{"id": "MlKcRG", "name": "Circle, Smiley, Rectangle, Sine", "author": "tiff", "description": "Basics- Drawing a circle / smiley face / rectangle / sine function line", "tags": ["circle"], "likes": 1, "viewed": 54, "published": "Public", "date": "1536942132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//drawing a circle\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r,r-blur, d);\n    \n\treturn c; \n}\n\n//drawing a band\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start - blur, start + blur, t); //start of band\n    float step2 = smoothstep(end + blur, end - blur, t); //end of band\n\n    return step1*step2; //multiplying both sides to make the band \n}\n\n//drawing a rectangle\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n\tfloat band1 = Band(uv.x, left, right, blur); //vertical band\n    float band2 = Band(uv.y, bottom, top, blur); //horizontal band\n    \n    return band1 * band2; //multiplying the bands to make a rectangle\n\n}\n\n//drawing a smiley\nfloat Smiley(vec2 uv, vec2 p, float size){\n\tuv -= p; // remaps in relation to uv\n    uv /= size; //scaling coordinate system\n    \n    float mask = Circle(uv, vec2(0.), .4, .01);\n    //mask += Circle(uv, vec2(-.5, .2), .1, .01); // += adds this circle to previous circle,\n    //mask \\-= Circle(uv, vec2(-.5, .2), .1, .01); // -= makes a 'black circle, if overlaps, carves a part out of a different circle\n    mask -= Circle(uv, vec2(-.13, .2), .07, .01); //eyes\n    mask -= Circle(uv, vec2(.13, .2), .07, .01); //eyes\n    \n    float mouth = Circle(uv, vec2(0., 0.), .3, .02); \n    mouth -= Circle(uv, vec2(0., 0.1), .3, .02); //circle - cirle to make the shape of the mouth\n    \n    mask -= mouth; //drwaing mouth to the face\n    return mask; //returning the face\n}\n\nfloat remap01(float a, float b, float t){\n\treturn (t-a)/(b-a);\t\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn remap01(a, b, t) * (d-c) + c;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    \n    uv -= .5; //-0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(1.);\n    \n    float mask = 0.;\n\t//float mask = Smiley(uv, vec2(0.), 1.);\n    \n    float x = uv.x;\n    float m = sin(t+x*8.)*.1;\n    float y = uv.y-m;\n    \n    float blur = remap(-.5, .5, .01, .25, x);\n    //blur = pow(blur*4., 3.);    \n    x += y*0.;\n\n    mask = Rect(vec2(x,y), -.5, .5, -.1, .1, blur); \n    \n    col = vec3(1., 1., 1.)*mask;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 70, 70, 156], [158, 175, 231, 231, 449], [451, 473, 555, 555, 762], [764, 783, 825, 825, 1547], [1549, 1549, 1590, 1590, 1614], [1616, 1616, 1673, 1673, 1714], [1716, 1716, 1773, 1823, 2403]], "test": "valid"}
{"id": "MlKcRR", "name": "VctrBox", "author": "kvick", "description": "laser box", "tags": ["retro", "box"], "likes": 4, "viewed": 89, "published": "Public", "date": "1537899199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE .1031\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime * 250.)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.01 / (dist2Line));\n    \n    f *= 0.1;\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t1., \t\t0.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        0., \t1., \t\t0.,\n        0.,\t\tcos(d),\t\tsin(d),\n        0.,\t\t-sin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    p = rotY(p, iTime);\n    \n    vec3 pCenter = vec3(-0., 0., 1.0);\n    p += pCenter;\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 hill(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-1.0, 0.1), vec2(viewAngle, 0.) + vec2(-0.5, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.5, 0.2), vec2(viewAngle, 0.) + vec2(-0.1, 0.4));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.1, 0.4), vec2(viewAngle, 0.) + vec2(0.4, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.4, 0.2), vec2(viewAngle, 0.) + vec2(0.8, 0.1));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.6, 0.0), vec2(viewAngle, 0.) + vec2(1.0, 0.2));\n    \n    //HillPeak\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.3, 0.3), vec2(viewAngle, 0.) + vec2(-0.18, 0.32));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.18, 0.32), vec2(viewAngle, 0.) + vec2(-0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.01, 0.31));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.01, 0.31), vec2(viewAngle, 0.) + vec2(0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.15, 0.3));\n    \n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-1., 0.0), vec2(1., 0.0));\n    return color;\n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n    //Cool warpy look\n    //st = vec2(pow(st.x, 2.), pow(st.y, 2.));\n    \n    //Trying to get a CRT-style monitor warp\n    //float stDistortPow = 2.;\n    //st += vec2(pow(st.x, stDistortPow)* ((st.x < 0.) ? -1.: 1.), pow(st.y, stDistortPow) * ((st.y < 0.) ? -1.: 1.));\n    \n\tfloat f;\n    \n    float iTime = iTime * 1.0;\n    \n    vec3 color = vec3(0.);\n\t\n    float deg = iTime * PI * 0.25;\n    float halfPI = PI * 0.5;\n\tf = getLine(st, \n                vec2(0.5, 0.5) + vec2(cos(deg), sin(deg)), \n                vec2(0.5, 0.5) + vec2(cos(deg + PI), sin(deg + PI))\n                );\n    f = 0.;\n    \n    color += vec3(0.8, 0., 0.) * f;\n    \n    float scale = 0.125 + sin(iTime) * 0.05 + 0.05;\n    \n    vec3[] p = vec3[](\n        (vec3(-scale, -scale, -scale)),\n    \t(vec3(-scale,  scale, -scale)),\n        (vec3( scale,  scale, -scale)),\n    \t(vec3( scale, -scale, -scale)),\n        \n        (vec3(-scale, -scale, scale)),\n    \t(vec3(-scale,  scale, scale)),\n     \t(vec3( scale,  scale, scale)),\n        (vec3( scale, -scale, scale))\n    );\n    \n    vec2[8] p_;\n    for (int i = 0 ; i < 8; ++i)\n    {\n        p_[i] = pToS(p[i]);\n    }\n    \n    const int k_edgeMax = 8 * 3;\n    int[] edges = int[](\n        0, 1,\n        1, 2,\n        2, 3,\n        3, 0,\n        \n        4, 5,\n        5, 6,\n        6, 7,\n        7, 4,\n        \n        //Draw connecting lines\n        0, 4,\n        1, 5,\n        2, 6,\n        3, 7\n    );\n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.003;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n        \n        //Rays casting from top right to give that projected look\n        float crazyTown = sin(iTime * 5.) * 0.2 + 0.2;\n        float texSample = texture(iChannel0, vec2(mod(iTime * 5., 1.), 0.)).x * 0.4;\n        crazyTown = texSample;\n        crazyTown *= clamp(sin(iTime + st.x), 0., 1.);\n        \n        f += getLine(st, pointA + float(i), pointB) * crazyTown;\n        \n    }\n    \n    //Color\n    //vec3 color = vec3(.05, 1., .1);\n    color += vec3(0., 0.3, 0.8) * f * 1.;\n    \n    //Hills\n    color += hill(st);\n    \n    //Grid\n    vec3 gridColor = vec3(0.9, 0., 0.1) * 0.15;\n    float gridSpacing = 0.2;\n    color += gridColor * getLine(vec2(st.x, mod(st.y + 0.5, gridSpacing)), vec2(-1., 0.), vec2(1., 0.));\n    \n    \n    float gamma = 0.59;\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 156, 177, 177, 294], [296, 379, 423, 423, 449], [451, 534, 582, 582, 630], [632, 632, 678, 678, 845], [847, 847, 890, 890, 1146], [1148, 1148, 1194, 1194, 1463], [1465, 1465, 1493, 1493, 1657], [1659, 1659, 1687, 1687, 1858], [1860, 1860, 1888, 1888, 2054], [2056, 2056, 2075, 2075, 2207], [2209, 2209, 2229, 2229, 3856], [3858, 3941, 3998, 3998, 7047]], "test": "error"}
{"id": "MlKcRt", "name": "AutomaticDifferenciation lib", "author": "ollj", "description": "a large and still quite messy library\nit dares to define automatic differenciation #define'ss that work on multiple different structs and vector types\ni fixed my od apha compositing, so you see all the demo layers on top of another....", "tags": ["derivative", "library", "ad", "chainrule", "common", "hgsdg"], "likes": 6, "viewed": 397, "published": "Public API", "date": "1537386586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//alphacompositing fixed\n//lacks root-solving shapes (parabola-ellipse)\n//canvas \"TinyBri300OHGDAPo14\"\n//lots of code from [inogo quilez] [mercury] [dr2] [David Hoskins]\n//has iFrame fixed\n//has unified smin() smooth-Boolean-fuzzy-logic variants\n//has complex 2d transforms (possibly buggy,checked as much as i care and know this stuff)\n//has some rgba-colorspace-gradients/indicators (but surely not all that i care for,cieluelch is missing)\n//has noise (upper ones are better for (hyperplanes of) less domains\n//- tri,which is food for very fast volumetric storms\n//- h41=[fastest fbm with normals],that is just fast fbm noise with (poorly estimated) 3d normals\n//- hfd=[hash(fract(dot()))],that does not use sin(fract(a)),by David Hopkins\n//- cel=cellular noise,parallelized/fast vorley noise with 2 shortest distances in 2d or 3d,with hash as additional static domain.\n//- s13=[simplex],highest quality/performance noise,generally too slow for 3d spheretracking (as displacement or heightmap)\n//- - lacks bayerMatrix,blueHash<-part of higher-domain content.\n//has DA derivative arithmetic\n//- has issues with Param2:\n//- - decapitated filling lists with zeroes,seems VERY nonsensical\n//- - DA mixing differs from MAT mixin,not just in structure.\n//- - ... previous DA shaders made the error od declaring DA-mixing as MAT-mixind with DA-parameters?\n//- - ... or was that just cases where MAT is identical to DA?\n//has alias-folds fixed,with mercury.sexy/hg_sdf\n//- are declared as defines,for\n//- - N-dimensional inputs,where that function still makes sense in higher dimensions\n//- - uses the same labels as DA,so depending on input it can also calculate derivatives\n//- Includes minified HG_SDF by Mercury mercury.sexy/hg_sdf\n//- omitted platonic solids because the original code uses arrays\n//- Some functions are converted to macros because they would be even smaller when preprocessed.\n//- Another macro,_M,is really filling up almost identical code as to make the result even smaller,\n\n//has AD=automatic Differentiation via chain rule but only demoes it in 1d\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n\n#define vec1 float\n#define norma normalize\n//#define ss smoothstep\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define cl(a,b,c) mi(ma(a,0.),1.)//till i define this for AD\n#define sat(x) cl(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define u5cos(a) u5(cos(a))\nstruct v11{vec1 a;vec1 b;};\nstruct v22{vec2 a;vec2 b;};\nstruct v33{vec3 a;vec3 b;};//for 2 domains(density/distance field)\nstruct v44{vec4 a;vec4 b;};\nstruct v444{vec4 a;vec4 b;vec4 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v333{vec3 a;vec3 b;vec3 c;};\nstruct v3333{vec3 a;vec3 b;vec3 c;vec3 d;};\nstruct v222{vec2 a;vec2 b;vec2 c;};\n//v222 g222(vec3 a,vec3 b){return v222(vec2(a.x,b.x),vec2(a.y,b.y),vec2(a.z,b.z));}\nv222 g222(v33 a){return v222(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv3333 muv(v3333 a,vec4 b){return v3333(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nvec4 ddv(v3333 a){return vec4(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD,wherelater spaces are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\nstruct DAm2{w13 x;w13 y;w13 z;};//for 3 domains (density/distance field) \nstruct DAm1{w12 x;w12 y;};//for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w11 x;};//for 2 domains (heightmap,isoline,contour)\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n\n\n\n\n\n\n\nw11 ma(w11 a,vec1 b){return w11(max(a.a,b),max(a.b,b));}\nw11 mi(w11 a,vec1 b){return w11(min(a.a,b),min(a.b,b));}\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n//DAm2 maxdm(DAm2 a,v2 p){return DAm2(maxd(a.a,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\n//DAm2 mindm(DAm2 a,v2 p){return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\n//DAm2 maxdm(DAm2 a,vec1 p){return maxdm(a,v2(p));}\n//DAm2 mindm(DAm2 a,vec1 p){return mindm(a,v2(p));}//needed for fast clamping\n//w13 maxdm(w13 a,w13 b,w13 c){return maxd(maxd(a,b),c);}\n//w13 maxdm(DAm2 a){return maxdm(a.a,a.y,a.z);}\n//The 3(or 2)dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN p)]:\n//where N=number of domains,range [0..3]\nv444 da_domain(vec3 p){return v444(vec4(p.x,1,0,0),vec4(p.y,0,1,0),vec4(p.z,0,0,1));}\nv33 da_domain(vec2 p){return v33(vec3(p.x,1,0),vec3(p.y,0,1));}\nvec2 da_domain(vec1 p){return vec2(p,1);}//for 1 domain(linear equation)\n//vNN() declares c11() c22() c33() c44()... for implicit typecasting into structs; v11 v22 v33 v44\nv11 c11(vec1 a,vec1 b){return v11(a,b);}\nv11 c11(vec1 a){return v11(a,a);}\n#define vNNv(z,x) {return z(x(a),x(b));}\n#define vNNu(z,x,y) z x(vec1 a,y b)vNNv(z,y) z x(y a,vec1 b)vNNv(z,y) z x(vec1 a,vec1 b)vNNv(z,y)\n#define vNN(z,y,x) vNNu(z,y,x) z y(x a,x b){return z(a,b);} z y(x a){return z(a,a);}\nvNN(v22,c22,vec2)\nvNN(v33,c33,vec3)\nvNN(v44,c44,vec4)\n\n\n//param1MAT dreaming of vec5 and vec2x2,also,this keeps define-namespace unused,by declating function sets!\n//lets me type \" a=min(vec3(a),float(b)) a=pow(vec3(a),float(b)) \" with less explicit typecasting and shorter aliases:\n//negate,reciprocal,abs,log,sin,asin,cos,acos,tan,atan,fract,floor\n#define NE(y,z) z ne(z a){return -a;}y ne(y a){return y(-a.a,-a.b);}\nNE(v11,vec1)NE(v22,vec2)NE(v33,vec3)NE(v44,vec4)\nw13 ne(w13 a){return w13(-a.a,-a.b);}\nw12 ne(w12 a){return w12(-a.a,-a.b);}\nw11 ne(w11 a){return w11(-a.a,-a.b);}\n#define def1E(z,y,x) x z(x a){return y(a);}\n#define def1(a,b) def1E(a,b,vec1) def1E(a,b,vec2) def1E(a,b,vec3) def1E(a,b,vec4)\n#define re(a) di(1.,b)\ndef1(ab,abs)def1(sg,sign)def1(sq,sqrt)\ndef1(ln,log)def1(ex,exp)\ndef1(si,sin)def1(asi,asin)\ndef1(co,cos)def1(aco,acos)\ndef1(ta,tan)def1(ata,atan)\ndef1(fr,fract)\ndef1(fl,floor)\n//----param2MAT\n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(ne(a)))\n#define def2U(z,y,x) x z(vec1 a,x b){return y(x(a),b);} x z(x a,vec1 b){return y(a,x(b));}\n#define def2E(z,y,x) x z(x a,x b){return y(a,b);}\n#define def2(a,b) def2E(a,b,vec1) def2E(a,b,vec2) def2E(a,b,vec3) def2E(a,b,vec4)\n#define defU(a,b) def2(a,b) def2U(a,b,vec2) def2U(a,b,vec3) def2U(a,b,vec4)\n#define sub(a,b) ((a)-(b))\n#define add(a,b) ((a)+(b))//sub(a,ne(b))\n#define div(a,b) ((a)/(b))\n#define mul(a,b) ((a)*(b)) //di(a,re(b)) reciprocal define may lose time&precision\n//a lot of these just reserve namespaces //dot() is special for folding to a vec1 uses defD()\n#define def2D(z,y,x) vec1 z(vec1 a,x b){return y(x(a),b);} vec1 z(x a,vec1 b){return y(a,x(b));}\n#define def2F(z,y,x) vec1 z(x a,x b){return y(a,b);}\n#define defF(a,b) def2F(a,b,vec1) def2F(a,b,vec2) def2F(a,b,vec3) def2F(a,b,vec4)\n#define defD(a,b) defF(a,b) def2D(a,b,vec2) def2D(a,b,vec3) def2D(a,b,vec4)\n//vNN operands foldlike this:\n#define vXX(z,y) z(y(a.a,b),y(a.b,b))\n#define vXY(z,y) z(y(a.a,b.a),y(a.b,b.a))\n#define vvZ(z,w,v,y) w z(w a,v b){return y(w,z);}w z(w a,vec1 b){return y(w,z);}w z(v11 a,v b){return y(w,z);}\n#define vvY(z,w,v,y) w z(w a,v b){return y(w,z);}w z(v a,w b){return y(w,z);}w z(w a,w b){return y(w,z);}\n#define vvX(y,w,v) vvZ(y,w,v,vXX) vvY(y,w,v11,vXY)\n#define vMM(z) vvX(z,v22,vec2)vvX(z,v33,vec3)vvX(z,v44,vec4)v11 z(v11 a,v11 b){return vXY(v11,z);}v11 z(v11 a,vec1 b){return vXX(v11,z);}\n//alias2_NinputAsVec; due to symmetrically defined alising,in favor of min() max() functions (previously called miv() mav()):\n//note that dt(vec4 a)==dot(dot(a.x,a.y),dot(a.z,a.w)),equivalent to ad(vec4 a)\n//note that po(vec4 a)==pow(pow(a.x,a.y),pow(a.z,a.w)),which is quite silly\n//note that su(vec4 a)==(a.x-a.y)-(a.z-a.w)=a.x+a.w-a.y-a.z=a.x+a.w-(a.y+a.z)\n//note that di(vec4 a)==(a.x/a.y)/(a.z/a.w)=a.x*a.w/a.y/a.z=a.x*a.w-(a.y*a.z)\n//alternatively fo() couls also be defined as dot(a,1.),where parts of a are negated or reciprocal\n#define Fo1(u,t) vec1 u(t a){return u(a.x,a.y);}\n#define Fo2(u,t) vec1 u(t a){return u(u(a.xy),a.z);}\n#define Fo3(u,t) vec1 u(t a){return u(u(a.xy),u(a.zw));}\n#define Fon(u) Fo1(u,vec2) Fo2(u,vec3) Fo3(u,vec4)\n#define defM(a,b) defU(a,b) vMM(a) Fon(a)\ndefM(po,pow)\ndefM(mi,min)defM(ma,max)\ndefM(su,sub)defM(di,div)\ndefM(ad,add)defM(mu,mul)\ndefM(mo,mod)\ndefM(st,step)\n//higher domains for high-domain-permutations/zOrder/Noise\n//v33 su(vec3 a,v33 b){return v33(a-b.a,a-b.b);}\nv33 g33(vec2 a){return v33(vec3(a.x),vec3(a.y));}\nv333 su(vec3 a,v333 b){return v333(a-b.a,a-b.b,a-b.c);}\nv333 g333(v33 a,vec3 b){return v333(a.a,a.b,b);}\nv3333 g3333(vec3 a,v333 b){return v3333(a,b.a,b.b,b.c);}\nv44 fl(v44 a){return v44(fl(a.a),fl(a.b));}\nv44 fr(v44 a){return v44(fr(a.a),fr(a.b));}\n//polar Complex dot()\nconst vec3 vs=vec3(-1,0,1);\n#define le(a) sq(dd(a))\ndefD(dt,dot)\n#define dd(a) dot(a,a)\n//vMM(dt)//breaks a pattern,due to being a foldingprojection\nFon(dt)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n//\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(vec1 a){return cs(vec2(a,a));}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)-(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\nmat2 r1(vec1 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}//rotate point by eightRotation (part of hg_sdf)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(le(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 sqc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}//vec2 po2c(vec2 a){return muc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nvec2 lgc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 lgc(vec4 a){return vec4(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nvec2 suc(vec2 a,vec2 b){return a-b;}vec2 adc(vec2 a,vec2 b){return a+b;}///complex addition is trivial\nvec2 muc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 muc(vec2 a,vec2 b,vec2 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 muc(vec4 a){return muc(a.xy,a.zw);}//parallel mult\nvec2 dic(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nvec2 lgc(vec2 a,vec2 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 lgc(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nvec2 exc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//vec2 lgc(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 poc(vec2 a,vec2 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 poc(vec2 w,vec2 z,float c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nvec2 lgc(vec2 a,vec2 b,float c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nvec2 wrtc(vec2 a,vec2 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtc(vec2 a,vec2 b,float c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//vec2 sqc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\nvec2 sic(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sic(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sic(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 coc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n\n//obsoleted vec2 coc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 coc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tac(vec2 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nvec2 cotc(vec2 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sihc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 cohc(vec2 z){return coc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 vec2 tahc(vec2 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 vec2 cothc(vec2 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(vec2 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl2.0 vec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//cosh(x)==(pow(e,x)+pow(e,-x)*.5\n//sinh(x)==(pow(e,x)-pow(e,-x)*.5\n//\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nvec2 arsic(vec2 z){return c2(lgc(perp(z)+sqc(c2(po2c(z.yx)))+vec2(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsic(vec2 z){vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcoc(vec2 z){return-c2(lgc(z+c2(sqc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcoc(vec2 z){ vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=lgc(vec2(p+q-z.y,-z.x)/r);vec2 b=lgc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nvec2 artac(vec2 z){return sub2(c4(lgc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artac(vec2 z){ vec2 a=lgc(vec2(1.0+z.y,-z.x));vec2 b=lgc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(sub2(c4(vec4(z,sqc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=su(u);return lgc(c2(z)+sqc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r+p-q,-2.0*z.x*z.y));a=lgc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return lgc(z+sqc(po2c(z)+vec2(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return lgc(z+muc(sqc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-su(z*z);z*=2.;return .5*lgc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return lgc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return lgc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=su(z*z);return lgc(c2(z)+muc(sqc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2);return float(b.x==b.y);}\nfloat checkerBool(hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a\n ;}\n \n//---param3MAT\n//SF3() is a hot mess to be simplified a lot! //only allows for vec1 ot vecmax\n//explicit namespace fold for scalar operations\n#define fi3(m,z,a,b,c) {return z(m(a),m(b),m(c));}\n#define Q3(z,a,b,c){return z(a,b,c);}\n#define SF3(n,y,z,a,b,c) n y(n a,n b,n c)fi3(n,z,a,b,c) n y(n a,n b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,n b,n c)fi3(n,z,a,b,c) n y(vec1 a,n b,vec1 c)fi3(n,z,a,b,c)\n#define scalar3(y,z) vec1 y(vec1 a,vec1 b,vec1 c)Q3(z,a,b,c) SF3(vec2,y,z,a,b,c) SF3(vec3,y,z,a,b,c) SF3(vec4,y,z,a,b,c)\nscalar3(mx,mix)\n//---param1AD Automatic Differenciation (needs param2MAT)\n//todo AD for;tan,asin,acos,atan,reciprocal\n//memo museum: for consistency structure changed: d->v00->v11;d1->v01->w12;d2->v02->w13\n//...the swivels oof d; are .xd ,the swivels of v0N (and [w*]) are .ab\nvec1 rec(float a){return(a==0.)?a:1./a;}//return [1/a] ,work safe//sqrt()and divisions require a worksave reciprocal operator:\n#define sqD(h)h sq(h a){vec1 q=sq(a.a);return h(q,.5*rec(q)*a.b);}\n#define cmD(h,i) h cmd(w11 a,i b){return h(a.a,mu(a.b,b));}\ncmD(w11,vec1)cmD(w12,vec2)cmD(w13,vec3)cmD(w14,vec4)//cmd() is special case of component-wise-multiplication,special because a.x==1: is subroutine of abs()\n//i am not too sure about my implementation on fr();\n//the hell,just use mo()instead,mo()has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)-=.0)\nvec1 jud(vec1 a){return mx(a,-1.,st(fr(a),0.)*st(0.,fract(a)));}\nvec2 jud(vec2 a){return vec2(jud(a.x),jud(a.y));}\nvec3 jud(vec3 a){return vec3(jud(a.x),jud(a.y),jud(a.z));}\nvec4 jud(vec4 a){return vec4(jud(a.x),jud(a.y),jud(a.z),jud(a.w));}\n//i should definitely define this by fract,and not by floor.\n//because fm-modulation taught me that i need fract()a lot more than floor()\n#define frD(h)h fr(h a){return h(fl(a.a),jud(a.b));}\n#define abD(h)h ab(h a){return cmd(w11(ab(a.a),sg(a.a)),a.b);}//w13(abs(a.x),sign(a.x)*a.d);}\n#define siD(h)h si(h a){return h(si(a.a),mu(co(a.a),a.b));}\n#define coD(h)h co(h a){return h(co(a.a),mu(ne(si(a.a)),a.b));}\n#define lgD(h)h ln(h a){return h(ln(a.a),di(a.b,a.a));}\n#define exD(h)h ex(h a){vec1 x=exp(a.a);return h(x,x*a.b);}\n#define DA1(h)h(w11)h(w12)h(w13)h(w14)\nDA1(abD)DA1(siD)DA1(coD)DA1(lgD)DA1(exD)DA1(sqD)DA1(frD)//because different functions have unique derivatives,\n//fl(a)=a-fr(a); hasvery slightly lower precision?rarely relevant.fract()has great precision on float!\n#define fl(a) su(a,fr(a))\n//---Param2AD are trickier: https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mo()mx()mi()ma()\n//AD_mo() ideally should be replaced by fr(),but that adds 1dvd()and 1mu(),BUT DA_mo(a,b) outperforms mu(fr(di(a,b)),b),via [reciprocal product rule]\n#define moD(h,i)h mo(h a,i b){return h(mo(a.a,b  ),fr(a.b));}\n#define moE(h,i)h mo(h a,i b){return h(mo(a.a,b.a),fr(a.b));}\n#define moF(h,i)h(w11,i)h(w12,i)h(w13,i)h(w14,i)\nmoF(moD,vec1)moF(moE,w11)\n#define miG(r,h,j) r mo(h a,r b){return r(mod(a.a,b.a),j(0));}\nmiG(w14,w13,vec4)miG(w14,w12,vec4)miG(w14,w11,vec4)miG(w13,w11,vec3)miG(w13,w12,vec3)\nw13 mo(vec1 a,w13 b){return w13(mod(a,b.a),vec3(0));}\nw12 mo(vec1 a,w12 b){return w12(mod(a,b.a),vec2(0));}\nw11 mo(vec1 a,w11 b){return w11(mod(a,b.a),0.);}\n//substraction is simple,because \"differentiation is integration\"; https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for; https://en.wikipedia.org/wiki/Translation_(geometry)\n//BUT if we substract a struct da from a vec1 or w11,we must negate the .b part.\n//i possibly messed this one up by not flipping the .a part,but i an not sure there.\n#define suNN(h,i,j)h su(i a,j b){return h(su(a.a,b.a),a.b);}h su(j a,i b){return h(su(a.a,b.a),-b.b);}\nsuNN(w12,w12,w11)suNN(w13,w13,w11)suNN(w13,w13,w12)//the leftmost param equals the larger param of the other 2 params\nsuNN(w14,w14,w11)suNN(w14,w14,w12)suNN(w14,w14,w13)//..the rightmost param is always smaller than the middle param\n#define suNM(t)t su(t a,vec1 b){return t(su(a.a,b),a.b);}t su(vec1 a,t b){return t(su(a,b.a),-b.b);}\n#define suMM(t)suNM(t)t su(t a,t b){return t(su(a.a,b.a),su(a.b,b.b));}\nsuMM(w11)suMM(w12)suMM(w13)suMM(w14)\n//in the end mix() has an identity,and that identity does translate into DA:\n#define mixd(a,b,c) ad(mu(c,su(a,b),a)\n//a big issue of this is that mixd() and mind() where defined as MAT-functions,vut using the AD-labeling\n//so is just deleted that junk code\n//I define mind()and=maxd(-,-)instead of maxd()and=mind(-,-)\n//because min()is far more common than max(),for z-buffering.\n//negation identity:max(a,b)--min(-a,-b),requires struct negation\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n//AD_mu simplifies contextually ,scalar multiplication is tautological product_rule.\n#define adM2(h) h mu(h a,vec1 b){return h(mu(a.a,b),mu(a.b,b));}\n#define adM1(h) adM2(h)h mu(vec1 a,h b){return mu(b,a);}\n#define atta(h,i,j) h mu(i a,j b){return h(mu(a.a,b.a),ad(mu(a.b,b.a),mu(a.a,b.b)));}\n#define attA(h) atta(h,h,w11)atta(h,h,h)atta(h,w11,h)\nadM1(w11)adM1(w12)adM1(w13)adM1(w14)\natta(w11,w11,w11)attA(w12)attA(w13)attA(w14)//oh i really like this attA()-way of folding it\nDAm2 mu(DAm2 p,vec3 s){return DAm2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nDAm1 mu(DAm1 p,vec2 s){return DAm1(mu(p.x,s.x),mu(p.y,s.y));}\nDAm0 mu(DAm0 p,vec1 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define rXX(h) h di(h a,vec1 b){return h(di(a.a,b),di(a.b,b));}h di(vec1 a,h b){return h(di(a,b.a),di((mu(ne(a),b.b)),mu(b.a,b.a)));}\nrXX(w11)rXX(w12)rXX(w13)rXX(w14)\n//inverse scalar multiplication is a tautolotgy.\n//some of these may be nonsensical\n#define rXY(h,i,j) i di(h a,i b){return i(di(a.a,b.a),di((mu(ne(a.a),b.b)),(b.a*b.a)));}i di(i a,j b){return i(di(a.a,b.a),di((su(mu(a.b,b.a),mu(a.a,b.b))),(mu(b.a,b.a))));}\nrXY(w13,w12,w11)\nrXY(w11,w13,w13)\nrXY(w12,w13,w11)\nrXY(w11,w14,w14)//just guessing this line\nrXY(w12,w14,w11)//just guessing this line\n//All exponential functions utilize their Base_E_identity:...which is still not efficient,but comes down to O(exp(n*log(n)))\n//pow (x,y)-=exp(log(x)*y)//baseE exponential and logarythmic functions.\n#define po(x,y)ex(mu(ln(x),x))\n/*\n//It gets trickier with functions that take 3 parameters:,applying the\n//https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem)with first derivatives.\n#define v0q vec1 q=length(vec2(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nw11 le(w11 x,w11 y){v0q;return w11(ll2\nw12 le(w12 x,w12 y){v0q;return w12(ll2\nw13 le(w13 x,w13 y){v0q;return w13(ll2\nw13 lengthw13(DAm2 u){return le(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters.below is 3d length.\nw13 le(w13 x,w13 y,w13 z){float q=length(vec3(x.a,y.a,z.a));return w13(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nw13 le(DAm2 u){return le(u.x,u.y,u.z);}//3*3domain\n//the utility of a length()function is clear.*/\n//su(ab(p),s)equals a translation away from the origin by [s] AND mirroring at origin,via abs()\n//...so it it clamps a an implicit surface to a limited \"thickness\" (in 3 domains),also translating its first derivatives.\nw12 suab(w12 p,vec1 s){return su(ab(p),s);}\nw11 suab(w11 p,vec1 s){return su(ab(p),s);}\nw13 suab(w13 p,vec1 s){return su(ab(p),s);}\nDAm2 suab(DAm2 p,vec3 s){return DAm2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nDAm1 suab(DAm1 p,vec2 s){return DAm1(suab(p.x,s.x),suab(p.y,s.y));}\nDAm0 suab(DAm0 p,vec1 s){return DAm0(suab(p.x,s));}\n\n\n//spheretracker /ePr is referenced by bicapsule() and other unsigned distances\n//ideally only a 4d marcher is defined,with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\nconst float iterRm=256.;\nconst float eRm=.00001;\nconst float zFar=20000.;\nfloat df(vec3 p);\nvec3 dNormal(vec3 p){const vec2 e=vec2(.005,0);return norma(vec3\n (df(p+e.xyy)-df(p-e.xyy)\n ,df(p+e.yxy)-df(p-e.yxy)\n ,df(p+e.yyx)-df(p-e.yyx)));}\n \nvec4 trace(v33 a\n){float t=0.\n ;for(float i=0.;i<iterRm;++i\n ){float d=df(a.a)\n  ;if(d<eRm)return vec4(a.a,i);\n  ;if(t>zFar)return vec4(0)\n  ;a.a+=d*a.b*.5//this marther has its first step overstep way too often,doubling lipschitz evades this(poorly)\n  ;t+=d;}return vec4(a.a,iterRm);}\nvec4 trace(vec3 a,vec3 b){return trace(v33(a,b));}//legacy compatible\n\n\n\n\n//\"crossproduct\" and \"determinant\" are related,cross() is the bilin()* of a lin()_determinant()\n//therefore i can fold the detemrinant() mnamespace onto the cross() namespace.\n//a cross() has 2 inpouts,where a determinant() has 1 input\n//we generalize \"crossproduct\" into its ternary: \"find the only vector that in a 90deg angle to all inputs\"\nvec2 cr(vec2 a){return a.yx*vec2(-1,1);}//rotBy4\nvec3 cr(vec3 a,vec3 b){return cross(a,b);}\n//vec4 cr(vec4 a,vec4 b,vec4 c){\n//solve LinearEquation for   dot(a,d)=0;dot(b,d)=0;dot(c,d)=0;with additional constrains to length(d)==1\n//}\n//[a bilinear (2 input vectors) product with a vector result only exists in 3d and 7d,in 7f it has more than 2 results (handedness,signs)\n//7d_dotproduct() is the octonion_pairing to 3d_quaternion.\nfloat det2d(vec2 a,vec2 b){return dot(a,cr(b));}//a.x*b.y-a.y*b.x//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct perpdot dotperp\n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos,p.zy),perm2(u5cos,p.zx),perm2(u5cos,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//noronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 su(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 mu(float a,v33 b){return v33(a*b.a,a*b.b);}\nmat3 su(mat3 a,mat3 b){return a-b;}\nmat3 addf(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n\n//fast cellular noise,optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares,1 is maximum jitter. (known bug,iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend,is ideally 1/7,but others can be fine too.use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime.\n//the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1,.y is L2 according to [worley noise]\n//this uses a lot of mat2,or the v33 struct,and permute()functions similar to ahsima-simplex noise,defers the sorting,for performance.\n//Cellular noise (\"Worley noise\")in 3D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license.\n//See LICENSE file for details.\n//https://github.com/stegu/webgl-noise\n#define mous (iResolution.xyxy-iMouse.xyzw)//flip mouse everywhere,for shadertoy fun\nmat3 fr(mat3 a){return mat3(fr(a[0]),fr(a[1]),fr(a[2]));}\n//mat3 fl(mat3 a){return mat3(fl(a[0]),fl(a[1]),fl(a[2]));}\nmat3 addd(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n//th7 is for the 2d noise,should be (iResolution.y/7.),BUT i managed to make other values look fine,too\n#define th7 (mous.y/iResolution.y)//usually==1./7.,because mod(a,7)is famous for old LCGs.\n//th8 is for the 3d noise,should be (iResolution.y/7.),other values may work,but they tend to barely work at all,try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))//seems to be fine bounds,not too sure.\nvec3 mod2893d(vec3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}//Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n//Permutation polynomial:(34x^2+x)mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n#define Kcel 1./th8//1/7\n#define Kcel2 1./th8/th8//1/(7*7)\n#define Kcelo (1.-Kcel)*.5//1/2-Kcel/2\n#define Kcelz 1./(th8-1.)//1/6\n#define Kcelzo .5-2./(th8-1.)//0.416666666667//1/2-1/6*2\n#define jitter mous.x/iResolution.x//smaller jitter gives more regular pattern\nmat3 perM3(vec3 p){return mat3(permute3d(p-1.),permute3d(p),permute3d(p+1.));}\nmat3 perM3(vec3 p,vec3 b){vec3 p1=permute3d(p+b.x-1.);vec3 p2=permute3d(p+b.y);vec3 p3=permute3d(p+b.z+1.);return mat3(p1,p2,p3);}\n#define maa(a,b,c) ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a)a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c)mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n//todo,make it traversable bny getting distance2Border.\nvec2 cellular(vec3 P,float m//not to be confuced with a voronoi3d,but can look similar.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=addf(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perM3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perM3(pp[0]+p.z)\n ;mat3 p2=perM3(pp[1]+p.z)\n ;mat3 p3=perM3(pp[2]+p.z)\n ;mat3 ox=fr(p1*Kcel)-Kcelo\n ;mat3 ox2=fr(p2*Kcel)-Kcelo\n ;mat3 ox3=fr(p3*Kcel)-Kcelo \n ;mat3 oz=fl(p1*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz2=fl(p2*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz3=fl(p3*Kcel2)*Kcelz-Kcelzo \n ;mat3 oy=mod73d(fl(p1*Kcel))*Kcel-Kcelo\n ;mat3 oyy=mod73d(fl(p2*Kcel))*Kcel-Kcelo\n ;mat3 oy3=mod73d(fl(p3*Kcel))*Kcel-Kcelo\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=addf(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=addf(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n ;mat3 a\n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared==is dot(r,r)\n //Sort out the two smallest distances (F1,F2)\n #if 0\n ;vec3 d1=min(min(d11,d12),d13) //sort out only F1\n ;vec3 d2=min(min(d21,d22),d23)\n ;vec3 d3=min(min(d31,d32),d33)\n ;vec3 d=min(min(d1,d2),d3)//shortest of 9 distances,except its 9*vec3()\n ;d.x=min(min(d.x,d.y),d.z)\n ;return vec2(sqrt(d.x));}//F1 F1\n #else\n ;vec3 d1a=min(d11,d12)//sort out F1 and F2\n ;d12=max(d11,d12)\n ;d11=min(d1a,d13)//Smallest now not in d12 or d13\n ;d13=max(d1a,d13)\n ;d12=min(d12,d13)//2nd smallest now not in d13\n ;vec3 d2a=min(d21,d22)\n ;d22=max(d21,d22)\n ;d21=min(d2a,d23)//Smallest now not in d22 or d23\n ;d23=max(d2a,d23)\n ;d22=min(d22,d23)//2nd smallest now not in d23\n ;vec3 d3a=min(d31,d32)\n ;d32=max(d31,d32)\n ;d31=min(d3a,d33)//Smallest now not in d32 or d33\n ;d33=max(d3a,d33)\n ;d32=min(d32,d33)//2nd smallest now not in d33\n ;vec3 da=min(d11,d21)\n ;d21=max(d11,d21)\n ;d11=min(da,d31)//Smallest now in d11\n ;d31=max(da,d31)//2nd smallest now not in d31\n ;d11.xy=(d11.x<d11.y)?d11.xy:d11.yx\n ;d11.xz=(d11.x<d11.z)?d11.xz:d11.zx//d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy)//nor in d12.yz\n ;d11.y=min(d11.y,d12.z)//Only two more to go\n ;d11.y=min(d11.y,d11.z)//Done! (Phew!)\n ;return sqrt(d11.xy);}//F1,F2\n#endif\n//crunched by ollj\n//Cellular noise (\"Worley noise\")in 2D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license of://https://github.com/stegu/webgl-noise\n//mod(a,289.)without a division (only multiplications),because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}//Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}//Permutation polynomial:(34x^2+x)mod 289\n#define tt3(p,f,j,m,a)square(su(j,su(v33(vec3(a),f),mu(m,mu(m,modth7(ff(p*th7)))))))\n#define permi(c)p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c)r[d]=tt3(p,f,k.a,m,e);permi(c)\n//Cellular noise,returning F1 and F2 in a vec2//3x3-hood reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity)m=1./7.,by sqiveling this parameter,you get+0.7 domain very cheaply\n//as in by making m a 3rd parameter,you ALMMOST get cheap cellular3d noise,BUT it is likely a bit flawed,more repetitive,shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop.the permute()function marks+1 iteration/tap//is 4tap voronoi in O(3)\n){v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1),f=o+.5,px=permute(o+k.b.x),permi(x)\n ;mat3 r\n ;ppm(0,-.5,y)//it seems that the loop got unrolled and al lits min()fucntions fold into the below\n ;ppm(1,+.5,z)//...//which is quite a lot of symmetry folding,surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line ,because r[0].y is a return value.\n ;r[0].y=min(mi(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n//simplex noise3d (simplex noise is worth it for higher dimensions)\n//Original:https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute(vec4 x){return mod(x*x*34.+x,289.);}\nfloat simplex1(vec3 v//ashima simplex3d,early optimizations by @makio64,structure by @ollj  https://www.shadertoy.com/view/Xd3GRf\n){const vec2 C=1./vec2(6,3);const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy)),x0=v-i+dot(i,C.xxx),g=step(x0.yzx,x0.xyz),l=1.-g//is a sequence of 4,no parallelization\n ;v33 f=v33(min(g.xyz,l.zxy),max(g.xyz,l.zxy));v3333 d=g3333(x0,su(x0,g333(su(f,g33(C)),D.yyy)))\n ;i=mod(i,289.);v222 F=g222(f);vec3 ns=.142857142857*D.wyz-D.xzx\n ;vec4 p=permute(permute(permute(i.z+vec4(0,F.c,1))+i.y+vec4(0,F.b,1))+i.x+vec4(0,F.a,1)),j=p-49.*floor(p*ns.z*ns.z),k=floor(j*ns.z)\n ;v44 t=ad(mu(v44(k,floor(j-7.*k)),ns.x),ns.y)\n ;vec4 h=1.-abs(t.a)-abs(t.b),a=-step(h,vec4(0))\n ;v44 b=v44(vec4(t.a.xy,t.b.xy),vec4(t.a.zw,t.b.zw))\n ;b=ad(v44(b.a.xzyw,b.b.xzyw),mu(v44(a.xxyy,a.zzww),ad(mu(fl(v44(b.a.xzyw,b.b.xzyw)),2.),1.)))\n ;v3333 q=v3333(vec3(b.a.xy,h.x),vec3(b.a.zw,h.y),vec3(b.b.xy,h.z),vec3(b.b.zw,h.w))\n ;q=muv(q,inversesqrt(ddv(q)));vec4 m=max(.6-ddv(d),0.)\n ;return .5+12.*dot(m*m*m,vec4(dot(q.a,d.a),dot(q.b,d.b),dot(q.c,d.c),dot(q.d,d.d)));}\n\n//fbm of dr2 noise (with multitap normals),is a bit crude,in favor for fast normals.\n#define fBm(a) vec2 b=vec2(0,1);for(int i=0;i<a;i++){b=vec2(b.x,0)+vec2(noise1(p),.5)*b.y;p*=2.;}return b.x/(2.-b.y);}\nvec1 fbm(vec1 p){fBm(5)vec1 fbm(vec2 p){fBm(5)vec1 fbm(vec3 p){fBm(5)vec1 fbms(vec3 p){fBm(3)\nvec1 fbmn(vec3 p,vec3 n){vec4 r=vec4(0,0,0,1);for(int i=0;i<4;i++\n){r=vec4(r.xyz,0)+r.w*vec4(vec3(noise1(p.yz),noise1(p.zx),noise1(p.xy)),.5);p*=2.;}return dot(r.xyz,abs(n));}\nvec3 VaryNf(vec3 p,vec3 n,vec1 f\n){vec2 e=vec2(.1,0);vec3 g=vec3(fbmn(p+e.xyy,n),fbmn(p+e.yxy,n),fbmn(p+e.yyx,n))-fbmn(p,n)\n ;return norma(n+f*(g-n*dot(n,g)));}\nfloat fbma(vec3 p//fbm of ashima simplex (no normals,duh)\n){float f\n ;f=.5*(simplex1(p));p=p*2.01\n ;f+=.25*(simplex1(p));p=p*2.02\n ;f+=.125*(simplex1(p));p=p*2.03\n ;f+=.0625*(simplex1(p));p=p*2.04\n ;f+=.03125*(simplex1(p));return f;}\n\n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\nfrflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)frflpm(v44,c44)\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\nfloat Blob(vec3 p){p=ab(p);p=mx(p,p.yzx,st(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-a)))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a))//i am not convinced by this one\n#define box(a,b) roundit(abm(a,b))\nfloat fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define segment2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,segment()sub ,is squared distance\n#define segment(a,b,c) sq(segment2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n#define segmentY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u,vec4 m){\n//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x);//calculate dorated differential\n return dot(u-m.xy,(f));//signed distance to line \n//more generally,f should be normalized here for proper caling.\n//but scaling is irrelevant as we only care fror the sign \n}\n#define  rac mix(.5,3.,sin(iTime)*.5+.5)\n//earvageg is still far from standardized. rac is the central radius, should be parametric.\nfloat EarVagEgg(vec2 u,vec2 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (sd2l(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(sd2l(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\nfloat CylEarVagEgg(vec3 u,vec2 m,float h\n){float a=abs(EarVagEgg(u.xy,m))-.01\n ;a=abs(a-.05)-.02\n ;float b=abs(u.z)-h\n ;return ma(b,a);}\n#define tiny .000001\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\nfloat debugHg2(vec3 u){\n ;float r=0.\n ;float t=cos(iTime)*.4+.5\n ;//r=box(u,vec3(1))-t\n ;//r=length(u-bicapsule3(u,vec3(-.5,0,2),vec3(.5,0,2),.7,.2))-.1;\n ;r=CylEarVagEgg(u*.5,.5*iMouse.xy/iResolution.xy,.2)\n //bicapsule(u,vec3(1,0,0),vec3(0,0,1),.5,2.)\n ;//r=Blob(u)\n ;//r=fPlane(abs(u),vec3(1,1,1),-1.5)//the raymarcher is not ideal for this one,with its alpha fadeout.\n ;//r=boxf(u,vec3(1))-.5\n ;//r=corner(u.xy)\n ;//r=cylinder(u,1.,1.)\n ;//failed to make a rounded cylinder via roundit()\n ;//r=segment(u,vec3(0),vec3(1,2,3))-t\n ;//r=segmentY(u,vec2(1,2))//could not get it to work instantly\n ;//r=torus(u,1.)-1.\n ;//r=disc(u,vec2(1.))-2.//could not get it to work instantly\n ;//r=hexCircum(u,1.)-1.\n ;//r=fCone(u,1.,2.)\n ;return r;}\n//2-distance input unions\n//note,for higher dimensions,i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances,b is a radius //todo,compare with mima()\n#define miRound(a,b) mi(ma0(a),-b)+le(ma0(b+a))//is likely wrong\n#define maRound(a,b) -fOpRoundMin(-a,b)//is likely wrong\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}//is likely wrong\n/*\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat micolumns _M(1.)\n ;p.x+=sqrt(.5)*-r+c*sqrt(2.)\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b)\n ;}\n\nfloat macolumns _M(-1.)\n p.y+=c;p.x=sqrt(.5)*(r+c)/p.x\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=-mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b);}//fails on its own\n#define mecolumns(a,b,r,n) -macolumns(a,-b,r,n)/**/\n\n\nmat2 r2(float a){vec2 b=cs(a);return mat2(b.x,b.y,-b.y,b.x);}\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return mi(mi(a,b),.5*(u+a+abs(mo(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\nvec2 debugHg(vec3 u){\n ;return vec2(debugHg2(u),1)\n ;float r=0.\n ;u.z-=1.\n ;float t=cos(iTime)*.4+.5\n ;float a=box(u   ,vec3(1))-t\n ;//u.xy*=r2(1.)\n ;float b=box(u-1.,vec3(1))-.2\n ;//return mi(a,b)\n ;//return ma(a,b)\n ;//return ma(a,-b)\n ;//return miChamfer(a,b,0.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return miChamfer(a,b,3.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return maChamfer(a,b,.5)//not sure if broken or tracer issue\n ;//return meChamfer(a,b,.5)\n ;//return chamfer180(a,b,.5)//round chamfer is best\n ;//return -chamfer180(-a,-b,.5)//max() round chamfer is weird but fun\n ;//return -chamfer180(-a,b,.23)//max(a,-b) round chamfer easily gets discotinuous\n ;//return chamfer180(a,b,3.5)//overchamfering round is bumpy\n ;//return miRound(a,b)//todo fixme\n ;//return mistairs(a,b,.5,13.)\n ;//return mistairs(a,b,.5,13.)\n ;//return mestairs(a,b,.5,13.)\n ;a=micolumns(a,b,.5,4.)\n ;//return mecolumns(a,b,.5,4.)\n ;//return mucolumns(a,b,.5,4.) \n ;//return macolumns(a,b,.5,4.)//macolumns fails\n ;//return mecolumns(a,b,.5,4.)\n ;//return pipe(a,b,.2)\n ;//return engrave(a,b,.5)\n ;//return -groove(-a,b,.5,.1)\n ;//return tongue(a,b,.5,.1)\n ;return vec2(a,1);}\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5cos(2.*pi*ab012(a,b));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below,but close\nvec3 hsv2rgb(const vec3 c){return c.z*mx(1.,sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n\n\n\n\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\nstruct v21{vec2 a;vec1 b;};//currently only for alpha compositing plans\nstruct v31{vec3 a;vec1 b;};//...for MAT arithmetic\nstruct v41{vec4 a;vec1 b;};\nv21 su(v21 a,v21 b){return v21(a.a-b.a,a.b-b.b);}\nv21 mu(v21 a,v21 b){return v21(a.a*b.a,a.b*b.b);}\nv21 mu(v21 a,vec1 b){return v21(a.a*b,a.b*b);}\nv31 su(v31 a,v31 b){return v31(a.a-b.a,a.b-b.b);}\nv31 mu(v31 a,v31 b){return v31(a.a*b.a,a.b*b.b);}\nv31 mu(v31 a,vec1 b){return v31(a.a*b,a.b*b);}\nv41 su(v41 a,v41 b){return v41(a.a-b.a,a.b-b.b);}\nv41 mu(v41 a,v41 b){return v41(a.a*b.a,a.b*b.b);}\nv41 mu(v41 a,vec1 b){return v41(a.a*b,a.b*b);}\n//generalizing alpha-compositing functions,named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent,.W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes],this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions,that return a or b,for simplicity\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n\n\n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\nw11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nvec4 demoSmin(vec2 u,vec2 m,vec2 n//smin (exponential and polinomial) , with automativDifferenciation\n){w11 a=w11(u.x-m.x*9.,1.)\n ;w11 b=w11(u.x-m.x*9.,1.)\n ;m.x=abs(m.x)+.2//optional evasion of very short wavelength\n ;vec4 c=vec4(0)\n ;float amp=1.//m.y\n ;a=   mu(co(di(a,di(m.x,mu(pi,.5)))),amp)//a.b is analytic first derivative of a.a\n ;b=ad(mu(si(di(b,di(m.x,mu(pi,.5)))),amp),mu(si(b),.3))//b.b is analytic first derivative of b.a\n ;a=su(co(mu(a,2.)),mu(a,.2))\n ;b=su(si(mu(b,2.)),mu(b,.561))\n ;w11 d=mae(a,b,1./m.y)\n ;w11 e=mae(a,b,1./m.y)\n ;w11 f=mas(a,b,3.*m.y)\n ;c.y=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.x=abs(b.a-u.y)/sqrt(1.+b.b*b.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.z=abs(d.a-u.y)/sqrt(1.+d.b*d.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.w=abs(f.a-u.y)/sqrt(1.+f.b*f.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;//c=abs(c-.2)-.1//optional shows how this is NOT distance2Sin()\n ;c=abs(c-aaa*2.)-aaa*.5//optional double line\n ;c=smoothstep(aaa,-aaa,c)\n ;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n ;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec4 y=vec4(angleToColor(vec3(rainb.y,1,1)),c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(angleToColor(vec3(rainb.z,1,1)),c.z)//coordinate system in magenta/pink\n ;vec4 w=vec4(angleToColor(vec3(rainb.w,1,1)),c.w)//coordinate system in magenta/pink\n ;x.xyz*=x.w;y.xyz*=y.w;z.xyz*=z.w;w.xyz*=w.w//alpha premultiplied\n ;x=pdOver(y,x)\n ;x=pdOver(z,x)\n ;x=pdOver(w,x)\n ;return x;}\n\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n\n\n\n\n\n\n\n// \"Generalized Distance Functions\" by Akleman and Chen ,often included in hg_sdf\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 norma(vec3(1,1,1))\n#define GDFVector4 norma(vec3(-1,1,1))\n#define GDFVector5 norma(vec3(1,-1,1))\n#define GDFVector6 norma(vec3(1,1,-1))\n#define GDFVector7 norma(vec3(0,1,PHI+1.))\n#define GDFVector8 norma(vec3(0,-1,PHI+1.))\n#define GDFVector9 norma(vec3(PHI+1.,0,1))\n#define GDFVector10 norma(vec3(-PHI-1.,0,1))\n#define GDFVector11 norma(vec3(1,PHI+1.,0))\n#define GDFVector12 norma(vec3(-1,PHI+1.,0))\n#define GDFVector13 norma(vec3(0,PHI,1))\n#define GDFVector14 norma(vec3(0,-PHI,1))\n#define GDFVector15 norma(vec3(1,0,PHI))\n#define GDFVector16 norma(vec3(-1,0,PHI))\n#define GDFVector17 norma(vec3(PHI,1,0))\n#define GDFVector18 norma(vec3(-PHI,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d+=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) \n fGDFExp(GDFVector4) \n fGDFExp(GDFVector5) \n fGDFExp(GDFVector6)\n fGDFExpEnd}\n \n/*\nfloat fDodecahedron(vec3 p,float r,float e){\n fGDFBegin\n ;d+=pow(abs(dot(p,norma(vec3(0,PHI,1)))),e);\n //fGDFExp(GDFVector13)\n fGDFExp(GDFVector14)\n fGDFExp(GDFVector15)\n fGDFExp(GDFVector16)\n fGDFExp(GDFVector17)\n fGDFExp(GDFVector18)\n fGDFExpEnd}\n /*\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\n\n*/\n\n\n\n//someone overthought checkerboard patterns\n//float xnor(float x,float y){return abs(x+y-1.);}// abs(0+0-1)-1 abs(1+0-1)-0 abs(0+1-1)-0 abs(1+1-1)-1\n//xnor(xnor(e.x,e.y),e.z)//checkerboard3d\n\n\n\n\n\n\n\n\n\n\n\n\n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv33 cam(vec2 u\n){\n  ;vec4 mouse=  iMouseZwFix(iMouse,true)\n ;float camOrbit=5.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=-.03*(mouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*iTime)//autopilot\n ;m=mx(n,m,step(0.,mouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v33(pos,dir);}\n\n\n\n//Phong+debugPlanes\n//\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n#define tracePlane(po,pd,o,d) dot(po-(o),pd)/dot(d,pd)\n//traceR if(t<0) return -1; return t;\n#define traceR(t) mix(-1.,t,step(t,0.))\n#define raytrace_plane(po,pd,o,d) traceR(tracePlane2(po,pd,o,d))\nvec1 planeDebug2(vec3 o,vec3 d,float c,inout float t,vec2 n,const int f//ray,ray,curPlane,time,domainLengths\n){if(n.x<c&&n.y>0.//debug plane //n.x=o.y n.y=d.y\n ){vec3 a=(mat3(1)*c)[1]\n //above line needs gl1.0 0:1318: '[]' : Index expression must be constant//\n  ;float p=tracePlane(a,a*t,o,d)\n  //;if(abs(p)<9.){\n   ;p=df(o+d*p)\n   ;float q=fract(p*8.)/(p*p*p*p+4.)\n   ;p=mix(q,mix(.3,.7,q),step(p,0.))\n   ;return p\n   ;}//}\n ;return 0.;}\n//x can be y,beware that z may be hidden from some cameras,need to rotate camera asound.\n//d is linked to e; e=x f=0 ; e=y f=1 ; e=z f=2 (; e=w f=3)\n#define planeDebug(a,b,c,d,e,f) planeDebug2(a,b,c,d,vec2(a.e,b.e),f)\n\nvec4 DebugPlanes(vec3 o,vec3 d,float t\n){float c0=sin(iTime*.5)*2.\n ;vec4 a=planeDebug(o,d,c0,t,x,0)*vec4(0,1,.5,1)\n ;vec4 b=planeDebug(o,d,c0,t,y,1)*vec4(.5,0,1,1)\n ;vec4 c=planeDebug(o,d,c0,t,z,2)*vec4(1,.5,0,1)\n ;return sat((a+b+c)*2.);}\nvec3 tex(vec3 u//textureid is 2 integers, .x one sets hue, .y sets saturation.\n){return cellular(u*5.,iTime).xyx\n //;return fract(u*4.+cos(iTime))\n ;}\n\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n \n//these likely have simpler expressions,its too late timeofday for me to bother now.\nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n\n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(iTime*.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1])\n ;y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(ma(dt(p,y))-o.x*3.,sq(mi(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\nvec3 dfPoly(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 pol=vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;return pol;}\n\n\nfloat df(vec3 p){\n#if 0\n ;p.xz=-p.xz;\n ;vec2 q=pModMirror2(p.xz,vec2(4.5))//repetition\n#endif\n ;//return dfPoly(p).x//array of 16 different spheroid\n ;return debugHg(p).x//hg_sdf debug playgound\n //;float dodec=fDodecahedron(p-vec3(-9,2,-4)/4.,.7)//i like how this is placed n the mirroring plane\n ;float b=fBox(p-vec3(0,-.1,0),vec3(1))\n ;float s=length(p-vec3(1.+sin(iTime*.25)*.2,.8,1))-1.//sphere\n ;s=min(b,s)\n //;return s;\n ;float d=mistairs(b,s,.7,4.)\n ;p.xz*=r1(iTime*.041);p.zy*=r1(iTime*.021)//lazy small rotation\n ;vec2 n=cellular(p*5.61,1./7.)\n ;//d-=(n.y-n.x)*.05//too much foreach march iteration.\n ;return d;}\n //;return min(d,dodec);}\n\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal(u.xyz)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=dfPoly(u.xyz).yz//surfaceID is distanceField specific\n ;tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(0,.1,.3),vec3(1,1,.9),diffuse)*surf+spec*vec3(1,1,.9)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n\n\n\n\nvec4 demo2NoiseCel(vec2 u,vec2 m\n){vec3 o=vec3(u*6.,cos(iTime)*4.)\n ;o.xz*=r1(iTime*.041);o.zy*=r1(iTime*.021)//lazy small rotation\n ;return vec4(cellular(o,iTime*.161),0,1);}\n\nvec4 demoHg3d(vec2 u\n){vec3 lir=norma(vec3(.5,1.0,-.25))\n ;v33 ray=cam(u)\n ;//v12 dt=trace(ray.a,ray.b)//td.a is distanceToCamera dt.b is a 2d textureId\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return c;}\n\nvec4 demoAd2d(vec2 u,vec2 m//deomes 1d automatic differentiation\n){vec3 c=vec3(0)\n ;w11 a=w11(u.x*9.,1.)\n ;a=w11(u.x,1.)\n ;a=si(ex((a)))//a.b is analytic first derivative of a.a\n //;a=(si(fr(a)))\n ;c.x=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float o=c.x\n ;c.y=a.b\n ;c.yz-=u.y\n ;c.yz=abs(c.yz)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;c=smoothstep(aaa,-aaa,c-aaa)\n ;if(abs(a.b)<aaa*50.)c.z=max(c.z,pow(1.-abs(a.b)*2.,4.))//mark local extrema with vertical lines (better line width would need 2nd derivative)\n ;c=c.zyx//;c=mix(c,c.yzx,iMouse.x/iResolution.x)*2.#\n ;vec4 x=vec4(0  ,c.x,c.x,c.x)//first derivative\n ;vec4 y=vec4(c.y,0  ,c.y,c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(c.z,c.z,0  ,c.z)//coordinate system in magenta/pink\n ;x=pdOver(y,x)//2 graphs,one is 1st derivative  in cyan/blue\n ;x=pdOver(z,x)//add coordinate system that highlights loccal extrema\n ;return x;}\n\nvec4 demo2d1(vec2 u,vec2 m,vec2 n\n){vec4 c=vec4(0)\n ;c.x=dd(m-u);c.y=dd(n-u);c.w=dd(mix(n,m,abs(cos(iTime*2.)))-u)//abs(cos())bounce fopr direction\n ;c.xyw=sqrt(c.xyw)\n ;u=abs(u)\n ;c.z=ma(u)\n ;float thick=.005,diam=.1\n ;c=smoothstep(.01,-.01,abs(abs(c-diam)-diam+thick)-thick)//i know theres better ways to do this abs(abs())identities...\n ;c.xy+=c.w;return vec4(c.xyz,ma(c.xyz))\n ;vec4 a=pdOver(vec4(0,c.y,0,c.y),vec4(c.x,0,0,c.x))//green over red\n ;c     =pdOver(vec4(c.w,c.w,0,c.w),vec4(0,0,c.z,c.z))//yellow over blue\n ;c     =pdOver(a,c)//green over red over yellow over blue\n ;return c;}\n\nvec3 ss(float a,vec3 b){return smoothstep(a,-a,b);}\n\nvec4 pd(vec2 u\n){vec2 m=fra(iMouse.xy)\n ;if(iMouse.z<.0)m=-vec2(.5)//while(mouse up)simulate mouse down.\n ;vec2 s=-vec2(1.,sin(iTime))//vector moves over time.\n ;vec3 e=vec3(dd(u)\n ,dd(u-m)\n ,dd(u-s))//eucliden distance projection.\n ;e=sqrt(e)//delayed square root\n ;e-=.5//circle radius\n ;e=abs(e)-.2;//turn cirlce into ring\n ;float SSAA=(cos(iTime)+1.25)*12./min(iResolution.x,iResolution.y);//screen-space-anti-aliasing\n ;e=ss(SSAA,e)\n ;e=sat(e)\n ;vec3 g=vec3(.96,.25,.05)//color ramp equals cheap colorblind mode.\n ;vec4 c0=vec4(g,e.x)\n ;vec4 c1=vec4(g.yzx,e.y)\n ;vec4 c2=vec4(g.zxy,e.z)//some colors with e.rgb as alpha channel.\n ;c0.rgb*=c0.w//general form scales .rgb by alpha,\n ;c1.rgb*=c1.w//...this acoids some division by 0 cases\n ;c2.rgb*=c2.w\n ;vec4 O=pdOver(c0,c1);O=pdOver(O,c2)\n ;//O=sXor(c0,c1);O=sXor(O,c2)\n ;//O=sAtop(c0,c1);O=sAtop(O,c2)\n ;vec4 bg=vec4(vec3((checkerBool2(u))),u.y)\n //;bg.rgb=pow(bg.rgb,vec3(2.2))\n ;if(O.w!=0.)O.rgb/=O.w\n ;O=pdOver(O,bg);\n ;O.rgb=pow(O.rgb,vec3(1./2.2))/**/\n ;return O;}\n\nvoid mainImage(out vec4 O,vec2 u\n){u=fra(u)\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 m=fra(mouse.xy)\n ;vec2 n=fra(mouse.zw)\n ;O=vec4(0)\n ;O=pdOver(O,demo2d1(u,m,n))//mouseCoords\n ;//O=pdOver(O,demoAd2d(u,m))//ad 1d\n ;O=pdOver(O,demoSmin(u,m,n))//ad 1d smin\n ;O=pdOver(O,demoHg3d(u/2.))//hg_sdf,u-scaling sets camera distance to center\n ;O=pdOver(O,demoComplex(u,m,n))\n ;//O=pdOver(O,demo2NoiseCel(u,m)*vec4(.3,.3,.3,1.))//celularNoise\n ;O=pdOver(O,vec4(vec3((checkerBoolT(u*1.61))*.5+.25),u.y))//checkerboard background\n ;}\n\n\n\n\n\n\n\n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dSegment(a,b,c) segment(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return segmentY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return segment(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 382], [3375, 3459, 3476, 3476, 3544], [3545, 3545, 3571, 3571, 3618], [3619, 3619, 3637, 3637, 3683], [4433, 4527, 4548, 4548, 4583], [4584, 4584, 4605, 4605, 4640], [4641, 4729, 4746, 4746, 4769], [4769, 4769, 4786, 4786, 4809], [4809, 4809, 4826, 4826, 4842], [5228, 5766, 5789, 5789, 5851], [5852, 5852, 5874, 5874, 5915], [5916, 5916, 5939, 5939, 5957], [5957, 6088, 6111, 6111, 6128], [6129, 6129, 6145, 6145, 6162], [6855, 6855, 6869, 6869, 6892], [6893, 6893, 6907, 6907, 6930], [6931, 6931, 6945, 6945, 6968], [8758, 9770, 9786, 9786, 9819], [9820, 9820, 9843, 9843, 9875], [9876, 9876, 9900, 9900, 9924], [9925, 9925, 9952, 9952, 9981], [9982, 9982, 9996, 9996, 10025], [10026, 10026, 10040, 10040, 10069], [10180, 10241, 10267, 10267, 10286], [10287, 10418, 10447, 10447, 10470], [10470, 10557, 10573, 10573, 10605], [10606, 10606, 10622, 10622, 10644], [10645, 10645, 10663, 10663, 10681], [10681, 11020, 11044, 11044, 11054], [11055, 11055, 11079, 11079, 11097], [11098, 11098, 11122, 11122, 11146], [11147, 11147, 11170, 11170, 11188], [11188, 11219, 11244, 11244, 11268], [11484, 11532, 11548, 11548, 11589], [11590, 11590, 11620, 11620, 11652], [11652, 11672, 11696, 11696, 11727], [11727, 11815, 11833, 11833, 11855], [11856, 11856, 11873, 11873, 11900], [11901, 11901, 11918, 11918, 11952], [11953, 11953, 11972, 11972, 12008], [12009, 12009, 12028, 12028, 12064], [12066, 12066, 12084, 12084, 12112], [12112, 12179, 12212, 12212, 12249], [12302, 12429, 12446, 12446, 12499], [12499, 12581, 12598, 12598, 12663], [12663, 12682, 12700, 12700, 12744], [12744, 12831, 12849, 12849, 12905], [12905, 12956, 12974, 12974, 13023], [13023, 13085, 13102, 13102, 13134], [13134, 13172, 13189, 13189, 13223], [13223, 13240, 13264, 13264, 13276], [13276, 13276, 13300, 13300, 13312], [13312, 13343, 13367, 13367, 13393], [13393, 13450, 13481, 13481, 13505], [13505, 13563, 13580, 13580, 13603], [13603, 13619, 13643, 13643, 13707], [13707, 13761, 13785, 13785, 13812], [13812, 13874, 13899, 13899, 13940], [13940, 14027, 14044, 14044, 14069], [14069, 14212, 14236, 14236, 14263], [14263, 14325, 14357, 14357, 14386], [14386, 14411, 14443, 14443, 14472], [14472, 14544, 14569, 14569, 14596], [14596, 14638, 14671, 14671, 14700], [14700, 14849, 14866, 14866, 14913], [14913, 15123, 15141, 15141, 15223], [15224, 15224, 15241, 15241, 15289], [15291, 15514, 15532, 15532, 15634], [15635, 15635, 15652, 15652, 15679], [15679, 15726, 15744, 15744, 15771], [15771, 15882, 15900, 15900, 15947], [15947, 16237, 16255, 16255, 16277], [16277, 16913, 16932, 16932, 16990], [16990, 17175, 17194, 17194, 17249], [17249, 17434, 17452, 17452, 17473], [17473, 17543, 17561, 17561, 17582], [17582, 17871, 17891, 17891, 17981], [17981, 18289, 18308, 18308, 18367], [18367, 18618, 18638, 18638, 18755], [18755, 19046, 19066, 19066, 19167], [19167, 19426, 19446, 19446, 19525], [19525, 19749, 19769, 19769, 19807], [19807, 19915, 19935, 19935, 19982], [19982, 20187, 20207, 20207, 20269], [20269, 20490, 20510, 20510, 20584], [20584, 20777, 20797, 20797, 20883], [21113, 21347, 21499, 21499, 22265], [22268, 23166, 23184, 23184, 23206], [23206, 23783, 23800, 23800, 23847], [23848, 23848, 23865, 23865, 23897], [23898, 23898, 23915, 23915, 23956], [23957, 23957, 23974, 23974, 24024], [24025, 24589, 25152, 25152, 25183], [25470, 25470, 25491, 25491, 25523], [25524, 25524, 25545, 25545, 25577], [25578, 25578, 25599, 25599, 25626], [25627, 26543, 27208, 27208, 27239], [27437, 27437, 27590, 27590, 27640], [27641, 27641, 27664, 27664, 27702], [27703, 27703, 27726, 27726, 27750], [27751, 27930, 28080, 28080, 28135], [28585, 29522, 29545, 29545, 29565], [29566, 29566, 29589, 29589, 29609], [29610, 29610, 29633, 29633, 29653], [29654, 29654, 29679, 29679, 29735], [29736, 29736, 29761, 29761, 29803], [29804, 29804, 29829, 29829, 29855], [29858, 30174, 30195, 30195, 30320], [30323, 30323, 30342, 30342, 30608], [30609, 30609, 30635, 30635, 30659], [30683, 31027, 31043, 31043, 31067], [31067, 31076, 31099, 31099, 31118], [31119, 31459, 31486, 31486, 31507], [31607, 31861, 31877, 31877, 31893], [31894, 31894, 31910, 31910, 31924], [31925, 31925, 31941, 31941, 31951], [31952, 31952, 31968, 31968, 31984], [31985, 31985, 32001, 32001, 32016], [32017, 32017, 32033, 32033, 32048], [32049, 32049, 32065, 32065, 32075], [33114, 33236, 33259, 33259, 33282], [33283, 33283, 33309, 33309, 33352], [33685, 33725, 33744, 33744, 33787], [33788, 33788, 33807, 33807, 33851], [33852, 33852, 33871, 33871, 33910], [33911, 33911, 33930, 33930, 34005], [34006, 34006, 34025, 34025, 34161], [34162, 34162, 34181, 34181, 34216], [34217, 34217, 34237, 34237, 34282], [34283, 34283, 34303, 34303, 34391], [34392, 34392, 34412, 34412, 34506], [34507, 34507, 34527, 34527, 34743], [34744, 34969, 34987, 34987, 35055], [35056, 35056, 35120, 35120, 35478], [35478, 35945, 35960, 35960, 35991], [35991, 36067, 36082, 36082, 36113], [36114, 36114, 36131, 36131, 36163], [36164, 36164, 36185, 36185, 36214], [36215, 36215, 36237, 36237, 36262], [36263, 36263, 36286, 36286, 36298], [36299, 36299, 36324, 36324, 36365], [36367, 37416, 37432, 37432, 37473], [37474, 37534, 37559, 37559, 37600], [37601, 37692, 37725, 37725, 37757], [37953, 38199, 38221, 38221, 38252], [38252, 38307, 38329, 38329, 38360], [38360, 38415, 38435, 38435, 38468], [38468, 38498, 38518, 38518, 38548], [38549, 38591, 38614, 38614, 38646], [38647, 38647, 38670, 38670, 38702], [38968, 38968, 38987, 38987, 39046], [39047, 39047, 39073, 39073, 39177], [39350, 39350, 39369, 39369, 39393], [42260, 42607, 42626, 42626, 42660], [42661, 42661, 42680, 42680, 42714], [42715, 42715, 42734, 42734, 42781], [42781, 42805, 42825, 42825, 42876], [42876, 42900, 42920, 42920, 42947], [42947, 42977, 42997, 42997, 43043], [43043, 43072, 43093, 43093, 43121], [43337, 43714, 43844, 43844, 44492], [44493, 44639, 44660, 44660, 44688], [44689, 44689, 44821, 44821, 45760], [45762, 46060, 46085, 46085, 46235], [46236, 46236, 46271, 46271, 46396], [46397, 46397, 46457, 46457, 46630], [46632, 46766, 46803, 46803, 46855], [46856, 46856, 46900, 46900, 46979], [46980, 46980, 47024, 47024, 47140], [47141, 47630, 47668, 47668, 47713], [47714, 47714, 47752, 47752, 47796], [47797, 47797, 47856, 47856, 47932], [47933, 47933, 47974, 47974, 48051], [48052, 48052, 48091, 48091, 48248], [48249, 48249, 48289, 48289, 48432], [48544, 48544, 48563, 48563, 48747], [48748, 49183, 49209, 49209, 49274], [50259, 50259, 50327, 50327, 50551], [50552, 50676, 50770, 50770, 51274], [51274, 51339, 51392, 51392, 51463], [51463, 52024, 52042, 52042, 52085], [52086, 52222, 52248, 52357, 52601], [52643, 52735, 52830, 52830, 53704], [53704, 53783, 53826, 53826, 53919], [53941, 53941, 53982, 53982, 54228], [54228, 54368, 54401, 54401, 54798], [54798, 54858, 54881, 54881, 55594], [56342, 56864, 56881, 56881, 56925], [56927, 56999, 57047, 57047, 57122], [57366, 57547, 57602, 57602, 57758], [57759, 57759, 57814, 57814, 57970], [57971, 57971, 58026, 58026, 58054], [58102, 58102, 58138, 58138, 58162], [58163, 58383, 58404, 58404, 59613], [59719, 59832, 59862, 59862, 59894], [59894, 59953, 59984, 59984, 60019], [60019, 60082, 60104, 60104, 60129], [60130, 60130, 60153, 60153, 60179], [60267, 60267, 60406, 60406, 60474], [60475, 60475, 60496, 60496, 60770], [60887, 61106, 61126, 61126, 61155], [61156, 61156, 61176, 61176, 61205], [61206, 61206, 61227, 61227, 61252], [61253, 61253, 61273, 61273, 61302], [61303, 61303, 61323, 61323, 61352], [61353, 61353, 61374, 61374, 61399], [61400, 61400, 61420, 61420, 61449], [61450, 61450, 61470, 61470, 61499], [61500, 61500, 61521, 61521, 61546], [61547, 62185, 62208, 62208, 62225], [62225, 62225, 62246, 62246, 62267], [62268, 62268, 62291, 62291, 62308], [62308, 62308, 62329, 62329, 62350], [62351, 62351, 62374, 62374, 62391], [62391, 62391, 62412, 62412, 62433], [62434, 62434, 62457, 62457, 62474], [62474, 62474, 62495, 62495, 62516], [62621, 62763, 62789, 62789, 62807], [62808, 62808, 62835, 62835, 62855], [62856, 62856, 62883, 62883, 62907], [62908, 62908, 62934, 62934, 62962], [62963, 62963, 62988, 62988, 63002], [63002, 63617, 63697, 63697, 63861], [63862, 63862, 63892, 63892, 64056], [64755, 64862, 64888, 64888, 65013], [65434, 65628, 65645, 65645, 65693], [66096, 66450, 66485, 66485, 66519], [66520, 66549, 66584, 66584, 66619], [66619, 66648, 66683, 66683, 66718], [66718, 66748, 66852, 66852, 68410], [68412, 68412, 68487, 68487, 68585], [68586, 68679, 68714, 68714, 68768], [70641, 70663, 70706, 70706, 70815], [73241, 73256, 73276, 73276, 73351], [73352, 73352, 73372, 73372, 73447], [73448, 73448, 73468, 73468, 73491], [73492, 73492, 73512, 73512, 73535], [73536, 73553, 73570, 73570, 73991], [74192, 74335, 74446, 74446, 74774], [74775, 74994, 75035, 75035, 75234], [75235, 75235, 75316, 75316, 75385], [75388, 75388, 75444, 75444, 75578], [75581, 75666, 75689, 75689, 75739], [75740, 75740, 75764, 75764, 75805], [75806, 75806, 75823, 75823, 75846], [75849, 75948, 76019, 76019, 76870], [76872, 76872, 76893, 76893, 77593], [77596, 77596, 77613, 77613, 78218], [78220, 78246, 78279, 78311, 79187], [79188, 79188, 79247, 79247, 79435], [79440, 79440, 79475, 79475, 79615], [79617, 79617, 79640, 79640, 79871], [79873, 79873, 79940, 79940, 80821], [80823, 80823, 80859, 80859, 81416], [81418, 81418, 81442, 81442, 81469], [81471, 81471, 81488, 81488, 82496], [82498, 82498, 82533, 82533, 83025]], "test": "error"}
{"id": "MlKcWW", "name": "bubbles_in_cube", "author": "skaplun", "description": "The main intention is to reproduce a 'sieve' animation from this post https://necessarydisorder.wordpress.com/\nBut this one is quite good-looking for me, so further work will be done in separate project.\nNeed to add AA.", "tags": ["raymarch", "volumetric"], "likes": 8, "viewed": 195, "published": "Public", "date": "1536657338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define thickness .0025\n#define sqrt3 1.73205080757\n#define d .0125\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n    \nconst vec3 boxmin = vec3(-1., -1., -1.);\nconst vec3 boxmax = -boxmin;\n\nbool intersect(in vec3 orig, in vec3 dir, out float minDist, out float maxDist) {\n    float tmin = (boxmin.x - orig.x) / dir.x; \n    float tmax = (boxmax.x - orig.x) / dir.x; \n \n    if (tmin > tmax){\n    \tfloat tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n \n    float tymin = (boxmin.y - orig.y) / dir.y; \n    float tymax = (boxmax.y - orig.y) / dir.y; \n \n    if (tymin > tymax){\n    \tfloat tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n \n    if ((tmin > tymax) || (tymin > tmax)) \n        return false; \n \n    if (tymin > tmin) \n        tmin = tymin; \n \n    if (tymax < tmax) \n        tmax = tymax; \n \n    float tzmin = (boxmin.z - orig.z) / dir.z; \n    float tzmax = (boxmax.z - orig.z) / dir.z; \n \n    if (tzmin > tzmax){\n    \tfloat tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    }\n \n    if ((tmin > tzmax) || (tzmin > tmax)) \n        return false; \n \n    if (tzmin > tmin) \n        tmin = tzmin; \n \n    if (tzmax < tmax)\n        tmax = tzmax;\n \n    minDist = tmin;\n    maxDist = tmax;\n    return true;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 clrInside(in float lmin, in float lmax, in vec3 origin,  vec3 dir){\n\tfloat iter = lmin + .01;\n    while(iter < lmax){\n    \tvec3 intersectionNormalized = vec3(.5) + (origin + dir * iter) * .5;\n        float y = floor(intersectionNormalized.y / thickness) * thickness;\n        float n = floor(fract(random(floor(intersectionNormalized.xz/d)) + iTime * .15) / thickness) * thickness;\n        float t = floor((sin(iTime) * .5 + .5) / thickness) * thickness;\n        vec2 muv = mod(intersectionNormalized.xz, d) * 2. - d;\n        if(y == max(n, t) && step(length(vec2(muv)), d * .75) == 1.)\n        \treturn vec3(y, 0., 0.);\n        iter += thickness;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6. * sin(iTime * .25), 3., 6. * cos(iTime * .25));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float lmin, lmax;\n    if (intersect(eye, worldDir, lmin, lmax)) {\n        vec3 point = eye + worldDir * lmin;\n        fragColor = vec4(clrInside(lmin, lmax, eye, worldDir), 1.);\n        return;\n    }\n    \n    fragColor = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 171], [248, 248, 329, 329, 1300], [1302, 1302, 1367, 1367, 1499], [1501, 1501, 1550, 1550, 1776], [1778, 1778, 1850, 1850, 2457], [2459, 2459, 2516, 2516, 3033]], "test": "valid"}
{"id": "MlKcWz", "name": "1972", "author": "tempoco", "description": "Eerste test nog aan het leren.\nStill learning it's all new for me.\nI use te visuals for supporting a DJ act \n", "tags": ["newhere"], "likes": 13, "viewed": 603, "published": "Public API", "date": "1535921633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define FAR 20.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvec3 camPath(in float t){ return vec3(sin(t * 0.45)*.75, cos(t * 0.75)*.75, t); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tvec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n// Akohdr's multitextured suggestion, with some small changes.\n#define t2D texture\nvec3 tpl4( sampler2D a, sampler2D b, \n           sampler2D c, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );\n    \n    float h = dot(cos(p*6.), sin(p.yzx*6.));\n    \n\tvec3 tx  = (t2D(a, p.yz)*n.x + t2D(a, p.zx)*n.y + t2D(a, p.xy)*n.z).xyz; // Pink sandstone.\n\tvec3 tx2 = (t2D(b, p.yz)*n.x + t2D(b, p.zx)*n.y + t2D(b, p.xy)*n.z).xyz; // Sandstone.\n    vec3 tx3 = 1.-(t2D(c, p.yz)*n.x + t2D(c, p.zx)*n.y + t2D(c, p.xy)*n.z).zyx; // Pink coral.\n\n    tx = mix(tx*tx, tx2*tx2, h*.5 + .5);\n    \n    h = dot(sin(p*5.), cos(p.zxy*5.));\n    \n\ttx2 = mix(tx3*tx3, tx2*tx2, h*.5 + .5);\n    \n    return mix(tx, tx2, dot(sin(p*2.), sin(p.zxy*2.))*.5 + .5);\n}\n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    p = cos(p*6.2831853) + 1.;\n    return dot(p, p);\n    \n}\n/*\n// Draw four warped spheres on a wrappable cube, and return the closest distance metric. Try to normalize\n// the result between zero and one.\nfloat cellTile(in vec3 p){\n    \n    vec4 d;\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    d.xy = min(d.xy, d.zw); // Minimum distance determination.\n    \n    return 1.- min(d.x, d.y)*.166; // Normalize... roughly.\n    \n}\n*/\n\n// Fast, three tap version, but I feel four is the minimum. Probably due to 3-simplex objects\n// requiring four vertices... but I haven't thought it through that thoroughly. Even so, this will\n// give a pretty convincing pattern under the right circumstances.\nfloat cellTile(in vec3 p){\n    \n    vec3 d;\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.1, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.2, .1, .64));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.1, .6, .10));\n    \n    return 1.- min(min(d.x, d.y), d.z)*.1666; // Normalize... roughly.\n    \n}\n\n\n\n\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty.\nfloat map(in vec3 p){\n    \n    float b = cellTile(p*3.); \n    //float b = cellTile(p + iTime/16.); // Animation.\n\n    // Offsetting the lattice around the camera path.\n    p.xy -= camPath(p.z).xy; \n\n    // Perturbing the surface slightly, prior to construction.\n    p += (sin(p*3.14159 - sin(p.zyx*3.14159)*3.14159*1.25))*.1;\n\n    // The main surface. A weird, molecular looking lattice.\n    float n = abs(dot(cos(p*3.14159), sin(p.yzx*3.14159)));\n\n    // Combining element to form the final structure.\n    return .45 - n*.33  - b*.1;\n    \n}\n\n \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., h;\n    for(int i = 0; i < 128; i++){\n\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.0015*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += (step(1., h)*.25 + .5)*h;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 4; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 5.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float vor = cellTile(p*27.);\n    \n    return pow(max(vor, 0.), 18.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.1, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    // Perturbing the screen coordinates to create the lamest underwater effect ever. :)\n    // Seriously, though, it's quite effective, all things considered.\n    u += sin(u*32. + cos(u.yx*16. + iTime*4.))*.0035;\n\n\t\n\t// Camera Setup.\n    vec3 o = camPath(iTime*.5); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*.5 + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*.5 + 1.5) + vec3(.0, .0, 0.); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 0.814159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 99., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2( camPath(lk.z).x/1. )*r.xy;\n \n    // Raymarch.\n    float t = trace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .02/(1. + t/FAR));\n        \n        n = dbF(p*sz, n, .01);\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n);\n        \n        // Texture variance: Akohdr's suggestion.\n        // Requires an additional sandstone texture in iChannel1, and the pink coral texture\n        // in iChannel2.\n        //vec3 tx = tpl4(iChannel0, iChannel1, iChannel2, p*sz, n);\n        \n        float c = dot(tx, vec3(0.299, 0.587, 0.114));\n        \n        tx += vec3(c*c*.8, c, c*c*.5)*fr;\n        \n\n\t\t// Very simple coloring. Fresnel and texture combination.\n        col = tx*(di + .1 + sp)+ tx*fr*2.;\n        col *= 1./(1. + d*.125 + d*d*.025)*ao*sh;\n\n        \n    }\n\n    // Mixing in a simple blue background.\n    vec3 bg = vec3(.5, .7, 1);\n    col = mix(clamp(col, 0., 8.), bg, smoothstep(0.8, FAR-5., t));\n    \n    // Half hearted gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 28, 50, 50, 85], [87, 239, 260, 260, 326], [328, 328, 353, 353, 409], [411, 565, 611, 611, 784], [786, 869, 954, 954, 1550], [1552, 1552, 1580, 1673, 1733], [2486, 2746, 2772, 2772, 3202], [3208, 3357, 3378, 3378, 3898], [3902, 4054, 4091, 4091, 4350], [4353, 4392, 4412, 4412, 4571], [4574, 4595, 4631, 4631, 5082], [5084, 5096, 5172, 5172, 5780], [5783, 5847, 5876, 5876, 5957], [5959, 6009, 6060, 6060, 6440], [6442, 6524, 6579, 6579, 7078], [7083, 7083, 7139, 7173, 10188]], "test": "error"}
{"id": "MlKyRt", "name": "New Learning Sparks", "author": "ClydeCoulter", "description": "Heavily based on Martijn Steinrucken's (BigWings) \"The Universe Within\"\nThis is my first attempt at shadertoy coding, after watching Martijn's tutorials.\nThis was first done in Unity 3D 2018.2 as a fullscreen quad shader.\nClydeCoulter", "tags": ["humanity"], "likes": 8, "viewed": 424, "published": "Public", "date": "1537383578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// New Learning Spark\n// Heavily based on Martijn Steinrucken's (aka BigWings) \"The Universe Within\"\n// This is my first attempt at shadertoy coding, first done in \n// Unity 3D 2018.2 as a fullscreen quad shader, while following Martijn's tutorial. \n// ClydeCoulter\n//\n// Background music is\"Slow Jam\" by Kevin MacLeod (incompetech.com)\n// Licensed under Creative Commons: By Attribution 3.0 License\n// http://creativecommons.org/licenses/by/3.0/\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define lerp(a, b, t) mix(a, b, t)\n\n// return a signed vector pependicular to the line segment a->b whose length is equal to the shortest \n// distance from the line segment a->b to p. (if there is no perp to the line segment to p, then returns\n// vector from the nearest point a or b to p)\nvec2 PerpToLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a; // vector from a to p\n    vec2 ba = b-a; // vector from a to b\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0); // clamping t makes ba a line Segment\n    vec2 c = ba*t;\n    return pa - c;\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    return length(PerpToLine(p, a, b));\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p * vec2(433.77, 231.93));\n    p += dot(p, p + 23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = N22(id + offset) * (iTime + 7642.186);\n\n    return offset + sin(n) * 0.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b, float w)\n{\n    float d = DistLine(p, a, b);\n    float m = S(w, w*0.333, d);\n    float d2 = length(a-b);\n    m *= S(1.2, 0.8, d2)*0.5 + S(0.05, 0.03, abs(d2-0.75));\n    return m * 2.8;\n}\n\nfloat Layer(vec2 uv)\n{\n    float m = 0.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    float w = 0.003;\n    float pw = w*12.0;\n\n    vec2 p[9];\n\n    // Had to convert the dual x & y for loops\n    // into a single loop to get the compiler\n    // to use the ndx.\n    float y = 0.0;\n    float x = 0.0;\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        x = mod(float(ndx), 3.0);\n        y = floor(float(ndx) / 3.0);\n        \n        p[ndx] = GetPos(id, vec2(x - 1.0, y - 1.0));\n    }\n\n    float t = (iTime + 123.67)*10.0;\n\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        if (ndx != 4)\n        {\n\t        m += Line(gv, p[4], p[ndx], w);\n\n            // Generate pulses going across to other nodes\n            float speed = iTime * 0.9;\n            vec2 pulse = vec2(0.0);\n            float t = mod(speed + N21(id + vec2(ndx)) * 3.0, 3.0) - 2.0;\n            pulse = mix(p[4], p[ndx], clamp(t, 0.0, 1.0));\n            m += S(pw, 0.0, length(gv - pulse)) * 2.5;\n\n            // pull their pulses accross to me\n            vec2 otherid = vec2(id.x + floor(mod(float(ndx), 3.0)) - 1.0, id.y + floor(float(ndx) / 3.0) - 1.0);\n            t = mod(speed + N21(otherid + vec2(8-ndx)) * 3.0, 3.0) - 2.0;\n            pulse = mix(p[ndx], p[4], clamp(t, 0.0, 1.0));\n            m += S(pw, 0.0, length(gv - pulse)) * 2.5;\n        }\n\n        // show some sparkle!\n        vec2 j = (p[ndx] - gv) * 25.0;\n        float sparkle = 1.0/dot(j,j);\n        m += 1.5 * sparkle * (sin(t+fract(p[ndx].x)*10.0) * 0.8 + 0.4);\n    }\n\n    // draw lines that cross our cells boundary\n    // where two neighbor points could draw across this cell\n    m += Line(gv, p[1], p[3], w);\n    m += Line(gv, p[1], p[5], w);\n    m += Line(gv, p[7], p[3], w);\n    m += Line(gv, p[7], p[5], w);\n\n    return m;\n}\n\nfloat GetLayers(vec2 uv, vec2 offset)\n{\n    float m = 0.0;\n\n    float t = iTime * 0.015; // speed that we move through the layers\n    for (float i = 0.0; i < 1.0; i += 1.0/3.0)\n    {\n        float z = fract(i+t);\n        float size = mix(10.0, 0.3, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.85, z); // fade in then fade out near camera(0)\n        m += Layer(uv * size + i * 10.0 - offset) * fade;\n    }\n\n    return m;\n}\n\n// offsets for glass effect (CFC,Jr)\n\nvec2 LineOffset(vec2 p, vec2 a, vec2 b, float w)\n{\n    vec2 perp = PerpToLine(p, a, b); // returns vector offset from line segment a->b to p\n\n    float d = length(perp);\n    float m = S(w, w*0.7, d); // mask line to width\n\n    float d2 = length(a-b);\n\n    return 160.0 * abs(perp) * perp * m;\n}\n\nvec2 LayerOffset(vec2 uv)\n{\n    vec2 m = vec2(0.0);\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    float w = 0.04;\n\n    vec2 p[9];\n\n    // Had to convert the dual x & y for loops\n    // into a single loop to get the compiler\n    // to use the ndx.\n    float y = 0.0;\n    float x = 0.0;\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        x = mod(float(ndx), 3.0);\n        y = floor(float(ndx) / 3.0);\n        \n        p[ndx] = GetPos(id, vec2(x - 1.0, y - 1.0));\n    }\n\n    float t = (iTime + 123.67)*10.0;\n\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        if (ndx != 4)\t\n            m += LineOffset(gv, p[4], p[ndx], w);\n    }\n    // draw lines that cross our cells boundary\n    // where the two neighbor points crossing lines in this cell\n    m += LineOffset(gv, p[1], p[3], w);\n    m += LineOffset(gv, p[1], p[5], w);\n    m += LineOffset(gv, p[7], p[3], w);\n    m += LineOffset(gv, p[7], p[5], w);\n\n    return m;\n}\n\nvec3 GetLayerDistortion(vec2 uv, vec2 offset)\n{\n    vec2 m = vec2(0,0);\n    float fade;\n    float t = iTime * 0.015; // speed that we move through the layers\n    for (float i = 0.0; i < 1.0; i += 1.0/3.0)\n    {\n        float z = fract(i+t);\n        float size = mix(10.0, 0.3, z);  // *** Layer Size!\n        fade = S(0.0, 0.5, z) * S(1.0, 0.9, z); // fade in then fade out near camera\n        m += LayerOffset(uv * size + i * 10.0 - offset) * fade; \n    }\n\n    return vec3(m, fade);\n}\n\nvec3 GetBackground(vec2 uv, vec2 offset)\n{\n    vec3 c = vec3(0,0,0);\n    \n    uv -= offset * 0.1;\n\n    // make a dotted background\n    float scale = 20.0;\n    vec2 pv = fract(uv * scale) - 0.5;\n    vec2 id = floor(uv * scale);\n    \n    \n    float blink = max(0.0, sin(iTime*12.0*N21(vec2(id.x*5.83, id.y*1.23)))) * 1.1 + 0.5;\n    float r = N21(id*1.236);\n    float g = N21(id*33.277);\n    float b = N21(id*78.29);\n    float m = S(0.45, 0.0, length(pv));\n    c +=  m * vec3(r, g, b) * blink;\n\n    return c;\n}\n\n// The original version of this shader was taken from \n// Martijn Steinruken's \"Universe Within\".\n// I intend to modify it such that the elements refract \n// light from glowing sphere's.\n// And, it seems that I have accomplished that goal\n// to some degree. (CFC,jr)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - 0.5;\n    mouse *= 1.0;\n\n    float gradient = uv.y;\n\n    // sway and rotate with time\n    float t = sin(mod((iTime * 0.1 + 3487.4), 6.28318530717959));  // rotate time\n    float st = sin(t);\n    float ct = cos(t);\n\n    mat2 rot = mat2(ct, -st, st, ct);\n    uv *= rot;\n    uv += vec2(-st, -ct) * 1.0;\n    \n    mouse *= rot;\n\n    // distortion is added for glass effect\n\n    vec3 distort = GetLayerDistortion(uv, mouse);\n    uv -= distort.xy * 1.0;\n\n    // Get Colors\n    vec3 col = vec3(0,0,0);\n\n    col += GetLayers(uv, mouse) * 2.0 * vec3(1.0, 0.9, 0.5);\n    col += GetBackground(uv, mouse) * 3.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dSSDd", "previewfilepath": "https://soundcloud.com/kevin-9-1/slow-jam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kevin-9-1/slow-jam", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKyRt.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[519, 773, 814, 814, 1030], [1032, 1032, 1072, 1072, 1114], [1116, 1116, 1135, 1135, 1233], [1235, 1235, 1253, 1253, 1307], [1309, 1309, 1344, 1344, 1433], [1435, 1435, 1480, 1480, 1655], [1657, 1657, 1679, 1679, 3438], [3440, 3440, 3479, 3479, 3868], [3870, 3908, 3958, 3958, 4202], [4204, 4204, 4231, 4231, 5137], [5139, 5139, 5186, 5186, 5624], [5626, 5626, 5668, 5668, 6133], [6135, 6403, 6460, 6510, 7326]], "test": "valid"}
{"id": "MlKyWy", "name": "palm-tree", "author": "teraspora", "description": " This is based on an excellent tutorial at https://www.youtube.com/watch?v=0ifChJ0nJfM&index=2&list=PL0EpikNmjs2CYUMePMGh3IjjP4tQlYqji.\n@iquilezles Thank you so much for your great teaching about manipulating the colours with sweet functions. :)", "tags": ["glslmaths"], "likes": 1, "viewed": 468, "published": "Public API", "date": "1537599432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// palm-tree - My fourth OpenGL shader;\n// Author: John Lynch (teraspora);\n// Date: 22 SEP 2018.\n// Based on Inigo Quilez's tutorial on making a basic palm tree, bending the trunk,\n// controlling the number of fronds and the smoothness or waviness of the trunk etc.\n// which can be found at\n// https://www.youtube.com/watch?v=0ifChJ0nJfM\n\n// I highly recommend the teachings of this highly intelligent and innovative \n// graphics developer, who in the best spirit of the dev community conveys his passion\n// for making art from mathematics and for communicating and sharing\n// his understanding.\n/// ====================================================================================\n\n// Note: I include some functions which I am not currently using but use in other \n// shaders and may experiment with in this or another shader based on this.\n// Feel free to play with them! :)\n\nconst float HALF = 0.5;\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0.1,0.8, 0.7);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\n// COLOUR FUNCTIONS:\n \n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// VECTOR FUNCTIONS:\nfloat len(vec2 v) {\n    return length(v);\n}\n\nvec2 hat(float phi) {\n  return vec2(cos(phi), sin (phi));\n}\n\nvec2 hat(vec2 v) {\n  return v / len(v);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\n// COMPLEX FUNCTIONS:\nvec2 times(vec2 v, vec2 w) {\n\treturn vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\nvec2 boxFold(vec2 z, float fold) {\n    return vec2(z.x > fold ? 2. * fold - z.x : (z.x < -fold ? -2. * fold - z.x : z.x),\n                z.y > fold ? 2. * fold - z.y : (z.y < -fold ? -2. * fold - z.y : z.y));\n}\n\nvec2 ballFold(vec2 z, float r, float bigR) {\n    float zAbs = len(z);\n    r = abs(r);\n    return zAbs < r ? z / (r * r) : (zAbs < abs(bigR)) ?\n            z / (zAbs * zAbs)\n            : z;\n}\n\nvec2 rotate(vec2 v, float phi) {\n  return times(v, polar(1.0, phi)) ;\n}\n\n// MISC. FUNCTIONS:\n\nbool isOdd(float n) {\n  return mod(n, 2.) > 0.5;\n}\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 0.5;\n    float order = 10.0;\n    float timeFactor = 1.0;\n    float factorG = 20.0;\n\tfloat t = 2. * mod(iTime * timeFactor, 1.0);\n    scaleFactor += 0.5 *sin(iTime /6.) / 2.;\n    \n    order = floor(mod(iTime / 10., 16.));\n    \n    // COORDINATES RAW (p) AND NORMALISED TO [-0.5, 0.5[ (q):\n    vec2 p = fragCoord.xy / iResolution.xy;\n    // p.x *= sin(p.y);\n    vec2 q = (p - vec2(0.5, 0.5)) / scaleFactor;\n    q = rotate(q, cos(iTime / 20.) * TWO_PI);\n    \n    // SMOOTHSTEP RADII and ASSOCIATED TRANSFORMATION FUNCTION:\n    // ===============================================\n    float rmin = 0.2;\n    float rinc = 0.01;\n    float rincp = 0.002;\n    float rincf = 0.1;     \n    // ===============================================\n    \n    // Colours:\n    vec3 orange = vec3(1.0, 0.2, 0.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    \n    // Define root colour:\n    vec3 col = mix(orange, yellow, (p.y));\n    col.b = sin(mod(iTime  / 12., 1.0));\n    // Now mutate according to length:\n    float r = rmin + rincf * cos(atan(q.y, q.x) * order + factorG * q.x + 1.0);\n    \n    col *= smoothstep(r, r + rinc, len(q));\n    \n    r = 0.04;\n    // make trunk wavy:\n    float barkWaviness = mod(iTime * 32., 100.0);\n    float barkIndentation = 0.016;\n    r += barkIndentation * cos(barkWaviness * q.y);\n    // make base broad; using p as it runs from 0 to 1:\n    r += exp(-64.0 *p.y);\n    \n    \n    // Put a green thing in the middle and tweak it:\n    float numPleats = 256.0;\n    float amp = 2.0 * cos(iTime / 20.);        \n    float baseX = 1.2;\n    float bendiness = 3.0;\n    baseX +=(mod(iTime/ 6.0, 1.6) - 1.6);\n    bendiness += (mod(iTime/ 2.0, 1.6) - 1.6);\n    col *= 1.0 -  (1.0 - smoothstep(r, r + rincp, abs(q.x + baseX * sin(bendiness * q.y)))) \n        * (1.0 - smoothstep(0.0, rincf, q.y));\n    \n    numPleats += (mod(iTime * 4., 18.) - 9.);\n    if (length(q) > 0.6 - amp * sin(numPleats *arg(q)) * 0.4) col = black;\n    \n    if (length(q) < 0.021 - amp * cos(numPleats * 3. * arg(q + PI / numPleats)) * 0.4) col = cyan;\n    \n    // Make things go a bit bluier once every so often:\n    float f = fract(iTime / 50.);\n    if (f < 0.2) col.b += abs(sin(f));;\n    \n    fragColor = vec4(col, 1.0);\n}\n\n//===================================================++++=========\n\n// SPARE CODE:\n\n// sin(atan(q.x, q.y) * (order - 1.)))", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1228, 1420, 1445, 1445, 1603], [1605, 1669, 1693, 1746, 2029], [2031, 2066, 2090, 2090, 2210], [2212, 2247, 2271, 2271, 2423], [2425, 2446, 2465, 2465, 2489], [2491, 2491, 2512, 2512, 2550], [2552, 2552, 2570, 2570, 2593], [2595, 2595, 2614, 2614, 2643], [2645, 2645, 2677, 2677, 2724], [2726, 2748, 2776, 2776, 2838], [2839, 2839, 2873, 2873, 3050], [3052, 3052, 3096, 3096, 3243], [3245, 3245, 3277, 3277, 3316], [3318, 3339, 3360, 3360, 3389], [3391, 3408, 3465, 3495, 5715]], "test": "valid"}
{"id": "MlVcDd", "name": "It fits!", "author": "Ebanflo", "description": "A cube-sized hole in a cube! Mouse changes the orientation", "tags": ["3d", "raymarching", "cube"], "likes": 1, "viewed": 349, "published": "Public API", "date": "1538268709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi6 0.666666*atan(1.0)\n#define pi2 3.0*pi6\n#define pi3 2.0*pi6\n#define pi 2.0*pi2\n#define pi4 0.25*pi\n\n#define width 1.0\n#define small 0.01\n#define far 10.0\n#define marchingIters 40\n\n#define cubeCol vec3(0, 0.9, 1)\n#define cutCubeCol vec3(0, 0, 1)\n#define light vec3(0.866)\n\n#define cubeAmp 2.2\n#define cubeFreq 1.0\n#define camRot vec2(1, 0)\n\n#define wholeCube\n\n//#define AA\n\nfloat sdCube(vec3 p){\n   vec3 d = abs(p) - width;\n   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdInfPrism(vec3 p){\n    vec3 d = abs(p) - vec3(9e9, width, width);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdf(vec3 p, mat3 orient){\n\n    float cube = sdCube(p);\n    p = orient*p;\n    float cutCube = max(cube, -sdInfPrism(p));\n\n    #ifdef wholeCube\n    return min(sdCube(p - vec3(cubeAmp*sin(cubeFreq*iTime), 0, 0)), cutCube);\n    #else\n    return cutCube;\n    #endif\n}\n\nvec3 calcNormal(vec3 p, mat3 orient){\n    vec2 h = vec2(0, small);\n    return normalize(vec3(sdf(p + h.yxx, orient),\n                          sdf(p + h.xyx, orient),\n                          sdf(p + h.xxy, orient))\n                          - sdf(p, orient));\n}\n\nmat3 calcOrient(vec2 m){\n\n    vec2 angles = vec2(pi3, pi6) + 0.5*pi6*m;\n    vec4 trig = sin(vec4(angles.x + vec2(0, pi2), angles.y + vec2(0, pi2)));\n\n    mat3 rot1 = mat3( trig.x, trig.y, 0,\n                     -trig.y, trig.x, 0,\n                           0,      0, 1);\n    mat3 rot2 = mat3( trig.z, 0, trig.w,\n                           0, 1, 0,\n                     -trig.w, 0, trig.z);\n\n    return rot1*rot2;\n}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nvec3 render(vec2 fragCoord){\n    \n    float time = 0.25*iTime;\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(xy, 2.5));\n    rd = r(rd, camRot*time + vec2(0, pi4));\n    vec3 ro = vec3(0, 0, -5);\n    ro = r(ro, camRot*time + vec2(0, pi4));\n    \n    mat3 orient = calcOrient(iMouse.xy==vec2(0)?vec2(0.5):iMouse.xy/iResolution.xy);\n    vec3 pos = vec3(cubeAmp*sin(cubeFreq*iTime), 0, 0);\n    \n    float t = 0.0;\n    vec3 p = ro;\n    int hit = 0;\n    \n    for(int i = 0; i < marchingIters; i++){\n\n        float d = max(sdCube(p), -sdInfPrism(orient*p));\n        if(d < small){hit = 1; break;}\n        \n        #ifdef wholeCube\n        float d2 = sdCube(orient*p - pos);\n        if(d2 < small){hit = 2; break;}\n        d = min(d, d2);\n        #endif\n        \n        p += d*rd;\n        t += d;\n        if(t > far) break;\n    }\n    if(hit > 0){\n        float shade = max(0.5, dot(light, calcNormal(p, orient)));\n        if(hit == 1) return shade*cutCubeCol;\n        else return shade*cubeCol;\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef AA\n    fragColor.rgb = vec3(0);\n    for(int i = -1; i <= 1; i++){\n        for(int j = -1; j <= 1; j++){\n            fragColor.rgb += render(fragCoord + 0.5*vec2(i, j));\n        }\n    }\n    fragColor.rgb /= 9.0;\n    #else\n    fragColor.rgb = render(fragCoord);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 384, 405, 405, 502], [504, 504, 529, 529, 646], [648, 648, 679, 679, 916], [918, 918, 955, 955, 1181], [1183, 1183, 1207, 1207, 1600], [1602, 1602, 1625, 1648, 1840], [1842, 1842, 1870, 1870, 2900], [2902, 2902, 2959, 2959, 3243]], "test": "valid"}
{"id": "MlVcDh", "name": "Curved Space Raytracing", "author": "RolandRock", "description": "[WIP]\nLighting seems to work\nRaytracing within a 3-sphere (i.e. surface of a 4D sphere)\nMove camera w/ mouse. Tan background is actually you - the rays loop around.\n\nCurrent scene: 7 balls, 1 reflective, + large sphere. Camera moving along geodesic.", "tags": ["raytracer", "4d"], "likes": 2, "viewed": 164, "published": "Public", "date": "1536109931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////// IMPORTANT CONSTANTS ///////////////////////////\n\n//Note: the containing 3-sphere always has a radius of 1\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = 2. * PI;\nbool debug_overrideColor = false;\n\nconst float MIN_RAY_HIT_THRESHOLD = 0.001;\n\n\n//////////////////////////// RAYTRACER PARAMS ////////////////////////////\n\nfloat zoom = 500.0;\nconst int AA_AMOUNT = 2;\nconst int REFLECTION_COUNT = 4;\nconst float REFLECTANCE = 0.6;\n\nconst vec3 BACKGROUND_COLOR = vec3(0);\nconst bool USER_SPHERE_VISIBLE = true;\n\n\n///////////////////////////// UTILITY METHODS ////////////////////////////\n\n//will rotate the positive x-axis towards the positive y-axis\nmat4 RotXYPlane(float angle)\n{\n    return mat4(cos(angle), -sin(angle), 0, 0,\n                sin(angle),  cos(angle), 0, 0,\n                         0,           0, 1, 0,\n                         0,           0, 0, 1);\n}\n//will rotate the positive x-axis towards the positive z-axis\nmat4 RotXZPlane(float angle)\n{\n     return mat4(cos(angle), 0, -sin(angle), 0,\n                          0, 1,           0, 0,\n                 sin(angle), 0,  cos(angle), 0,\n                 0,          0,           0, 1);\n}\n//will rotate the positive y-axis towards the positive z-axis\nmat4 RotYZPlane(float angle)\n{\n     return mat4(1, 0,          0,           0,\n                 0, cos(angle), -sin(angle), 0,\n                 0, sin(angle),  cos(angle), 0,\n                 0, 0,          0,           1);\n}\n//will rotate the positive x-axis towards the positive w-axis\nmat4 RotXWPlane(float angle)\n{\n     return mat4(cos(angle), 0, 0, -sin(angle),\n                          0, 1, 0,           0,\n                          0, 0, 1,           0,\n                 sin(angle), 0, 0,  cos(angle));\n}\n//will rotate the positive y-axis towards the positive w-axis\nmat4 RotYWPlane(float angle)\n{\n     return mat4(1,          0,           0,           0,\n                 0, cos(angle),           0, -sin(angle),\n                 0,          0,           1,           0,\n                 0, sin(angle),           0,  cos(angle));\n}\n//will rotate the positive z-axis towards the positive w-axis\nmat4 RotZWPlane(float angle)\n{\n     return mat4(1, 0,           0,          0,\n                 0, 1,           0,          0,\n                 0, 0,  cos(angle),  -sin(angle),\n                 0, 0,  sin(angle),  cos(angle));\n}\n\nfloat GeodesicDistance(vec4 p1, vec4 p2)\n{\n    float dotProd = dot(normalize(p1), normalize(p2));\n    \n    //clamp in case of float imprecision\n    return acos(clamp(dotProd, -1.0, 1.0));\n}\n\nfloat AngleFromGeodesicDistance(float dist)\n{\n    return dist;\n}\n\nvec4 Reflect(vec4 normal, vec4 dir)\n{\n    vec4 n = normalize(normal);\n    return dir - (2.*dot(dir, n))*n;\n}\n\nvec4 Project(vec4 toBeProjected, vec4 onto)\n{\n    vec4 normOnto = normalize(onto);\n    return dot(toBeProjected, normOnto) * normOnto;\n}\n\nbool PointsAreEqualOrOpposite(vec4 pt1, vec4 pt2)\n{\n    return abs(dot(pt1, pt2)) == 1.0;\n}\n\n\n/////////////////////////////////// RAY ///////////////////////////////////\n\nstruct Ray\n{\n    vec4 origin;\n    \n    //For the purpose of this raytracer, the \"direction\" vector is the point in space that this\n    //ray will reach at t=pi/2.\n    \n    //So the equation of this ray would be cos(t) * origin + sin(t) * direction\n    vec4 direction;\n};\n\nvec4 PointAlongRay(Ray ray, float t)\n{\n    return normalize((cos(t) * ray.origin) + (sin(t) * ray.direction));\n}\n\nvec4 DirectionAtPointAlongRay(Ray ray, float t)\n{\n    return normalize((cos(t) * ray.direction) + (sin(t) * -ray.origin));\n}\n\nRay RayFromAToB(vec4 from, vec4 to)\n{    \n    return Ray(from, normalize(to - Project(to, from)));\n}\n\n/////////////////////////////////// HIT ///////////////////////////////////\n\nstruct Hit\n{\n    bool isHit;\n    float dist;\n    vec4 normal;\n    vec3 color;\n    \n    bool hasReflection;\n    Ray reflectedRay;\n};\nHit NO_HIT = Hit(false, -1., vec4(0.0), vec3(1.0, 0., 1.0), false, Ray(vec4(0), vec4(0)));\nHit HitWithoutReflection(bool isHit, float dist, vec4 normal, vec3 color)\n{\n    return Hit(isHit, dist, normal, color, false, Ray(vec4(0), vec4(0)));\n}\n    \n\n////////////////////////////////// SPHERE /////////////////////////////////\n\nstruct Sphere\n{\n    vec4 center;\n    float radius;\n    vec3 color;\n    \n    bool hasCheckerboardPattern;\n    bool isReflective;\n    bool visibleFromInside;\n};\n   \nHit SphereHit(Sphere sphere, Ray ray)\n{\n    //A circle on the surface of a 3D sphere can be defined as the intersection\n    //of a plane and a sphere (and conversely, the intersection of a plane and a\n    //sphere will always generate a circle on the surface of the sphere)\n    //\n    //Similarly, intersecting a 3-dimensional \"hyperplane\" with a 4D sphere gets you\n    //a sphere within the surface of the 4D sphere. We can use this to determine intersection.\n    //Instead of trying to calculate the intersection of the ray and the sphere, we calculate\n    //the intersection of the ray and the hyperplane that would generate the sphere if it \n    //intersected the 4D sphere.\n    \n    float angle = AngleFromGeodesicDistance(sphere.radius);\n    vec4 volumeNormal = sphere.center;\n    vec4 volumeNormalCenter = sphere.center * cos(angle);\n    \n    float A = dot(volumeNormal, ray.direction);\n    float B = dot(volumeNormal, ray.origin);\n    float C = dot(volumeNormal, volumeNormalCenter);\n\n    float phaseShift = atan(B, A);\n    float amplitude = sqrt((A*A)+(B*B));\n\n    float asinInput = C / amplitude;\n    if(abs(asinInput) > 1.)\n    {\n        return NO_HIT;\n    }\n\n    float asinVal = asin(asinInput);\n    float asinAltVal = sign(asinVal) * (PI - abs(asinVal));\n    \n    float t1 = asinVal - phaseShift;\n    float t2 = asinAltVal - phaseShift;\n    \n    while(t1 < 0.)      { t1 += TWO_PI; }\n    while(t1 >= TWO_PI) { t1 -= TWO_PI; }\n    while(t2 < 0.)      { t2 += TWO_PI; }\n    while(t2 >= TWO_PI) { t2 -= TWO_PI; }\n    \n    //When we're inside a sphere, we can see through it.\n    //(this is mainly to allow the user to have a sphere representing them.)\n    bool rayIsComingFromWithinSphere = GeodesicDistance(ray.origin, sphere.center) <= sphere.radius;\n    \n    float t;\n    float nearT = min(t1, t2);\n    float farT = max(t1, t2);\n    if(nearT < MIN_RAY_HIT_THRESHOLD && farT < MIN_RAY_HIT_THRESHOLD)\n    {\n        return NO_HIT;\n    }\n    else if(nearT < MIN_RAY_HIT_THRESHOLD)\n    {\n        t = farT;\n    }\n    else if(farT < MIN_RAY_HIT_THRESHOLD)\n    {\n        if(!sphere.visibleFromInside && rayIsComingFromWithinSphere)\n        {\n            //debug_overrideColor = true;\n            return NO_HIT;\n        }\n        else\n        {\n        \tt = nearT;\n        }\n    }\n    else\n    {\n        if(!sphere.visibleFromInside && rayIsComingFromWithinSphere)\n        {\n            //debug_overrideColor = true;\n            t = farT;\n        }\n        else\n        {       \n        \tt = nearT;\n        }\n    }\n    \n    vec3 returnColor = sphere.color;\n    \n    vec4 hitPoint = PointAlongRay(ray, t); \n    \n    //Draw a grid-like texture on the spheres to let you see how you rotate around them\n    if(sphere.hasCheckerboardPattern)\n    {  \n        ivec4 alternating = ivec4(round(mod(vec4(floor(hitPoint / .06)), 2.)));\n        if((alternating.x == 1) ^^ (alternating.y == 1) ^^ (alternating.z == 1) ^^ (alternating.w == 1))\n        {\n            returnColor = vec3(0);\n        }\n    }\n    \n    vec4 rayDirAtHitPoint = DirectionAtPointAlongRay(ray, t);\n    vec4 vecToHitPoint = hitPoint - sphere.center;\n    vec4 normal = normalize(vecToHitPoint - Project(vecToHitPoint, hitPoint));\n    \n    Ray reflectedRay = Ray(vec4(0), vec4(0));\n    if(sphere.isReflective)\n    {\n        //Calculate reflection\n        vec4 reflection = normalize(Reflect(normal, rayDirAtHitPoint));\n        reflectedRay = Ray(hitPoint, reflection);\n    }\n    \n    return Hit(true, t, normal, returnColor, sphere.isReflective, reflectedRay);  \n}\n\n\n////////////////////////////// SCENE OBJECTS //////////////////////////////\n\nconst vec4 lightPos = normalize(vec4(1.,0.,0., 0.25));\nfloat lightIntensity = 0.5;\nfloat ambientLight = 0.1;\n\nconst Sphere lightObject = Sphere(lightPos, 0.05, vec3(1.0, 1.0, 1.0), false, false, false);\n\nSphere[] spheres = Sphere[](\n    //bools are in this order: checkerboard, reflective, visible from inside.\n    \n    Sphere(vec4(0), 0.1, vec3(0.8, 0.5, 0.5), false, false, false) //This spot reserved for the player sphere\n    \n    ,Sphere(normalize(vec4(1., 0., 0., 0.)),  0.1, vec3(1.0, 1.0, 1.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0.5, 0., 0.)), 0.1, vec3(0.0, 0.0, 0.0), false, true, true)\n    ,Sphere(normalize(vec4(1., -0.5, 0., 0.)),  0.1, vec3(1.0, 0.0, 0.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., 0.5, 0.)), 0.1, vec3(1.0, 0.0, 1.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., -0.5, 0.)),  0.1, vec3(0.0, 1.0, 0.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., 0., 0.5)), 0.1, vec3(1.0, 1.0, 0.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., 0., -0.5)),  0.1, vec3(0.0, 0.0, 1.0), true, false, true)\n    \n    // The light (at the moment it looks funny because things cast shadows on it)\n    ,lightObject\n    \n    //almost-plane at the bottom\n    ,Sphere(normalize(vec4(0.0, 0.0, 0.0, -1.)),  (PI/2.0) - 0.15, vec3(0.4, 0.2, 0.9), true, false, true)\n);\n\n\n////////////////////////// CORE RENDERING LOGIC ///////////////////////////\n\nHit FindClosestHit(Ray ray, out int hitObjectIndex)\n{\n    Hit nearest = HitWithoutReflection(false, 99999999999999., vec4(0), BACKGROUND_COLOR);\n    hitObjectIndex = -1;\n\n    //Iterate over spheres\n    int startingPoint = USER_SPHERE_VISIBLE ? 0 : 1;\n    for(int i = startingPoint; i < spheres.length(); i++)\n    {            \n        Hit sphereHit = SphereHit(spheres[i], ray);\n        if(sphereHit.isHit && sphereHit.dist < nearest.dist)\n        {\n            nearest = sphereHit;\n            hitObjectIndex = i;\n        }\n    }\n    \n    return nearest;\n}\n\nvec3 RayColor(Ray ray)\n{\n    vec3[REFLECTION_COUNT+1] colors;\n    \n    for(int i = 0; i < colors.length(); i++)\n    {\n        //So we can detect non-reflective surfaces.\n        colors[i] = vec3(-1);\n    }\n    \n    for(int reflections = 0; reflections <= REFLECTION_COUNT; reflections++)\n    {\n        int hitObjectIndex;\n        Hit nearest = FindClosestHit(ray, hitObjectIndex);\n        \n        if(!nearest.isHit)\n        {\n            colors[reflections] = BACKGROUND_COLOR;\n            break;\n        }\n        \n        vec4 hitPos = PointAlongRay(ray, nearest.dist);\n\n        float lightAmnt;\n        if(spheres[hitObjectIndex] == lightObject)\n        {\n            lightAmnt = 1.0;\n        }     \n        else if(PointsAreEqualOrOpposite(hitPos, lightPos))\n        {\n            if(dot(hitPos, lightPos) == 1.0)\n            {\n                lightAmnt = 1.0;\n            }\n            else\n            {\n                //TODO\n            }\n        }\n        else\n        {\n            vec4 lightRayDirAtHitPoint = -normalize(lightPos - Project(lightPos, hitPos));\n            float nearPathDotProduct = dot(-lightRayDirAtHitPoint, nearest.normal);\n\n            Ray lightRayWithPossibilityOfHitting;\n            float hitDotProduct;\n            if(nearPathDotProduct > 0.0)\n            {\n                lightRayWithPossibilityOfHitting = RayFromAToB(lightPos, hitPos);\n                hitDotProduct = nearPathDotProduct;\n            }\n            else if(nearPathDotProduct < 0.0)\n            {\n                Ray closeRay = RayFromAToB(lightPos, hitPos);\n                closeRay.direction = -closeRay.direction;\n                lightRayWithPossibilityOfHitting = closeRay;\n\n                hitDotProduct = -nearPathDotProduct;\n            }\n            else\n            {\n                // angle is exactly 90deg so it's not lit at all\n                lightAmnt = 0.0;\n            }\n\n            int lightHitObjectIndex;\n            Hit firstHit = FindClosestHit(lightRayWithPossibilityOfHitting, lightHitObjectIndex);\n\n            //TODO: this only works for convex objects - if concave objects are added this code will need to be updated \n            if(lightHitObjectIndex == hitObjectIndex)\n            {\n                //Nothing in between!\n\n                //TODO: may want to have sanity check here, compare adjusted geodesic distance to firsthit dist\n                //float dist = GeodesicDistance(lightPos, hitPos);\n                float dist = firstHit.dist;\n                lightAmnt = min(1.0, lightIntensity / (sin(dist) * sin(dist)));\n                lightAmnt *= clamp(hitDotProduct, 0.0, 1.0);\n            }\n            else\n            {\n                lightAmnt = 0.0;\n            }          \n        }\n        \n        //TODO: gamma correction\n\n        lightAmnt = min(1.0, lightAmnt + ambientLight);\n             \n        colors[reflections] = nearest.color * lightAmnt;\n\n        if(nearest.hasReflection)\n        {\n            ray = nearest.reflectedRay;           \n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    \n    vec3 curColor = colors[REFLECTION_COUNT];\n    for(int j = REFLECTION_COUNT - 1; j >= 0; j--)\n    {\n        //TODO: gamma correction & better lighting alg\n        if(curColor == vec3(-1))\n        {\n            curColor = colors[j];\n        }\n        else\n        {\n        \tcurColor = mix(colors[j], curColor, REFLECTANCE);\n        }\n    }\n    \n    return curColor;\n}\n\nvec4 ColorAt(vec2 pixelCoord)\n{\n    //full loop is 8 seconds\n    //(+0.56 is for thumbnail)\n    float a = 0.56 + (iTime / 8.) * TWO_PI;\n    vec2 mousePos = (iMouse.xy - (iResolution.xy/2.))/(iResolution.y/2.);\n    \n    //for thumbnail\n    if(iMouse.xy == vec2(0))\n    {\n        mousePos = vec2(-0.5, 0);\n    }\n    \n    //Generate ray\n    vec2 adjPixel = pixelCoord - iResolution.xy/2.;\n    vec4 baseRayDir = normalize(vec4(adjPixel.x/zoom, 0., 1., adjPixel.y/zoom));\n    \n    mat4 matrixTransform = RotYZPlane(a) * RotXYPlane(-PI / 4.);\n    mat4 mouseTransform = RotZWPlane(mousePos.y * PI / 2.) * RotXZPlane(-mousePos.x * PI / 2.);\n    \n    Ray ray = Ray(\n        normalize(vec4(0.,1.,0.,0.) * matrixTransform), \n        normalize(baseRayDir * mouseTransform * matrixTransform)\n    );\n    \n    if(USER_SPHERE_VISIBLE)\n    {\n    \tspheres[0].center = ray.origin;\n    }\n\n    return vec4(RayColor(ray), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    zoom *= iResolution.x / 1000.;\n    \n    fragColor = vec4(0.0);\n    \n    //antialiasing\n    for(float x = 0.; x < 1.; x += 1. / float(AA_AMOUNT))\n    {\n    \tfor(float y = 0.; y < 1.; y += 1. / float(AA_AMOUNT))\n        {    \n    \t\tfragColor += ColorAt(fragCoord + vec2(x, y));    \n    \t}\n    }\n    fragColor /= float(AA_AMOUNT * AA_AMOUNT);\n    \n    if(debug_overrideColor)\n    {\n        fragColor = vec4(1., 0., 1., 1.);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[638, 700, 730, 730, 921], [922, 984, 1014, 1014, 1209], [1210, 1272, 1302, 1302, 1497], [1498, 1560, 1590, 1590, 1785], [1786, 1848, 1878, 1878, 2113], [2114, 2176, 2206, 2206, 2404], [2406, 2406, 2448, 2448, 2595], [2597, 2597, 2642, 2642, 2661], [2663, 2663, 2700, 2700, 2771], [2773, 2773, 2818, 2818, 2909], [2911, 2911, 2962, 2962, 3002], [3005, 3354, 3392, 3392, 3466], [3468, 3468, 3517, 3517, 3592], [3594, 3594, 3631, 3631, 3694], [3696, 3996, 4071, 4071, 4147], [4154, 4394, 4433, 5072, 7919], [9327, 9404, 9457, 9457, 9961], [9963, 9963, 9987, 9987, 13413], [13415, 13415, 13446, 13506, 14322], [14324, 14324, 14379, 14379, 14817]], "test": "error"}
{"id": "MlVcDt", "name": "Paint 1", "author": "JuliaPoo", "description": "Just some experiments with fbm", "tags": ["fbm", "paint"], "likes": 29, "viewed": 921, "published": "Public API", "date": "1538232512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot( float a )\n{ \n    float s = sin(a);\n    float c = cos(a);\n    return mat2( s,  c, -c,  s ); \n}\n\nfloat noise( in vec2 x ){ return smoothstep(0.,1.,sin(1.5*x.x)*sin(1.5*x.y)); }\n\nfloat fbm( vec2 p )\n{\n    mat2 m = rot(.4);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pattern (in vec2 p, out vec2 q, out vec2 r, float t){\n   \n    \n\tq.x = fbm( p + vec2(0.0,0.0) + .7*t );\n    q.y = fbm( p + vec2(5.2,1.3) + 1.*t );\n\n    r.x = fbm( p + 10.0*q + vec2(1.7,9.2) + sin(t) );\n    r.y = fbm( p + 12.0*q + vec2(8.3,2.8) + cos(t) );\n\n    return fbm( p + 3.0*r );\n    \n}\n\nvoid mainImage(out vec4 C, in vec2 U){\n    \n    vec2 uv = (U.xy - iMouse.xy)/iResolution.xy * 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 q,r;\n    vec3 col1 = vec3(0.,.9,.8);\n    vec3 col2 = vec3(1.,.6,.5);\n    \n    float f = pattern(uv, q, r, 0.1*iTime);\n    \n    vec3 c = mix(col1, vec3(0), smoothstep(.0,.95,f));\n    vec3 a = col2 * smoothstep(0., .8, dot(q,r)*0.6);\n    c = sqrt(c*c + a*a);\n\n    C = vec4( c, 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 103], [105, 105, 130, 130, 184], [186, 186, 207, 207, 582], [585, 585, 644, 644, 882], [884, 884, 922, 922, 1316]], "test": "valid"}
{"id": "MlVczG", "name": "TriangleMesh", "author": "budsan", "description": "Triangles waving and changing size and color", "tags": ["trianglewave"], "likes": 0, "viewed": 87, "published": "Public", "date": "1536825838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mn = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cc = fragCoord/mn;\n    \n   \tcc = cc * vec2(16.0, 24.0);\n    float ccf = floor(cc).y;\n    cc = fract(cc);\n    cc.x = abs((cc.x * 2.0) - 1.0);\n    \n    float thr = sin(iTime + uv.x * 8.0 + ccf * 0.4) * 0.5;\n    \n    float br = cc.x + cc.y;\n    float st = smoothstep(0.5 + thr - (20.0/mn), 0.5 + thr + (20.0/mn), br);\n\n    vec3 col1 = vec3(0.7 + 0.3 * cos(iTime+uv.xy*vec2(0.6,1)), 1.0);\n    vec3 col2 = vec3(0.8 + 0.2 * sin(iTime+uv.xy*vec2(0.8,1)), 1.0);\n    \n    vec3 fcol = mix(col2,col1,st);\n    fragColor = vec4(fcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 684]], "test": "valid"}
{"id": "MlVyDG", "name": "Rectangle/Smiley", "author": "rlarp", "description": "Simple rectangle + smiley", "tags": ["rectangle", "education", "school", "homework"], "likes": 0, "viewed": 89, "published": "Public", "date": "1537575247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){ // Function creates a circle of radius r, with blur \n    float d = length(uv-p); // Distance formula \n    float c = smoothstep(r, r-blur, d); // Blurs the edges \n    return c; // Returns the circle\n}\n\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t); // Cuts of the smoothstep to start/end and uses the blur value to add the interval of start/end by a bit to achieve blur\n    float step2 = smoothstep(end+blur, end-blur, t); // Horizontal Band, above is Vertical Band\n\treturn step1*step2; // Gets the area in which both step1 and step2 = 1. (if one is .0, it's all .0\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    float band1 = Band(uv.x, left, right, blur); // Vertical band (x coord)\n    float band2 = Band(uv.y, bottom, top, blur); // Horizontal band (y coord)\n    return band1*band2; \n}\n\nfloat Smiley(vec2 uv, vec2 p, float size) { // Function creates a smiley face (so you don't have to do all the things in main\n    uv -= p; // Change the location of the Smiley (relocate the coordinate system)\n    uv /= size; // Change size of Smiley by scaling the coordinate system\n    \n    float mask = Circle(uv, vec2(0.), .4, .05); // Uses the circle function to create the outline for the Smiley\n    \n    mask -= Circle(uv, vec2(-.13, .2), .07, 0.01); // Cuts out part of circle to make eyes\n    mask -= Circle(uv, vec2(.13, .2), .07, 0.01); \n    \n    float mouth = Circle(uv, vec2(0., 0.), 0.3, 0.02); // Makes an ellipse like shape using Circle for the mouth\n    mouth -= Circle(uv, vec2(0., 0.1), 0.3, 0.02);\n    \n    mask -= mouth; // Subtract the area of the mouth so that it seems like there is a mouth \n    return mask; // Returns the smiley \n}\n\nfloat remap01(float a, float b, float t){ // Returns float between 0.0-1.0 depending on distance to value a/b.\n    return (t-a) / (b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t){ // High blur on right, low blur on left\n    return remap01(a,b,t) * (d-c) + c; \n}\n    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy; // set the resolution\n    float t = iTime; \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y; // equal out x/y\n    \n    // Note: I didn't take comments on a few of these things for they were already pre-made when the video started.\n    \n    vec3 col = vec3(0.);\n    \n    float mask = .0; // If you want rectangle\n    // float mask = Smiley(uv, vec2(0., .0), 1.); // If you want smiley\n    \n    float x = uv.x; // Seperate uv coords into x and y components\n    float m = sin(t+x*8.)*.1; // Manipulate y component according to a function\n    float y = uv.y-m;\n    \n    float blur = remap(-.5, .5, .01, .25, x);\n    blur = pow(blur*4., 3.); // Manipulate blur. \n    \n    mask = Rect(vec2(x,y), -.5, .5, -.1, .1, blur); // Utilizes the smoothstep function to split the screen\n   \n    col = vec3(1., 1., 1.)*mask; // Only colors the mask \n    \n    fragColor = vec4(col, 1.0); // Adds color the the smiley\n    \n    // \n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVyDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 104, 251], [253, 253, 309, 309, 685], [687, 687, 769, 769, 950], [952, 952, 995, 1077, 1808], [1810, 1810, 1851, 1920, 1948], [1950, 1950, 2007, 2047, 2089], [2096, 2096, 2151, 2151, 3115]], "test": "valid"}
{"id": "MlycD3", "name": "Trapezoid - distance", "author": "iq", "description": "Distance to a capped cone. Useful to make 3D truncated cones. This function is the basis to build and exact SDF to a 3D capped cone (as shown here: [url]https://www.shadertoy.com/view/Xds3zN[/url] and [url]https://www.shadertoy.com/view/tsSXzK[/url])", "tags": ["2d", "distancefield", "sdf", "triangle", "cone", "distance"], "likes": 6, "viewed": 1494, "published": "Public API", "date": "1537952013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an isosceles trapezoid\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ra = 0.2+0.15*sin(iTime*1.3+0.0);\n    float rb = 0.2+0.15*sin(iTime*1.4+1.1);\n    vec2  pa = vec2(-0.6,0.0)+0.4*sin(iTime*1.1+vec2(0.0,2.0));\n    vec2  pb = vec2(-0.6,0.0)+0.4*sin(iTime*1.2+vec2(1.0,2.5));\n    vec2  pc = vec2(0.8,0.0);\n\n    // axis aligned trapezoid\n\tfloat d = sdTrapezoid( p-pc, ra, rb, 0.5+0.2*sin(1.3*iTime) );\n    // aribitrary trapezoid\n    d = min( d, sdTrapezoid( p, pa, pb , ra, rb ) );\n\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdTrapezoid( m, pa, pb , ra, rb );\n    d = min( d, sdTrapezoid( m-pc, ra, rb, 0.5+0.2*sin(1.3*iTime) ) );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlycD3.jpg", "access": "shaders20k", "license": "mit", "functions": [[1117, 1276, 1300, 1300, 1319], [1321, 1377, 1442, 1442, 1766], [1768, 1795, 1872, 1872, 2418], [2419, 2419, 2476, 2476, 3645]], "test": "valid"}
{"id": "MlycR3", "name": "Plasma Droplet", "author": "aparadja", "description": "Super duper ray trace boogaloo", "tags": ["raytracing", "plasma"], "likes": 23, "viewed": 290, "published": "Public", "date": "1537108485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool intersect(vec3 origin, vec3 ray, float radius, out float t, out vec3 n) {\n    vec3 L = -origin;\n    float radiusSquared = radius * radius;\n    float tca = dot(L, ray);\n    if (tca < 0.0) return false;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > radiusSquared) return false;\n    float thc = sqrt(radiusSquared - d2);\n    t = tca - thc;\n    n = normalize(origin + ray * t);\n    return true;\n}\n\nfloat fresnel(vec3 ray, vec3 normal) {\n    float scale = 1.2;\n    float power = 2.5;\n    float c = scale*pow(1. + dot(ray, normal), power);\n    return clamp(c, 0., 1.);\n}\n\nvec3 sky(vec3 d) {\n    float t = iTime;\n    float f = 16.0;\n    float g = t*.5;\n    d.xz *= mat2(-cos(g), sin(g), sin(g), cos(g));\n    float a = d.x*sin(t/7.) + d.y*cos(t/3.) + d.z*sin(t/5.);\n    float v1 = sin(f/3.14*a + t);\n    float cx = d.x + .5*sin(t/5.);\n    float cy = d.y + .5*cos(t/3.);\n    float v2 = sin(sqrt(f*10.0*(cx*cx + cy*cy + 1.)) + t);\n    float v3 = sin(f*d.x/3.14 + t/2.);\n    float v = v1 + v2 + v3 + sin(t);\n    float stripe = 1. - pow(sin(v*6.), 4.) * .1;\n    return vec3(sin(v - .1 + sin(t/2.0)*.2), -cos(v+0.2), -sin(v+1.05))*.4 + .6*stripe;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy*2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 origin = vec3(sin(iTime/3.)*0.3, sin(iTime/5.)*.2, -2.+sin(iTime/1.6)*0.3);\n    vec3 ray = normalize(vec3(uv.xy, 1));\n    float distort = pow(sin(iTime/3.), 7.)*.03;\n    float radius = 1. + sin(7.*(ray.x + iTime/3.0))*distort + cos(11.*(ray.y + iTime/5.))*distort;\n\n    float t;\n    vec3 normal;\n    if (intersect(origin, ray, radius, t, normal)) {\n        float rc = fresnel(ray, normal);\n        float vc = pow(abs(normal.z), 10.)*.4;\n        vec3 reflectedRay = reflect(ray, normal);\n        vec3 refractedRay = refract(ray, normal, 1./1.31);\n        vec3 reflectedColor = sky(reflectedRay);\n        vec3 refractedColor = sky(refractedRay);\n        vec3 internalColor = mix(refractedColor, vec3(1.), vc);\n        vec3 lightDirection = normalize(vec3(0, 1, 0));\n        float specular = pow(max(0., dot(reflectedRay, lightDirection)), 12.);\n        vec3 color = mix(internalColor, reflectedColor, rc) + specular*.5;\n        fragColor = vec4(color, 1.);\n    }\n    else {\n        fragColor = vec4(mix(sky(ray), vec3(.7), .2), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlycR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 78, 78, 402], [404, 404, 442, 442, 574], [576, 576, 594, 594, 1145], [1147, 1147, 1202, 1202, 2343]], "test": "valid"}
{"id": "MlycRK", "name": "In or Out?", "author": "ColtonSoneson", "description": "Just messing around with animation", "tags": ["introtomoderngraphics"], "likes": 1, "viewed": 69, "published": "Public", "date": "1536891866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 circlePos1 = vec2(0.5, 0.5);\nfloat radius1 = 0.35;\n\nvec2 circlePos2 = vec2(0.5, 0.5);\nfloat radius2 = 0.3;\n\nvec2 circlePos3 = vec2(0.5, 0.5);\nfloat radius3 = 0.25;\n\nvec2 circlePos4 = vec2(0.5, 0.5);\nfloat radius4 = 0.2;\n\nvec2 circlePos5 = vec2(0.5, 0.5);\nfloat radius5 = 0.15;\n\nvec2 circlePos6 = vec2(0.5, 0.5);\nfloat radius6 = 0.1;\n\nvec2 circlePos7 = vec2(0.5, 0.5);\nfloat radius7 = 0.05;\n\n\nvec4 FG1 = vec4(1.0, 1.0, 0.0, 1.0);\nvec4 FG2 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 BG = vec4(1.0,1.0,1.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x; //upscaler for the y to get that 1:1 ratio\n    uv.y = uv.y * aspectRatio; //upscales the y\n    \n    vec3 rainbow1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1,2,3));\n    vec3 rainbow2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1.2,2.2,3.2));\n    vec3 rainbow3 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1.4,2.4,3.4));\n    vec3 rainbow4 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1.6,2.6,3.6));\n    vec3 rainbow5 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1.8,2.8,3.8));\n    vec3 rainbow6 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(2.0,3.0,4.0));\n    vec3 rainbow7 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(2.2,3.2,4.2));\n\tvec4 RB1 = vec4(rainbow1, 1.0);\n    vec4 RB2 = vec4(rainbow2, 1.0);\n    vec4 RB3 = vec4(rainbow3, 1.0);\n    vec4 RB4 = vec4(rainbow4, 1.0);\n    vec4 RB5 = vec4(rainbow5, 1.0);\n    vec4 RB6 = vec4(rainbow6, 1.0);\n    vec4 RB7 = vec4(rainbow7, 1.0);\n    \n    circlePos1.y = circlePos1.y * aspectRatio;\n\tcirclePos1.x += sin(iTime) * 0.05;\n    \n    circlePos2.y = circlePos2.y * aspectRatio;\n\tcirclePos2.x += sin(iTime) * 0.1;\n    \n    circlePos3.y = circlePos3.y * aspectRatio;\n\tcirclePos3.x += sin(iTime) * 0.15;\n    \n    circlePos4.y = circlePos4.y * aspectRatio;\n\tcirclePos4.x += sin(iTime) * 0.2;\n    \n    circlePos5.y = circlePos5.y * aspectRatio;\n\tcirclePos5.x += sin(iTime) * 0.25;\n    \n    circlePos6.y = circlePos6.y * aspectRatio;\n\tcirclePos6.x += sin(iTime) * 0.3;\n    \n    circlePos7.y = circlePos7.y * aspectRatio;\n\tcirclePos7.x += sin(iTime) * 0.35;\n    \n    if(length(circlePos7 - uv) < radius7)\n    {\n        fragColor = RB1;\n    }\n    else if(length(circlePos6 - uv) < radius6)\n    {\n        fragColor = RB2;\n    }\n    else if (length(circlePos5 - uv) < radius5)\n    {\n        fragColor = RB3;\n    }\n    else if (length(circlePos4 - uv) < radius4)\n    {\n        fragColor = RB4;\n    }\n    else if (length(circlePos3 - uv) < radius3)\n    {\n        fragColor = RB5;\n    }\n    else if (length(circlePos2 - uv) < radius2)\n    {\n        fragColor = RB6;\n    }\n    else if (length(circlePos1 - uv) < radius1)\n    {\n        fragColor = RB7;\n    }\n    else\n    {\n        fragColor = BG;\n    }\n      \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlycRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 507, 564, 614, 2782]], "test": "valid"}
{"id": "MlycRy", "name": "Demo - Voronoi Noise", "author": "ikuto", "description": "Inspired by https://www.shadertoy.com/view/4sl3Dr.\nVoronoi noise is based on iq's article http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm.", "tags": ["3d", "voronoi", "noise", "octave"], "likes": 30, "viewed": 1638, "published": "Public API", "date": "1536858803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nvec2 hash2(vec2 p) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nmat3 lookAt( in vec3 eye, in vec3 center, in vec3 up )\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat voronoiDistance( in vec2 pos )\n{\n\tvec2 p = floor(pos), f = fract(pos);\n    float u = 0.5 * (sin(iTime-0.5*PI) + 1.0);\n    \n\tvec2 res = vec2(8.0);\n\tfor(int i = -1; i <= 1; i ++)\n\tfor(int k = -1; k <= 1; k ++)\n\t{\n\t\tvec2 b = vec2(i, k);\n\t\tvec2 r = b - f + hash2(p + b) * u;\n\t\t\t\n\t\tfloat d = dot(r, r);\n        \n\t\tif(d < res.x){\n            res.y = res.x; \n            res.x = d; \n        } \n        else if(d < res.y){\n            res.y = d; \n        }\n\t}\n\treturn res.y - res.x;\n}\n\nvec3 render( in vec3 rayOri, in vec3 rayDir )\n{\n    float theta = 2.0 * (acos(0.5*rayDir.x) / PI) - 1.0;\n    float phi = atan(rayDir.y, rayDir.z) / PI;\n    vec2 uv = vec2(theta, phi);\n    \n    float v = 0.0;\n\tfor(float i = 0., a = .6, f = 8.; i < 3.; ++i, f*=2., a*=.6)\n\t{\t\n\t\tfloat v1 = 1.0 - smoothstep(0.0, 0.2, voronoiDistance(uv * f));\n\t\tfloat v2 = 1.0 - smoothstep(0.0, 0.2, voronoiDistance(uv * f * 0.5 + iTime));\n        float intensity = 0.5 * (cos(iTime) + 1.0);\n\t\tv += a * (pow(v1 * (0.5 + v2), 2.0) + v1 * intensity + 0.1);\n\t}\n\t\n\tvec3 c = vec3(8.0, 3.0, 2.0);\n\tvec3 col = vec3(pow(v, c.x), pow(v, c.y), pow(v, c.z)) * 2.0;\n\t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 rayOri = vec3(0.0);\n    vec2 mouse = (iMouse.z > 0.5) ? 5.0*(2.0*iMouse.xy/iResolution.xy-1.0) : vec2(0.0);\n    vec3 rayTgt = vec3(cos(mouse.x), mouse.y, sin(mouse.x));\n    \n    mat3 viewMat = lookAt(rayOri, rayTgt, vec3(0.0, 1.0, 0.0));\n    vec3 rayDir = normalize(viewMat * vec3(uv, -1.0));\n\n    vec3 col = render(rayOri, rayDir);\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlycRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 42, 42, 136], [138, 138, 194, 194, 316], [318, 318, 356, 356, 800], [802, 802, 849, 849, 1455], [1457, 1457, 1514, 1514, 1954]], "test": "valid"}
{"id": "MlycWK", "name": "Glitched Moire", "author": "eScape", "description": "test", "tags": ["test"], "likes": 5, "viewed": 118, "published": "Public", "date": "1537735065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Remap\n    vec2 p = uv-vec2(0.5);\n\n    // Compensate for aspect ratio\n    p.x *=iResolution.x/iResolution.y;    \n    \n    float radius = 0.5;\n    float r = radius+(0.2*cos(atan(p.y,p.x)*float(iFrame)));\n    //float r = radius+(0.2*cos(atan(p.y,p.x)*.5));\n    \n    r -= (0.1*sin((iTime*2.0)+atan(p.y,p.x)*10.0));\n\tvec4 col = vec4(1.0);\n    float sm =abs( 0.5*cos(iTime+atan(p.y,p.x)));\n\tsm=.5;\n    col.rgb *= smoothstep(r,r-sm,length(p));\n    vec4 tex =  texture(iChannel0, uv * 0.3);\n    col -=tex;\n    \n    // Output to screen\n    fragColor = vec4(vec3(col),0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlycWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 717]], "test": "error"}
{"id": "MlyyDy", "name": "Veins-Sphere Project", "author": "cake7914", "description": "Looks like veins all throughout an arm/leg or something :) (sphere project)", "tags": ["beginner"], "likes": 2, "viewed": 71, "published": "Public", "date": "1537493059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(-cos(a), -sin(a),\n                -sin(a), -cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n    //pMod3(q, vec3(0.75, 1., 0.8));\n    pMod3(q, vec3(.905, .785, 0.5));\n   \n    \n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.25); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.7);\n    \n    float disp = 0.5 * (abs(sin(p.x*20.)) *\n                       abs(cos(p.y*10.)) *\n                       abs(sin(p.z*20.)) );\n    \ts1 += disp;\n    \t//s1 -= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, -s2+.075); // Union\n    float df2 = max(s1, s2); // Intersection\n    float df3 = max(s1, -s3); // Difference\n    \n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*0.3;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.1, 0.5, 0.5);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = .15;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime*1.0, 0.0, -1.75);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.55 / (t*t* .25);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    fragColor = vec4((fc-color),.4);\n    //fragColor = vec4(cos(fc+color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 89], [91, 91, 130, 130, 201], [203, 203, 240, 240, 283], [285, 285, 320, 320, 352], [355, 355, 374, 374, 937], [940, 940, 975, 975, 1133], [1136, 1136, 1193, 1193, 1692]], "test": "error"}
{"id": "MlyyRc", "name": "Fuck this", "author": "wangyue66", "description": "just fuck it", "tags": ["tutorial"], "likes": 1, "viewed": 349, "published": "Public API", "date": "1537113799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 PURPLE = vec3(1.0, 0.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\n\n// rate = long radius / short radius\nvec3 DrawEllipse(in vec2 uv, in vec2 center, float radius, float rate, float blur, in vec3 backCol, in vec3 drawCol)\n{\n    vec2 origin = uv - center;\n    origin.y /= rate;\n    float dis = length(origin);\n    \n    float t = smoothstep(radius, radius - blur, dis);\n    vec3 col = mix(backCol, drawCol, t);\n    return col;\n}\n\nvec3 DrawCircle(in vec2 uv, in vec2 center, float radius, float blur, in vec3 backCol, in vec3 drawCol)\n{\n    float dis = length(uv - center);\n    float rate = smoothstep(radius, radius - blur, dis);\n    vec3 col = mix(backCol, drawCol, rate);\n    return col;\n}\n\nvec3 DrawMouse(in vec2 uv, in vec2 center,in float offset, float radius, float blur, in vec3 backCol, in vec3 drawCol)\n{\n    float dis = length(uv - center);\n    float rate1 = smoothstep(radius, radius - blur, dis);\n    float dis2 = length(uv - vec2(center.x, center.y + offset));\n    float rate2 = smoothstep(radius, radius - blur, dis2);\n    float rate = rate1 - rate2;\n    vec3 col = mix(backCol, drawCol, rate);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= 0.5;\n    uv *= 2.0;  //(x,y -> [-1,1])\n    uv.x *= iResolution.x / iResolution.y; //x unit equal y unit\n\t// head\n    vec3 head = DrawCircle(uv, vec2(0.0,0.0), 0.8, 0.1, RED, BLUE);\n    // left eye  \n    vec3 leftEye = DrawEllipse(uv, vec2(-0.35,0.2), 0.12, 0.6, 0.02, head, GREEN);\n    // right eye\n    vec3 rightEye = DrawEllipse(uv, vec2(0.35,0.2), 0.12, 0.6, 0.02, leftEye, GREEN);\n    // nose\n    vec3 nose = DrawEllipse(uv, vec2(0.0,-0.08), 0.04, 1.0, 0.02, rightEye, CYAN);\n    \n    // mouth\n    float offset = sin(iTime * 5.0) * 0.04;\n    vec3 mouth;\n    if(offset < 0.0)\n    {\n        mouth = DrawMouse(uv, vec2(0.0,-0.5), offset, 0.1, 0.02, nose, PURPLE);\n    }\n    else\n    {\n        mouth = DrawMouse(uv, vec2(0.0,-0.4), offset, 0.1, 0.02, nose, PURPLE);\n    }\n    \n    vec3 lastCol = mouth;\n    // Output to screen\n    fragColor = vec4(lastCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 236, 354, 354, 557], [559, 559, 664, 664, 820], [822, 822, 942, 942, 1255], [1257, 1257, 1314, 1369, 2285]], "test": "valid"}
{"id": "MlyyWD", "name": "Analytic 2-order motion blur", "author": "nalivai", "description": "The shader is inspired by https://www.shadertoy.com/view/MdSGDm\nThat shader looks good but the motion blur there does not follow the path of the particle. The problem is solved partly by using local particle acceleration.", "tags": ["2order", "analyticmotionblur"], "likes": 13, "viewed": 243, "published": "Public", "date": "1536407300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n/*\nAnalytical 2-order motion blur\nVersion: 0.2\nAuthor: Fedor Petrov\n\nInspired  by https://www.shadertoy.com/view/MdSGDm\n\nThe blur achieved in https://www.shadertoy.com/view/MdSGDm is always\nlinear. This is OK for relatively slow motion, even fast motion \nlooks nice but doesn't feel fully right. At high velocities \nthe blured dots start to look like rigid sticks.\n\nThe blur in this shader follows the parabola, which is constructed \ntaking into account local coordinate, local velocity  and local acceleration.\nTo find the distance from a point to a parabola and thus the area covered\nwith color one needs to solve the third order equation for time.\nHere I was too lazy and made the assumtion, that t**3 term is negligible.\nIt works quite fine, however there are some artifacts (work in progress). \n\nI know that the code is not clean enough, there are some parts to\nbe refactored.\n\nThis shader, however, doesn't simulate a lot of things that become\ncomplicated when the trajectory is not linear (e.g., color overlapping\nfor a particle that rapidly changes direction of motion etc). \n*/\nmat2 rotate(float alpha) {\nreturn mat2(sin(alpha),cos(alpha),cos(alpha),-sin(alpha));\n}\n\nfloat trace(vec2 p, vec2 r0, vec2 v0, vec2 a0, float R, float dt)\n{\n\tfloat rat = 1.5* PI*R*R/(length(v0)*dt*2.0*R+PI*R*R);\n    float a = 1.5*(a0.y*v0.y+a0.x*v0.x);\n    float b = (v0.x*v0.x+v0.y*v0.y) + a0.y*(r0.y-p.y) + a0.x*(r0.x-p.x);\n    float c = v0.x*(r0.x-p.x)+v0.y*(r0.y-p.y);\n    float D = b*b-4.0*a*c;\n    float t1 = dt*10.0;\n    float t2 = dt*10.0;\n    float T=dt*10.0;\n    float L1 = 2.0*R;\n    float L2 = 2.0*R;\n    float LM1 = 2.0*R;\n    float LM2 = 2.0*R;\n    float coef = 0.0;\n    vec2 V1 = v0-a0*dt;\n    float RT1 = R/length(V1);\n    vec2 V2 = v0+a0*dt;\n    float RT2 = R/length(V2);\n    vec2 R1 = vec2(2.0*R);\n    vec2 R2 = vec2(2.0*R);\n    vec2 RM1 = 0.5*a0*dt*dt - v0*dt+r0-p;\n    vec2 RM2 = 0.5*a0*dt*dt + v0*dt+r0-p;\n    LM2 = length(RM2);\n    LM1 = length(RM1);\n    if(D>=0.0)\n    {\n    t1 = (-b + sqrt(D))*0.5/a;\n    t2 = (-b - sqrt(D))*0.5/a;\n    R1 = 0.5*a0*t1*t1 + v0*t1+r0-p;\n    R2 = 0.5*a0*t2*t2 + v0*t2+r0-p;\n    L1 = length(R1);\n    L2 = length(R2); \n\tif((abs(t1)<dt && L1<R) \n      || (abs(t2)<dt && L2<R) \n      || (min(LM1,LM2)<R) \n      )\n    {\n    coef = 1.0;\n    }   \n    }\n    else if(min(LM1,LM2)<R) {\n        coef = 1.0;\n        }\n         \n    if(coef!=0.0) {\n        float mt = min(L1,L2);\n        if(mt>min(LM1,LM2))\n        {\n        mt = min(LM1,LM2);\n        }   \n        if(LM1<R && LM2<R)\n        {\n        rat = 1.0;\n        }\n        else if(LM1<R) {\n            float RMdir = dot(RM1,V1)/length(V1);\n            float RMperp = sqrt(LM1*LM1-RMdir*RMdir);\n            float fact = 0.5-0.5*RMdir/sqrt(R*R-RMperp*RMperp);\n            coef *=sqrt(1.0-pow(clamp(RMperp,0.0,R)/R,2.0))*fact;\n        }\n        else if(LM2<R) {\n            float RMdir = dot(RM2,V2)/length(V2);\n            float RMperp = sqrt(LM2*LM2-RMdir*RMdir);\n            float fact = 0.5+0.5*RMdir/sqrt(R*R-RMperp*RMperp);\n            coef *=sqrt(1.0-pow(clamp(RMperp,0.0,R)/R,2.0))*fact;\n        }\n        else {\n        coef *= sqrt(1.0-pow(mt/R,2.0));\n        }\n        }    \n\treturn coef*rat;\n}\n\n\nfloat randomoff(float x)\n{\nreturn fract(271828.459045+3.1415926*sqrt(abs(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cent = vec2(0.5,0.5);\n    float alpha = 2.0;\n    float beta = 2.0;\n    float ampxx = 0.3;\n    float ampyy = 0.3;\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    fragColor.rgb*=0.5;\n    float maxx=30.0;\n    for(float k=0.0;k<maxx;k++)\n    {\n    alpha = alpha + 0.111111;\n    beta = beta + randomoff(beta);\n    float tt = iTime*0.5;\n    float phi = randomoff(k*2.71828182845*10.0);\n    float ampx = ampxx*(0.9+0.2*randomoff(k*alpha));\n    float ampy = ampyy*(0.9+0.2*randomoff(k*beta));\n    vec2 r0 = vec2(ampx*sin(alpha*tt+phi),\n                   ampy*cos(beta*tt+phi));\n    vec2 v0 = vec2(alpha*ampx*cos(alpha*tt+phi),\n                   -beta*ampy*sin(beta*tt+phi));\n    vec2 a0 = vec2(-alpha*alpha*ampx*sin(alpha*tt+phi),\n                   -beta*beta*ampy*cos(beta*tt+phi));\n    a0 = a0*rotate(k*0.1);\n    v0 = v0*rotate(k*0.1);\n    r0 = r0*rotate(k*0.1)+vec2(ratio*0.5,0.5);\n      \n    float R = 0.02+k/maxx*0.03;\n    float DT=0.02;\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+phi*2.0);\n\tfloat mult = trace(uv,r0,v0,a0,R,DT);\n    // Output to screen\n    fragColor = fragColor*(1.0-mult) + vec4(col*1.5*vec3(k/maxx),1.0)*mult;\n    \n    }\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 1108, 1134, 1134, 1195], [1197, 1197, 1264, 1264, 3210], [3213, 3213, 3239, 3239, 3293], [3295, 3295, 3352, 3352, 4717]], "test": "error"}
{"id": "MlyyWt", "name": "Distance Field Step Vis", "author": "JeroenDStout", "description": "Rays 'come in' from the left and are solved in under 32 steps.\n\nOn the top half are the steps each ray takes with 'hotter' rows getting more yellow with each step. Bottom shows the scanline. Mouseclick places rogue circle.", "tags": ["distancefield"], "likes": 1, "viewed": 280, "published": "Public API", "date": "1538085996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sampleCircle( vec2 origin, vec2 point )\n{\n    return length(origin - point) - 0.1;\n}\n\nfloat sampleBox( vec2 origin, mat2x2 orient, vec2 point )\n{\n    vec2 rel = (point - origin);\n    float relDist = length(rel);\n    \n    if (relDist > 0.3) {\n        return relDist - 0.2;\n    }\n    \n    rel *= orient;\n    \n    return max(abs(rel.x), abs(rel.y)) - 0.1;\n}\n\nfloat baseCombine( float a, float b )\n{\n    return min(a, b);\n}\n\nfloat combineZand( float a, float b)\n{\n    float k = .1;\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nfloat sampleDistanceField( vec2 point, vec2 mouse, float time )\n{\n    float dist = 9999.;\n    \n    float circRot = time / 5. * 3.;\n    float circRot2 = time / 7. * 6.;\n    \n    dist = baseCombine(dist, sampleCircle(vec2(sin(circRot) + 1.8, -cos(circRot)) * .2, point));\n    dist = baseCombine(dist, sampleCircle(vec2(cos(circRot) + 1.4, sin(circRot)) * .2, point));\n    \n    dist = combineZand(sampleCircle(vec2(sin(circRot) + 1.8, -cos(circRot)) * .2, point),\n                       sampleCircle(vec2(cos(circRot2) + 1.4, sin(circRot2)) * .1, point) );\n    dist = baseCombine(dist, sampleCircle(mouse, point));\n    \n    float  r = 0.4;\n    mat2x2 box = mat2x2( cos(r), -sin(r),\n        \t\t         sin(r),  cos(r) );\n    dist = baseCombine(dist, sampleBox(vec2(-0.3, -0.1), box, point));\n    \n     r = -0.4;\n    box = mat2x2( cos(r), -sin(r),\n        \t\t  sin(r),  cos(r) );\n    dist = baseCombine(dist, sampleBox(vec2(-0.3, -0.1), box, point));\n    \n     r = -0.25 + time / 3. * 2.;\n    box = mat2x2( cos(r), -sin(r),\n        \t\t  sin(r),  cos(r) );\n    dist = baseCombine(dist, sampleBox(vec2(-0.3, 0.4), box, point));\n    \n    // enable this to over-step\n    //if (dist > 0.)\n    //    dist *= 1.2;\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    \n\tuv = (2.0 * uv - 1.0) * aspect * 0.5;\n    vec2 mouse = ((iMouse.xy / iResolution.xy) - .5) * aspect;\n    \n    float val = sampleDistanceField( uv, mouse, iTime );\n    \n    if (val >= 0.) {\n        float mVal = mod(val, .1) + 0.2;\n        fragColor.xyz = pow(vec3(0.8, 0.85, 0.7), vec3(mVal*25.)) * 1.5;\n    }\n    \n    float hRow = (1. - 2. * mod(iTime * .1, 1.)) * 0.3;\n    \n    float sampleRow = uv.y;\n    float graphVal = 1. - (uv.y + 0.3) / -0.2;\n    \n    if (uv.y < -0.3) {\n        sampleRow = hRow;\n    }\n    \n    float curPoint = -1.;\n    vec3 stepColour;\n    float dist = 9999.;\n    for (int i = 0; i < 32; i++) {\n        dist = sampleDistanceField( vec2(curPoint, sampleRow), mouse, iTime );\n        dist *= 1.0;\n        \n        curPoint += dist;\n        if (abs(uv.x - curPoint) < 5e-3) {\n            stepColour.x = pow(0.5, float(i) *-0.5) * .1;\n            stepColour.y = pow(0.9, float(i) *-0.5) * .2;\n            stepColour.z = pow(0.99, float(i) *-0.5) * .5;\n            fragColor.xyz += stepColour;\n        }\n        if (abs(dist) < 5e-3)\n            break;\n    }\n    \n    if (abs(hRow - uv.y) < 2e-3) {\n        if (uv.x < curPoint)\n        \tfragColor.x = 1.;\n        else\n        \tfragColor.z = 1.;\n    }\n    if (curPoint < uv.x) {\n        fragColor.xyz *= .7;//+= stepColour;\n    }\n    \n    if (uv.y < -0.3) {\n        \n        fragColor.xyz = vec3(graphVal);\n    \n        val = sampleDistanceField( vec2(uv.x, hRow), mouse, iTime );\n        \n        float valError = val * val;\n        \n        if (graphVal - 0.2 < val * 5.0) {\n            fragColor.xyz = vec3(1. - val, 0.3, .3);\n            if (val < 0.) {\n                fragColor.xyz += vec3(0.1, 0.1, 0.1);\n            }\n        }\n        else {\n            fragColor.xyz = vec3(0., 0., 0.);\n        }\n        if (graphVal < 0.2) {\n            fragColor.xyz += vec3(0.1, 0.4, 0.1);\n        }\n        \n        fragColor.xyz += stepColour;\n    }\n        \n    fragColor.w = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 90], [92, 92, 151, 151, 360], [362, 362, 401, 401, 425], [427, 427, 465, 465, 560], [562, 562, 627, 627, 1785], [1787, 1787, 1844, 1844, 3902]], "test": "valid"}
{"id": "MsGfWK", "name": "Sine Wave Ghosts", "author": "Doctrometer", "description": "Ghosts in a sine wave! does not work in WebGL 1.0 will fix this soon!", "tags": ["sin", "pacman", "square", "ghosts"], "likes": 6, "viewed": 410, "published": "Public API", "date": "1538280346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool circle(vec2 center,vec2 point, float r){\n     \n      if(((point.x-center.x)*(point.x-center.x) + ((point.y-center.y)*(point.y-center.y))) <= (float(r*r))){\n          return true;\n      }\n    \n    return false;\n    \n}\n\n\nbool square(vec2 position,vec2 point,float w, float h){\n       \n    if(point.x > position.x && point.x < position.x+w && point.y > position.y && point.y < position.y+h){\n       return true;\n    } \n    return false;\n}\n\n\n\n    \n    const int blocks2[52] = // positions of blocks x,y,w,h\n        int[](5,12,4,1,\n              3,11,8,1,\n             2,10,10,1,\n             1,7,12,3,\n             0,2,14,6,\n             0,1,2,1,\n             3,1,3,1,\n             8,1,3,1,\n             12,1,2,1,\n             0,0,1,1,\n             4,0,2,1, // 52\n             8,0,2,1,\n             13,0,1,1  \n             );\n\t const int blocks[44] = // 44\n        int[](5,12,4,1,\n              3,11,8,1,\n             2,10,10,1,\n             1,7,12,3,\n             0,2,14,6,\n             0,1,4,1,\n             5,1,4,1,\n             10,1,4,1,\n             1,0,2,1,\n             6,0,2,1,\n             11,0,2,1\n              );\n\n\tconst int eye[12] = \n        int[](1,0,2,1,\n             0,1,4,3,\n             1,4,2,1);\n        \nvoid eyes(vec2 pos,vec2 frag, int scale,vec4 inCol, out vec4 colour){\n    \n    \n    for(int b = 0; b < 12;b+=4){\n        \n        int x = eye[b];\n        int y = eye[b+1];\n        int w = eye[b+2];\n        int h = eye[b+3];\n        \n        //int scale = 10;\n        if(square(vec2(float(x*scale)+pos.x,float(y*scale)+pos.y),frag,float(w*scale),float(h*scale))){\n            colour = vec4(1.0,1.0,1.0,1.0);\n               break;\n        }else{\n        \tcolour = inCol;\n        }\n        \n       \n            \n    } \n    \n}\n\nvoid ghost(vec2 pos,vec2 frag, int scale,vec4 inCol, out vec4 colour, vec4 ghostColour){\n    \n    \n    if(mod(float(iFrame/10),2.0) == 0.0){ // controls the speed of the sprite change\n        \n        for(int b = 0; b < 44;b+=4){\n\n            int x = blocks[b];\n            int y = blocks[b+1];\n            int w = blocks[b+2];\n            int h = blocks[b+3];\n\n            //int scale = 10;\n            if(square(vec2(float(x*scale)+pos.x,float(y*scale)+pos.y),frag,float(w*scale),float(h*scale))){\n                colour = ghostColour;\n                break;\n            }else{\n                colour = inCol;\n            }\n        }\n    \n    }else{\n        for(int b = 0; b < 52;b+=4){\n\n            int x = blocks2[b];\n            int y = blocks2[b+1];\n            int w = blocks2[b+2];\n            int h = blocks2[b+3];\n\n            //int scale = 10;\n            if(square(vec2(float(x*scale)+pos.x,float(y*scale)+pos.y),frag,float(w*scale),float(h*scale))){\n                colour = ghostColour;\n                break;\n            }else{\n                colour = inCol;\n            }\n        }\n    }\n    \n    vec2 rightEye = vec2(pos.x+2.0 * float(scale),pos.y+5.0 * float(scale));\n    vec2 leftEye = vec2(pos.x+8.0 * float(scale),pos.y+5.0 * float(scale));\n    \n    eyes(rightEye,frag,scale,colour,colour);\n    eyes(leftEye,frag,scale,colour,colour);\n    \n    \n    vec2 leftPupil = vec2(rightEye.x+1.0*float(scale),rightEye.y + 2.0 * float(scale));\n     vec2 rightPupil = vec2(leftEye.x+1.0*float(scale),leftEye.y + 2.0 * float(scale));\n    \n    leftPupil = vec2((sin(iTime*4.0)*1.0*float(scale))+leftPupil.x,leftPupil.y);\n    rightPupil = vec2((sin(iTime*4.0)*1.0*float(scale))+rightPupil.x,rightPupil.y);\n    \n    if(square(leftPupil,frag,2.0* float(scale),2.0* float(scale))){\n      colour = vec4(0.0,0.0,1.0,1.0); \n    }\n    \n    if(square(rightPupil,frag,2.0* float(scale),2.0* float(scale))){\n      colour = vec4(0.0,0.0,1.0,1.0); \n    }\n    \n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //background\n\tfragColor = vec4(uv.y,0.2,1.0,1.0);\n    \n    // need to fix scaling\n    int scale = 2 ;//int(iResolution.y/100.0);\n    \n    int ghostCount = int(iResolution.x/float(scale*20));\n    \n    for(int i= 0; i < ghostCount; i++){\n    float o = (sin((iTime+float(i)/2.0)*2.0)*40.0) + iResolution.y/2.0;\n    ghost(vec2(float(i)*20.0*float(scale) + float(scale*2),1.0*o),fragCoord,scale,fragColor,fragColor,mix(vec4(1.0,1.0,1.0,1.0), fragColor,0.5));\n    o = (-sin((iTime+float(i)/2.0)*2.0)*40.0) + iResolution.y/2.0;\n    ghost(vec2(float(i)*20.0*float(scale) + float(scale*2),1.0*o),fragCoord,scale,fragColor,fragColor,mix(vec4(1.0,0.0,0.0,1.0), fragColor,0.5));\n    }\n    \n    \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 221], [224, 224, 279, 279, 440], [1226, 1226, 1295, 1295, 1748], [1750, 1750, 1838, 1838, 3711], [3716, 3716, 3773, 3773, 4507]], "test": "valid"}
{"id": "MsVSDK", "name": "Nice carpet, bro", "author": "dedmoros", "description": "It's a carpet made out of fractals, yo.", "tags": ["fractal"], "likes": 1, "viewed": 121, "published": "Public", "date": "1538168580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fold = vec2(0.5, -0.5);\nvec2 translate = vec2(1.5);\nfloat scale = 1.3;\n\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec2 rotate(vec2 p, float a){\n\treturn vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)+p.y*cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    \n    fragCoord.xy -= iResolution.xy/2.;\n    fragCoord *= 1.+ cos((iTime)*.0000005644887)*.99;\n\tfloat f = tan(dot(fragCoord,fragCoord)*(1.+sin((iTime)*.000000861741164752781)*.9)+sin(iTime*.06917481283157));\n    \n\tp.x *= iResolution.x/iResolution.y;\n\tp *= 0.003;\n\tfloat x = p.y;\n\tp = abs(mod(p, 8.0) - 4.0);\n\tfor(int i = 0; i < 36; i++){\n\t\tp = abs(p - fold) + fold;\n\t\tp = p*scale - translate;\n\t\tp = rotate(p, 3.14159/(8.0+sin(iTime*0.00001+float(i)*0.1)*0.5+0.5));\n\t}\n\tfloat i = x*10.0 + atan(p.y, p.x) + iTime*0.5;\n\tfloat h = floor(i*6.0)/5.0 + 0.07;\n\th += smoothstep(0.0, 0.4, mod(i*6.0/5.0, 1.0/5.0)*5.0)/5.0 - 0.5;\n\tfragColor=vec4(hsv(h, f, smoothstep(-1.0, 3.0, length(p))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 112, 112, 197], [199, 199, 228, 228, 290], [292, 292, 349, 349, 1091]], "test": "valid"}
{"id": "MtGcRy", "name": "Rolling Ball of Lava", "author": "jonnyjedjedi", "description": "More travels in the wonderful world of learning Shaderland stuff. Thank you Mr Gonzalez and Mr Quilez, et al for the fantastic online resources.", "tags": ["ballrollingvoronoinoisefbmrandomlavamagma"], "likes": 8, "viewed": 361, "published": "Public", "date": "1536770859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float NoiseResolution = 4.0; //  0.4\nconst float Lacunarity = 2.0; // 2.0 // intuitive measure of gappiness / heterogenity or variability\nconst float Gain = 0.6; // 0.6\nconst float Ball_rad = 0.45; // 0.45\nconst float Ball_roll_spd = 0.5; // 0.5\nconst float Dark_lava_spd = 0.05; // 0.05\nconst float Dark_island_spd = 0.5; // 0.5\n\n\n// Let's get random numbers\nvec2 random2D(vec2 p) {\n\treturn fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))*43758.5453);\n}\n\nfloat random1D(vec2 p) {\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n\n// Add a bit of noise\nfloat noise2D(vec2 _pos) {\t\n    vec2 i = floor(_pos); \t\t// integer\n\tvec2 f = fract(_pos); \t\t// fraction\n\n// define the corners of a tile\n\tfloat a = random1D(i);\n\tfloat b = random1D(i + vec2(1.0, 0.0));\n\tfloat c = random1D(i + vec2(0.0, 1.0));\n\tfloat d = random1D(i + vec2(1.0, 1.0));\n\n\t// smooth Interpolation\n\tvec2 u = smoothstep(0.0, 1.0, f);\n    \n\t// lerp between the four corners\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// fractal brownian motion\nfloat fbm(vec2 _pos) {\n\t_pos.y += iTime * Ball_roll_spd;\n\t_pos.x += sin(iTime * Ball_roll_spd);\n\tfloat ts = iTime * Dark_lava_spd;\n\tfloat val = 0.0;\n\tfloat amp = 0.4;\n    \n\t// Loop of octaves\n\tfor (int i = 0; i < 4; ++i) // set octave number to 4\n\t{\n\t\tval += amp * noise2D(_pos+ts);\n\t\t_pos *= Lacunarity;\n\t\tamp *= Gain;\n\t}\n\treturn val;\n}\n\nfloat voronoiIQ(vec2 _pos) {\n\t_pos.y += iTime * Ball_roll_spd;\n\t_pos.x += sin(iTime * Ball_roll_spd);\n\tvec2 p = floor(_pos);\n\tvec2  f = fract(_pos);\n\tfloat res = 0.0; \n\tfor (int j = -1; j <= 1; j++)\n\t\tfor (int i = -1; i <= 1; i++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 pnt = random2D(p + b);\n\t\t\tpnt = 0.5 + 0.5*sin((iTime * Dark_island_spd) + 6.2831*pnt);\n\t\t\tvec2 r = vec2(b) - f + pnt;\n\t\t\tfloat d = dot(r, r);\n\t\t\tres += exp(-32.0*d); // quickly decaying exponential \n\t\t}\n   return -(1.0 / 32.0)*log(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 pos1 = uv.xy - vec2(0.825, 0.5) ; // center what being drawn\n    vec3 pos = vec3(pos1, sqrt(Ball_rad*Ball_rad - pos1.x*pos1.x - pos1.y*pos1.y)/ NoiseResolution);\n    \n \tfloat dist = distance(pos.xy, vec2(0.0, 0.0));\n\tpos /= vec3(1.0*pos.z, 1.0*pos.z, 0.0);\n\n    \n\tif (dist > (Ball_rad - Ball_rad * 0.125)) {\n        color = vec3(0.0, 0.0, 0.0);\n\t    color.r += 1.0-smoothstep(Ball_rad - Ball_rad * 0.35, Ball_rad + 0.125, dist);\n} \n    else {\n       \tcolor.rg = vec2(voronoiIQ(pos.xy));\n\t\tcolor.r += 0.25+fbm(pos.xy);\n}\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 367, 390, 390, 511], [513, 513, 537, 537, 610], [613, 635, 661, 661, 1096], [1098, 1125, 1147, 1147, 1462], [1464, 1464, 1492, 1492, 1969], [1971, 1971, 2028, 2028, 2800]], "test": "valid"}
{"id": "MtGcWw", "name": "Tesseract 4D raymarcher", "author": "NuSan", "description": "Just a little test to raymarch edges of an hypercube in 4D and multisample along the w direction to reveal it.", "tags": ["raymarcher", "4d"], "likes": 27, "viewed": 994, "published": "Public", "date": "1536493787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SPHERE_GRID 0\n#define HIGHLIGHT_3D_SLICE 1\n#define USE_MAX 0\n#define SAMPLES_W 30\n#define MAXSTEPS 30\n\n#define time iTime\n#define v2Resolution iResolution\n#define out_color fragColor\n\nfloat sph(vec4 p, float r) { return length(p)-r; }\nfloat cyl2(vec2 p, float r) {return length(p)-r; }\nfloat box(vec4 p, float s) { vec4 ap = abs(p); return min(length(max(vec4(0),ap-s)), max(max(ap.x,ap.y),max(ap.z,ap.w))-s); }\nfloat box2(vec2 p, float s) { vec2 ap = abs(p); return min(length(max(vec2(0),ap-s)),max(ap.x, ap.y)-s); }\n\nvec4 rep(vec4 p, vec4 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec4 rid(vec4 p, vec4 s) {\n  return floor(p/s-0.5);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\nfloat map(vec4 p, float size) {\n\n  float spd = 0.6;\n  \n  p.yz *= rot(time*0.05);\n  p.xw *= rot(time * spd);\n  p.yw *= rot(time*0.2*spd);\n  p.xw *= rot(time*0.7*spd);\n  p.zw *= rot(time*0.3*spd);\n  \n  //p.xz *= rot(time*0.2);\n\n#if SPHERE_GRID\n  // grid inside a sphere\n  float d = sph(p, 2.0);\n\n  vec4 rp2 = rep(p, vec4(1.0));\n\n  //float size = 0.24;\n  size*=0.55;\n  float c = box2(rp2.xz, size);\n  c = min(c, box2(rp2.xy, size));\n  c = min(c, box2(rp2.yz, size));\n  c = min(c, box2(rp2.xw, size));\n  c = min(c, box2(rp2.yw, size));\n  c = min(c, box2(rp2.zw, size));\n  d = max(d, -c);\n#else\n    \n  // tesseract\n  float d = box(p, 1.0);\n\n  vec4 rp = p;//rep(op, vec4(0.4));\n  //float size = 0.95;\n  float c = box2(rp.xz, size);\n  c = min(c, box2(rp.xy, size));\n  c = min(c, box2(rp.yz, size));\n  c = min(c, box2(rp.xw, size));\n  c = min(c, box2(rp.yw, size));\n  c = min(c, box2(rp.zw, size));\n\n  d = max(d, -c);\n\n#endif\n  \n  return d;\n}\n\nvec3 norm(vec4 p, float size) {\n  vec2 off=vec2(0.01,0);\n  return normalize(vec3(map(p+off.xyyy, size)-map(p-off.xyyy, size),map(p+off.yxyy, size)-map(p-off.yxyy, size),map(p+off.yyxy, size)-map(p-off.yyxy, size)));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(172.412,735.124)+uv.yx*vec2(97.354,421.653)+vec2(94.321,37.365)),vec2(4.6872,7.9841))+0.71243);\n}\n\nvec3 GetCol(vec2 uv, float motion, float size) {\n\n  \n  vec4 s=vec4(0,0,-5,motion);\n  vec4 r=normalize(vec4(-uv, 1,0));\n\n  float dd = 0.0;\n  vec4 p = s;\n  float at=0.0;\n  float show=1.0f;\n  for(int i=0; i<MAXSTEPS; ++i) {\n    float d = map(p, size);\n    if(d<0.001) {\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n    if(dd>100.0) {\n      show=0.0f;\n      break;\n    }\n    at += exp(-d)*0.8;\n  }\n\n  vec3 n=norm(p, size);\n  vec3 l=normalize(vec3(-1));\n  float lum=max(0.0, dot(l,n));\n\n  vec3 col = vec3(0);\n  col += lum * 2.0;\n  col += lum * pow(max(0.0, dot(n, normalize(-r.xyz+l))), 10.0) * vec3(1.0,5.0,10.0);\n  col += (n.y*0.5+0.5) * vec3(0.1,0.5,1.0);\n  col *= show*2.0/dd;\n\n  col += vec3(0.8,0.2,0.2)*0.03/exp(-at*0.25);\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / v2Resolution.x, fragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  float str = 1.7;\n  float off = rnd(uv);\n  vec3 col = vec3(0.0);\n  float size = 0.87+sin(time*0.2)*0.1;\n  \n  for(int i=0; i<SAMPLES_W; ++i) {\n\n    float motion = (float(i)+off)/float(SAMPLES_W);\n    motion = motion * 2.0 - 1.0;\n#if HIGHLIGHT_3D_SLICE\n    motion = motion*motion*sign(motion);\n#endif\n    motion *= str;\n\n    vec3 cur = GetCol(uv, motion, size);\n#if USE_MAX\n    col = max(col, cur);\n#else\n    col += cur;\n#endif\n  }\n\n#if USE_MAX\n\tcol *= size*0.4;    \n#else\n\tcol *= size*4.0/float(SAMPLES_W);\n#endif\n    \n  out_color = vec4(col.rgb, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 221, 221, 243], [244, 244, 273, 273, 294], [295, 295, 323, 323, 420], [421, 421, 450, 450, 527], [529, 529, 555, 555, 590], [592, 592, 618, 618, 645], [647, 647, 666, 666, 732], [735, 735, 766, 766, 1669], [1671, 1671, 1702, 1702, 1888], [1890, 1890, 1910, 1910, 2039], [2041, 2041, 2089, 2089, 2780], [2783, 2783, 2840, 2840, 3535]], "test": "valid"}
{"id": "MtGyRK", "name": "Shader  #2", "author": "jkashimura", "description": "HW", "tags": ["beginner"], "likes": 3, "viewed": 78, "published": "Public", "date": "1536876662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere - Signed Distance Function\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n\n\n\n// Locate objects\nfloat map(vec3 p)\n{    \n    // Sphere radius\n    float sphereSize = cos(iTime)+1.;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n     int tx = int(q.x);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\tfft *= 2.5;\n    // Signed distance of sphere\n    float s = sphere(q, sphereSize);\n    \n    float d = 0.1 * (cos(q.x*5.*fft) * cos(q.y*5.*fft) * cos(q.z*5.*fft) );\n    //return s +wave;\n    return s+d;\n}\n\n\n// Trace rays\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0; // Distance Traveled\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = origin + r * t*-sin(iTime);\n        float d = map(p); // Locate object\n        t += d * 0.2; // Step along the ray\n        \n        \n    }\n    return t; \n    \n    \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(tan(iTime), cos(iTime*0.4), -sin(iTime)+3.);\n  \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n\n   \t// Create ray to fire into scene\n   \tvec3 ray = normalize(vec3(uv, 1.5));\n    \n    // Create origin of scene\n    vec3 origin = vec3(0., 0.,iTime);\n   \n    \n    // Trace any objects in the scene\n    float t = trace(origin*cos(iTime)*.5, ray*-sin(iTime)*.5);\n    \n    t += smoothstep(-sin(iTime),-tan(iTime),cos(iTime));\n    \n    // Generate fog based on distance from t\n    float fog = 100. / (1.0 + t * t * 0.3);\n    float expFog = 2.0 / (t*t*0.1);\n    // Final color with includes sdf + fog\n    vec3 fc = vec3(expFog*7.);\n     //vec3 fc = vec3(expFog*7.,iTime/uv.xy-vec2(-cos(iTime),0));\n\t\n    //fc /= cos(log(color*fft)*0.5);\n    fc -= tan(color);\n    // Output to screen\n    fragColor = vec4(-cos(fc*0.7)+sin(fc*0.7),6.0);\n}\n/* \n    \n    \n    // Trace any objects in the scene\n    float t = trace(origin, ray);\n    \n    // Generate fog based on distance from t\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    // Final color with includes sdf + fog\n    vec3 fc = vec3(fog);\n\n\n    //fc -= abs(log(tan(color))); //different transitioning of color   \n    fc -= tan(color);\n    \n    // Output to screen\n    fragColor = vec4(fc, color);\n*/\n\n\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 72, 72, 103], [109, 127, 146, 171, 595], [598, 612, 647, 647, 904], [910, 910, 967, 1017, 1963]], "test": "error"}
{"id": "MtGyW3", "name": "Signed Distance to Polygon", "author": "nr4", "description": "Filled 2d Polygons. Suggestions for optimization welcome :)\n", "tags": ["2d", "sdf", "polygon"], "likes": 10, "viewed": 179, "published": "Public", "date": "1537922459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Signed Distance to Polygon\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Got rid of the if(.) by using step functions\n\n// (Un)Comment this for different look\n#define DRAW_GEOMETRY\n// More points = cooler\n#define N 32\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Standard shadertoy fill color\nvec3 col(vec2 uv, float o)\n{\n    return 0.5 + 0.5*cos(o+uv.xyx+vec3(0,2,4));\n}\n\n// Distance to specific polygon\nfloat polygon(vec2 x)\n{\n    vec2 pts[N];\n\tfloat ret = 1., n = 0.;\n    \n    for(float i=0.; i<float(N); i+=1.)\n    \tpts[int(i)] = -.5*c.xx+vec2(1.5*rand(i*c.xx)+.25*cos(rand(3.*i*c.xx)*iTime), rand(2.*i*c.xx)+.25*sin(rand(3.*i*c.xx)*iTime));\n    \n    for(int i=0; i<N; ++i)\n    {\n        int ip1 = int(mod(float(i+1), float(N)));\n        vec2 k = x-pts[i], d = pts[ip1]-pts[i];\n        \n        float beta = k.y/d.y,\n            alpha = d.x*k.y/d.y-k.x;\n        \n        n += step(0., beta)*step(beta, 1.)*step(0., alpha);\n        ret = min(ret, lineseg(x, pts[i], pts[ip1]));\n    }\n    \n    return mix(ret, -ret, mod(n, 2.));\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Add the polygon to a scene\nvec4 scene(vec2 x)\n{\n    vec4 sdf = vec4(polygon(x), col(x, 3.+iTime));\n    sdf = add(sdf, vec4(stroke(sdf.x, .003), col(x, 5.+iTime)));\n    return sdf;\n}\n\n// Draw everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    vec4 s = scene(uv);\n\tvec3 col = \n#ifdef DRAW_GEOMETRY\n        mix(s.gba,\n#endif\n            mix(col(uv, iTime), col(uv, 1.+iTime), .5+.5*sign(s.x))\n            *smoothstep(1.5/iResolution.y, -1.5/iResolution.y, .001*sin(2.*pi*50.*s.x))\n#ifdef DRAW_GEOMETRY\n            , \n            smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, s.x)\n           )\n#endif\n    \t;\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGyW3.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[978, 995, 1016, 1016, 1086], [1088, 1116, 1157, 1157, 1249], [1251, 1288, 1320, 1320, 1343], [1345, 1378, 1406, 1406, 1456], [1458, 1490, 1513, 1513, 2117], [2119, 2168, 2198, 2198, 2340], [2342, 2372, 2392, 2392, 2526], [2528, 2547, 2602, 2602, 3045]], "test": "error"}
{"id": "MtGyWt", "name": "Window of static", "author": "Shmish", "description": "this is spaghetti code ", "tags": ["static"], "likes": 4, "viewed": 109, "published": "Public", "date": "1538082881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//static and random color generation - shmish\n\nfloat random (vec2 rndpos) {\n    return fract(sin(dot(rndpos.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 display = fragCoord.xy;\n    display.x = display.x/iResolution.x;\n    display.y = display.y/iResolution.y;\n    float time = iTime*0.01;\n    float timestatic = iTime*5.0;\n    float pixelscale = 0.1;\n    float xpos = pixelscale;\n    float xneg = 0.00;\n    float ypos = pixelscale;\n    float yneg = 0.00;\n    vec3 randomfactor = vec3(100.0, 100.0, 100.0);\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.00);\n\n    // color stuff\n    for(int counter = 0; counter <= 99; counter++)\n    {\n        float rndr = fract(sin(xpos*time)*randomfactor.x);\n        float rndg = fract(sin(xpos*time)*randomfactor.y);\n        float rndb = fract(sin(xpos*time)*randomfactor.z);\n\n        color.r = rndr;\n        color.g = rndg;\n        color.b = rndb;\n\n        /*color.r = color.r+0.03;\n        color.g = color.r+0.04;\n        color.b = color.r+0.04;*/\n\n        if(display.x < xpos && display.x > xneg && display.y < ypos && display.y > yneg)\n        {\n            fragColor = color;       \n        }\n\n        xpos = xpos+pixelscale;\n        xneg = xneg+pixelscale;\n\n        if(xpos >=1.1)\n        {\n            ypos = ypos+pixelscale;\n            yneg = yneg+pixelscale;\n            xpos = pixelscale;\n            xneg = 0.0;\n            randomfactor.x = randomfactor.x+25.0;\n            randomfactor.y = randomfactor.y+30.0;\n            randomfactor.z = randomfactor.z+35.0;\n        }\n    }\n    // base border\n    if(display.x < 0.209 || display.x < 1.0 && display.x > 0.79\n        || display.y < 0.3 || display.y < 1.0 && display.y > 0.7)\n    {\n        fragColor = vec4(0.05, 0.05, 0.05, 1.0);\n    }\n\n    // background static\n    if(display.x < 0.78 && display.x > 0.22 && display.y < 0.68\n        && display.y > 0.32)\n    {\n                vec2 rndposs = fragCoord.xy/iResolution.xy;\n                float rnd = random( rndposs*timestatic );\n                fragColor = vec4(vec3(rnd),1.0);     \n    }\n    // top right border\n    if(display.x < 0.78 && display.x > 0.765 && display.y < 0.68\n        && display.y > 0.32)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    if(display.x < 0.78 && display.x > 0.22 && display.y < 0.68\n        && display.y > 0.655)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    // bottom left border\n    if(display.x < 0.225 && display.x > 0.22 && display.y < 0.68\n        && display.y > 0.32)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    if(display.x < 0.78 && display.x > 0.22 && display.y < 0.325\n        && display.y > 0.318)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 75, 75, 186], [188, 188, 245, 245, 2792]], "test": "valid"}
{"id": "MtGyz3", "name": "Lissajous Curves", "author": "Tantor", "description": "A simple shader to visualize Lissajous figures.", "tags": ["math", "geometry", "lissajous"], "likes": 3, "viewed": 112, "published": "Public", "date": "1537096753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592\n#define ratio (2.0/3.0)\n#define speed 2\n#define offset (pi*0.0)\n#define radius 0.45\n#define trail (pi*3.0)\n#define detail 20\n#define thickness 0.01\n\nvec2 get_point(float time) {\n\tvec2 p;\n\tp.x = cos(time * float(speed));\n\tp.y = sin(time * float(speed) * float(ratio) + float(offset));\n\tp *= float(radius);\n    return p;\n}\n\nfloat point_linesegment_dist(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    float l_sq = dot(ab, ab);\n    if (l_sq <= 0.000001)\n        return distance(p, a);\n    vec2 ap = p - a;\n    float proj = dot(ap, ab) / l_sq;\n    proj = clamp(proj, 0.0, 1.0);\n    vec2 pp = a + proj * ab;\n        \n    return distance(p, pp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    float on_line = 0.0;\n    const float inv_detail = (1.0 / float(detail));\n\tfor\t(float t = 0.0; t >= -float(trail); t -= inv_detail) {\n        // t is the offset back in time to look at where the curve was\n\t\tvec2 p0 = get_point(iTime + t);\n\t\tvec2 p1 = get_point(iTime + t - inv_detail);\n        \n        float trail_amount = 1.0 + (t / float(trail));\n\n        float dist = point_linesegment_dist(uv, p0, p1);\n        float coverage = 1.0 - dist / (float(thickness) * trail_amount);\n        coverage *= sqrt(trail_amount); // Fade out the trail\n        on_line = max(on_line, coverage);\n\t}\n\n\tvec3 color = mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 1.0, 0.0), on_line);\n\n\tfragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 197, 197, 340], [342, 342, 396, 396, 664], [666, 666, 722, 747, 1525]], "test": "valid"}
{"id": "MtKcDt", "name": "Pie Chart", "author": "unbird", "description": "Simple pie chart.", "tags": ["2d", "chart", "shape", "pie"], "likes": 7, "viewed": 610, "published": "Public", "date": "1538228880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/MtKcDt\n\n#define ANIMATE 1\n\n// number of parts\n#define COUNT 5\n// automatically close the chart to full circle\n#define CLOSED 1\n\n// angles for each pie slice in radians\nconst float angles[COUNT] = float[5](0.1,0.2,0.3,0.4,0.5);\n\n\n// constants\n#define PI 3.1415926535897932384626433832795\n\nconst vec4 Red = vec4(1,0,0,1);\nconst vec4 LightRed = vec4(1,0.8,0.8,1);\nconst vec4 Yellow = vec4(1,1,0,1);\nconst vec4 Green = vec4(0,1,0,1);\nconst vec4 LightGreen = vec4(0.8,1.0,0.8,1);\nconst vec4 Blue = vec4(0,0,1,1);\nconst vec4 LightBlue = vec4(0.8,0.8,1,1);\nconst vec4 White = vec4(1,1,1,1);\nconst vec4 Gray = vec4(0.5,0.5,0.5,1);\nconst vec4 Black = vec4(0,0,0,1);\nconst vec4 TransparentWhite = vec4(1,1,1,0);\nconst vec4 Brown = vec4(0.8, 0.4, 0.2,1);\n\n// pie sclice colors\nconst vec4 colors[COUNT] = vec4[5](Red,Green, Blue, Yellow, LightBlue);\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat pie(vec2 p, float angle)\n{\n\tvec2 n = vec2(-cos(angle), sin(angle));\n\treturn p.x * n.x + p.y*n.y;\n}\n\nfloat sceneDist(vec2 p, inout vec4 color)\n{    \n    float time = iTime;    \n\tvec2 center = iResolution.xy / 2.0;\n    p = p - center;\n    \n    float a[COUNT];    \n\n    for(int i = 0; i < COUNT; i++)\n    {\n#ifdef ANIMATE\n        a[i] = 2.0*angles[i] + angles[i] * cos(time * float(i+1) + float(i));                                               \n#else\n        a[i] = angles[i];\n#endif\n    }\n    \n    float cc = 0.0;\n    float start = 0.0;\n    float circle = length(p) - center.y * 0.9;    \n    \n    for(int i = 0; i < COUNT + CLOSED; i++)\n    {\n        float end;\n        vec4 pieColor;        \n\t\tif(i == COUNT)\n        {\n            end = 2.0 * PI;\n            pieColor = Gray;\n        }\n        else\n        {\n            end = start + a[i];\n            pieColor = colors[i];\n        }                \n    \t\n        float c = pie(p, start);    \n        float c2 = pie(p, end);    \n        float delta = end - start;\n        if(delta < PI)\n        \tcc = intersect(c,1.0 - c2);\n        else\n            cc = merge(c,1.0 - c2);\n        cc = intersect(circle, cc);\n        color = mix(color, pieColor, clamp(1.0-cc,0.0,1.0) );\n        start = end;\n    }    \n    \n\treturn cc;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t// background\t\n\tvec4 col = vec4(0.2, 0.2, 0.4, 1.0);\n\tfloat dist = sceneDist(p, col);\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[779, 874, 911, 911, 934], [936, 936, 969, 969, 992], [994, 994, 1026, 1026, 1098], [1100, 1100, 1143, 1143, 2272], [2275, 2275, 2332, 2332, 2527]], "test": "valid"}
{"id": "MtKcDy", "name": "Satisfying cube pattern", "author": "Caesar", "description": "I was playing around with shadertoy(great name btw) and this was the effect. Even though it is quite simple it looks very satisfying. ", "tags": ["cube", "colorful", "animation", "pattern", "satisfying"], "likes": 3, "viewed": 113, "published": "Public", "date": "1537626332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool inRange(float val, vec2 range){\n\tif(val >= range.x && val <= range.y)\n        return true;\n    return false;\n}\n\nbool inQuad(vec2 pos, vec2 size){\n\tif(inRange(pos.x, vec2(0.0, size.x)) && inRange(pos.y, vec2(0.0, size.y)))\n        return true;\n    return false;\n}\n\nbool inQuad(vec2 pos, vec2 off, vec2 size){\n\tif(inRange(pos.x, vec2(off.x, off.x+size.x)) && inRange(pos.y, vec2(off.y, off.y+size.y)))\n        return true;\n    return false;\n}\n\nfloat oscillate(vec2 range, float speed, float offset){\n\tfloat d = range.y-range.x;\n    \n    d *= (sin(offset+iTime*speed)/2.0 + 0.5);\n    \n    return range.x + d;\n}\n\nvec3 drawQuad(vec2 pos, vec2 quadSize, vec2 offset, vec3 color){\n\tif(inQuad(pos, offset, quadSize))\n        return color;\n    return vec3(0, 0, 0);\n}\n\n\n    vec2 quadSize = vec2(0.25, 0.25);\n    float speed = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.y/iResolution.x;\n    uv.y *= aspectRatio;\n    float scale = 0.3;\n    uv /= scale;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 offset = vec2(0, 0);        \n    vec3 color = vec3(0, 0, 0);\n    float stage = 0.0;\n    \n    for(int i = 0; i < 60; i++){\n        offset.x = -1.0 + float(i)*0.1 + oscillate(vec2(0.0, 1.0-quadSize.x), speed, stage);\n        stage += 3.14/1.0;\n        \n        for(int j = 0; j < 30; j++){\n            offset.y = -1.0 + float(j)*0.1 + oscillate(vec2(0.0, 1.0-quadSize.x), speed, 0.0);\n            \n        \tif(inQuad(uv, offset, quadSize)){\n        \t\tif(length(color) > 0.0)\n                    color = vec3(0, 0, 0);\n             \telse\n               \t\tcolor = col;\n        \t}\n        }\n    }\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 115], [117, 117, 150, 150, 267], [269, 269, 312, 312, 445], [447, 447, 502, 502, 612], [614, 614, 678, 678, 763], [828, 828, 885, 885, 1741]], "test": "valid"}
{"id": "MtKczG", "name": "hextacy", "author": "elenzil", "description": "Just fooling around with IQ's hexagon function", "tags": ["hexagaons"], "likes": 18, "viewed": 637, "published": "Public API", "date": "1536815246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Just fooling around with IQ's hexagon function\n// Orion Elenzil 2018\n\n#define PI    (3.14159265359)\n#define TWOPI (2.0 * PI)\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\n// 2d cell ID, distance to border, distance to center\nvec4 square(vec2 p) {\n    p = p * 0.71;\n    \n\tvec2 pi = floor(p + vec2(0.5));\n\tvec2 pf = fract(p);\n    \n    \n    float e = 2.0 * min(abs(pf.x - 0.5), abs(pf.y - 0.5));\n    // i've clearly chosen the wrong coordinate system somewhere\n    float f = 1.0 * length(fract(p - vec2(0.5)) - vec2(0.5));\n    return vec4(pi, e, f);   \n}\n\nvec4 shape(vec2 p) {\n//    if (int(iTime / 5.0) % 2 == 0) {\n        return hexagon(p);\n//    }\n//    else {\n//        return square(p);\n//    }\n}\n\nmat2 rot(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x /= iResolution.y / iResolution.x;\n    vec2 uvPlain = uv;\n    float t = iTime * 0.01;\n    uv.x += cos(t) * 20.0;\n    uv.y += sin(t) * 20.0;\n    uv *= 4.0;\n    \n    vec4 h = shape(uv);\n    float q0 = float(abs(int(h.y * h.x)) % 5 - 1);\n    q0 += q0 >= 0.0 ? 1.0 : 0.0;\n    \n    uv = h.xy + uv * q0 * 0.7;\n    h = shape(uv);\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(1.0);\n    float q1 = float(int(h.y * h.x) % 10 - 3);\n    float q2 = smoothstep(-0.5, 0.5, sin((h.z * 25.0 + (q1 * 2.0 - 1.0) * -iTime * 0.7)));\n    q2 = q1 == 0.0 ? q2 : 1.0 - q2;\n    q2 = q2 * 0.25 + 0.5;\n    col *= q2;\n    if (h.z > 0.3) {\n\t    col.x *= h.w * 5.0 - q1 * 0.2;\n    }\n    \n    for (int n = 2; n >= 0; --n) {\n        vec2 uvVignette = uvPlain * vec2(2.0, 2.0);\n        uvVignette *= 1.0 - (float(n) / 7.6);\n        uvVignette *= rot(iTime * 0.1 * (n % 2 == 0 ? -1.0 : 1.0));\n        h = shape(uvVignette);\n        if (h.x == h.y && h.x == 0.0) {\n            if (n == 0) {\n\t            col *= smoothstep(0.0, 0.2, h.z);\n            }\n            float fn = float(n);\n            col += smoothstep(0.02 / (fn + 1.0), 0.0, abs(h.z - 0.03)) * \n                (vec3(0.3) + 0.4 *\n                 vec3(sin(iTime + float(n) + TWOPI * 0.0 / 3.0),\n                      sin(iTime + float(n) + TWOPI * 1.0 / 3.0),\n                      sin(iTime + float(n) + TWOPI * 2.0 / 3.0)));\n        }\n        else {\n            col *= 0.6;\n            vec3 grad = vec3(dFdx(h.z), dFdy(h.z), 0.0);\n            grad.z = (grad.x + grad.y) * 0.5;\n            col.zyx += grad * 10.0;\n        }\n    }\n    \n    if (h.x == h.y && h.x == 0.0) {\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 311, 336, 336, 847], [849, 903, 924, 924, 1229], [1231, 1231, 1251, 1290, 1376], [1378, 1378, 1401, 1401, 1485], [1487, 1487, 1544, 1594, 3340]], "test": "valid"}
{"id": "MtKyDK", "name": "counters", "author": "teraspora", "description": "This shader  will print numbers on the screen if it is so commanded.", "tags": ["numbers"], "likes": 1, "viewed": 503, "published": "Public API", "date": "1537910967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 John Lynch\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so, subject\n// to the following conditions: The above copyright notice and this permission\n// notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Counters - a fragment shader in OpenGL, built on shadertoy.com;\n// Function: display numbers;\n// Author: John Lynch (@teraspora);\n// Date: 25 SEP 2018.\n\nint num;\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n\nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// bitmaps of the 10 decimal digits, given in octal for ease of visualisation\nconst uint[] digits = uint[](07642424276u, 01010101010u, 07602764076u, 07602760276u,\n                             04040447604u, 07640760276u, 04040764276u, 07602020202u,\n                             07642764276u, 07642760202u);\n    \nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\n// return the biggest prime less than n:\nint largestPrimeLessThan(int n) {\n    if (n < 3) return 2;\n\tbool prime[1000];\n    for (int i = 0; i < prime.length(); i++) {\n    \tprime[i] = true;\n    }    \n    for (int p = 2; p * p <= n; p++) { \n        if (prime[p]) { \n            for (int i = p * 2; i <= n; i += p) \n                prime[i] = false; \n        } \n    } \n\tfor (int i = n - 1; i >= 0; i--) {\n    \tif (prime[i]) return i;\n    }    \n}\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 2.;\n    float numTiles = tileDim * tileDim;\n    \n    // some shorter names:\n    float resx = iResolution.x;\n    float resy = iResolution.y;\n    vec2 f = fragCoord.xy;\n    vec2 hr = iResolution.xy / tileDim;\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 1.02;\n    \n    // ===============================================================\n    // the output vector giving the position the program needs to know!-\n    vec2 pp = f;\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(f.x / resx * tileDim)), float(int(f.y / resy * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.;\t// start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    vec3 col;\n    // ===============================================================\n    \n    // Main code here:\n    \n    int t = int(iTime);\n    float level = mod(iTime, 30.);\n    \n    switch(int(tile)) {\n        case 1:\n        num = t;\n        \tcol = mix(gold, blue, sqrt(abs(sin(q.y))));\n        \tcol.g *= ((cos(iTime / 2.) + 1.) * 0.5);\n    \t\tnum = t;\n    \t\tbreak;\n        case 0:\n        \tcol = mix(orange, yellow, sin(q.y));\n        \tcol.b = (-sin(iTime / 3.) + 1.) * 0.5;\n    \t\tnum = t * t;\n        \tbreak;\n        case 2:\n        \tcol = mix(cyan, crimson, sin(q.y));\n        \tcol.g *= ((-cos(iTime / 5.) + 1.) * 0.5);\n    \t\tnum = largestPrimeLessThan(t);\n        \tbreak;\n        case 3: \n        \tcol = mix(yellow, magenta, sin(q.y));\n        \tcol.g *= ((sin(iTime / 7.) + 1.) * 0.5);\n    \t\tnum = int(pow(2., floor(level)));\n            // shift askew for fun!\n        \tq = rotate(q, PI * 0.015 * (fract(iTime / 60.) < 0.5 ? 1. : -1.));\n        \t// when each new cycle's coming rotate 2pi in 5 secs\t\n        if (level > 25.) q = rotate(q, TWO_PI * 0.2 * (level - 25.));\n            break;\n    }    \n    // We'll store the bitmaps of each digit here, pulling them out of\n    // the digits[] array where they've been put:\n    float rows = 5.;\n    float columns = 54.;\n    // width and height of a digit in rows of bit-blocks\n    float dw = 6.;\n    float dh = 5.;\n    \n    // populate an array with bitmaps for the appropriate digits:\n    uint[] bitmap = uint[10](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u);\n    for (int i = 0, divisor = 100000000; i < 9; i++, divisor /= 10) {\t\n        int m = num / divisor;\n    \tbitmap[i] = digits[m];\n        num -= m * divisor;\n    }\n    // Note: I wasted a lot of time using floats here and getting\n    // numerical errors with large numbers.\n    // Even tried making them all highp.\n    // Eventually realised the only way was back to ints (which I would\n    // certainly have used in any other language!)\n    \n    vec2 box = vec2(0.9, 0.2);\n    vec2 padding = (-box + 1.) / 2.;\n    \n    // if fragCoord is inside the numeric display box, work out where that maps to\n    // in the grid, get the appropriate bit (the tricky bit ;) ) and \"AND\" it with the base colour\n    if (q.x >= -0.5 + padding.x && q.x < 0.5 - padding.x\n        \t&& q.y >= -0.5 + padding.y && q.y < 0.5 - padding.y) {\n        \n    \tvec2 p = (q * vec2(1., -1.) + vec2(0.5, 0.5) - padding) / box;\n        float bx = float(p.x * columns);\n        float by = float(p.y * rows);\n        float place = bx / dw;\n        float dx = bx - floor(place) * dw;\n        float dy = floor(by);\n        uint digit = bitmap[int(place)]; \n        int bitx = int(dy * dw + dx);\n        int charSize = int(dw * dh);\n        bitx = charSize - bitx ;\n        col *= (1. - float((digit >> bitx) & 1u));        \n    }       \n    \n    // End main code. \n    \n    \n    // ===============================================================\n    // rotate the frame in sync but opposite in sense to the contact rotating\n    if (tile == 3. && level > 25.) {\n        pp = rotate(pp - hr * 0.5, TWO_PI * -0.2 * (level - 25.)) + hr * 0.5;\n    }\n    \n    \n    \n    \n    // ===============================================================\n    // Make a border: 8px solid black; with line inset:\n    float b = 6.;   // border width    \n    vec3 borderInsetLineColour = white;\n    \n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = borderInsetLineColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = borderInsetLineColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));    \n    \n    // and finally return the colour:\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyDK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1920, 2231, 2250, 2250, 2279], [2281, 2281, 2313, 2313, 2360], [2362, 2362, 2390, 2390, 2455], [2457, 2457, 2489, 2489, 2530], [2532, 2573, 2606, 2606, 2973], [2975, 2992, 3049, 3118, 8075]], "test": "error"}
{"id": "MtKyDR", "name": "Noise + Noise raymarching", "author": "DeadMan", "description": "This is a raymarcher that visualizes a noise function using the sound from a song as an input.\nInspiration: https://www.shadertoy.com/view/4ddXW4", "tags": ["raymarching", "music"], "likes": 0, "viewed": 301, "published": "Public", "date": "1535853518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DISTANCE 50.0\n#define STEP 0.0\n#define STEPINC 0.00005\n#define SEED 10283.2\n#define PERSISTENCE 1.0\n#define SPEED 3.0\n#define BRIGHTNESS 1.0\n#define SPEC_POW 100.0\n#define SPEC_INTENSITY 10.0\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\nfloat noise(vec3 x) {\n\tconst vec3 Step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, Step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(Step, vec3(0, 0, 0))), hash(n + dot(Step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(Step, vec3(0, 1, 0))), hash(n + dot(Step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(Step, vec3(0, 0, 1))), hash(n + dot(Step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(Step, vec3(0, 1, 1))), hash(n + dot(Step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat getNoise(vec3 loc){\n    return noise(vec3(loc * PERSISTENCE) + vec3(SEED + texture(iChannel0, (loc.xy * 0.01) - vec2(0.5)) * 10.0)) * (length(loc.xy));\n}\n\nvec3 getNormal(vec3 pos){\n\tvec2 eps = vec2(1.0, 0.0);\n\n\tvec3 nor = vec3(getNoise(pos + eps.xyy) - getNoise(pos - eps.xyy),\n\t\t\tgetNoise(pos + eps.yxy) - getNoise(pos - eps.yxy),\n\t\t\tgetNoise(pos + eps.yyx) - getNoise(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord / iResolution.xy;\n    vec2 screenPos = UV * 2.0 - vec2(1.0);\n\tvec3 camLoc = vec3(0, 0, iTime * SPEED);\n    vec3 calcDir = vec3(screenPos.x, screenPos.y * (iResolution.y / iResolution.x), 1.0);\n    \n    Ray mainRay;\n    mainRay.origin = camLoc;\n    mainRay.direction = calcDir;\n    \n    float dist = 0.0;\n    \n    float brightness = 0.0;\n    \n    float stepDist = STEP;\n    vec3 location;\n    \n    for(float t = 0.0; t < DISTANCE; t += stepDist){\n        location = mainRay.origin + (mainRay.direction * t);\n        if(getNoise(location) > 0.99){\n            /*while(getNoise(location) > 0.5){\n                t -= 0.01;\n                location = mainRay.origin + (mainRay.direction * t);\n            }*/\n            dist = t / DISTANCE;\n            vec3 norm = getNormal(location);\n            \n            vec3 dirToCam = normalize(location - camLoc);\n            \n            brightness = clamp(dot(dirToCam, norm), 0.0, 1.0);\n            \n            vec3 refVec = reflect(norm, dirToCam);\n            \n            float spec = pow(clamp(-dot(refVec, dirToCam), 0.0, 1.0), SPEC_POW) * SPEC_INTENSITY;\n            \n            brightness += spec;\n            \n            brightness *= 1.0 / (t);\n            \n            brightness *= BRIGHTNESS;\n            \n            break;\n        }\n        stepDist += STEPINC;\n    }\n    \n    vec3 color = 0.5 + 0.5*cos((iTime*2.0)+location+vec3(0,2,4));\n    \n    // Output to screen\n    //fragColor = vec4(snoise(vec4(UV * PERSISTENCE, 1023.0, 210.4)));\n    fragColor = vec4(brightness * color, 1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 275, 305], [306, 306, 326, 326, 414], [417, 417, 438, 438, 1178], [1180, 1180, 1205, 1205, 1339], [1341, 1341, 1366, 1366, 1598], [1600, 1600, 1657, 1657, 3229]], "test": "error"}
{"id": "MtKyWd", "name": "Philosopher Stoned", "author": "stb", "description": "Mouse-enabled!", "tags": ["3d", "fractal", "ray", "marching", "kaleidoscopic", "kifs", "function", "system", "iterated"], "likes": 29, "viewed": 532, "published": "Public", "date": "1538232749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tPhilosopher Stoned\n\tstb - late September 2018\n\n*/\n\nconst int\tMaxRaySteps\t= 128;\t\t// # ray steps b4 bailout\nconst float\tMaxDist\t\t= 3.3;\t\t// ray distance b4 bailout\nconst float\tFudgeFactor\t= 1.;\t\t// accuracy/speed\n#define\tAccuracy\t2. / iResolution.x\t// ray marching surface threshold\n#define NormAcc\t\t2. / iResolution.x\t// surface normal accuracy\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\nvoid rotateXY(inout vec3 p, vec2 axy) {\n    p.yz = rotate(p.yz, axy.y);\n    p.xz = rotate(p.xz, axy.x);\n}\n\nvec3 fold(in vec3 p, in vec3 n) {\n    n = normalize(n);\n    p -= n * max(0., 2.*dot(p, n));\n    return p;\n}\n\nfloat mapDE(in vec3 p) {\n\tfloat f;\n    \n    const float I = 64.;\n    for(float i=0.; i<I; i++) {\n        rotateXY(p, vec2(10.-.024273*iTime, .0045*iTime));\n        //p = abs(p);\n        \n        p = fold(p, vec3(1., -1., 0.));\n        p = fold(p, vec3(-1., 0., -1.));\n        p -= .125*.025 / ((i+1.)/I);\n        \n    }\n    \n    f = length(p)-.007;\n    return f;\n}\n\nvec3 mapSky(in vec3 p) {\n    p = normalize(p);\n    return\n        max(\n            vec3(0.),\n            1.25 * vec3(1., 1.2, 1.5)\n            * vec3(.5+.25*(sin(3.*p.x)+sin(3.*p.y)))\n            + vec3(.4, .2, .1)\n            - .25\n       \t);\n}\n\nvec3 getNorm(vec3 p) {\n\tvec3 d = vec3(NormAcc, -NormAcc, 0.);\n    return normalize(vec3(mapDE(p+d.xzz) - mapDE(p+d.yzz), mapDE(p+d.zxz) - mapDE(p+d.zyz), mapDE(p+d.zzx) - mapDE(p+d.zzy)));\n}\n\n// uses iq's soft shadows\n/*float getShadow(vec3 hit, vec3 lightDir, float lightDist) {\n\tfloat dist;\n\tfloat k = 132.; // shadow hardness\n\tfloat totalDist = 2. / k; // starting distance based on shadow hardness\n\tfloat res = 1.;\n\tfor(int steps=0; steps<MaxRaySteps; steps++) {\n\t\tvec3 P = hit + totalDist * lightDir;\n\t\tdist = mapDE(P);\n\t\tif(dist < Accuracy) return 0.;\n        if(totalDist >= min(MaxDist, lightDist)) break;\n\t\tres = min(res, k*dist/float(steps));\n\t\ttotalDist += dist;\n\t}\n\treturn res;\n}*/\n\n// source lost; if this is yours, speak up :)\nfloat getAO(vec3 hit, vec3 norm) {\n    const float ns = 16.;\n    float AO = 0.;\n    float d = .1;\n    for(float i=1.; i<ns; i++) {\n    \tfloat dist = mapDE(hit+d*norm*i/ns);\n        AO += .875 * ns / d * dist / i;\n    }\n    return clamp(AO/ns, 0., 1.);\n}\n\n\n// returns last and total distances from a ray traced from camPos to rayDir\nvec2 march(vec3 camPos, vec3 rayDir) {\n\tfloat dist;\n\tfloat totalDist = 0.;\n\tvec3 p;\n\tfor(int steps=0; steps<MaxRaySteps; steps++) {\t\n\t\tp = camPos + totalDist * rayDir;\n\t\tdist = mapDE(p) * FudgeFactor;\n        totalDist += dist;\n\t\tif(dist<Accuracy || totalDist>MaxDist) break;\n\t}\n    return vec2(dist, totalDist);\n    \n}\n\nvec3 getColor(vec3 hit, vec3 rayDir, vec2 dists) {\n    \n    vec3 col = vec3(0.);\n    \n    // a surface was hit, do some shading\n    if(dists.x < Accuracy) {\n\t\tvec3 norm = getNorm(hit);\n\n        vec3 diffuse = vec3(1., .7, .5) * mapSky(norm);\n        \n        // angle of incidence\n        float aoi = pow(1.-dot(norm, -rayDir), 1.);\n        \n        // ambient occlusion\n        float ao = pow(getAO(hit, norm), 4.) * 2.;\n        \n        // initial color\n        col = diffuse;\n        \n        // reflected sky\n        vec3 ref = mapSky(normalize(reflect(rayDir, norm)));\n\t\t\n        // mix in reflections\n        col = mix(col, ref, aoi);\n        \n        // apply ao\n        col *= ao;\n        \n        // mix sky into color (fog effect)\n        col = mix(col, mapSky(rayDir), pow(dists.y/MaxDist, 2.));\n        \n    } else {\n        // return sky only, for there's nothing else\n        col = mapSky(rayDir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv\t\t= (fc-.5*res) / res.y;\n    vec2 mPos\t= (iMouse.xy-.5*res) / res.y;\n\t\n    vec3 rayBeg\t\t= vec3(0., 0., -3.);\n    vec3 rayDir\t\t= normalize(vec3(uv, 1.*2.));\n    \n    vec2 camRotXY = iMouse.z > 0. ? 4. * mPos.xy : vec2(.75+.0353*iTime, .75+.0485*iTime);\n    rotateXY(rayBeg, camRotXY);\n    rotateXY(rayDir, camRotXY);\n    \n    vec2 dists\t= march(rayBeg, rayDir);\n    vec3 hit\t= rayBeg + dists.y * rayDir;\n    vec3 col = getColor(hit, rayDir, dists);\n    \n\tfo = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 421, 460, 460, 526], [528, 528, 561, 561, 635], [637, 637, 661, 661, 1001], [1003, 1003, 1027, 1027, 1248], [1250, 1250, 1272, 1272, 1440], [1945, 1991, 2025, 2025, 2244], [2247, 2323, 2361, 2361, 2642], [2644, 2644, 2694, 2694, 3584], [3586, 3586, 3629, 3629, 4144]], "test": "valid"}
{"id": "MtVcWt", "name": "fast diagonal mirror  TLjX+", "author": "ollj", "description": "a fast diagonal mirror is doable by\n ;u=mix(u,vec2(-u.y,u.x),step(abs(u.y),abs(u.x)))\n==\n;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\ncan remove one of the 2 , or both, abs() to remove a mirror, for a T, L  or j shape\nan X or + shape is 2 abs()", "tags": ["uv", "mirror", "fold", "symmetry", "microchip", "diagonal"], "likes": 0, "viewed": 434, "published": "Public API", "date": "1538212276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\nthe whole shape is a single sqrt(), because it is the same single circle\n, mirrored diagonally, stretched, and in a modular-interval\n\nmain feature of this shader is to mirror uv diagonally,twice, via:\n;u=mix(u,u.yx*vec2(-1,1),step(abs(u.y),abs(u.x)))\n//which should be identical to:\n;if(abs(u.y)<abs(u.x))u=u.yx*vec2(-1,1)//dual cross diagonal mirror u\nremoving one of the abs() removes one of the diagonal mirrors?\n\nthe older feature of this shader os to use mStretch() to stretch a circle into a capsule.\n\nthe older feature of this is pModR() == a modulo within an interval, which is inspired by [hg_sdf]\n*/\n\n//for a straight/horizontal central part search for \"mstretch\",the mstretch()function\n\n//repeated intervals\n#define repeats (floor(abs(m.y*8.))+2.)\n//period length m=iMouse,scaled to scrteenspace\n#define period m.x\n\n#define ViewZoom 5.\n\n#define vec1 float\n\nvec2 fra(vec2 u){u/=iResolution.xy;u-=.5;u.x*=iResolution.x/iResolution.y;return u*ViewZoom;}\n\n\n#define pi acos(-1.)\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\nconst vec1 tau=6.2831853071795864769252867665590057683943387987502116419\n,eul=2.7182818284590452353602874713526624977572470936999595749;\n//exists as y=exp(1.)???\nconst vec2 phi=sqrt(5.)*.5+vec2(.5,-.5);\nconst vec4 vs=vec4(-1,0,1,phi.x);\n#define fr(a)fract(a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define sat(a)clamp(a,0.,1.)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\nvec1 sat2(vec1 a,vec2 m){a=.5*(sign(a)+m.x)*a+m.y;return (sign(2.-a)+1.)*(a-2.)*.5+1.;}//generalization of clamp(a,0.,1.);for m=vec2(1)\n#define dd(a)dot(a,a)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/dotpProduct.html//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nvec1 dotp(vec2 a,vec2 b){return dot(perp(a),b);}\n//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//worksafe:\nvec1 stp(vec1 a){return u5(sign(a));}//explicit step(a,b),substitutions,for a multi-context namespace\nvec1 stp(vec1 a,vec1 b){return stp(a-b);}vec1 stp(vec2 a){return stp(a.x-a.y);}//substitute step(a,b)to a differential function.\nvec1 circleY(vec2 u){return u.y-sqrt(1.-(u.x*u.x));}//i keep forgetting this one\nconst vec1 tiny=1e-7;//smallest denormalNumber>0_16bit_float is pow(2,-24);make sure that:0.<(tiny*tiny/6.75)<tiny .\nconst vec1 NINF=65536.;//near infinity;should be 1/tiny\n#define if0(a)a=mix(a,tiny,step(abs(a),tiny))\n//if(abs(a)<tiny)a=tiny\nvec1 ifu0b(vec1 u,vec1 a){return a*(1.-sign(u)*sign(u));}//if(u==0.)return a,else return 0.;\nvec1 ifu0b(vec2 u){return ifu0b(u.x,u.y);}\n//http://www.iquilezles.org/www/articles/functions/functions.htm\n//aiB()and ai()return \"almost identity\",\"0-skipping identity\",they do return 0 for u==0//ai()is branchless,aiB()is branching?\n//,but this defeats most of their purpose! to make them return something else for u==0\n//,so you MUST add+=ifu0b(u.x,m.y)above for WorkSafe<->rather having a discontinuity near 0,than diving by/0\n//to enfoce no divisions by/0 by smoothly skipping over y=f(u)-0\n//[aifs] is optional constrain to general case;keeps sign of first drivative constant.\n#define aifs m.x=max(m.x,m.y*1.5);vec1 t=u/m.x\n#define aif (2.*(m.y*(t-1.5)+m.x)-u)*t*t+m.y\n//m.x=threshold.x(cubic [aif] only exists within x<abs(m.x));m.y=abs(minimum),never return anything smaller than abs(m.y)\nvec1 aiB(float u,vec2 m){aifs;if(u<m.x)return aif;return u;}\n//special case where m.y is minimal,and m.x becomes u.y for speed.\nvec1 aiB(vec2 u){u.y=max(u.y,tiny);if(u.x<u.y*1.5){float a=u.y;u*=u*u;return a*(u.x/u.y/6.75+1.);}return u.x;}\nvec1 aiB(vec1 u,vec1 a){return aiB(vec2(u,a));}\nvec1 ai(vec1 u,vec2 m){aifs;return u+.5*(aif-u)*(1.-sign(u-m.x));}\n//A special case where m.y is minimal,and m.x becomes u.y for speed.is undefined for a=0.its trivial case AND purpose of this function\nvec1 ai(vec1 u,vec1 a){a=max(a,tiny);vec1 b=u/a;return u+(.5*(u*(b*b/6.75-1.)+a))*(1.-sign(u-a*1.5));}//...therefore a=max(a,tiny)\nvec1 ai(vec2 u){return ai(u.x,u.y);}\nvec1 ai(vec1 u){vec1 b=u/tiny;return u+(.5*(u*(b*b/6.75-1.)+tiny))*(1.-sign(u-tiny*1.5));}\nfloat almostIdentityE(float u,vec2 m){return ai(u,vec2(.1,1.)/NINF);}\n\n//unbranch\nvec1 suv(vec2 a){return a.x+a.y;}vec1 suv(vec3 a){return a.x+a.y+a.z;}vec1 suv(vec4 a){return a.x+a.y+a.z+a.w;}//dot(a,vec4(1))can be faster.\nvec1 sub(vec2 a){return a.x-a.y;}vec1 sub(vec3 a){return a.x-suv(a.yz);}vec1 sub(vec4 a){return a.x-suv(a.yzw);}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\nvec1 mul(vec2 a){return a.x*a.y;}vec1 mul(vec3 a){return a.x*a.y*a.z;}vec1 mul(vec4 a){return a.x*a.y*a.z*a.w;}\nvec1 div(vec2 a){return a.x/a.y;}vec1 div(vec3 a){return a.x/mul(a.yz);}vec1 div(vec4 a){return a.x/mul(a.yzw);}\nvec1 mav(vec2 a){return max(a.x,a.y);}vec1 mav(vec3 a){return max(a.x,mav(a.yz));}vec1 mav(vec4 a){return max(mav(a.xy),mav(a.zw));}\n#define miv(a)-mav(-a)\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n//return vec with smaller .x component\n#define equals(a,b,c)   mix(b,a,step(c,0.)+step(0.,c)-1.)\n//(c==0)?a:b\n#define greater(a,b,c)  mix(a,b,step(c,0.))\n//(c>0)?a:b\n#define less(a,b,c)     mix(a,b,step(0.,c))\n//(c<0)?a:b\n//--mirror symmetry mirror==swap outputs--\n#define unless(a,b,c)   mix(b,a,step(0.,c))\n//(a>=0)?a:b unless   =not less==equal OR greater \n#define ungreater(a,b,c)mix(b,a,step(c,0.))\n//(c<=0)?a:b ungreater=not greater==equal OR less \n#define unequal(a,b,c)  mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(c!=0)?a:b\n\n//polar\n#define r2(a)mat2(cs(a).xyyx*vs.zxzz)\n#define rs(r)mat2(sin(r+vec4(1,0,0,-1)*pi))\n//mirror p at half rotated axis==cheap SINGLE 2d rotation.\n#define cs(a)vec2(cos(a),sin(a))\n#define arg(a)atan(a.y,a.x)\n//atan2()is aka \"arg,phase\"//length()is aka \"rad,amplitude\"\n#define c2p(a)vec2(length(a),arg(a))\n//carthesian to polar\n#define p2c(z)cs(z.x)*z.y\n//polar to cartesian\n#define real(z)z.x*cos(z.y)\n//real and imaginary parts for polar z\n#define imag(z)z.x*sin(z.y)\n\nstruct v11{vec1 a;vec1 b;};\nv11 g11(vec2 a){return v11(a.x,a.y);}\nstruct v22{v11 a;v11 b;};\nv22 g22(vec2 a,vec2 b){return v22(g11(a),g11(b));}\nv22 g22(vec4 a){return v22(g11(a.xy),g11(a.zw));}\n\n#define segment(p,a,b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n//return distance of [u] from segment,from [a] to [b]\n//#define mStretch(c,m)v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//stretch nimus;positive values do not change\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//stretch plus ;negative values do not change\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n \n//interpolating in a straight box is a simple mix(a,b,t),but skewed corners split the interpolation.\n#define lin2(t,a,b,c,d)mix(mix(a,b,t.x),mix(c,d,t.x),t.y)\n//bilinear interpolation,general case with corners [a,b,c,d]\n#define bez2(t,a,b,c)lin2(t.xx,a,b,b,c)\n//return time[t] value of quadratic bezier of 3 CVs[a,b,c],happens to be a special-fold-case of bilin generalization.\n#define lin3(t,a,b,c,d,e,f,g,h)mix(lin2(t.xy,a,b,c,d),lin2(t.xy,e,f,g,h),t.z)\n//trilinear interpolation (general case,usually a special case with more symmetry is used)\n\n//simple ptterns:\n#define grid(u)mav(abs(u2(fr(u))))\n#define ss2t(a)a=abs(u2(a))//triangle wave;\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2);return float(b.x==b.y);}\nfloat checkerBool(hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5)floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n//how to transform this to a non-boolean solution with smooth borders?//multiply with a smoothstep?\n//no dummy,you do your step to smoothstep subsititutions!\n\n//fast good monochrome distance field visualization.\n//blue is grid,red and green are distance fields\nvec3 rg(vec3 c,vec2 u){vec1 fsaa=1./min(iResolution.x,iResolution.y);\n return vec3(c.rg=mix(fract(c.rg*4.),smoothstep(fsaa,-fsaa,c.rg),.5+(atan(c.rg))/acos(-1.)),grid(u));}//.b=grid \nvec4 rg(vec4 c,vec2 u){vec1 fsaa=1./min(iResolution.x,iResolution.y);\n return vec4(c.rga=mix(fract(c.rga*4.),smoothstep(fsaa,-fsaa,c.rga),.5+(atan(c.rga))/acos(-1.)),grid(u)).rgab;}//.b=grid ,.a=yellow\nvec2 gLLxX(vec2 a,vec2 b,vec2 c,vec2 d\n           //return intersection from line(a b)and line(c d).\n){d-=c;b-=a,c-=a;float e=dotp(d,b);if0(e)\n ;return a+b*dotp(d,c)/e;}\n                   //second life wiki geometry\n\n#define f32 (3.-2.*f)*f*f;\nvec1 ss(vec2 a,vec1 b){return smoothstep(a.x,a.y,b);}\nvec2 ss(vec2 a,vec2 b){return smoothstep(a.x,a.y,b);}\nvec3 ss(vec2 a,vec3 b){return smoothstep(a.x,a.y,b);}\n\n\nvec2 ff(vec1 a){return vec2(fract(a),floor(a));}\nvec4 ff(vec2 a){return vec4(fract(a),floor(a));}\n\n//hg_sdf\n//for pMix [s] sets period length\nv11 pMod(vec1 u,vec1 s){return g11(ff(u/s+.5)*vec2(s,1));}\n                   //.a            is in-tile fract().b            is tileID floor()\nv22 pMod(vec2 u,vec2 s){return g22((ff(u/s+.5)*vec4(s,1,1)).xzyw);}\n                   //.a.a&&.b.a are in-tile fract().a.b&&.b.a are tileID floor()\nv11 pModr(vec1 p,vec1 s,vec1 n\n          //n==number of repeats (discontinuities),where the smallest discontinuity is at [s]\n){v11 c=pMod(p,s);p=p+.5*s;return v11(mix(mix(c.a,p-s*n,step(n,c.b)),p,step(c.b,0.)),clamp(c.b,0.,n));}\n//for u<0 and u>s*n the space condinues linearily,without repetition,this is different from hg_sdf.\n//it also does not set a start,you must just shift u instead\nv11 pModR(vec1 p,vec1 s,vec1 n){v11 a=pModr(p,s,n);a.a-=s*.5;return a;}\n                   //offset the output for more utility.\n//minor flaw;for s==0.special linear case,it still splits a line in 2 segments.\n\nvec3 whitecross(vec2 u){u=abs(u);u.x=miv(u);return vec3(ss(vec2(1,-1)*3./aa,u.x));}\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}\n                   //sine rainbow with offsets\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}\n                   //triangle rainbow with offsets\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\",range [-.159 ...159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green)blue;try;p=1.+vec3(-1,0,1)*cos(iTime*.001)\nvec3 rainbow3(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)\n    //;m=vec2(0)//simple case\n ;m.x=c11(-m.x,.5)\n     //good optional bounds,sign negation for utility.\n ;m.y=c11(m.y,.159)\n     //decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow(u.x-m.x*.5,fract(m.x*.6))\n     //the .mx/2 ensures that white/green stays centred and purple stys bordered;\n ;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;vec2 v=u\n ;u.x*=m.y\n ;u.x*=iResolution.y/16.\n ;float g=cos(iTime)\n     //;g=.1//a 3rd domain as time for demoing,whould actually be constant\n//;c=gradVis(c,u,v)\n ;return c;}\n\n#define stretch2(a,b)sign(a)*max(abs(a)-b,0.)\n#define stretch(a,b)stretch2(a-b*.5,b*.5)//stretch space in positive direction so that length(u)returns a capsule\n\n#define roundCore(a)(length(max(a,0.))+mav(min(a,0.)))//rounding deform\n#define box(u,s)roundCore(abs(u)-s)//rounded box size s\n\nfloat chip(vec2 u){\n ;vec2 v=u;\n ;vec2 b=abs(u)-1.\n     //box size 1.\n ;b=vec2(dd(max(b,0.)),b.y=mav(min(b,0.)))\n     //rounded box transform,but not squarerooted\n ;float d=(b.x+b.y*b.y)\n     //roughly equal to squared distance to rounded box?\n ;u=mix(u,vec2(-u.y,u.x),step(abs(u.y),abs(u.x)))\n     //;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n//above code is squared distance to rounded box,below code mirrors space so that a dot-distance becomes the distance to 3*4 legs.\n ;float r=3.\n     //range[0..4] work fine. other ranges would need more scaling.\n ;r=floor(r)\n ;v11 a=pModR(u.x+.25*r,.5,r)//;v11 a=pModR(u.x,period,repeats)\n ;u.x=a.a\n ;//u.x=abs(u.x)//saw to pyramid, effect is neglible in most symmetries.\n ;u.y=abs(u.y)\n     //optionally remove liwer and left side legs\n ;u.y-=1.\n     //offset.y of chip legs from vec2(0)\n ;float leglength=.5+cos(iTime)*.2\n ;u.y=stretch(u.y,leglength)\n ;d=sqrt(min(d,dd(u)))\n     //central large dot\n ;return d;}\n\nvoid mainImage(out vec4 O,in vec2 u){\n ;u=fra(u)\n ;vec2 v=u;\n ;vec2 m=fra(iMouse.xy)\n ;vec2 n=fra(iMouse.zw)\n//;m-=.5\n ;m*=.2\n ;m=abs(m)\n ;float d=chip(u)\n ;d=ss(vec2(1,-1)*2./aa,abs(d-m.x)-m.y)\n ;O=vec4(d,d,d,1)\n ;}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[763, 872, 889, 889, 965], [1181, 1418, 1443, 1443, 1505], [1505, 1576, 1594, 1594, 1613], [1614, 1741, 1766, 1766, 1789], [1875, 1887, 1904, 1904, 1924], [1924, 1989, 2013, 2013, 2030], [2030, 2030, 2047, 2047, 2068], [2068, 2118, 2139, 2139, 2170], [2418, 2442, 2468, 2468, 2499], [2499, 2535, 2554, 2554, 2577], [3209, 3331, 3356, 3356, 3391], [3392, 3459, 3476, 3476, 3569], [3570, 3570, 3594, 3594, 3617], [3618, 3618, 3641, 3641, 3684], [3685, 3820, 3843, 3843, 3922], [3922, 3951, 3967, 3967, 3987], [3988, 3988, 4004, 4004, 4078], [4079, 4079, 4117, 4117, 4148], [4150, 4161, 4178, 4178, 4194], [4194, 4194, 4211, 4211, 4231], [4231, 4231, 4248, 4248, 4272], [4272, 4303, 4320, 4320, 4336], [4336, 4336, 4353, 4353, 4375], [4375, 4375, 4392, 4392, 4415], [4416, 4416, 4434, 4434, 4452], [4452, 4476, 4493, 4493, 4509], [4509, 4509, 4526, 4526, 4546], [4546, 4546, 4563, 4563, 4587], [4588, 4588, 4605, 4605, 4621], [4621, 4621, 4638, 4638, 4660], [4660, 4660, 4677, 4677, 4700], [4701, 4701, 4718, 4718, 4739], [4739, 4739, 4756, 4756, 4783], [4783, 4783, 4800, 4800, 4833], [5828, 5924, 5940, 5940, 5961], [5988, 5988, 6011, 6011, 6038], [6039, 6039, 6055, 6055, 6088], [7610, 7841, 8136, 8136, 8285], [8285, 8296, 8319, 8319, 8477], [8477, 8498, 8601, 8601, 8667], [8687, 8743, 8766, 8766, 8796], [8797, 8797, 8820, 8820, 8850], [8851, 8851, 8874, 8874, 8904], [8907, 8907, 8923, 8923, 8955], [8956, 8956, 8972, 8972, 9004], [9006, 9049, 9073, 9073, 9107], [9127, 9193, 9217, 9217, 9260], [9280, 9342, 9469, 9469, 9570], [9571, 9732, 9764, 9764, 9803], [9823, 9942, 9966, 9966, 10025], [10027, 10173, 10203, 10203, 10237], [10257, 10285, 10316, 10316, 10351], [10371, 10628, 10665, 10665, 11229], [11521, 11521, 11540, 11540, 12487], [12489, 12489, 12526, 12526, 12705]], "test": "error"}
{"id": "MtVczy", "name": "Shadow Audio Visual", "author": "Shadeyboi", "description": "Practicing oscillating colors and fog, created a cool shadow effect.", "tags": ["beginner"], "likes": 1, "viewed": 81, "published": "Public", "date": "1536847038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere - Signed Distance Function\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n// Locate objects\nfloat map(vec3 p)\n{    \n    // Sphere radius\n    float sphereSize = 0.4;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p * 1.5) * 2.5 - 1.2;\n    \n     int tx = int(q.x);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\tfft *= 2.5;\n    // Signed distance of sphere\n    float s = sphere(q, sphereSize);\n    \n    float d = 0.4 * (sin(q.x*6.*fft) * sin(q.y*5.*fft) * sin(q.z*4.*fft) );\n    \n    float rot = iTime;    \n    p *= vec3(cos(rot),-sin(rot),sin(rot));\n    //return s +wave;\n    return s+d;\n}\n\n\n// Trace rays\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0; // Distance Traveled\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p); // Locate object\n        t += d * 0.5; // Step along the ray\n    }\n    return t; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = 0.5 + 0.4*cos(iTime+uv.xyx+vec3(0,3,4));;\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n\n   \t// Create ray to fire into scene\n   \tvec3 ray = normalize(vec3(uv, 1.0));\n    \n    // Create origin of scene\n    vec3 origin = vec3(0., 0.,iTime);\n   \n    \n    // Trace any objects in the scene\n    float t = trace(origin, ray);\n    \n    // Generate fog based on distance from t\n    float fog = .9 / (1.0 + t * t * 0.4);\n    \n    // Final color with includes sdf + fog\n    vec3 fc = vec3(fog);\n\n\t\n    //fc /= cos(log(color*fft)*0.5);\n    fc -= sin(color * 1.6);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}\n", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVczy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 72, 72, 103], [106, 124, 143, 168, 664], [667, 681, 716, 716, 932], [935, 935, 992, 1042, 1761]], "test": "error"}
{"id": "MtVyWd", "name": "Dipole", "author": "wyatt", "description": "Mouse to add third charge", "tags": ["physics", "fields"], "likes": 26, "viewed": 1247, "published": "Public API", "date": "1538242458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define W 2. // frequency of wiggles\n#define Q 20. // how many wigglers\n#define I 2   // how many bones in each wiggler\n\n\n\nvec2 mouse;\nvec2 hash(vec2 p) // Dave H\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat L (vec2 p, vec2 a, vec2 b, float c) {\n    vec2 ab = b-a;\n    float l = dot(p-a,ab)/dot(ab,ab);\n    p += 0.005*normalize(vec2(-1,1)*ab.yx)*sin(c+W*l);\n    return length(p-a-ab*clamp(l,0.,1.));\n}\nvec2 Z (vec2 U) {\n\tvec2 \n        A = U-0.2*vec2(sin(.5*iTime),cos(.5*iTime)),\n        B = U-0.3*vec2(cos(.321*iTime),sin(.321*iTime)),\n        C = U-mouse;\n    vec2 F = vec2(0);\n    F -= A/dot(A,A)/length(A);\n    F += B/dot(B,B)/length(B);\n    if (iMouse.z > 0.) F += C/dot(C,C)/length(C);\n    return F;\n}\n\nfloat S (vec2 U, vec2 V) {\n    float d = 1e3;\n    V = floor(V*Q+0.5)/Q;\n    vec2 h = hash(V);\n    V += 0.5*(h*2.-1.)/Q;\n    V += 0.5*vec2(sin(iTime+10.*h.y),cos(iTime+10.*h.x))/Q;\n    vec2 z,v = V;\n    for (int i = 0; i < I; i++) {\n        z = Z (V);\n    \tv += 2.*normalize(z)/Q/float(I);\n        d = min(d, 1.5*float(3+i)/float(I+1)*L(U,V,v,-25.*iTime+W*float(i)+100.*h.x));\n        V = v;\n    }\n    return smoothstep(0.02,0.,d);\n}\nfloat E (vec2 U) {\n\tvec2 V = U;\n    float d = 0.;\n    for (int x = -2; x<= 2; x++)\n    for (int y = -2; y<= 2; y++)\n   \t    d += S(U,V + vec2(x,y)/Q);\n    return d;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    mouse = iMouse.xy;\n    U = 2.*(U-0.5*R)/R.y;\n    mouse = 2.*(mouse-0.5*R)/R.y;\n    \n    C = vec4(vec3(sin(0.3*vec3(1,2,3)*E(U))),1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 164, 164, 304], [305, 305, 348, 348, 504], [505, 505, 522, 522, 810], [812, 812, 838, 838, 1244], [1245, 1245, 1263, 1263, 1411], [1412, 1412, 1453, 1453, 1622]], "test": "valid"}
{"id": "MtVyWK", "name": "Reflective fractal", "author": "mrange", "description": "Messing around with reflections and fractals. Quite punishing for the GPU.", "tags": ["raymarching", "fractal", "reflection"], "likes": 19, "viewed": 426, "published": "Public API", "date": "1537827144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by mrange/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Messing around with reflections and fractals. I am quite new to shader programming\n//  and raymarching so while I think the code might not be very good I also think that\n//  what makes ShaderToy.com so good is that programmers are sharing what they do, \n//  big and small. I too want to share in the hope it might help someone on my level.\n// \n// Inpiration and code from shaders:\n//  https://www.shadertoy.com/view/4ds3zn (iq, fractal)\n//  https://www.shadertoy.com/view/XljGDz (otaviogood, \"skybox\")\n//  https://www.shadertoy.com/view/Xl2GDW (purton, inspiration for reflection)\n// Blogs:\n//  Raymarching explained: http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//  Distance Estimators: www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//  Cool primitives: http://mercury.sexy/hg_sdf/\n\n\n#define TOLERANCE       0.0005\n#define MAX_RAY_LENGTH  64.0\n#define MAX_BOUNCES     4\n#define MAX_RAY_MARCHES 160\n#define APOLLO          7\n\n#define AA              1 // Set to 0 if the framerate is low\n\n#define FADEINTIME      3.0\n#define FADEOUTTIME     42.0\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nvoid pR(inout vec2 p, float a) { p = cos(a)*p + sin(a)*vec2(p.y, -p.x); }\n\nfloat maxComp(in vec3 p) { return max(p.x,max(p.y,p.z)); }\n\nfloat sdSphere(in vec3 p, in float r) { return length(p) - r; }\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross(in vec3 p, float r)\n{\n  float xz = length(p.xz) - r;\n  float xy = length(p.xy) - r;\n  float yz = length(p.yz) - r;\n    \n  return min(min(xz, xy), yz);\n}\n\nfloat hollowBox(in vec3 p)\n{\n  float s = 10.0;\n  p /= s;\n  float t = iTime;\n  pR(p.xz, -t);\n  pR(p.xy, t/3.0);\n  pR(p.yz, t/5.0);\n  \n  float d = max(sdBox(p, vec3(1.0)), -sdCross(p, 0.9));\n\n  return s*d;\n}\n\nfloat apollian(vec3 p, float s)\n{\n  float scale = 1.0;\n\n  for(int i=0; i<APOLLO;i++)\n  {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n\t\t\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n\t\n  return 0.25*abs(p.y)/scale;\n}\n\nfloat obj(in vec3 p, out vec3 col, out float ref)\n{\n  p = vec3(p.z, p.y, p.x);\n  col = vec3(0.75);  \n  ref = 0.4;\n    \n  float b = sdBox(p, vec3(0.45, 0.5, 1.0));\n  if(b >= TOLERANCE*100.0)\n  {\n    return b;\n  }\n  else\n  {\n    float a = apollian(p - vec3(0.0, -0.5, 0.0), 1.17);\n    \n    float rr = 0.24;\n    float s0 = sdSphere(p - vec3(0.45, -0.2, 0.0), rr);\n    float s1 = sdSphere(p - vec3(-0.45, -0.2, 0.0), rr);\n    float s  = min(s0, s1);\n  \n    return max(b, max(a, -s));\n  }\n}\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref)\n{\n  float i   = obj(p, col, ref);\n\n  float c   = sdBox(p - vec3(0.0, -0.7 + 0.01, 0.0), vec3(2.0, 0.2, 2.0));\n\n  float s   = min(i, c);\n    \n  float hb  = hollowBox(p);\n\n  s = min(s, hb);\n\n  if (s == c)\n  {\n    col = vec3(0.75);  \n    ref = 0.4;\n  }\n  else if (s == hb)\n  {\n    col = vec3(0.2);  \n    ref = 0.0;\n  }\n\n  return s;\n\n}\n\nconst vec3 lightPos1 = 20.0*vec3(-0.3, 0.15, 1.0);\nconst vec3 lightPos2 = 20.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 getSkyColor(in vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  \n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += lightCol1 * pow(ld1, 200.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3 col;\n  float ref;\n  vec3  eps = vec3(.0001,0.0,0.0);\n  vec3 nor;\n  nor.x = distanceField(pos+eps.xyy, col, ref) - distanceField(pos-eps.xyy, col, ref);\n  nor.y = distanceField(pos+eps.yxy, col, ref) - distanceField(pos-eps.yxy, col, ref);\n  nor.z = distanceField(pos+eps.yyx, col, ref) - distanceField(pos-eps.yyx, col, ref);\n  return normalize(nor);\n}\n\nfloat rayMarch(in vec3 ro, inout vec3 rd, in float mint, in float maxt, out int rep, out vec3 col, out float ref)\n{\n  float t = mint;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance = distanceField(ro + rd*t, col, ref);\n    float tolerance = TOLERANCE * t;\n    if (distance < TOLERANCE || t > maxt) break;\n    t += max(distance, 0.001);\n    rep = i;\n  }\n  return t;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 col    = vec3(0.0);\n  float ragg2 = 1.0;\n    \n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (ragg2 < 0.01) break;\n    vec3 mat    = vec3(0.0);\n    float rscale= 0.0;\n    int rep     = 0;\n    float t     = rayMarch(ro, rd, 0.01, MAX_RAY_LENGTH, rep, mat, rscale);\n  \n    vec3 pos    = ro + t*rd;\n    vec3 nor    = vec3(0.0, 1.0, 0.0);\n    \n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      col += ragg2*getSkyColor(rd);\n      break;\n    }\n\n    float occ = pow(1.0 - float(rep)/float(MAX_RAY_MARCHES), 1.5);\n\n    vec3 ref  = reflect(rd, nor);\n      \n    vec3 ld1  = normalize(lightPos1 - pos);\n    float dif1= max(dot(nor,ld1),0.0);\n\n    vec3 ld2  = normalize(lightPos2 - pos);\n    float dif2= max(dot(nor,ld2),0.0);\n      \n    vec3 acol = vec3(0.0);\n    acol      += pow(dif1*lightCol1, vec3(0.5));\n    acol      += pow(dif2*lightCol2, vec3(0.5));\n    acol      *= occ;\n    acol      = saturate(acol);\n    acol      = pow(acol, vec3(2.0));\n    acol      *= mat;\n    \n    col        += ragg2*acol*(1.0 - rscale);\n    ragg2      *= rscale;\n\n    ro        = pos;      \n    rd        = ref;\n  }\n    \n \n  return col;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float z = 4.0*(1.0 - smoothstep(0.0, 20.0, iTime)) + 0.55;\n  vec3 ro = vec3(0.0, -0.25 + 0.5*(z - 0.55), z);\n  vec3 la = vec3(0.0, -0.25, 0.25);\n  pR(ro.xz, iTime/4.0);\n    \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n\n  float fadeIn = smoothstep(0.0, FADEINTIME, iTime);\n  //float fadeOut = 1.0 - smoothstep(FADEOUTTIME, FADEOUTTIME + FADEINTIME, iTime);\n  float fadeOut = 1.0;\n\n  fragColor = vec4(col*fadeIn*fadeOut, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVyWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1216, 1244, 1244, 1273], [1274, 1274, 1302, 1302, 1331], [1332, 1332, 1360, 1360, 1389], [1391, 1391, 1423, 1423, 1464], [1466, 1466, 1492, 1492, 1524], [1526, 1526, 1565, 1565, 1589], [1591, 1591, 1620, 1620, 1711], [1713, 1713, 1748, 1748, 1879], [1881, 1881, 1909, 1909, 2086], [2088, 2088, 2121, 2121, 2344], [2346, 2346, 2397, 2397, 2831], [2833, 2833, 2894, 2894, 3224], [3440, 3440, 3474, 3474, 4176], [4178, 4178, 4204, 4204, 4564], [4566, 4566, 4681, 4681, 4952], [4954, 4954, 4991, 4991, 6213], [6215, 6215, 6242, 6242, 6621], [6623, 6623, 6678, 6678, 7260]], "test": "valid"}
{"id": "MtVyWz", "name": "Mucous Membrane", "author": "tholzer", "description": "Something that looks like a mucous membrane...\nDon't touch it, if you have weak nerves!", "tags": ["2d", "organic", "pattern", "membrane", "mucous"], "likes": 8, "viewed": 257, "published": "Public", "date": "1535869533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Mucous_Membrane.glsl  by Antony Holzer\n// version:   v1.0  9/2018  initial release\n// original:  http://glslsandbox.com/e#48575.4 by Catzpaw\n// info:      Something that looks like a mucous membrane...\n// tags:      2d, membrane, mucous, organic, pattern\n//---------------------------------------------------------\n\n#define D 0.6\n\n#define time iTime\n#define R iResolution\n\nfloat wave(vec2 p)\n{\n  float v = sin(p.x + sin(p.y*2.) + sin(p.y * 0.43));\n  return v * v;\n}\n\nconst mat2 rot = mat2(0.5, 0.86, -0.86, 0.5);\n\nfloat map(vec2 p)\n{\n  float v = wave(p);\n  p.x += time * 0.224;  p *= rot;  v += wave(p);\n  p.x += time * 0.333;  p *= rot;  v += wave(p);\n  return abs(1.5 - v);\n}\n\nvec3 Mucous_Membrane (vec2 pos)\n{\n  vec2 uv = (pos * 2.0 - R.xy) / R.y;\n  vec2 mp = iMouse.xy / R.xy;\n  uv.y += mp.y;\n  float zoom = 18.0 - 14.0 * mp.x;\n  vec2 p = normalize(vec3(uv.xy, 2.3)).xy * zoom;\n  p.y += time * 0.2;\n  float v = map(p);\n  vec3 c = mix(vec3(0.3, 0.0, 0.1), vec3(1.0, 0.3 + map(p * 3.5) * 0.6, 0.5), v);\n  vec3 n = normalize(vec3(v - map(vec2(p.x + D, p.y)), v - map(vec2(p.x, p.y + D)), -D));\n  vec3 l = normalize(vec3(0.1, 0.2, -0.5));\n  v = dot(l, n) + pow(dot(l, n), 88.0);\n  c.g *= v*v;\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = Mucous_Membrane (gl_FragCoord.xy);\n  color = color * 0.9 +vec3(0.1);   // desaturate a bit\n  fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 437, 457, 457, 529], [578, 578, 597, 597, 741], [743, 743, 776, 776, 1270], [1272, 1272, 1329, 1329, 1467]], "test": "valid"}
{"id": "MtycDV", "name": "Raymarched Sphere - Demo", "author": "Balajanovski", "description": "Simple demo which displays a sphere above a checkerboard.\n\nGithub repository:\nhttps://github.com/Balajanovski/graphics-demo", "tags": ["raytracer", "raymarched", "sphere", "shadows", "raymarcher", "raytraced", "checkerboard", "reflections", "blinnphong"], "likes": 3, "viewed": 148, "published": "Public", "date": "1537773030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Math constants\n#define M_PI 3.1415926535897932384626433832795\n#define EPSILON 0.01f\n\n// Raymarching constants\n#define MAX_STEPS 300\n#define MAX_DIST 100.0\n#define FOV (M_PI / 2.0) // In radians\n\n// Size of a checkerboard tile\n#define CHECKERBOARD_TILE_SIZE 1.0\n\n// Collision IDs\n#define SPHERE 0\n#define PLANE 1\n\n// Signed-distance function of a sphere\nfloat sphereSDF(in vec3 pos, in float radius, in vec3 center) {\n    return length(pos + center) - radius;\n}\n\n// Signed-distance function of a plane\nfloat planeSDF(in vec3 pos, in vec4 normal) {\n    return dot(pos, normal.xyz) + normal.w;\n}\n\n// SDF of scene which tells you what you collide with\nfloat sceneSDF(in vec3 pos, out int collision_id) {\n    float d_sphere = sphereSDF(pos, 1.0, vec3(0, 0.3 * sin(iTime), 0));\n    float d_plane = planeSDF(pos, vec4(0.0, 1.0, 0.0, 2.0));\n\n    if (d_sphere <= d_plane) {\n        collision_id = SPHERE;\n        return d_sphere;\n    } else {\n        collision_id = PLANE;\n        return d_plane;\n    }\n}\n\n// SDF of scene which doesn't tell you what you collide with\nfloat sceneSDF(in vec3 pos) {\n    int collision_id;\n    return sceneSDF(pos, collision_id);\n}\n\n// Estimate the normal off of the scene sdf\nvec3 estimateNormal(in vec3 p) {\n    return normalize(vec3(\n            sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n            sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n            sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n        ));\n}\n\n// The blinn-phone BRDF\nvec3 blinnPhongContribForLight(in vec3 diffuse_color, in vec3 specular_color, in float alpha, in vec3 p, in vec3 eye,\n                          in vec3 lightPos, in vec3 lightIntensity, in float attenuation) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    // Light not visible from this point\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // Light reflection in opposite direction as viewer, apply only diffuse lighting\n    if (dotRV < 0.0) {\n        return lightIntensity * (diffuse_color * dotLN) * attenuation;\n    }\n\n    // Blinn - phong calculation\n    vec3 half_direction = normalize(normalize(L) + V);\n    float specular = pow(max(dot(half_direction, N), 0.0), 16.0);\n    return (lightIntensity * diffuse_color * dotLN * attenuation) +\n           (specular_color * pow(dotRV, alpha) * specular * attenuation);\n}\n\nvec3 blinnPhongIllumination(vec3 diffuse_color,\n                            vec3 specular_color, float alpha, float attenuation,\n                            vec3 light_pos, float light_intensity,\n                            vec3 point_pos, vec3 eye) {\n    vec3 light_I = light_intensity * vec3(1.0, 1.0, 1.0);\n\n    vec3 color = blinnPhongContribForLight(diffuse_color, specular_color, alpha, point_pos, eye,\n                                  light_pos,\n                                  light_I, attenuation);\n\n    return color;\n}\n\n// Determine the unit vector to march along\nvec3 rayDirection(in float fieldOfView, in vec2 size, in vec2 frag_coord) {\n    vec2 xy = frag_coord - size / 2.0;\n    float z = size.y / tan(fieldOfView / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// The raymarching algorithm\n// -------------------------\n// March along a ray by the distance to the nearest object\n// until that distance approaches zero (collision)\n// or it exceeds the max steps or max distance\nfloat raymarch(in vec3 eye, in vec3 ray_dir, out int collision_id) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = sceneSDF(eye + depth * ray_dir, collision_id);\n        if (d < EPSILON) {\n            return depth;\n        }\n        depth += d;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Calculate penumbra shadows for free\n// Algorithm sourced from Inigo Quilez\n// URL: https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(in vec3 ray_origin, in vec3 ray_direction, in float min_t, \n             in float max_t, in float k) {\n    float res = 1.0;\n    for (float t = min_t; t < max_t; ) {\n        float dist = sceneSDF(ray_origin + ray_direction * t);\n        if (dist < EPSILON) {\n            return 0.0;\n        }\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return res;\n}\n\n// Determine what tile the point falls in on the checkerboard\n// to colour the tile\nvec3 checkerboard_color(vec3 p) {\n    vec3 pos = vec3(p.x, p.y, p.z - (0.7 * iTime));\n\n    // Checkerboard pattern\n    if ((mod(pos.x,(CHECKERBOARD_TILE_SIZE * 2.0)) < CHECKERBOARD_TILE_SIZE &&\n        mod(pos.z,(CHECKERBOARD_TILE_SIZE * 2.0)) > CHECKERBOARD_TILE_SIZE) ||\n\n        (mod(pos.x,(CHECKERBOARD_TILE_SIZE * 2.0)) > CHECKERBOARD_TILE_SIZE &&\n        mod(pos.z,(CHECKERBOARD_TILE_SIZE * 2.0)) < CHECKERBOARD_TILE_SIZE)) {\n            // White tile\n            return vec3(0.9, 0.9, 0.9);\n    } else {\n            // Black tile\n            return vec3(0.1, 0.1, 0.1);\n    }\n}\n\n// Main function\n// When an object is hit, perform the math magic to colour it\nvec3 calculate_color(vec3 eye, vec3 p, int collision_id, vec3 ray_dir) {\n\n    // Determine / define blinn-phong calculation components\n    vec3 ambient_color = vec3(0.2, 0.2, 0.2);\n    vec3 diffuse_color;\n    if (collision_id == SPHERE) {\n        diffuse_color = vec3(0.0, 1.0, 1.0);\n    } else if (collision_id == PLANE) {\n        diffuse_color = checkerboard_color(p);\n    }\n    vec3 specular_color = vec3(1.0, 1.0, 1.0);\n    float shininess = 20.0;\n\n    // Light attributes\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                              2.0,\n                              4.0 * cos(iTime));\n    float lightIntensity = 1.0f;\n\n    // Compute the ambient component of light\n    vec3 ambient_light = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambient_light * ambient_color;\n\n    // Compute if the point of calculation is obstructed by any objects from the light\n    vec3 shadow_ray = normalize(lightPos - p);\n    float shadow_factor = shadow(p + shadow_ray, shadow_ray, 0.0, MAX_DIST, 8.0);\n\n    // Add the diffuse and specular components\n    vec3 blinn_phong_contribution = blinnPhongIllumination(diffuse_color, specular_color, shininess, 0.5,\n                                    lightPos, lightIntensity, p, eye) * shadow_factor;\n    color += blinn_phong_contribution;\n\n    // Reflect light off of the sphere\n    if (collision_id == SPHERE) {\n        vec3 reflection_dir = ray_dir - (2.0 * dot(ray_dir, estimateNormal(p))\n                                * estimateNormal(p));\n\n        // March along ray till it intersects\n        int collision_id;\n        float dist = raymarch(p + reflection_dir, reflection_dir, collision_id);\n\n        vec3 reflected_color;\n        vec3 reflected_p = p + dist * reflection_dir;\n        if (dist > MAX_DIST - EPSILON) {\n            // Nothing was hit\n            // Create nice gradient effect for the background\n            reflected_color = vec3(0.0, .8-sqrt(reflection_dir.y * 5.0), .8-sqrt(reflection_dir.y * 5.0));\n        } else {\n\n            // Compute if the point of calculation is obstructed by any objects from the light\n            vec3 shadow_ray = normalize(lightPos - reflected_p);\n            float shadow_factor = shadow(reflected_p + shadow_ray, shadow_ray, 0.0, MAX_DIST, 8.0);\n\n            // Add blinn-phong brdf to reflection\n            reflected_color = ambient_light * ambient_color;\n            reflected_color += blinnPhongIllumination(checkerboard_color(reflected_p), specular_color, shininess, 0.5,\n                                                     lightPos, lightIntensity, p, eye)\n                                                     * shadow_factor;\n        }\n\n        // Lerp the reflection with the sphere's original colour\n        color = mix(color, reflected_color, 0.2);\n    }\n\n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ray_dir = rayDirection(FOV, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 0, 5);\n\n    int collision_id;\n    float dist = raymarch(eye, ray_dir, collision_id);\n\n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * ray_dir;\n\n    if (dist > MAX_DIST - EPSILON) {\n        // Nothing was hit\n        // Create nice gradient effect for the background\n        fragColor = vec4(0.0, .8-sqrt(ray_dir.y * 5.0), .8-sqrt(ray_dir.y * 5.0), 1.0);\n    } else {\n        // Something was hit\n        fragColor = vec4(calculate_color(eye, p, collision_id, ray_dir), 1.0);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtycDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 356, 419, 419, 463], [465, 504, 549, 549, 595], [597, 651, 702, 702, 998], [1000, 1061, 1090, 1090, 1154], [1156, 1200, 1232, 1232, 1558], [1560, 1584, 1793, 1793, 2587], [2589, 2589, 2840, 2840, 3119], [3121, 3165, 3240, 3240, 3364], [3366, 3581, 3649, 3649, 3963], [3965, 4115, 4230, 4230, 4500], [4502, 4586, 4619, 4619, 5170], [5172, 5251, 5323, 5385, 8038], [8040, 8040, 8097, 8097, 8722]], "test": "valid"}
{"id": "MtycDW", "name": "soft shadows through holes", "author": "FabriceNeyret2", "description": "sky lighting on screen via occluder with holes (radius r, height h to screen). \n#THIN=0 -> thick\nRef image (see bottom) from \"strange shadows\" [url]https://www.boredpanda.com/amazing-shadows-optical-illusions/[/url]:\nuh, maybe wrong light source model.\n", "tags": ["shadows", "convolution", "soft"], "likes": 5, "viewed": 478, "published": "Public API", "date": "1536239189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define THIN 1  // 1: no thickness 0: thickness = 2e\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float h = .01 + .6*(.5+.5*sin(iTime)),    // distance occluder-screen\n          r = .3,                             // holes radius\n          e = .15/2.,                         // occluder thickness/2\n          I = 4.;                             // source intensity\n          \n    O -= O;\n\n    U *= 4. / iResolution.y;                  // scaling\n    U.x -= .5 * mod(floor(U.y),2.);\n    U = fract( U ) - .5;                      // local coordinates % hole center\n\n    for (int k=0; k<25; k++) {                // accounts for center + neighbor cells\n        vec2 P = vec2(k%5-2,k/5-2);\n        P.x -= .5 * mod(floor(P.y),2.);       // hole center\n        float d = length( U-P ),              // distance to it\n              a = atan(h,d-r) - atan(h,d+r);  // hole (thus sky) apperture from pixel on screen        \n#if THIN // thin occluder\n        a *= a;                               // solid angle = PI.(a/2)\n#else // thick occluder (approx footprint by ellipse)\n        a *=   max( atan(h+e,d-r), atan(h-e,d-r) )\n             - max( atan(h+e,d+r), atan(h-e,d+r) );\n#endif\n        O +=  a / 8.; // hole (thus sky) solid angle / 2Pi from pixel on screen\n    }\n    \n    O = pow( I*O, vec4(1./2.2) );             // to sRGB / gamma\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtycDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 92, 92, 1336]], "test": "valid"}
{"id": "MtycWD", "name": "Circle pulse on grid", "author": "murazaki", "description": "Circle pulse on grid", "tags": ["pulse", "grid", "circle"], "likes": 10, "viewed": 267, "published": "Public", "date": "1536247897", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat growingCircle( in float offset, in float thickness, in vec2 pos, in float speed, in float repeatAtTime, in float cellSize) {\n    float circle_size = mod(iTime * speed, repeatAtTime) - offset;\n    float radius = length(floor((pos + cellSize / 2.) / cellSize) * cellSize);\n    \n    return smoothstep(circle_size + thickness / 2., circle_size, radius) -\n           smoothstep(circle_size, circle_size - thickness / 2., radius);\n}\n\nfloat showGrid(in float thickness, in vec2 pos, in float speed, in float repeatAtTime, in float cellSize) {\n    float circle_size = mod(iTime * speed, repeatAtTime);\n    float radius = length(pos);\n    \n    float valueAtTime = 1. - pow(mod(iTime * speed, repeatAtTime) - repeatAtTime / 2., 2.);\n    vec2 isBorderVec = (smoothstep(thickness / 2., 0., abs(mod(pos + cellSize / 2., cellSize)))) *\n        \t\t\t\t(smoothstep(circle_size - 1.2, circle_size - .3, radius) -\n                         smoothstep(circle_size - .3, circle_size + .1, radius));\n    float isBorder = isBorderVec.x + isBorderVec.y;\n    \n    \n    return valueAtTime * isBorder;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy,\n         pos = (2.*fragCoord - R ) / min(R.x,R.y);\n    vec3 color = vec3(0.0);\n    \n    \n    float loopTime = length(R)/min(R.x,R.y) * 1.6;\n    float circleThickness = .35;\n    float cellSize = circleThickness / 2.;\n    float gridStrokeThickness = 12./min(R.x,R.y);\n    float speed = 3.;\n    \n    vec3 color1 = vec3(1., 0.5, 0.3);\n    vec3 color2 = vec3(0.1, 1., 0.2);\n    vec3 color3 = vec3(0.6, 0.2, 1.);\n\n    color = growingCircle(0., circleThickness, pos, speed, loopTime, cellSize) * color1 +\n            growingCircle(circleThickness/2., circleThickness, pos, speed, loopTime, cellSize) * color2 +\n            growingCircle(circleThickness, circleThickness, pos, speed, loopTime, cellSize) * color3 +\n            showGrid(gridStrokeThickness, pos, speed, loopTime, cellSize);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtycWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 156, 156, 458], [460, 460, 567, 567, 1105], [1107, 1107, 1163, 1163, 2011]], "test": "valid"}
{"id": "MtyczK", "name": "spinning around", "author": "skaplun", "description": "Another reproduce of Dave's animation https://twitter.com/beesandbombs/status/1038083580025552896\nFurther work - reduce loop in main() to 3 iterations and get rid of magic numbers.", "tags": ["rgb", "hsv", "polarcoords"], "likes": 7, "viewed": 487, "published": "Public", "date": "1536924304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define       TAU 6.28318530717958647\n#define thickness .005\n#define \t\te 7.5/iResolution.y\n#define \t\tr .35\n#define \t\tR .5\n\nvec3 hsv2rgb(vec3 c) {\n  // igo Qulez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvec3 circle(in vec2 uv, in vec2 c, in float aa){\n\tfloat ba = fract(atan(uv.y, uv.x) / TAU + .5);\n    float la = fract(atan(uv.x - c.x, uv.y - c.y) / TAU + .5 - iTime * .5 - aa);\n    vec3 col = hsv2rgb(vec3(ba, smoothstep(0., .2, 1. - la), la));\n    return col * smoothstep( (thickness + e) * la, thickness * la, abs(r - length(uv - c)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor -= fragColor;\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n  for(float i=0.; i<=360.; i+=30.)\n  \t  fragColor.rgb += circle(uv, vec2(R * cos(radians(i)), R * sin(radians(i))), radians(i * 4.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 145, 209, 356], [358, 358, 406, 406, 697], [699, 699, 754, 754, 985]], "test": "valid"}
{"id": "MtyyDy", "name": "Sphere Project- Disco Floor", "author": "rlarp", "description": "Sphere project (only spheres) inspired by a disco floor. ", "tags": ["sphere", "spheres", "education", "disco", "floor", "school", "homework", "discofloor"], "likes": 3, "viewed": 91, "published": "Public", "date": "1537492054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\nfloat map(vec3 p)\n{\n    float radius = 0.25; // or change to 0.1 for carpet like look\n    vec3 q = fract(p*=2.5) * 1.5 - 0.5;\n    \n    return sphere(q, radius);\n}\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.2;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d * 0.1;\n        }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *3.-2.; \n    uv.x *= iResolution.y/iResolution.x;\n    \n    vec3 color = vec3((sin(iTime)), 4.0, 1.1);\n    \n   \tfloat FOV = 1.5;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    ray.xy *= rot(iTime*0.2);\n    ///ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(0.5, 0.75, 1.0);\n    float t = trace(origin, ray);\n    \n    float expFog = 10. / (t*t*0.1);\n    \n    vec3 fc = vec3(expFog);\n\n    \n    fragColor = vec4(cos(fc+color),5.0);\n    \n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 123, 123, 154], [156, 156, 175, 175, 318], [320, 320, 355, 355, 515], [517, 517, 574, 574, 1106]], "test": "valid"}
{"id": "MtyyRd", "name": "Noises experiments", "author": "badjano", "description": "Noise repository", "tags": ["noise", "perlin", "simplex", "value"], "likes": 7, "viewed": 486, "published": "Public", "date": "1537326891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\n//simplex and perlin noise hash\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat value_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat fbm(vec3 p, vec2 uv)\n{\n    float r = 0.;\n    float m = 0.5;\n    for (int i=0; i<5;i++){\n        if (uv.x > 0.666){\n    \t    r += value_noise(p) * m;\n        } else if ( uv.x > 0.333 ){\n\t        r += simplex_noise(p) * m;\n        } else {\n\t        r += perlin_noise(p) * m;\n        }\n        p *= 2.;\n        m *= 0.5;\n    }\n    return r;\n}\n\nfloat weird(vec3 p, vec2 uv){\n    float value = 0.;\n    float m = 1.0;\n    for (int i=0; i<3; i++){\n\t    value = fbm(vec3(p.xy-vec2(cos(value),sin(value))*m,iTime + (1.*m+0.01*value)), uv);\n        if ( uv.y > 0.5){\n\t        m *= 1.1;\n        } else {\n\t        m *= 0.;\n        }\n    }\n//    return abs(tanh(value*p.z));\n    return tanh(value*p.z)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    float scale = 10.0;\n    vec3 col = vec3(\n        weird(vec3(uv*scale,50.0), uv2),\n        weird(vec3(uv*scale,5.0), uv2),\n        weird(vec3(uv*scale,0.5), uv2)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 59, 82, 82, 197], [199, 231, 253, 253, 405], [407, 407, 434, 434, 967], [969, 969, 997, 997, 1936], [1938, 1938, 1967, 1967, 2684], [2686, 2686, 2714, 2714, 3031], [3033, 3033, 3062, 3062, 3391], [3393, 3393, 3450, 3500, 3865]], "test": "valid"}
{"id": "MtyyRV", "name": "Molecular Buffet", "author": "aparadja", "description": "Contains no actual molecules", "tags": ["raymarch"], "likes": 4, "viewed": 107, "published": "Public", "date": "1536918283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float flatten(float x, float d) {\n    if (x > 0.0) return max(0.0, x - d);\n    return min(0.0, x + d);\n}\n\nfloat mapPill(vec3 position, float radius, float stretch, out vec3 normal, out float ao) {\n    vec3 q = fract(position) - 0.5;\n    \n    float pulse = sin(iTime * 6.0 + position.x + position.y + position.z);\n    radius -= pulse * 0.03;\n    stretch += pulse * 0.06;\n\n    float angle = (iTime * 2.0 + position.x + position.y + position.z) / 2.0;\n    mat2 rotation = mat2(-cos(angle), sin(angle), sin(angle), cos(angle));\n    q.xz *= rotation;\n    q.yz *= rotation;\n\n    vec3 s;\n    vec3 a = abs(q);\n    if (a.x > a.y && a.x > a.z)\n        s = vec3(flatten(q.x, stretch), q.yz);\n    else if (a.y > a.z)\n    \ts = vec3(q.x, flatten(q.y, stretch), q.z);\n    else\n    \ts = vec3(q.xy, flatten(q.z, stretch));\n    ao = 1.3 * radius / length(q);\n    normal = normalize(s);\n    normal.yz *= inverse(rotation);\n    normal.xz *= inverse(rotation);\n    return length(s) - radius;\n}\n\nfloat trace(vec3 origin, vec3 ray, out vec3 normal, out float ao) {\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = origin + ray * t;\n        t += mapPill(p, 0.1, 0.2, normal, ao) * 1.0;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    vec3 ray = normalize(vec3(uv, 1.45) + vec3(0, -0.2, 0));\n    float angle = iTime / 3.0;\n    mat2 rotation = mat2(-cos(angle), sin(angle), sin(angle), cos(angle));\n    ray.xz *= rotation;\n    vec3 origin = vec3(cos(iTime/13.0) * 14.0, iTime * 0.3, 0);\n    vec3 normal;\n    float ao;\n    float depth = trace(origin, ray, normal, ao);\n    vec3 light = vec3(0, -1, 0);\n    vec3 fog = vec3(1.0 / (1.0 + depth * depth * 0.2));\n    float diffuse = max(0.0, dot(-light, normal));\n    vec3 sun = vec3(0.1, 0.9, 0.4);\n    vec3 ambient = vec3(0.1, 0.2, 0.3);\n    float occlusion = max(0.0, 1.0 - ao);\n    \n    vec3 col = fog * occlusion * (ambient + sun * diffuse + 1.7 * pow(diffuse, 24.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 104], [106, 106, 196, 196, 972], [974, 974, 1041, 1041, 1206], [1208, 1208, 1263, 1263, 2081]], "test": "error"}
{"id": "MtyyRy", "name": "bref j'apprends", "author": "shantee", "description": " la base je voulais dessiner un couch de soleil", "tags": ["soleil"], "likes": 2, "viewed": 57, "published": "Public", "date": "1536757841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) /\n          smoothstep( pct, pct+0.02, st.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 rose = vec3(0.75,0.2,0.88);\n    vec3 blue = vec3(0.1,0.55,0.98);\n\tvec3 jaune = vec3(.244, .235, .66);\n\t\n    float rx = length((0.0,0.8) * uv.x);\n    //float r = rx*ry;\n    float c = smoothstep(0.0,uv.y,.1);\n    float s = smoothstep(1.0,uv.y,0.55);\n    float soleil = smoothstep(0.0,uv.x,0.5)+length((0.0,0.7) * uv);\n    \n    vec3 col = (blue*c)+rose*s+soleil*jaune*sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [125, 125, 182, 232, 692]], "test": "valid"}
{"id": "XlccWs", "name": "Alemanha", "author": "leandroa", "description": "Add borda", "tags": ["bandeira"], "likes": 0, "viewed": 51, "published": "Public", "date": "1537566439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float balanco=sin(iTime)*0.01+sin(uv.x*3.0+iTime)*0.01;\n    \n    if(uv.y<(0.66+balanco))\n        fragColor=vec4(0,0,0,0);\n    if(uv.y<(0.67+balanco) && uv.y>(0.32+balanco))\n        fragColor=vec4(1,0,0,0);\n    if(uv.y<(0.33+balanco))\n        fragColor=vec4(1,1,0,0);\n    if(uv.y<(0.01+balanco))\n        fragColor=vec4(1,0,1,0);\n    if(uv.y>(0.98+balanco))\n        fragColor=vec4(1,0,1,0);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlccWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 518]], "test": "valid"}
{"id": "XlGyRW", "name": "Brasil", "author": "leandroa", "description": "asd", "tags": ["asd"], "likes": 0, "viewed": 42, "published": "Public", "date": "1537566454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 myuv = vec2(uv-vec2(0.5,0.5));\n    vec2 notmyuv= vec2(myuv.x*3.0,myuv.y*1.8);\n    float balanco=sin(iTime)*0.01+sin(uv.x*3.0+iTime)*0.01;\n    \n    float mag = length(notmyuv);\n    \n     \n    \n    if (round(mag)==0.0)\n    \tfragColor = vec4(round(mag),round(mag),1,0);\n    else\n        fragColor = vec4(0,1,0,0);\n    \n    if(uv.y<(0.66+balanco))\n        fragColor=vec4(0,1,0,0);\n    if(uv.y<(0.70+balanco) && uv.y>(0.30+balanco))\n        fragColor=vec4(1,1,0,0);\n    if(uv.x<(0.67+balanco) && uv.x>(0.32+balanco))\n        fragColor=vec4(1,1,0,0);\n    if(uv.y<(0.01+balanco))\n        fragColor=vec4(1,0,1,0);\n    if(uv.y>(0.98+balanco))\n        fragColor=vec4(1,0,1,0);\n    if (round(mag+balanco)==0.0)\n    \tfragColor = vec4(round(mag),round(mag),1,0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 875]], "test": "valid"}
{"id": "XlGyRy", "name": "Colors-CO", "author": "cake7914", "description": "Colorful", "tags": ["beginner"], "likes": 1, "viewed": 339, "published": "Public", "date": "1536695055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Rotate\n//mat2 rot(float a){\n    //return mat2(cos(a), -sin(a),\n               //sin(a), cos(a));\n//}\n\n\n// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = 0.75;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p) * 2.0 - 1.0;\n\n    \n    // Signed distance of sphere\n    return sphere(q, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d * 0.25;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(.9124, .657, 0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = .01;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    //ray.yz *= rot(iTime*0.1);\n    //ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(0.0, 0.0, iTime/120.0);\n    float t = trace(origin, ray);\n    \n    \n    float linearFog = 2.0 / (1.0 - t*0.2);\n    float expFog = 10.0 / (t*t*0.1);\n    \n    vec3 fc = vec3(expFog);\n\n    // Output pixels to screen\n    fragColor = vec4(fc,2.0);\n    \n    // Try oscilating the final pixels\n    fragColor = vec4(tan(fc-color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 119, 154, 154, 185], [188, 232, 251, 251, 439], [442, 442, 477, 477, 637], [640, 640, 697, 697, 1451]], "test": "valid"}
{"id": "XlGyWw", "name": "ray test 1", "author": "teebnike", "description": "ray test 1", "tags": ["raytest"], "likes": 2, "viewed": 343, "published": "Public API", "date": "1536633254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere( vec3 p, float s )\n{\n    float x = cos(p.x)*1.5;\n    float y = sin(p.y)*1.5;\n    float z = cos(p.z)*1.5;\n    return length(vec3(x,y,z))-s;\n}\n\nfloat udBox(vec3 p, vec3 b )\n{\n  float x = cos(p.x)*1.5;\n  float y = sin(p.y)*1.5;\n  float z = sin(p.z)*1.5;\n  return length(max(abs(vec3(x,y,z))-b,0.));\n}\n\t\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  float x = cos(p.x)*1.5;\n  float y = sin(p.y)*1.5;\n  \n  return length(max(abs(vec3(x,y,p.z))-b,0.0))-r;\n}\n\t\n\t\n\n\n\nfloat map(vec3 p){\n    \n    vec3 p2 =vec3(0.,0.,-4.) - p;\n    p2.z += iTime*4.5;\n    \n    \n    //float angle = iTime*0.01;\n   // float x = sin(angle)*p2.x - cos(angle) * p2.z;\n   // float y = cos(angle)*p2.x + sin(angle) * p2.z;\n  //  p2.x = x;\n   // p2.z = y;\n    float d = sdSphere(p2,1.);\n    \n    vec3 p3 =vec3(0.,0.,-4.) - p;\n    p3.z += iTime*4.5;\n   /// d = min(d,udBox(p3,vec3(.5,.5,.5)));\n    \n    //vec3 p4 =vec3(-3,sin(iTime),-4.) - p;\n    //d = min(d,sdSphere(p4,1.));\n\t//d = min(d,udRoundBox(vec3(1.,-1.,-20.)-p,vec3(1.,1.,1.),0.1));\n    return d;\n}\n\nvec3 calcNormal(in vec3 p){\n\tvec2 e = vec2(1.0 , -1.0) *0.0005;\n    return normalize(\n    \te.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx)\n    );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float precis = 0.0001;\n\tconst float maxt = 10.0;\n\n    float t = 0.0;\n    for( int i=0; i<200; i++ )\n    {\n\t    float h = map( ro+rd*t );\n        if( h<precis || t>maxt ) break;\n        t += h;\n    }\n\n    if( t>maxt ) t=-1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\t\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    vec3 ro = vec3(0,0,1);\n    \n   \tvec3 rd = normalize(vec3(q,0.) - ro);\n    \n    float t,h = 1.;\n    \n    for(int i = 0; i<256; i++){\n\t\th = map(ro + rd * t);\n        t += h;\n        if (h<0.01) break;\n    }\n    \n    if(h<0.01){\n    \tvec3 p = ro +rd *t;\n        vec3 normal = calcNormal(p);\n        vec3 light = normalize(vec3(0,2,1));\n        \n        float col = dot(light,normal);\n       \n        \n        rd = reflect(rd,normal);\n        ro = p + normal*0.001;\n        \n      \n        float t2 = intersect(ro,rd);\n        fragColor = vec4(1.);\n       \n       \t\n        \n        fragColor *= vec4(vec3(col),1.);\n        \n         if(t2 < 0.0){\n        \n            fragColor *= vec4(0.8);\n        }\n        \n    }else{\n    \n    \tfragColor = vec4(0.4,0.5,0.8,1.0);\n    }\n    \n        \n    \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 155], [157, 157, 187, 187, 312], [315, 315, 360, 360, 467], [475, 475, 493, 493, 1037], [1039, 1039, 1066, 1066, 1260], [1262, 1262, 1305, 1305, 1553], [1555, 1555, 1612, 1612, 2536]], "test": "valid"}
{"id": "XlKcDd", "name": "dizzy27", "author": "teraspora", "description": "dizzy27", "tags": ["dizzy27"], "likes": 1, "viewed": 82, "published": "Public", "date": "1538194869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// squirming-abyss - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Date: 29 SEP 2018.\n\n// NOTE: This shader contains a number of functions not currently used;\n// they are there for ease of adaptation and in the spirit of FOSS;\n// also because I am passionate about discovering, inventing and\n// adapting ideas which I can fashion into useful tools and \n// so build up a toolset I can use intuitively.   So I want to \n// have them always available, so I am (for now, anyway) building every shader in\n// this template, in which I have to an extent factored out the tiling code and\n// border code into separate methods.\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\nfloat tileIndex;\n\n// My inline library of useful functions:\n\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n// =======================================\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n    float time = iTime;\n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 1.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 120.0 * nsin(time * 0.125);\n    \n    // ===============================================================\n    \n    // Normalisation and tiling:\n    // ========================\n    \n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    // ===============================================================================================\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Main code for the shader goes here:\n    // ===============================================================================================\n    \n    vec3 col = vec3(0.);\n  \tfloat r2 = 4.;\n    q *= vec2(ncos(ncos(time)), nsin(ncos(time)));\n    col = vec3(nsin(time), nsin(length(q) * time * 25.), ncos(q.x + q.y));\n    \n    // ===============================================================================================\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Border code:    \n    // ===============================================================================================\n    \n    float borderWidth = 3.;\n    vec3 borderInsetLineColour = white;\n \t\n    col = drawBorder(col, borderWidth, borderInsetLineColour, pp, hr, tile);\n    // finally return the colour to caller(mainImage()):     \n    return col;\n}\t// END doStuff()\n    // ===============================================================================\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = doStuff(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}\n    \n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1329, 1538, 1563, 1563, 1721], [1723, 1787, 1811, 1864, 2147], [2149, 2184, 2208, 2208, 2328], [2330, 2365, 2389, 2389, 2541], [2604, 2648, 2667, 2667, 2696], [2698, 2698, 2730, 2730, 2777], [2779, 2779, 2807, 2807, 2872], [2874, 2874, 2906, 2906, 2947], [2949, 2949, 2968, 2968, 2986], [2988, 2988, 3005, 3005, 3023], [3025, 3025, 3044, 3044, 3062], [3064, 3064, 3085, 3085, 3113], [3115, 3115, 3136, 3136, 3164], [3166, 3166, 3188, 3188, 3222], [3224, 3224, 3255, 3255, 3327], [3329, 3329, 3370, 3370, 3409], [3411, 3411, 3426, 3426, 3464], [3465, 3509, 3598, 3834, 4371], [4373, 4390, 4426, 4562, 7090], [7091, 7197, 7254, 7254, 7546]], "test": "error"}
{"id": "XlKcWy", "name": "Archimedes 2dLine", "author": "letsparty1793", "description": "Archimedes 2dLine", "tags": ["archimedes2dline"], "likes": 2, "viewed": 68, "published": "Public", "date": "1537547666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\nfloat circle(vec2 p, vec3 rr)\n{\n    float theta = atan(p.y,p.x);\n    float r     = length(p);\n    float i = round(((r-rr.y)/rr.x - (rr.z+theta))/(2.*PI));\n    return abs(r - (rr.z + theta + float(i)*2.0*PI) * rr.x) - rr.y;\n}\nvoid render(out vec3 dst, vec3 src, float d)\n{\n    float dd = 1.0-smoothstep(-0.02,0.00,d);\n    dst = mix(dst, src, dd);\n}\nvec3 draw(vec2 p)\n{\n    vec3 color = texture(iChannel0,p).rgb;\n    vec3 c = vec3(1.0);\n    render(color,c,circle(p, vec3(0.01,4./iResolution.y,2.0*PI*fract(iTime))));\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p  = (2.*fragCoord - iResolution.xy) / iResolution.y; \n\tvec3 col = draw(p);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 243], [244, 244, 290, 290, 366], [367, 367, 386, 386, 553], [554, 554, 611, 611, 726]], "test": "error"}
{"id": "XlKcWz", "name": "Animation128349278942", "author": "fodiz", "description": "An animation", "tags": ["animation"], "likes": 0, "viewed": 58, "published": "Public", "date": "1535804660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 backgroundColor = vec3(0.50, 0.44, 0.47);\n    vec3 sparkColorRed = vec3(0.86, 0.18, 0.17);\n    vec3 sparkColorYellow = vec3(0.93, 0.84, 0.17);\n    int sparksCount = 20;\n    vec2 uv = fragCoord / iResolution.xy; // iTime\n    // float c = texture(iChannel0, uv / vec2(10.0, 100.0) + vec2(0.0, -mod(iTime, 30.0) / 30.0)).r;\n    // float d = (c - 0.9) * 10.0;\n    vec3 color = backgroundColor;\n    \n    float d = 0.0;\n    for (int i = 0; i < sparksCount; i++) {\n        // vec2 h = texture(iChannel0, vec2(float(i) / float(sparksCount), mod(iTime, 500.0) / 500.0)).xy * 2.0 - 1.0;\n        // vec2 h = vec2(0, cos(mod(iTime, 500.0) / 500.0));\n        vec2 k = vec2(texture(iChannel0, vec2(float(i) / float(sparksCount), 0.0)).x * 2.0 - 1.0, 0.0);\n        float speed = 0.5 + float(i) / float(sparksCount) * 2.0;\n        vec2 c = mod(k + vec2(0.5 + cos(iTime / 3.0 + float(i) / float(sparksCount)) * 0.5, mod(iTime, speed) / speed + float(i) / float(sparksCount)), 1.0);\n        // float skew = 0.7 + texture(iChannel0, vec2(float(i) / float(sparksCount), 0.0)).z * 0.3;\n        // float skew = -c.x * 2.0 + 1.0;\n        // float angle = 2.3;\n        // float skew = \n        // d += 1.0 - clamp(distance(c * vec2(10.0, 1.0), uv * vec2(10.0, 1.0)), 0.0, 0.03) / 0.03;\n        // d += 1.0 - clamp(distance(c, uv), 0.0, 0.03) / 0.03;\n        vec2 mul = vec2(iResolution.x / iResolution.y, 1.0);\n        vec2 pos = c * mul - uv * mul;\n        float angle = (c.x * -2.0 + 1.0) * 0.3 + cos(iTime + float(i) / float(sparksCount)) * 0.3;\n        mat2 mat = mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n        );\n        vec2 rotated = mat * pos;\n        vec2 scaled = rotated / vec2(0.2 - float((i + sparksCount / 2) % sparksCount) / float(sparksCount) * 0.15, 1.0);\n        // d += distance(scaled, vec2(0.0, 0.0)) < 0.02 ? 1.0 : 0.0;\n        // d += distance(c * mul, vec2(uv.x - uv.y * skew, uv.y) * mul) < 0.03 ? 1.0 : 0.0;\n        float d = clamp(0.04 - distance(scaled, vec2(0.0, 0.0)), 0.0, 0.03) / 0.03;\n        color = mix(color, mix(sparkColorRed, sparkColorYellow, float(i) / float(sparksCount)), d);\n    }\n   \n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen (cos(iTime) + 1.0) / 2.0\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 108, 108, 2438]], "test": "error"}
{"id": "XlKyRV", "name": "EDO KIRIKO WORLD", "author": "tatsunoru", "description": "Edo Kiriko is a glass craft that has been handed down in Tokyo.", "tags": ["world", "edo", "kiriko"], "likes": 7, "viewed": 202, "published": "Public", "date": "1536948668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 supershapes(vec4 n, float phi){\n\tfloat delta = 1.0;\n\tfloat m = n.x * phi * 0.25;\n\tfloat t1 = pow(abs(cos(m)), n.z);\n\tfloat t2 = pow(abs(sin(m)), n.w);\n\tfloat radius = 1.0 / pow(t1 + t2, 1.0 / n.y);\n\treturn vec2(cos(phi), sin(phi)) * radius * delta;\n}\n\nvec2 supershapes(vec4 n, vec2 coord){\n\treturn supershapes(n, atan(coord.y, coord.x));\n}\n\nfloat supershapesDistance(vec4 n, vec2 coord){\n\treturn distance(coord, supershapes(n, coord));\n}\n\nvec2 toOrigin(vec2 uv){\n\treturn (uv - 0.5) * 2.0;\n}\n\nvec2 fromOrigin(vec2 uv){\n\treturn uv * vec2(0.5, -0.5) + 0.5;\n}\n\nfloat hexLength(vec2 pos){\n\tvec2 q = abs(pos);\n\treturn max(q.x, max(q.x+q.y*0.57735, q.y*1.1547));\n}\n\nvec2 modEx(vec2 pos, vec2 b){\n    return toOrigin(mod(pos, b) / b);\n}\n\nfloat modNormalize(float pos, float b){\n    return mod(pos, b) / b;\n}\n    \nfloat noise(vec3 p){\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1.0, 57.0, 21.0)) + vec4(0.0, 57.0, 21.0, 78.0);\n\tvec3 f = cos((p-i) * acos(-1.0))*(-0.5) + 0.5;\n\ta = mix(sin(cos(a) * a),sin(cos(1.0 + a)*(1.0 + a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat rengaHex(vec2 pos, float gridScale){\n    vec2 grid = vec2(gridScale, gridScale);\n    vec2 halfgrid = grid * 0.5;\n    \n\tvec2 p1 = modEx(pos, grid);\n\tvec2 p2 = modEx(pos + halfgrid, grid);\n    \n    float d1 = supershapesDistance(vec4(8.0, 0.6, 0.2, 0.2), p1);\n    float d2 = supershapesDistance(vec4(4.0, 0.3, 0.2, 0.2), p2);\n    \n    return min(d1, d2);\n}\n    \nvec2 sphereUV(vec2 pos){\n  \tfloat r = dot(pos, pos);\n\tfloat f = (1.0 - sqrt(abs(1.0 - r))) / r;\n\treturn pos * f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 ret = vec4(0.0);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * mix(0.5, 8.0, (1.0 + sin(iTime * 0.3)) * 0.5);   \n    \n    float nz = noise(vec3(0.0, 0.0, iTime * 0.2));\n    float nz2 = noise(vec3(1.0, 1.0, iTime * 0.2));\n    \n    float hexField = rengaHex(sphereUV(uv * 0.94)+vec2(nz, nz2), 0.15);\n    float hexFIeldRepat = modNormalize(hexField, 0.4);\n    \n    ret -= vec4(0.9, 0.5, 0.0, 1.0) * hexFIeldRepat;\n    ret += smoothstep(0.4, 0.6, texture(iChannel0, sphereUV(uv  + vec2(hexFIeldRepat-0.5, hexFIeldRepat-0.5)))).xxxx * 0.75 + 0.25;\n    \n \tfragColor = ret;   \n}\n\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 256], [258, 258, 295, 295, 345], [347, 347, 393, 393, 443], [445, 445, 468, 468, 496], [498, 498, 523, 523, 561], [563, 563, 589, 589, 663], [665, 665, 694, 694, 734], [736, 736, 775, 775, 805], [811, 811, 831, 831, 1090], [1092, 1092, 1134, 1134, 1452], [1458, 1458, 1482, 1482, 1572], [1574, 1574, 1628, 1628, 2239]], "test": "error"}
{"id": "XlKyWy", "name": "Bouncing on Marble", "author": "Blokatt", "description": "Quality pogo time.\nAnti-aliasing is done by dynamically smoothing the texture generation function, so it's not 100% perfect, but screen-space sampling may be added later.\nFeedback appreciated!", "tags": ["demoscene", "motionblur", "demoeffect", "rotozoomer", "bouncing", "chromaticabberation", "pogo"], "likes": 9, "viewed": 1134, "published": "Public API", "date": "1537546095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nBouncing on Marble 1.0\nBy Blokatt (@blokatt | blokatt.net)\n22/09/18\n*/\n\n#define MOTION_BLUR_LENGTH 0.025\n#define MOTION_BLUR_SAMPLES 10.0\n#define ARC_MAX_LEN 8.0\n#define ARC_MAX 0.3\n#define TIME_OFFSET 13.75 + (iMouse.x / iResolution.x - .5)\n#define JUMPING_SPEED 1.0\n\nconst float PI = 3.141592653589793238462643;\nconst float HPI = PI * 0.5;\nconst float FPI = ARC_MAX_LEN / PI;\nconst float MOTION_BLUR_FALOFF = 1.0 - (1.0 / (1. + MOTION_BLUR_SAMPLES * 0.3));\nconst float MOTION_BLUR_LENGTH_OFFSET = MOTION_BLUR_LENGTH / MOTION_BLUR_SAMPLES;\n#define RATIO iResolution.x / iResolution.y\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n        \t\tsin(a), cos(a));\n}\n\nfloat smoothmod(float v, float d, float p){\n\tfloat res = mod(v, d);\n    return res * (1. - smoothstep(d - p, d, res)); \n}\n\nvec4 baseTexture(in vec2 uv, float depth){    \n    float size = 1.;    \n    float blur = min(.0005 * (depth * 10.5), .0030);    \n    return vec4(.5) * smoothstep(0., blur, smoothmod(uv.x * size, .05, blur * 5.)) * smoothstep(0., blur * RATIO, smoothmod(uv.y * size, .05, blur * RATIO * 3.)) * smoothstep(1., 1. - blur, mod(uv.x * size + .05 * floor(mod(uv.y * size, .1) * 20.), .1) * 20.) + texture(iChannel0, uv * 5.) - vec4(.14, .15, .01, 0.);\t\n}\n\nfloat arcExtreme(float t) {\n\treturn ARC_MAX * floor(abs(HPI - mod(t / ARC_MAX_LEN - HPI, PI)) * FPI);\n}\n\nvec4 zoomer(in vec2 uv, in float t){    \n    uv.x *= RATIO; \n    vec2 _uv = uv;\n    \n    float bounceT = t * JUMPING_SPEED + .2;    \n    float z = .1 + abs(sin(bounceT)) * (1. + arcExtreme(bounceT));         \n    uv *= z;          \n    uv.x += cos(t * 1.) * .25 * sin(t * .2 + .2);\n    uv.y -= sin(t * 1.) * .25 * sin(t * .2 + .2);        \n\tuv *= rot(t * .3 + length(uv) * .5);  \n    \n    float l = length(uv);\n    float depth = sin(l * 10. - t * 5.) * ((1. / (1. + l * .25)) * .03);\n    float size = 1.5 + depth * 1.5;  \n    float _l = length(_uv * size);\n    return vec4(1. - depth * 15.) * baseTexture(uv * size, z) * (mix(smoothstep(.25 * .15, .5 * .15, _l * z - max(0., max(0., .006 - z * 2.5))), 1., clamp(0., 1., .15 + z + depth)));\t\n}\n\nvec4 trail(in vec2 uv, in float t){\n    t += TIME_OFFSET;\n\tvec4 col = zoomer(uv, t);\n    float factor = .5;\n    for (float i = 1.; i < MOTION_BLUR_SAMPLES; i += 1.){\n    \tcol = mix(col, zoomer(uv, t - i * MOTION_BLUR_LENGTH_OFFSET), 1. * factor);\n        factor *= MOTION_BLUR_FALOFF;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - .5;                   \n    fragColor = vec4(trail(uv, iTime - .005).r, trail(uv * .996, iTime).g, trail(uv * .993, iTime + .005).b, 1.) * (1. - smoothstep(.5, .9, length(uv)));\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 589, 607, 607, 666], [668, 668, 711, 711, 789], [791, 791, 833, 833, 1239], [1241, 1241, 1268, 1268, 1344], [1346, 1346, 1382, 1382, 2088], [2090, 2090, 2125, 2125, 2398], [2400, 2400, 2457, 2457, 2681]], "test": "error"}
{"id": "XlVcD3", "name": "Periodic2D SimplexCellular Noise", "author": "Markyparky56", "description": "Adapted from Brian Sharpe's Simplex Cellular Noise (see code)\nIt wraps the position coordinate by a given period in the hash function to cause the hash to repeat. Seems to be slightly stretched in the x-axis.\n", "tags": ["noise", "worley", "simplex", "cellular", "periodic"], "likes": 10, "viewed": 175, "published": "Public", "date": "1537977713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from Brian Sharpe's Simplex Cellular Noise from https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvoid FAST32_hash_2D( vec2 gridcell, float period, out vec4 hash_0, out vec4 hash_1 )\t//\tgenerates 2 random numbers for each of the 4 cell corners\n{    \n    //gridcell = mod(gridcell, period);\n    const vec2 OFFSET = vec2( 26.0, 161.0 );\n    const float DOMAIN = 71.0;\n    const vec2 SOMELARGEFLOATS = vec2( 951.135664, 642.949883 );\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n        \n    // Wrap by period\n    P = mod(P, period);\n    \n    P = P - floor(P * ( 1.0 / DOMAIN )) * DOMAIN;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 / SOMELARGEFLOATS.y ) );\n}\n\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\nvec2 rotUV(in vec2 uv, in mat2 rotMatrix)\n{\n    return uv = vec2((uv.x - 0.5), uv.y - 0.5) * rotMatrix;\n}\n\nfloat SimplexCellular2D( vec2 P, float period )\n{\n    //\tsimplex math based off Stefan Gustavson's and Ian McEwan's work at...\n    //\thttp://github.com/ashima/webgl-noise\n\n    //\tsimplex math constants\n    const float SKEWFACTOR = 0.36602540378443864676372317075294;\t\t\t// 0.5*(sqrt(3.0)-1.0)\n    const float UNSKEWFACTOR = 0.21132486540518711774542560974902;\t\t\t// (3.0-sqrt(3.0))/6.0\n    const float SIMPLEX_TRI_HEIGHT = 0.70710678118654752440084436210485;\t// sqrt( 0.5 )\theight of simplex triangle.\n    const float INV_SIMPLEX_TRI_HEIGHT = 1.4142135623730950488016887242097;\t//\t1.0 / sqrt( 0.5 )\n    const vec3 SIMPLEX_POINTS = vec3( 1.0-UNSKEWFACTOR, -UNSKEWFACTOR, 1.0-2.0*UNSKEWFACTOR ) * INV_SIMPLEX_TRI_HEIGHT;\t\t//\tvertex info for simplex triangle\n\n    //\testablish our grid cell.\n    P *= SIMPLEX_TRI_HEIGHT;\t\t// scale space so we can have an approx feature size of 1.0  ( optional )\n    vec2 Pi = floor( P + dot( P, vec2( SKEWFACTOR ) ) );\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_x, hash_y;\n    FAST32_hash_2D( Pi, period, hash_x, hash_y );\n    //SGPP_hash_2D( Pi, hash_x, hash_y ); \n\n    //\tpush hash values to extremes of jitter window\n    const float JITTER_WINDOW = ( 0.10566243270259355887271280487451 * INV_SIMPLEX_TRI_HEIGHT );\t\t// this will guarentee no artifacts.\n    hash_x = Cellular_weight_samples( hash_x ) * JITTER_WINDOW;\n    hash_y = Cellular_weight_samples( hash_y ) * JITTER_WINDOW;\n    \n    //\tcalculate sq distance to closest point    \n    vec2 p0 = ( ( Pi - dot( Pi, vec2( UNSKEWFACTOR ) ) ) - P ) * INV_SIMPLEX_TRI_HEIGHT;\n    hash_x += p0.xxxx;\n    hash_y += p0.yyyy;\n    hash_x.yzw += SIMPLEX_POINTS.xyz;\n    hash_y.yzw += SIMPLEX_POINTS.yxz;    \n    vec4 distsq = hash_x*hash_x + hash_y*hash_y;\n    vec2 tmp = min( distsq.xy, distsq.zw );\n    return min( tmp.x, tmp.y );\n}\n\nvec3 renderGrid(vec2 pos, float period, vec3 gridCol, vec3 colIn)\n{\n    pos.x = mod(pos.x, period*1.0);\n    pos.y = mod(pos.y, period*1.0);\n    float aa = 0.0000000025;\n    \n    vec2 toGrid = pos - round(pos);\n    if(pos.x > (toGrid.x - aa) && pos.x < (toGrid.x + aa)) return gridCol;\n    else if(pos.y > (toGrid.y - aa) && pos.y < (toGrid.y + aa)) return gridCol;\n   \telse return colIn;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    const float period = 8.0;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    uv *= 8.0;\n    uv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));\n    \n    const float angle = 0.2617994; //15deg in rads, because simplex tile at an angle we rotate space/uvs slightly to correct this\n    const float cos_factor = cos(angle);\n    const float sin_factor = sin(angle);\n    const mat2 rotMat = mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n    vec2 rotUV = rotUV(uv, rotMat);\n\n    vec3 col = vec3(SimplexCellular2D(rotUV, period));    \n   \n    vec2 griduv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    griduv *= 8.0;\n    griduv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));\n    //col = renderGrid(griduv, period, vec3(1.0,0.0,0.0), col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 282, 326, 801], [803, 803, 849, 849, 1040], [1042, 1042, 1085, 1085, 1147], [1149, 1149, 1198, 1350, 3016], [3018, 3018, 3085, 3085, 3407], [3409, 3409, 3463, 3463, 4343]], "test": "valid"}
{"id": "XlVcW1", "name": "Snakes", "author": "skaplun", "description": "Original: https://twitter.com/beesandbombs/status/1035545423069503488\nNeed to get rid of loop in row func", "tags": ["circles", "animation", "snakes"], "likes": 11, "viewed": 131, "published": "Public", "date": "1536233027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAD .1\n#define e ( 3. / iResolution.y )\n#define tt .0666666667\n\nfloat makeCircle(in vec2 uv, in vec2 c, in float r){\n\treturn smoothstep(e, 0., abs( distance(uv, c) - r ) );\n}\n\nfloat row(in vec2 uv){\n    float color = 0.,\n    s = sign(mod(floor((uv.y * .5 + .5)/RAD), 2.) - .5),\n    rad = RAD/2. + RAD/2. * sin(uv.x * 4. - iTime * 1.5) * .75 * s;\n    for(float i=-1.; i<5.; i++)\n    \tcolor += makeCircle(mod(uv, RAD * 2.), vec2(i * tt, RAD), rad);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y + vec2(iTime * .05, 0.);\n    fragColor = vec4(row(uv) * step(abs(uv.y), .6));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVcW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 124, 124, 182], [184, 184, 206, 206, 474], [476, 476, 532, 532, 677]], "test": "valid"}
{"id": "XlVcWh", "name": "CSC 550 Assignment 1", "author": "AustinJ", "description": "This is for assignment 1 in my CSC 550 class. This is comprised of 5 primitive shapes, two that are animated, one controlled by the mouse, and at least one with a generated pattern.", "tags": ["shapes"], "likes": 2, "viewed": 66, "published": "Public", "date": "1536185211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// took this from the in class example\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    //defining edges ( from point P0 to point P1\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n    //create vector from each triangle point to the sample point \"p\"\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n    \n    //\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//formula for hexagon from https://www.shadertoy.com/view/Xd2GR3\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv *= 1.5;\n\n    \n    vec3 col = vec3(0.0);\n    \n    \n    //draw the hexagon\n    vec2 pos = (-iResolution.xy + 5.0*fragCoord.xy)/iResolution.y;\n    //pos = vec2(0.5); I can't figure out from the formula how it\n    //determines a stopping point. When I put in my desired cordinates\n    //it just gave me a solid color. So, I assume that it does not know\n    //when to stop if its input does not change. This is because the pos\n    //is changing since it relies on the resolution and fragCoord.\n    vec4 h = hexagon(pos);\n    col = vec3(h);\n\n    vec2 mousePos = iMouse.xy;\n    float radius = 35.0;\n    \n    if (sqrt(pow(mousePos.x - fragCoord.x, 2.0) + \n             pow(mousePos.y - fragCoord.y, 2.0))\n             < radius)\n        col = vec3(.5);\n    \n    //draw the rectangle and animate it\n    vec2 ul = vec2(0.3 + cos(iTime),0.6 + cos(iTime));\n    vec2 lr = vec2(0.5 + cos(iTime),0.3 + cos(iTime));\n    if((uv.x >= ul.x && uv.x <= lr.x) && \n       (uv.y <= ul.y && uv.y >= lr.y))\n        col = vec3(0.0,0.0,0.5);\n    \n    //draw the triangle with the example from class\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n    //creating animated vertices for our triangle\n\tvec2 v1 = cos( sin(iTime) + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( sin(iTime) + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( /*sin(iTime) +*/ vec2(0.0,3.00) + 4.0 ); //made the triangle swing on a point\n\n    //distance from current Pixel to triangle\n\tfloat d = sdTriangle( v1, v2, v3, p );\n    \n    if(d < 0.0)\n        col = vec3(0.5,0.0,0.0);\n    \n    //draw... plus sign\n    vec2 origin = vec2(0.75);\n    vec2 p1 = vec2(origin.x + 0.25, origin.y);\n    vec2 p2 = vec2(origin.x, origin.y + 0.25);\n    vec2 p3 = vec2(origin.x - 0.25, origin.y);\n    vec2 p4 = vec2(origin.x, origin.y - 0.25);\n    float width = 0.15;\n    \n    ;\n    \n    //check the points tips of the plus signs as borders\n    if(\n        (( uv.y <= p1.y + width && uv.y > p1.y - width ) \n         && (uv.x <= p1.x && uv.x >= p3.x)) ||\n        ((uv.y <= p2.y && uv.y >= p4.y) && \n         (uv.x <= p2.x + width && uv.x >= p2.x - width))\n      )\n        //create a striped pattern\n        col = vec3(0.0,abs(cos(uv.y*10.0f)),cos(0.0)); \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 142, 191, 881], [884, 949, 974, 974, 1485], [1486, 1486, 1543, 1593, 3910]], "test": "valid"}
{"id": "XlVcWy", "name": "Endless Marbles", "author": "yx", "description": "Forked from [url]https://www.shadertoy.com/view/ltVyRd[/url]", "tags": ["loop"], "likes": 6, "viewed": 461, "published": "Public API", "date": "1537548818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\n// I changed the timing slightly for shadertoy so it loops at exactly 5 seconds - I got the math wrong on stream\n#define iTime (iTime * pi * .4)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat tick()\n{\n    float t = sin(iTime)*.5+.5;\n    return t*2.-1.;\n}\n\nvec2 halfScene(vec3 p)\n{\n    p.x = mod(p.x+2., 4.)-2.;\n    float env = max(\n        max(p.y,-p.z),\n        -sdTorus(p, vec2(1,.25))\n    );\n\n    env = max(env,sdTorus(p,vec2(1,.35)));\n    \n    p.xz = rotate(p.xz, iTime);\n    p.z -= step(0.,cos(iTime))*2.-1.; // tweaked this line - sign(x) and step(0,x)*2-1 are not the same when x is zero\n\n    float ball = sdSphere(p,.25);\n\n    return vec2(min(env,ball), env<ball?1:0);\n}\n\nvec2 scene(vec3 p)\n{\n    vec3 pA = p;\n    vec3 pB = p;\n\n    pA.x += tick();\n    pB.x -= tick();\n    pB.z *= -1.;\n\n    vec2 a = halfScene(pA);\n    vec2 b = halfScene(pB);\n    return vec2(min(a.x,b.x),a.x<b.x?a.y:b.y);\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    for(int bounce=0;bounce<3;++bounce)\n    {\n        float t;\n        vec2 k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k.x;\n            if (k.x < .001 || k.x > 10.)\n                break;\n        }\n\n        // sky hack\n        if (k.x > 10.)\n            k.y = 2.;\n\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy).x-scene(h-o.xyy).x,\n            scene(h+o.yxy).x-scene(h-o.yxy).x,\n            scene(h+o.yyx).x-scene(h-o.yyx).x\n        ));\n\n        if (k.y == 2.)\n        {\n            // sky\n            // tweaked - I forgot to include the accumulation term on stream\n            return vec3(dir.y*.15+.1) * vec3(30.) * accum;\n        }\n        if (k.y == 1.)\n        {\n            float A = .1;\n            float B = scene(h+n*A).x;\n            float fakeAO = clamp(B/A,0.,1.);\n            fakeAO = pow(fakeAO,.6)*.2+.8;\n\n            float light = n.y*.5+.5;\n\n            vec3 color = vec3(.8);\n\n            h.x += tick() * sign(h.z);\n\n            // floor\n            return light * fakeAO * accum * color;\n        }\n        else\n        {\n            // balls\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel = mix(.0016,1.,fresnel);\n            accum *= fresnel;\n            cam = h + n*.0015;\n            dir = reflect(dir, n);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(uv*3.,-5.);\n    vec3 dir = vec3(0,0,1);\n\n    cam.yz = rotate(cam.yz, atan(1.,sqrt(2.)));\n    dir.yz = rotate(dir.yz, atan(1.,sqrt(2.)));\n\n    cam.xz = rotate(cam.xz, pi/4.);\n    dir.xz = rotate(dir.xz, pi/4.);\n\n    out_color.rgb = pow(trace(cam,dir),vec3(.45));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 170, 200, 200, 323], [325, 325, 358, 358, 427], [429, 429, 462, 462, 488], [490, 490, 504, 504, 558], [560, 560, 584, 584, 982], [984, 984, 1004, 1004, 1202], [1204, 1204, 1236, 1236, 2680], [2682, 2682, 2734, 2734, 3110]], "test": "error"}
{"id": "XlVcWz", "name": "contraption", "author": "nolibab", "description": "Port intro 'Contraption' by Enpera from Solskogen 2018 demo party", "tags": ["gears", "rotation", "spheroid"], "likes": 9, "viewed": 939, "published": "Public", "date": "1535813706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat w(vec3 p,float r)\n{\nfloat a=atan(p.x,p.z)+r;\nfloat o=pow(abs(sin(12.*a)),.1)*sign(sin(12.*a))*.15+1.;\nreturn length(p.xz)+(p.y*.75)*(o*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat time_ = iTime/100.;\nvec3 o=vec3(fragCoord.xy/iResolution.xy-vec2(.5),1.);\no.x*=1.777;\nfloat v=time_*3.14159*6.;\nvec3 p=vec3(sin(v)*5.,1.5,cos(v)*5.);\nvec3 d=normalize(vec3(o.x*cos(v)+o.z*sin(v),o.y+.3,-o.x*sin(v)+o.z*cos(v))-p);\nvec3 op=p;\nif(abs(o.x)<1.)\nfragColor=vec4(0.,0.,0.,1.); \nfor(int i=0;i<120;++i)\n{\nfloat g=1000000.;\nfloat ra=time_*3.14159*30.;\nvec3 qz=vec3(p.x*0.7071+p.y*0.7071,p.y*0.7071-p.x*0.7071,p.z);\nvec3 qy=vec3(p.x*0.7071+p.z*0.7071,p.y,p.z*0.7071-p.x*0.7071);\nvec3 qx=vec3(p.x,p.y*0.7071+p.z*0.7071,p.z*0.7071-p.y*0.7071);\nfloat rb=ra+.2618;\ng=min(g,w(p,rb));\ng=min(g,w(-p,-ra));\ng=min(g,w(-p.yzx,-ra));\ng=min(g,w(p.zxy,rb));\ng=min(g,w(-p.zxy,-ra));\ng=min(g,w(qz,-rb));\ng=min(g,w(-qz,ra));\ng=min(g,w(-qy.yzx,ra));\ng=min(g,w(-qx.zyx,-rb));\ng=min(g,w(qz.yxz,ra));\ng=min(g,w(-qz.yxz,-rb));\ng=min(g,w(-qy.yxz,-rb));\ng=min(g,w(-qx.yzx,ra));\ng=min(g,w(p.yzx,rb));\ng=min(g,w(qy.yzx,-rb));\ng=min(g,w(qx.zyx,ra));\ng=min(g,w(qy.yxz,ra));\ng=min(g,w(qx.yzx,-rb));\ng=max(g,length(p)-.5);\ng=max(g,.45-length(p));\nif(g<.001)\n{\nfragColor = vec4(1.-float(i)/200.)*(dot(normalize(p),normalize(op))*.4+.6)*vec4(.9,.6,.0,1.);\nbreak;\n}\np+=d*.3*g;\nif(distance(p,op)>6.)break;\n}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 148], [150, 150, 207, 207, 1394]], "test": "valid"}
{"id": "XlVczc", "name": "Old Television Frame", "author": "Minus256", "description": "This is display ratio free television lookalike frame for Pixel shader.\nyou can use it if you want.", "tags": ["2d", "beginner", "frame"], "likes": 2, "viewed": 176, "published": "Public", "date": "1537186733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragCord = abs(fragCoord*2.0-iResolution.xy/1.0);\n    float line = pow(fragCord.x/iResolution.x,20.0)+pow((fragCord.y+(iResolution.x-iResolution.y))/iResolution.x,20.0);\n    float minphase = abs(0.02*sin(iTime*10.0)+0.2*sin(fragCoord.y));\n    float frame = max(min(line+minphase,1.0),0.0);\n    \n    \n    \n//------------scene------------//\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec4 Color = vec4(col,1.0);\n//-----------------------------//\n    \n    \n    \n    vec4 colorinput = Color; //put fragcolor\n    \n    fragColor = colorinput - vec4(vec3(frame),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 794]], "test": "valid"}
{"id": "XlVczK", "name": "DRAGON BALL RADAR", "author": "tatsunoru", "description": "DRAGON BALL RADAR", "tags": ["radar", "ball", "dragon"], "likes": 16, "viewed": 256, "published": "Public", "date": "1536944502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 rotate(vec2 v, float c, float s){\n\treturn v * mat2(c, -s, s, c);\n}\n\nvec2 rotate(vec2 v, float r){\n    return rotate(v, cos(r), sin(r));\n}\n\nfloat center(float v){\n    float x = smoothstep(0.3, 0.7, v);\n    x = 1.0 - abs((x - 0.5) * 2.0);\n    return x;\n}\n\nfloat modNormalize(float a, float b){\n    return mod(a, b) / b;\n}\n\nvec2 sphereUV(vec2 pos){\n  \tfloat r = dot(pos, pos) * 0.75;\n\tfloat f = (1.0 - sqrt(abs(1.0 - r))) / r;\n\treturn vec2(pos.x * f, pos.y * f);\n}\n\nvec2 toOrigin(vec2 uv){\n\treturn (uv - 0.5) * 2.0;\n}\n\nvec2 fromOrigin(vec2 uv){\n\treturn uv * vec2(0.5, -0.5) + 0.5;\n}\n\nvec4 textureOrigin(sampler2D tex, vec2 v){\n    return texture(tex, fromOrigin(v));\n}\n\nfloat circle(vec2 base, vec2 pos, float radius){\n    return length(pos - base) - radius;\n}\n\nvec2 hash2(vec2 p){\n    vec2 q = vec2(dot(p, vec2(127.14684, 311.76987)), dot(p, vec2(269.5143, 183.3168)));\n\treturn fract(q) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 2.0;   \n    float len = length(uv);\n    uv = sphereUV(uv);  \n\n    float alpha = mod(atan(uv.y, uv.x) / 3.1415 * 0.5 + iTime / 5.0, 1.0);\n    float alphaoffset = (1.0 + alpha * 0.3);\n\n    float field = max(center(modNormalize(uv.x + 0.025, 0.05 * alphaoffset)), center(modNormalize(uv.y + 0.025, 0.05 * alphaoffset)));\n\n    vec4 ret = vec4(0.0, 0.8, 0.3, 0.0) * (1.0 - alpha * 4.0);\n    \n\tret = clamp(ret, 0.0, 1.0) + vec4(0.0, 0.2, 0.0, 0.0);\n    ret += smoothstep(0.48, 0.52, textureOrigin(iChannel0, uv).r) * clamp((1.0 - alpha * 2.0), 0.0, 1.0);\n    \n    ret += field * vec4(0.0, 0.3, 0.1, 1.0);\n    ret += field * field * field * vec4(0.0, 0.3, 0.1, 1.0) * 5.0;\n    \n    for(int i=0; i < 7; ++i){\n        vec2 hash = hash2(vec2(floor(iTime * 0.001), i)) * 0.8;\n        \n        float object = circle(uv, hash, 0.01);\n\t    object = ((1.0 - alpha) - smoothstep(0.0, 0.05, object) - 0.3) * 8.0;\n\n    \tret = mix(ret, vec4(1.0, 0.5, 0.1, 1.0) * pow(object, 2.0), clamp(object, 0.0, 1.0));\n    }\n    \t\n    vec4 col = ret * (1.0 - smoothstep(0.6, 1.0, len));\n    \n    col = mix(col, vec4(0.5) * pow(len, 12.0), smoothstep(0.99, 1.0, len) * (1.0 - smoothstep(1.1, 1.11, len)));\n    col = mix(col, vec4(0.0), smoothstep(1.05, 1.06, len) * (1.0 - smoothstep(1.06, 1.07, len)));\n    \n\tfragColor = col;\n\n}\n\n", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 72], [74, 74, 103, 103, 143], [145, 145, 167, 167, 258], [260, 260, 297, 297, 325], [327, 327, 351, 351, 467], [469, 469, 492, 492, 520], [522, 522, 547, 547, 585], [587, 587, 629, 629, 671], [673, 673, 721, 721, 763], [765, 765, 784, 784, 899], [901, 901, 958, 958, 2330]], "test": "error"}
{"id": "XlVyzV", "name": "Slice of a 3d mandelbrot", "author": "vegardno", "description": "Just trying out a generalisation of the Mandelbrot set to 3D.", "tags": ["mandelbrot"], "likes": 1, "viewed": 48, "published": "Public", "date": "1536993427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mul(vec3 p, vec3 q) {\n    return vec3(p.x * q.x + p.y * q.z - p.z * q.y,\n                p.x * q.y + p.y * q.x + p.z * q.z,\n                -p.x * q.z + p.y * q.y + p.z * q.x);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// https://github.com/kbinani/colormap-shaders/blob/master/shaders/glsl/IDL_Rainbow%2BBlack.frag\nvec4 colormap_hsv2rgb(float h, float s, float v) {\n\tfloat r = v;\n\tfloat g = v;\n\tfloat b = v;\n\tif (s > 0.0) {\n\t\th *= 6.0;\n\t\tint i = int(h);\n\t\tfloat f = h - float(i);\n\t\tif (i == 1) {\n\t\t\tr *= 1.0 - s * f;\n\t\t\tb *= 1.0 - s;\n\t\t} else if (i == 2) {\n\t\t\tr *= 1.0 - s;\n\t\t\tb *= 1.0 - s * (1.0 - f);\n\t\t} else if (i == 3) {\n\t\t\tr *= 1.0 - s;\n\t\t\tg *= 1.0 - s * f;\n\t\t} else if (i == 4) {\n\t\t\tr *= 1.0 - s * (1.0 - f);\n\t\t\tg *= 1.0 - s;\n\t\t} else if (i == 5) {\n\t\t\tg *= 1.0 - s;\n\t\t\tb *= 1.0 - s * f;\n\t\t} else {\n\t\t\tg *= 1.0 - s * (1.0 - f);\n\t\t\tb *= 1.0 - s;\n\t\t}\n\t}\n\treturn vec4(r, g, b, 1.0);\n}\n\nvec4 colormap(float x) {\n\tif (x < 0.0) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else if (1.0 < x) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else {\n\t\tfloat h = clamp(-9.42274071356572E-01 * x + 8.74326827903982E-01, 0.0, 1.0);\n\t\tfloat s = 1.0;\n\t\tfloat v = clamp(4.90125513855204E+00 * x + 9.18879034690780E-03, 0.0, 1.0);\n\t\treturn colormap_hsv2rgb(h, s, v);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -2 to 2)\n    vec3 c = 2. * vec3(2. * fragCoord / iResolution.xy - vec2(1., 1.), 0);\n\n    c = (rotationMatrix(vec3(1., 0., 0.), 1.0 * iTime) * vec4(c, 0)).xyz;\n    //c = (rotationMatrix(vec3(0., 1., 0.), 0.3 * iTime) * vec4(c, 0)).xyz;\n    //c = (rotationMatrix(vec3(0., 0., 1.), 0.7 * iTime) * vec4(c, 0)).xyz;\n    \n    const int n = 100;\n    \n    vec3 z = vec3(0., 0., 0.);\n    \n    int i;\n    for (i = 0; i < n; ++i) {\n        z = mul(z, z) + c;\n        if (length(z) > 4.)\n            break;\n    }\n\n    // Output to screen\n    fragColor = colormap(log(float(i)) / log(float(n)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVyzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 183], [185, 254, 299, 299, 927], [929, 1026, 1076, 1076, 1598], [1600, 1600, 1624, 1624, 1958], [1960, 1960, 2017, 2068, 2644]], "test": "valid"}
{"id": "XlyczV", "name": "wooohey", "author": "thewhiteambit", "description": "just for fun", "tags": ["simple"], "likes": 3, "viewed": 75, "published": "Public", "date": "1536873028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvOrig = uv;\n\n    uv.x = abs(-cos(iTime + uvOrig.y) * uvOrig.x);\n    uv.y = abs(sin(iTime - uvOrig.x) * uvOrig.y);\n    \n    //uvOrig = uv;\n    // Time varying pixel color\n    vec3 col;\n    col.x = 0.5*abs(cos(5.0*iTime+30.0*uv.y) / sin(13.0*iTime+30.0*uv.x));\n    col.y = 0.5*abs(cos(7.0*iTime+30.0*uv.y+2.0) / sin(17.0*iTime+30.0*uv.x+2.0));\n    col.z = 0.5*abs(cos(11.0*iTime+30.0*uv.y+4.0) / sin(3.0*iTime+30.0*uv.x+4.0));\n    \n\tvec4 texCol=texture(iChannel0, uvOrig);\n    // Output to screen\n    //if(texCol.x>.5 && texCol.y<.1 &&texCol.z<1.1)\n    if(texCol.x>0.2)\n        fragColor = texCol;\n    else\n    \tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 796]], "test": "error"}
{"id": "XlyyDD", "name": "[twitch] Gears of Time", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/9f8dbeeab1f583db332338230c68d40e[/url]", "tags": ["gears", "pastel"], "likes": 23, "viewed": 1424, "published": "Public API", "date": "1536182503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define tau (pi*2.)\n\n#define saturate(a) clamp(a,0.,1.)\n\nfloat tooth(float x, float offset, float scale)\n{\n    return saturate((abs(x-.5)-offset)*scale)*.12;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nvec3 pal(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a+b*cos(tau*(c*t+d));\n}\n\nvec3 rainbow(float t)\n{\n    return pal(\n        vec3(.5),\n        vec3(.5),\n        vec3(1),\n        vec3(0,1,2)/3.,\n        t\n    );\n}\n\nvec4 plasma(vec2 uv)\n{\n    return vec4(rainbow(fract(atan(uv.x, uv.y) / tau)), 1);\n}\n\nfloat tick(float time)\n{\n    float t = saturate(fract(time)*3.);\n    const float k = 2.;\n    return (sin(mix(-k,k,t))/sin(k))*.5+.5;\n}\n\nconst float DEPTH_EXPONENT = 1.15;\nconst float ATTENUATION = .2;\nconst float SPIRAL_RADIUS = .3;\nconst float FLIGHT_SPEED = 3.;\nconst float GEAR_THICKNESS = .2;\nconst float SPIRAL_PERIOD_SCALE = .4;\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 screenUv = fragCoord.xy / iResolution.xy;\n\n    vec2 baseUv = gl_FragCoord.xy / iResolution.xy - .5;\n    baseUv.x *= iResolution.x / iResolution.y;\n    baseUv *= .65;\n    baseUv.y -= .05;\n\n    out_color = vec4(1,0,0,1);\n\n    for (int i = 20; i >= 0; --i)\n    {\n        vec2 uv = baseUv;\n        vec2 uv2 = baseUv;\n        float depth = float(i) - fract(iTime*FLIGHT_SPEED);\n        float depth2 = depth + GEAR_THICKNESS;\n\n        uv *= pow(DEPTH_EXPONENT, depth);\n        uv2 *= pow(DEPTH_EXPONENT, depth2);\n\n        uv -= vec2(\n            sin(depth*SPIRAL_PERIOD_SCALE),\n            cos(depth*SPIRAL_PERIOD_SCALE)-1.\n        )*SPIRAL_RADIUS;\n        uv2 -= vec2(\n            sin(depth2*SPIRAL_PERIOD_SCALE),\n            cos(depth2*SPIRAL_PERIOD_SCALE)-1.\n        )*SPIRAL_RADIUS;\n\n        vec2 uvWithoutRotation = uv;\n\n        uv = rotate(uv, -tick(iTime+depth*.1) * (tau / 12.));\n\n        float a = atan(uv.x, uv.y) / tau;\n        float gear1 = (length(uv) - .8) + tooth(fract(a * 12.), .175, 8.);\n        float gear2 = (length(uv) - .83) + tooth(fract(a * 12.), .23, 8.);\n        float gear3 = (length(uv2) - .8) + tooth(fract(a * 12.), .175, 8.);\n\n        vec4 color = vec4(0);\n        if (gear1 > 0.)\n        {\n            color = mix(\n                vec4(rainbow(depth*.1),1),\n                vec4(rainbow(depth*.1)*.6,1),\n                saturate(gear2*30.+.5)\n            );\n        }\n        else if (gear3 > 0.)\n        {\n            color = vec4(rainbow(depth*.1)*.1,1);\n        }\n        color = saturate(color);\n\n        out_color = mix(out_color, color, color.a) * pow(.997, depth*depth);\n    }\n    out_color = pow(out_color, vec4(.4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 127, 127, 180], [182, 182, 212, 212, 335], [337, 337, 388, 388, 423], [425, 425, 448, 448, 560], [562, 562, 584, 584, 646], [648, 648, 672, 672, 782], [984, 984, 1036, 1036, 2699]], "test": "valid"}
{"id": "XlyyRG", "name": "stripes 02 with blend", "author": "piotrus04", "description": "blend shader", "tags": ["blend"], "likes": 1, "viewed": 77, "published": "Public", "date": "1536945439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float user1 = 0.3; \nfloat user2 = 0.5; \nfloat user3 = 0.1;\nfloat user4 = 0.1;\nfloat user5 = 0.1;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float amount = user1 * user1; // amount\n    \n    float size = user2; // worm size\n    \n    float fadein = user3; // fadein smooth\n    float fadeout = user4; // fadeout smooth\n    \n    const float speedfactor = 150.0; // speed mult\n\n    float offset = user5;\n    \n    float u = fragCoord.x/iResolution.x;\n    \n    u = u * 2.0 -1.0; // ramene au centre\n    \n    u *= amount * iResolution.x * 0.03;\n    \n    float rampTime = mod(offset + u + iTime * amount * speedfactor, 1.0);\n   \n    u = rampTime;\n\n    u = u * 2.0 -1.0; // centre\n    u *= (1.0-(pow(size, 0.1)))*20.0; // scale\n    \n    float dista = 1.0 - (distance(0., u)*2.0);\n\n    \n    fragColor = vec4(dista);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyyRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 157, 157, 828]], "test": "valid"}
{"id": "XlyyWc", "name": "Assignment 2 JBtheHUT", "author": "JBtheHUT1988", "description": "attempt of assignment 2", "tags": ["school"], "likes": 1, "viewed": 113, "published": "Public", "date": "1537899540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://github.com/yuichiroharai/glsl-y-rotate/blob/master/rotateY.glsl\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateZ(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, s, 0.0,\n        -s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t\t\n\t);\n}\n\nfloat kEpsilon = 1e-8;\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+trd = p(u,v) = vo + u(v1-v0) + v(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n/*\nbool triangleTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir,\n                    out float v, out float t)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+trd = p(u,v) = vo + u(v1-v0) + v(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n     v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n     t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.0)\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n*/\n\n\n\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n    if(t < 0.001)\n        return false;\n    \n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\nbool planeTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\n\n//send a ray toward a sphere?\n//return true if it intersects sphere\n//also set the intersecting 3D Point\n//and reflected Ray direction\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 spherePos, in float sphereRadius,\n\tout vec3 intersectPos, out vec3 intersectDir) {\n\n\t//create a vector from ray Starting Point to Sphere Center\n\tvec3 L = spherePos - rayPos;\n\n\t//project that ray onto my ray direction and get its length\n\tfloat tc = dot(L, rayDirection);\n\n\tif (tc < 0.0)\n\t\treturn false;\n\n\t//float d = sqrt(pow(length(L), 2.0) - pow(tc,2.0));\n\tfloat d = sqrt(dot(L, L) - pow(tc, 2.0));\n\tif (d > sphereRadius)\n\t\treturn false;\n\n\tfloat t1c = sqrt(pow(sphereRadius, 2.0) - pow(d, 2.0));\n\n\t//distance from ray Start to hitting the sphere\n\tfloat t1 = tc - t1c;\n\n\t//results in 3D point where ray hits the sphere\n\tintersectPos = rayPos + rayDirection * t1;\n\n\tvec3 normal = normalize(intersectPos - spherePos);\n\n\tintersectDir = reflect(rayDirection, normal);\n\n\treturn true;\n\n}\n\nconst ivec3 CUBE_INDEX[12] = ivec3[12](\n\tivec3(0, 1, 2),\n\tivec3(2, 1, 3),\n\tivec3(2, 3, 4),\n\tivec3(4, 3, 5),\n\tivec3(4, 5, 6),\n\tivec3(6, 5, 7),\n\tivec3(6, 7, 0),\n\tivec3(0, 7, 1),\n\tivec3(1, 7, 3),\n\tivec3(3, 7, 5),\n\tivec3(6, 0, 4),\n\tivec3(4, 0, 2)\n\t);\n\n//verts position\nconst vec3 CUBE_VERTS[8] = vec3[8](\n\tvec3(-0.25, -0.25, 0.25),\n\tvec3(0.25, -0.25, 0.25),\n\tvec3(-0.25, 0.25, 0.25),\n\tvec3(0.25, 0.35, 0.25),\n\tvec3(-0.25, 0.25, -0.25),\n\tvec3(0.25, 0.25, -0.25),\n\tvec3(-0.25, -0.25, -0.25),\n\tvec3(0.25, -0.25, -0.25)\n\t);\n\n//Cone:\n\nconst ivec3 CONE_INDEX[8] = ivec3[8](\n    ivec3( 0 ,  4 ,  3 ), \n    ivec3( 0 ,  1 ,  5 ), \n    ivec3( 1 ,  2 ,  5 ), \n    ivec3( 2 ,  3 ,  5 ), \n    ivec3( 3 ,  4 ,  5 ), \n    ivec3( 4 ,  0 ,  5 ), \n    ivec3( 4 ,  0 ,  5 ), \n    ivec3( 4 ,  0 ,  5 ) \n    );\n\nconst vec3 CONE_VERTS[6] = vec3[6](\n    vec3( 0.309017121792 ,  -1.0 ,  -0.951056599617 ), \n    vec3( -0.809017002583 ,  -1.0 ,  -0.587785363197 ), \n    vec3( -0.809017062187 ,  -1.0 ,  0.587785243988 ), \n    vec3( 0.30901697278 ,  -1.0 ,  0.951056540012 ), \n    vec3( 1.0 ,  -1.0 ,  0.0 ), \n    vec3( 0.0 ,  1.0 ,  0.0 ) \n    );\n\n\n//Cuboid:\nconst vec3 CUBOID_VERTS[12] = vec3[12](\n    vec3( 0.0 ,  0.0 ,  -1.0 ), \n    vec3( 0.723606824875 ,  0.525731086731 ,  -0.447213590145 ), \n    vec3( -0.276393264532 ,  0.850650906563 ,  -0.44721364975 ), \n    vec3( -0.8944272995 ,  -7.81933167104e-08 ,  -0.44721364975 ), \n    vec3( -0.276393294334 ,  -0.850650787354 ,  -0.447213590145 ), \n    vec3( 0.72360676527 ,  -0.525731146336 ,  -0.447213590145 ), \n    vec3( 0.8944272995 ,  0.0 ,  0.44721364975 ), \n    vec3( 0.276393175125 ,  0.850650846958 ,  0.447213590145 ), \n    vec3( -0.72360688448 ,  0.525731086731 ,  0.44721364975 ), \n    vec3( -0.72360676527 ,  -0.52573120594 ,  0.447213590145 ), \n    vec3( 0.276393324137 ,  -0.850650787354 ,  0.447213590145 ), \n    vec3( 0.0 ,  0.0 ,  1.0 ) \n    );\nconst ivec3 CUBOID_INDEX[20] = ivec3[20](\n    ivec3( 0 ,  2 ,  1 ), \n    ivec3( 0 ,  3 ,  2 ), \n    ivec3( 0 ,  4 ,  3 ), \n    ivec3( 0 ,  5 ,  4 ), \n    ivec3( 0 ,  1 ,  5 ), \n    ivec3( 1 ,  2 ,  7 ), \n    ivec3( 2 ,  3 ,  8 ), \n    ivec3( 3 ,  4 ,  9 ), \n    ivec3( 4 ,  5 ,  10 ), \n    ivec3( 5 ,  1 ,  6 ), \n    ivec3( 1 ,  7 ,  6 ), \n    ivec3( 2 ,  8 ,  7 ), \n    ivec3( 3 ,  9 ,  8 ), \n    ivec3( 4 ,  10 ,  9 ), \n    ivec3( 5 ,  6 ,  10 ), \n    ivec3( 6 ,  7 ,  11 ), \n    ivec3( 7 ,  8 ,  11 ), \n    ivec3( 8 ,  9 ,  11 ), \n    ivec3( 9 ,  10 ,  11 ), \n    ivec3( 10 ,  6 ,  11 ) \n    );\n\n\n\nconst vec3 SPHERE_POS[3] = vec3[3](vec3(2.0, 0.5, -1.0),\n\tvec3(0.5, 0.0, 0.0),\n\tvec3(0.55, 0.25, -1.0)\n\n\t);\n\nconst vec3 SPHERE_COLOR[3] = vec3[3](vec3(1.0, 2.0, 01.0),\n\tvec3(0.5, 0.5, 0.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\nconst float SPHERE_RADIUS[3] = float[3](0.5, 0.3, 0.1\n\t);\n\nconst vec3 LIGHT_POS[3] = vec3[3](vec3(1.0, 10.0, 0.0),\n\tvec3(-5.0, 2.5, 5.0),\n\tvec3(2.5, 2.5, 10.0)\n\n\t);\n\nconst vec3 LIGHT_COLOR[3] = vec3[3](vec3(0.0, 0.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.y;\n\tuv -= 0.5; //center the uvs\n\n\n\tvec3 cubePos = vec3(0.5, 0.55, -1.0);//*rotateZ(iTime / 2.0);\n    \n\tvec3 conePos = vec3(3.0, 1.05, -0.5);//*rotateZ(iTime / 2.0);\n    \n\tvec3 cubdPos = vec3(-1.0, 1.05, -0.5);//*rotateZ(iTime / 2.0);\n\n\n\tvec3 lightPos = vec3(0, 10, 0);\n\tvec3 lightPos2 = vec3(5, 0, 5);\n\n\t//vec3 rayPos = vec3(uv.x, uv.y + 2.0, 7.0);\n    vec3 rayPos = vec3(0.0,0.5, 3.0);//*rotateY(iTime / 2.0);\n\t\n\tvec3 rayDir = normalize(vec3(uv.x*3.0, uv.y *3.0, -3.0));//*rotateY(iTime / 2.0));\n\n\tvec3 planePos = vec3(0.0, -0.25, 0.0);\n\tvec3 planeNormal = vec3(0.0, 1.0, 0.0);\n    \n\tvec3 planePos_A = vec3(0.0, 0.0, -2.0);\n\tvec3 planeNormal_A = vec3(0.0, 0.0, 1.0);\n    \n\tvec3 planePos_B = vec3(-1.5, 0.0, 0.0);\n\tvec3 planeNormal_B = vec3(1.0, 0.0, 0.0);\n\n\n\tvec3 newPos;\n\tvec3 newDir;\n\tvec3 currColor;\n\n\tvec3 col = vec3(0.0);\n\n\t//loop for ray bounces\n\tfor (int r = 0; r <2; r++) {\n\n\t\t//col = vec3(0.0);\n\n\t\tfloat minDist = 999999999.0;\n\t\tvec3 tempNewPos;\n\t\tvec3 tempNewDir;\n\n\t\t//foreach sphere in our scene check if ray hits it\n\t\tfor (int s = 0; s < 3; s++) {\n\n\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\tif (sphereTrace(rayPos, rayDir,\n\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = SPHERE_COLOR[s];\n\n\t\t\t\t}\n\n\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t}\n\n\t\t}\n        \n        //end of sphere Tracing, still bouncing rays tho\n        \n        \n        \n\t\tfor (int f = 0; f < 12; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CUBE_VERTS[CUBE_INDEX[f].x] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].y] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].z] * rotateY(iTime) + cubePos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(0.5,0.0,1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        \n        \n\t\tfor (int f = 0; f < 8; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CONE_VERTS[CONE_INDEX[f].x] * rotateY(iTime) + conePos,\n                              CONE_VERTS[CONE_INDEX[f].y] * rotateY(iTime) + conePos,\n                              CONE_VERTS[CONE_INDEX[f].z] * rotateY(iTime) + conePos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(0.5,0.0,1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n\t\tfor (int f = 0; f < 20; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CUBOID_VERTS[CONE_INDEX[f].x] * rotateY(iTime) + cubdPos,\n                              CUBOID_VERTS[CONE_INDEX[f].y] * rotateY(iTime) + cubdPos,\n                              CUBOID_VERTS[CONE_INDEX[f].z] * rotateY(iTime) + cubdPos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rrr;//vec3(1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        \n        //------------------------------planeTracing------------------------\n        \n\n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos, planeNormal,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rrr;//vec3(1.0);\n\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n        \n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos_A, planeNormal_A,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = vec3(0.05,0.8,2.0);\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n        \n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos_B, planeNormal_B,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = vec3(0.5,0.80,0.20);\n\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n        \n        //------------------------------End planeTracing------------------------\n\n\n\n\t\tif (minDist < 50.0) { //make sure this ray doesn't hit anything\n\n\t\t\trayPos = newPos;\n\t\t\trayDir = newDir;\n\n\n\t\t//\t col = newDir;\n        //    col = vec3(minDist/50.0);\n\n\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t//now let's check if this ray can see the light sources\n\n\t\t\t\tvec3 lightDir = normalize(LIGHT_POS[l] - rayPos);\n\t\t\t\tfloat lightDist = 9999999.9f;\n\n\n\t\t\t\tfor (int s = 0; s < 3; s++) {\n\n\t\t\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\t\t\tif (sphereTrace(rayPos, lightDir,\n\t\t\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int f = 0; f < 12; f++) {\n\t\t\t\t\tif (triangleTrace(rayPos, lightDir,\n\t\t\t\t\t\t\t\tCUBE_VERTS[CUBE_INDEX[f].x] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].y] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].z] * rotateY(iTime) + cubePos,\n                                      tempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                \n                \n                //likely need the cuboid and cone trace here as well\n\n\t\t\t\tif (planeTrace(rayPos, lightDir,\n\t\t\t\t\tplanePos, planeNormal,\n\t\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\tlightDist = dist;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t\t}\n\n\n\t\t\t\tif (lightDist > distance(rayPos, LIGHT_POS[l])) {\n\t\t\t\t\tcol += (currColor*0.15 //ambient\n\t\t\t\t\t\t+ clamp(dot(rayDir, lightDir), 0.0, 1.0)*currColor //diffuse\n\t\t\t\t\t\t+ pow(clamp(dot(rayDir, lightDir), 0.0, 1.0), 50.8) * LIGHT_COLOR[l]\n\n\t\t\t\t\t\t) * (1.0/(float(r) + 1.0))\n\t\t\t\t\t\t* 50.0 / pow(distance(rayPos, LIGHT_POS[l]), 2.0);\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t}\n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 99, 99, 204], [206, 206, 231, 231, 345], [371, 371, 528, 528, 1307], [1309, 2290, 2432, 2432, 2768], [2770, 2770, 2914, 2914, 3205], [3208, 3343, 3489, 3550, 4188], [5309, 7164, 7219, 7266, 14242]], "test": "error"}
{"id": "Xt3BRn", "name": "I made a thing", "author": "EFHIII", "description": "I still barely know how these things work so I'm going slow.", "tags": ["circle"], "likes": 2, "viewed": 319, "published": "Public API", "date": "1538269927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float dist=length(fragCoord-vec2(iResolution.x/2.,iResolution.y/2.))-100.;\n    \n    float grad = smoothstep(0.,1.,dist);\n    \n    vec3 col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*grad+\n        \t   (0.5 + 0.5*sin(iTime+uv.xyx*4.+vec3(0,2,4)))*(1.-grad);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3BRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 503]], "test": "valid"}
{"id": "XtcfRn", "name": "Gold Agate", "author": "JuliaPoo", "description": "This was the effect I wanted, smokey and kinda neon", "tags": ["fbm", "smoke", "agate"], "likes": 22, "viewed": 1076, "published": "Public API", "date": "1538281755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot( float a ){ return mat2( sin(a),  cos(a), -cos(a),  sin(a) ); }\n\nfloat noise( in vec2 x ){ return smoothstep(0.,1.,sin(1.5*x.x)*sin(1.5*x.y)); }\n\nfloat fbm( vec2 p ){\n    \n    mat2 m = rot(.4);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pattern (in vec2 p, out vec2 q, out vec2 r, float t){\n   \n    \n\tq.x = fbm( 2.0*p + vec2(0.0,0.0) + 2.*t );\n    q.y = fbm( 1.5*p + vec2(5.2,1.3) + 1.*t );\n\n    r.x = fbm( p + 4.*q + vec2(1.7,9.2) + sin(t) + .9*sin(30.*length(q)));\n    r.y = fbm( p + 8.*q + vec2(8.3,2.8) + cos(t) + .9*sin(20.*length(q)));\n\n    return fbm( p + 7.*r*rot(t) );\n    \n}\n\nvoid mainImage(out vec4 C, in vec2 U){\n    \n    vec2 uv = (U.xy-iMouse.xy)/iResolution.xy * 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 q,r;\n    vec3 col1 = vec3(.9,.7,.5);\n    vec3 col2 = vec3(.3,.5,.4);\n    vec3 c;\n    \n    float f = pattern(uv, q, r, 0.1*iTime);\n    \n    //mix colours\n    c = mix(col1, vec3(0), pow(smoothstep(.0,.9,f), 2.));\n    c += col2 * pow(smoothstep(0., .8, dot(q,r)*.6), 3.) * 1.5;\n    //add contrast\n    c *= pow(dot(q,r) + .3, 3.);\n    //soften the bright parts\n    c *= f*1.5;\n    \n    //c += vec3(1.7,1.2,1.2) * dot(q,r);\n    //c += vec3(.2) * smoothstep(0., .2,pow(length(q),3.));\n    //c += dot(q,r);\n    //c += smoothstep(0.,3.,pow(length(df),0.12));\n    \n\n    C = vec4( c, 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 72], [74, 74, 99, 99, 153], [155, 155, 175, 175, 447], [450, 450, 509, 509, 803], [805, 805, 843, 843, 1534]], "test": "valid"}
{"id": "XtGcDz", "name": "HomeworkPractice1", "author": "elijah_green14", "description": "homework", "tags": ["practice"], "likes": 1, "viewed": 53, "published": "Public", "date": "1536170974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //Colors\n    vec3 fgColor = vec3(0.741, 0.635, 0.471);\n\tvec3 bgColor = vec3(0.192, 0.329, 0.439);\n    \n    //Triangle barycentric coordinates defined on screen space\n    vec2 t0 = vec2(0.25, 0.25);\n\tvec2 t1 = vec2(0.75, 0.25);\n\tvec2 t2 = vec2(0.50, 0.85);\n    vec2 tCentroid  = (t0 + t1 + t2)/3.0;    \n    //Compute UV coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 v0 = t2 - t0;\n    vec2 v1 = t1 - t0;\n    vec2 v2 = uv - t0;\n\t\n    //Compute barycentric coordinates \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0/(dot00 * dot11 - dot01 * dot01);\n    float baryX = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float baryY = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    if((baryX >= 0.0) && (baryY >= 0.0) && (baryX + baryY <= 1.0)) {\n    \tfragColor = vec4(fgColor, 1.0);\n    } else {\n        fragColor = vec4(bgColor, 1.0);\n    }\n    \n    \n    \n    \n    vec3 col = vec3(0.0);\n    \n    vec2 p = (2.0 *fragCoord.xy - iResolution.xy)/iResolution.y;\n    p *= 1.5;\n    \n    // circle measurement set up\n     vec2 m = (2.0 *iMouse.xy - iResolution.xy)/iResolution.y;\n    m *= 1.5;\n    float distFromCircle = distance(p,m);\n    float radius = 0.5f;\n    \n    vec3 normal;\n    \n    \n    \n     col = vec3(0.0);\n    float checkerSize = 20.0;\n    vec3 checkCol = vec3(0.0);\n    //cicle drawing   \n     //handle X direction\n    if(int(fragCoord.x/checkerSize) % 2 == 0){\n        if(int(fragCoord.y/checkerSize) % 2 == 0)\n        \tcheckCol = vec3(1.0);\n        \n    }\n    else // fragCoord.X % 2 == 1\n    \tif(int(fragCoord.y/checkerSize) % 2 == 1)\n       \tcheckCol = vec3(1.0);\n        \n    if(distFromCircle < radius)\n        col = checkCol;\n    \n    \n    \n    \n    \n     // oval measurement set up\n    p = ((2.0 *fragCoord.xy - iResolution.xy)/iResolution.xy)*vec2(5, 10);\n    distFromCircle = distance(p,vec2(-0.8,0.6));\n    radius = 0.5f;\n    //oval drawing    \n    if(distFromCircle < radius)\n        col = vec3(1.0);\n   \n    \n    // square darawing\n    float size = 0.08;\n    float smoothness = 2.0 / iResolution.x;\n    uv = (fragCoord.xy -0.9 * iResolution.xy) / iResolution.x * rotate(iTime / .5); // green\n\tvec2 uv2 = ((fragCoord.xy -0.2 * iResolution.xy) * rotate(iTime / 3.0)/ iResolution.xy );// red\n    \n\n    \n    // Thanks to FabriceNeyret2 for this clever snippet!\n    uv = abs(uv);\n    uv2 = abs(uv2);\n    float d = max(uv.x, uv.y);\n    float d2 = max(uv2.x, uv2.y);\n    \n    //red square output\n    fragColor += vec4(smoothstep(size, size - smoothness, d2),0,0,0);\n    //green square output\n    fragColor += vec4(0,smoothstep(.02, .02 - smoothness, d),0,0);\n   \t//white circle output\n    fragColor += vec4(col,0.0);\n\n\n}\n\n//Credits To:\n//https://www.shadertoy.com/view/llsXzn\n//https://www.shadertoy.com/view/llGcWz\n//", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 131, 2918]], "test": "valid"}
{"id": "XtGcWh", "name": "ASMR Crawler", "author": "Janitorhell", "description": "Started with the Circle Tutorial, then added the Rectangle and finally wound up here.", "tags": ["meditation", "asmr", "calming"], "likes": 0, "viewed": 95, "published": "Public", "date": "1535946283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) \n{\n\n   float d = length(uv-p);\n   float c = smoothstep(r, r-blur, d);\n   return c;\n    \n}\n\nfloat Band(float t, float start, float end, float blur)\n{\n \n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1*=step2;\n\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n \n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1*=band2;\n\n}\n\n\nfloat Smiley(vec2 uv, vec2 p, float size, float bluramt)\n{\n    \n    uv -= p; //translating coordinate system\n    uv /= size; //scaling coordinate\n    \n    float mask1 = Circle(uv, vec2(0.), .41, bluramt);\n    //Top Bottom Center\n    mask1 -= Circle(uv, vec2(0., .310), .085, bluramt);\n    mask1 -= Circle(uv, vec2(0., -.310), .085, bluramt);\n    //Top Quarters\n    mask1 -= Circle(uv, vec2(-.22, -.22), .085, bluramt);\n    mask1 -= Circle(uv, vec2(.22, -.22), .085, bluramt);\n     //Bottom Quarters\n    mask1 -= Circle(uv, vec2(-.22, .22), .085, bluramt);\n    mask1 -= Circle(uv, vec2(.22, .22), .085, bluramt);\n    //Right left center\n    //mask1 -= Circle(uv, vec2(-.310, 0.), .085, bluramt);\n    //mask1 -= Circle(uv, vec2(.310, 0.), .085, bluramt);\n    \n    float mouth = Circle(uv, vec2(0., 0.), .33, bluramt); // outer edge of Black circle\n    //mouth -= Circle(uv, vec2(0., 0.), .25, bluramt); // inner edge of Black circle    \n    mouth += Circle(uv, vec2(0., 0.), .23, bluramt); //inner circle yellow\n    \n    mask1 -= mouth;\n    \n    return mask1;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    float ix = iResolution.x;\n    float iy = iResolution.y;\n    float bluramt = 0.2;\n\n    uv -= .5;\n    uv.x *= ix/iy;\n   \n    vec3 col = vec3(0.);\n    vec3 col1 = vec3(0.);\n    \n    float mask = 0.;\n    float mask1 = 0.;\n        \n        //Smiley(uv, vec2(.0, .0), .75, bluramt);\n    t = t * 3.;\n    \n    float x = uv.x;\n    float m =sin(t + x*40.)*.09;\n    float y = uv.y-m;\n   \n    \n    mask = Smiley(vec2(x, y), vec2(.0, .0), .90, .04);\n    mask1 = Rect(vec2(x, y), -.99, .99, -.3, .3, .02);\n        \n    col1 = vec3(.5, .5, 1.)*mask1;\n    col = vec3(1., .5, .5)*mask;\n    \n    \n    fragColor = vec4(col1, 2.)/+vec4(col, 2.);\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 140], [142, 142, 199, 199, 339], [341, 341, 424, 424, 552], [555, 555, 613, 613, 1619], [1622, 1622, 1679, 1729, 2426]], "test": "valid"}
{"id": "XtGyWc", "name": "Warp distortion", "author": "cacheflowe", "description": "Warping correction attempt for projections... Probably not very good.", "tags": ["wrap"], "likes": 1, "viewed": 102, "published": "Public", "date": "1537934414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n   return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat sineIn(float t) {\n  return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n\nfloat sineOut(float t) {\n  return sin(t * HALF_PI);\n}\n\nfloat quadraticIn(float t) {\n  return t * t;\n}\n\nfloat quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\nfloat gain(float x, float k) {\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvOrig = fragCoord/iResolution.xy;\n    \n    float controlX = 0.5 + 0.2 * sin(iTime);//iMouse.x;\n    \n    float distToControl = distance(controlX, uv.x);\n    distToControl *= 2.25;\n    distToControl = clamp(distToControl, 0., 1.);\n    distToControl = 1. - distToControl;\n    \n    \n    // calculate easing curve\n    // try sineInOut\n    float gainCurve = 1.2;\n    float curveLeft = gain( map(uv.x, 0.,controlX, 0., 1.), gainCurve );\n    float curveRight = gain( map(uv.x, controlX, 1., 0., 1.), gainCurve );\n\tfloat curveAmp = (uv.x < controlX) ? curveLeft : curveRight + 1.;\n    \n    // uv.x = mix(uv.x, curveAmp, 0.5);\n    uv.x = mix(uv.x, curveAmp / 2., 0.15);\n    \n    // display warped texture\n    fragColor = texture(iChannel0, uv);\n    \n    //////////////////////////////////////////\n    // debug\n    // black line\n    if(uv.y < 0.455) {\n    \tfragColor = vec4(0., 0., 0., 1.);\n    }\n    // original texture\n    if(uv.y < 0.45) {\n    \tfragColor = texture(iChannel0, uvOrig);\n    }\n    // black line\n    if(uv.y < 0.155) {\n    \tfragColor = vec4(0., 0., 0., 1.);\n    }\n    // show curve gradient\n    if(uv.y < 0.15) {\n      curveAmp = (uvOrig.x < controlX) ? curveLeft : 1.- curveRight;\n      fragColor = vec4(vec3(curveAmp), 1.);\n    }\n    // distance to controlX\n    if(uv.y < 0.1) {\n      fragColor = vec4(distToControl, distToControl, distToControl, 1.);\n    }\n    // controlX center\n    if(uv.y < 0.05) {\n      float direction = sign(controlX - uvOrig.x);\n      fragColor = vec4(vec3(direction), 1.);\n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 139, 139, 208], [210, 210, 234, 234, 256], [258, 258, 283, 283, 332], [334, 334, 364, 364, 418], [420, 420, 451, 451, 504], [506, 506, 532, 532, 571], [573, 573, 596, 596, 639], [641, 641, 665, 665, 694], [696, 696, 724, 724, 742], [744, 744, 773, 773, 800], [802, 802, 832, 832, 911], [913, 913, 970, 1020, 2584]], "test": "error"}
{"id": "XtGyWh", "name": "Shaderdough x-ray", "author": "tdhooper", "description": "X-ray rendering of [url=https://www.shadertoy.com/view/4tc3WB]Shaderdough[/url]", "tags": ["sdf", "twist", "pastel", "playdough"], "likes": 37, "viewed": 1584, "published": "Public API", "date": "1535899778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --------------------------------------------------------\n// OPTIONS\n// --------------------------------------------------------\n\n// Disable to see more colour variety\n//#define SEAMLESS_LOOP\n#define COLOUR_CYCLE\n#define HIGH_QUALITY\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n\n\nfloat t;\n\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat around an axis\nvoid pModPolar(inout vec3 p, vec3 axis, float repetitions, float offset) {\n    vec3 z = vec3(0,0,1);\n\tmat3 m = orientMatrix(axis, z);\n    p *= inverse(m);\n    pR(p.xy, offset);\n    pModPolar(p.xy, repetitions);\n    pR(p.xy, -offset);\n    p *= m;\n}\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc;\nvec3 pbc;\nvec3 pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\nfloat splitPlane(float a, float b, vec3 p, vec3 plane) {\n    float split = max(sign(dot(p, plane)), 0.);\n    return mix(a, b, split);\n}\n\nfloat icosahedronIndex(inout vec3 p) {\n    vec3 sp, plane;\n    float x, y, z, idx;\n\n    sp = sign(p);\n    x = sp.x * .5 + .5;\n    y = sp.y * .5 + .5;\n    z = sp.z * .5 + .5;\n\n    plane = vec3(-1. - PHI, -1, PHI);\n\n    idx = x + y * 2. + z * 4.;\n    idx = splitPlane(idx, 8. + y + z * 2., p, plane * sp);\n    idx = splitPlane(idx, 12. + x + y * 2., p, plane.yzx * sp);\n    idx = splitPlane(idx, 16. + z + x * 2., p, plane.zxy * sp);\n\n    return idx;\n}\n\nvec3 icosahedronVertex(vec3 p) {\n    vec3 sp, v, v1, v2, v3, result, plane;\n    float split;\n    v = vec3(PHI, 1, 0);\n    sp = sign(p);\n    v1 = v.xyz * sp;\n    v2 = v.yzx * sp;\n    v3 = v.zxy * sp;\n\n    plane = vec3(1, PHI, -PHI - 1.);\n\n    split = max(sign(dot(p, plane.xyz * sp)), 0.);\n    result = mix(v2, v1, split);\n    plane = mix(plane.yzx * -sp, plane.zxy * sp, split);\n    split = max(sign(dot(p, plane)), 0.);\n    result = mix(result, v3, split);\n\n    return normalize(result);\n}\n\n// Nearest vertex and distance.\n// Distance is roughly to the boundry between the nearest and next\n// nearest icosahedron vertices, ensuring there is always a smooth\n// join at the edges, and normalised from 0 to 1\nvec4 icosahedronAxisDistance(vec3 p) {\n    vec3 iv = icosahedronVertex(p);\n    vec3 originalIv = iv;\n\n    vec3 pn = normalize(p);\n    pModIcosahedron(pn);\n    pModIcosahedron(iv);\n\n    float boundryDist = dot(pn, vec3(1, 0, 0));\n    float boundryMax = dot(iv, vec3(1, 0, 0));\n    boundryDist /= boundryMax;\n\n    float roundDist = length(iv - pn);\n    float roundMax = length(iv - vec3(0, 0, 1.));\n    roundDist /= roundMax;\n    roundDist = -roundDist + 1.;\n\n    float blend = 1. - boundryDist;\n    blend = pow(blend, 6.);\n    \n    float dist = mix(roundDist, boundryDist, blend);\n\n    return vec4(originalIv, dist);\n}\n\n// Twists p around the nearest icosahedron vertex\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\n    vec4 a = icosahedronAxisDistance(p);\n    vec3 axis = a.xyz;\n    float dist = a.a;\n    mat3 m = rotationMatrix(axis, dist * amount);\n    p *= m;\n}\n\nvoid pTwistIcosahedron(inout vec3 p, vec3 center, float amount) {\n    p += center;\n    pTwistIcosahedron(p, amount);\n    p -= center;\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n     \nModel fInflatedIcosahedron(vec3 p, vec3 axis) {\n    float d = 1000.;\n    \n    # ifdef SEAMLESS_LOOP\n        // Radially repeat along the rotation axis, so the\n        // colours repeat more frequently and we can use\n        // less frames for a seamless loop\n        pModPolar(p, axis, 3., PI/2.);\n    # endif\n    \n    float idx = icosahedronIndex(p);\n\n    d = length(p) - .9;\n\n    // Colour each icosahedron face differently\n    # ifdef SEAMLESS_LOOP\n        if (idx == 3.) {\n            idx = 2.;\n        }\n        idx /= 10.;\n    # else\n        idx /= 20.;\n    # endif\n    # ifdef COLOUR_CYCLE\n        idx = mod(idx + t*1.75, 1.);\n    # endif\n\n    vec3 colour = spectrum(idx);\n    \n    d *= .6;\n    return Model(d, colour, 1.);\n}\n\nModel model(vec3 p) {\n    \n    float rate = PI/6.;\n    vec3 axis = pca;\n\n    vec3 twistCenter = vec3(0);\n    twistCenter.x = cos(0. * rate * -3.) * .6;\n\ttwistCenter.y = sin(0. * rate * -3.) * .6;\n\n\tmat3 m = rotationMatrix(\n        reflect(axis, vec3(0,1,0)),\n        t * -rate\n   \t);\n    p *= m;\n    twistCenter *= m;\n\n    pTwistIcosahedron(p, twistCenter, 10.5);\n\n\treturn fInflatedIcosahedron(p, axis);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\nconst float MAX_TRACE_DISTANCE = 6.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\n#ifdef HIGH_QUALITY\n\tconst float FUDGE_FACTOR = .2;\n#else\n\tconst float FUDGE_FACTOR = .6;\n#endif\n//--------------------------------\n// Modelling\n//--------------------------------\nModel map( vec3 p ){\n    return model(p);\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    t = iTime - .25;\n    //t = mod(t, 4.);\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3(3.,0,0);\n    vec3 camTar = -camPos;\n    float camRoll = 0.;\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    vec3 color = pow(vec3(.15,0,.2), vec3(2.2));    \n    \n    vec3 ro = camPos;\n    float t = 0.0;\n    float h = INTERSECTION_PRECISION * 2.0;\n    float res = -1.0;\n    vec3 colour;\n\n    for( int i=0; i< 500 ; i++ ){\n\n        if( t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = abs(m.dist);\n        t += max(INTERSECTION_PRECISION, h * FUDGE_FACTOR);\n        color += m.colour * pow(max(0., (.01 - h)) * 42., 10.) * 150.;\n        color += m.colour * .005 * FUDGE_FACTOR;\n    }\n    \n    color = pow(color, vec3(1./1.8)) * 1.5;\n    color = pow(color, vec3(1.2));\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 427, 472, 472, 938], [941, 1104, 1139, 1139, 1491], [1494, 1736, 1756, 1756, 1794], [1796, 1796, 1816, 1816, 1841], [1843, 2081, 2113, 2113, 2158], [2160, 2188, 2250, 2250, 2374], [2376, 2489, 2539, 2539, 2929], [2931, 2956, 3030, 3030, 3203], [3205, 3373, 3441, 3441, 3484], [3486, 3486, 3510, 3510, 3608], [3611, 3825, 3849, 3882, 4309], [4311, 4311, 4347, 4347, 4484], [4486, 4486, 4542, 4542, 4621], [4623, 4623, 4661, 4661, 5073], [5075, 5075, 5107, 5107, 5565], [5567, 5782, 5820, 5820, 6399], [6401, 6451, 6503, 6503, 6653], [6655, 6655, 6720, 6720, 6790], [6793, 6993, 7040, 7040, 7725], [7727, 7727, 7748, 7748, 8132], [8453, 8536, 8556, 8556, 8579], [8582, 8613, 8677, 8677, 8855], [8857, 8857, 8914, 8914, 10021]], "test": "error"}
{"id": "XtGyzK", "name": "Shader #1", "author": "jkashimura", "description": "HW", "tags": ["beginner"], "likes": 1, "viewed": 385, "published": "Public", "date": "1536852467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotate\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n\n// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-(radius*(tan(iTime*0.2)+6.));\n\n}\n\n\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = 0.1;\n    \n    // Transform coordinate space so spheres repeat\n    //vec3 q = fract(p) * 2.0 - 1.0;\n    vec3 q = fract(p)-0.5;\n\n    // Signed distance of sphere\n    return sphere(q, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 4.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * r* t *0.7 -sin(iTime);\n        float d = map(p)*2.;\n        t -= d;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n   /* if (mod(iTime,2.)=1.){\n   \tfloat FOV = 0.5;\n    }*/\n    //else{\n    float FOV = 3.;\n\n  //  }\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    ray.yz *= rot(iTime*0.1);\n    ray.zx *= rot(iTime*0.1);\n    \n    vec3 origin = vec3(10.0, 0.0, iTime);\n    float t = trace(origin, ray);\n    \n    \n    float linearFog = 2.0 / (1.0 - t*2.);\n    float expFog = 2.0 / (t*t*0.1);\n    \n    vec3 fc = vec3(iTime+iTime+uv.xy+vec2(5,3),expFog*7.);\n    //vec3 fc = vec3(expFog*7.);\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output pixels to screen\n    fragColor = vec4(fc,1.0);\n    \n    // Try oscilating the final pixels\n    fragColor = vec4(cos(fc*0.7)-sin(fc*0.7),6.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 28, 28, 96], [99, 113, 148, 148, 202], [206, 250, 269, 269, 480], [483, 483, 518, 518, 694], [697, 697, 754, 804, 1660]], "test": "valid"}
{"id": "XtKcDm", "name": "Fractal Spiders", "author": "Klems", "description": "Simple 3D fractal for my portfolio. It kind of looks like spiders.", "tags": ["procedural", "3d"], "likes": 24, "viewed": 2171, "published": "Public API", "date": "1536602193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n#define BORDER 4.0\n\n// hash function for dithering\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// hsv function\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = cos( 2.0*PI*c.x + 2.0*PI/3.0*vec3(3,2,1) ) * 0.5 + 0.5;\n\treturn c.z * mix(vec3(1), rgb, c.y);\n}\n\n// from iq filterable procedurals\nfloat grid( in vec3 p, in vec3 dp, in float N ) {\n    vec3 w = abs(dp);\n    vec3 a = p + 0.5*w;                        \n    vec3 b = p - 0.5*w;           \n    vec3 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return 1.0-(1.0-i.x)*(1.0-i.y)*(1.0-i.z);\n}\n\n// iq smin\nfloat smax( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// main distance function\nfloat de( vec3 p, float r, out float color ) {\n    \n    mat2 q = rot(sin(p.z*1.0)*0.8+0.6);\n    float t = length(p.xy);\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.0;\n    for (int i = 1 ; i <= 2 ; i++) {\n        float m = dot(p,p);\n        p = abs(fract(p/m)-0.5);\n        p.xy *= q;\n        s *= m;\n    }\n    d = (length(p.xz)-0.15)*s;\n    \n    color = 0.0;\n    color += grid(p*10.0*s, vec3(r)*s*500.0, 30.0)*0.2;\n    color += grid(p*10.0*s-0.03, vec3(r)*s*500.0, 100.0)*0.8;\n    \n    return smax(d,-t, 0.3);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if (any(greaterThan(fragCoord, iResolution.xy-BORDER)) ||\n        any(lessThan(fragCoord, vec2(BORDER)))) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    bool page = false;\n    vec2 uv = vec2(0);\n    if (iResolution.x > iResolution.y) {\n        uv = fragCoord/iResolution.xy;\n        uv = uv.yx-0.5;\n        uv.y *= iResolution.x/iResolution.y;\n        page = true;\n    } else {\n        fragCoord = iResolution.xy-fragCoord;\n    \tuv = (fragCoord - iResolution.x*0.5) / iResolution.x;\n    }\n    \n\tvec3 from = vec3(0);\n\t//vec3 dir = normalize(vec3(uv.x, 1.0 / tan(FOV*0.5), uv.y));\n    vec3 dir = normalize(vec3(uv.x, cos(length(uv*.5)), uv.y));\n    \n    mat2 rotx = rot(0.0);\n\tmat2 roty = rot(0.0);\n    \n\tif (iMouse.z > 0.5) {\n        vec2 delt = iMouse.xy-iMouse.zw;\n        if (page) {\n            delt = -delt.yx;\n        }\n        rotx = rot(-delt.x*0.004);\n        roty = rot(delt.y*0.004);\n    }\n\t\n\tdir.yz  *= roty;\n\tdir.xy  *= rotx;\n    from.z -= iTime*0.1;\n    \n    // dithering\n    vec3 dither = hash33(vec3(fragCoord.xy, iFrame));\n    \n    // get the sine of the angular extent of a pixel\n    float sinPix = sin(1.0 / iResolution.x)*1.5;\n    // accumulate color front to back\n    vec2 acc = vec2(0, 1);\n\n    float totdist = 0.0;\n    float dummy = 0.0;\n    totdist += dither.r*de(from, 0.0, dummy)*1.0;\n    \n\tfor (int i = 0 ; i < 80 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = totdist*sinPix;\n        float color = 0.0;\n        float dist = de(p, r, color);\n        color *= 1.0 - float(i) / 70.0;\n        \n        // cone trace the surface\n        float prox = dist / r;\n        float alpha = clamp(prox * -0.5 + 0.5, 0.0, 1.0);\n        \n        if (alpha > 0.01) {\n            // accumulate color\n            acc.x += acc.y * (alpha*color);\n            acc.y *= (1.0 - alpha);\n        }\n        \n        // hit a surface, stop\n        if (acc.y < 0.01) {\n            break;\n        }\n        \n        // continue forward\n        totdist += abs(dist*0.6);\n\t}\n    \n    // set random color per day\n    fragColor.rgb = hsv2rgb(vec3(totdist*0.3+iDate.w*0.001,\n                                 0.6, 0.4));\n    fragColor.rgb *= acc.x*0.99+0.01;\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    // dithering\n    fragColor.rgb += (dither-0.5)*0.01;\n    \n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKcDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 128, 150, 150, 274], [276, 292, 319, 319, 430], [432, 466, 515, 515, 763], [765, 776, 826, 826, 919], [921, 947, 993, 993, 1476], [1478, 1478, 1535, 1535, 3885]], "test": "error"}
{"id": "XtKcRG", "name": "particlepart", "author": "piotrus04", "description": "particle", "tags": ["particle"], "likes": 1, "viewed": 60, "published": "Public", "date": "1536945423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist2(vec2 a, vec2 b)\n{\n    return dot(a - b, a - b);\n}\n\nvec2 getDir(vec2 uv)\n{\n    float delta = 0.01;\n    float n = texture(iChannel0, vec2(uv.x, uv.y + delta)).r;\n    float s = texture(iChannel0, vec2(uv.x, uv.y - delta)).r;\n    float e = texture(iChannel0, vec2(uv.x + delta, uv.y)).r;\n    float w = texture(iChannel0, vec2(uv.x - delta, uv.y)).r;\n    vec2 dir = normalize(vec2(e - w, n - s));\n    return dir;\n}\n\nvec3 drawParticles(vec2 uv, vec2 ePos, vec2 dir, float time, float duration)\n{\n    vec3 col = vec3(0.0);\n   \t\n    float r = 0.0001; // size\n    const int particleCount = 50;\n    float delta = 5.0 / (duration * float(particleCount));\n    \n    \n    for (int i = 0; i < particleCount; i++)\n    {\n        float offset = float(i) / float(particleCount);\n        \n        vec2 pPos = ePos + mod(offset + delta * time, 1.0) * dir;\n    \tfloat fade = (1.0 - dist2(pPos, ePos));\n   \t\tcol += mix(vec3(1.0, 1.0, 1.0), vec3(0.0), smoothstep(0.0, r, dist2(uv, pPos))) * fade;\n    }\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.3;\n        uv.y -= 0.3;\n    \n    fragColor = vec4(0.0);\n\tfragColor += vec4(drawParticles(uv, vec2(0.5, 0.0), vec2(0.0, 1.0),  mod(iTime, 3.0), 3.0),1.0);\n //   fragColor += vec4(drawParticles(uv, vec2(0.5, 0.0), vec2(1.0, 1.0),  mod(iTime, 4.0), 2.0),1.0);\n //   fragColor += vec4(drawParticles(uv, vec2(0.5, 0.0), vec2(-1.0, 1.0), mod(iTime, 3.0), 1.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 61], [63, 63, 85, 85, 421], [423, 423, 501, 501, 1014], [1016, 1016, 1073, 1073, 1534]], "test": "error"}
{"id": "XtKcWh", "name": "Sort3", "author": "CeeJayDK", "description": "An algorithm for sorting 3 numbers.\n\nI saw iq try his hand at an algorithm for sorting 3 floats ( https://twitter.com/iquilezles/status/559477513139675136 ) and wondered if I could do better. I hope I succeeded. UPDATE: Nope. I failed. ", "tags": ["sort", "median"], "likes": 0, "viewed": 555, "published": "Public API", "date": "1536007944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I'm doing swaps using swizzles to network sort 3 values. \n//You can design your own network sorts using http://pages.ripco.net/~jgamble/nw.html\n\nvec3 sort3( vec3 c ) //this is the sorting algoritm this Shadertoy is about.\n{\n    //1st cycle\n\tc.rg = (c.r < c.g) ? c.rg : c.gr; //2 op\n\n\t//2st cycle\n\tc.rb = (c.r < c.b) ? c.rb : c.br; //2 op\n\n\t//3rd cycle\n\tc.gb = (c.g < c.b) ? c.gb : c.bg; //2 op\n    \n    return c;\n}\n\n\nvec3 noise( vec3 p ) //noise maker\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvoid mainImage( out vec4 c, in vec2 fc )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fc/iResolution.xy;\n    \n    \n    c.rgb = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); //Time varying pixel color\n\n\tc.rgb = noise(uv.x * uv.y + c.rgb); //Make some noise. Try the median with this - it makes the noise more pleasant.\n    \n    //c.rgb = vec3(0.4,0.8,0.2); //Enter your own constant numbers to check it's working\n    \n\tc.rgb = sort3(c.rgb);\t//lets get this sorted.\n    \t\t\t\t\t\t//Will make the image look blue since that component now stores the max.\n    \n    //c.rgb = c.rrr; //only the red   (the minimum if you used sort)\n    c.rgb = c.ggg; //only the green (the  median if you used sort)\n    //c.rgb = c.bbb; //only the blue  (the maximum if you used sort)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 147, 225, 241, 416], [419, 419, 455, 455, 613], [615, 615, 657, 707, 1389]], "test": "valid"}
{"id": "XtKyWc", "name": "sketchfab logo noise", "author": "gabwoot", "description": "do you like us?", "tags": ["noise", "sketchfab"], "likes": 3, "viewed": 75, "published": "Public", "date": "1537978615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size * 0.5;\n    \n    vec2 uv = smoothstep(\n        _size,\n        _size + vec2(0.001),\n        _st\n    );\n\n    uv *= smoothstep(\n        _size,\n        _size + vec2(0.001),\n        vec2(1.0) - _st\n    );\n    \n    return uv.x * uv.y;\n}\n\nfloat random (in vec2 st) {\n    return fract(\n        sin(\n            dot(st.xy, vec2(12.9898,78.233))\n        ) * 43758.5453123\n    );\n}\n\nfloat map(float x, float a1, float a2, float b1, float b2) {\n    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n}\n\nvec2 rotate2d(vec2 st, float angle) {\n    return (\n        (st - vec2(.5)) *\n        mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n        ) +\n        vec2(.5)\n    );\n}\n\nvec2 scale(vec2 st, vec2 s) {\n    return st * s;\n}\n\nvec2 translate(vec2 st, vec2 t) {\n    return st + t;\n}\n\nvec2 skewY(vec2 st, float angle) {\n    return (\n        (st - vec2(.5)) *\n        mat2(\n            1., 0.,\n            tan(angle), 1.\n        ) +\n        vec2(.5)\n    );\n}\n\n\nfloat sketchfabLogo(vec2 st) {\n    return max(\n        box(\n            skewY(\n                translate(\n                    st,\n                    vec2(-.17, 0.25)\n                ),\n                -.5\n            ),\n            vec2(.27)\n        ),\n        max(\n            box(\n                skewY(\n                    translate(\n                        st,\n                        vec2(.17, 0.25)\n                    ),\n                    .5\n                ),\n                vec2(.27)\n            ),\n            box(\n                rotate2d(\n                    translate(\n                        scale(st, vec2(1., 1.9)),\n                        vec2(0., -.5)\n                    ),\n                    PI / 4.\n                ),\n                vec2(.4)\n            )\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.y *= iResolution.y/iResolution.x;\n\n    float speed =\n        random(floor((st.yy - vec2(.5) * 2.) * 250. ) * vec2(1., 10)) * 10.;\n    \n    float size = random(st.yy * 1.);\n\n    float randc =\n        random(floor(st.xx * (10. * size) + iTime * speed));\n\n    vec3 color = vec3(st.x, 0., st.y);\n\n    color = mix(\n        color, \n        vec3(st.y, 0, st.x),\n        sketchfabLogo(\n            translate(\n                scale(st, vec2(1.5, 1.3)),\n                vec2(-.25, 0.)\n            )\n        )\n    );\n\n    fragColor = vec4(color * randc,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 59, 59, 319], [321, 321, 348, 348, 459], [461, 461, 521, 521, 573], [575, 575, 612, 612, 775], [777, 777, 806, 806, 827], [829, 829, 862, 862, 883], [885, 885, 919, 919, 1057], [1060, 1060, 1090, 1090, 1861], [1863, 1863, 1920, 1920, 2600]], "test": "valid"}
{"id": "XtKyWy", "name": "Sphere Project- Tripping", "author": "tiff", "description": "Abstract imagination ", "tags": ["rotate"], "likes": 2, "viewed": 87, "published": "Public", "date": "1537671718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotate\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n\n// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = 0.1;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p)*0.8 -0.5;\n\n    // Signed distance of sphere\n    return sphere(q, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.2;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    ray.yz *= rot(iTime*0.1);\n    ray.zx *= rot(iTime*0.2);\n    \n    vec3 origin = vec3(0.0, 0.0, iTime);\n    float t = trace(origin, ray);\n    \n    \n    float linearFog = 2.0 / (1.0 - t*0.2);\n    float expFog = 2.0 / (t*t*0.1);\n    \n    vec3 color = vec3(0.0, iTime, -iTime);\n    \n    vec3 fc = vec3(expFog) / cos(color);\n    //vec3 fc = vec3(expFog) / cos(color)- color*0.7;\n\n    // Output pixels to screen\n    fragColor = cos(vec4(fc,2.0));\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 28, 28, 96], [99, 113, 148, 148, 180], [183, 227, 246, 246, 425], [428, 428, 463, 463, 616], [619, 619, 676, 726, 1420]], "test": "valid"}
{"id": "XtVcDw", "name": "kimo kawai sin wave", "author": "uynet", "description": "kimo kawai", "tags": ["sin"], "likes": 4, "viewed": 134, "published": "Public", "date": "1536591753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p){\n  return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\n//f : freq\n//v: velocity\n//a: amp\nfloat wave(float x , float f,float v , float a){\n    return  sin(x*f + iTime*v)*a ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv.y *= asp;\n    \n    float grad = 3.0;\n    vec3 col = vec3(.3,.6,.8);\n    \n \n    \n    float f = 0.0;\n    float po = sin(iTime);\n    float yo = tan(iTime*1.0);\n    \n    f+=wave(uv.x , 8.0 , 2.0 , 0.06);\n    f+=wave(uv.x , 4.0 , 4.0 , 0.02);\n    f+=wave(uv.x , 10.0+po*3.0, -3.4 , sin(iTime*5.0)*0.01);\n    f+=wave(uv.x , 60.0 * sin(iTime*0.1) , -2.0,min(1.0,yo*yo)*0.02);\n    f+=wave(uv.x -0.5 , 30.0 * min(3.0,yo*yo) , 4.0 , 0.02);\n\n    \n    f += 0.20;\n    \n   \n\n    if(uv.y -f<0.01){\n        col = vec3(.8,.6,.4);\n        if(uv.y-f > 0.006){\n            col = vec3(0.8,0.9,1);\n            //col.y -= rand(uv + vec2(f))*0.2;\n        }\t\t\n    }\n\n    // Time varying pixel color\n    \n   col.z -= uv.x*uv.x/grad;\n    col.z -= (1.0-uv.x)*(1.0-uv.x)/grad;\n    col.y -= uv.x*uv.x/grad;\n    col.y -= (1.0-uv.x)*(1.0-uv.x)/grad;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVcDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [89, 123, 171, 171, 208], [210, 210, 267, 317, 1295]], "test": "valid"}
{"id": "XtVyDc", "name": "Something For Your Imagination", "author": "PrzemyslawZaworski", "description": "Comments are welcome.", "tags": ["fbm", "cool"], "likes": 3, "viewed": 145, "published": "Public", "date": "1537997815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nAuthor: Przemyslaw Zaworski\n26.09.2018\nversion 1.0\n*/\n\nfloat hash(float h)\n{\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 i = fract(x);\n\ti = i * i * (3.0 - 2.0 * i);\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\tfloat a = hash(n + 0.0);\n\tfloat b = hash(n + 1.0);\n\tfloat c = hash(n + 157.0);\n\tfloat d = hash(n + 158.0);\n\tfloat e = hash(n + 113.0);\n\tfloat f = hash(n + 114.0);\n\tfloat g = hash(n + 270.0);\n\tfloat h = hash(n + 271.0);\n\treturn mix(mix(mix(a,b,i.x),mix(c,d,i.x),i.y),mix(mix(e,f,i.x),mix(g,h,i.x),i.y),i.z);\n}\n\nfloat fbm(vec3 p)   \n{\n\tfloat f = 0.0;\n\tf = 0.5000*noise(p);  p *= 2.01;\n\tf += 0.2500*noise(p);  p *= 2.02;\n\tf += 0.1250*noise(p);\n\treturn f;\n}\n\nvec4 surface (vec2 uv, float a, int k)\n{\n\tvec4 total = vec4(0.0);\n\tfor (int i=0;i<k;i++)\n\t{\n\t\tvec2 p = float(i*2+1) * uv + vec2(a,a);   \n\t\tfloat color = fbm(vec3(p,iTime*0.1));         \n\t\tif (color>0.5 && color<0.52)\n\t\t{\n\t\t\ttotal+=vec4(pow(max(smoothstep(0.52,0.5,color),smoothstep(0.5,0.52,color)),8.0));\n\t\t}\n\t\ta += 10.0;\n\t}\n\treturn total;\n}\n\nvec2 distortion (vec2 uv, float a, float b, float c, float d)\n{\n\tuv.x+=cos(uv.y*a+iTime)*b;\n\tuv.y+=sin(uv.x*c+iTime)*d; \n\treturn uv;\n}\n\nvec4 remap (vec2 p, bool t, vec3 o)\n{\n\tif (t) p = distortion(p,6.0,0.05,3.0,0.04);\n\tif (t) p.y+=0.15*fbm (vec3(10.0*o.xz,iTime*0.01));\n\tvec3 d = normalize(vec3(p,2.0));\n\tvec3 m = d*(-0.2/d.y);\n\tm.z+=iTime*0.1;\n\treturn vec4(m,d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec4 s = remap(p,false,vec3(0.0));  \n\tvec4 k = remap(p,true,s.xyz);    \n\tfloat clouds = fbm (vec3(5.0*s.xz,iTime*0.1));\n\tvec4 a = (vec4(clouds)+vec4(.7,.7,0,1))*(max(0.05,min(iTime/40.,.25)))/length(p-vec2(0,min(iTime/40.,.7)))*(5.*s.w);\n\tvec4 b = (surface(vec2(k.xz),50.,12)+vec4(0,0,.7,1))*(pow(-(min(iTime/10.,1.5))*k.w,1.));\n\tfragColor = max(a,b);\n}", "image_inputs": [{"id": "ldBXDd", "previewfilepath": "https://soundcloud.com/tjsaurusrex-james/scratches-ost-18-revealed", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tjsaurusrex-james/scratches-ost-18-revealed", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 80, 80, 121], [123, 123, 144, 144, 568], [570, 570, 592, 592, 713], [715, 715, 755, 755, 1057], [1059, 1059, 1122, 1122, 1193], [1195, 1195, 1232, 1232, 1427], [1429, 1429, 1486, 1486, 1901]], "test": "valid"}
{"id": "XtVyDz", "name": "Game Explosion", "author": "Redline", "description": "An explosion created using simple methods and also quite customizable", "tags": ["explosion", "fire", "animation", "smoke"], "likes": 12, "viewed": 717, "published": "Public API", "date": "1535818496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define loop\nconst int layers = 128;\nconst float blur = .1;\nconst float speed = 4.;\nconst float peaks = 8.;\nconst float peakStrength = .1;\nconst float ringSpeed = 1.5;\nconst float smoke = .4;\nconst float smokeTime = 40.;\n\nfloat hash(float seed){\n\treturn fract(sin(seed * 3602.64325) * 051.63891);\n}\n\nfloat circle(float radius, vec2 pos){\n\treturn radius - pos.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    #ifdef loop\n    time = mod(time, 5.);\n    #endif\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x /= iResolution.y / iResolution.x;\n    vec2 puv = vec2(length(uv),atan(uv.x,uv.y)); //polar coordinates\n\n    vec3 col = vec3(0);\n    for(int i = 0; i < layers;i++){\n    \tfloat prog = float(i) / float(layers);\n        float radius = prog * ((1. - 1. / pow(time * speed,1./3.)) * 2.); //decrease radius using cubed\n        radius += sin(puv.y * peaks + hash(prog) * 513.) * peakStrength; //modulate radius so it isnt enitly symetrical\n        vec3 color = vec3(\n            1. / radius,\n            .25 ,\n            .1 * (2. - radius)\n        )/ time / abs(log(time * ringSpeed) - puv.x); // base explosion color, decrease with time and with distance from center\n        color += vec3((1. - time / smokeTime) * puv.x * smoke);  //add smoke color, falloff can be controlled with smoketime variable\n        col += color * smoothstep(0.,1.,circle(radius,puv) / blur);\n    }\n\n    fragColor = vec4(col / float(layers),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 245, 245, 298], [300, 300, 337, 337, 363], [365, 365, 422, 422, 1495]], "test": "valid"}
{"id": "XtVyRV", "name": "lpnorm 3d", "author": "CLPB", "description": "Lp-norm distance function, or Minkowski distance metric in 3D. Note that discontinuity along the corners and edges is mitigated by shortening the step length.", "tags": ["raymarching"], "likes": 7, "viewed": 515, "published": "Public API", "date": "1536953771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modified from https://www.shadertoy.com/view/Xds3zN by iq.\n\n// https://en.wikipedia.org/wiki/Lp_space\n// https://en.wikipedia.org/wiki/Minkowski_distance\n\n\n#define AA 1\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat lpnorm(vec3 p, float s){\n    return pow(\n        (\n         pow(abs(p.x),s)+\n         pow(abs(p.y),s)+\n         pow(abs(p.z),s)), \n        1.0/s);\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\nvec2 map_shapes( vec3 pos ) {\n    vec2 res = vec2(lpnorm(pos-vec3(-2.0,0.5,0.0), 1.0)-0.35, 200.0);\n    res = opU(\n        vec2(lpnorm(pos-vec3(-1.0,0.5,0.0), 2.0)-0.35, 83.0), \n        res);\n    res = opU(\n        vec2(lpnorm(pos-vec3(0.0,0.5,0.0), 5.0)-0.35, 44.0), \n        res);\n    res = opU(\n        vec2(lpnorm(pos-vec3(1.0,0.5,0.0), 80.0)-0.35, 5.0), \n        res);\n    res = opU(\n        vec2(lpnorm(pos-vec3(2.0,0.5,0.0), 0.8)-0.5, 9.0), \n        res);\n    \n    res = opU(\n        vec2(lpnorm(pos-vec3(0.0,1.0,2.0), sin(iTime)*3.0+3.7)-0.5, 60.0), \n        res);\n    \n    res = opU(\n        vec2(lpnorm(pos-vec3(-1.0,0.5,1.0), pos.y*pos.y+1.0)-0.35, 70.0), \n        res);\n    \n    res = opU(\n        vec2(lpnorm(pos*vec3(1.0,.5,1.0)-vec3(1.0,0.35,1.0), 15.0-clamp(pos.y*1.6,0.0,1.0)*14.2)-0.35, 160.0), \n        res);\n    \n    return res;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(     pos), 1.0 );\n    \n    res = opU(res, map_shapes(pos));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<80; i++ )\n    {\n\t    float precis = 0.0001;\n\t    vec2 res = map( ro+rd*t );\n        //if( res.x<precis || t>tmax ) break;\n        t += res.x*.4;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            //float f = checkersGradBox( 5.0*pos.xz );\n            vec2 ma = map_shapes(pos);\n            float f = mod(ma.x, 0.1);\n            f = f >.05?1.0:0.0;\n            f /= t*0.7;\n            col = 0.3 + f*vec3(0.3);\n            col = mix(col, \n                      mix(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),clamp(ma.x, 0.0, 3.0)/3.0)\n                      , 0.5);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 243, 268, 268, 283], [285, 285, 315, 315, 439], [441, 511, 541, 541, 574], [576, 646, 675, 675, 1496], [1498, 1498, 1523, 1523, 1635], [1637, 1637, 1677, 1677, 2007], [2010, 2010, 2088, 2088, 2350], [2352, 2352, 2384, 2384, 2592], [2594, 2594, 2636, 2636, 2935], [2937, 3013, 3049, 3070, 3293], [3295, 3295, 3334, 3334, 5318], [5320, 5320, 5372, 5372, 5549], [5551, 5551, 5608, 5608, 6577]], "test": "valid"}
{"id": "XtycDw", "name": "4DRaymarching", "author": "Spyion", "description": "This shader shows a grid of four-dimensional spheres using raymarching. Time corresponds the W value, sort of.", "tags": ["raymarching", "4d"], "likes": 6, "viewed": 426, "published": "Public API", "date": "1536422694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat udBox( vec4 p, vec4 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n#define gridSize 200\nvec4 c = vec4(gridSize,gridSize,gridSize,gridSize /2);\nfloat sdSphere( vec4 p, float s )\n{\n    \n  return abs(length(mod(p, c) - 0.5f*c)-s);\n}\nfloat getDistance(vec4 point){\n    \treturn sdSphere(point, 25.);\n}\n\nstruct HitData{\n\tfloat distance;\n    float normal;\n};\nHitData rayMarch(vec4 point, vec4 dir){\n    HitData hd;\n\tfloat marched = 0.;\n    float epsilon = 0.1;\n    float lastDistance = 0.;\n    while(marched < 10000.){\n    \tfloat distance = getDistance(point);\n        marched += distance;\n        point += dir*distance;\n        if(distance < epsilon){\n            return HitData(marched, 1.-distance/lastDistance);\n        }\n        lastDistance = distance;\n        \n    }return HitData(1000.,1.);\n}\nvec4 eye = vec4(0,0,0,-1);\nfloat layers = 24.;\nvec4 getPosition(vec2 coord, float layer){\n    return vec4(coord.x / iResolution.x * 2. - 1., (coord.y/iResolution.y * 2. - 1.) * iResolution.y / iResolution.x, layer/layers * 2. - 1.,0.);\n}\n\nfloat color(float d){\n    return d / 1000.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    eye = vec4(0, 0 ,0, - 1) * 2.;\n    //spheres[0] = vec3(sin(iTime)*20.,0,20.);\n    //radii[0] = abs(sin(iTime * 1.3f + 20.)) * 10.;\n    float l = (fract(iTime/50.)*2.-1.)*layers;\n    vec4 pos = getPosition(fragCoord, l);\n    vec4 dir = normalize(pos - eye);\n    HitData hd = rayMarch(pos, dir);\n\tfloat amount = color(hd.distance) * hd.normal;\n    amount = hd.normal;\n    fragColor = vec4(amount,amount,amount,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtycDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 70], [148, 148, 183, 183, 234], [235, 235, 265, 265, 301], [357, 357, 396, 396, 798], [846, 846, 888, 888, 1036], [1038, 1038, 1059, 1059, 1083], [1084, 1084, 1141, 1141, 1559]], "test": "valid"}
{"id": "XtycWd", "name": "256b Tunnel", "author": "yx", "description": "Inspired by every 256-byte DOS demo ever.", "tags": ["2tweets"], "likes": 8, "viewed": 502, "published": "Public API", "date": "1538072761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c,vec2 f){\n    vec2 u=(f-mod(f,3.)-iResolution.xy*.5)/iResolution.y;\n    ivec2 i=ivec2(fract(iTime+vec2(\n        .25/length(u),\n        atan(u.x,u.y)/(asin(1.))\n    ))*255.);\n    for(int X=3;X-->0;)\n        c[X]=fract(float((i.x^i.y)-(iFrame>>X))/255.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtycWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 278]], "test": "valid"}
{"id": "XtycWm", "name": "Flying through the desert", "author": "Emil", "description": "The majestic eagle.., Soaring through the sky, hunting for prey.\nIn reality, just me playing around with fake planes some more", "tags": ["plane", "fake3d", "mode7"], "likes": 14, "viewed": 716, "published": "Public", "date": "1536427597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy)-0.5)*vec2(iResolution.x/iResolution.y,1.0);\n    uv += 0.2*vec2(sin(iTime*0.4),sin(iTime*0.2)+0.5*cos(iTime*0.45));\n    uv.y += uv.x*0.3*sin(iTime*0.5);\n    uv.x += uv.y*0.3*cos(iTime*0.5)*(step(uv.y,0.0)*1.7-0.3);\n    \n    \n    \n    vec3 viewDir = normalize(vec3(uv,0.5));\n    \n    vec2 planarUV = viewDir.xz/abs(viewDir.y)*0.3;\n    \n    float depth = planarUV.y;\n    \n    vec3 ground = texture( iChannel0, (planarUV+vec2(0.0, iTime*.6))*0.6).rgb * step(viewDir.y,0.0);\n    \n    float fog = pow(depth,0.4)*0.2;\n    ground = mix(ground,vec3(1.0),fog);\n    \n    vec3 sky = vec3(0.0);\n    for(float i = 0.0; i<1.0; i+= 0.1){\n        planarUV = (viewDir.xz/abs(viewDir.y-i*0.1/depth)*0.2);\n        sky += (0.05*smoothstep(i,0.8+i,texture( iChannel1, (planarUV+vec2(0.0, iTime*.2))*0.9).r));\n    }\n    sky += vec3(0.2,0.4,1.0);\n    sky *= step(-viewDir.y,0.0);\n    \n    fragColor = vec4(ground + sky,1.0);\n    fragColor *= vec2(smoothstep(0.1,0.9,viewDir.b),smoothstep(0.2,0.85,viewDir.b)).rgrg; // vignette\n    fragColor.b *= 0.85; // \"sandier\" look\n    fragColor.rgb += vec3(0.02/length(uv)); // sun\n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtycWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1203]], "test": "error"}
{"id": "XtycWy", "name": "random ants", "author": "FabriceNeyret2", "description": "random ants as a replacement of dash ants when no curve parameterization is available.\n\nSee variants in comments.\n", "tags": ["ants", "selector"], "likes": 2, "viewed": 421, "published": "Public API", "date": "1537431795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hash(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n  \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O -= O;\n    \n    U = U+U - R;\n    float d = length(U) - .6*R.y;\n    d = min( d, length(U+R/3.) - .4*R.y ) ;\n    d = min( d, length(U-R/3.) - .4*R.y ) ;\n\n    if (U.x < 0.) O = vec4( smoothstep(2.,-2.,d ) );\n    O = max(O, vec4(max(U.x,U.y)<-R.y/6.));\n    \n    float ants = fract( hash(floor(U/6.)) + 2.*iTime );\n    //float ants = fract( U.x/30. + 3.*iTime );\n    //float ants = fract( sin(U.x/10.)*sin(U.y/10.) + 3.*iTime );\n    \n    O = mix(O, vec4(ants), smoothstep(3.,0.,abs(d)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtycWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 113, 113, 633]], "test": "valid"}
{"id": "XtyyRc", "name": "XOR RGB", "author": "tholzer", "description": "\nThis fork looks like a 3 layers platine layout...", "tags": ["colors", "rgb", "xor", "platine"], "likes": 6, "viewed": 148, "published": "Public", "date": "1537044247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// XOR_RGB.glsl\n\n// original XOR by Philemonic  https://www.shadertoy.com/view/XlGyRc\n\n#define HASH 1\n#define scale1 200.\n#define scale2 888.\n#define iterations 15\n\nfloat hash(float n) \n{\n    return fract(sin(n) * 43758.5453123); \n}\n\nfloat mbrn(float n) \n{\n    for (int i=0; i<iterations; i++) n=n*n-2.;  return n*.5; \n}\n\nfloat xor(vec2 p) \n{\n    p.x=abs(scale2 - mod(p.x,scale2*2.));\n    p*=mat2(1.,1.,-1.,1.);\n    float xor = float(int(p.x)^int(p.y));\n    if (HASH == 1) return pow(mbrn(xor/scale2),3.);\n    else           return pow(hash(xor),2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.+fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;                  \n    uv.x += iTime*.5;\n    uv.x += (iMouse.z>0.) ? iMouse.x : sin(iTime*.1)*2.;\n    fragColor = vec4(xor(uv*scale1),xor(uv*123.),xor(uv*99.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 166, 188, 188, 233], [235, 235, 257, 257, 321], [323, 323, 343, 343, 553], [555, 555, 612, 612, 861]], "test": "valid"}
{"id": "XtyyRd", "name": "Alien", "author": "jkashimura", "description": "HW", "tags": ["beginner"], "likes": 1, "viewed": 84, "published": "Public", "date": "1537287355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n   // pMod3(q, vec3(0.75, 1., 0.8));\n    pMod3(q, vec3(sin(iTime)*0.5, tan(iTime), cos(iTime)));\n    \n    \n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.7);\n    \n    float disp = 0.5 * (abs(cos(p.x*10.)) *\n                       abs(cos(p.y*10.)) *\n                       abs(cos(p.z*10.)) );\n    \t//s1 += disp;\n    \ts1 /= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2); // Union\n    float df2 = max(s1, s2); // Intersection\n    float df3 = max(s1, -s3); // Difference\n    \n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*0.3;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.324, 0., 0.536);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, 0.0, -1.75);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.5 / (t*t* 0.45);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    //fragColor = vec4((fc+color),1.0);\n    fragColor = vec4(cos(fc+color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 127, 127, 198], [200, 200, 237, 237, 280], [282, 282, 317, 317, 349], [352, 352, 371, 371, 952], [955, 955, 990, 990, 1147], [1150, 1150, 1207, 1207, 1706]], "test": "error"}
