{"id": "4d2BDD", "name": "Noisemeter", "author": "AlexeyB", "description": "https://dribbble.com/shots/1987372-Noisemeter-3", "tags": ["polar"], "likes": 0, "viewed": 64, "date": "1500483360", "time_retrieved": "2024-06-20T18:57:29.994309", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sin_factor = sin(-1.57);\n    float cos_factor = cos(-1.57);\n    \n    float from = -4.*3.14 ;\n    float by = 20.*3.14;\n    from = from - float(iFrame)/400. * by;\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n    float a = atan(uv.y, uv.x) / 6.28 + .5 ;\n    float x =  from + by*a;\n    float y = cos(x)/x;\n    \n    vec4 startColor = vec4(0.953, 0.114, 0.071, 1.);\n    vec4 finishColor = vec4(0.651, 0.047, 0.376, .5);\n    vec4 newColor = startColor - (startColor - finishColor) * a;\n    vec4 diff = (newColor - vec4(0.0))*step(0.5, a);\n    fragColor = (newColor- diff*(a-0.5)*2.) * step(length(uv), y*0.75 + 0.3) * step(a, float(iFrame)/400.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2BDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2BRy", "name": "Dragon Triscales", "author": "ttoinou", "description": "Without the music and 3x more triangles of [url]https://www.shadertoy.com/view/lsSBRG[/url]\n\nOriginal technique here : https://www.shadertoy.com/view/ld2BWw ", "tags": ["triangle", "spiral", "infinite"], "likes": 10, "viewed": 294, "date": "1500935479", "time_retrieved": "2024-06-20T18:57:32.273062", "image_code": "#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define dx (iMouse.x/iResolution.x)\n#define PI 3.14159265359\n\nfloat fft(float x)\n{\n    return .8;\n    //return max( texture(iChannel0,vec2(x,.25)).x - .2 , .0 )*2.;\n}\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z , float k ) { return polar(pow(length(z),k) , k*atan(z.y,z.x) ); }\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    float nbPoles = 2.;\n    vec2 ret = vec2(1.,0.);\n    \n    for(float i = 0. ; i < nbPoles ; i += 1. )\n    {\n        ret = cmul(ret,uv - polar(deformation_pole.x,2.*PI*i/nbPoles));\n    }\n    \n    //return cdiv( ret/nbPoles , uv );\n    return cdiv( ret/nbPoles , cmul(uv,uv) );\n    \n   // uv = cdiv( cmul( uv + deformation_pole , uv - deformation_pole ) , cmul( uv , uv ) );\n    //uv = cdiv(vec2(1.,0.),uv);\n    //return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat mmod(float x,float y)\n{\n    return mod(mod(x,y)+y,y);\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    vec2 D = (Tri.A+Tri.B+Tri.C)/3.0;\n    float ScaleID = 0.;\n    //vec2 E = (Tri.A*.8 + Tri.B)/(1. + .8);\n    //vec2 E = (Tri.A*RadiusCoeff + Tri.B)/(1. + RadiusCoeff);//(Tri.A*dx + Tri.B)/(1. + dx);//\n    \n    // 3 subtriangles : ABD BCD CAD\n    #define CHECK_TRIANGLE(X,Y,Z,n) \\\n    \tif( pointsOnSameSideOfLine(uv_s,X,Y,Z) && pointsOnSameSideOfLine(uv_s,Y,X,Z) ) \\\n    \t{ \\\n            Tri.A = X; \\\n            Tri.B = Y; \\\n            Tri.C = Z; \\\n            ScaleID = n; \\\n    \t}\n   \t\n    CHECK_TRIANGLE(Tri.A,Tri.B,D,0.)\n    else\n        CHECK_TRIANGLE(Tri.B,Tri.C,D,1.)\n    else\n       CHECK_TRIANGLE(Tri.A,Tri.C,D,2.)\n        \n    /*\n    CHECK_TRIANGLE(Tri.A,E,D,0.)\n    else\n        CHECK_TRIANGLE(E,Tri.B,D,1.)\n    else\n       CHECK_TRIANGLE(Tri.C,Tri.B,D,2.)\n    else\n       CHECK_TRIANGLE(Tri.A,Tri.C,D,3.)\n      */  \n    vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    col.r *= 1.2 + .5* cos(log(length(Tri.A)));\n    col = mix( col , vec3( dot(col,vec3(.3,.5,.2)) ) ,-.8 );\n\n    float freq = mmod(Tri.ID/sqrt(17.),1.)*.9+.1;\n    col *= pow( 1.2*max( fft( freq ) - .25 , 0. ) , 2. );\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*.3); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    if(ScaleID == 1.)\n    {\n        col = vec3(1.2,.8,.5)*col.gbr;\n    }\n    \n    if(ScaleID == 2.)\n    {\n        col = vec3(.7,.6,1.3)*col.brg;\n    }\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 6.;\n    //vec3 coeffs = vec3( 1. , tan(PI/2. - TriangleAngle) , tan(TriangleAngle) ) ;//vec3(1.);\n    vec3 coeffs = vec3( 1.4 );\n    //coeffs.xy -= normalize(uv_s);\n    coeffs.xy += polar(1. , - atan(uv_s.y , uv_s.x) ); //  + vec2( fft(.3),fft(.9) )\n    \n    vec2 TriCenterMix =\n          (Tri.A * coeffs.x + Tri.B * coeffs.y + Tri.C * coeffs.z)\n        / (coeffs.x + coeffs.y + coeffs.z);\n    \n    \n    \n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    return col;//mix(vec3(1.),col,1./(1. + dot(uv_s,uv_s)/1e7 ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    TriangleAngle = PI * mix(\n        1./3.9 ,\n        1./2.4 , // cannot go lower than this value :-( \n        //iMouse.x/iResolution.x\n        sqrt( -cos(iTime/29.*PI)*.5+.51 )\n    );\n    \n    //TriangleAngle = atan(2.); // Pinwheel\n    //TriangleAngle = PI/3.; // Equerre \n    \n    //PI * ( mix( 1./12. ,  1./4. ,  iMouse.x/iResolution.x ) + .333 );\n    \n    angleShift = -iTime*2.;\n    logZoom = iTime/sqrt(5.);\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    \n    viewportMagnify = 1./mix(4. , 1. , -cos(iTime*PI/17.)*.5 + .5 );\n    uv *= viewportMagnify;\n    \n    vec2 uv_s = deformation(uv);\n    \n    \n    \n    \n    fragColor.rgb = color(uv_s);\n\n    fragColor.rgb = tanh(fragColor.rgb*3.  ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2BRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2BW1", "name": "[SH17A] Apollonian Structure", "author": "Shane", "description": "An Apollonian structure.", "tags": ["raymarch", "apollonian", "tweet"], "likes": 67, "viewed": 2143, "date": "1500354639", "time_retrieved": "2024-06-20T18:57:32.751937", "image_code": "/*\n\tApollonian Structure\n\t--------------------\n\n\tOverall, there's nothing particularly exciting about this shader, but I've \n\talways liked this structure, and thought it'd lend itself well to the two \n\ttweet environment.\n\n\tI couldn't afford shadows, AO, etc, so applied a bit of fakery to at least\n\tconvey that feel.\n\n\n*/\n\n// Apollonian based fractal. I couldn't find the original source, but it's\n// been around for a while. IQ has a really cool variation here: \n// Apollonian: https://www.shadertoy.com/view/4ds3zn\n//\n// I'm guessing the original was posted by someone on a fractal forum somewhere \n// at some stage.\n//\nfloat m(vec3 p){\n    \n    // Moving the scene itself forward, as opposed to the camera.\n    // IQ does it in one of his small examples.\n    p.z += iTime;\n    \n    // Loop counter and variables.\n    float i = 0., s = 1., k;\n\n\t// Repeat Apollonian distance field. It's just a few fractal related \n    // operations. Break up space, distort it, repeat, etc. More iterations\n    // would be nicer, but this function is called a hundred times, so I've\n    // used the minimum to give just enough intricate detail.\n    while(i++ < 6.) p *= k = 1.5/dot(p = mod(p - 1., 2.) - 1., p), s *= k;\n\t\t\n\t// Render numerous little spheres, spread out to fill in the \n    // repeat Apollonian lattice-like structure you see.\n    //\n    // Note the \".01\" at the end. Most people make do without it, but\n    // I like the tiny spheres to have a touch more volume, especially\n    // when using low iterations.\n    return length(p)/s - .01; \n    \n}\n\n\nvoid mainImage( out vec4 c, vec2 u)\n{\n    // Direction ray and origin. By the way, you could use \"o = d/d\" (Thanks, Fabrice),\n    // then do some shuffling around in the lighting calculation, but I didn't quite \n    // like the end result, so I'll leave it alone, for now anyway.\n    vec3 d = vec3(u/iResolution.y - .5, 1)/4., o = vec3(1, 1, 0);\n\n    // Initialize to zero.\n    c -= c;\n    \n    // Raymarching loop -- sans break, which always makes me cringe. :)\n    while(c.w++<1e2) o += m(o)*d;\n\n    \n    // Lame lighting - loosely based on directial derivative lighting and the \n    // way occlusion is performed, but mostly made up. It'd be nice to get rid \n    // of that \"1.1,\" but it's kind of necessary.  Note that \"o.z\" serves as  \n    // a rough distance estimate, and to give a slight volumetric light feel. \n    //c += (m(o - .01)*m(o - d)*4e1 + o.z*1.1 - 2.)/o.z;\n    // I stared at the line above for ages and got nothing. Fabrice looked at it\n    // instantly, and saw the obvious. :)\n    c += (m(o - .01)*m(o - d)*4e1 - 2.)/o.z + 1.1;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2BW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2Bz3", "name": "Simple move squares pattern", "author": "Keram", "description": "My first public shader. The code size is exactly 8 full bit address (255 chars) of memory. :)", "tags": ["2d", "pattern"], "likes": 0, "viewed": 98, "date": "1501455738", "time_retrieved": "2024-06-20T18:57:33.024785", "image_code": "// Code from Keram (255 chars, old):\n\n// s = checker size\n#define s 64.\n\nbool P(vec2 p) {\n\tvec2 d = mod(p, s *2.);\n\treturn (d.x < s) ^^ (d.y < s);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) { \n    vec3 c = vec3(0);        // background black\n\n    float t = (iTime +.5) *64.;  // +.5 Needed to be visible for 0 sec launch (startup).\n    vec2 m = vec2(U.x -t, U.y +t);\n\n\n    if ( P(vec2(m.x, U.y)) )\n\t\tc = vec3(.9, 0, 0);  // red pattern (.9 is enough for lighting.) :D\n\n    if ( P(vec2(U.x, m.y)) )\n\t\tc = vec3(0, 0, .9);  // blue pat.\n\n    O = vec4(c, 1);\n}\n\n\n/*\n// Better solution from FabriceNeyret2 (189 chars):\n// See in comment ( https://www.shadertoy.com/view/4d2Bz3 )\n#define s 64.\n\nbool P(vec2 p) {\n\tp = mod(p, s *2.) -s;\n\treturn p.x*p.y < 0.;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    float t = (iTime +.5) *64.; \n    \n\tO =   P(U+vec2( 0,t)) ? vec4( 0, 0, .9,1)\n        : P(U+vec2(-t,0)) ? vec4(.9, 0,  0,1)\n        : O-O;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2Bz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2fWh", "name": "20170717", "author": "RitonAndRoll", "description": "First sahder of my life : 4 seasons day and night", "tags": ["color"], "likes": 1, "viewed": 131, "date": "1500290787", "time_retrieved": "2024-06-20T18:57:33.024785", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n\n\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-.1;\n    uv.x*=iResolution.x+.1/iResolution.y;\n    \n    vec2 ux = fragCoord.xy / iResolution.xy-.1;\n    ux.x*=iResolution.y+.1/iResolution.x;\n    \n    \n    //fragColor = vec4(1,uv+.2,0);\n    fragColor = vec4(ux*sin(iTime)+.5,uv*cos(iTime)+.5);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2fWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2fzD", "name": "UV Color Wheel", "author": "jbracey2004", "description": "Creates HSV color from UV Coordinates. Converts HSV Color to RGB Color.", "tags": ["2d", "rgb", "hsv"], "likes": 3, "viewed": 470, "date": "1499805178", "time_retrieved": "2024-06-20T18:57:33.024785", "image_code": "float pi = 3.14159265358979323846264;\n\nvec3 RGB_fromHSV(vec3 HSV)\n{\n    vec3 retCol;\n\tif ( HSV.y == 0.0 )\n    {\n       retCol.x = HSV.z;\n       retCol.y = HSV.z;\n       retCol.z = HSV.z;\n    }\n    else\n    {\n       float var_h = HSV.x * 6.0;\n       if ( var_h == 6.0 ) {var_h = 0.0;}     //H must be < 1\n       float var_i = floor( var_h );             //Or ... var_i = floor( var_h )\n       float var_1 = HSV.z * ( 1.0 - HSV.y );\n       float var_2 = HSV.z * ( 1.0 - HSV.y * ( var_h - var_i ) );\n       float var_3 = HSV.z * ( 1.0 - HSV.y * ( 1.0 - ( var_h - var_i ) ) );\n       if      ( var_i == 0.0 ) { retCol.x = HSV.z     ; retCol.y = var_3 ; retCol.z = var_1; }\n       else if ( var_i == 1.0 ) { retCol.x = var_2 ; retCol.y = HSV.z ; retCol.z = var_1; }\n       else if ( var_i == 2.0 ) { retCol.x = var_1 ; retCol.y = HSV.z ; retCol.z = var_3; }\n       else if ( var_i == 3.0 ) { retCol.x = var_1 ; retCol.y = var_2 ; retCol.z = HSV.z;     }\n       else if ( var_i == 4.0 ) { retCol.x = var_3 ; retCol.y = var_1 ; retCol.z = HSV.z;     }\n       else                   { retCol.x = HSV.z     ; retCol.y = var_1 ; retCol.z = var_2; }\n    }\n    return retCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvc = -1.0*((2.0*uv) - 1.0);\n    float ang = (atan(uvc.y,uvc.x)+pi)/(2.0*pi);\n    ang = mod(ang - iTime, 1.0);\n    float dist = sqrt(uvc.x*uvc.x + uvc.y*uvc.y);\n    //vec3 colHSV = vec3(uv.x, 1.0, uv.y);\n    //vec3 colHSV = vec3(uvc.x, 1.0, uvc.y);\n    //vec3 colHSV = vec3(uvc.x, 1.0+uvc.y, abs(uvc.y));\n    vec3 colHSV = vec3(ang,1.0, dist);\n    vec3 colRGB = RGB_fromHSV( colHSV );\n    //fragColor = vec4(ang, dist, 0.0, 1.0);\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(colRGB,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2fzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBBRc", "name": "reflection & sparkling", "author": "FabriceNeyret2", "description": "Mirrors are micro-mountains! Descartes reflection results from interferences. Basic rule is Huygens: any point scatters  in every directions.\nMouse: incident direction. SPACE: show energy  vs  wavefronts\nNB: we are monofrequency (i.e. laser), thus sparkle", "tags": ["physics", "optics", "interferences", "huygens"], "likes": 7, "viewed": 972, "date": "1501359538", "time_retrieved": "2024-06-20T18:57:33.285503", "image_code": "// --- simulating reflection on a micro-relief + sparkling (because of mono-frequency)\n// see also 2-buffers optimized version https://www.shadertoy.com/view/4sSBRd\n\n#define T(x)        .1 + z * textureLod(iChannel0,vec2(.5*x,.75),0.).g     // relief\n#define W(P)         k*( dot(P,D) - .1*iTime )                             // incident phase\n#define M(P)       ( .7 + .3* cos(k*cross2(U-C,D)) )                       // dashing\n#define cross2(a,b) ( (a).x*(b).y - (b).x*(a).y )\n#define draw(v)      clamp(1.* (v) -0., 0., 1.)                            // draw wave\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.) // keyboard\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 D = normalize(vec2(1,-5)), d=vec2(0),\n         R = iResolution.xy,\n         C = vec2(R.x/R.y/2.,.1);                     // pivot for in-out rays\n\tU /= R.y;\n    O -= O;\n    \n    if (length(iMouse.xy)>10.) D = -normalize(iMouse.xy-C*R.y); // tune incident direction\n    float k = 150.,                                   // wavenumber\n          z = .03,                                    // relief amplitude\n          l, N = 300.; // R.y                         // sampling \n\n    if (U.y < T(U.x)) { O ++; return; }               // relief\n    \n    O.g = draw( .7 * cos(W(U)) * M(U) )               // incident wavefronts\n        + smoothstep(2./R.y,.0,abs(cross2(U-C,D)));   // incident direction\n   \n    for (float x=-1.; x< 2.5; x+=1./N) {              // sum scattering from each terrain point\n        vec2 P = vec2(x, T(x) );\n        l = length(U-P);\n        d += cos( k*l + W(P) +vec2(0,1.5708) ) * 2.5 / l / N; //  * M(P) \n    }\n    O.r =   draw( !keyToggle(32)                      // diffracted wavefronts\n                 ? max(d.x,0.) : length(d));          // wavefront vs amplitude   \n    O.rb += smoothstep(4./R.y,.0,abs(cross2(vec2(2.*C.x-U.x,U.y)-C,D))); // reflected direction\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBfR1", "name": "Glow intro", "author": "Tomza", "description": "First shader. Trying to reproduce Glow intro", "tags": ["starneon"], "likes": 17, "viewed": 1009, "date": "1499342362", "time_retrieved": "2024-06-20T18:57:33.285503", "image_code": "float pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n\n\nfloat epsilon = 1e-3;\nfloat infinity = 1e6;\n\n//Settings\n#define BORDER_COLOR vec3(0.05, 0.20, 1.00)\n\n#define BRIGHTNESS 0.004\n#define THICKNESS  0.002\n\n//Checks if a and b are approximately equal.\nbool ApproxEqual(float a, float b)\n{\n    return abs(a - b) <= epsilon;\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv, float scale)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n\nfloat dfBorder(vec2 uv, float scale)\n{\n    float dist = infinity;\n    \n    vec2 pt1 = vec2(0.,2.86), \n         pt2=vec2(1.86,2.86),\n         pt3=vec2(2.43,4.63),\n         pt4=vec2(3.,2.86), \n         pt5=vec2(4.86,2.86),\n         pt6=vec2(3.36,1.77),\n         pt7=vec2(3.93,0.),\n         pt8=vec2(2.43,1.10),\n         pt9=vec2(0.93,0.),\n         pt10=vec2(1.51,1.77);\n    \n\tdist = min(dist, dfLine(pt1, pt2, uv, scale));\n    dist = min(dist, dfLine(pt2, pt3, uv, scale));\n    dist = min(dist, dfLine(pt3, pt4, uv, scale));\n    dist = min(dist, dfLine(pt4, pt5, uv, scale));\n    dist = min(dist, dfLine(pt5, pt6, uv, scale));\n    dist = min(dist, dfLine(pt6, pt7, uv, scale));\n    dist = min(dist, dfLine(pt7, pt8, uv, scale));\n    dist = min(dist, dfLine(pt8, pt9, uv, scale));\n    dist = min(dist, dfLine(pt9, pt10, uv, scale));\n    dist = min(dist, dfLine(pt10, pt1, uv, scale));\n   \n    \n    return dist;\n}\n\n\nvec3 DrawStar(vec2 uv, vec3 color, float ind)\n{\n\tfloat dist = 0.0;\n    float shade = 0.0;\n\tfloat scale = -ind + mod(iTime-ind,8.)*2. / 6.0;\n    if(scale >= 0. /*&& scale < 1.0*/)\n    {\n        vec2 offs = vec2(5.0, 4.5) * scale/2.0;\n\n        float bright_bord = BRIGHTNESS * min(1.0, 1.0 - sin(0.5 * pi * 50.0) / (0.5 * pi * 1.3));\n\n\n        //Border\n        dist = dfBorder(uv + offs, scale);\n\n        shade = bright_bord / max(epsilon, dist - THICKNESS);\n    \n    return color * shade;\n    }\n    \n    return vec3(0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n\t\n    vec3 color = vec3(0);\n    \n    for(float i=0.;i<20.;i++)\n    {\n    color += DrawStar(uv, vec3(0.86-mod(i,10.)*0.2,0.0,0.48+0.02*mod(i,10.)), 0.1*i);\n    }\n\n\n\tfragColor = vec4(color , 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBfR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBfRK", "name": "[SH17C] Challenge", "author": "shadertoy", "description": "Use this shader to ask questions to the community about the 3rd challenge or the Shadertoy Competition. \n\nMore info : [url]https://www.shadertoy.com/events/competition2017[/url]", "tags": ["challenge", "sh17c"], "likes": 6, "viewed": 2163, "date": "1501048070", "time_retrieved": "2024-06-20T18:57:33.291524", "image_code": "// Created by Shadertoy - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt( in vec2 uv, in int value, const int maxDigits )\n{\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //------------------------------\n    // coords (-1,1) with 10% paddin\n    //------------------------------\n    \n    vec2  uv = 1.1 * (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n    float px = 1.1 * 2.0/iResolution.y;\n    \n\n    //------------------------------\n    // animation\n    //------------------------------\n\n    float t = (iMouse.z<0.001) ? iTime : 6.2831*iMouse.x/iResolution.x;\n    vec2 p = cos( t - vec2(0.0,3.1415927/2.0) );\n\n\n    //------------------------------\n    // rendering\n    //------------------------------\n    \n    vec3 col = vec3(0.0);\n    // grid\n    col = vec3( 0.2 ) + 0.01*mod(floor(uv.x*10.0)+floor(uv.y*10.0),2.0);\n\t// circle\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, px, abs(length(uv)-1.0) ) );\n\t// axes\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, px, abs(uv.x) ) );\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, px, abs(uv.y) ) );\n    // orage lines\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, px, sdSegment(uv, vec2(p.x,0.0), p) ) );\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, px, sdSegment(uv, vec2(0.0,p.y), p) ) );\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, px, sdSegment(uv, vec2(0.0,0.0), p) ) );\n    // red point    \n    col = mix( col, vec3(1.0,0.3,0.0), 1.0-smoothstep( 0.0, px, abs(length(uv-p)-0.03)-0.002 ) );\n    // numbers\n    col += vec3(0.7,0.4,0.1)*float( PrintInt( (uv-vec2(1.3,-0.95))*10.0, int(round(abs(10000.0*p.x))), 5 ) );\n\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBfzD", "name": "Canal Ruins", "author": "dr2", "description": "Look around using mouse", "tags": ["reflection", "water", "voxel", "hexagon", "boat"], "likes": 17, "viewed": 913, "date": "1499675554", "time_retrieved": "2024-06-20T18:57:33.316849", "image_code": "// \"Canal Ruins\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define SQRT3 1.73205\n\nmat3 bMat, boatMat[3];\nvec3 bPos, boatPos[3], qHit, trkF, trkA, vuPos, sunDir, cHit, cHitP, qnHit;\nfloat boatAng[3], bAng, tCur, dstFar;\nint idObj, idObjGrp;\nconst float hcScale = 1.8;\nconst vec3 hcSize = vec3 (0.5 * SQRT3, 1., 1.8);\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec2 c, r, dr;\n  c = vec2 ((2. / SQRT3) * p.x, p.y);\n  r = floor (c);\n  r += mod (vec2 (r.x, r.y + step (2., mod (r.x + 1., 4.))), 2.);\n  dr = c - r;\n  r += step (1., 0.5 * dot (abs (dr), vec2 (SQRT3, 1.))) * sign (dr) * vec2 (2., 1.);\n  return r;\n}\n\nbool HexCellFull (vec3 p)\n{\n  float hs, hb;\n  p = (p * hcSize).yzx / hcScale;\n  p.xy -= TrackPath (p.z).xy;\n  hs = - SmoothMin (length (p.xy * vec2 (0.9 - 0.35 * cos (p.z * pi / 20.), 0.3)) - 4.,\n    6.5 + 4.5 * dot (sin (p * pi / 16. - cos (p.yzx * pi / 12.)), vec3 (1.)) - p.y, 2.);\n  return (hs < 0.);\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, dy;\n  ro *= hcScale;\n  cHit = vec3 (PixToHex (ro.zx), floor (ro.y / hcSize.z + 0.5));\n  hv[0] = vec2 (0., 1.);\n  hv[1] = vec2 (1., 0.5);\n  hv[2] = vec2 (1., -0.5);\n  for (int k = 0; k < 3; k ++)\n     hv[k] *= sign (dot (hv[k], vec2 (0.5 * SQRT3 * rd.z, rd.x)));\n  if (rd.y == 0.) rd.y = 0.0001;\n  dy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar * hcScale + 0.01;\n  for (int j = 0; j < 300; j ++) {\n    w = ro - (cHit * hcSize).yzx;\n    ht.z = 1e6;\n    for (int k = 0; k < 3; k ++) {\n      ve = vec2 (0.5 * SQRT3 * hv[k].x, hv[k].y);\n      htt = vec3 (hv[k], (1. - dot (ve, w.zx)) / dot (ve, rd.zx));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * dy * hcSize.z - w.y) / rd.y;\n    cHitP = cHit;\n    if (ht.z < ty) cHit.xy += 2. * ht.xy;\n    else cHit.z += dy;\n    if (HexCellFull (cHit)) {\n      if (ht.z < ty) {\n        qnHit = - vec3 (0.5 * SQRT3 * ht.x, ht.y, 0.);\n        dHit = ht.z;\n      } else {\n        qnHit = - vec3 (0., 0., dy);\n        dHit = ty;\n      }\n      break;\n    }\n  }\n  return dHit / hcScale;\n}\n\nfloat HexFaceDist (vec3 p)\n{\n  vec4 h[4];\n  vec3 cNeb, vh;\n  float d;\n  p = p.zxy * hcScale - cHitP * hcSize;\n  p.z *= 2. / hcSize.z;\n  h[0] = vec4 (0., 1., 0., 1.);\n  h[1] = vec4 (1., 0.5, 0., 1.);\n  h[2] = vec4 (1., -0.5, 0., 1.);\n  h[3] = vec4 (0., 0., 0.5, 0.5 * hcSize.z);\n  d = 1e5;\n  for (int k = 0; k < 4; k ++) {\n    vh = h[k].xyz;\n    cNeb = cHitP + 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w - dot (vh * hcSize, p));\n    cNeb = cHitP - 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w + dot (vh * hcSize, p));\n  }\n  return d;\n}\n\nvec3 HexVolCol (vec3 p, float edgDist, float dHit)\n{\n  vec3 col;\n  col = vec3 (0.9, 0.85, 0.75);\n  col *= 0.8 + 0.2 * smoothstep (0., 0.05, abs (edgDist));\n  if (qnHit.z != 0.) col *= 0.7 + 0.3 * smoothstep (0., 0.7, abs (edgDist));\n  if (qnHit.z == 1.) col *= vec3 (0.4, 0.7, 0.4);\n  col *= (1.2 - 0.2 * smoothstep (0., 0.06 * sqrt (dHit), abs (edgDist) - 0.03)) *\n     (0.5 + 0.5 * smoothstep (0., 0.03 * sqrt (dHit), abs (edgDist) - 0.01));\n  return col;\n}\n\nfloat EdgeDist (vec3 p)\n{\n  vec2 dh;\n  float d;\n  p *= hcScale;\n  dh = p.zx - cHit.xy * vec2 (0.5 * SQRT3, 1.);\n  if (qnHit.z == 0.) {\n    d = abs (fract (p.y / hcSize.z) - 0.5) * hcSize.z;\n    dh -= qnHit.xy * dot (dh, qnHit.xy);\n    d = min (d, abs (length (dh) - 1. / SQRT3));\n  } else {\n    dh = abs (dh);\n    d = max (0.5 * dot (dh, vec2 (SQRT3, 1.)), dh.y) - 1.;\n  }\n  return d;\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 0.7;\n  q = p;\n  d = max (max (PrRCylDf (q, 1.2, 2., 3.5),\n     - max (PrRCylDf (q - vec3 (0., 0.1, 0.), 1.15, 2., 3.5),\n     max (q.y - 0.1, - q.y - 0.1))), max (q.y - 0., - q.y - 0.2));\n  q.y -= -0.2;\n  d = max (SmoothMin (d, max (PrRCylDf (q, 1., 2., 3.3), q.y), 0.1), q.z - 2.);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (-0.5, -0.2);\n  d = max (PrRCylDf (q, 1., 1.1, 2.3), max (0.4 - q.y, q.z - 1.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 2;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (1.3, -0.6);\n  d = PrCylDf (q.xzy, 0.04, 0.8);\n  q.y -= 0.2;\n  d = min (d, PrCylDf (q.yzx, 0.02, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 3; }\n  q.y -= 0.6;\n  d = PrCylDf (q.xzy, 0.15, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 4; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, -0.9, 2.);\n  d = PrRoundBoxDf (q, vec3 (0.02, 0.2, 0.1), 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 5; }\n  q.y -= -0.4;\n  d = PrCylAnDf (q, 0.1, 0.02, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (-1., 2.);\n  d = PrCylDf (q, 0.1, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (0.3, 1.9);\n  d = PrCylDf (q.xzy, 0.015, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 7; }\n  q.yz -= vec2 (0.38, 0.15);\n  d = PrBoxDf (q, vec3 (0.01, 0.1, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 8; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dLim;\n  const float szFac = 2.;\n  dLim = 0.2;\n  dMin = dstFar;\n  dMin *= szFac;\n  for (int k = 0; k < 3; k ++) {\n    q = szFac * (p - boatPos[k]);\n    idObjGrp = (k + 1) * 256;\n    d = PrCylDf (q.xzy, 3.5, 3.);\n    dMin = (d < dLim) ? BoatDf (boatMat[k] * q, dMin) : min (dMin, d);\n  }\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 BoatCol (vec3 n)\n{\n  vec3 col, nn, cc;\n  float spec;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (ig == 1) nn = boatMat[0] * n;\n  else if (ig == 2) nn = boatMat[1] * n;\n  else nn = boatMat[2] * n;\n  spec = 0.3;\n  if (id == 1) {\n    if (qHit.y < 0.1 && nn.y > 0.99) {\n      col = vec3 (0.8, 0.5, 0.3) *\n         (1. - 0.4 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.)));\n      spec = 0.1;\n    } else {\n      cc = vec3 (0.9, 0.3, 0.3);\n      if (qHit.y > -0.2) col = (ig == 1) ? cc :\n         ((ig == 2) ? cc.yzx : cc.zxy);\n      else col = vec3 (0.7, 0.7, 0.8);\n      spec = 0.7;\n    }\n  } else if (id == 2) {\n    if (abs (abs (qHit.x) - 0.24) < 0.22 && abs (qHit.y - 0.7) < 0.15 ||\n       abs (abs (qHit.z + 0.2) - 0.5) < 0.4 && abs (qHit.y - 0.7) < 0.15) {\n       col = vec3 (0., 0., 0.1);\n       spec = 1.;\n     } else col = vec3 (1.);\n  } else if (id == 3) col = vec3 (1., 1., 1.);\n  else if (id == 4) col = vec3 (1., 1., 0.4);\n  else if (id == 5) col = vec3 (0.4, 1., 0.4);\n  else if (id == 6) col = vec3 (1., 0.2, 0.);\n  else if (id == 7) col = vec3 (1., 1., 1.);\n  else if (id == 8) col = (ig == 1) ? vec3 (1., 0.4, 0.4) : vec3 (0.4, 1., 0.4);\n  return vec4 (col, spec);\n}\n\nfloat WakeFac (vec3 p)\n{\n  vec3 twa;\n  vec2 tw[3];\n  float twLen[3], wkFac;\n  for (int k = 0; k < 3; k ++) {\n    tw[k] = p.xz - (boatPos[k].xz - Rot2D (vec2 (0., 0.12), boatAng[k]));\n    twLen[k] = length (tw[k]);\n  }\n  if (twLen[0] < min (twLen[1], twLen[2])) twa = vec3 (tw[0], boatAng[0]);\n  else if (twLen[1] < twLen[2]) twa = vec3 (tw[1], boatAng[1]);\n  else twa = vec3 (tw[2], boatAng[2]);\n  twa.xy = Rot2D (twa.xy, - twa.z);\n  wkFac = clamp (1. - 2.5 * abs (twa.x), 0., 1.) * clamp (1. - 2. * twa.y, 0., 0.2) *\n     smoothstep (-5., -2., twa.y);\n  return wkFac;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (50. - ro.y) / (rd.y + 0.0001) + ro.xz));\n  col = vec3 (0., 0.2, 0.7) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) +\n     0.2 * pow (sd, 512.));\n  return mix (col, vec3 (0.9), clamp ((f - 0.05) * rd.y + 0.3, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, row, rdw;\n  float dstObj, dstWat, dstBlk, dEdge, diff, h, sh, reflCol, wkFac;\n  int idObjT;\n  reflCol = 1.;\n  dstBlk = HexVolRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstWat = - (ro.y + 2.) / rd.y;\n  if (rd.y * (min (dstBlk, dstObj) - dstWat) < 0.) {\n    ro += dstWat * rd;\n    row = ro;\n    wkFac = WakeFac (row);\n    vn = vec3 (0., 1., 0.);\n    if (wkFac > 0.) vn = VaryNf (100. * ro, vec3 (0., 1., 0.), 10. * wkFac);\n    else vn = VaryNf (2. * ro, vec3 (0., 1., 0.), 0.2);\n    rd = reflect (rd, vn);\n    rdw = rd;\n    dstBlk = HexVolRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    reflCol = 0.8;\n  }\n  bgCol = vec3 (0.2, 0.2, 0.3) * (1. + 0.2 * rd.y);\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      ro += rd * dstBlk;\n      vn = qnHit.yzx;\n      dEdge = EdgeDist (ro);\n      h = smoothstep (0., 0.1, HexFaceDist (ro));\n      col = HexVolCol (ro, dEdge, dstBlk) * (0.7 + 0.3 * h) *\n         (1. - 0.2 * Fbm3 (30. * ro));\n      col = mix (vec3 (0., 0.2, 0.), col, 0.5 + 0.5 * smoothstep (-2., -1.8, ro.y));\n      vn = VaryNf (5. * ro, vn, 2.);\n      diff = max (dot (sunDir, vn), 0.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.5 : 1.;\n      col = col * (0.2 + sh * (0.1 * max (vn.y, 0.) + 0.8 * diff)) + 0.2 * sh *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);        \n      col = mix (col, bgCol, smoothstep (0.2 * dstFar, 0.85 * dstFar, dstBlk));\n    } else {\n      ro += rd * dstObj;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      col4 = BoatCol (vn);\n      diff = max (dot (sunDir, vn), 0.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.5 : 1.;\n      col = col4.rgb * (0.3 + 0.7 * sh * diff) +\n         col4.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    }\n  } else col = SkyCol (ro, rd);\n  col *= reflCol;\n  if (reflCol < 1. && wkFac > 0.) col = mix (col, vec3 (0.9),\n     10. * wkFac * clamp (0.1 + 0.5 * Fbm3 (23. * row), 0., 1.));\n  return col;\n}\n\nvoid BoatPM (float t)\n{\n  vec3 v;\n  float c, s, bAz;\n  bPos = TrackPath (t);\n  bPos.y = -1.9;\n  bMat[2] = vec3 (1., 0., 0.);\n  bMat[0] = normalize (vec3 (0., 0.1, 1.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  v = TrackVel (t);\n  bAz = atan (v.z, - v.x);\n  bAng = 0.5 * pi - bAz;\n  c = cos (bAz);\n  s = sin (bAz);\n  bMat *= mat3 (c, 0., s, 0., 1., 0., - s, 0., c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, vMov, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  trkF = vec3 (0.029, 0.021, 0.016);\n  trkA = vec3 (15., 23., 34.);\n  vMov = 4.;\n  for (int k = 0; k < 3; k ++) {\n    BoatPM (vMov * tCur + 8. + 12. * float (k));\n    boatPos[k] = bPos;  boatMat[k] = bMat;  boatAng[k] = bAng;\n    boatPos[k].y += 0.1 * Fbm1 (5. * float (k) + tCur);\n  }\n  ro = TrackPath (vMov * tCur);\n  ro.y += 0.2;\n  vd = TrackVel (vMov * tCur);\n  el = 0.;\n  az = atan (vd.x, vd.z);\n  if (mPtr.z > 0.) {   \n    el += 0.7 * pi * mPtr.y;\n    az += 2. * pi * mPtr.x;\n  }\n  ori = vec2 (clamp (el, -0.5 * pi, 0.45 * pi), az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  dstFar = 250.;\n  a = 0.3 * pi * sin (0.02 * pi * tCur);\n  sunDir = normalize (vec3 (sin (a), 3., - cos (a)));\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p = 2. * p.yzx;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBfzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4djBDw", "name": "Equerre Tiling Spiral", "author": "ttoinou", "description": "A pythagorean spiral of equerre triangles is used to start equerres tilings,\nHoped to be better but failed :-( \nNeed to find another cool spiral !\nMouse X to control number of recursions", "tags": ["spiral", "tiling", "equerre"], "likes": 6, "viewed": 136, "date": "1500730189", "time_retrieved": "2024-06-20T18:57:35.376517", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n    float ID2;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C; \\\n    T.ID = Q.ID;  \\\n    T.ID2 = Q.ID2;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \n#define _AB_ (1)\n#define _BC_ (2)\n#define _CA_ (3)\n        \n#define _ALPHA_ _AB_\n#define _BETA_  _BC_\n#define _GAMMA_ _CA_\n        \n#define _REPLACE_(X,Y,Z,T) \\\n        if( Begin == X && End == Y && !operation ) { \\\n            Begin = Z; End = T; operation = true; \\\n        } else if( End == X && Begin == Y && !operation) { \\\n            End = Z; Begin = T; operation = true; \\\n        }\n\n#define _SWAP_(X,Y) _REPLACE_(X,Y,Y,X)\n\n#define _SWAP_KEEP_BETA_ \\\n\t_REPLACE_(_BETA_,_ALPHA_,_BETA_,_GAMMA_) \\\n\t_REPLACE_(_BETA_,_GAMMA_,_BETA_,_ALPHA_) \\\n\n#define _SWAP_KEEP_GAMMA_ \\\n\t_REPLACE_(_GAMMA_,_ALPHA_,_GAMMA_,_BETA_) \\\n\t_REPLACE_(_GAMMA_,_BETA_,_GAMMA_,_ALPHA_) \\\n\n        \n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\n// Base Triangle\nEquerre Tri;\n\nfloat k = 1. - sqrt(3.)*.5;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,-(n + logZoom)/2.) , (n)/3.*PI + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\n\n\n\nvec3 colorTriangle(vec2 uv,Equerre Tri)\n{\n    vec2 C = EQUERRE_CENTER(Tri);\n    vec3 col = vec3(C*.5+.5,1.); \n    \n    col = hash3point(vec2(\n        // coloring algorithm\n        Tri.ID+cos(Tri.ID2),sin(Tri.ID*3.)-Tri.ID2\n        //abs(Tri.ID*5.),Tri.ID*cos(Tri.ID)*34.\n        \n        //Tri.ID,Tri.ID // this coloring shows that there's something wrong with Tri.ID ?\n    ));\n    \n    float scale = 6./viewportMagnify;\n    vec3 EquerreColor = vec3(0.); // buggy if not black :'( \n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 6.;\n    vec2 TriCenterMix = (Tri.A*2. + Tri.B + Tri.C*sqrt(3.))/(3. + sqrt(3.)); // incircle center\n    \n    #if SHOW_POINTS==1\n        col *= 4.*(1. + coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 10;//1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    // doesn't matter, infinite zoom :p\n    viewportMagnify = 1.; \n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.))) * exp(-iTime/8.);\n    uv *= viewportMagnify;\n    \n    \n    angleShift = iTime/2.;\n    logZoom = iTime/1.5;\n    \n    float r = floor( -log(dot(uv,uv))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv) )\n    {\n        FindEquerre(r,uv);\n    }\n    \n    Tri.ID2 = 0.;\n    Equerre Tri_TMP;\n    float kLimit = mix( .8 , 4. , iMouse.x/iResolution.x )/5.*viewportMagnify;\n    float k;\n    \n    for(int i = 0 ; i < nbIterations; i++)\n    {\n        EQUERRE_COMPUTE_DE(Tri);\n        Tri_TMP.ID2 = Tri.ID2 * 3.;\n        \n        if( EQUERRE_COND1(uv,Tri) )\n        {\n            EQUERRE_GET1(Tri_TMP,Tri);\n            Tri_TMP.ID2 += 0.;\n        }\n        else if( EQUERRE_COND2(uv,Tri) )\n        {\n            EQUERRE_GET2(Tri_TMP,Tri);\n            Tri_TMP.ID2 += 1.;\n        }\n        else \n        {\n            EQUERRE_GET3(Tri_TMP,Tri);\n            Tri_TMP.ID2 += 2.;\n        }\n        \n        k = length(Tri_TMP.B - Tri_TMP.A)/kLimit;\n        if( k < 1. )\n        {\n            break;\n        }\n        else\n        {\n        \tEQUERRE_COPY(Tri,Tri_TMP);\n        }\n    }\n    \n    k = max( (k-1./sqrt(3.))/(1. - 1./sqrt(3.)) , 0. );\n    \n    fragColor.rgb = mix(\n        colorTriangle(uv,Tri),\n        colorTriangle(uv,Tri_TMP),\n        smoothstep(0.,1.,sqrt(k))\n    );\n    \n    \n    \n    fragColor.rgb = tanh( fragColor.rgb / (.5 + kLimit/viewportMagnify) * .7 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4djBzy", "name": "Buggy Rip of IQs Heart", "author": "Slyth", "description": "No clue why the shadows are bugging out. Not too worried about it. Was just interested in messing around with sphere deformations. Wrote this in very short amount of time, not high quality whatsoever. Credit to www.youtube.com/watch?v=aNR4n0i2ZlM (IQ)", "tags": ["raymarching"], "likes": 0, "viewed": 109, "date": "1500957381", "time_retrieved": "2024-06-20T18:57:35.376517", "image_code": "vec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n\tif (obj0.x < obj1.x)\n    \treturn obj0;\n\telse\n    \treturn obj1;\n}\n\nvec2 obj_floor(in vec3 p)\n{\n\treturn vec2(p.y+4.0,0);\n}\n\nvec2 obj_sphere(in vec3 op, float r)\n{\n    float theta = iTime * 0.5;\n    mat3 rot = mat3(vec3(cos(theta), 0.0, -sin(theta)),\n                    vec3(0.0, 1.0, 0.0),\n                    vec3(sin(theta), 0.0, cos(theta)));\n    vec3 p = op * rot;\n    r = r + r / 5.0 * pow(0.5 + 0.5 * sin(2.0 * 3.14159265 * iTime + p.y), 3.5);\n    p.z = p.z * (2.1 - p.y);\n    p.y = 1.2 * p.y - abs(p.x) * sqrt(max(1.25 - abs(p.x), 0.0));\n  \treturn vec2(length(p) - r, 1.0);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n  \treturn obj_union(obj_floor(p), obj_sphere(p + vec3(0.0, 1.0, 0.0), 1.0));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 64; ++i )\n    {\n        vec2 h = distance_to_obj( ro + rd * t * .6);\n        if ( h.x < 0.001 )\n            return 0.1;\n\t\t\n\t\tres = min( res, k * h.x / t );\n        t += h.x;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distance_to_obj( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 1.0;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 floor_color(in vec3 p)\n{\n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n\treturn 0.3 + 0.1 * f * vec3(1.0);\n}\n\nvec3 prim_c(in vec3 p)\n{\n  \treturn vec3(0.8, 0.3, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * uv;\n\n   \tvec3 vuv=vec3(0,1,0); \n    vec3 vrp=vec3(0,-1,0);\n\n\tvec3 prp = vec3(0.0, 0.1, -3.0); \n    \n    vec3 vpn = normalize(vrp-prp);\n  \tvec3 u = normalize(cross(vuv,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = (prp+vpn);\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-prp);\n    \n    vec3 lightPos = vec3(5.0, 2.5, -4.0);\n  \tvec3 fogColor = vec3(0.5,0.6,0.7);\n    vec3 lightColor = vec3(1.0);\n\n    const vec3 e = vec3(0.02,0,0);\n  \tconst float maxd = 100.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 c,p,N;\n    \n    float f = 1.0;\n    float stepDist = 0.9;\n    for(int i = 0; i < 256; i++)\n    {\n     \tif((abs(d.x) < .001) || (f > maxd))\n        \tbreak;\n        f += d.x;\n        p = prp + scp * f;\n        d = distance_to_obj(p);\n    }\n    \n    if (f < maxd)\n  \t{\n        if (d.y==0.0) {\n      \t\tc=floor_color(p);\n            N = vec3(0.0, 1.0, 0.0);\n        } else {\n      \t\tc=prim_c(p);\n    \t    N = vec3(d.x-distance_to_obj(p-e.xyy).x, d.x-distance_to_obj(p-e.yxy).x, d.x-distance_to_obj(p-e.yyx).x);\n        }\n        \n    \tN = normalize(N);\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(N, lightDir), 0.0);\n\t\tvec3 diffuse = diff * lightColor; \n        float vis = shadowSoft( p, normalize(lightPos-p), 0.0925, length(lightPos-p), 128.0);\n        float ambient = 0.15;\n        float ao = calcAO(p, N);\n        vec3 h = (lightDir - scp) / 2.0;\n\t\tfloat s = clamp(pow(dot(N, h), 30.) * 50.0, 0.0, 0.9);\n        diffuse += s;\n        \n        float fogAmount = 1.0 - exp(-sqrt(p.x * p.x + p.z * p.z) * 0.065 );\n    \tfragColor = vec4(mix(c * diffuse * (ao * 1.0) * (vis * 1.5 + 0.3) + ambient, fogColor, fogAmount), 1.0);\n  }\n  else \n    fragColor = vec4(fogColor,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djBzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4djfz3", "name": "Calm Blue Ocean", "author": "purrrcy", "description": "Some fun with SDF water and a very simple day/night cycle", "tags": ["sdf", "water", "spheremarch"], "likes": 4, "viewed": 157, "date": "1501466046", "time_retrieved": "2024-06-20T18:57:36.649363", "image_code": "// The number of seconds for the sun to do one lap.\n#define DAY_NIGHT_CYCLE_PERIOD 32.\n\nstruct Sdf {\n    float dist;\n    float material;\n};\n\nSdf sdfSky(vec3 point) {\n    float d = length(point);\n\treturn Sdf(140. - d, 0.);\n}\n\nSdf sdfSphere(vec3 point, vec3 origin, float radius) {\n    vec3 po = point - origin;\n    float d = length(po);\n\treturn Sdf(d - radius, 1.);\n}\n\nSdf sdfPlane(vec3 point, vec3 normal, float D) {\n    float d = dot(point, normal) - D;\n\treturn Sdf(d, 1.);\n}\n\nfloat wave(float offset, float frequency, float dir, vec3 p) {\n\treturn cos(offset + frequency * dot(p.xz, vec2(cos(dir), sin(dir))));\n}\n\nfloat wave(float offset, float frequency, vec3 origin, vec3 p) {\n\treturn cos(offset + frequency * distance(p, origin));\n}\n\n\nfloat waves(float t, vec3 p) {\n\tfloat d = 0.;\n    //d += 0.10 * (sin(t * 0.5 + p.x) + cos(t * 0.3 + p.z));\n\t//d += 0.33 * (sin(t * .2 + p.x * 0.13) + cos(t * 0.17 + p.z * .2));\n    \n\td += 0.33 * wave(t * 1.1, 0.1, 2.0, p);\n\td += 0.37 * wave(t * .53, 0.13, 2.3, p);\n\td += 0.33 * wave(t * .33, 0.25, 0.3, p);\n\td += 0.31 * wave(t * .25, 0.33, 0.6, p);\n\n\td += 0.13 * wave(-t * 0.63, 0.6, vec3(80., 0.0, 50.), p);\n\t//d += 0.12 * wave(-t * 2.1, 0.2, vec3(-20., 0.0, -90.), p);\n\n\t\n    //d += 0.33 * wave(-t * 3.3, 0.6, vec3(80., 0.0, 30.), p);\n\n\t//d += 0.13 * wave(t * 1.3, 1.0, -0.6, p);\n\t//d += 0.7 * wave(t * 0.4, 0.2, 1.7, p);\n\t//d += 0.15 * wave(1.42 + t * 4.4, 0.2, vec3(1., 3.0, .0), p);\n\n    return d * 0.45;\n}\n\nSdf sdfWave(vec3 point, vec3 normal, float D) {\n    float d = dot(point, normal) - D\n        + waves(iTime, point);\n\treturn Sdf(d, 1.);\n}\n\nSdf pickClosest(Sdf a, Sdf b) {\n    float aOrB = step(b.dist, a.dist);\n    return Sdf(mix(a.dist, b.dist, aOrB),\n               mix(a.material, b.material, aOrB));\n}\n\nstruct Intersection {\n    vec3 normal;\n    float depth;\n    float material;\n};\n\nSdf world(vec3 p) {\n    Sdf closest = sdfSky(p);\n    Sdf ground = sdfWave(p, vec3(0., 1., 0.), -2.);\n\n    closest = pickClosest(closest, ground);\n    return closest;\n}\n\nvec3 worldNormal(vec3 p) {\n    //iq's trick\n    vec2 e = vec2(1.0, -1.0) * 0.0125;\n    return normalize(e.xyy * world(p + e.xyy).dist + \n\t\t\t\t\t e.yyx * world(p + e.yyx).dist + \n\t\t\t\t\t e.yxy * world(p + e.yxy).dist + \n\t\t\t\t\t e.xxx * world(p + e.xxx).dist );\n}\n    \nIntersection trace(vec3 rayOrigin, vec3 rayDirection, float startDepth) {\n    \n    float depth = startDepth;\n    \n    Sdf closest = Sdf(0., 0.);\n\n    for (int j = 0; j < 10; ++j) {        \n        for (int i = 0; i < 8; ++i) {\n\n            vec3 marched = rayOrigin + rayDirection * depth;\n\t\t\tclosest = world(marched);\n\n            depth += closest.dist;\n        }\n\t    if ((closest.dist * closest.dist) < 0.0001) {\n\t\t    vec3 normal = worldNormal(rayOrigin + rayDirection * depth);\n\t    \treturn Intersection(normal, depth, closest.material);\n    \t}\n    }\n    \n\tvec3 normal = worldNormal(rayOrigin + rayDirection * depth);\n    return Intersection(normal, depth, closest.material);\n}\n\nstruct SurfaceIntersection {\n    vec3 normal;\n    vec3 origin;\n    vec3 reflectionDirection;\n    vec3 refractionDirection;\n    \n    float NdotV;\n    float NdotT;\n};\n\nSurfaceIntersection surface(Intersection i, vec3 rayOrigin, vec3 rayDirection) {\n    vec3 V = -rayDirection;\n\tvec3 R = reflect(rayDirection, i.normal);\n\tvec3 T = refract(rayDirection, i.normal, 1.0 / 1.5);\n\n    return SurfaceIntersection(i.normal,\n                               rayOrigin + rayDirection * i.depth,\n                               R,\n                               T,\n                   \t\t\t   max(0., dot(i.normal, V)),\n                               max(0., dot(i.normal, -T)));\n}\n\nvec3 sunDirection() {\n    float t = iTime * (6.283 / DAY_NIGHT_CYCLE_PERIOD) + 1.2;\n    //t = 3.;\n    return normalize(vec3(0.2 * cos(t) + sin(t), .2 + .8 * cos(t), 0.2 * sin(t)));\n}\n\nvec3 skyColorDiffuse(vec3 direction) {\n    //direction = normalize(direction);\n\tvec3 L = sunDirection();\n    vec3 bgDay = mix(vec3(0.6, 0.7, .8), vec3(0.7, 0.8, .9), direction.y);\n    vec3 bgNight = mix(vec3(.075, .15, .15), vec3(.1, .2, .3), direction.y);\n    //vec2 polar = atan(direction.yy, direction.xz);\n    //vec3 bgStars = .3 * texture(iChannel1, polar.xy).rgb;\n    \n    vec3 bg = mix(bgNight, bgDay, smoothstep(-.2, .2, L.y));\n    //bg = mix(bgStars, bg, smoothstep(-.8, -.3, L.y));\n\n \n    // TODO: should do some atmospheric refraction here\n    float RdotL = max(0., dot(direction, L));\n    vec3 sun = mix(vec3(0.), vec3(0.3, 0.2, 0.), pow(RdotL, 2.));\n \n    \n\treturn bg + sun;\n}\n\nvec3 skyColorSpec(vec3 direction) {\n\tvec3 L = sunDirection();\n\n    // TODO: should do some atmospheric refraction here\n    float RdotL = max(0., dot(direction, L));\n    vec3 sunColor = mix(vec3(.8, .6, .1), vec3(.8, .2, .1), pow(1. - L.y, 2.));\n    vec3 sunSpot = sunColor * 13. * pow(RdotL, 250.);\n \n\treturn skyColorDiffuse(direction) + sunSpot;\n}\n\n\nvec3 Fresnel(vec3 n1, vec3 n2, float NdotV) {\n\tvec3 R0 = (n1 - n2) / (n1 + n2);\n    R0 = R0 * R0;\n    return R0 + (vec3(1.) - R0) * pow(1. - NdotV, 5.);\n}\n\nvec3 colorAtSurface(SurfaceIntersection surf) {\n\n    vec3 indirectSky = skyColorDiffuse(surf.normal) * .4;\n    \n    vec3 indirect = mix(vec3(0.0, 0.0, 0.2), vec3(0.1, 0.1, 0.4), max(0., surf.origin.y * 0.15 + .6));\n\treturn indirectSky + indirect;\n}\n\nvec3 colorAt(vec3 rayOrigin, vec3 rayDirection) {\n    \n    //find intersection in scene\n    vec3 origin = rayOrigin;\n    vec3 direction = rayDirection;\n    vec3 color = vec3(0.);\n    \n    vec3 intensity = vec3(1.);\n\tIntersection intersection = trace(origin, direction, 1.);\n    for (int i = 0; i < 3; ++i) {\n    \tif (intersection.material < 1.) {\n    \t\tcolor += skyColorSpec(direction) * intensity;\n            return color;\n        } else {\n\t\t    SurfaceIntersection surf = surface(intersection, origin, direction);\n    \t\tvec3 F = Fresnel(vec3(1.), vec3(1.4, 1.3, 1.4), surf.NdotV);\n            F += min(vec3(1.), pow(intersection.depth * 0.0045, 2.));\n            vec3 T = (1. - F) * intensity;\n            // mix in a surface layer and a deep ocean layer by the incidence\n            // of the refracted ray.\n            color += T * mix(colorAtSurface(surf), vec3(.01, .01, .1), surf.NdotT);\n            intensity *= F;\n            origin = surf.origin;\n            direction = surf.reflectionDirection;\n            intersection = trace(origin, direction, 24.);\n        }\n    }\n    // treat last hit as sky for the remaining intesity\n    color += skyColorDiffuse(direction) * intensity;\n    return color;\n}\n\nvec3 rotateX(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x, v.y * c - v.z * s, v.y * s + v.z * c);\n}\n\nvec3 rotateY(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}\n\nvec3 rotateZ(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x * c - v.y * s, v.x * s + v.y * c, v.z);\n}\n\nvec3 colorAtScreenCoord(vec2 uv) {\n    vec3 ray = normalize(vec3(uv, -1.4));\n    ray = rotateX(ray, .05 + (iMouse.y / iResolution.y) * 0.45);\n    \n    vec3 origin = vec3(0., 4., 5.);\n    origin = rotateY(origin, -1.9);\n    ray = rotateY(ray, -1.9);\n    \n\treturn colorAt(origin, normalize(ray));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy / iResolution.xy) - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.);\n    // do a silly spiral pattern AA\n    const int spp = 5; \n    const float sppF = 1. / float(spp);\n    for (int i = 0; i < spp; ++i) {\n        float rad = 3.141592 * (float(i) * 2.1 * sppF);\n        vec2 offset = float(i) * (sppF * 6. / iResolution.x) * vec2(cos(rad), sin(rad));\n\t    color += colorAtScreenCoord(uv + offset) * sppF;\n    }\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSBR3", "name": "Spiral1", "author": "sambaridli", "description": "Spiral", "tags": ["spiral", "circle"], "likes": 2, "viewed": 1345, "date": "1501316322", "time_retrieved": "2024-06-20T18:57:36.976532", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define PARTS 100.\n#define WIDTH 0.1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv = 2. * uv - 1.;\n    \n    float SPIRAL_GAP = WIDTH / PARTS;\n    float ANGLE = 360. / PARTS;\n    \n    float dist_to_point = distance(uv, vec2(0., 0.));\n    \n    float theta = asin(uv.y / dist_to_point);\n    \n    theta *= (180. / M_PI);\n    \n    if (theta >= 0.)\n    {\n        if (uv.x >= 0.)\n            ;\n        else\n            theta = 180. - theta;\n    }\n    else \n    {\n        if (uv.x >= 0.) \n            theta += 360.;\n        else\n            theta = 180. - theta;\n    }\n\n    \n    float group = floor(theta / ANGLE);\n    float group_radius = group * SPIRAL_GAP;\n    float time_variation = mod(iTime, 0.9) / 9.;\n    \n    float remainder = mod(dist_to_point, WIDTH);\n    \n    group_radius += time_variation;\n    if (group_radius > WIDTH)\n    {\n        remainder += WIDTH;\n    }\n    \n    float final_color = 0.;\n\n    final_color = smoothstep(group_radius - 0.007, group_radius + 0.005, remainder);\n    if (final_color == 1.)\n        final_color = 0.;\n    fragColor = vec4(vec3(final_color), 1.);\n}\t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSBzD", "name": "Tetris Shapes Fractal", "author": "KilledByAPixel", "description": "Fratal zoom into random tetrominos with random rotations & colors.", "tags": ["fractal", "tetris"], "likes": 4, "viewed": 160, "date": "1499658606", "time_retrieved": "2024-06-20T18:57:38.207328", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Tetris Shapes Fractal - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.6;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 0.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 4;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 28;// how many glyphs total\nconst float glyphMargin\t\t\t= 1.0;\t// how much to center the glyph in each pixel\nconst int glyph[glyphSize*glyphCount] = int[]\n(// glyph sheet\n 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0110, 0x0110, 0x0010, 0x0100, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0010, 0x0100, 0x0010, 0x0100,   \n 0x0000, 0x0110, 0x0010, 0x1000, 0x1100, 0x0110, 0x0100, 0x0110, 0x0010, 0x0100, 0x0110, 0x0110, 0x0100, 0x1100, 0x1110, 0x0110, 0x0000, 0x0110, 0x1110, 0x1110, 0x1100, 0x1100, 0x0100, 0x0110, 0x0010, 0x0100, 0x0110, 0x0110, \n 0x1111, 0x0110, 0x1110, 0x1110, 0x0110, 0x1100, 0x0100, 0x0110, 0x0010, 0x0100, 0x0100, 0x0010, 0x1110, 0x0100, 0x0100, 0x0100, 0x1111, 0x0110, 0x0010, 0x1000, 0x0110, 0x0110, 0x0100, 0x0110, 0x0110, 0x0110, 0x0100, 0x0010, \n 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000\n);//   \n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 10;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0), pow(gsfi,8.0), pow(gsfi,9.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    return 1.0;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3\n    (\n    \tmix(0.0, 1.0, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n    \tmix(0.0, 1.0, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n        mix(0.0, 0.45, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y))\n    );\n    \n    // vary light and dark colors\n    if ((i+r)%2 == 0)\n        myColor.z = 1.0 - myColor.z;\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    return mix(color, myColor, f);\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += (0.05*uv.y + 0.05*uv.x + 0.05*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    // rotate over time\n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n    \n    // generate random rotations that will never have the same number in a row\n    int r1i = 2*(RandInt(iterations-1+10) % 2);\n    if ((iterations-1) % 2 == 0)\n        r1i += 1;\n    int r2i = 2*(RandInt(iterations+10) % 2);\n    if ((iterations) % 2 == 0)\n        r2i += 1;\n    float r1 = (pi/2.0)*float(r1i);\n    float r2 = (pi/2.0)*float(r2i);\n    if (r2 - r1 > pi)\n        r2 -= 2.0*pi;\n    if (r1 - r2 > pi)\n        r1 -= 2.0*pi;\n    float turnRate = 0.25;\n    \n    float theta = mix(r1, r2, ((1.0 / turnRate)*max(timePercent-(1.0-turnRate), 0.0)));\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyph[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyph(int i, ivec2 glyphPos, ivec2 glyphPosLast)\n{ \n    int seed = i + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 GetFocus(int i)\n{\n    // find a random valid pixel in glyph\n    int g = GetFocusGlyph(i-1);\n    int c = 0;\n    for (int y = 0; y < glyphSize; ++y)\n    {\n\t\tint glyphRow = GetGlyphPixelRow(y, g);\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }\n\n    c -= RandInt(i) % c;\n    for (int y = 0; y < glyphSize; ++y)\n    {\n\t\tint glyphRow = GetGlyphPixelRow(y, g);\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x,y);\n        }\n    }\n}\n        \n// get recursion depth of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocus(iterations-2);\n\tivec2 glyphPos =     GetFocus(iterations-1);\n    int g = GetFocusGlyph(iterations-1);\n\t\n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocus(iterations+r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        int glyphValue = 0;\n\t\tif (r <= recursionCount)\n        {\n            // offset and bounds check\n            pos -= vec2(glyphMargin/glyphSizeF);\n\n            // get glyph and pos within that glyph\n            glyphPosLast = glyphPos;\n            glyphPos = ivec2(pos * glyphSizeF);\n\n            // check depth\n            glyphValue = GetGlyphPixel(glyphPos, g);\n        }\n            \n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // update pos\n\t\tpos *= glyphSizeF;\n\t\tpos -= vec2(floor(pos));\n        \n        if (glyphPos == GetFocus(iterations+r))\n            g = GetFocusGlyph(iterations+r); // inject correct glyph\n        else\n            g = GetGlyph(iterations + r, glyphPos, glyphPosLast);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    vec2 uv2 = uv;\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n    \n    // rotate then zoom\n    //float turnRate = 0.75;//(abs(r1-r2) > pi - 0.1)? 0.5 : 0.75;\n    //timePercent = (min((timePercent)*(1.0/turnRate), 1.0));\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocus(iterations+i)) + vec2(glyphMargin)) / glyphSizeF) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv2);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSBzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSfWR", "name": "[SH17A] Fractal Chimneys", "author": "Klems", "description": "Not too happy about this one, but 280 char raymarching is hard :(", "tags": ["3d", "raymarching", "fractal", "sh17a"], "likes": 3, "viewed": 545, "date": "1500087841", "time_retrieved": "2024-06-20T18:57:38.207328", "image_code": "void mainImage( out vec4 c, vec2 p ) {\n    \n    vec3 h, n = vec3(p/iResolution.x-.5, 1);\n    \n    //if (iMouse.z > .5) n.xy += (iMouse.xy-iResolution.xy*.5)*.003;\n    \n    float d, s, i, j, t=i=0.;\n    for(;i++<2e2;) {\n        \n        h = n*t;\n        h.z += iTime;\n        \n        d = 9e9;\n        s = 2.;\n        \n        for(j=-.5;j++<8.;)\n            d = min(d, max((length(h.xz = 2.*fract(h.xz-.3)-1.)-.2)/(s *= 2.), h.y+j*.1));\n\n        t += d;\n    }\n    \n    c = vec4(.9, .6, .4, 1) / t * cos(h.y*4.)*.7+.5;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSfzD", "name": "Hexagonal Voronoi Line Distance", "author": "Shane", "description": "This is a 14 tap hexagonal version of IQ's Voronoi line-distance formula, with some additional smoothing for the rounded look. It's nothing exciting, but has been included for completeness.", "tags": ["voronoi", "line", "hexagon", "distance", "edge", "bump"], "likes": 17, "viewed": 1171, "date": "1499695827", "time_retrieved": "2024-06-20T18:57:40.364828", "image_code": "/*\n\n\tHexagonal Voronoi Line Distance\n\t-------------------------------\n\n\tAs the lacklustre title suggests, this is a hexagonal Voronoi implementation of the \n\t\"point to nearest cell edge distance\" formula. It uses fewer taps than the square\n\tgrid versions, but those gains are probably offset by the hexagonal transforms, etc. \n\tI kind of prefer the square grid version, but I thought it'd be nice to put this up \n\tfor comparison, and just in case someone required a reference.\n\n\tDr2 has been putting up a few hexagonal Voronoi examples lately. I was going to\n\tincorporate his code, but I thought I'd use one of my own versions, just to provide\n\ta mildly different perspective. It uses cheaper hexagonal transforms, but that may \n\tbe at the expense of less variation in point spread... I'm not sure.\n\n\tI did this for the novelty. Feel free to check out the Voronoi function, but it's\n\tpretty straight forward. Basically, you convert to a hexagonal grid, offset cell \n\tcenter points, find the nearest cell point, then perform another pass to determine the \n\tnearest edge to the nearest cell point. As you can see, the edges are pretty uniform.\n\n\tThe rest is just some very lazy prettying up. In case it isn't obvious, visually\n\tspeaking, this is just a rehash of my last example with a few simple changes. The\n\teffects are all fake. It's a essentially a bump mapped example with some shading to\n\tgive the impression of some shadowing.\n\n\t// Other examples:\n\n    // Another hexagonal Voronoi edge example using a more relaxed, but faster, method.\n    Voronoi Of The Week - Dr2\n\thttps://www.shadertoy.com/view/lsjBz1\n\n\t// The original point to nearest edge example.\n\tVoronoi distances - iq\n\thttps://www.shadertoy.com/view/ldl3W8\n\t// His well written article that describes the process in more detail.\n\t// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n*/\n\n//#define SCROLL\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    \n    #ifdef SCROLL\n    return fract(vec2(262144, 32768)*n); \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*.5 + .5; \n    #endif\n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n    \n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n// Converting to the hexagonal grid.\nvec2 pixToHex(vec2 p){\n    \n    return floor(vec2(p.x + .57735*p.y, 1.1547*p.y) + 1./3.);\n}\n\n// Randomized hexagonal offset point.\nvec2 hexPt(vec2 p) {\n\n    // The offset value is restricted to the radius of the incircle of the\n    // hexagon, or apothem as it's technically known.\n    return vec2(p.x - p.y*.5, .866025*p.y) + (hash22(p) - .5)*.866025/2.;\n    \n}\n\n\n// Scene object ID, and individual cell IDs. Used for coloring.\nfloat objID; // The rounded web lattice, or the individual Voronoi cells.\n//vec2 cellID; // Individual Voronoi cell IDs.\n\n// This is a hexagonal variation on a regular 2-pass Voronoi traversal that produces\n// a Voronoi pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It uses element from an old hexagonal Voronoi example, \n// and is based on IQ's original example. It was inspired by Dr2's hexagonal examples.\n// The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to attempt to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n//\n// Desert Town - dr2\n// https://www.shadertoy.com/view/XslBDl\nvec3 Voronoi(vec2 p){\n    \n    // Convert to the hexagonal grid.\n    vec2 pH = pixToHex(p); // Map the pixel to the hex grid.\n\n    // There'd be a heap of ways to get rid of this array and speed things up. The\n    // most obvious, would be unrolling the loops, but there'd be more elegant ways.\n    // Either way, I've left it this way just to make the code easier to read.\n \n    // Hexagonal grid offsets. \"vec2(0)\" represents the center, and the other offsets effectively circle it.\n    // Thanks, Abje. Hopefully, the compiler will know what to do with this. :)\n\tconst vec2 hp[7] = vec2[7](vec2(-1), vec2(0, -1), vec2(-1, 0), vec2(0), vec2(1), vec2(1, 0), vec2(0, 1)); \n    \n    \n    // Voronoi cell ID containing the minimum offset point distance. The nearest\n    // edge will be one of the cells edges.\n    vec2 minCellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for (int i=0; i<7; i++){\n    \n        // Determine the offset hexagonal point.\n        vec2 h = hexPt(pH + hp[i]) - p;\n        // Determine the distance metric to the point.\n    \td = dot(h, h);\n    \tif( d<md ){ // Perform updates, if applicable.\n            \n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = h; \n            //cellID = h + p; // For cell coloring.\n            minCellID = hp[i]; // Record the minimum distance cell ID.\n        }\n    }\n    \n    // Second pass: Point to nearest cell-edge distance.\n    //\n    // With the ID of the cell containing the closest point, do a sweep of all the\n    // surrounding cell edges to determine the closest one. You do that by applying\n    // a standard distance to a line formula.\n    for (int i=0; i<7; i++){\n    \n         // Determine the offset hexagonal point in relation to the minimum cell offset.\n        vec2 h = hexPt(pH + hp[i] + minCellID) - p - mo; // Note the \"-mo\" to save some operations. \n        \n        // Skip the same cell.\n        if(dot(h, h)>.00001){\n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article (link above) for a visual representation.            \n            lnDist = dot(mo + h*.5, normalize(h));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based\n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // Polynomial-based smooth minimum. The last factor controls the roundness of the \n            // edge joins. Zero gives you sharp joins, and something like \".25\" will produce a\n            // more rounded look.\n            lMd = smin(lMd, lnDist, .1);\n            // Exponential-based smooth minimum.\n            //lMd = sminExp(lMd, lnDist, 20.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n            \n        }\n\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but I'm not \n    // positive. Although not used here, the standard minimum point distance is returned also.\n    return max(vec3(lMd, lMd2, md), 0.);\n    \n    \n}\n\n// This is a bit messy. I'll tidy it up later, but it's basically just playing with\n// the Voronoi isovalues to geometrically show some lines, and so forth.\nfloat bumpFunc(vec2 p){ \n\n    vec3 v = Voronoi(p*4.);\n\tfloat c = v.x; // Range: [0, 1]\n    \n    // ID - used for scene object coloring.\n    objID = 0.;\n    \n    const float edge = .08;\n    const float edge2 = .08;\n    \n    if( c<edge) { // Main outer borders.\n        c = ((edge - c)/edge)*.1;\n        objID = 1.;\n    }\n    else {\n       c = (v.x - edge)/(1. - edge);\n        \n       if(c>edge2) { // Inner cells.\n           objID = 2.;\n           c = (v.y - edge2)/(1. - edge2)*2.;\n           \n        }\n        else { // Dark, inner borders.\n            c = abs(c - edge2)/(1. - edge2);\n           \n        }\n    }\n    \n    // Return the manipulated Voronoi value.\n    return c;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*0.15 + .1, sin(iTime)*0.15 + .1, -1.); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n \n\t// Scrolling.\n    #ifdef SCROLL\n    sp.x -= iTime/8.;\n    lp.x -= iTime/8.;\n    #endif     \n\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(2./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    \n    float svObjID = objID; // Save the object ID here.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n  \n    float fx2 = bumpFunc(sp.xy + eps.xy); // Same for the nearby sample in the X-direction.\n    float fy2 = bumpFunc(sp.xy + eps.yx); // Same for the nearby sample in the Y-direction.\n    float edge = abs(fx + fy + fx2 + fy2 - 4.*f);//abs(fx - f)+ abs(fy - f);\n    edge = smoothstep(0., 8., edge/eps.x);//sqrt(edge/eps.x*8.)\n   \n \t// Controls how much the bump is accentuated.\n\tfloat bumpFactor = .1;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*0.15);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth or the impression of ambient occlusion.\n    atten *= f*.7 + .3; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    //diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n\n\t\n    // TEXTURE COLOR\n    //\n\t// Fake tri-planar texel lookup, and by that I mean, I've moved the Z-position up by a fraction\n    // of the heightmap amount to give the impression that this is a 3D lookup. The rest is a  regular\n    // tri-planar lookup. Not sure if it made a difference, but it can't hurt.\n    vec3 nsn = max(abs(sn), .001);\n    nsn /= dot(nsn, vec3(1));\n    vec3 texCol = vec3(0), txA, txB, txC;\n    sp.z = -f*.2; // Moving the Z position out a bit - That's the fake bit.\n    txA = texture(iChannel0, sp.xy*2.).xyz;\n    txB = texture(iChannel0, sp.zx*2.).xyz;\n    txC = texture(iChannel0, sp.yz*2.).xyz;\n    // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    texCol = txA*txA*nsn.z + txB*txB*nsn.y + txC*txC*nsn.x; \n    texCol = smoothstep(.0, .5, texCol)*2.;\n \n    \n    if(svObjID>1.5) { // Salmon colored interior cells.\n        \n        texCol *= vec3(1.85, .7, .65);\n        // Some subtle leopard spot patterning.\n        texCol *= 1. - smoothstep(0., .05, Voronoi(sp.xy*32.).x - .025)*.25;\n        \n        // texCol = texCol.yzx; // Other colors, if you prefer. texCol.xzy, etc.\n        \n        \n    }\n    else if(svObjID>.5) { // Lighter outer edges.\n        texCol *= vec3(1.6, 1, .75);\n        // Some subtle reptilian patterning.\n        texCol *= smoothstep(0., .05, Voronoi(sp.xy*48.).x - .05)*.35 + .65;\n    }\n    else texCol *= .25; // Dark inner edges.\n        \n    \n\n\t// Mixing in some subtle purple for a bit more color variance. Made up on the spot.\n    texCol = mix(texCol, texCol.zyx, dot(sin(sp.xy*4. + cos(sp.yx*8.)), vec2(.0625)) + .125);\n         \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol * (diff + 0.25) + vec3(.5, .7, 1)*spec*2.)*atten;\n\n    // Applying a subtle edge outline.\n    if(svObjID>1.5) col *= 1. - edge*.65;\n    else if(svObjID>.5) col *= 1. - edge*.35;\n\n    // Mixing in the gradient for some fake shadowing.\n    col *= min(mix(max(fx, 0.), max(fy, 0.), .5)*.5 + .25, 1.25);\n    \n    \n    \n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSfzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2BRD", "name": "Red Heart", "author": "Txoka", "description": "red heart", "tags": ["heart"], "likes": 0, "viewed": 264, "date": "1499787902", "time_retrieved": "2024-06-20T18:57:40.364828", "image_code": "#define tau 6.2831853071795864769\n#define heart vec4(1.0,0.0,0.0,1.0)\n#define bright 0.5\n//bright radius best: 1000,2000,3000,5000,100\n#define brightRadius 2000\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 u = fragCoord.xy-iResolution.xy/2.;\n    u.y-=abs(u.x)*sqrt((100.-abs(u.x))/66.);\n   \tfloat c = u.x*u.x+u.y*u.y;\n    float r = (0.5*sin(tau*iTime+u.y/60.)+0.5)*0.4;\n    r*=r*r*r;\n    r+=0.2;\n    r*=r*99999.;\n    fragColor = smoothstep(r+300., r,c)*heart+(1.-smoothstep(0.,r+float(brightRadius),c))*bright;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2BRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2BRh", "name": "Colorful foam", "author": "vicyang", "description": "click mouse button to change effects", "tags": ["2d", "colorful", "soap", "foam"], "likes": 0, "viewed": 652, "date": "1499432545", "time_retrieved": "2024-06-20T18:57:40.370655", "image_code": "\nfloat RGB(float x, float y, float e)\n{\n    return ( x * tan(x/y) ) * ( y * tan( x/y + iTime/2.0 * e ) ) / (iMouse.x*10.0+500.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord;\n\t// coord = vec2( fragCoord.x - iResolution.x/2.0, fragCoord.y - iResolution.y/2.0 ) * 5.0; \n    coord = (fragCoord - iResolution.xy/2.0)*5.0;\n   \n\tfragColor = vec4(\n        float(int(RGB(coord.x, coord.y, 0.33)) %255) / 255.0,\n        float(int(RGB(coord.x, coord.y, 0.66)) %255) / 255.0,\n        float(int(RGB(coord.x, coord.y, 0.99)) %255) / 255.0,\n        1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2BRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2BWW", "name": "Demoivre's Theory", "author": "Slyth", "description": "Never knew this existed. Very neat idea, converting to polar coordinates for dynamic powers.", "tags": ["fractal"], "likes": 1, "viewed": 80, "date": "1500436847", "time_retrieved": "2024-06-20T18:57:40.370917", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float maxIter = 256.0;\n    vec2 r = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 z = vec2(0.0);\n    float zoom = 0.1;\n    vec2 xy = r;\n    vec2 c = vec2(0.0) + xy / (zoom * 10.0);\n    float distD = 1e20;\n    float distP = distD;\n    vec2 pointD = vec2(sin(iTime), cos(iTime));\n    vec2 pointP = vec2(pointD.x, -pointD.y);\n    float l = 0.0;//((sin(iTime * 0.5) + 1.0) * 0.5) * maxIter - 1.5;\n    float power = ((sin(iTime) + 1.0) * 0.5) * 5.0 + 2.0;\n    for(int i = 0; i >= 0; i++)\n\t{\n        float r = pow(length(z), power);\n        float theta = atan(z.y, z.x) * power;\n    \tz = r * vec2(cos(theta), sin(theta)) + c;\n\t\tif(z.x * z.x + z.y * z.y > maxIter * maxIter || l > maxIter) break; \n        float dTrap = cos(abs(z.x - pointD.x) + abs(z.y - pointD.y));\n        float pTrap = sin(abs(z.x - pointP.x) + abs(z.y - pointP.y));\n        distD = min(distD, dTrap * dTrap);\n        distP = min(distP, pTrap * pTrap);\n        l++;\n\t}\n    \n    distD = sqrt(distD);\n    distP = sqrt(distP); \n    fragColor = vec4(distD, distP, (distD + distP) / 2.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2BWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2fDm", "name": "Square Eyez", "author": "ttoinou", "description": "Some basic blending ", "tags": ["spiral", "complex", "equerre"], "likes": 7, "viewed": 126, "date": "1500758627", "time_retrieved": "2024-06-20T18:57:42.353376", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cnorm( vec2 z )  { return z/length(z); }\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \n#define _AB_ (1)\n#define _BC_ (2)\n#define _CA_ (3)\n        \n#define _ALPHA_ _AB_\n#define _BETA_  _BC_\n#define _GAMMA_ _CA_\n        \n#define _REPLACE_(X,Y,Z,T) \\\n        if( Begin == X && End == Y && !operation ) { \\\n            Begin = Z; End = T; operation = true; \\\n        } else if( End == X && Begin == Y && !operation) { \\\n            End = Z; Begin = T; operation = true; \\\n        }\n\n#define _SWAP_(X,Y) _REPLACE_(X,Y,Y,X)\n\n#define _SWAP_KEEP_BETA_ \\\n\t_REPLACE_(_BETA_,_ALPHA_,_BETA_,_GAMMA_) \\\n\t_REPLACE_(_BETA_,_GAMMA_,_BETA_,_ALPHA_) \\\n\n#define _SWAP_KEEP_GAMMA_ \\\n\t_REPLACE_(_GAMMA_,_ALPHA_,_GAMMA_,_BETA_) \\\n\t_REPLACE_(_GAMMA_,_BETA_,_GAMMA_,_ALPHA_) \\\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat k = 1. - sqrt(3.)*.5;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,-(n + logZoom)/2.) , (n)/3.*PI + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nvec3 color(vec2 uv_s)\n{\n    \n    float r = floor( -log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n    #endif\n    \n    return col*2./(1. + dot(uv_s,uv_s)/1e3 );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify = 1.; \n    //uv_s *= viewportMagnify;\n    \n    \n    angleShift = cos(iTime/3.5)*8.;\n    logZoom = iTime*1.5;\n    \n    float e = deformation_pole.x*1.;\n    \n    //fragColor.rgb = color(uv_s);\n    fragColor.rgb = mix(\n        color(uv_s),\n        color( (logZoom *= -1. , cconj ( cdiv(cnorm(vec2(1,1)),uv_s) ) ) ), //  , uv_s.y *= -1.\n        smoothstep(-e,e,uv.x) //uv.x*.5+.5\n    );\n\n    fragColor.rgb = tanh(fragColor.rgb  ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2fDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2fDz", "name": "Basic Metaballs", "author": "Slyth", "description": "playing around with metaballs", "tags": ["metaballs"], "likes": 0, "viewed": 77, "date": "1500091831", "time_retrieved": "2024-06-20T18:57:42.353376", "image_code": "const int NUM_BALLS = 4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 balls[NUM_BALLS];\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float sum = 0.0;\n\n    balls[0] = vec2(sin(iTime * 0.3), cos(iTime * 0.75)) * 0.8;\n    balls[1] = vec2(cos(iTime * 0.7), sin(iTime)) * 0.8;\n    balls[2] = vec2(sin(iTime), cos(iTime * (1.0 / 3.0))) * 0.8;\n    balls[3] = vec2(cos(iTime * 0.4), cos(iTime * 0.5)) * 0.8;\n\n    for(int i = 0; i < NUM_BALLS; i++)\n        sum += 0.25 / mix(abs(uv.x - balls[i].x) + abs(uv.y - balls[i].y), length(uv - balls[i]), (cos(iTime + float(i) * 13.5) + 1.0) * 0.5);\n\n    sum /= float(NUM_BALLS);\n    \n    fragColor = vec4(smoothstep(smoothstep(0.6, 0.4, sum), sum, (sin(iTime) + 1.0) * 0.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2fDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2fR3", "name": "Overlapping Shutter", "author": "isak", "description": "Animation of a overlapping shutter", "tags": ["triangles", "blades", "overlappingshutter"], "likes": 0, "viewed": 106, "date": "1501453801", "time_retrieved": "2024-06-20T18:57:42.353376", "image_code": "\n#define PI 3.1415926535\n\n\nvec2 orto(vec2 pv)\n{\n    return normalize(vec2(-pv.y, pv.x));\n}\n\nvec2 rot(vec2 p, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec2(ca*p.x - sa*p.y, ca*p.y + sa*p.x);\n}\n\n\nfloat sCircle(vec2 p, float r)\n{\n    float ds = 0.01*r;\n    return smoothstep(-ds, ds , (r-dot(p,p)));\n}\n\n\nfloat sTriangle(vec2 p, vec2 p1, vec2 p2, vec2 p3)\n{\n    float ds = 0.005;\n    vec3 dsv = vec3(ds, ds, ds);\n    vec3 pev = vec3(dot( orto(p2 - p1), p - 0.5*(p1 + p2)), \n                   \tdot( orto(p3 - p2), p - 0.5*(p2 + p3)),\n        \t\t\tdot( orto(p1 - p3), p - 0.5*(p3 + p1)));\n    vec3 S = smoothstep(dsv, -dsv, pev);\n    return S.x*S.y*S.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.2;\n    \n    float p_time_p = 0.5*(1.0 + sin(iTime/3.0));\n    float p_time_m = 0.5*(1.0 - sin(iTime/3.0));\n    \n    //uv = uv*(1.0/( p_time_m + (1.0 - p_time_p)*dot(uv,uv)) );\n    \n    uv = uv*( p_time_m*dot(uv,uv) + p_time_p/dot(uv,uv) );\n    \n    \n\tvec3 blue  = vec3(65.0, 105.0, 225.0)/255.0;\n    vec3 white = vec3(1.0, 1.0, 1.0); \n    vec3 gray = 0.8*vec3(0.1, 0.1, 0.1);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 brown = 0.1*vec3(255.0, 128.0, 0.0)/255.0 + 0.05*white;\n    \n\tint N = 11;  // Change this to for example 100 ;)\n    float alpha = PI/float(N);\n    \n    float L = 1.0;\n    float sft = 0.10;\n    vec2 shift = vec2(0.0, sft);\n    \n    float dw = L*tan(alpha);\n    \n    vec2 p1 = vec2(0.0, L) - shift;\n    vec2 p2 = vec2( dw, 0.0) - shift;\n    vec2 p3 = vec2(-dw, 0.0) - shift;\n       \n    float st = alpha + (0.5*PI - alpha)*(0.5 + 0.5*sin(iTime/1.5));\n    \n    float blades = 0.0; \n    float nails = 0.0;\n    \n   \tfor (int i = 0; i < N; i++)\n    {\n        float a = 2.0*PI*float(i)/float(N);\n       \t\n        vec2 p = (L - sft)*vec2(cos(a), sin(a));\n        \n        blades += sTriangle(uv, \n                            rot(p1, a + st) + p, \n                            rot(p2, a + st) + p, \n                            rot(p3, a + st) + p);\n        \n    \tnails += sCircle(uv - p, 0.0005);\n        \n    }\n    \n    float sRing = sCircle(uv, 1.0) - sCircle(uv, 0.65);\n    \n    sRing = 0.0; // Comment this line to recover the ring\n    \n    vec3 c = gray;\n    c += (blue - gray)*(blades - sRing*blades) + (brown)*(sRing-nails) + blue*nails  ;\n    c += 0.2*blue*(1.0 - smoothstep(+2.0, -2.0, 2.0 - dot(uv,uv)));\n    c += 0.2*blue*(1.0 - smoothstep(+0.5, -0.5, 0.5 - dot(uv,uv)));\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2fR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2fRW", "name": "Mandelbulb morphing", "author": "Slyth", "description": "Basic mandelbulb ray tracing", "tags": ["mandelbulb"], "likes": 4, "viewed": 248, "date": "1499767265", "time_retrieved": "2024-06-20T18:57:42.353376", "image_code": "vec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  \tif (obj0.x < obj1.x)\n  \t\treturn obj0;\n  \telse\n\t\treturn obj1;\n}\n\nvec2 obj_floor(in vec3 p)\n{\n\treturn vec2(p.y+4.0,0);\n}\n\nvec2 obj_sphere(in vec3 p, float r)\n{\n    return vec2(length(p) - r, 0);\n}\n\nvec2 obj_mandel(in vec3 p, in float power)\n{\n    float angle = radians(45.0);\n    mat3 rot = mat3(cos(angle), -sin(angle), 0,\n                    0, 0, 1,\n                    sin(angle), cos(angle), 0);\n    vec3 z = p * rot; // remove rot to see real mandelbulb. rotation is glitchy.\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++) {\n\t\tr = length(z);\n\t\tif (r>4.0) break;\n\t\t\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=p;\n\t}\n\treturn vec2(0.5*log(r)*r/dr, 1.0);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n    float power = (sin(iTime * 0.1 + 40.0) + 1.0) * 0.5 * 12.0 + 1.0;\n  \treturn obj_union(obj_floor(p), obj_mandel(p / 3.0, power));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 64; ++i )\n    {\n        vec2 h = distance_to_obj( ro + rd * t );\n        if ( h.x < 0.001 )\n            return 0.1;\n\t\t\n\t\tres = min( res, k * h.x / t );\n        t += h.x;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distance_to_obj( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 floor_color(in vec3 p)\n{\n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n\treturn 0.3 + 0.1 * f * vec3(1.0);\n}\n\nvec3 prim_c(in vec3 p)\n{\n    float d = obj_sphere(p, 1.0).x;\n  \treturn vec3(d / 5.0, d / 2.0, d / 3.0); // simplistic orbit trap coloring to darken towards center\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * uv;\n\n   \tvec3 vuv=vec3(0,1,0); \n    vec3 vrp=vec3(0,0,0);\n\n\tvec3 prp = vec3(sin(iTime*0.15) * 6.0, 2.0, cos(iTime * 0.15) * 6.0); \n    \n    vec3 vpn = normalize(vrp-prp);\n  \tvec3 u = normalize(cross(vuv,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = (prp+vpn);\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-prp);\n    \n    vec3 lightPos = vec3(sin(iTime * 0.5) * 7.0, 3.0, -cos(iTime * 0.5) * 7.0);\n  \tvec3 fogColor = vec3(0.5,0.6,0.7);\n    vec3 lightColor = vec3(0.8);\n\n    const vec3 e = vec3(0.02,0,0);\n  \tconst float maxd = 100.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 c,p,N;\n    \n    float f = 1.0;\n    float stepDist = 0.9;\n    for(int i = 0; i < 256; i++)\n    {\n     \tif((abs(d.x) < .001) || (f > maxd))\n        \tbreak;\n        f += d.x;\n        p = prp + scp * f;\n        d = distance_to_obj(p);\n    }\n    \n    if (f < maxd)\n  \t{\n        if (d.y==0.0) {\n      \t\tc=floor_color(p);\n            N = vec3(0.0, 1.0, 0.0);\n        } else {\n      \t\tc=prim_c(p);\n    \t    N = vec3(d.x-distance_to_obj(p-e.xyy).x, d.x-distance_to_obj(p-e.yxy).x, d.x-distance_to_obj(p-e.yyx).x);\n        }\n        \n    \tN = normalize(N);\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(N, lightDir), 0.0);\n\t\tvec3 diffuse = 0.3 + diff * lightColor; \n        float vis = shadowSoft( p, normalize(lightPos-p), 0.0625, length(lightPos-p), 128.0 );\n        float ambient = 0.15;\n        float ao = calcAO(p, N);\n        \n        float fogAmount = 1.0 - exp(-sqrt(p.x * p.x + p.z * p.z) * 0.065 );\n    \tfragColor = vec4(mix(c * diffuse * (ao * 1.0) * (vis + 1.3) + ambient, fogColor, fogAmount), 1.0);\n  }\n  else \n    fragColor = vec4(fogColor,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2fRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sBBWh", "name": "[SH17A] Directional Water Flow", "author": "drivenbynostalgia", "description": "Directional water flow shader based on https://www.shadertoy.com/view/Xt3XzH and https://www.shadertoy.com/view/lltSRH\n\nI reduced a shader from 2180 chars to 237 and all I got was this lousy feeling of accomplishment.", "tags": ["2tweets", "waterflow"], "likes": 5, "viewed": 610, "date": "1500205916", "time_retrieved": "2024-06-20T18:57:42.353376", "image_code": "void mainImage(out vec4 c, in vec2 p)\n{\n    vec2 r = iResolution.xy;\n    float h, o = h = 0., b = 1.;\n\n    while (o < 8.)\n        h += sin(b / (o + 15.) * (iTime * (o * (.5 - .1 * o++) + 5.) - 28. * length(p / r))) / (b += b);\n\n    vec2 n = 2. * vec2(dFdx(h), dFdy(h));\n\n    c = texture(iChannel0, p / r + n) + dot(n, n) * length(r);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sjBR1", "name": "Chevron", "author": "cacheflowe", "description": "I needed a chevron pattern for a project, so here it is :) ", "tags": ["blackandwhite", "bw", "pattern", "chevron"], "likes": 4, "viewed": 721, "date": "1499466785", "time_retrieved": "2024-06-20T18:57:42.353376", "image_code": "#define PI     3.14159265358\n\n// updated saw() from @ollj\nfloat sawNew(float rads) {\n    rads = rads / (PI * 2.) + PI / 4.;\n    rads = fract(rads); \n    return -1. + 2. * abs(rads * 2. - 1.);\n}\n\nfloat saw(float rads) {\n    rads += PI * 0.5;\n    float percent = fract(rads/PI);\t\t\t\t\n    float dir = sign(sin(rads));\n    return dir * (2. * percent  - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\t\t\t\t\t\t\t\t\t\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float amp = 0.06;\n    float freq = 25.;\n    float numLines = 70. + 25. * sin(time);\n    float sawWaveDisp = saw(uv.x * freq);\n    float sinWaveDisp = sin(uv.x * freq);\n    uv.y += amp * mix(sawWaveDisp, sinWaveDisp, 0.5 + 0.5 * sin(time));\n    float col = 0.5 + 0.5 * sin(uv.y * numLines);\n    float aA = 1./(iResolution.y * 0.01) ;\n    col = smoothstep(0.5 - aA, 0.5 + aA, col);\n\tfragColor = vec4(vec3(col),1.0);\n}\n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sjBzK", "name": "Hopf Fibration", "author": "starea", "description": "Forked from zeletochoy's https://www.shadertoy.com/view/lstGRS. Hopf fibers with iq's better color scheme https://www.shadertoy.com/view/ll2GD3.\nmouse.x corresponds to ", "tags": ["4d", "hypersphere", "hopf", "fibration"], "likes": 3, "viewed": 543, "date": "1501170735", "time_retrieved": "2024-06-20T18:57:43.431732", "image_code": "// Hopf Fibration\n// https://en.wikipedia.org/wiki/Hopf_fibration\n// https://www.shadertoy.com/view/4sjBzK\n#define PI 3.141592653589793\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 fiber_at(vec3 pt, float ph)\n{\n  float th = atan(-pt.x, pt.y) - ph;\n  float al = sqrt((1.0 + pt.z) / 2.0);\n  float be = sqrt((1.0 - pt.z) / 2.0);\n  float w = al * cos(th);\n  float x = -be * cos(ph);\n  float y = -be * sin(ph);\n  float z = al * sin(th);\n  float r = acos(w) / PI;\n  float f = r / (1.0 - w * w);\n  return f * vec3(x, y, z);\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 opTurn(vec3 p, vec3 rot)\n{\n  float a = -rot.x, b = -rot.y, c = -rot.z;\n  float ca = cos(a), cb = cos(b), cc = cos(c);\n  float sa = sin(a), sb = sin(b), sc = sin(c);\n  mat3 m = mat3(ca*cb*cc-sa*sc, -ca*cb*sc-sa*cc, ca*sb,\n                sa*cb*cc+ca*sc, -sa*cb*sc+ca*cc, sa*sb,\n                -sb*cc,         sb*sc,           cb);\n  return m * p;\n}\n\nvec3 calc_rot(vec3 norm)\n{\n  float x = atan(norm.y, norm.z);\n  float y = atan(norm.x, norm.y);\n  float z = atan(norm.y, norm.x);\n  return vec3(x, y, z);\n}\n\nfloat fiber(vec3 p, vec3 pt)\n{\n  vec3 a = fiber_at(pt, 0.0);\n  vec3 b = fiber_at(pt, PI);\n  vec3 c = fiber_at(pt, 0.5 * PI);\n  vec3 center = (a + b) / 2.0;\n  vec3 norm = normalize(cross(c - center, b - center));\n  norm = normalize(cross(b - center, norm));\n  vec3 rot = calc_rot(norm);\n  vec2 torus_params = vec2(1.0, 0.01);\n  return sdTorus(opTurn(p, rot) + center, torus_params);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{       \n  float len = length(p);\n  p = normalize(p);\n\n  float delta = PI / 8.;\n\n  vec3 pol = vec3(fract(len),\n                  mod(atan(p.y, p.x), delta) - delta / 2.,\n                  atan(p.z, length(p.xy)));\n\n  return vec3(pol.x * cos(pol.y)* cos(pol.z),\n              pol.x * sin(pol.y) * cos(pol.z),\n              pol.x * sin(pol.z));\n}\n\nfloat equator_fibers(vec3 p)\n{\n  float d = 9999999999999.0;\n  for (float th = 0.1; th < 2.0 * PI; th += PI / 32.0)\n    d = min(d, fiber(p, normalize(vec3(cos(th), sin(th), 2.0 * iMouse.x / iResolution.x))));\n  return d;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n  return vec2(equator_fibers(pos), 1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  float precis = 0.002;\n  float t = tmin;\n  float m = -1.0;\n  int count = 0;\n  for(int i=0; i < 50; i++)\n  {\n    count++;\n    vec2 res = map( ro+rd*t );\n    if( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n  if( t>tmax ) m=-1.0;\n  return vec2( t, count);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for( int i=0; i<16; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n                  map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n                  map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n  return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  vec3 col = pal( 0.0, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n  vec2 res = castRay(ro,rd);\n  float t = res.x;\n  float m = res.y;\n  if( m>-0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    //col = pal( 0.5 * log(m), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    col = pal( 0.3 * log(m), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n      //col = 0.35 + 0.3 * cos(vec3(0.05,0.08,0.10) * 42. * log(m));\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    //col = mix( col, vec3(1.0, 0.0, 0.0), 1.0-exp( -0.0005*t*t ) );\n  }\n\n  return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n\n  float time = iTime;\n\n  // camera     \n  vec3 ro = 3.0 * vec3(cos(time), 0.5, sin(time));\n  vec3 ta = vec3(0.);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy,2.0));\n\n  // render   \n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(pow(col, vec3(0.4545)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sjfDD", "name": "Diffeomorphisms of the disk", "author": "etale_cohomology", "description": "Fork of Fabrice's https://www.shadertoy.com/view/ltdXR8", "tags": ["2d", "simple", "math", "tutorial", "topology", "diffeomorphism", "fabrice"], "likes": 5, "viewed": 218, "date": "1500485644", "time_retrieved": "2024-06-20T18:57:43.431732", "image_code": "// Fork of Fabrice's https://www.shadertoy.com/view/ltdXR8\n\n// I'm pretty sure this is a family of diffeomorphisms of the disk,\n// which reminds me a lot of Wikipedia's diffeomorphism of the square:\n// https://en.wikipedia.org/wiki/Diffeomorphism\n// https://en.wikipedia.org/wiki/File:Diffeomorphism_of_a_square.svg\n\n#define TWIST 4.\n#define STRIPES 70.\n#define STRIPE_THINNESS .7\n\nvoid mainImage(out vec4 fragColor, in vec2 uv){\n    uv = (2.*uv - iResolution.xy) / iResolution.y;\n\n    float radius = distance(uv, vec2(0));\n    float angle = atan(uv.y, uv.x);\n\n    float radius_complement = clamp(1. - radius, .0, 1.);  // This seems to have all the magic...\n    float twisting = sin(angle + TWIST * pow(radius_complement, 2.) * sin(iTime));  // This adds all the twisting!\n\tfloat rgb = radius * twisting;\n    rgb = STRIPE_THINNESS + sin(rgb * STRIPES);  // Try to comment this out!\n    rgb /= fwidth(rgb);  // Some AA!\n\n    fragColor.rgb = vec3(rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4slfDs", "name": "Cereals jumping on milk", "author": "onclipse", "description": "Simular unos cereales saltando sobre leche. Trabajo de shaders para la prctica 3 de PGATR.\nSe ha implementado mediante ray-marching. Ms informacin en el pdf.\nClaudia Ochagavas\n", "tags": ["raymarching", "torus", "fog", "plane"], "likes": 0, "viewed": 81, "date": "1498860490", "time_retrieved": "2024-06-20T18:57:43.431732", "image_code": "/*\nCEREALS JUMPING ON MILK\n*/\n/*Trabajo para la prctica 3 de PGATR - Claudia Ochagavas\n//Creado utilizando ray marching\n*/\n\n//Constantes que sern utilizadas durante el shader\n#define DISTANCIA_BIAS 0.7\n#define EPSILON 0.015\n#define NUMERO_PASOS 50\n#define PLANO_CERCA 0.5\n#define PLANO_LEJOS 60.0\n\n//Creacin de plano ondulado. Se mueve con el tiempo\nfloat planoOndulado(const in vec3 vPos) {\n\tfloat f1 = 0.2 + sin(vPos.x + iTime) * 0.15 - 1.0;\n\tfloat f2 = vPos.y;\n\t//return (f2 < f1) ? f1 - f2 : f2 - f1;\n    return f2 - f1;\n        \n}\n//Funcin creacin de un plano\nfloat sdPlane( vec3 p, vec4 n )\n{\n  //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n  // n est normalizado\n  return dot(p,n.xyz) + n.w;\n}\n\n//Funcin para crear esfera. p: posicin global del rayo. s: radio de esfera\nfloat crearEsfera (vec3 p, float s){\n    //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    //return length(p)-s;\n    float dis = length(p)-s;\n\n   // return dis + sin(iTime)*0.08;\n     return dis + sin(iTime)*0.08;\n}\n\n//Funcin crear torus\nfloat crearTorus( vec3 p, vec2 t ){\n    //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat fmod(float a, float b){\n    if(a < 0.0){\n        return b - mod(abs(a), b);\n    }\n    return mod(a,b);\n}\n\n//Escena: Se genera una distancia a la posicin dada\nvec2 escena(vec3 position)\n{\n    //Trasladamos el plano\n    vec3 trasladar = vec3(0.0, 1.1, 1.0);\n    //float distancia = crearEsfera(position - trasladar, 0.5);\n    //Creamos el plano a partir de las distancias\n    //float distancia = sdPlane(position - trasladar, vec4(0.0,1.0,0.0,1.0));\n    float distancia = planoOndulado(position - trasladar);\n    \n    //Asignamos el identificador del material\n    float materialId = 1.0;\n    trasladar = vec3(0.0, +0.65, 1.0);\n\n    //Vamos a crear los cereales, haciendo un tiling de torus. Para ello, modificaremos la posicin\n    //del plano, y tilearemos en X.\n    vec3 posicion_plano = position - trasladar;\n    \n    //Hacemos un offset en 0.5, tileamos, y volvemos a -0.5 para ponerlo en la posicin original\n    posicion_plano.x = fract(posicion_plano.x + 0.5) - 0.5;\n    posicion_plano.z = fmod(posicion_plano.z + 1.0, 2.0) - 1.0;\n    \n    //Vamos a animar el movimiento de los cereales a partir de seno y el coseno,\n    //modificando la altura\n    posicion_plano.y += sin(position.x + iTime*2.5) * 0.85;\n    posicion_plano.y += cos(position.z + iTime*3.5) * 0.9;\n    float distancia2 = crearTorus(posicion_plano, vec2(0.15,0.065));\n    //Identificador del material de los cereales\n    float materialId2 = 2.0;\n    \n    //Combinamos las distancias de los dos objetos\n    if(distancia2 < distancia){\n        distancia = distancia2;\n        materialId = materialId2;\n    }\n    \n    //Devolvemos un vec2 con la distancia y el material final\n    return vec2 (distancia, materialId);  \n}\n\n\n//Funcin raymarching\nvec2 raymarching(vec3 position, vec3 direction){\n\n    //Cmo de lejos nos hemos movido\n    float total_distancia = PLANO_CERCA;\n    for(int i=0; i < NUMERO_PASOS ; i++){\n    \tvec2 result = escena(position + direction * total_distancia);\n        \n        //Si estamos muy cerca a la superficie (epsilon) asumimos que la golpeamos\n        if(result.x < EPSILON){\n        \treturn vec2(total_distancia, result.y);\n        }\n    \n        //Utilizamos distancia_bias para corregir imprecisiones\n        total_distancia += result.x * DISTANCIA_BIAS;\n        \n        //Paramos si nos vamos demasiado lejos\n        if(total_distancia > PLANO_LEJOS){\n            break;\n        }\n    \n    }\n\n    //Si no nos hemos acercado a ninguna superficie, devolvemos distancia de plano_lejos\n    //y ningn material\n    return vec2(PLANO_LEJOS, 0.0);\n}\n\n//Clculo vector normal\nvec3 normal(vec3 rayo_posicion, float smoothness){\n\n    vec3 n;\n    vec2 dn =  vec2(smoothness, 0.0);\n    n.x\t= escena(rayo_posicion + dn.xyy).x - escena(rayo_posicion - dn.xyy).x;\n\tn.y\t= escena(rayo_posicion + dn.yxy).x - escena(rayo_posicion - dn.yxy).x;\n\tn.z\t= escena(rayo_posicion + dn.yyx).x - escena(rayo_posicion - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Coordenadas en espacio UV 0-1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n//\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    //Movemos la coordenada 0,0 al centro. Por lo tanto tenemos de -1,-1 a 1,1\n    uv = uv * 2.0 - 1.0;\n    \n    //El aspect ratio de la ventana. Adaptamos la coordenada x\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Creamos la posicin de la cmara y la direccin\n    vec3 camara_pos = vec3(0.0, 1.4, -5.0);\n    vec3 direction = normalize(vec3(uv, 2.5));\n\n    //Llamamos a la funcin de raymarching\n    vec2 result = raymarching (camara_pos, direction);\n                               \n    //Colores de los cereales y el plano\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n        vec3 color;\n        color = vec3(1.2,1.65,2.0);\n        materialColor = color;\n    }\n    if(result.y == 2.0)\n    {\n        //Los cereales van cambiando de color con el tiempo\n       \tmaterialColor = vec3(uv,0.7+0.8*sin(iTime) + 0.4);\n    }                           \n    \n    //Punto de interseccin y normal\n    vec3 interseccion = camara_pos + direction * result.x;\n    vec3 normalf = normal(interseccion, 0.01);\n      \n    //Luz direccional y difusa\n    vec3 luz_dir = normalize(vec3(1.0, 1.0, 0.0));\n   \tfloat difusa = dot(luz_dir, normalf);                           \n    //Luz alrededor\n    difusa = difusa * 0.7 + 0.5;                           \n    //Combinamos luz ambiental e iluminacin difusa por luz direccional\n    vec3 color_ambiental = vec3(0.2, 0.45, 0.7);\n    vec3 color_luz = vec3(1.3, 1.1, 0.6);\n    vec3 difusaL = materialColor * (difusa * color_luz + color_ambiental);                          \n    \n        \n    //Aadimos niebla para que el fondo se vaya viendo cada vez menos\n    float niebla = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    //Color final\n    fragColor = vec4(difusaL, 1.0) * niebla;                           \n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slfDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sSBRy", "name": "Infinite Pinwheel Snakes", "author": "ttoinou", "description": "Yeaaaah", "tags": ["zoom", "snakes", "infinite", "pinwheel"], "likes": 15, "viewed": 310, "date": "1500836417", "time_retrieved": "2024-06-20T18:57:43.437810", "image_code": "#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cnorm( vec2 z )  { return z/length(z); }\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n    return (uv - iResolution.xy/2.0 ) / iResolution.x * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n    \n    float r;\n    float ID;\n    float ID2;\n};\n\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C; \\\n    T.ID = Q.ID; \\\n    T.ID2 = Q.ID2; \\\n    T.r = Q.r; \n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(X,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(X,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(X,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(X,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nPinwheel Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindTriangle(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        return false;\n    }\n    \n    return true;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    //uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat qLimit;\n\n\n\nvec3 colorTriangle(vec2 uv_s,Pinwheel Tri,int i)\n{\n    \n    vec3 col = hash3point(vec2(\n        // coloring algorithm\n        Tri.ID+cos(Tri.ID2),sin(Tri.ID*3.)-Tri.ID2\n    ));\n    \n    //col = vec3(1.);\n    \n    //vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    /*if( i < -1 )\n    {\n        col *= .0;\n        return col;\n    }*/\n    \n    col *= 2./(1. + dot(uv_s,uv_s)/1e3 );\n    \n    float iterK = pow(5.,-float(i+1)/2.);\n    float k = float(Tri.ID2)*iterK*iterK;\n    float k2 = (\n            cos( (k - iTime*.1*(mod(Tri.ID,2.)*2.-1.) )*PI*5. )\n        );\n    col.rgb = col.gbr *\n        smoothstep( 1. , 0. , tanh(abs(k2*3.)+.4) )\n        * ( cos(\n             (k - + Tri.ID2*iterK ) * vec3(7.,5.,3.) - iTime\n           )*.5+.5 );\n    //col.rgb *= 1. - step( abs(k) , 1. ) * (cos(k*vec3(7.,5.,3.)*3.)*.5+.5)*(1. - k*k);\n    \n    return col;\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindTriangle(r+1.,uv_s) )\n    {\n        // inside circle\n        FindTriangle(r,uv_s);\n    }\n    \n    \n    \n\tint nbIterations = 8;\n    \n    Pinwheel Tri_TMP;\n    Tri.ID2 = 0.;\n    \n    bool direction = false;\n    #define ID_DIRECTION(x) (direction ? 4.-x : x)\n      \n    EQUERRE_COPY(Tri_TMP,Tri);\n    float q;\n    qLimit = .03;\n    //qLimit = ( 1. / mix( 1. , 1./.14  , iMouse.x/iResolution.x ) )/5.*viewportMagnify;\n    \n    int i = 0;\n    for(; i < nbIterations ; i++)\n    {\n        Tri_TMP.ID2 *= 5.;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv_s,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(0.);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(1.);\n                direction = !direction;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv_s,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(2.);\n                direction = !direction;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(3.);\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            Tri_TMP.ID2 += ID_DIRECTION(4.);\n        }\n        \n        q = length(Tri_TMP.B - Tri_TMP.A)/qLimit;\n        if( q < 1. )\n        {\n            break;\n        }\n        else\n        {\n        \tEQUERRE_COPY(Tri,Tri_TMP);\n        }\n    }\n    \n    \n    q = max( \n        (q-1./sqrt(5.))/(1. - 1./sqrt(5.))\n        // nice effects here\n        //* pow(viewportMagnify/length(uv_s),.75)\n        //* 2.\n    , 0. );\n    \n    vec3 colA = colorTriangle(uv_s,Tri,i-1);\n    vec3 colB = colorTriangle(uv_s,Tri_TMP,i);\n    q = smoothstep(0.,1.,sqrt(q));\n    \n    if( i == 0 )\n    {\n    \t//colA *= q;\n    \t//colB *= q;\n        colA *= .0;\n        colB *= .0;\n    }\n    if( i == 1 )\n    {\n        colA *= .0;\n        //colB *= .0;\n    }\n    \n    return mix( colA, colB, q );\n    \n    //return colorTriangle(uv_s,Tri);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    TriangleAngle = atan(2.); // Pinwheel\n    //TriangleAngle = PI/3.; // Equerre \n    \n    //PI * ( mix( 1./12. ,  1./4. ,  iMouse.x/iResolution.x ) + .333 );\n    \n    angleShift = -iTime*.4;\n    logZoom = 1.3*iTime/sqrt(3.);\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy);\n    uv.x -= .6;\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify = 1.;\n    //uv_s *= viewportMagnify;\n    \n    \n    fragColor.rgb = color(uv_s);\n    fragColor.rgb = tanh(fragColor.rgb * 2e2 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sSBz3", "name": "circle_", "author": "zhaxiu3", "description": "", "tags": ["2d"], "likes": 0, "viewed": 74, "date": "1501383453", "time_retrieved": "2024-06-20T18:57:43.704304", "image_code": "\nvec4 circle(vec2 uv, vec2 center, float radius)\n{\n/*    if(distance(uv, center) > radius)\n    {\n        return vec4(0);\n    }\n    return vec4(1);\n*/\n    //use step to replace if statements \n    return vec4( step ( distance(uv, center), radius )) ;\n}\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle), -sin(angle), \n                sin(angle), cos(angle));\n}\n\nvec4 rotateCircle(vec2 uv, vec2 d, float r)\n{\n    vec2 center1 = d;    \n    center1 = rotate(iTime)*center1 +iResolution.xy*0.5;\n    return circle(uv, center1,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //init fragColor with zero\n    fragColor -= fragColor;\n    vec2 uv = fragCoord.xy;\n    \n    for(int i = -4; i < 5; ++i)\n    {\n        fragColor+= rotateCircle(uv, vec2(0,50.0*float(i)) ,sin(iTime*2.0)*10.0+20.0);\n    }\n    \n    for(int i = -4; i < 5; ++i)\n    {\n        fragColor+= rotateCircle(uv, vec2(50.0*float(i),0) ,sin(iTime*2.0)*10.0+20.0);\n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sSBzy", "name": "[SH17B] Cold Shore", "author": "Xor", "description": "A helicopter ride over some icy mountains (Drag mouse to turn view). It could be improved, but I felt a little rushed.\nThis however does have good performance and a huge view distance.\nHere's my first attempt: https://www.shadertoy.com/view/4d2fWD", "tags": ["3d", "water", "mountains", "xor", "ice", "snow", "sh17b"], "likes": 17, "viewed": 791, "date": "1500932608", "time_retrieved": "2024-06-20T18:57:43.704304", "image_code": "//\"[SH17B] Cold Shore\" by Xor\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FOG 100.\n#define PRE .01\n\n#define SUN normalize(vec3(0,4,1))\n\nfloat height(vec2 P)\n{\n    float H = 8.*texture(iChannel0,P/96.).r+\n              2.*texture(iChannel0,P/25.).r+\n              .1*texture(iChannel0,P/2.).r;\n    return min(H-.1*P.y,5.02+.02*pow(cos(3.*H-3.*P.y+iTime),2.));\n}\n\nvec4 raymarch(vec4 P,vec3 R)\n{\n    P = vec4(P.xyz+R*2.,2);\n    float E = 1.;\n \tfor(int i = 0;i<300;i++)\n    {\n        P += vec4(R,1)*E;\n        float H = height(P.xy);\n        E = clamp(E+(H-P.z)-.5,E,1.);\n        if (H-E*.6<P.z)\n        {\n        \tP -= vec4(R,1)*E;\n            E *= .7;\n            if (E<PRE*P.w/FOG) break;\n        }\n    }\n    return P;\n}\n\nfloat shadow(vec4 P,vec3 R)\n{\n    float S = 0.;\n    P = vec4(P.xyz,0);\n    float E = .5;\n \tfor(int i = 0;i<10;i++)\n    {\n        \n        P += vec4(R,1)*E;\n        float H = height(P.xy);\n        if (H<P.z)\n        {\n            S = min((H-P.z)*9.,S);\n        }\n    }\n    return S;\n}\n\nfloat bump(vec2 P)\n{\n \treturn texture(iChannel1,P*4.).r*texture(iChannel1,P).r*texture(iChannel1,P/4.).r;\n}\n\nvec3 normal(vec2 P)\n{\n    vec2 N = vec2(1,0);\n    N = height(P-N.xy*PRE)*-N.xy+height(P+N.xy*PRE)*N.xy+height(P-N.yx*PRE)*-N.yx+height(P+N.yx*PRE)*N.yx;\n \treturn normalize(vec3(N,-PRE));\n}\n\nvec3 sky(vec3 R)\n{\n    vec3 S = vec3(1,.5,.2)/(dot(R,SUN)*99.+99.5);\n    vec2 P = R.xy/sqrt(max(.1-R.z,.1))*9.;\n    float C = (cos(P.y+cos(P.x*.5+cos(P.y)))*cos(P.y*.7)*.5+.5)*min(abs(.1-6.*R.z),1.);\n \treturn mix(vec3(.4,.7,.9),vec3(1),C*C)+S;\n}\n\nvec3 color(vec4 P,vec3 R)\n{\n    vec3 N = normal(P.xy);\n    vec3 I = reflect(R,N);\n    float F = min(P.w/FOG,1.);\n    float L = exp(shadow(P,-SUN)+dot(N,-SUN)-1.);\n    vec3 S = mix(vec3(.3,.4,.5),vec3(1),L)-bump(P.xy);\n    vec3 C = (P.z<5.)?vec3(.4+.6*smoothstep(-PRE*(5.+50.*F),-PRE*4.,P.z-height(P.xy-PRE*vec2(8,2)))):\n         sky(I)*min(I.z+1.,1.)+max(-I.z,0.)*vec3(.1,.2,.4);\n \treturn mix(C*S,sky(R),F*F);\n}\n\nvoid mainImage(out vec4 Color,in vec2 Coord)\n{    \n    Coord = (Coord-iResolution.xy*.5)/iResolution.y;\n    float A = 3.*(.5-(iMouse.y/iResolution.y))*sign(iMouse.y)+.6-.3*cos(iTime*.3);\n    float B = 3.*(.5-(iMouse.x/iResolution.x))*sign(iMouse.x);\n    vec3 R = normalize(vec3(1,Coord))*mat3(cos(A),0,sin(A),0,1,0,sin(A),0,-cos(A))*mat3(cos(B),sin(B),0,sin(B),-cos(B),0,0,0,1);\n    vec4 P = raymarch(vec4(iTime,cos(iTime*.2),-3.+2.*cos(iTime*.3),0),R);\n    vec4 C = vec4(color(P,R),1);\n    Color = C;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSBzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sSfDz", "name": "Pink Bullet", "author": "Torumu106", "description": "I expressed movement.", "tags": ["shader", "bullet"], "likes": 1, "viewed": 80, "date": "1499998763", "time_retrieved": "2024-06-20T18:57:43.704304", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.0, 0.5, 0.8);\n    vec3 col = vec3(1.0, 0.5, 0.5);\n    float GlobalTime = mod(iTime + floor((r.y - 0.5) * 2.5) * 0.5, 1.6) * 15.0 - 11.5;\n    \n    r *= 5.0;\n    r.y = mod(r.y - 1.0, 2.0) - 1.0;\n    \n    r.y /= 0.5;\n    float i = smoothstep(0.5, max(0.8 - (r.x - GlobalTime) * 0.3 / 0.5, 0.5), length(r - vec2(GlobalTime, 0.0)));\n    ret = col * (1.0 - i) + ret * i;\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXfDf", "name": "s/t/a/r/s", "author": "DJDoomz", "description": "What secret do these stars hold? <.<\nSome fireworks would've made more sense for the 4th of July...", "tags": ["2d", "tiny", "onetweet", "golf"], "likes": 10, "viewed": 501, "date": "1499267771", "time_retrieved": "2024-06-20T18:57:44.007382", "image_code": "//122 version by FabriceNeyret2\n//116 after addition of iTime, is this supported on all versions of oGL?\n//103 with the #define trick\nvoid mainImage(out vec4 f, vec2 u) {\n    vec2 g = u+ vec2( cos((u.y+iTime)/3.) , u.x/9.);\n    f += 2./ length(u-g + 1e2*cos(g+ceil(g)) )\n      -f;}\n\n//original by me (135)\n//void mainImage( out vec4 f, vec2 u)\n//{////////////////////////////////////////////////////////////////////////////\n//*        .           *                  .            *              .     */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#define s(x) u-x+cos(x+ceil(x))*99.\n//**/f //    .       *    .   .  *           .        *    .                */ \n//*    */= // .     *                .        *                      .      */\n//*    */2.//    .       .                               *                  */\n//*    *// //                                    *                          */\n//*    */length//       .            *                                .     */\n//*  . */(//                             .            *         .           */\n//*        */s//      *          .                                          */  \n//*    *   */(//             *                                              */\n//*            */vec2//                          .             *            */\n//*  .    .    */(//                      *                                 */\n//*                */u.x//       .              .                     .     */\n//*            *   */+ //                                    .              */\n//*     .          */cos//  *                                               */\n//*   *            */(//                   .                                */\n//*            *      */(//            *                 *              .   */     \n//*                        */u.y//                                          */   \n//*.       *       .   *   */+ //          .                    *           */    \n//*                        */iTime//                                  */             \n//*            *       */)//                        .         .             */ \n//*   *                *// //  *                                         .  */ \n//*           .        */3.//                                               */\n//*                */)//                  .                  *              */\n//*       .        */,//      .                                             */\n//*                */u.y//                      *                 .         */\n//*  .          .  */+ //                                  .                */\n//*        *       */u.x//      .                                           */\n//*                *// //            *   .                       *          */\n//*  .     *       */9.//                                                   */\n//*            */)//                             .      *              .    */\n//*        */)//      *       *                                             */\n//*    */)//      *             .   *                           .           */\n//**/-f;//    .        .                      .                             */\n//}////////////////////////////////////////////////////////////////////////////\n\n/*\n//a much prettier effect:\nvoid mainImage( out vec4 f, vec2 u)\n{\n    //189\n    //uv = floor(uv/8.)*8.;\n\tfloat t = iTime,y=u.y,x=u.x;\n    f.gb+=1./length(u-vec2(x+cos(x/40.+tan(t+y/35.)+ceil(x/32.))*70.+sin((x+y)/10.+t)*6.,y+cos((y+x)/40.-t+ceil(y/32.))*70.))-f.gb;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXfDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2BDR", "name": "Another brick in the wall - eTnt", "author": "Molive", "description": "based on this: https://scratch.mit.edu/projects/155310387/", "tags": ["2d", "oneline"], "likes": 1, "viewed": 96, "date": "1500116564", "time_retrieved": "2024-06-20T18:57:44.013499", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(mod((((6579300.0 + ((((floor(((mod(fragCoord.y+iTime*10.0,18.0))*256.0)/18.0))*256.0)-6579300.0) * (abs(sign(floor(mod(fragCoord.x+iTime*5.0 + (15.0 * (1.0-(abs(sign(mod(floor((fragCoord.y+iTime*10.0)/18.0),2.0)))))),30.0) / 4.0))) * abs(sign(floor(mod(fragCoord.y-180.0+iTime*10.0,18.0) / 4.0))))))*256.0) / 256.0 / 256.0), 256.0) / 255.0, mod((((6579300.0 + ((((floor(((mod(fragCoord.y+iTime*10.0,18.0))*256.0)/18.0))*256.0)-6579300.0) * (abs(sign(floor(mod(fragCoord.x+iTime*5.0 + (15.0 * (1.0-(abs(sign(mod(floor((fragCoord.y+iTime*10.0)/18.0),2.0)))))),30.0) / 4.0))) * abs(sign(floor(mod(fragCoord.y-180.0+iTime*10.0,18.0) / 4.0))))))*256.0) / 256.0        ), 256.0) / 255.0, mod((((6579300.0 + ((((floor(((mod(fragCoord.y+iTime*10.0,18.0))*256.0)/18.0))*256.0)-6579300.0) * (abs(sign(floor(mod(fragCoord.x+iTime*5.0 + (15.0 * (1.0-(abs(sign(mod(floor((fragCoord.y+iTime*10.0)/18.0),2.0)))))),30.0) / 4.0))) * abs(sign(floor(mod(fragCoord.y-180.0+iTime*10.0,18.0) / 4.0))))))*256.0)                ), 256.0) / 255.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2BRw", "name": "[SH17A] Molten core", "author": "Daedelus", "description": "This is harder than it looks! Weird sines feeding sines pattern, offset & colorized to add a sense of depth.", "tags": ["moltencore"], "likes": 10, "viewed": 231, "date": "1500142244", "time_retrieved": "2024-06-20T18:57:44.013499", "image_code": "void mainImage(out vec4 f,vec2 c)\n{\n    f-=f;\n\tvec2 u=c/iResolution.y*-4.+10.,t=vec2(3,1)*.0003*iTime+9.;\n    float w=.04;\n    for(int i=0;i<20;++i)\n    {\n        u=u*sin(t.x)+cos(t.y)*vec2(-u.y,u.x);\n        u*=1.2+f.xy*.06;\n        w*=.96;\n    \tf+=w*(abs(sin(u.x))+abs(cos(u.y)));\n    }\n    f.x=sin(f.x*4.);\n    f*=f;\n    f*=f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2BWw", "name": "Triangle Infinite Spiral", "author": "ttoinou", "description": "Improved [url]https://www.shadertoy.com/view/Xd2fWw[/url] for any triangle (not just the Equerre one)\n\nGoing through all the angles where it works before it breaks or becomes not beautiful to look at", "tags": ["triangle", "zoom", "spiral", "infinite"], "likes": 8, "viewed": 164, "date": "1500758352", "time_retrieved": "2024-06-20T18:57:45.977382", "image_code": "#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cnorm( vec2 z )  { return z/length(z); }\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    //uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    return col*2./(1. + dot(uv_s,uv_s)/1e3 );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    TriangleAngle = PI * mix(\n        1./3.9 ,\n        1./2.385 , // cannot go lower than this value :-( \n        //iMouse.x/iResolution.x\n        sqrt( -cos(iTime/7.*PI)*.5+.5 )\n    );\n    \n    //TriangleAngle = atan(2.); // Pinwheel\n    //TriangleAngle = PI/3.; // Equerre \n    \n    //PI * ( mix( 1./12. ,  1./4. ,  iMouse.x/iResolution.x ) + .333 );\n    \n    angleShift = -iTime;\n    logZoom = -cos(iTime/sqrt(3.))*6.;\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify = 1.;\n    //uv_s *= viewportMagnify;\n    \n    \n    \n    \n    fragColor.rgb = color(uv_s);\n\n    fragColor.rgb = tanh(fragColor.rgb*1.5  ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2BzV", "name": "3D Metaball Objects", "author": "dhygns", "description": "Metaball example\n", "tags": ["3d", "raymarching", "sphere", "metaball"], "likes": 1, "viewed": 187, "date": "1501315217", "time_retrieved": "2024-06-20T18:57:45.977382", "image_code": "#define STEPDETAIL 0.0125\n\nstruct Cam {\n    vec3 pos;\n    vec3 dir;\n};\n\nvec2 aspectRatio(in vec2 st) {\n    return 2.0 * (st - 0.5) * iResolution.xy / max(iResolution.x, iResolution.y);\n}\n\nfloat sphere(in vec3 pos, float size, in vec3 spc) {\n    vec3 psc = spc - pos;\n    return smoothstep(size, 0.0, length(psc));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = aspectRatio(uv);\n    \n    \n    //Camera Control\n    Cam camera;\n    camera.pos = vec3(0.0, 0.0, -2.0);\t//set position\n    camera.dir = vec3((st) * 1.1, 1.0); //set direction in this pixel coord.\n \n    //camera rotating\n    float radian = iTime * 0.3;\n    mat2 rot = mat2(cos( radian), sin( radian), -sin( radian), cos( radian));\n   \tcamera.pos.xz *= rot;\n    camera.dir.xz *= rot;\n    \n    //transform of shpere (x, y, z, scale)\n    vec4 pos1 = vec4(0.10 * sin(radian * 0.5), 0.60 * sin(radian * 1.3), 0.09 * sin(radian * 3.0), 0.35);    \n    vec4 pos2 = vec4(0.15 * sin(radian * 3.1), 0.30 * sin(radian * 0.2), 0.12 * sin(radian * 2.7), 0.40);\n    vec4 pos3 = vec4(0.25 * sin(radian * 2.7), 0.50 * sin(radian * 3.2), 0.10 * sin(radian * 1.1), 0.16);\n    vec4 pos4 = vec4(0.10 * sin(radian * 2.3), 0.20 * sin(radian * 0.1), 0.15 * sin(radian * 2.1), 0.18);\n\n    \n    \n    //raycasting by depth \n    const float near = 1.625;\n    const float far = 2.125;\n    \n    float e = 0.0;\n    for(float stepf = near; stepf < far; stepf+= STEPDETAIL){\n        vec3 spc = camera.pos + camera.dir * stepf;\n        \n        e += sphere(pos1.xyz, pos1.w, spc); // shepre1\n        e += sphere(pos2.xyz, pos2.w, spc); // shepre2\n        e += sphere(pos3.xyz, pos3.w, spc); // shepre3\n        e += sphere(pos4.xyz, pos4.w, spc); // shepre4\n        if(e > 0.2) {\n            e = 0.2 + 0.8 * (1.0 - (stepf - near) / ( far - near ));\n            break;\n        } else {\n            e = 0.0;\n        }\n        \n        \n\n    }\n \n\tfragColor = vec4(e, e, e, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2fD1", "name": "[SH17A] Crazy 5th dimension eye", "author": "Ruzzyr", "description": "An eye from 5th dimension watches you. A late night fiddle.", "tags": ["simple", "eye", "crazy"], "likes": 1, "viewed": 74, "date": "1500352054", "time_retrieved": "2024-06-20T18:57:45.983420", "image_code": "//#define mainImage( r, fd )\tvec2 u = fd.xy*4./ iResolution.xy -2.; u.x *= 16./9.;float a = sin(iTime), s = sin(a), c = cos(a), d=0.; vec3 e = vec3(-s,0.,-c), o = vec3(u, 1.), p;for (a = 0.; a< 6.; a++){p=e*d+o;d+=length(p*d) - 1.;}a = d*length(u);u.x = c*a,u.y = s*a;r = mix(texture(iChannel0, u), vec4(0.9), d);\nvoid mainImage( out vec4 r, in vec2 fd )\n{\n\tvec2 u = fd.xy*4./ iResolution.xy -2.;\n    u.x *= 16./9.;\n    float a = sin(iTime), s = sin(a), c = cos(a), d=0.;\n    vec3 e = vec3(-s,0.,-c), o = vec3(u, 1.), p;\n    for (a = 0.; a< 3.; a++){p=e*d+o;d+=length(p*d) - 1.;}\n   \ta = d*length(u);\n    u.x = c*a,\n    u.y = s*a;\n    r = mix(texture(iChannel0, u), vec4(0.9), d);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2fD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2fzh", "name": "Alphabet Soup", "author": "KilledByAPixel", "description": "Endless pixel fractal zoom using English alphabet. \nI also made a screensaver version that uses real words at http://pixelwords.3d2k.com", "tags": ["2d", "fractal", "zoom", "alphabet"], "likes": 9, "viewed": 348, "date": "1499563623", "time_retrieved": "2024-06-20T18:57:47.195605", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Alphabet Soup - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.3;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 2.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 26;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// glyph sheet\n 0x01110, 0x11110, 0x01111, 0x11110, 0x11111, 0x11111, 0x01111, 0x11011, 0x11111, 0x01111, 0x11011, 0x11000, 0x01010, 0x11001, 0x01110, 0x11110, 0x01110, 0x11110, 0x01111, 0x11111, 0x11011, 0x11011, 0x10101, 0x10001, 0x10001, 0x11111,\n 0x11011, 0x11011, 0x11100, 0x11011, 0x11000, 0x11000, 0x11000, 0x11011, 0x01110, 0x00110, 0x11110, 0x11000, 0x11111, 0x11101, 0x11011, 0x11011, 0x11011, 0x11011, 0x11100, 0x01110, 0x11011, 0x11011, 0x10101, 0x11011, 0x11011, 0x00111,\n 0x11111, 0x11111, 0x11000, 0x11011, 0x11110, 0x11110, 0x11011, 0x11111, 0x01110, 0x10110, 0x11100, 0x11000, 0x11111, 0x11111, 0x11011, 0x11110, 0x11011, 0x11110, 0x11111, 0x01110, 0x11011, 0x11011, 0x11111, 0x01110, 0x01110, 0x01110,\n 0x11011, 0x11011, 0x11100, 0x11011, 0x11000, 0x11000, 0x11011, 0x11011, 0x01110, 0x11110, 0x11110, 0x11000, 0x10101, 0x10111, 0x11011, 0x11000, 0x11010, 0x11111, 0x00111, 0x01110, 0x11111, 0x01110, 0x11111, 0x11011, 0x01110, 0x11100,\n 0x11011, 0x11110, 0x01111, 0x11110, 0x11111, 0x11000, 0x01111, 0x11011, 0x11111, 0x01100, 0x11011, 0x11111, 0x10101, 0x10011, 0x01110, 0x11000, 0x01101, 0x11011, 0x11110, 0x01110, 0x01110, 0x00100, 0x01010, 0x10001, 0x01110, 0x11111\n);// A        B        C        D        E        F        G        H        I        J        K        L        M        N        O        P        Q        R        S        T        U        V        W        X        Y        Z\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 8;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3\n    (\n    \tmix(-0.02, 0.02, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n   \t\tmix(0.0, 1.0, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n      \t1.0\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color.x += myColor.x*f;;\n        color.y = max(color.y, myColor.y*f);\n    color.z = max(color.z, myColor.z*pow(f, 1.3));\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += (0.05*uv.y + 0.05*uv.x + 0.05*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.01*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.01*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.1*sin(2.0*uv.y + 1.0*iTime);\n\tuv.y += 0.1*sin(2.0*uv.x + 0.8*iTime);\n    \n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 0;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }\n\n    // find a random valid pixel in glyph\n    c -= RandInt(iterations) % c;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x, glyphSize - 1 - y/glyphCount);\n        }\n    }\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2fzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBDh", "name": "[SH17A] crowded gyros", "author": "FabriceNeyret2", "description": "to be seen in fullscreen.\n\nultra simplification of [url]https://www.shadertoy.com/view/XtlXRB[/url]\nwhich was compact simplified version of [url]https://www.shadertoy.com/view/MllXz7[/url]", "tags": ["3d", "raymarching", "2tweets", "short", "spheremarching", "golf"], "likes": 2, "viewed": 449, "date": "1500220576", "time_retrieved": "2024-06-20T18:57:47.480529", "image_code": "// new simplification of https://www.shadertoy.com/view/XtlXRB\n// compact simplified version of https://www.shadertoy.com/view/MllXz7 (773 chars)\n// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\nvoid mainImage(out vec4 f, vec2 w) { vec3 d,p=vec3(w/1e3,0)-.5,t,a;p.x-=.4;d=p;float j,x=iTime;f+=1.-f;p.z+=5.*x;while(f.x>0. && x>.01){t=mod(p,8.)-4.;for(j=3.;j>.8;j-=.4)t.zy*=mat2(sin(iTime+.79*vec4(2,0,4,2))),a=abs(t),x=min(x,max(max(a.x,max(a.y,a.z))-j*.8,abs(length(t)-j)));p-=d*x;f-=.01;}; }\n\n\n\n\n\n/**  // expended version, + commented enrichments\n\n// #define r(t) *= mat2(sin(t*iTime+1.57*vec4(1,0,2,1))) , // rotation\n\nvoid mainImage( out vec4 f, vec2 w ) \n{\n    vec3 // p = vec3(w/iResolution.y,0)-.5, \n         p = vec3(w/1e3,0)-.5, \n         d,t,a;    // ,u;\n    p.x-=.4; \n    //p.xz r(.13)   p.yz r(.2)                      // rotate camera\n    d = p;  \n    float j, x=iTime; f +=1.-f;\n    p.z += 5.*x;\n // float i=1e2, j, x=i; while ( --i>0.\n    while ( f.x>0. && x>.01 ) {                     // tracing rays\n\n     // u = sin(9.+ceil(p/8.));                     // current cell id (used as seed)\n        t = mod(p,8.)-4.;                           // local coords to def shapes in cell\n\n       // x=1e9;\n        for ( j=3.; j>.8; j-= .4)                   // oignon layers\n         // t.xy r(u.x)  t.xz r(u.y)                // rotate balls\n         // t.zy  *= mat2(sin(u.x*iTime+.79*vec4(2,0,4,2))),   // 45, + 21+2 for u=seed\n            t.zy  *= mat2(sin(iTime+.79*vec4(2,0,4,2))),       // 41, u no longer needed\n            a = abs(t),                                        // 9+2 chars\n            x = min(x, max( max(a.x,max(a.y,a.z))-j*.8,// cube\n                            abs(length(t)-j)           // minus sphere\n                   )      );             \n \n        p -= d*x;                                   // step through free space\n        f -= .01;\n    }\n\n // f += i*i/8e3 -f;                                // light at surface hit\n //   f += i/95. -f;                                  \n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBDm", "name": "[SH17B] Boaty Goes Caving", "author": "Dave_Hoskins", "description": "Boaty McBoatface2omBAJ0AN00 is taking a cave diving detour from his usual duties!! :)\nMouse X scrubs time.\n\nLaunch...\n[url]https://www.youtube.com/watch?v=CjyrruHrC60[/url]\n\n\nMy usual anti-aliasing stack rendering is now WebGL 2 only.", "tags": ["3d", "raymarch", "sea", "water", "caustics", "sh17b", "boaty"], "likes": 84, "viewed": 7698, "date": "1500908002", "time_retrieved": "2024-06-20T18:57:50.274555", "image_code": "//[SH17B] Boaty Goes Caving\n// The unsolicited travels of Boaty McBoatface..\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Information on Boaty McBoatface https://youtu.be/2omBAJ0AN00\n// I don't think it actually has a head-light, but what the hell...\n\n// The objects are rendered by tracing through the scene scraping off any geometry that gets within an expanding limit\n// This provides a form of anti-alising and makes a nice fuzzy distance focus.\n\n// The ocean has 4 layers, a blotchy background effect, floating detritus, water caustic light, and a god-ray effect.\n// Other features are a movable spot-light & scattering, a blurry propellor and a very cool sound track found on SoundCloud that I've bought.\n\n#define FLOATY_BITS\n\nstruct March\n{\n    vec3 pos;\n    float alpha;\n    float dist;\n};\n\n#define STACK_SIZE 8\nMarch stack[STACK_SIZE];\n\nint spointer;\nfloat gTime, focus, specular, floatyBits, scatter;\nvec3 diver, sunLight, headLight, heading;\nmat3 diverMat;\n\n#define TAU 6.28318530718\n#define SUN_COLOUR vec3(.9, 1.2, 1.2)\n#define FOG_COLOUR vec3(.0, .16, .13)\n\n//========================================================================\n// Utilities...\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define F length(.5-fract(k.xyw*=mat3(-2,-1,2, 3,-2,1, 1,2,2)*\n\nfloat getCaustic(vec2 p)\n{\n    vec4 k = vec4(gTime*.005);\n    k.xy = p/8e1;\n    \n    return pow(min(min(F.5)),F.4))),F.3))),8.)*40.;\n}\n    \n\n// Thanks to iq for all the shape stuff...\n\n//----------------------------------------------------------------------------------------\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xy), p.z );\n    float d1 = -q.x-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n//----------------------------------------------------------------------------------------\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat rBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n//----------------------------------------------------------------------------------------\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//--------------------------------------------------------------------------\nvec3 texCube(in sampler2D tex, in vec3 p, in vec3 n )\n{\n  \n\tvec3 x = textureLod(tex, p.yz, 0.0).xyz;\n\tvec3 y = textureLod(tex, p.zx, 0.0).xyz;\n\tvec3 z = textureLod(tex, p.xy, 0.0).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(1e-20+abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//----------------------------------------------------------------------------------------\nvec2 rot2D(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n//----------------------------------------------------------------------------------------\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n//----------------------------------------------------------------------------------------\n// Thanks to Nimitz for the triangular noise stuff...\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\nfloat noise3d(in vec3 p, in int si)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (int i=0; i<= si; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 1.8;\n\t\tz *= 1.4;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.2;\n\t}\n\treturn rz;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n//----------------------------------------------------------------------------------------\nfloat sMax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n//========================================================================================\n\nfloat sphereRadius(float t)\n{\n\tt = abs(t-focus);\n\tt *= 0.02;\n\treturn clamp(t*t, 20.0/iResolution.y, 2000.0/iResolution.y);\n}\n\n//--------------------------------------------------------------------------\nvec2 cameraPath( float t )\n{\n    vec2 p = vec2(120.0 * sin(.01*t), 20.+ cos(.0071*t) * 80.0+sin(0.003*t)*80.0 );\n\treturn p;\n} \n\n//--------------------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//--------------------------------------------------------------------------\nfloat diverMap(vec3 p)\n{\n\tvec3 fin = p, fin2 = p;\n    \n    vec3 b = diverMat * (diver - p);\n    float d = segment(b, vec3(.0, 0, 0), vec3(0,0,-4), 1.5, 1.3); \n    d = sMin(d, cylinder(b+vec3(0,0,0), vec2(.5,2)), 3.1); \n    d = min(d, rBox(b+vec3(0,0,1), vec3(3.0, .0, .5), .001));\n\n   \n    fin = diverMat * (diver - fin);\n    fin.xy = rot2D(fin.xy, .5);\n    //fin.x = abs(fin.x);     \n   \tfin += vec3(1.,0,3.5);\n    \n    d = min(d, rBox(fin, vec3(1.0, .02, .2), .01));\n    \n    fin2 = diverMat * (diver - fin2);\n    fin2.xy = rot2D(fin2.xy, -.5);\n    fin2 += vec3(-1.,0,3.5);\n\n   \td = min(d, rBox(fin2, vec3(1.0, .01, .2), .001));\n    \n    fin  = diverMat * (diver - p);\n    d = min(d, rBox(fin+vec3(0,1,3.5), vec3(.01, 1.0, .2), .001));\n    \n    \n    fin = diverMat * (diver - p);\n    fin.xy = rot2D(fin.xy, -abs(length(fin)*4.)+gTime*.8);\n    fin += vec3(0.,0,4.);\n    d = min(d, rBox(fin, vec3(.6, .15, .01), .01));\n\t\n\treturn d;\n}\n\nvoid diverCol(vec3 p, in float di, inout vec3 alb)\n{\n   \tvec3 fin = p, fin2 = p;\n    \n    vec3 b = diverMat * (diver - p);\n    float d = segment(b, vec3(.0, 0, 0), vec3(0,0,-3.5), 1.5, 1.2); \n    \n    d = sMin(di, cylinder(b+vec3(0,0,0), vec2(.5,2)), 3.1);\n\n\n    if (d  < 2.5)\n    {\n        alb = vec3(.8,.8,0);\n        specular  = 1.0;\n    }\n\n    \n    \n    d = min(d, rBox(b+vec3(0,0,1), vec3(3.0, .0, .5), .001));\n    if (d < 0.1) alb = vec3(1,1,1);\n   \n    fin = diverMat * (diver - fin);\n    fin.xy = rot2D(fin.xy, .5);\n    //fin.x = abs(fin.x);     \n   \tfin += vec3(1.,0,3.5);\n    \n    d = min(d, rBox(fin, vec3(1.0, .02, .2), .01));\n    \n    fin2 = diverMat * (diver - fin2);\n    fin2.xy = rot2D(fin2.xy, -.5);\n    fin2 += vec3(-1.,0,3.5);\n\n   \td = min(d, rBox(fin2, vec3(1.0, .01, .2), .001));\n    \n    fin  = diverMat * (diver - p);\n    d = min(d, rBox(fin+vec3(0,1,3.5), vec3(.01, 1.0, .1), .001));\n       \n    fin = diverMat * (diver - p);\n   fin.xy = rot2D(fin.xy, -abs(length(fin)*4.)+gTime*.8);\n    fin += vec3(0.,0,4.);\n\td = min(d, rBox(fin, vec3(.6, .15, .01), .01));\n    if (d < .2)\n    {\n        alb = vec3(1,1,1);\n        specular  = 1.0;\n    }\n\t\n}\n\n//--------------------------------------------------------------------------\nfloat map( in vec3 p, const in int detail )\n{\n    vec3 q = p * 0.0007;\n    //q.y*= 2.;\n    float d = noise3d(q, detail)*370.;\n    d = p.y-d+20.;\n\n    q = p;\n    q.xy -= cameraPath(q.z);\n    q.y*=2.;  \n    d = sMax(d, (10.-length(q.xy)), 400.);\n    d = min(diverMap(p), d);\n    if (detail <8 )\n    {\n        vec3 light= (diverMat*(p-diver));\n        light.xz = rot2D(light.xz, sin(gTime*.03)*1.1);\n\n        float s = sdCone( light, vec3(8,8,10))/length(light*light);\n        scatter += max(-s, 0.0);\n    }\n    return d;\n}\n\n//--------------------------------------------------------------------------\nfloat rays(vec2 uv, vec3 dir)\n{\n    float bri = 0.0;\n    uv.x*= 1.0+dir.y*.5;\n    uv.x += dir.x*.1;\n\n    bri += getCaustic(uv * vec2(40., 0.1))*.2;\n    bri -= pow(abs(1.0-uv.y)*.5,16.0);\n    bri  = clamp(bri,0.0,1.0);\n    \n    return bri;\n}\n//--------------------------------------------------------------------------\nvec3 getOcean(vec3 dir, vec2 uv, vec3 pos)\n{\n    vec3 col;\n    vec3 clou = dir * 2. + pos*.01+iTime*.2;\n\tfloat t = noise(dir);\n    t += noise(clou * 2.1) * .5;\n    t += noise(clou * 4.3) * .25;\n    t += noise(clou * 7.9) * .125;\n\tcol = FOG_COLOUR + vec3(.04,.08,.1) *t;\n    col+= pow(max(dot(sunLight, dir), 0.0)*.8, 4.0);\n    return col;\n}\n\nfloat cloudy(in vec3 pos)\n{\n    pos = pos*.01 - gTime*.005;\n    float t = noise(pos) * .5;\n    t += noise(pos * 2.) * .25;\n    t += noise(pos * 4.) * .125;\n    t =  pow(max(t-.5, 0.), 4.0)*40.;\n    return t;\n}\n\n//--------------------------------------------------------------------------\nvec3 getNormal(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 9) - map(p-vec3(e,0.0,0.0), 9),\n                            map(p+vec3(0.0,e,0.0), 9) - map(p-vec3(0.0,e,0.0), 9),\n                            map(p+vec3(0.0,0.0,e), 9) - map(p-vec3(0.0,0.0,e), 9) ) );\n}\n\n//--------------------------------------------------------------------------\n//Fill the stack by marching through the scene...\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = hash12(co)*3.;\n\tvec4 normal = vec4(0.0);\n\tvec3 p;\n    float alphaAcc = 0.0;\n\n    spointer = 0;\n\tfor( int j=0; j < 100; j++ )\n\t{\n        // Check if it's full or too far...\n\t\tif (spointer == STACK_SIZE || t > 800.0 || alphaAcc >= 1.) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = sphereRadius(t);\n\t\tfloat h = map(p, 4);\n\t\tif( h < sphereR)\n\t\t{\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);\n\t\t\tstack[spointer].pos = p;\n            stack[spointer].alpha = alpha;\n            stack[spointer].dist = t;\n            alphaAcc += alpha;\n\t        spointer++;\n        }\n\t\tt +=  h*.45 + t*.004;\n\t}\n    return alphaAcc;\n}\t\n\n//--------------------------------------------------------------------------\n// Grab the colour...\nvec3 albedo(vec3 pos, vec3 nor)\n{\n    specular  = .0;\n    vec3 alb  = texCube(iChannel0, pos*.0005, nor);\n    vec3 alb2 = texCube(iChannel2, pos*.005, nor);\n    \n    alb = mix(alb2, alb,  smoothstep(-150., 70.0, pos.y));\n    alb=alb*alb*1.2;\n    \n    diverCol(pos, 200.0, alb);\n\n    return alb;\n}\n\n//--------------------------------------------------------------------------\nfloat shadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    \n    float t = .0;\n    for( int i = 0; i < 12; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, 2);\n        res = min( res, 3.*h/t );\n        t += h*1.5+.2;\n    }\n    return clamp( res, 0., 1.0 );\n}\n\n// Set up a camera matrix\n//--------------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nconst int   STAR_VOXEL_STEPS = 8;\nconst float STAR_VOXEL_STEP_SIZE = 3.;\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\nvec3 getDotColour(float t)\n{\n\treturn vec3(t*.3,t*.6,t*.5);\n}\n\n// This code is the starfield stuff from iapafoto\n// https://www.shadertoy.com/view/Xl2BRR\nvec4 detritus(in vec3 ro, in vec3 rd, in float tmax) { \n \n    float d =  0.;\n    \n    vec3 ros = ro + rd*d;\n    ros /= STAR_VOXEL_STEP_SIZE;\n\tvec3 pos = floor(ros),\n\t     mm, ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\t\n    float dint;\n\tvec3 offset, id;\n    vec4 col = vec4(0);\n    vec4 sum = vec4(0);\n    \n    \n\tfor( int i=0; i<STAR_VOXEL_STEPS; i++ ) {\n\n        id = hash33(pos);\n        float size  = hash11(float(i))*.03+.01;\n        offset = clamp(id+.1*cos(id+(id.x)*iTime),size, 1.-size);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint > 0. && dint*STAR_VOXEL_STEP_SIZE<tmax)\n        {\n            //col.rgb = \n            col = (vec4(getDotColour(id.x), .6)*(smoothstep(size, 0.0,d)));\n            col.a *= smoothstep(float(STAR_VOXEL_STEPS),0.,dint);\n            col.rgb *= col.a/dint;   \n            sum += (1.-sum.a)*col;\n            if (sum.a>.99) break;\n        }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum*.75;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 lighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+normal*(.05+(1.0-specular)*10.),  sunLight);\n    // Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0))*sh;\n    col +=  getCaustic(pos.xz*1.1+gTime*.02)*max(normal.y, 0.)*sh*.3*SUN_COLOUR;\n    \n    col += mat * max(dot(headLight,normal), 0.0) * smoothstep(.7, .9, dot(heading, headLight))*1.6;\n    // Ambient...\n\tcol += mat  * abs(normal.y*.07);\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 8.0)  * SUN_COLOUR * sh * specular;\n\n\treturn min(col, 1.0);\n}\n\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunLight  = normalize( vec3(  0.5, 0.8,  0.3 ) );\n    specular = 0.0;\n\tfloat m = (iMouse.x/iResolution.x)*500.0+170.;\n\tgTime = (iTime*4.0+m)*8.;\n    vec2 xy = abs((fragCoord.xy / iResolution.xy)-.5);\n    if (xy.y > .39)\n\t{\n\t\t// Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(0,0,0,1);\n\t\treturn;\n\t}\n\tvec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    diver.z = gTime + 10.;  diver.xy = cameraPath(diver.z);\n    heading.z = diver.z+50.; heading.xy = cameraPath(heading.z);\n    heading = normalize(diver-heading);\n   \n    // Use the camera matrix function to orientate the submarine and spin it's light...\n    diverMat = setCamera(vec3(0), heading, 0.);\n\theading.xz = rot2D(heading.xz, sin(gTime*.03)*1.1);\n\n    \n\tvec3 camPos, camTar;\n    camPos.z = gTime+sin(gTime*.02)*.5;\t\tcamPos.xy = cameraPath(camPos.z);\n    camPos.y+=sin(gTime*.005)*6.;\n    camTar.z = gTime+200.; camTar.xy = cameraPath(camTar.z);\n    focus = 30.;//(diver.z- camPos.z)*.6;\n   \n        \n    mat3 camMat = setCamera(camPos, camTar, sin(gTime*.01)*.6);\n    vec3 dir = camMat * normalize( vec3(uv,cos((length(uv)))));\n     vec3 ocean = getOcean(dir, uv, camPos);\n    vec3 col = vec3(0);\n    scatter = 0.0;\n    \n    float alpha = marchScene(camPos, dir, fragCoord);\n    // Render the stack...\n    if (alpha > .0)\n    {\n\n        for (int i = 0; i < spointer; i++)\n        {\n            vec3  p = stack[i].pos; \n            float d = stack[i].dist;\n            \n            vec3 nor =  getNormal(p, sphereRadius(d)*.5);\n            vec3 mat = albedo(p, nor);\n            \n   \t        headLight = normalize(diver-p);\n            vec3  temp = lighting(mat, p, nor, dir, d);\n            temp = mix(ocean, temp , exp(-d*.005));\n            col += temp * stack[i].alpha;\n        }\n    }\n    col += ocean *  (1.0-alpha);\n    // Get shadow from the camera for the god-ray stuff...\n    float sh = shadow(camPos,  sunLight)*.4;\n    \n    #ifdef FLOATY_BITS\n    vec4 star = detritus(camPos*.4, dir,  40.);\n\tcol = col.rgb * (1.0 - star.a)+star.rgb;\n    #endif\n\n    col += rays(uv+heading.xz*.2, dir)*sh;\n    if (dir.y > 0.0 && alpha < .5)\n    {\n        float d = ((220.0-camPos.y) / dir.y);\n    \tvec2 sur = (dir.xz*d) + camPos.xz;\n    \tcol += getCaustic(sur)*pow(abs(dir.y), 2.0)*.15;\n    }\n\n    \n    col = min(col+scatter*.08, 1.0);\n    col = col*col*(3.0-col*2.0);\n    //col = col*col*3.0;\n\tcol = sqrt(col);\n    col *= pow(abs(35.0* (.39-xy.y))*(.5-xy.x), .3 );\n\tfragColor = vec4(col*smoothstep(.0, 4.,iTime), 1);//texture(iChannel1, fract(uv)).xyz,1.0);\n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4slSDf", "previewfilepath": "https://soundcloud.com/a-sound-effect/dive-deep-preview", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/a-sound-effect/dive-deep-preview", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBDR", "name": "lit cloud", "author": "loganz", "description": "bad perlin noise", "tags": ["perlin"], "likes": 3, "viewed": 167, "date": "1500020041", "time_retrieved": "2024-06-20T18:57:50.280805", "image_code": "#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat grad(float hash, vec3 pos) {\n    float h = floor(mod(hash, 16.0));\n    float u = h<8.0 ? pos.x : pos.y,\n          v = h<4.0 ? pos.y : h==12.0||h==14.0 ? pos.x : pos.z;\n    return (mod(h, 2.0) == 0.0 ? u : -u) + (mod(h, 4.0) == 0.0 ? v : -v);\n}\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat hash(float x) {return rand(vec2(x, x * 1.121)) * 256.0;}\nfloat hashx(float x) {return mod(x * 15531.13513 + x * x * 24.98981, 256.0);}\nfloat lerp(float t, float a, float b) {return a+t*(b-a);}\n\nfloat cnoise(vec3 pos){\n    vec3 ipos = mod(floor(pos), 256.0);\n    pos = fract(pos);\n    vec3 faded = fade(pos);\n    \n    float A = hash(ipos.x)+ipos.y, AA = hash(A)+ipos.z, AB = hash(A+1.0)+ipos.z;\n    float B = hash(ipos.x+1.0)+ipos.y, BA = hash(B)+ipos.z, BB = hash(B+1.0)+ipos.z;\n\n    //gradient values\n    float g0 = grad(hash(AA), pos);\n    float g1 = grad(hash(BA), pos-vec3(1.0,0.0,0.0));\n    float g2 = grad(hash(AB), pos-vec3(0.0,1.0,0.0));\n    float g3 = grad(hash(BB), pos-vec3(1.0,1.0,0.0));\n    float g4 = grad(hash(AA+1.0), pos-vec3(0.0,0.0,1.0));\n    float g5 = grad(hash(BA+1.0), pos-vec3(1.0,0.0,1.0));\n    float g6 = grad(hash(AB+1.0), pos-vec3(0.0,1.0,1.0));\n    float g7 = grad(hash(BB+1.0), pos-vec3(1.0,1.0,1.0));\n    return lerp(faded.z, lerp(faded.y, lerp(faded.x, g0, g1), lerp(faded.x, g2, g3)), lerp(faded.y, lerp(faded.x, g4, g5), lerp(faded.x, g6, g7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dim = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 mpos = vec3(iMouse.xy / iResolution.xy, 0.0);\n    \n    int i = 0;\n    vec3 val;\n    for (float f=0.0; f<6.282; f+=0.3) {\n    \tfloat x = f + iTime;\n        vec2 pos = vec2(cos(x), sin(x*2.0)) * 0.25 + 0.5;\n        vec2 dx = pos - uv;\n        float idist = sqrt(dx.x*dx.x + dx.y*dx.y)*1024.0;\n        idist = log(idist+1.0)/log(1024.0);\n        idist = max(0.0, 1.0 - idist);\n        idist *= idist * 0.5;\n        val += idist;\n\t\tif (i == 0)\n            val.r += idist;\n        else if (i == 1)\n            val.g += idist;\n        else\n            val.b += idist;\n        i++;\n        if (i>2)\n            i=0;\n    }\n    \n    vec3 color;\n    vec2 co = vec2(iTime, 0);\n    float intensity = 1.0;\n    float scale = 2.0;\n    for (int i=0; i<7; i++) {\n        vec2 relPos = uv * scale + co;\n    \tfloat cr = cnoise(vec3(relPos, 1.0) + mpos) + 0.5;\n        float cg = cnoise(vec3(relPos, 1.2) + mpos) + 0.5;\n        float cb = cnoise(vec3(relPos, 1.4) + mpos) + 0.5;\n        color += vec3(cr,cg,cb) * intensity;\n        scale *= 2.0;\n        intensity /= 2.0;\n    }\n    \n\tfragColor = vec4(color * val, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBDW", "name": "[SH17A] Deadleyen", "author": "s23b", "description": "Well this is what I could come up with 1 hour before the deadline", "tags": ["eye"], "likes": 4, "viewed": 418, "date": "1500404556", "time_retrieved": "2024-06-20T18:57:50.280805", "image_code": "#define L(x,y) length(i + vec2(x, y))\nvoid mainImage (out vec4 o, vec2 i)\n{\n    i /= iResolution.x;\n    i -= vec2(.5, .3);\n    i *= 5.;\n    i = L(0, 1) < 2. && L(0, -1) < 2. || L(1, 0) > 3. || L(-1, 0) > 3. ? i : i.yx;\n    \n    i.x = abs(i.x) + 1.;\n    i = vec2(length(i), atan(i.x, i.y)) * 5.;\n    i.y += floor(i.x) * iTime * .1;\n    \n    o = abs(sin(i.y + vec4(0, .3, .7, 1)) * fract(i.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBR1", "name": "particle consumption", "author": "public_int_i", "description": "particle consumption", "tags": ["3d", "raymarch", "particle", "consumption"], "likes": 1, "viewed": 389, "date": "1499424794", "time_retrieved": "2024-06-20T18:57:50.280805", "image_code": "//Ethan Alexander Shulman 2017\n\n\nstruct mat {\n    vec3 diffuse, specular;\n    float metallic, roughness;\n};\n    \nfloat hash(vec2 p) {\n    return fract(dot(p+vec2(.36834,.723), normalize(fract(p.yx*73.91374)+1e-4))*7.38734);\n}\nfloat voronoi_dither(vec2 u) {\n    #define l(i) length(fract(u*.7+fract(i*vec2(1,8))+cos(u.yx*.2333+i*8.))-.5)\n\treturn min(l(.1),l(.6))*2.66-1.;\n}\n\n//scene distance function\nfloat df(vec3 p) {\n    float s = 2.;\n    return length(abs(mod(abs(p),s*2.)-s)-.5)-s*.5;\n}\n//scene distance function used for normal calculation(put normal mapping/displacements here)\nfloat dfNormal(vec3 p) {\n    return df(p);\n}\n//returns normalized gradient at position p\nvec3 normal(vec3 p) {\n     const vec2 NE = vec2(1e-3, 0.);\n     return normalize(dfNormal(p)-vec3(dfNormal(p-NE.xyy), \n                      \t\t\tdfNormal(p-NE.yxy), \n                      \t\t\tdfNormal(p-NE.yyx)));\n}\n\n\n#define join(d,c) s.xyz = mix(s.xyz,c,clamp((s.w-d)/s.w,0.,1.)); if (d < s.w) s.w = d;\n\n//distance must be >= 0\n//scene emissive(xyz) & distance(w) function, w parameter in 'p' is the mipmap to use level\nvec4 scene(vec4 p) {\n    float d = df(p.xyz);\n    vec3 fp = floor(abs(p.xyz)/4.);\n    float a = max(0.,hash(fp.xy*.82745+fp.yz*.63745)-.9)*30.;\n    vec4 s = vec4(a, a, a, d);\n\n    return s;\n}\n                  \n//scene material at position p\nmat material(vec3 p) {\n    //sphere\n    return mat(vec3(1.), vec3(.8), 1., .2);\n}\n\n//background function, returns color from direction d.xyz and mipmap/blur level d.w\nvec3 background(vec4 d) {\n    return vec3(0.);\n}\n\n\n//ray-trace(march) scene, returns distance to hit or -1 if nothing hit\nfloat trace(vec3 rp, vec3 rd, float epsilon) {\n    float s = 0.;\n    for (int i = 0; i < 32; i++) {        \n        float dst = df(rp+rd*s);\n        if (dst < epsilon) return s;\n        s += dst;\n    }\n    return -1.;\n}\n\n\n//blurry trace scene, returns color\nvec3 blurTrace(vec3 pos, vec3 dir, float blur) {\n    vec4 rp = vec4(pos,1.),\n         rd = vec4(dir,blur);\n    float istep = .15+voronoi_dither(dir.xy*512.+dir.zz*2048.)*.05,\n        bm = abs(dot(dir,normal(pos)));\n    \n    vec4 c = vec4(0.);\n    float d = 1e-4;\n    for (int i = 1; i < 16; i++) {\n        if (c.w >= 1.) break;\n        \n        vec4 s = scene(rp+rd*d);\n        s.w = max(s.w, blur);\n        float ba = bm*d*blur;\n        c += vec4(s.xyz,1.)*(max(0., 1.-s.w/ba)/ba);\n        d += mix(s.w, float(i)*istep, min(1.,blur));\n    }\n\t\n    \n    return mix(background(vec4(dir,blur*10.)),c.xyz/max(1e-4,c.w),min(c.w,1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //ray-march screen ray\n    float epsilon = 2e-2+voronoi_dither(fragCoord+128.)*1e-2;//dither epsilon\n    vec3 rp = vec3(cos(iTime*.1)*40.,sin(iTime*.1)*40.,-1e2+iTime*3.),\n         rd = vec3(normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,.5)));\n    rp += rd*5.;\n    \n    float s = trace(rp,rd,epsilon);\n    \n    vec3 c;\n    if (s < 0.) {\n        //nothing hit, background\n        c = background(vec4(rd,0.));\n    } else {\n        //shade object\n        vec3 hp = rp+rd*s,\n            hn = normal(hp),\n            ref = reflect(rd, hn);\n        mat m = material(hp);\n\n        c = scene(vec4(hp,0.)).xyz+ //emissive\n                         m.diffuse*blurTrace(hp,hn,1.)*(.5-m.metallic*.5)+ //diffuse\n                         m.specular*blurTrace(hp,ref,m.roughness)*(1.-max(0.,dot(-rd,ref))*(1.-m.metallic))*(.5+m.metallic*.5); //specular\n    \tc /= 1.+s*s*.1;\n    }\n\n\tfragColor = vec4(floor(c*32.99+voronoi_dither(fragCoord))/32.,1.);//dither\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBWm", "name": "Tentacles 1 ", "author": "AlexM", "description": "Trying to make a tentacle-like thing. Yucky. ", "tags": ["tentacle"], "likes": 0, "viewed": 130, "date": "1500650227", "time_retrieved": "2024-06-20T18:57:51.802032", "image_code": "// Trying to make some weird organic tentacle-like things. Doesn't look too organic though, need to\n// mess around with noise a bit more.\n\n#define PI 3.141592653589793 \n\n#define MATERIAL_EXTERIOR 1 \n#define MATERIAL_INTERIOR 2 \n\nconst float MAXT = 20.0f;\n\nconst float FOGHEIGHT = 0.02; // background fog height. \nconst float FOGFADEHEIGHT = 0.05; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.364, 0.270, 0.254);\nconst float FOGDENSITY = 0.08; \n\nconst vec3  SUNDIRECTION = normalize(vec3(0.0, -0.3, -0.6)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(1.0, 0.949, 0.839); // sun color? \nconst vec3  SKYCOLOR = vec3(0.929, 0.792, 0.768);\nconst float REFRETA = 1.0/1.4;\nconst vec3 REPETITIONS = vec3(3.5, 0.0, 0.0);\n\n\n\nconst float EXTERIOR_FRESNEL_POW = 2.0;\nconst float ABSORBANCE_SCALE = 4.5;\nconst vec3  ABSORBANCE = vec3(0.15, 0.7, 0.8);\nconst float TRANSPARENCY = 0.9;\n\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    int materialID;\n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    vec3 u = x*x*(3.0-2.0*x);\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(fg, 0.0, 1.0);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(-a,b);\n}\n\nfloat opAdd(float a, float b) {\n    return min(a,b);\n}\n\nvec3 opRepeat(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat exterior(vec3 p, out int mattype) {\n    mattype = MATERIAL_EXTERIOR;\n\n    p.x -= noise(p.zz*0.1+iTime*0.2) * 3.0;\n    p = opRepeat(p, REPETITIONS);\n    float f;\n    f = length(p.xy)-0.6; \n    float a = 0.50*(1.0-abs(2.0*noise(p*1.2+vec3(1.0)  +iTime*0.25)-1.0)); a = a*a*a*a;\n    float b = 0.40*(1.0-abs(2.0*noise(p*2.4+vec3(100.0)-iTime*0.27)-1.0)); b = b*b*b*b;\n    float c = 0.13*(1.0-abs(2.0*noise(p*20.+vec3(200.0)+iTime*0.73)-1.0)); c = c*c*c*c;\n    float d = 0.12*(1.0-abs(2.0*noise(p*220.+vec3(500.0)+iTime*0.93)-1.0)); d = d*d*d*d;\n    f = f-a-b-c-d;\n    return f;\n}\n\nfloat interior(vec3 p, out int mattype) {\n    float f;\n    float t =exterior(p, mattype);  \n    f = opSubtract(t, -90000.0);\n    p.x -= noise(p.zz*0.1+iTime*0.2) * 3.0;\n    p = opRepeat(p, REPETITIONS);\n\n    // tubes inside the body\n    p = rotateZ(0.8+iTime*0.5)*p;\n\n    for (int t = 0; t < 2; t++) {\n        float f1 = length(p.xy-vec2(float(t)*0.3-0.2,0.0))-0.10; \n        float a = 0.40*(1.0-abs(2.0*noise(p*1.2+vec3(1.0)  +iTime*0.09)-1.0)); a = a*a*a;\n        float b = 0.30*(1.0-abs(2.0*noise(p*4.4+vec3(100.0)-iTime*0.02)-1.0)); b = b*b*b;\n        f1 = f1-a-b;\n        f= opAdd(f, f1);\n    }\n    mattype = MATERIAL_INTERIOR; \n    if (abs(f-t)<0.2) mattype = MATERIAL_EXTERIOR;\n    return f;\n}\n\n\nfloat interior(vec3 p) { int unused; return interior(p, unused); }\nfloat exterior(vec3 p) { int unused; return exterior(p, unused); }\n\nTraceResult traceInterior(vec3 ro, vec3 rd) {\n    int mattype = 0;\n    int watermat = 0;\n    TraceResult traceResult = TraceResult(false, 0.0, mattype);\n    float t = 0.02;\n    float tmax = MAXT; \n    for (;t < tmax;) {\n        float d = interior(ro+rd*t, mattype);\n        if (d<0.001) { \n            traceResult = TraceResult(true, t, mattype);\n            break;\n        }\n        t += d;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nTraceResult traceExterior(vec3 ro, vec3 rd) {\n    int mattype = 0;\n    int watermat = 0;\n    TraceResult traceResult = TraceResult(false, 0.0, mattype);\n    float t = 0.02;\n    float tmax = MAXT; \n    for (;t < tmax;) {\n        float d = exterior(ro+rd*t, mattype);\n        if (d<0.001) { \n            traceResult = TraceResult(true, t, mattype);\n            break;\n        }\n        t += d;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 calcInteriorNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = interior(p+eps.xyy)-interior(p-eps.xyy);\n    float y = interior(p+eps.yxy)-interior(p-eps.yxy);\n    float z = interior(p+eps.yyx)-interior(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\nvec3 calcExteriorNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = exterior(p+eps.xyy)-exterior(p-eps.xyy);\n    float y = exterior(p+eps.yxy)-exterior(p-eps.yxy);\n    float z = exterior(p+eps.yyx)-exterior(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\n\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\n//@v - view direction, normalized;\n//@k - shininess constant;\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, 2.0));\n}\n\nvoid getMaterial(in int mattype, out vec3 matcolor) {\n    matcolor = vec3(0.0);\n    vec3 exteriorColor1 = vec3(0.223, 0.050, 0.019);\n    vec3 exteriorColor2 = vec3(0.105, 0.117, 0.172);\n    vec3 interiorColor1 = vec3(0.521, 0.298, 0.098);\n    vec3 interiorColor2 = vec3(0.611, 0.043, 0.815);\n\n    float f = sin(iTime*0.5)*0.5+0.5;\n    if (mattype == MATERIAL_EXTERIOR) { \n        matcolor = mix(exteriorColor1, exteriorColor2, f);\n    }\n    if (mattype == MATERIAL_INTERIOR) {\n        matcolor = mix(interiorColor1, interiorColor2, f);\n    }\n    \n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n\n    vec3 color = vec3(0.0);\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.005-0.1) * rotateX(iMouse.y*0.005-0.4)  * rd;\n    rd = normalize(rd);\n\n    vec3 ro = vec3(0.0,1.5,0.0); \n    ro += iTime*0.2*normalize(vec3(0.0, 0.0, 1.0));\n\n\n    TraceResult exteriorTrace = traceExterior(ro, rd);\n    if (exteriorTrace.hit) {\n        vec3 exteriorPosition = ro+exteriorTrace.rayt*rd;\n        vec3 exteriorNormal = calcExteriorNormal(exteriorPosition);\n\n\n        // trace inside the thing \n        vec3 interiorStartPosition = exteriorPosition - exteriorNormal * 0.01; \n        vec3 interiorRayDirection = refract(rd, exteriorNormal, REFRETA); \n        TraceResult interiorTrace = traceInterior(interiorStartPosition, interiorRayDirection);\n\n        vec3 interiorColor;\n        if (interiorTrace.hit) {\n            getMaterial(interiorTrace.materialID, interiorColor);\n\n            vec3 interiorPosition = interiorStartPosition+interiorTrace.rayt*interiorRayDirection;\n            vec3 interiorNormal = calcInteriorNormal(interiorPosition);\n            // compute lighting inside\n            interiorColor = interiorColor*(0.3+phongDiffuseFactor(-SUNDIRECTION, interiorNormal)*1.0\n                                              +phongSpecularFactor(-SUNDIRECTION,interiorNormal, interiorRayDirection, 50.0)*1.0\n            );\n\n            // exit the interior....\n            if (interiorTrace.materialID == MATERIAL_EXTERIOR)\n                interiorColor += sky(interiorPosition, interiorRayDirection) * 0.2;\n        }\n\n        vec3 exteriorColor; \n        getMaterial(exteriorTrace.materialID, exteriorColor);\n        exteriorColor = exteriorColor*(0.3+phongDiffuseFactor(-SUNDIRECTION, exteriorNormal)*1.0 \n                                          +phongSpecularFactor(-SUNDIRECTION,exteriorNormal, rd, 50.0)*1.0\n        );\n\n        vec3 absorbance = exp(-ABSORBANCE*ABSORBANCE_SCALE*interiorTrace.rayt);\n        float fresnel = pow(dot(exteriorNormal, -rd), EXTERIOR_FRESNEL_POW);\n        fresnel *= TRANSPARENCY;\n        vec3 reflection = sky(ro, reflect(rd, exteriorNormal));\n        color = reflection*exteriorColor*(1.0-fresnel) + interiorColor*absorbance*(fresnel);\n\n                \n        color = mix(color, FOGCOLOR, fog(exteriorTrace.rayt));\n        color = clamp(color, 0.0, 1.0);\n    } else {\n        color = sky(ro, rd);\n    }\n\n\n\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBBzV", "name": "[SH17C] Subpixel movement", "author": "unbird", "description": "Subpixel movement illustration. Speed is 1 \"pixel\" per second, upper half is smooth, lower is rounded to pixel position.\n\nChange PIXELSIZE constant for granularity. Set to 1 for actual pixels.\n\n(made after a chat discussion about the topic)", "tags": ["antialias", "subpixel", "movement"], "likes": 6, "viewed": 332, "date": "1501137609", "time_retrieved": "2024-06-20T18:57:51.808056", "image_code": "/*\n    Subpixel movement\n\t\n\tby unbird\n\n\tLicense: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t\n\tIllustrating the illusion of subpixel movement thanks to filtering/\"supersampling\"/anti-aliasing\n\n\tSelf ref : https://www.shadertoy.com/view/ldBBzV\n\n\tUpdate: Cleaner transitions, simplified calculation\n\n*/\n\n// Change the following constant to define \"pixel\" size\n\nconst int PIXELSIZE = 10;\n\n///////////////////////////////////////////////////////////\n\nfloat circle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvoid blend(inout vec4 back, float dist, vec4 color, float border)\n{\n    float alpha = saturate((dist+border)/border);\n    color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), saturate((dist + 2.0 * border)/border));    \n    back = mix(back, color, (1.0-alpha) * color.a);\n}\n\nfloat pingpong(float time)\n{\n    // triangle curve\n\treturn abs(fract(time)*2.0 - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    fragColor = vec4(0.5);\n    float center = iResolution.y / 2.0;\n\tivec2 pixCoord = ivec2(fragCoord);\n    \n    // screen split\n    if(pixCoord.y == int(center))\n        return;\n    \n    // background color\n\tfragColor = vec4(0.0,1.0,0.0,1.0);\n    \n\tfloat pixelSize = float(PIXELSIZE);   \n\t\n    // comment out the following line to remove the pixelated look (for debugging)\n    fragCoord = floor(fragCoord / pixelSize) * pixelSize;\n\t\n    float radius = iResolution.y / 3.0;        \n    float speed = pixelSize / iResolution.x;\n\tfloat x = radius + pingpong(iTime*speed) * (iResolution.x - radius*2.0);\n    if(pixCoord.y < int(center))\n        x = round(x / pixelSize) * pixelSize;\n\t\n    blend(fragColor, circle(vec2(fragCoord.x - x, fragCoord.y - center), radius), vec4(1.0), pixelSize);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBfWz", "name": "synchronous drops", "author": "public_int_i", "description": "synced drops", "tags": ["drops", "synchronous"], "likes": 1, "viewed": 355, "date": "1500036028", "time_retrieved": "2024-06-20T18:57:51.808056", "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    o += 1.-fract((u.y*.02+atan(u.y,u.x)*iResolution.x*.03)*fract(u.x*.61)+iTime)*5.-o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBfzw", "name": "[SH17A] Fireworks", "author": "BigWIngs", "description": "Based on my previous fireworks shader:\nhttps://www.shadertoy.com/view/lscGRl\n\nThis is my first code golf exercise. I hope the masters of this can shave off a few more characters. I'm looking at you FabriceNeyret, GregRostami, Coyote, P_Malin :)", "tags": ["fireworks", "2tweets", "codegolf", "sh17a"], "likes": 71, "viewed": 5600, "date": "1499879422", "time_retrieved": "2024-06-20T18:57:52.547642", "image_code": "// \"[SH17A] Fireworks\" by Martijn Steinrucken aka BigWings/Countfrolic - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on https://www.shadertoy.com/view/lscGRl\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n\n// Greg Rostami & FabriceNeyret2 version -> 265 chars \n#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2) \nvoid mainImage(out vec4 o, vec2 U) {\n    vec2 u = U/iResolution.y;\n    float e, d, i=-2.;\n    for(vec4 p; i++<9.; d = floor(e = i*9.1+iTime),p = N(d)+.3, e -= d)\n        for(d=0.; d++<50.;)\n            o += p*(1.-e) / 1e3 / length(u-(p-e*(N(d*i)-.5)).xy);\n    u.y<N(ceil(u.x*i+d+e)).x*.4 ? o-=o*u.y : o;}\n\n/* //Original version, 278 chars\n#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2) \nvoid mainImage(out vec4 o,vec2 u )\n{\n    o-=o; \n    \n    u /= iResolution.y;\n    \n    float e, d, i=-2.; \n    \n    for(vec4 p; i++<9.; d = floor(e = i*9.1+iTime),p = N(d)+.3, e -= d)\n        for(d=0.; d++<50.;)\n            o += p*(1.-e) / 1e3 / length(u-(p-e*(N(d*i)-.5)).xy);  \n\n    if(u.y<N(ceil(u.x*i+d+e)).x*.4) o-=o*u.y;\n}\n*/\n\n/*\nEXPLANATION OF HOW THIS WORKS\n\n\n// turns 1 float into a pseudo random vec4 in the 0-1 range\n#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2) \n\nvoid mainImage(out vec4 o,vec2 u )\n{\n    //initialize o to 0,0,0,0 in the shortest way possible\n    // o is what will hold the final pixel color\n    o-=o; \n    \n    // divide the uv pixel coordinates by the height to get aspect corrected 0-1 coords\n    u /= iResolution.y;\n    \n    // loop iterator defined here because it saves characters\n    // starts at -2 so it goes through 0, which gives the occasional rocket\n    float e, d, i=-2.; \n    \n    // outer loop, defines number of simultaneous explosions\n    // other var assignments inside of the for statement which \n    // saves chars on brackets around the for loop\n    // i++<9 which saves the i++; that usually goes at the end of the for\n    for(vec4 p; i++<9.; \n        // e = the time since the shader started + an offset per explosion\n        // d = the floored version of that, which stays the same for a second, then jumps\n        d = floor(e = i*9.1+iTime),\n        // the position of the explosion, as well as the color\n        // which is a pseudo random number made by throwing a large number into a sine function\n        // +.3 so the explosions are centered horizontally (because aspect ratio of screen)\n        p = N(d)+.3, \n        // turn e into the fractional component of time e.g. 10.546 -> 0.546\n        e -= d)\n        // inner loop, renders the particles in the explosion\n        for(d=0.; d++<50.;)\n            // add to final pixel col\n            // p = the color, 1.-e is a number that starts at 1 and goes to 0 \n            // over the duration of the explosion, essentially fading the particle\n            o += p*(1.-e) \n            // divide by 1000, otherwise the pixel colors will get too bright\n            / 1e3 \n            // divide by the distance to the particle, the farther away, the darker\n            // note that this never gets to 0, each tiny particle has an effect over the\n            // entire screen\n            // dist to particle is the length of the vector from the current uv coordinate (u)\n            // to the particle pos (p-e*(N(d*i)-.5)).xy\n            // particle pos starts at p, when e is 0\n            // N(d*i) gives a pseudo random vec4 in 0-1 range\n            // d*i to give different vec4 for each particle\n            // *i is not really necessary but when i=0 it gives 0 for the whole vec4\n            // which makes the appearance of the occasional rocket\n            // N(d*i)-.5 to go from 0-1 range to -.5 .5 range\n            / length(u-(p-e*(N(d*i)-.5)).xy);  \n\n   // draw skyline\n   // uv.x goes from 0 to 1.6  *i to make it larger i=9. (save a char cuz 9. is 2 chars)\n   // +d+e   d+e = iTime  -> this will make the skyline scroll\n   // ceil to go in steps (stay at one height, then jump to the next)\n   // N(..) to make a value 0, 1, 2, 3.. etc into random numbers in 0-1 range\n   // .x*4   N returns a vec4, but we only need a float, *.4 so buildings are lower\n   // o -= o*u.y   o-=o would make the buildings pitch black, *u.y to fade them towards the \n   // bottom, creating a bit of a fog effect     \n   if(u.y<N(ceil(u.x*i+d+e)).x*.4) o-=o*u.y;\n}\n\n*/", "image_inputs": [{"id": "4sXSWS", "previewfilepath": "https://soundcloud.com/gabriella-vargas/calvin-harris-florence-and-the", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/gabriella-vargas/calvin-harris-florence-and-the", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBfzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjBRw", "name": "[SH17A] Waves", "author": "Koltes", "description": "Variation of https://www.shadertoy.com/view/MdXBWl\nThanks to GregRostami and FabriceNeyret2 for starting the golf.\nS trick by BigWIngs", "tags": ["waves"], "likes": 13, "viewed": 718, "date": "1499967259", "time_retrieved": "2024-06-20T18:57:52.547642", "image_code": "#define S sin(iTime\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O.xyz = iResolution;\n    float y, i=-15., k=O.y, c;\n    \n\tU /= k;\n    \n    while (i++ < 15.)\n        c = exp(-.1*i*i),\n        y = (.08 + .02 * S*2.+i*2.)) * exp(-.01*i*i)\n            * S*2. + U.x / (.2-.1*c) + i*4. )\n            - i/20. + .5 - U.y, \n        O += max(0., 1.-exp(-y*k*c) )\n             * (\n                 tanh(40.*y)\n                 * (.5 + .4 * S+i+vec4(0,1,1,0)))\n                 - O\n             );\n}", "image_inputs": [{"id": "lsXSzs", "previewfilepath": "https://soundcloud.com/khaled-elyamany/piano-1-hour-with-sea-sound", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/khaled-elyamany/piano-1-hour-with-sea-sound", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjBW1", "name": "[SH17A] Matrix rain", "author": "reinder", "description": "Matrix rain. View in full screen.", "tags": ["matrixrain", "sh17a"], "likes": 38, "viewed": 1774, "date": "1500332665", "time_retrieved": "2024-06-20T18:57:52.547642", "image_code": "// [SH17A] Matrix rain. Created by Reinder Nijhoff 2017\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/ldjBW1\n//\n\n#define R fract(1e2*sin(p.x*8.+p.y))\nvoid mainImage(out vec4 o,vec2 u) {\n    vec3 v=vec3(u,1)/iResolution-.5,\n        s=.5/abs(v),\n        i=ceil(8e2*(s.z=min(s.y,s.x))*(s.y<s.x?v.xzz:v.zyz)),\n        j=fract(i*=.1),\n        p=vec3(9,int(iTime*(9.+8.*sin(i-=j).x)),0)+i;\n   o-=o,o.g=R/s.z;p*=j;o*=R>.5&&j.x<.6&&j.y<.8?1.:0.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjBzz", "name": "Chaotic disturbance", "author": "lsdlive", "description": "Raymarching inspired by LJ's early geometry at Revision 's shader showdown (cross + amod).\n\nNo colour because I like white-fake ambient occlusion.\n\nNot yet a demoscene hacker, but still progressing.", "tags": ["raymarching"], "likes": 11, "viewed": 250, "date": "1499253275", "time_retrieved": "2024-06-20T18:57:52.553734", "image_code": "\nfloat cheapFFT(float m) {\n\treturn texture(iChannel0, vec2(m, 0.)).r;\n}\n\nfloat smin(float a, float b)\n{\n\tfloat k = 8.;\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(res) / k;\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 amod(vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y), m) - m * .5;\n\treturn vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat sc(vec3 p) {\n\tp = abs(p);\n\treturn smin(min(max(p.x, p.y), max(p.y, p.z)), max(p.z, p.x));\n}\n\nfloat map(vec3 p) {\n\tmat2 r = r2d(iTime);\n\tp.xz *= r; p.xy *= r;\n\n\tp.xz = amod(p.xz, .785);\n\n\tp.x = mod(p.x, 8.) - 4.;\n\n\tfloat c1 = 8. * sin(iTime*.2);\n\tp.z = mod(p.z, c1) - c1 * .5;\n\n\n\treturn sc(p) - .5 + smoothstep(.1, .9, cheapFFT(iTime));\n\treturn length(max(abs(p) - vec3(.7), 0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(1., 2., 10.), p;\n\tvec3 rd = normalize(vec3(uv, -1.));\n\tp = ro;\n\n\tint it;\n\tfor (int i=0; i < 50; i++) {\n        it = i;\n\t\tfloat d = map(p);\n\t\tif (d < .01) break;\n\t\tp += rd * d;\n\t}\n\n\tfragColor = vec4(1. - float(it) / 50.);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjBzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjfDm", "name": "Happy Birthday to a Friend!", "author": "4onen", "description": "A simple shader I threw together in a half hour to celebrate a friend's birthday!", "tags": ["2d", "simple", "signeddistancefields"], "likes": 1, "viewed": 88, "date": "1500764077", "time_retrieved": "2024-06-20T18:57:53.008106", "image_code": "//2D signed distance field box\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//2D signed distance field \"candle\"\nfloat candle(vec2 p){\n    return min(\n        box(p,vec2(0.05,0.4)),\n        box(p-vec2(0.0,0.25),vec2(0.001,0.25))\n        );\n}\n\n//Add two objects together with materials\nvec2 oUnion(vec2 o1, vec2 o2){\n    return o1.x < o2.x ? o1 : o2;\n}\n\n//The objects in the world\nvec2 map(vec2 p){\n    //No object\n    vec2 background = vec2(0.01,0.0);\n    \n    //The cake\n    vec2 loaf = vec2(\n        max(box(p-vec2(0.0,-0.3),vec2(0.5,0.3))-0.15,-box(p-vec2(0.0,-0.7),vec2(1.0,0.2))),\n        1.0);\n    \n    //The candles\n    vec2 candles = vec2(\n        min(candle(p-vec2(0.0,0.1)),\n            min(candle(p-vec2(0.3,0.0)),\n                candle(p-vec2(-0.3,0.0)))\n           )\n        ,4.0);\n    \n    //Combine all of the objects\n    return oUnion(background,\n                  oUnion(loaf,candles)\n                 );\n}\n\nvec3 material(vec2 obj){\n    //Turn the materials into colors!\n    \n    //Modifier\n    float m = 1.0-smoothstep(0.0,0.01,obj.x);\n    \n    //Background\n    if(obj.y < 0.1) return vec3(0.7,0.7,0.65);\n    \n    //Loaf\n    if(obj.y < 1.1) return vec3(0.45,0.255,0.25);\n    \n    //Candle\n    if(obj.y < 4.1) return vec3(1.0,vec2(sin(3.14+365.25*obj.x)));\n    \n    //Error material/color\n    return m*vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //Establish an aspect-ratio independent \"world\" with a [-1,1] y coordinate\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Make the \"world\" bounce.\n    uv.y += sin(iTime)/8.0;\n    \n    fragColor = vec4(material(map(uv)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjfDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlBDl", "name": "Yet Another Torus", "author": "jTobergte", "description": "Basically, this is a quick conversion of a torus, I used for the 'Yet Another 4KB Intro' on ATARI ST - released at Outline 2012.", "tags": ["oldschool", "dots"], "likes": 12, "viewed": 493, "date": "1498907273", "time_retrieved": "2024-06-20T18:57:54.341327", "image_code": "//---------------------------------------------------------------------\n//\tYet Another Torus\n//\tby Joerg Tobergte (mr.coke)\n//\n//\tMy first released Shadertoy :D\n//\tBasically, this is a quick conversion of\n//\ta torus, I used for the 'Yet Another 4KB Intro'\n//\ton the ATARI ST - releaed at Outline 2012\n//\n//\tThanks to Tetane for https://www.shadertoy.com/view/ldtGDn\n//\t..this was _very_ helpful to me!\n//---------------------------------------------------------------------\n\n//---------------------------------------------------------------------\n//\tUsing less dots due to better performance.\n//---------------------------------------------------------------------\n#define pi 3.14159\n#define pi2 6.28318\nconst float dotsnb = 720.0 * 0.125;\n\nvec3 hsv2rgb (vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (pi2 * (hsv.x + vec3(0.0, 0.666, 0.333))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx * 0.5;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 0.002;\t\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset\n    float stepp = 1.0 / dotsnb;\n    float hue = 0.0;\n        \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\n        hue += stepp;\n        float mANGLE = pi2*hue;\n        float SX = mANGLE * 26.0;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );\n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n        \n        // Better 3D to 2D conversion by Bastian Schick\n        float DZ = CAMZ / ( CAMZ + pos3D.z ) * 0.185;\n        pos2D = vec2( pos3D.x, pos3D.y );\n        pos2D *= DZ;\n        \n        // Better distance code by Bastian Schick\n        pos2D += scrs;\n        float dx = abs( uv.x - pos2D.x );\n        float dy = abs( uv.y - pos2D.y );\n        float dist = 0.3 * ( dx + dy ) + 0.4 * max( dx, dy );\n                \n\t\tcol += hsv2rgb( vec3( hue, dist / intensity, intensity / ( dist * 2.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n/*\n//---------------------------------------------------------------------\n//\t3rd Optimization - Got some help! Thanks to Bastian Schick\n//---------------------------------------------------------------------\n#define pi 3.14159\n#define pi2 6.28318\nconst float dotsnb = 720.0;\n\nvec3 hsv2rgb (vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (pi2 * (hsv.x + vec3(0.0, 0.666, 0.333))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx * 0.5;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 0.002;\t\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset\n    float stepp = 1.0 / dotsnb;\n    float hue = 0.0;\n        \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\n        hue += stepp;\n        float mANGLE = pi2*hue;\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );\n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n        \n        // Better 3D to 2D conversion by Bastian Schick\n        float DZ = CAMZ / ( CAMZ + pos3D.z ) * 0.185;\n        pos2D = vec2( pos3D.x, pos3D.y );\n        pos2D *= DZ;\n        \n        // Better distance code by Bastian Schick\n        pos2D += scrs;\n        float dx = abs( uv.x - pos2D.x );\n        float dy = abs( uv.y - pos2D.y );\n        float dist = 0.3 * ( dx + dy ) + 0.4 * max( dx, dy );\n                \n\t\tcol += hsv2rgb( vec3( hue, dist / intensity, intensity / ( dist * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n/*\n//---------------------------------------------------------------------\n//\t2nd Optimization - Lost a lot divisions & multiplies! :D\n//\t\t\t\t\t   Edit: Looking for a better way to convert a\n//\t\t\t\t\t\t\t vec3 pos into a vec2 pos\n//\t\t\t\t\t\t\t PLZ - contact me, or write a comment!\n//---------------------------------------------------------------------\n#define pi 3.14159\n#define pi2 6.28318\nconst float dotsnb = 720.0;\n\nvec3 hsv2rgb (vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (pi2 * (hsv.x + vec3(0.0, 0.666, 0.333))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 0.002;\t\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset    \n    \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\n        float hue = i/dotsnb;\n        float mANGLE = pi2*hue;\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );\n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n                \n        float DZ = CAMZ + pos3D.z;\n        pos2D = vec2( CAMZ*pos3D.x/DZ, CAMZ*pos3D.y/DZ );\n        pos2D *= 0.185;\n        \n        float dist = distance( uv, scrs * 0.5 + pos2D );\n\t\tcol += hsv2rgb( vec3( hue, dist / intensity, intensity / ( dist * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n/*\n//---------------------------------------------------------------------\n//\t1st Optimization - Got rid of sqrt & atan!! :D\n//---------------------------------------------------------------------\n#define pi 3.14159\nconst float dotsnb = 720.0*4.0; // Number of dots\n\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 1.0/500.0;\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset    \n    \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\t\t\n        float hue = i/dotsnb;\n        float mANGLE = 2.0*pi*hue;\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );        \n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n                \n        float DZ = CAMZ + pos3D.z;\n        pos2D = vec2( CAMZ*pos3D.x/DZ*0.185, CAMZ*pos3D.y/DZ*0.185 );\n        \n        vec2 shift = scrs / 2.0 + pos2D;\n\t\tcol += hsv2rgb( vec3( hue,\n                        distance( uv,shift ) * ( 1.0 / intensity ),\n                        intensity / ( distance( uv, shift ) * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n\n/*\n//---------------------------------------------------------------------\n//\tFirst Version\n//---------------------------------------------------------------------\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec2 pos  = vec2(0.0); \t\t\t// Position of the dots\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 1.0/500.0;\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset\n    \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\t\t\n\t\tfloat mANGLE = 2.0*pi*i/dotsnb;\n\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n        float SZ = cos( mANGLE ) * 0.35;\n                        \n        float X = sin( SX ) * SY;\n        float Y = SZ;\n        float Z = cos( SX ) * SY;\n\n        Y += sin( iTime ) * 0.5;\t// add Y-swing\n                \n        float RLEN = sqrt( Z*Z + X*X );\n        float WTST = atan( X, Z );\n        X = sin( WTST + iTime * 0.5 ) * RLEN;\n        Z = cos( WTST + iTime * 0.5 ) * RLEN;\n        \n        float DZ = CAMZ + Z;\n        float XX = CAMZ * X / DZ * 0.185;\n        float YY = CAMZ * Y / DZ * 0.185;\n        \n        pos = vec2( XX, YY );\n\n        float hue = 0.8;\t\t\t\t// classic colors\n        //float hue = i / dotsnb;\t\t// more colorful version\n        \n\t\tcol += hsv2rgb( vec3( hue,\n                        distance( uv,scrs / 2.0 + pos ) * ( 1.0 / intensity ),\n                        intensity / ( distance( uv, scrs / 2.0 + pos ) * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/", "image_inputs": [{"id": "4dlXRX", "previewfilepath": "https://soundcloud.com/j-tobergte/floating", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/j-tobergte/floating", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsBDs", "name": "Smooth Notch", "author": "Split82", "description": "This is my first shadertoy shader. The core is made from https://www.youtube.com/watch?v=yxNnRSefK94 ", "tags": ["procedural"], "likes": 16, "viewed": 318, "date": "1498945624", "time_retrieved": "2024-06-20T18:57:54.681124", "image_code": "float map(vec3 p)\n{    \n    vec3 q = fract(p * 0.5) * 2.0 - 1.0;\n\tq.y = q.x * 0.5;\n    \n\treturn length(q) - 0.3;\n}\n\nfloat trace(vec3 origin, vec3 ray) \n{    \n    float t = 0.0;\n    for (int i = 0; i < 18; i++) {\n        vec3 p = origin + ray * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    uv = uv * 2.0 - 1.0;\n    \n    // Aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;                        \n    \n    // RGB\n    vec3 c;\n    \n    float s1 = sin(iTime * 0.5);\n    \n    // Compute RGB separately.\n    for (int i = 0; i < 3; i++) {\n        \n        // Move origin.\n        vec3 origin = vec3(0.0, 0.0, iTime);\n        \n        // Some kind of chromatic aberration.\n        uv.x *= 0.97;\n        uv.y *= 0.97;\n        \n    \tvec3 ray = normalize(vec3(uv, 0.5));\n        \n        // Spiral rotation (XY).\n    \tfloat the = iTime + length(uv) * s1;\n    \tray.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n        \n        // Normal rotation (XZ).\n        the = iTime * 0.1;\n        ray.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n                \n        float t = trace(origin, ray);\n        \n        // Visualize depth.\n    \tc[i] = 1.0 / (1.0 + t * t * 0.07);\n    }    \n       \n        \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsBDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSBDw", "name": "D3sp4c1t0 !!!11!!11!1", "author": "CorgiLord", "description": "based on www.shadertoy.com/view/XdXGRB\nawesome chiptune : soundcloud.com/ddstrainers/despacito-8bit-by-vinheteiro", "tags": ["pls", "despacito", "jpp"], "likes": 3, "viewed": 172, "date": "1500632918", "time_retrieved": "2024-06-20T18:57:56.245317", "image_code": "vec2 coord;\n\n#define font_size 20. \n#define font_spacing .068\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n#define P_ vec2(0.,5.)\n#define Q_ vec2(1.,5.)\n#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define STOP(p) t(B_,B_,p)\n#define FLY1(p) t(H_,F_,p) \n#define FLY1b(p)+ t(H_,D_,p)\n#define FLY2(p) t(H_,L_,p)\n#define FLY2b(p) t(H_,J_,p)\n#define SMOKE(p) t(vec2(0,0),vec2(2,0),p) + t(vec2(2,0),vec2(2,2),p)+ t(vec2(2,2),vec2(0,2),p)+ t(vec2(0,2),vec2(0,4),p)+ t(vec2(0,4),vec2(2,4),p)+ t(vec2(2,4),vec2(2,6),p)+ t(vec2(2,6),vec2(0,6),p)+ t(vec2(0,6),vec2(0,8),p)+ t(vec2(0,8),vec2(1.5,8.2),p)+ t(vec2(1.5,8.2),vec2(1,9),p)+ t(vec2(1,9),vec2(1,10),p)\n#define POOP(p) t(vec2(8,0),vec2(12,-1),p) + t(vec2(10,-0.5),vec2(12,-3),p)+ t(vec2(14,1.5),vec2(12,-3),p)+ t(vec2(14,1.5),vec2(8,0),p)+ t(vec2(6,1.5),vec2(8,0),p)+ t(vec2(6,1.5),vec2(5,3),p)+ t(vec2(15,1.25),vec2(5,3),p)+ t(vec2(15,1.25),vec2(16,3),p)+ t(vec2(15,5.5),vec2(16,3),p)+ t(vec2(15,5.5),vec2(4,5.5),p)+ t(vec2(3,4.),vec2(4,5.5),p)+ t(vec2(3,4.),vec2(5.,2.8),p)\n\n\nvec2 caret_origin = vec2(1.0, .93);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 10. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat mult = 1.;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount += mult;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add(float o)\n{\n\tcaret.x += o;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .108;\n}\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 9000.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\tvec3 col = vec3(0.1, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\tmult = 5.5;\n    \n\td += D(r());\n    newline();\n    d += E(r()); \n    newline();\n    d += S(r());\n   newline(); \n    d += P(r());\n    newline();\n    d += A(r());\n    newline();\n    d += C(r());  \n    newline();\n    d += I(r());\n    newline();\n    d += T(r());\n    newline();\n    d += O(r());\n    \n\n    caret = caret_origin; \n    caret.y -= .550;\n    caret.x += 10.75; \n    d+= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .150;\n    caret.x += 8.75; \n    d+= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .650;\n    caret.x += 1.75;\n    d+= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .10;\n    caret.x += 4.;\n    d+= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .525;\n    caret.x += 4.75;\n    d+= SMOKE(r());\n    \n    caret = caret_origin; \n    caret.y -= .300;\n    caret.x += 6.5;\n    d+= SMOKE(r());\n    \n    caret = caret_origin; \n    caret.y -= .450;\n    caret.x += 8.2;\n    d+= SMOKE(r());\n    \n    caret = caret_origin; \n    caret.y -= .750;\n    caret.x += 4.55;\n    \n    d+= POOP(r());\n    \n    mult = .4;\n    \n    //----------cleanflies\n    caret = caret_origin; \n    caret.y -= .550;\n    caret.x += 10.75; \n    d-= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .150;\n    caret.x += 8.75; \n    d-= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .650;\n    caret.x += 1.75;\n    d-= FLY1(r())+FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .10;\n    caret.x += 4.;\n    d-= FLY1(r())+FLY1b(r());\n    \n    //---------anim1A\n    \n    float anim = step(.5,sin(time*10.));\n    \n    caret = caret_origin; \n    caret.y -= .550;\n    caret.x += 10.75; \n    d+= anim*FLY1(r());\n    \n    caret = caret_origin; \n    caret.y -= .150;\n    caret.x += 8.75; \n    d+= anim*FLY1(r());\n    \n    caret = caret_origin; \n    caret.y -= .650;\n    caret.x += 1.75;\n    d+= anim*FLY1(r());\n    \n    caret = caret_origin; \n    caret.y -= .10;\n    caret.x += 4.;\n    d+= anim*FLY1(r());\n\t\n    //---------anim1B\n    caret = caret_origin; \n    caret.y -= .550;\n    caret.x += 10.75; \n    d+= anim*FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .150;\n    caret.x += 8.75; \n    d+= anim*FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .650;\n    caret.x += 1.75;\n    d+= anim*FLY1b(r());\n    \n    caret = caret_origin; \n    caret.y -= .10;\n    caret.x += 4.;\n    d+= anim*FLY1b(r());\n    \n    //---------anim2A\n    \n    float anim2 = step(.5,sin(time*10.+10.));\n    \n    caret = caret_origin; \n    caret.y -= .525;\n    caret.x += 10.75; \n    d+= anim2*FLY2(r());\n    \n    caret = caret_origin; \n    caret.y -= .1250;\n    caret.x += 8.75; \n    d+= anim2*FLY2(r());\n    \n    caret = caret_origin; \n    caret.y -= .6250;\n    caret.x += 1.75;\n    d+= anim2*FLY2(r());\n    \n    caret = caret_origin; \n    caret.y -= .0750;\n    caret.x += 4.;\n    d+= anim2*FLY2(r());\n\t\n    //---------anim2B\n    caret = caret_origin; \n    caret.y -= .5250;\n    caret.x += 10.75; \n    d+= anim2*FLY2b(r());\n    \n    caret = caret_origin; \n    caret.y -= .1250;\n    caret.x += 8.75; \n    d+= anim2*FLY2b(r());\n    \n    caret = caret_origin; \n    caret.y -= .6250;\n    caret.x += 1.75;\n    d+= anim2*FLY2b(r());\n    \n      caret = caret_origin; \n    caret.y -= .0750;\n    caret.x += 4.;\n    d+= anim2*FLY2b(r());\n    \n    \n\td = clamp(d*2.* (.75+sin(fragCoord.x*PI*.8-time*8.3)*.8), .08, 0.80);\n      \n    col += vec3(d*.7, d, d*.2);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.8, .1, .0) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .8 );\t\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "MdXXDS", "previewfilepath": "https://soundcloud.com/ddstrainers/despacito-8bit-by-vinheteiro", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ddstrainers/despacito-8bit-by-vinheteiro", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSBRK", "name": "HSLuv / HPLuv Radial Test", "author": "ttoinou", "description": "\" HSLuv preserves the lightness and hue components of CIELUV LCh and stretches its chroma so that every color has the same range, defined as a percentage. \"\nWith Saturation maxed at 150%\nClick for safe HPLuv (no chroma distortion, pastel colors)", "tags": ["color", "rgb", "hue", "hsl", "husl", "hsluv"], "likes": 1, "viewed": 985, "date": "1501095679", "time_retrieved": "2024-06-20T18:57:56.250952", "image_code": "// http://www.hsluv.org/comparison/\n/*\nhttps://raw.githubusercontent.com/williammalo/hsluv-glsl/master/hsluv-glsl.fsh\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n    return (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n    return sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n    vec3 len = y / (sin(theta) - x * cos(theta));\n    if (len.r < 0.0) {len.r=1000.0;}\n    if (len.g < 0.0) {len.g=1000.0;}\n    if (len.b < 0.0) {len.b=1000.0;}\n    return len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub0 = L + 16.0;\n    float sub1 = sub0 * sub0 * sub0 * .000000641;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bounds0x = top1 / bottom;\n    vec3 bounds0y = top2 / bottom;\n\n    vec3 bounds1x =              top1 / (bottom+126452.0);\n    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n    float hrad = radians(H);\n\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bound0x = top1 / bottom;\n    vec3 bound0y = top2 / bottom;\n\n    vec3 bound1x =              top1 / (bottom+126452.0);\n    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    const mat3 m = mat3( \n        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n    \n    return hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n    float X = tuple.x;\n    float Y = tuple.y;\n    float Z = tuple.z;\n\n    float L = hsluv_yToL(Y);\n    \n    float div = 1./dot(tuple,vec3(1,15,3)); \n\n    return vec3(\n        1.,\n        (52. * (X*div) - 2.57179),\n        (117.* (Y*div) - 6.08816)\n    ) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float U = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 2.25 * U * Y / V;\n    float Z = (3./V - 5.)*Y - (X/3.);\n\n    return vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n    float L = tuple.x;\n    float U = tuple.y;\n    float V = tuple.z;\n\n    float C = length(tuple.yz);\n    float H = degrees(atan(V,U));\n    if (H < 0.0) {\n        H = 360.0 + H;\n    }\n    \n    return vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n    return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n    return lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n    return lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n    return lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n    return lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n    return xyzToRgb(luvToXyz(tuple));\n}\n\n#define PI (3.1415926535897)\n#define TWOPI (2.*3.1415926535897)\n/*\nfloat mmod(float x,float y)\n{\n    return mod(mod(x,y)+y,y);\n}\n\nfloat SmoothHue(float k)\n{\n    k *= 3.;\n    float q = floor(k);\n    k = mmod(k,1.);\n    //return (k+q)/3.;\n    //return ((1. - cos(k*PI))*.5+q)/6.;\n    return (smoothstep(0.,1.,k)+q)/3.;\n}\n*/\nvoid mainImage( out vec4 col, in vec2 coord )\n{\n\tvec2 uv = (coord.xy / iResolution.xy - vec2(.5));\n    uv.x *= iResolution.x/iResolution.y;\n    float r = length(uv);\n    vec3 hsluv = vec3(\n        atan(uv.y,uv.x)/TWOPI * mix( 1. , 4. , -cos(iTime*PI/13.)*.5+.5 ) + .25 ,\n        clamp(r*2.,.0,1.5), // Max Saturation is 150%\n        mix(.5,cos(log(r+0.05)*16.*PI)*.5+.5,clamp(r*3.,0.,1.))\n    );\n    \n    //hsluv.r = SmoothHue(hsluv.r);\n    \n    col.rgb = iMouse.z > .5\n        ? hpluvToRgb(hsluv*vec3(360.,100.,100.))\n        : hsluvToRgb(hsluv*vec3(360.,100.,100.))\n    ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSBRw", "name": "[SH17A] Nifty fractal", "author": "Bananaft", "description": "In 3D, beautiful and diverse, super detailed, colored and animated. It's a best deal! What do you waiting for? Go hit that \"Like\" button!\n\nCheck out full screen and alternative versions.\n", "tags": ["fractal", "raymarch", "280chars", "uglyhacks"], "likes": 11, "viewed": 347, "date": "1499887666", "time_retrieved": "2024-06-20T18:57:56.250952", "image_code": "//*    <-- switch versions on and off.\n// basic version, no texture \n#define K for (int i=0; i++ < 29;) \n#define T .1 * sin(-iTime*.2)\nvoid mainImage( out vec4 o,  vec2 w )\n{\n    vec4 p = vec4(w,0,1)/iResolution.x-.5,\n    q=p-p;\n    q.y =T*3.;\n    K\n    {\n        o = p-q;\n        K\n          o *= (1.7+T)/clamp(dot(o.xyz=abs(o.xyz+.5)-1., o.xyz), .2+T, 1.);\n        q +=p*length(o.xz)/o.w;\n     }\n\to.a /= -50.;\n    q.y *= q.z;\n    o = 2. * q.zyxw +   o.aggg / 1e7;\n}\n//*/\n\n/*\n// 280 textured\n#define K for (int i=0; i < 27; i++) \n#define T .1 * sin(-iTime*.2)\n\nvoid mainImage( out vec4 o,  vec2 w )\n{\n    \n    //uncoment second for fullscreen:\n    vec4 p = vec4(w,0,1)/iResolution.x-.5,\n    q=p-p;\n    q.y =T*3.;\n    K\n    {\n        o = p-q;\n        K\n           o *= (1.7+T)/clamp(dot(o.xyz=abs(o.xyz+.5)-1., o.xyz), .2+T, 1.);\n        q +=p*length(o.xz)/o.w;\n\t\t\n        \n    }\n    \n\to =2. * q.xzzw + texture(iChannel0,o.gg*8e-9);\n}\n\n//*/\n\n\n/*\n// 228 chars fog only version\n#define K for (int i=0; i++ < 32;) \n#define T .1 * sin(-iTime*.2)\n\nvoid mainImage( out vec4 o,  vec2 w )\n{\n    \n    vec4 p = vec4(w,0,1)/7e2-.6, q=p-p;\n    K\n    {\n        o = p-q;\n        K\n          o *= (1.7+T)/clamp(dot(o.xyz=abs(o.xyz+.5)-1., o.xyz), .2+T, 1.);\n        q +=p*length(o.xz)/o.w;\n     }\n\n\to = q.zyxz;\n}\n//*/\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSBRz", "name": "Ocean Waves 1", "author": "AlexM", "description": "Trying out some of the water stuff. This one uses sum of sines approach described in GPUgems.", "tags": ["oceanwaterheightmap"], "likes": 8, "viewed": 544, "date": "1499089365", "time_retrieved": "2024-06-20T18:57:58.135830", "image_code": "\n// Trying out some ocean water using sum of sines approach described in GPUgems (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch01.html)\n// Looks more like jello rather than actual water though.\n// This whole thing breaks down if camera is under the water surface... \n\n#define PI 3.141592653589793 \n\nconst float WORLEYMAXDIST = 1.3; // worley noise max distance\nconst float MAXLENGTH = 190.0; // maximum ray length\n\n\nconst float FOGHEIGHT = 0.01; // background fog height. \nconst float FOGFADEHEIGHT = 0.30; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.839, 1, 0.980);\nconst float FOGDENSITY = 0.010; \n\nconst vec3  OCEAN_COLOR = vec3(0.164, 0.345, 0.454); // water color\nconst vec3  OCEAN_REFRACTION_COLOR = vec3(0.0, 0.1, 0.8); // Color we fall back to if the ocean floor is beyond the maximum visibility distance.\nconst vec3  OCEAN_ABSORBANCE = vec3(0.6, 0.25, 0.30);\nconst float OCEAN_ABSORBANCE_SCALE = 0.09;\nconst float OCEAN_FRESNEL_POW = 2.0;\nconst float OCEAN_SPEC_FACTOR = 90.0;\nconst float N1 = 1.0;  // refractive index 1 - air\nconst float N2 = 1.32; // refractive index 2 - ocean \n\nconst vec3  SUNDIRECTION = normalize(vec3(1.0, -0.4, -0.9)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(1.0, 0.949, 0.839); // sun color? \nconst float SUNINTENSITY = 1.2;\n\nconst vec3  SKYCOLOR = vec3(0.513, 0.882, 0.945);\nconst float SKYCLOUDSCALE = 11.0;\n\nconst float CONTRAST = 0.20;\nconst float BRIGHTNESS = 1.8;\nconst float GAMMA = 1.2;  // higher => darker; lower => brighter\nconst float SATURATION = 1.8;\n\n\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    int materialID;\n};\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nfloat noise2D(vec2 uv) {\n    vec2 st = 0.1 * uv; \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat worley(vec2 uv) {\n\tvec2 tileCoord = floor(uv);    \n    float dist = 90000.0;\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec2 currentTile = tileCoord + vec2(x, y);\n        vec2 point = currentTile + random(currentTile);\n        dist = min(dist, length(point-uv)); \n    }\n    dist = clamp(dist, 0.0, WORLEYMAXDIST) / WORLEYMAXDIST;\n    return dist;\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitud = 1.0;\n    float frequency = 0.25;\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitud * noise2D(st * frequency);\n        st *= 2.;\n        amplitud *= .10;\n        frequency *= 0.5;\n    }\n    return value;\n}\n\nfloat fbm_ridgesin(vec2 st) {\n    float value = 0.0;\n    float amplitude = 0.9;\n    float frequency = 0.50;\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        float noise = sin(dot(vec2(0.0, 1.0),st)*frequency* 0.9+3.0*noise2D(st*frequency*5.0)); \n        float temp = amplitude*abs(noise); \n        value += pow(temp, 3.0); \n        st *= 2.;\n        amplitude *= .50;\n        frequency *= 0.8;\n    }\n    return value;\n}\n\nfloat oceanfloor(vec2 st, out int mattype) {\n    // sand \n    float h = 0.0;    \n    h = fbm_ridgesin(st*15.0) * 0.02;\n    h += noise2D(st * 1.3) * 4.5;\n    // fake seaweed\n    float f = (1.0-worley(st * 2.5)) * 0.25;\n    f += noise2D(st * 2.0) * 2.0;\n    h = max(f, h);\n    mattype = 1; \n    if (h == f) mattype = 2;\n    return h * 1.1 - 50.0;\n}\n\n// wrapper with materialID hidden.\nfloat oceanfloor(vec2 st) { int unused; return oceanfloor(st, unused); }\n\nTraceResult traceOceanFloor(vec3 ro, vec3 rd, float dstep) {\n    TraceResult traceResult = TraceResult(false, 0.0, 0);\n    \n    float t = 0.02;\n    float tmax = MAXLENGTH;\n    for (;t < tmax;) {\n        int m = 0;\n        vec3 rp = ro + rd * t;\n        float h = oceanfloor(rp.xz, m);\n        float d = rp.y - h;\n\n        if (d < 0.01) {\n            traceResult = TraceResult(true, t, m);\n            break;\n        }\n        t += dstep * d;\n    }\n\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 getOceanFloorNormal(vec3 rp) {\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 normal = normalize(vec3( \n        oceanfloor(rp.xz - eps.xy) - oceanfloor(rp.xz + eps.xy),\n        2.0 * eps.x, \n        oceanfloor(rp.xz - eps.yx) - oceanfloor(rp.xz + eps.yx) \n    ));\n    return normal;\n}\n\n/// WATER SURFACE \n// 1- amplitude, 2 - frequency, 3 - speed;\nfloat oceanSurface(vec2 st, out int mattype) {\n    float time = iTime * 3.5;\n    float h = 3.0;\n    h += 0.35*sin(dot(vec2( 0.0, 1.0),st)*0.5+5.0*noise2D(st*0.1)+time*0.50); \n    h += 0.45*sin(dot(vec2(-1.4, 0.8),st)*0.1+5.0*noise2D(st*0.5)+time*0.45); \n    h += 0.15*sin(dot(vec2( 0.4, 1.0),st)*0.4+3.0*noise2D(st*3.0)+time*0.60); \n    h += 0.09*sin(dot(vec2(-0.3, 1.0),st)*0.9+3.0*noise2D(st*4.0)+time*0.92); \n    h+=fbm(st*50.0+time*4.0)*0.06;\n    mattype = 3;\n    return h;\n}\n\n// wrapper with materialID hidden.\nfloat oceanSurface(vec2 st) { int unused; return oceanSurface(st, unused); }\n\nTraceResult traceOceanSurface(vec3 ro, vec3 rd, float dstep) {\n    TraceResult traceResult = TraceResult(false, 0.0, 0);\n\n    float t = 0.02;\n    float tmax = MAXLENGTH;\n    for (;t < tmax;) {\n        int m = 0;\n        vec3 rp = ro + rd * t;\n        float h = oceanSurface(rp.xz, m);\n        float d = rp.y - h;\n\n        if (d < 0.01) {\n            traceResult = TraceResult(true, t, m);\n            break;\n        }\n        t += dstep * d;\n    }\n\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 getOceanSurfaceNoraml(vec3 rp) {\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 normal = normalize(vec3( \n        oceanSurface(rp.xz - eps.xy) - oceanSurface(rp.xz + eps.xy),\n        2.0 * eps.x, \n        oceanSurface(rp.xz - eps.yx) - oceanSurface(rp.xz + eps.yx) \n    ));\n\n    return normal;\n}\n\nfloat bad_ao(vec3 n) {\n    return abs(dot(n, vec3(0.0, 1.0, 0.0))); \n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, 2.0));\n}\n\n// borrowed this from a certain thread on pouet\nvec3 postprocess(vec3 color) {\n    color = color * BRIGHTNESS;\n    color = pow(color, vec3(GAMMA));\n    color = color * 0.5 + CONTRAST * 0.5;\n    float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n    color = luminance + (color - luminance) * SATURATION;\n    return clamp(color, 0.0, 1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float time = iTime * 10.0;\n    // borrowed it from one of iq's demos, hopefully no one will notice...\n    color += smoothstep(0.3, 1.0, fbm(rd.xz*SKYCLOUDSCALE/ rd.y + time*0.15));\n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat phongAmbientFactor(void) {\n    return 0.1;\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\n//@v - view direction, normalized;\n//@k - shininess constant;\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nvoid getMaterial(int mattype, vec3 rp, out vec3 color1, out vec3 color2, \n                                       out float smin, out float smax,\n                                       out float vmin, out float vmax) {\n    // texture slope fade constants\n    // anything below smin slope uses grass texture, anything above uses rock texture,\n    // values between are lerped.\n    smin = 0.02;  \n    smax = 0.09;\n\n    // terrain detail texture\n    vmin = 0.95;\n    vmax = 1.0;\n\n    // default colors\n    color1 = vec3(1.0, 0.0, 0.0);\n    color2 = vec3(1.0, 0.0, 0.0);\n\n    if (mattype == 1) {\n        color1 = vec3(1, 0.937, 0.678); //  snow color;\n        color2 = vec3(0.900, 0.815, 0.539); // rock \n    }\n    if (mattype == 2) {\n        color1 = vec3(0, 0.301, 0.047); //  tree base;\n        color2 = vec3(0.341, 0.784, 0.317); //   tree top;\n        color1 = color1 + vec3(noise2D(rp.xz * 9.0),  noise2D(rp.zx * 2.0), noise2D(rp.zx)) * 0.10;\n        color2 = color2 + vec3(noise2D(rp.xz * 5.0),  noise2D(rp.zx * 9.0), noise2D(rp.zx)) * 0.10;\n        smin = 0.09;\n        smax = 0.14;\n        vmin = 0.2;\n        vmax = 1.0;\n    }\n    if (mattype == 3) {\n        color1 = OCEAN_COLOR;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color1, color2;\n    float smin, smax, vmin, vmax;\n    vec2 eps = vec2(0.1, 0.0);\n    \n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.002+0.785) * rotateX(iMouse.y*0.002-0.25)  * rd;\n    rd = normalize(rd);\n \n    vec3 ro = vec3(0.0, 10.0, 0.0); \n    ro += iTime * 0.4 * normalize(vec3(-1.0, 0.0, 1.0));\n\n    // trace ocean surface\n    TraceResult oceanSurfaceTrace = traceOceanSurface(ro, rd, 0.30);\n    vec3 rp = ro + oceanSurfaceTrace.rayt * rd;\n    vec3 n = getOceanSurfaceNoraml(rp);\n    float saf = phongAmbientFactor();\n    float sdf = phongDiffuseFactor(-SUNDIRECTION, n);\n    float ssf = phongSpecularFactor(-SUNDIRECTION, n, rd, OCEAN_SPEC_FACTOR);\n\n    // compute fresnel factor for the water surface \n    float fr = pow(dot(n, -rd), OCEAN_FRESNEL_POW);\n\n    // compute reflection color;\n    vec3 refl_color = OCEAN_COLOR * 0.3;\n    vec3 refl_ro = rp + eps.yxy;\n    vec3 refl_rd = reflect(rd,n);\n    TraceResult reflectionTraceResult = traceOceanSurface(refl_ro,refl_rd,0.5);\n    if (reflectionTraceResult.hit) refl_color = sky(refl_ro, refl_rd) * 0.2;\n    \n    // compute refraction\n    vec3 refr_color = OCEAN_REFRACTION_COLOR * 0.1;\n    float eta = N1/N2;\n    vec3 refr_ro = rp - eps.yxy;\n    vec3 refr_rd = refract(rd, n, eta);\n    TraceResult refractionTraceResult = traceOceanFloor(refr_ro, refr_rd, 0.2);\n    if (refractionTraceResult.hit) {\n        // compute lighting of the the seafloor\n        vec3 refr_rp = refr_ro + refractionTraceResult.rayt * refr_rd;\n        vec3 refr_n = getOceanFloorNormal(refr_rp);\n        float faf = phongAmbientFactor();\n        float fdf = phongDiffuseFactor(-SUNDIRECTION, refr_n);\n        getMaterial(refractionTraceResult.materialID, refr_rp, color1, color2, smin, smax, vmin, vmax);\n\n        float slopefactor = 1.0 - abs(dot(refr_n, vec3(0.0, 1.0, 0.0)));\n        slopefactor = clamp(slopefactor, smin, smax);\n        slopefactor = (slopefactor-smin) / (smax - smin);\n        refr_color = mix(color1, color2, slopefactor);\n\n        float ao = bad_ao(refr_n);\n        vec3 absorbance = exp(-OCEAN_ABSORBANCE*OCEAN_ABSORBANCE_SCALE*refractionTraceResult.rayt);\n\n        refr_color = refr_color*faf*ao + refr_color*fdf;\n        refr_color *= absorbance;\n        refr_color *= SUNCOLOR * SUNINTENSITY;\n        refr_color = clamp(refr_color, 0.0, 1.0);\n    } \n    refl_color = refr_color*fr+(1.0-fr)*refl_color;\n\n    getMaterial(oceanSurfaceTrace.materialID, rp, color1, color2, smin, smax, vmin, vmax);\n\n    vec3 color = clamp(color1*saf+color1*sdf+ssf+refl_color, 0.0, 1.0);\n    color *= SUNCOLOR * SUNINTENSITY;\n    color = mix(color, FOGCOLOR, fog(oceanSurfaceTrace.rayt));\n    if (!oceanSurfaceTrace.hit)  color = sky(ro, rd); \n    color = postprocess(color);\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSBWR", "name": " Hexagons", "author": "Torumu106", "description": "I wrote hexagon.", "tags": ["hexagon", "shader", "polygon"], "likes": 2, "viewed": 167, "date": "1500000766", "time_retrieved": "2024-06-20T18:57:58.135830", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n    float sqrt3 = 1.73205;\n    r *= 2.5;\n    \n    float the = 0.0 + iTime * 0.3;\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec2 r1 = abs(r);\n    r1.y += 1.0 * r1.x / sqrt3;\n    if(r1.x <= 0.5 *  sqrt3 && r1.y  <= 1.0){\n    \tret = vec3(1.0);\n    }\n    vec2 r2 = abs(r - vec2(sqrt3 * 0.5, -1.5));\n    r2.y += 1.0 * r2.x / sqrt3;\n    if(r2.x <= 0.5 *  sqrt3 && r2.y  <= 1.0){\n    \tret = vec3(1.0, 0.0, 0.0);\n    }\n    vec2 r3 = abs(r - vec2(sqrt3 * 0.5, 1.5));\n    r3.y += 1.0 * r3.x / sqrt3;\n    if(r3.x <= 0.5 *  sqrt3 && r3.y  <= 1.0){\n    \tret = vec3(0.0, 1.0, 0.0);\n    }\n    vec2 r4 = abs(r - vec2(sqrt3, 0.0));\n    r4.y += 1.0 * r4.x / sqrt3;\n    if(r4.x <= 0.5 *  sqrt3 && r4.y  <= 1.0){\n    \tret = vec3(1.0, 1.0, 0.0);\n    }\n    vec2 r5 = abs(r - vec2(-sqrt3, 0.0));\n    r5.y += 1.0 * r5.x / sqrt3;\n    if(r5.x <= 0.5 *  sqrt3 && r5.y  <= 1.0){\n    \tret = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 r6 = abs(r - vec2(-sqrt3 * 0.5, 1.5));\n    r6.y += 1.0 * r6.x / sqrt3;\n    if(r6.x <= 0.5 *  sqrt3 && r6.y  <= 1.0){\n    \tret = vec3(0.0, 1.0, 1.0);\n    }\n    vec2 r7 = abs(r - vec2(-sqrt3 * 0.5, -1.5));\n    r7.y += 1.0 * r7.x / sqrt3;\n    if(r7.x <= 0.5 *  sqrt3 && r7.y  <= 1.0){\n    \tret = vec3(1.0, 0.0, 1.0);\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSBzz", "name": "Voronoi Rocks", "author": "dr2", "description": "Rocks in shallow water (mouse enabled)", "tags": ["voronoi", "reflection", "waves", "water", "rocks", "foam"], "likes": 9, "viewed": 788, "date": "1499104443", "time_retrieved": "2024-06-20T18:57:59.923881", "image_code": "// \"Voronoi Rocks\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\n\nvec3 sunDir, waterDisp, cloudDisp;\nvec2 gVec[7], hVec[7];\nfloat dstFar, dstObj, tCur;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 vc;\n  float d;\n  vc = HexVor (p.xz);\n  d = p.y - max (SmoothMin (0.6, SmoothMax (0., vc.x, 0.6), 0.3) *\n     (1. + vc.w) * (1. - dot (vc.yz, vc.yz)), 0.) *\n     (1. - smoothstep (0.8, 1., dstObj / dstFar));\n  return 0.5 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.5;  wAmp = 0.1;  pRough = 5.;\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t2 = 0.6 * tCur * vec2 (1., -1.);\n    t4 = vec4 (q2 + t2.xx, q2 + t2.yy) * wFreq;\n    t2 = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + abs (cos (t4)));\n    v2 = pow (1. - sqrt (v4.xz * v4.yw), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.25;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return 0.2 + ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = 0.;\n    sLo = 0.;\n    for (int j = 0; j < 80; j ++) {\n      p = ro + s * rd;\n      h = p.y - WaveHt (p);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.3, h) + 0.005 * s;\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        h = step (0., p.y - WaveHt (p));\n        sLo += h * (s - sLo);\n        sHi += (1. - h) * (s - sHi);\n      }\n      dHit = sHi;\n    }\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  float ht = WaveHt (p);\n  return normalize (vec3 (ht - WaveHt (p + e.xyy), e.x, ht - WaveHt (p + e.yyx)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  sd = pow (max (dot (rd, sunDir), 0.), 64.);\n  col = vec3 (0.1, 0.2, 0.5) + 0.1 * pow (1. - max (rd.y, 0.), 4.) +\n     (0.35 * sd + 0.65 * min (pow (sd, 4.), 0.3)) * vec3 (1., 1., 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col;\n  float dstWat, s;\n  bool waterRefl;\n  HexVorInit ();\n  dstObj = ObjRay (ro, rd);\n  dstWat = WaveRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    rd = reflect (rd, WaveNf (ro, dstWat));\n    ro += 0.1 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vc = HexVor (ro.xz);\n    vn = VaryNf (16. * ro, ObjNf (ro), 10.);\n    s = Noisefv3 (8. * (1. + vc.w) * ro);\n    if (ro.y > 0.05) col = mix (vec3 (0.3, 0.45, 0.3) * (0.8 + 0.4 * vc.w),\n       vec3 (0.5 * (1. + 0.2 * vc.w), 0.6, 0.6),\n       smoothstep (0.3, 0.5, s) * smoothstep (0.3, 0.4, ro.y)) * (1. - 0.1 * s) *\n       (0.6 + 0.4 * smoothstep (0.3, 0.5, ro.y));\n    else col = vec3 (0.);\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n       0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.));\n  } else col = SkyCol (ro, rd);\n  if (waterRefl) {\n    col = mix (mix (vec3 (0.1, 0.15, 0.1), vec3 (0.1, 0.1, 0.12),\n       smoothstep (0.4, 0.6, Fbm2 (10. * ro.xz))),\n       0.8 * col, 1. - pow (abs (rd.y), 3.));\n    col = mix (col, vec3 (0.7), pow (clamp (WaveHt (ro) +\n       0.75 * Fbm3 (2. * ro), 0., 1.), 8.));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.3 * pi * sin (0.03 * pi * tCur);\n  el = -0.3 * pi + 0.15 * pi * sin (0.022 * pi * tCur);\n  if (mPtr.z > 0.) {\n    el = clamp (el + pi * mPtr.y, -0.4 * pi, 0.4 * pi);\n    az = az + 2.5 * pi * mPtr.x;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.5));\n  ro.z = 0.3 * tCur;\n  ro.y = 4.;\n  dstFar = 50.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  waterDisp = 0.1 * tCur * vec3 (1., 0., 1.);\n  cloudDisp = 0.5 * tCur * vec3 (1., 0., 0.);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p = 2. * p.yzx;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSfRK", "name": "More Tentacles 1", "author": "AlexM", "description": "Trying some tentacles, this time with cell noise. A bit too slow though. ", "tags": ["organic", "tentacles"], "likes": 15, "viewed": 314, "date": "1501096423", "time_retrieved": "2024-06-20T18:58:01.342126", "image_code": "// Trying some some more tentacles.... this time with cell noise. \n#define PI 3.141592653589793 \n\nconst float MAXT = 70.0f;\nconst float FOGHEIGHT = 0.01; // background fog height. \nconst float FOGFADEHEIGHT = 0.30; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.839, 1, 0.980);\nconst float FOGDENSITY = 0.022; \n\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    vec3 color; \n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    vec3 u = x*x*(3.0-2.0*x);\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(2.0*fg-1.0, -1.0, 1.0);\n}\n\nfloat sdSpheroid(vec3 p, vec3 s) {\n    return (length(p/s) - 1.0)  * min(s.x, min(s.y, s.z));\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) - n.w;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat opAddSmooth( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opSubtract( float a, float b ) {\n    return max(-a,b);\n}\n\nfloat opAdd(float a, float b) {\n    return min(a,b);\n}\n\nvec3 opRepeat(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat worley_smooth(vec3 p) {\n    vec3 tileCoord = floor(p);    \n    float dist = 90000.0;\n    float heightoffset = 0.0;\n    for (int z = -1; z <= 1; z++)\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec3 currentTile = tileCoord + vec3(x,y,z);\n        vec3 point = currentTile + random(currentTile);\n\n        float d = distance(point, p);\n        dist = opAddSmooth(dist, d, 0.05);\n    }\n    return -dist;\n}\n\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.8;\n\n    const int octaves = 5;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(p*frequency);\n        p *= 2.;\n        amplitude *= 0.3;\n        frequency *= 1.4;\n    }\n    return value;\n}\n\nvec4 map(vec3 p) {\n    // tentacle\n    p.x -= noise(p.zz*0.2+iTime*0.04) * 2.25;\n    p.y -= noise(p.xy*0.2+iTime*0.10) * 1.20;\n    float tube = length(p.xy)-1.75; \n\n    for (int i = 1; i < 5; i++) {\n        vec3 pt = p - vec3(0.0,0.0,float(i)*20.0);\n        pt = rotateZ(1.75*float(i))*pt;\n        pt = opRepeat(pt, vec3(0.0, 0.0, 60.0));\n\n        float sphere = sdSpheroid(pt-vec3(0.0, 12.0, 0.0), vec3(6.0, 5.0, 6.0));\n        float stube = length(pt.xz) - 1.2;\n        float plane = sdPlane(pt, vec4(0.0,1.0,0.0,0.0));\n\n        stube = opSubtract(plane, stube);\n        stube = opAddSmooth(sphere, stube, 5.5);\n        tube = opAddSmooth(stube, tube, 0.75);\n    }\n\n    // outer walls\n    float box1 = length(p.xy) -12.0;\n    float box2 = length(p.xy) -10.0;\n    box1 = opSubtract(box2, box1);\n    tube = opAddSmooth(box1, tube, 4.0);\n\n    vec3 color = vec3(0.964, 0.482, 0.454); // default body color;\n    vec3 cavity_color = vec3(0.403, 0.090, 0.074); // color between cells.\n    vec3 veins_color = vec3(0.027, 0.117, 0.333);\n\n    float f = worley_smooth(p*0.5-iTime*0.04)*0.7;\n    color = mix(color, cavity_color, abs(f)*2.5);  \n\n    // veins @OPTIMIZE this is still slow!!! \n    float a = 0.25*(1.0-abs(fbm(p*1.0+iTime*0.06))); \n    float c = 0.01*(1.0-abs(fbm(p*9.2+iTime*0.03))); \n    float veins = a+c;\n    float sm = smoothstep(0.0, 1.0, veins*2.0);\n    color = mix(color, veins_color, sm);\n\n    return vec4((tube-f-veins)*0.75, color);\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    TraceResult traceResult = TraceResult(false, 0.0, vec3(0.0));\n    float t = 0.02;\n    float tmax = MAXT; \n    for (;t < tmax;) {\n        vec3 rp = ro + rd * t;\n        vec4 tr = map(rp);\n        if (tr.x<0.001) {\n            traceResult = TraceResult(true, t, tr.yzw);\n            break;\n        }\n        t += tr.x;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = map(p+eps.xyy).x-map(p-eps.xyy).x;\n    float y = map(p+eps.yxy).x-map(p-eps.yxy).x;\n    float z = map(p+eps.yyx).x-map(p-eps.yyx).x;\n    return normalize(vec3(x,y,z));\n}\n\n// based on a function in IQ's shadertoy \n//https://www.shadertoy.com/view/Xdl3R4\nfloat calcSurfaceThickness(vec3 ro, vec3 rd, float p) {\n    float w = 1.0;\n    float a = 0.0;\n    const int numsteps = 4;\n    for (int t = 1; t <= numsteps; t++) {\n        float rt = 0.1*float(t); \n        float d = map(ro+rt*rd).x;\n        a += w*(rt-min(d,0.0));\n        w *= 0.9;\n    }\n\n    return pow(clamp(1.2-0.25*a, 0.0, 1.0), p);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float w = 1.0;\n    float a = 0.0;\n    const int maxsteps = 4;\n    for (int t = 1; t <= maxsteps; t++) { \n        float rt = 0.2*float(t);\n    \ta += w*(rt-map(p+rt*n).x);   \n        w *= 0.8;\n    }\n    \n    return clamp(1.0-a, 0.0, 1.0);\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\n//@v - view direction, normalized;\n//@k - shininess constant;\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, 2.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.008) * rotateX(iMouse.y*0.004)* rd;\n    rd = normalize(rd);\n\n    vec3 ro = vec3(2.0, 4.0, 0.0); \n    ro += iTime*0.3*normalize(vec3(0.0, 0.0, 1.0));\n\n    vec3 color = FOGCOLOR;\n    TraceResult traceResult = trace(ro, rd);\n    if (traceResult.hit) {\n\n        vec3 rp = ro+traceResult.rayt*rd;\n\n        vec3 n = calcNormal(rp);\n\n        // calculate surface thickness \n        float thickness = calcSurfaceThickness(rp-n*0.01, rd, 20.0) * 4.0;\n        float ao = calcAO(rp, n);\n\n        vec3 c = traceResult.color;\n\n        vec3 SUNDIRECTION = rd;\n        float ph = 0.5*ao + phongDiffuseFactor(-SUNDIRECTION, n) * 0.5 \n                          + phongSpecularFactor(-SUNDIRECTION,n, rd, 50.0) * 0.5;\n        float ph2 = phongDiffuseFactor(-SUNDIRECTION, n) ;\n        color = ph*c+c*thickness;\n        color = mix(color, FOGCOLOR, fog(traceResult.rayt));\n    }\n\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSfz3", "name": "Fire Test Eddie", "author": "eddietree", "description": "fire", "tags": ["fire"], "likes": 2, "viewed": 118, "date": "1501403902", "time_retrieved": "2024-06-20T18:58:01.348371", "image_code": "/*float random(in vec2 st)\n{\n    vec4 noiseVal = texture(iChannel0, st * 700485.233);\n    return noiseVal.x*2.0-1.0;\n}\n*/\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123) * 2.0 - 1.0;\n}\n\n\nfloat noise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float uvDelta = 1.0;// / 64.0;\n    \n    float a = random(i);\n    float b = random(i + vec2(uvDelta,0.0));\n    float c = random(i + vec2(0.0,uvDelta));\n    float d = random(i + vec2(uvDelta,uvDelta));\n    \n    vec2 u = smoothstep(vec2(0.0), vec2(1.0), f);\n    \n   return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// from bookofshaders\n#define OCTAVES 7\nfloat fbm(in vec2 st)\n{\n    float value = 0.0;\n    float amp = 0.6;\n    float freq = 0.0;\n    \n    for(int i = 0; i < OCTAVES; ++i)\n    {\n        value += amp * abs(noise(st));\n        st *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return value;\n}\n\nfloat pattern(in vec2 st)\n{\n    // f(p) = fbm(p + fmb(p))\n    \n    vec2 q = vec2(fbm(st + vec2(iTime*0.3, -iTime*0.4333)), fbm(st+vec2(70442.3, 1042.9423+iTime*-0.1)));\n    return fbm(st+q) * 1.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvOrigin = fragCoord.xy / iResolution.xy;\n    vec2 uv = uvOrigin;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float patVal = pattern(uv*vec2(2.0,1.0) + vec2(0.0, iTime*-0.5));\n    \n    patVal *= smoothstep(0.2, 0.4, 1.2-uvOrigin.y - fbm(uv*1.0 + vec2(0.0,-iTime)));\n    patVal *= 1.0-smoothstep(0.1, 0.2, abs(uvOrigin.x-0.5) +fbm(uv*0.4 + vec2(0.0,-iTime*0.4))*0.1);\n    \n    vec3 color = vec3(0.0);\n    \n    color.xyz = mix( vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.0), smoothstep(0.0,0.7,patVal));\n    color.xyz = mix( color.xyz, vec3(1.0,1.0,0.1), smoothstep(0.4,0.9,patVal));\n    color.xyz = mix( color.xyz, vec3(1.0,1.0,1.0), smoothstep(0.7,1.0,patVal));\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSfzm", "name": "[SH17A] Raymarched Plasma", "author": "Himred", "description": "For fun", "tags": ["raymarch", "plasma", "sh17a"], "likes": 19, "viewed": 1157, "date": "1499890550", "time_retrieved": "2024-06-20T18:58:01.348371", "image_code": "// Raymarched plasma\n// Idea based on iq 2 tweet raymarch: https://www.shadertoy.com/view/MsfGzM\n\nfloat m(vec3 p) \n{ \n\tp.z+=5.*iTime; \n    return length(.2*sin(p.x-p.y)+cos(p/3.))-.8;\n    //return length(.2*sin(p.x-p.y)+cos(p/3.)-.1*sin(1.5*p.x))-.8;\n \n}\n\nvoid mainImage(out vec4 c,vec2 u)\n{\n    vec3 d=.5-vec3(u,0)/iResolution.x,o=d;\n    for(int i=0;i<64;i++) o+=m(o)*d;\n    c.xyz = abs(m(o+d)*vec3(.3,.15,.1)+m(o*.5)*vec3(.1,.05,0))*(8.-o.x/2.);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llB3W3", "name": "aadeon - Voronoi Diagram ", "author": "aadeon", "description": "asdfas", "tags": ["voronoi"], "likes": 0, "viewed": 105, "date": "1500429101", "time_retrieved": "2024-06-20T18:58:01.348371", "image_code": "#define NUM_POINTS 11\n#define PI 3.14159\n\nstruct point\n{\n \tvec2 pos;\n    vec3 color;\n};\n\npoint newPoint(vec2 pos, vec3 color)\n{\n    point p;\n    p.pos = pos;\n    p.color = color;\n    return p;\n}\n\n//euclidean distance\nfloat eDist(vec2 p, vec2 q)\n{\n \treturn length(p - q);   \n}\n\n//manhattan distance\nfloat mDist(vec2 p, vec2 q)\n{\n \treturn abs(p.x-q.x)+abs(p.y-q.y);   \n}\n\n//chebyshev distance\nfloat chDist(vec2 p, vec2 q)\n{\n  \treturn max(abs(p.x-q.x), abs(p.y-q.y));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = 50.0+iMouse.y/2.0;\n    vec2 uv = (((fragCoord.xy / iResolution.xy)*2.0-1.0)*(vec2(1.0, iResolution.y/iResolution.x))*zoom/iResolution.y/.1);\n    \n    \n    float t = iTime / 2.0;\n    \n    point points[NUM_POINTS];\n    points[0] = newPoint(vec2( 0.5+tan(.1*t),  0.0+.29*sin(2.0*t)), vec3(1.0, 0.0, 0.0));\n    points[1] = newPoint(vec2( 0.3+sin(t)+.1*cos(5.0*t),  0.0), vec3(0.0, 1.0, 0.0));\n    points[2] = newPoint(vec2( 0.5+.1*sin(7.0*t), -0.5+.1*cos(7.0*t)), vec3(0.0, 0.0, 1.0));\n    points[3] = newPoint(vec2( 0.0-tan(.44*t), 0.3), vec3(1.0, 1.0, 0.0));\n    points[4] = newPoint(vec2( 0.1+sin(t),  0.0+.05*sin(15.0*t)), vec3(0.0, 1.0, 1.0));\n    points[5] = newPoint(vec2( 0.0, -0.505), vec3(1.0, 0.0, 1.0));\n    points[6] = newPoint(vec2(-0.5+tan(t),  0.5), vec3(1.0, 0.5, 0.0));\n    points[7] = newPoint(vec2(-0.5+.3*cos(.33*t),  0.1+.18*cos(.23*t)), vec3(0.0, 0.6, 0.4));\n    points[8] = newPoint(vec2(-0.5+.002*t, -0.5+.002*t), vec3(0.5, 0.3, 1.0));\n    points[9] = newPoint(vec2( pow(sin(t), 2.0), .1/cos(.42*t) ), vec3(.65, 0.6, 0.55));\n    points[10]= newPoint(vec2(sin(t), cos(t)), vec3(1.0, 1.0, 1.0));\n    \n    point closest = points[0];\n    float distClosest;\n    \n    for(int i=0; i<=NUM_POINTS; i++)\n    {\n        float distThis = eDist(uv, points[i].pos);\n        distClosest = eDist(uv, closest.pos);\n        \n\t\tif(distThis < distClosest)\n        {\n            closest = points[i];\n        }\n    }\n    \n    if (iMouse.x <iResolution.x/2.0)\n    {\n    \n        if (distClosest < .01)\n        {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);   \n        }\n        else\n        {\n            fragColor = vec4(closest.color, 0.0);\n        }\n    \t\n    }\n    else\n    {\n        fragColor = (vec4(0.0, 0.0, 0.0, 0.0)+distClosest* vec4(1.0, 1.0, 1.0, 1.0));\n        \n        \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llB3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2BzD", "name": "Sine Effect", "author": "andreasleeb", "description": "Sine effect", "tags": ["2d", "wave", "color", "effect", "sine"], "likes": 4, "viewed": 243, "date": "1499847993", "time_retrieved": "2024-06-20T18:58:01.348371", "image_code": "#define PI 3.14159265359\n\nfloat hardWave(in vec2 xy, in float amplitude, in float frequency, in float phase, in float speed, in float thickness) {\n    float delta = thickness / 2.;\n    float value = amplitude * sin(.56 * PI * frequency * xy.x + iTime * speed + phase);\n    float deviation = xy.y - value;\n    return (step(-delta, deviation) - step(delta, deviation)) * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    fragColor = vec4(0.);\n    float time = iTime + 204.;\n    \n    for(float i = 1.; i < 20.; i++) {\n        uv.y += .06 * sin(uv.x * .7 * time);\n        \n        //fragColor += hardWave(uv, .1, 1., 0., 1., .05) * .3 * vec4(.7, .2, 1., 1.);\n        fragColor += hardWave(uv, .1, 1., 0., 1., .05) * .3 * vec4(sin(time), .2, sin(time / 2.), 1.);\n        \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2BzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2Bzy", "name": "[SH17B] Adventure Time", "author": "spolsh", "description": "Move the mouse and find out which parts of Jake move.\nBased on Jake of Adventure Time.\nWanted to participate with little time to spare for coding, enjoy!", "tags": ["2d", "time", "cartoon", "adventure", "jake", "sh17b", "klos"], "likes": 14, "viewed": 1096, "date": "1501029789", "time_retrieved": "2024-06-20T18:58:01.356016", "image_code": "// [SH17B] Adventure Time\n// by Michal \"spolsh\" Klos 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n#define BG vec3(249.0/255.0, 192.0/255.0, 41.0/255.0)\n#define MOUNTH0 vec3(0.5, 0.0, 0.2)\n#define MOUNTH1 vec3(0.9, 0.4, 0.4)\n#define DBG vec3(1.0, 0.0, 1.0)\n#define STROKE 0.005\n\n#define RES iResolution\n#define FRAG fragCoord\n#define T (40.0*iTime)\n#define t (2.0*iTime)\n#define M (iMouse.xy)\n\nfloat udBox( vec2 p, vec2 b )\n{ // by iq\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{ // by iq\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = FRAG/RES.xy-0.5;\n    uv.y *= RES.y/RES.x; \n    //uv *= vec2(1.5);\n    uv += 0.01*vec2(cos(t),sin(t));\n    uv.y += 0.05;\n        \n    float irisMove = 0.002*sin(T);\n    vec2 facePos\t= vec2(0.0, 0.15);\n    vec2 eyePos0\t= facePos +vec2( 0.14, 0.0);\n    vec2 eyePos1\t= facePos +vec2(-0.14, 0.0);\n    vec2 irisPos0\t= eyePos0 +vec2(0.017 +irisMove, 0.025);\n    vec2 irisPos1\t= eyePos1 +vec2(0.017 +irisMove, 0.025);\n    vec2 irisPos2\t= eyePos0 +vec2(-0.04 +irisMove, -0.052);\n    vec2 irisPos3\t= eyePos1 +vec2(-0.04 +irisMove, -0.052);    \n    vec2 nosePos\t= facePos +vec2(0.0, -0.05);\n    vec2 moustachePos0\t= facePos +vec2(0.0, -0.05);\n    vec2 moustachePos1\t= facePos +vec2(0.0, -0.20);    \n    vec2 handsPos = vec2(0.0, -0.2) + vec2(0.0, 0.01*sin(t));\n    vec2 lidPos\t= vec2(0.0, -0.09);\n    \n    vec2 mouseDir = normalize(((fragCoord.xy-M)/RES.xy) - facePos);\n       \n    vec2 p0 = uv;\n    p0.y *= 1.6;\n    \n    float s0 = length(uv -eyePos0)\t - 0.1;\n    float s1 = length(uv -eyePos1)\t - 0.1;\n    float s2  = length(uv -irisPos0 +0.008*mouseDir)  - 0.065;\n    float s3  = length(uv -irisPos1 +0.008*mouseDir)  - 0.065;    \n    float s9  = length(uv -irisPos2 +0.008*mouseDir)  - 0.025;\n    float s10 = length(uv -irisPos3 +0.008*mouseDir) - 0.025;\n    float s4 = length(p0 -nosePos - vec2(0.0, 0.015)) - 0.062;\n    float s5 = length(p0 -moustachePos0) - 0.12;\n    float s6 = length(p0 -moustachePos0) - 0.12-STROKE;\n    float s7 = uv.y-0.06;\n    float s11 = sdCapsule(p0, nosePos +vec2( 0.091, -0.098), nosePos +vec2( 0.091, 0.0), 0.034);\n    float s12 = sdCapsule(p0, nosePos +vec2(-0.091, -0.098), nosePos +vec2(-0.091, 0.0), 0.034);\n    float s13 = min(max(-s7, s6), min(s11, s12));\n    float s14 = s13 +STROKE;    \n        \n    vec2 p1 = uv -facePos -handsPos;\n    p1.x = -abs(p1.x) + 0.15;    \n    float s15 = sdCapsule(p1, vec2(0.0,    0.0), vec2(0.0,    -1.8), 0.02);\n    float s16 = sdCapsule(p1, vec2(-0.037, 0.0), vec2(-0.037, -1.8), 0.02);\n    float s17 = sdCapsule(p1, vec2(-0.074, 0.0), vec2(-0.074, -1.8), 0.02);\n    float s18 = udBox(p1      +vec2(0.04, 0.3), vec2(0.04, 0.28));\n    float s19 = min(s15, min(s16, s17));\n    float s20 = min(s18, s19 +STROKE);\n    \n    vec2 p2 = uv -facePos -lidPos; \n    p2.x = -abs(p2.x) + 0.15;        \n    p2 *= vec2(1.0, 2.0);\n    float s21 = length(p2) -0.09;\n    float s22 = length(p2 +vec2(0.001, 0.015)) -0.09;\n        \n    vec2 p3 = uv * vec2(1.0, 1.05);\n    p3.y += 0.001*sin(t);\n    float s23 = length(p3 -facePos -vec2(0.0, -0.085)) - 0.065;\n    float s24 = s23 +STROKE;        \n    float s26 = length(p3 -facePos -vec2( 0.0,  -0.115)) - 0.017;\n    float s27 = length(p3 -facePos -vec2( 0.03, -0.108)) - 0.017;\n    float s28 = length(p3 -facePos -vec2(-0.03, -0.108)) - 0.017;\n    float s29 = min( s28, min(s26, s27));\n    float s30 = min( s28, min(s26, s27)) +0.004;\n    p3.y += 0.002*sin(t);\n    float s25 = max( length(p3 -facePos +0.008*mouseDir -vec2(0.02, -0.16)) - 0.03, s24);\n    \n    vec3 c = BG;    \n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, min( s0, s1 )));\n    c = mix(WHITE,   c, smoothstep(0.0, 0.002, min( min( s9, s10), min(s2, s3))));\n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, min(s21, s23)));\n    c = mix(MOUNTH0, c, smoothstep(0.0, 0.002, s24));        \n    c = mix(MOUNTH1, c, smoothstep(0.0, 0.002, s25));                 \t\n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, s29));\n    c = mix(WHITE,   c, smoothstep(0.0, 0.002, s30));\n    c = mix(BG,      c, smoothstep(0.0, 0.002, s22));     \n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, s13));\n    c = mix(BG,      c, smoothstep(0.0, 0.002, s14));   \n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, min(s4, s19)));    \n    c = mix(BG,      c, smoothstep(0.0, 0.002, s20));                 \t       \n    \n    // c = mix(DBG,     c, smoothstep(0.0, 0.002, length((fragCoord.xy-M)/RES.xy) - 0.017));                 \t       \n           \n\tfragColor = vec4(c, 0.0);    \n}", "image_inputs": [{"id": "XdXXDj", "previewfilepath": "https://soundcloud.com/steven-universeonsc/adventure-time-everthing-stays-official-prod-rebecca-sugar-sung-by-olivia-olson", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/steven-universeonsc/adventure-time-everthing-stays-official-prod-rebecca-sugar-sung-by-olivia-olson", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2Bzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2fDR", "name": "[SH17A]Point lights", "author": "Nesvi7", "description": "5 animated point lights. It could be 6 but with 5 is better.", "tags": ["light", "sh17a"], "likes": 6, "viewed": 536, "date": "1500130198", "time_retrieved": "2024-06-20T18:58:01.356016", "image_code": "#define i ++m; d = normalize(vec3(f/iResolution.x,1)-.5); p = d*(-1./d.y);l=vec3(0,-.5,3)+sin(vec3(1,2,.3)*iTime+m)*vec3(1,.2,1); c += texture(iChannel0,p.xz)*pow(max(1.5-length(l-p),0.),3.)+pow(dot(l,d)/length(l),1e4);\nvoid mainImage( out vec4 c, vec2 f )\n{\n    c-=c;\n    float m;\n    vec3 d,p,l;\n    \n\ti i i i i \n}\n", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2fDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2fRh", "name": "Bouncing thingy 2d", "author": "pmpod", "description": "The first, veery simple shader I did for learning purposes, it was fun!\n\n", "tags": ["2d", "noise", "geometry"], "likes": 2, "viewed": 143, "date": "1499552015", "time_retrieved": "2024-06-20T18:58:01.942188", "image_code": "//***********************************************************************************\n// The MIT License\n// Copyright  2017 Piotr Podziemski \n// ----------------------------------------\n// A first shader - commented heavily for myself and others at begginer level\n// Thanks for inspiration to: @jonobr1, @iq\n//***********************************************************************************\n\n\n#define CS(a) vec2(cos(a),sin(a)) \n\n//-----------------------------------------------------------\n// Get color in 0-1 range based on 0-255 RGB value\n//-----------------------------------------------------------\nvec3 rgbNormalized(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n//-----------------------------------------------------------\n// 2d signed distance to the circle\n//-----------------------------------------------------------\nfloat sd2dCircle(vec2 uv, vec2 origin, float radius)\n{\n\tfloat d = length(origin - uv) - radius;\n    return d;\n}\n\n//-----------------------------------------------------------\n// 2d signed distance to the square\n//-----------------------------------------------------------\nfloat vmax(vec2 v)\n{\n\treturn max(v.x, v.y);\n}\nfloat sd2dBox(vec2 uv, vec2 origin, vec2 s)\n{\n\treturn vmax(abs(uv-origin) - s);\n}\n\n\n//-----------------------------------------------------------\n//  Main fragment shader function \n//-----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 3.*iTime; //global time\n    float noiseValue = texture(iChannel0, fragCoord.xy / iResolution.x).x;\n    \n    //[1] Coordinates of the fragment we are dealing with right now\n\tvec2 uv = -1.0 + 2.*fragCoord.xy / iResolution.xy;    //uv coordinates -1<u<1 ; -1<v<1 of the fragment on the viewport screen\n\t  uv.y *= iResolution.y/iResolution.x;  //correct y coordinate for the right aspect ratio\n    \n    //[2] Properties of the objects\n\tfloat radius = 0.25;\n    vec2 centerPoint = vec2(0.0,0.0);\n    \n    //[2] Define movement of the center point of the circle\n    float amplitudeMod = 0.02+0.4*texture(iChannel1, vec2(0.3, 0.0)).x;\n    float shapeChangeMod = 1.0*texture(iChannel1, vec2(0.5, 0.0)).x;\n\tvec2 movement =  amplitudeMod * CS(shapeChangeMod+time+noiseValue);\n    \n    centerPoint +=movement;\n    \n    // Background color\n\tvec4 layer1 = vec4(rgbNormalized(200.0, 210.0, 220.0), 1.0);\n\tvec4 layer2 = vec4(0.0,0.0,0.0,0.0);\n\t// Circle\n\tvec3 red = rgbNormalized(225.0, 95.0, 60.0);\n    \n\n    float minD = mix\n    (\n        sd2dCircle(uv, centerPoint, radius),\n        sd2dBox( uv, centerPoint, vec2(radius,radius)),\n        (cos(shapeChangeMod*20.0+time*1.564526) + 1.0) / 2.0\n    );\n    if(minD <0.1)\n    {\n\t\tfloat t = clamp(minD*iResolution.x, 0.0, 1.0);\n        layer2 = vec4(0.5+0.5*shapeChangeMod,0.0+0.1*shapeChangeMod,0.0, 1.0-t);\n    }\n    \n    // vigneting from iq\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    layer1 *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    \n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n    \n}\n\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2fRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2fzK", "name": "21 August 2017", "author": "rigel", "description": "All set to the Great American Eclipse !", "tags": ["procedural", "2d", "noise"], "likes": 15, "viewed": 589, "date": "1501269303", "time_retrieved": "2024-06-20T18:58:02.451467", "image_code": "// Created by Rigel\n// First shader and total noob :) all the knowledge to make this \n// shader came from this one by iq...\n// https://www.shadertoy.com/view/lsfGRr\n\n// returns a random number\nfloat hash(vec2 p) {\n  return fract(sin(dot(p,vec2(12.9898,78.2333)))*43758.5453123);\n}\n\n// return a noise value in a 2D space\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ),\n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ),\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// returns a fractal noise in a 2D space\nfloat fbm ( vec2 p ) {\n    // rotation matrix to spin the noise space and remove axial bias\n    mat2 m = mat2(0.8,0.6,-0.6,0.8);\n\n    float f = 0.0;\n    f += 0.5000*noise ( p ); p*=m*2.02;\n    f += 0.2500*noise ( p ); p*=m*2.04;\n    f += 0.1250*noise ( p ); p*=m*2.03;\n    f += 0.0650*noise ( p ); p*=m*2.01;\n    // normalize f;\n    f /= 0.9375;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = -0.5 + fragCoord.xy / iResolution.xy;\n  p.x *= iResolution.x / iResolution.y;\n\n  float r = sqrt( dot(p,p) ); // radius\n\n  // abs is to fix the -pi/pi discontinuity in atan and noise artifact  \n  float a = atan( p.y, abs(p.x) ); // angle\n\n  vec3 color = vec3(0.,0.,0.140);\n  float anim = iTime*0.7;\n\n  // red burn\n  float f = 1.0 - smoothstep(0.2,0.45, r);\n  color = mix(color, vec3(0.47,0.11,0.09), f);\n\n  // shine\n  f = smoothstep(0.4, 0.3, 2.0 * length(p - vec2(0.1,0.1)));\n  color += vec3(1.0,0.85,0.68) * f ;\n\n  // angular distortion\n  float aa = a + 0.2 * fbm (15.0*p);\n\n  // heat\n  f = smoothstep(0.2, .45, r);\n  color = mix(color, vec3(0.210,0.093,0.020), f*fbm(vec2(10.0*r-anim,10.0*aa)));\n\n  // dissipation\n  f = smoothstep(0.40, .5, r);\n  color = mix(color, vec3(0.0,0.0,0.140),f);\n\n  // radius of the sun\n  float rs = fbm(vec2(20.0*r-anim,15.0*aa));\n\n  // sun\n  f = 1.0 - smoothstep(0.29,0.3+(rs*0.02), r);\n  color = mix(color, vec3(0.9,0.8,0.490), f);\n\n  // corona\n  f = 1.0 - smoothstep(0.2, .42, r);\n  color = mix(color, vec3(0.965,0.750,0.008), f*rs);\n\n  // moon\n  f = smoothstep(0.29,0.3,r);\n  color *= f;\n\n  // flare\n  f = smoothstep(3.5, 0.2, 25.0 * length(p - vec2(0.2,0.2)));\n  color += vec3(.9,0.7,0.0) * 0.3 * f ;\n\n  // atmosphere\n  color = mix(color, vec3(.9,0.8,0.6), smoothstep(0.4,1.0,r)*0.2*fbm(vec2(4.1*r-anim,25.*(a+0.2 * fbm (3.0*p)))));\n\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2fzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBBDR", "name": "Moving Circles Practice", "author": "h13579", "description": "Followed https://www.youtube.com/watch?v=wgURQjsTVDM&t=1371s\nGet to understand how to make different circles show up.\nTODO:\nFigure out how to let the circle move within the window. Currently they go out of the window for a while.", "tags": ["2d"], "likes": 0, "viewed": 339, "date": "1500020407", "time_retrieved": "2024-06-20T18:58:02.451467", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n\tfloat d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat rand(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tfloat scale = iResolution.x/iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tuv -= .5;\n    \n    uv.x *= scale;\n    \n    float originY = cos(0.5 * (iTime));\n    float originX = scale * originY;\n    \n    float c1 = rand(length(uv)) * Circle(uv, vec2(originX, originY), .3, .01);\n\n    float c2 = rand(length(uv)) * Circle(vec2(-uv.x, uv.y), vec2(originX, originY), .3, .01);\n    \n    float c3 = rand(length(uv)) * Circle(vec2(-uv.x, -uv.y), vec2(originX, originY), .3, .01);\n    \n    float c4 = rand(length(uv)) * Circle(vec2(uv.x, -uv.y), vec2(originX, originY), .3, .01);\n   \n    \n    float c = c1 + c2 + c3 + c4;\n    \n\tfragColor = vec4(abs(sin(iTime)), c, abs(cos(iTime)),1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBBRW", "name": "Circlemania", "author": "coolblinger", "description": "Niet helemaal de bedoeling.", "tags": ["circles", "of", "lots"], "likes": 0, "viewed": 373, "date": "1499689220", "time_retrieved": "2024-06-20T18:58:02.457342", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = (uv - 0.5) * 2.0;\n    offset += vec2(cos(iTime * 1.2), sin(iTime * 1.5));\n    \n    float xColor = cos(length(offset) + iTime) + 0.5;\n    float yColor = sin(length(offset) + iTime) + 0.5;\n    \n    fragColor = vec4(xColor, (xColor + yColor) / 2.0, yColor, 1.0);\n    fragColor *= dot(uv, offset);\n    fragColor += abs(log2(fragColor)) / 10.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBBW1", "name": "Curve Revolute", "author": "aiekick", "description": "click on screen to control with :\n- axix x, the branch count\n- axis y, teh z shape section", "tags": ["curve", "revolute"], "likes": 14, "viewed": 543, "date": "1500230288", "time_retrieved": "2024-06-20T18:58:03.342311", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nvec2 m;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.14159 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat shape(vec2 p)\n{\n    vec2 q = p;\n    \n    vec2 s = vec2(0.01,2); // 2d box size\n    \n    q.x += sin(q.y*5.)*.2 + sin(q.y*20.)*.1; // perturb box thickness along height\n    \n\treturn length(max(abs(q) - s, 0.)); // 2d iq box shape\n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*floor(m.x*10.) + iTime;\n    \n    vec2 rev = vec2(length(p.xz), p.y) - 2.5;\n    \n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n\tvec2 res = vec2(abs(shape(rev))-0.032, 0);\n    //if (iMouse.z > 0.)\n\t\tif (p.z+m.y*10.-5. > res.x) \n            res = vec2(p.z+m.y*10.-5., 1);\n\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,2);\n\t\t\n\treturn res; \n\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy/iResolution.xy;\n    if (m.x == 0.) m.x = .1;\n    \n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tvec2 camp = vec2(.73,.37) * 5.;\n\tvec3 rayOrg = vec3(cos(1.57),sin(camp.y),sin(1.57)) * camp.x * 2.;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.2,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dMax) break;\n\t\ts = df(p).x;\n\t\td += s * 0.2;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBBzV", "name": "superprim extrude round polar", "author": "ollj", "description": "pause time to diminish confusion.\n\nstretch1() utility:\n\nmouse.y folds space == extrude object-space's center of the object (for each tile center)\nmouse.x lerps between rounded corners and 90deg corners (and beyond)\ncenter position makes most sense.", "tags": ["pacman", "normal", "symmetry", "rounding", "corner", "asteroids", "stretch", "extrude", "pmod", "superprim", "disymmetry", "dynamiceps", "bisymmetry"], "likes": 6, "viewed": 761, "date": "1501158653", "time_retrieved": "2024-06-20T18:58:05.039866", "image_code": "/*\nthere is a simple disymmetry in cylinder and torus, \nas in, they are basically /polar or carthesian) stretched 2d shapes.\nand the stretching can be done via stretch1()\nstretch1() folds a domain domain, stretching/extruding the DistanceField\nfDisc() should be stretchable to cylinder(), using stretch1()\nfDisc() and pacman() are 2d shapes, easily extruded or rounded.\n\n  return mix(round,sharp,2.*iMouse.x/iResolution.x);\n  ...lerps between 2 fDisc() and cylinder(), both extending on pacman()\n  ...but with different \"corner rounding\"\n\nI wanted to explore simple stretch1() extrusion of fDisc()\nI got sidetracked into a 3d \"superprim\" based on a 2d pacman shape.\nsidetracking results in messier code.\n\nthe pacman() code can be made much more symmetrical \n...with what i learned by making this shader.\n*/\n\n//time scaling\n#define time iTime*.5\n\n//maximum raymarching iterations\n#define rMaxIter 256.\n\n//maximum ray-marching distance from camera\n//if (marched further) it hits a \"weird cosmic microwave backkground\"\n#define rdMax 300.\n\n//content of tiles is rotated by tileID\n//has much more lipschitz discontinuity, due to modulo tesselation.\n#define tielsrotated\n\n//size of a tile (is a box, .y is smaller.)\n//tilesize>4. or else the content touches the tile border, getting cut by it.\n//larger tilesizes let you \"see further away\", seeing more diversity over distance.\n#define tilesize (((cos(time*2.-40.))*.5+.5)*4.+4.2)\n\n//rotate camera over time\n#define camrotate\n\n//field of view within a square part of the viewFrame; 1.=90deg,\n//is actually \"ideal distance of eyes to viewscreen, inverse ratio to screen height\"\n//if (screen is 0.5meter high && your head is 1 meter away from it)  #define fow (0.5/1.)\n#define fow .75\n\n//smarter raymarching, epsilon is a cubic function with distance and lastStelLength.\n//resulting in less overstepping and often better performance\n//but it sets the minimum barrier for low-quality-settings higher.\n#define dynamicEps\n\n//LipSchitsScale is only used if dynamicEps is DISABLED\n//lipshits_constant is abs() of first derivative of the distance field, projected on the ray.\n//if lipshits_constant>1., you likely overstep, raymarching becomes quantum unchertain, tunnels.\n//if lipshits_constant>2., you definitely overstep\n//lipshits_constant*=LipSchitsScale, sales steps down, you need more steps, for less overstepping\n//fract()mod() tesselation makes the distanceField c0_dscontinuous, \n//...therefore overstepping is much more likely.\n#define LipSchitsScale .25\n\n//eps is needed to calculate normals (and for raymarching without dynamicEps)...\n//epsilon for heuristics and gratients\n#define eps 0.00001\n\n/*\n//todo, replace line-segment subroutine of pacman code partially with sdf_line6n()\n//may require some \"new disymmetry\" knowledge.\n\n//i pledge for the Term \"disymmetry\"=\"gradient between the extremes; symmetry to asymmetry\"\n\n\n//return signed distance of point [p] to line [a]\n//where [a] is the differential of 2 points that the line goes trough;\n//... you have a line trough [c]and [d] then a=c-d OR a=d-c;\n//which one you chose to define [a] sets the sign of the distance == line direction.\nfloat sdf_line6(vec2 p,vec2 a){a.x=-a.x;return dot(a.yx,p);}\n//for the above, a must be normalized, which is done by wrapper below.\nfloat sdf_line6n(vec2 p,vec2 a){return sdf_line6(p,normalize(a));}\n//https://www.shadertoy.com/view/4dBfzG\n\n\n/*my main goal was to use this shape to cisualize quaternion slerp:\n\nstruct quat{vec3 a;float r;};//struct makes bloated code, more explicit, more worksafe.\n//enforcing prefix arithmetic\nquat v42c(vec4 a){return quat(a.xyz,a.w);}\nquat norm(quat a){return v42c(normalize(vec4(a.a,a.r)));}\nquat add(quat a,quat b){return v42c(vec4(a.a+b.a,a.r+b.r));}\nquat sub(quat a,quat b){return v42c(vec4(a.a-b.a,a.r-b.r));}\nquat mul(quat a,float b){return v42c(vec4(a.a*b,a.r*b));}\n\n//return spherical-linear-iterpolation from [a] to [b] by [x]\nquat slerp(quat a,quat b,float x){a=norm(a);b=norm(b);//must be normalized,else unpredictable.\n float d=dot(a.a,b.a);if(abs(d)>.9995){//if(inputs are too close)\n  return norm(add(mul(sub(b,a),d),a));}//linear interpolation is more precise.\n if(d<0.){//if(inputs have different signs)\n  b.a=-b.a;d=-d;} //flip chiralty/handetness to take shorter path\n d=clamp(d,-1.,1.);//make sure that acos(d) is defined.\n float t=acos(d)*x; //= angle between v0 and result \n  quat c=sub(b,mul(a,d));//quat v2=quat(v1.av0.a*d);\n  c=norm(c);//{v0,v2} is now an orthonormal basis\n  return add(mul(a,cos(t)),mul(c,sin(t)));}//https://en.wikipedia.org/wiki/Slerp\n\n//return trilienar interpolation by [i] over the cube3d volume with the sides a,c,b\nvec2 blin(vec3 i, vec2 a, vec2 b,vec2 c){vec2 r=vec2(0);\n r=mix(r,r+a,i.x);//lerp in direction of a\n r=mix(r,r+b,i.y);//lerp in direction of b\n r=mix(r,r+c,i.z);//lerp in direction of c\n return r;}//imagine simple case: a=vec2(1,0,0) and b=vec2(0,1,0) and c=vec3(0,0,1);\n*/\n\n\n//#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\nif(iResolution.x>iResolution.y)u.x*=iResolution.x/iResolution.y;\nelse u.y*=iResolution.y/iResolution.x;return u*5.;}\n\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define ss(a) a=smoothstep(.003,-.003,a);\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n//does not check for non-intersecticn cases! intersection.y is not important.\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n\n//https://www.shadertoy.com/view/ldBBDw\n#define stretch(a) p.a=mix(p.a-m.a,mix(0.,p.a,step(p.a,0.)),step(p.a,m.a));\n/*          / stretch(a) is a linear funtion that looks like:\n           /\n          /\n    _____/ \n   /0    m.a\n  / \n /\n/  with 2 discontinuities at v.a=0 and v.a=m.a\nx axis is v.a*/\n#define stretch1(p,m) mix(p-m,mix(0.,p,step(p,0.)),step(p,m))\n/*          / stretch(p,m) is a linear funtion that looks like:\n           /\n          /\n    _____/ \n   /0    m\n  / \n /\n/  with 2 discontinuities at p=0 and p=m\nx axis is v.a*/\n\n//https://www.shadertoy.com/view/4ssBDs\n\n//return mirror matrix, mirror is rotated by r*0.5 radians; is a faster alternative to SINGLE rotations.\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//alternative to 2d rotation: mat2(-cos(a),sin(a),sin(a),cos(a))\n\n//return distance of [p] to line segment from vec2(0) to vec2(1,0)\nfloat ls(vec2 p){p.x-=.5;p=abs(p);return mix(length(p-vec2(.5,0)),p.y,step(p.x,.5));}\n//aove special case is faster than the more common dot()/dot() distance to line segment.\n\n//return distance of [p] to pacman-shape, line segment, polar extruded by [r] range [0..2*pi]\nfloat pacman(vec2 p,float r,vec3 t){//r=-3.14*.5;quater open mouth\n  //animated mouth poverwrite;\n  //r=sin(time*5.*(sqrt(5.)*.5+.5))*.5+.5;\n  //r*=1.5;r-=3.;\n                             \n //r=clamp(r,-acos(-1.),acos(-1.));//optionally, constrain th group of this shape!\n //out of bounds shapes \"extended\" this shape \"nicely\" \n //...to something harder do describe as \"overlayed polar extrusion\"?\n float m=atan(p.y,-p.x),ll=length(p)-1.,a=ls(p);p*=r2(-r);p.x+=1.;float b=ls(p);\n r=mix(max(max(ll,-a),-b),min(a,b),step(m,r));\n return r-sin((t.x*t.y+time)*5.)*.5;\n //if(m>r){return max(max(ll,-a),-b);}return min(a,b); \n}\n//return pacman(p,r), with a shortcut branch case if (closed circle)\nfloat pacman2(vec2 p,float r,vec3 t){if(r<=-acos(-1.))return length(p)-1.;return pacman(p,r,t);}\n\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n//except i replaced the circular disk with a distance field for pacman.\nfloat fDisc(vec3 p,float r,vec3 t){\n float l=pacman(p.xz,r,t);\n //l=length(p.xz)-r;//for circle\n float s=mix(abs(p.y),length(vec2(p.y,l)),step(0.,l));//branchless\n //float s= l < 0. ? abs(p.y):length(vec2(p.y, l));//branching\n return s;\n}//mercury.hg_sdf , Subtract some value to make a flat disc with rounded edge.\n/*\n//original disc code\nfloat fDiscO(vec3 p,float r){p*=.25;\n float l=length(p.xz)-r;\n return l<0.?abs(p.y):length(vec2(p.y,l));}\n*/\n\n//i should possibly just change fCylinder into fCylinderWrapper(fDisc())\nfloat fCylinder(vec3 p,float r,float h,vec3 t){\n    p.y=abs(p.y);\n    //p.y=stretch1(p.y,abs(h));\n    //return fDisc(p,r);\n    h=.1;\n    float circle=length(p.xz)-r;\n    float pac=pacman(p.xz,r,t);\n    return max(pac,abs(p.y)-h);}\n\n//return distance to \"cylindrical pacman\"\n//if (t is out of bounds) extends beyond a pacman shape; \"2sticks\" \"hall\" \"minifigHand\"\nfloat fCylPacman(vec3 p,vec3 t){\n //folding domains == extruding distance field. \n float tt=t.x+t.y*sqrt(2.)+t.z*acos(-1.);//very lazy \"hash31\", feed by tilePiy.xyz   \n \n #ifdef tielsrotated\n p.xy*=r2(tt);p.yz*=r2(t.z); \n #endif\n    \n float fold=.5*iMouse.y/iResolution.y;\n p.x=stretch1(p.x+fold*.5,fold);\n p.y=stretch1(p.y+fold*.5,fold);\n p.z=stretch1(p.z+fold*.5,fold);\n    \n //p.z=stretch1(p.z+fold*.1,fold*.2);//folding the .z domain too much is not the best idea\n \n  //if(circle)mm sets circle raduis\n  //else() radius is =1. and mm sets \"how far open pacman mouth is\"\n  float mm=sin((tt*9.+time)*(sqrt(5.)*.5+.5))*.5+.5;\n  mm*=16.;\n  mm-=8.;\n p.xz*=r2(-mm*.5);\n float round=fDisc(p,mm,t)-.1;//rounded corners\n float sharp=fCylinder(p,mm,.0,t);//sharp corrners\n return mix(round,sharp,2.*iMouse.x/iResolution.x);\n return round;//i could instead just interpolate the radius of fDisc(), but this allows overdoing it\n //return sharp;//fCylinder() could be expressed as tansforming wrapper onto fDisc();\n}\n\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\n//return signed distance of [p] to implicit surface.\nfloat df(vec3 p){//this fnction mostly just handles the main tesselation(s)\n vec3 t;//t stores tileID\n //p=fract(p)-.5;//modulo p;\n t.y=floor(p.y*1.5/tilesize);\n p.y=fract(p.y*1.5/tilesize)*tilesize-tilesize*.5;//modulo p;\n t.xz=pModMirror1(p.xz,vec2(tilesize));//modmirror evades overstepping on disymmetry.\n \n return fCylPacman(p,t);\n// return length(p)-.25;//-.5 has spheres touch, which constrains camera placement\n //sinusoidial_blob():\n// float k = 50.*(sin(time*.3)*.5+.5);//k=0.;\n// return length(p)-.2 +.1*sin(k*p.x)*sin(k*p.y)*sin(k*p.z);\n}\n\n#ifndef dynamicEps\n//raymarching, root solver for a distance field.\nvoid rm(inout vec3 p,vec3 o,vec3 r){float u=0.;for(float i=0.;i<rMaxIter;++i){\n  p=o+u*r;float s=df(p);\n  if(d<eps)return;u+=s*LipSchitsScale;//if close enough to surface\n  if(u>rdMax)return;u+=s*LipSchitsScale;//if too far from camera\n}}\n#else\n//raymarching, root solver for a distance field.\n//dynmicEpsilon variant evades overstepping with often better performance.\nvoid rm(inout vec3 p,vec3 o,vec3 r){\n float d=0.;//distance of ray from camera\n float s=0.;//last step length\n for (float i=0.;i<rMaxIter;i++){\n  if (log(d*d/s/1e5)>0. || d>rdMax) break;\n  s=df(p);//step length\n  d+=s*.3;\n  p = o + r * d;\t\n}}\n#endif\n\n//return normal==normalized gradient at [p] with distance eps*2. over 3 domains\nvec3 normal(const in vec3 p){vec2 e=vec2(-1.,1.)*eps*2.;\n return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)+e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n#define rs(r) mat2(sin(r+vec4(-1,0,0,1)*asin(1.)))\n#define ratio(r) r.x/r.y\n//great tiny 3d raymarching example: //http://glslsandbox.com/e#38217.0\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=(U.xy/iResolution.xy)*2.-1.;//p(0,0) to center \n u.x*=ratio(iResolution);//aspect ratio adjustment\n float a=time*.3;//time\n vec3 o=+vec3(tilesize*.5);//o=vec3(0,0,sin(a)*3.);//camera position\n vec3 r=normalize(vec3(u*fow,1));//camera ray direction (lazy)\n mat2 m=rs(a*.5);//m=mat2(cos(a),-sin(a),sin(a),cos(a));//is slightly different\n #ifdef camrotate\n r.yz *=m;r.xy *=m;//rotate camera rayson 2 domain pairs.\n #endif\n r=r.yzx;//optional: swivel camera rays, for better view on time=0.\n vec3 p;//accululated total raymarched vector\n rm(p,o,r);\n float d=sqrt(dot(p,p)*.07+2.);//distance to camera, \n //... with scaling function for \"fake nearby ambient light\"\n //O=vec4(fract(p)*mod(p,3.)/d,1);//show xy positions by color\n p=normal(p)*.5+.5;\n O=vec4(p.xzy/d,1.);//mixing normal and .xyz position for nice fake-AO-depth\n O*=5.-3.;//overbrighten\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBBzw", "name": "[SH17A] Shaded Spheres", "author": "theGiallo", "description": "First attempt at 2 tweets shadertoy. Best viewed in 1920x1080.\nExploiting the [url=https://www.shadertoy.com/view/Xd2BWh]Tiniest Shadertoy Trick[/url] by pellicus and theGiallo.", "tags": ["spheres", "sh17a"], "likes": 1, "viewed": 101, "date": "1500282502", "time_retrieved": "2024-06-20T18:58:05.536501", "image_code": "void mainImage(out vec4 o,vec2 c){vec3 r = (vec3(c - vec2(960,540),1920))*5e-4,S = r-r,P;float t = 0., s,l, T = 4e3;for(S.x = -iTime*T;t < 1e6;t += l < .1?(T = max( 0., dot( S = P / s * .5 + .5, vec3(.6,.6,-.6) ) ),o = ( T + .5 + 2. * pow( T, 15. ) ) * vec4(.8,.32,0,0),1e7) : l )P = mod(r * t - S,T) - .5 * T,s = length( P ),l = s - 9e2;}\n/*\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    vec3 r = (vec3(c - vec2(960,540),1920))*5e-4,\n         S = r-r,\n         P;\n    float t = 0., s,l, T = 4e3;\n    for(S.x = -iTime*T;\n        t < 1e6;\n        t += l < .1?\n        (\n            T = max( 0., dot( S = P / s * .5 + .5, vec3(.6,.6,-.6) ) ),\n            o = ( T + .5 + 2. * pow( T, 15. ) ) * vec4(.8,.32,0,0),\n            1e7\n        ) : l )\n    \n        P = mod(r * t - S,T) - .5 * T,\n        s = length( P ),\n        l = s - 9e2;\n}\n*/\n\n/*\n// Original submission.\n#define mainImage(o,c) vec3 S, r = (vec3(c - vec2(960,540),1920))*5e-4,P;S-=S;float t = 0., s,l, T = 4e3;S.x = -iTime*T;for(;t < 1e6;)P = mod(r * t - S,T) - .5 * T,s = length( P ),l = s - 9e2,t = (l < .1?(        \tS = P / s * .5 + .5,P = vec3(.6,.6,-.6),T = max( 0., dot( S, P ) ),P = vec3(1,.4,0),o.rgb = ( .8 * T + .4 ) * P +1.6 * pow( T, 15. ) * P,1e7) :  t + l );\n*/\n/*\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    vec3 S,\n         //r = normalize(vec3(c - iResolution.xy*.5,iResolution.x)),\n         r = (vec3(c - vec2(960,540),1920))*5e-4,\n         P;\n    S-=S;\n    float t = 0., s,l, T = 4e3;\n    S.x = -iTime*T;\n    for(;t < 1e6;)\n    \n        P = mod(r * t - S,T) - .5 * T,\n        s = length( P ),\n        l = s - 9e2,\n        t = (l < .1?\n        (\n        \tS = P / s * .5 + .5,\n            \n            //float w = 1.0 - shadow( point, -sun_light_dir );\n            //S.x = .5; // diffuse_reflection\n            //S.y = 1.; // specular_reflection\n            //S.z = 1.; // ambient_reflection\n            //rp = 15.; // shininess\n            //t = .4; // ambient\n    \t\t//S = vec3(.8,1,1); // sun_specular_color\n            //o.rgb = vec3(1,.4,0), // object color\n            //s = 1.6; // shadow\n            //vec3 L = normalize(vec3(-1,-1,1)); // light direction\n            P = vec3(1,1,-1)*.6, // light direction (normalized) .577\n            //float d = ; // diffuse term\n            \n            // specular is now fake because it needs reflect(r,S)\n            T = max( 0., dot( S, P ) ),\n            P = vec3(1,.4,0),\n            //s = s * pow( rp, 15. ); \n            o.rgb = ( .8 * T + .4 ) * P +\n                    1.6 * pow( T, 15. ) * P,//vec3(.8,1,1),\n            1e7 // break\n        ) :  t + l );\n    \n        /*\n        if ( l < .1 )\n        {\n        \tS = P / s * .5 + .5;\n            \n            //float w = 1.0 - shadow( point, -sun_light_dir );\n            //S.x = .5; // diffuse_reflection\n            //S.y = 1.; // specular_reflection\n            //S.z = 1.; // ambient_reflection\n            //rp = 15.; // shininess\n            //t = .4; // ambient\n    \t\t//S = vec3(.8,1,1); // sun_specular_color\n            o.rgb = vec3(1,.4,0); // object color\n            //s = 1.6; // shadow\n            //vec3 L = normalize(vec3(-1,-1,1)); // light direction\n            P = vec3(1,1,-1)*.58; // light direction (normalized)\n            //float d = ; // diffuse term\n            \n            // specular is now fake because it needs reflect(r,S)\n            T = max( 0., dot( S, P ) );\n            \n            //s = s * pow( rp, 15. ); \n            o.rgb = ( .8 * T + .4 ) * o.rgb + 1.6 * pow( T, 15. ) * vec3(.8,1,1);\n            break;\n        }\n        t +=l;\n}\n        */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBBzy", "name": "28 Moons", "author": "zproxy", "description": "https://www.shadertoy.com/view/XsjBWm", "tags": ["sun", "space", "stars", "moon", "globe"], "likes": 2, "viewed": 124, "date": "1500900336", "time_retrieved": "2024-06-20T18:58:09.900420", "image_code": "// inspired by Ramon Viladomat\n\n#define DRAW_RED_MAGIC \n//#define DRAW_GREEN_MAGIC \n#define DRAW_BLUE_MAGIC \n#define DRAW_YELLOW_MAGIC \n \n#define PI 3.1415\n#define EPSILON 0.002\n\n// 384,400 km\n#define SATELITE_RADIUS 384.400\n//#define SATELITE_RADIUS 34.400\n\n//#define MAGIC_RADIUS\t384.400\n#define MAGIC_RADIUS\t(384.400  + 7.)\n\n// 1,737 km\n#define SATELLITE_RADIUS 1.737\n//#define SATELLITE_RADIUS 10.737\n//#define SATELLITE_RADIUS 0.1737\n\n// 6,371 km\n#define PLANET_RADIUS \t6.371\n\n// camera rotation basically means one rotates with a planet.\n// the texture has to also rotate for that effect\n//#define CAM_ROTATION_SPEED 0.01\n// moon is supposed to do a real orbit in 28days\n//#define SAT_ROTATION_SPEED 0.1\n\n//#define CAM_ROTATION_SPEED 0.0\n//#define SAT_ROTATION_SPEED 0.0\n\n#define CAM_ROTATION_SPEED 0.02\n#define SAT_ROTATION_SPEED 0.01\n// if its the same speed. its basically at the same spot.\n// it has to fall back on x axis full circle within 28days\n// yet it has to travel from blue to red in 14 days\n//#define SAT_ROTATION_SPEED 0.1\n//#define SAT_ROTATION_SPEED (CAM_ROTATION_SPEED/28.)\n\n\n\n// ah. so this defines how the shadow should behave, per expected distance of the sun\n#define SOFTSHADOW_BANDWIDTH 0.7\n//#define SOFTSHADOW_BANDWIDTH 0.2\n\n\n\n\n\n// moon pos. can we make it move?\n\n///////////////\n// MATERIALS //\n///////////////\n\n\n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\n\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\nvec2 GetNormalMap(in sampler2D s, in vec2 resolution, in vec2 uv)\n{\n\tvec3 eps=vec3(1.0/resolution,0.0);\n\tvec2 norm = vec2(length(texture(s,uv+eps.xz)) - length(texture(s,uv-eps.xz)),\n\t\t\t\t\t length(texture(s,uv+eps.zy)) - length(texture(s,uv-eps.zy)));\n\t\n\treturn norm;\n}\t\n\nvec4 calcColor( in vec3 pos, in vec3 nor, in float material, out vec3 normal, vec3 ballPos  )\n{\n\tvec4 materialColor = vec4(0.0);\n\t\n\tvec3 q = pos - mix(ballPos,vec3(0.0),material);\n\tfloat radius = mix(0.5,3.0,material);\n\tvec2 angles = vec2(atan(abs(q.z)/abs(q.x)),acos(q.y/radius));\n\t\n\tfloat mixer = step(1.0,material);\n\t\n\t\n    // material ?\n    //materialColor = vec4(0.01,0.01,0.7*material, 0.01);\n    \n    // float1 is earth.\n    // float0 is moon?\n    if (material < 0.5)\n    \t//materialColor = vec4(material,material,1.0-material, 0.01);\n        //materialColor = vec4(0.4,0.4,0.4, 0.01);\n    \n        // does the light hit it the right way?\n        materialColor = vec4(0.4,0.4,0.4, 0.01);\n    else\n        materialColor =\n        \n//        (1./ 14.) *\n        vec4(\n            \n                        0.01,0.01,0.7, \n\n             //0.01,0.01,0.7 - startrails(angles.xyy).x,\n            //0.01,0.01,0.7, \n            \n            0.01);\n    \n    //materialColor = vec4(0.01,0.01,0.01, 0.01);\n    \n  \n\tvec2 normalMap = //mix(\n        \n        // looks like a golfball?\n        //hash33(angles.xyy).xy\n        //hash33(pos * 0.00001).yx * 0.1\n        \n        0.\n        //startrails(pos).xy\n        //4.0 * sin(float(iFrame) * 0.1)//*GetNormalMap(iChannel1,iChannelResolution[1].xy,angles)\n        * vec2(1)\n        ;\n        \n        //GetNormalMap(iChannel0,iChannelResolution[0].xy,angles),mixer);\n\t\t\n\tvec3 left = normalize(cross(vec3(0.0,1.0,0.0),nor));\n\tvec3 up = normalize(cross(left,nor));\n\tnormal = normalize(normalMap.x*left + nor + normalMap.y*up);\n\t\n\treturn materialColor;\n}\n\n// can it become a scanline?\n//float GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params, in vec2 sine)\nfloat GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params)\n{\n\tfloat rotAngle = movement.x+iTime*movement.y;\n\tvec2 refPos = MAGIC_RADIUS*vec2(sin(rotAngle),cos(rotAngle));\n\tvec2 refFwd = vec2(-refPos.y,refPos.x);\n\t\n\tfloat hVert = pos.y - movement.z;\n\tfloat hDist = length(pos.xz - refPos);\n\t\n\t//float fl = max(dot(pos.xz,refFwd),0.0)*(1.0 - smoothstep(0.0,params.x,hDist));\n\tfloat fl = max(dot(pos.xz,refFwd),0.0)\n        \n        *(1.0 - smoothstep(0.0,params.x,hDist));\n    \n    \n\t//float fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z*sin(sine.x*angle+sine.y)));\n\tfloat fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z\n                                                // *sin(sine.x*angle+sine.y)\n                                                ));\n\t\n\treturn fl*fh;\n}\n\nvec3 GetAlphaColor(in vec3 pos)\n{\n\tvec3 ret = vec3(0.0);\n\tfloat angle = atan(pos.z/pos.x);\n\t\n#ifdef DRAW_RED_MAGIC\n\tret +=  0.000001 \n        * vec3(1.,0.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle,\n            \n            \n            vec3(0.0,-4., 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                1270.0,\n                \n                // width\n                2.,\n                \n                // moves it up or down?\n                \n                // up\n                -135.\n            \n                // down\n                //5.\n            \n                // center\n                //0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n#endif\n#ifdef DRAW_GREEN_MAGIC\n\tret += vec3(0.0,1.0,0.0)*GetTrail(pos,angle,vec3(0.5,2.1, 0.5),vec3(8.0,0.1,0.8),vec2(2.0,1.0));\n#endif\n#ifdef DRAW_BLUE_MAGIC\n\tret +=  0.000001 \n        * vec3(0.,0.0,1.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle,\n            \n            \n            vec3(0.0,4.1, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                1270.0,\n                \n                // width\n                2.,\n                \n                // moves it up or down?\n                \n                // up\n                //-2.\n            \n                // down\n                135.\n            \n                // center\n                //0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    #endif\n#ifdef DRAW_YELLOW_MAGIC\n\tret +=0.0000 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                -4.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    ret += 0.0000 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                4.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n      ret += 0.00000 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    #endif\n\treturn ret;\n}\n\n/////////////////\n// RAY METHODS //\n/////////////////\n\nfloat raySphereIntersection( in vec3 ro, in vec3 rd, in vec3 center, in float radius, float multiplier)\n{\n\tfloat res = 9999.0;\n\tvec3 oc = ro - center;\n\tfloat b = dot(rd,oc); //should be 2*rd*oc but the 2 gets eliminated after expanding the quadratic equation\n\tfloat c = dot(oc,oc)-(radius*radius);\n\t\n\tfloat bminac = (b*b)-c;\n\tif (bminac >= 0.0)\n\t{\n\t\t//intersection\n\t\tfloat sqrtbminac = sqrt(bminac);\n\t\tfloat t = (-b + multiplier*sqrtbminac);\n\t\tres = mix(res,t,step(0.0,t));\n \t}\n\t\n\treturn res;\n\t\n}\n\nfloat shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)\n{\n\tfloat lambda = dot(-(ro - sphere.xyz),rd);\n\tfloat dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;\n\treturn mix(9999.0,dist,step(0.0,lambda)); \n}\n\n////////////////\n// RAY TRACER //\n////////////////\n\nvec2 intersect( in vec3 ro, in vec3 rd,  vec3 ballPos, int imoon )\n{\n\tvec2 res = vec2(9999.0,-1.0);\n\t\n\tvec2 centerSatellite = vec2(raySphereIntersection(ro,rd,ballPos,SATELLITE_RADIUS,-1.0),0.0);\n\tvec2 centerPlanet = vec2(raySphereIntersection(ro,rd,vec3(0.0),PLANET_RADIUS,-1.0),1.0);\n\t\n\tif (centerSatellite.x < res.x) res = centerSatellite; \n\t\n    // unless we need multiple eclipses?\n    // keep only moon0 near sun. others should not be able to cause the eclipse\n    // ha. also. other moons should not appear thru the planet.\n    \n    if (centerPlanet.x < res.x) \n    {\n         if (imoon == 0)\n         {\n        \tres = centerPlanet; \n        \n         }\n        else\n        {\n            \n            // erase any moons...\n        res = vec2(9999.0,-1.0);\n        }\n\n    }\n        \n\treturn res;\n}\n\nfloat GetShadows( in vec3 ro, in vec3 rd, vec3 ballPos )\n{\n\tfloat shadowSatellite = shadowRaySphere(ro,rd,vec4(ballPos,SATELLITE_RADIUS));\n    \n    \n\tfloat shadowPlanet = shadowRaySphere(ro,rd,vec4(0.0,0.0,0.0,PLANET_RADIUS));\n\t\n\treturn smoothstep(0.0,SOFTSHADOW_BANDWIDTH,min(shadowSatellite,shadowPlanet));\n}\n\nvec3 GetTransparency( in vec3 ro, in vec3 rd, float depth)\n{\n\tfloat back = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,1.0);\n\tfloat front = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,-1.0);\n\n\treturn GetAlphaColor(ro+rd*back)*step(back,depth) \n        // what does this do?\n        + GetAlphaColor(ro+rd*front)*step(front,depth)\n        ;\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nvec3 calcNormal( in vec3 pos, in vec2 tmat, vec3 ballPos )\n{\n\treturn normalize(pos-mix(ballPos,vec3(0.0),tmat.y));\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd , vec3 ballPos )\n{\n\tfloat scene = GetShadows(ro,rd, ballPos);\n\tfloat alpha = 1.0 - 0.8*clamp(length(GetTransparency(ro,rd,9999.0)),0.0,1.0);\n    return min(alpha,scene);\n\t\n}\n\n\n\n\n\n\nvoid line_rgb (\n    //inout vec4 fragColorR,\n\tinout vec3 rgb1,\n\n    in float lat180,  \n    in float lat180target, \n    in float lat180radius,\n\n\tvec3 rgb)\n{\n    if (lat180 < (lat180target + lat180radius))\n        if (lat180 >( lat180target - lat180radius))\n            \n \t\t//if (lat180 < 108.)\n     //   if (lat180 > 72.)            \n        {\n\n            \n            //float a = 0.3;\n\n            \n\n            rgb1.rgb = rgb;\n\n            //fragColorR.b = a;\n            //fragColorR.g = a;\n\n        }\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n// nested functions would be just awesome. \nvec3 draw(int imoon, vec3 ballPos, vec3 camPosition, \n          vec3 rayDir,  \n          vec3 lightPos1 ,\n          vec3 lightColor1 ,\n           float attenuation,\n          \n          out vec2 tmat,\n          inout int space\n         )\n{\n    vec3 finalcolor = vec3(0.0);\n    \n      float depth = 9999.0;\n        for( int reflectCount=0; reflectCount<2; reflectCount++ )\n        {\n            float isFirst = min(float(reflectCount),1.0);\n\n\n\n\n\n            // Compute color for single ray\n             tmat = intersect(camPosition,rayDir, ballPos, imoon);\n            vec3 alpha = GetTransparency(camPosition,rayDir,tmat.x);\n\n            //finalcolor += attenuation*alpha;\n            finalcolor += alpha;\n\n            if (tmat.y > -0.5)\n            {\n                depth = mix(tmat.x,depth,isFirst);\n\n                // results extraction\n                vec3 position \t= camPosition + tmat.x*rayDir;\n                vec3 normal \t= calcNormal(position,tmat,ballPos);\n\n                // lights and materials \n                vec3 normalMod = vec3(0.0);\n                vec4 materialColor \t= calcColor( position, normal, tmat.y , normalMod, ballPos);\n                normal = normalMod;\n\n                float ambient  \t\t= 0.1 + 0.1*normal.y;\n                vec3 ambientColor \t= ambient*materialColor.rgb;\n\n                //light 1 ( specular computed through reflections )\n                vec3 lightDir1 \t= normalize(lightPos1 - position);\n\n                float diffuse1  = max(dot(normal,lightDir1),0.0);\n                float shadow1   = 1.* softShadow( position, lightDir1 , ballPos);\n\n                // HDR bright\n                vec3 diffuseColor1 = 10.0* diffuse1*lightColor1*materialColor.rgb;\n                vec3 ilumColor1 = shadow1*diffuseColor1;\n\n                // mixing lights\n                finalcolor += attenuation*mix(ambientColor,ilumColor1,0.8);\n\n                // prepare next ray for reflections \n                rayDir = reflect(rayDir,normal);\n                attenuation *= 2.0*materialColor.w;\n                camPosition = position + EPSILON*normal;\n                \n                space--;\n            }\n\n\n        }\t\n    \n    return finalcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // need SIRIUS from\n    // https://www.shadertoy.com/view/XdXcDB\n    \n    // need scanlines from\n    // https://www.shadertoy.com/view/ldXyzs\n    \n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\t//move camera when clicking\n\tfloat animatedCamAngle = -0.7 + iTime*CAM_ROTATION_SPEED;\n\t//float inputCamAngle = PI + 2.0*PI*(mousePos.x*14.);\n    float inputCamAngle = PI + 2.0*PI*(mousePos.x);\n\t//float inputCamAngle = PI + 2.0*PI*(mousePos.x*7.);\n\t\n\t//float camAngle = mix(animatedCamAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\n    float camAngle = animatedCamAngle+inputCamAngle;\n    \n    //float camDist = 5.0; \n\t//float camDist = 10.0; \n\t//float camDist = 10.0 +1.* sin(iTime);  \n\t//float camDist = 50.0  ;  \n\t//float camDist = 6.3715  ;  \n\t //float camDist = 5. * 6.3715  ;  \n\t//float camDist = 384.400 + 6.; \n    float camDist = 2. * 384.400; \n    \n    // #define PLANET_RADIUS \t6.371\n\n    // #define MAGIC_RADIUS\t384.400\n\n    \n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), \n                                              \n                                              \n                                              0.0, cos(camAngle)));\n    \n    // will rock the boat\n    //camPosition.y += 2. * sin(iTime * 0.5);\n    //camPosition.y += .2 * sin(iTime * 0.5);\n    \n    \n    //vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    // the closer we get. the more horizon we need to look at in 2D\n    vec3 camTarget\t = vec3( -8.0, 0.0, 0.0 );\n    \n    if (camDist > 10.)\n        camTarget.x = 0.;\n    \n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n\tvec3 rayRaw \t = p.x*camRight + p.y*camUp + 2.0*camFront;\n    vec3 rayDir \t = normalize( rayRaw );\n\t\n    //rayDir *=  rotationMatrix(vec3(1., 0., 0.), radians(90.0 )); // make it wavy\n    //camPosition *=  rotationMatrix(vec3(1., 0., 0.), radians(90.0 )); // make it wavy\n    \n\t// light compute (fake fire light)\n\t// how does the eclipse behve if we move the lightsource?\n    \n    // so if it needs to be northern minight sun sun has too appear at +20?\n    //vec3 lightPos1 = vec3(00.0,1300.0,-3840.400);\n    \n    // recenter scanline 0\n//    vec3 lightPos1 = vec3(00.0, 0. * 1300.0,-3840.400);\n    \n    \n    \n    // looky sun as seen within a year.\n    vec3 lightPos1 = vec3(00.0, \n                          1. * 1300.0 * sin(iTime * 0.005),\n                          -3840.400);\n    \n    \n\t\n\t//vec3 lightColor1 = vec3(1.0,0.7,0.0);\n\t//vec3 lightColor1 = vec3(0.7,0.7,0.7);\n\t\n\t//Update World\n\tfloat rotAngle = PI + SAT_ROTATION_SPEED * iTime; \n    \n    \n    //#define SATELITE_RADIUS 12.0\n \n\t\t\n\t//Compute Screen Shadow\n\t//vec3 barPos = camPosition + rayRaw*0.5*BAR_DEPTH;\n\t//vec3 lightDirExt = normalize(camPosition - barPos);\n\t//float screen_shadow = GetShadows(barPos,lightDirExt);\n\t\n\t//Start Ray\n    vec3 finalcolor = vec3(0.0);\n    \n    // need it be dynamic?\n    // ISO\n\t\n    // degamma?\n    float attenuation = 11.0;\n    attenuation += 8.5 * (cos(camAngle));  \n    //attenuation = 5.0;\n    \n    \n    vec3 lightColor1 = vec3(2.0,2.*0.7,0.0);\n    \n//    lightColor1 = 0.01 * vec3(2.0,2., 2. - (1.+cos(camAngle)));\n    \n    //finalcolor += 0.05 * vec3(\n    //    0.2* sin(camAngle / 2.),\n    //    0.2 * sin(camAngle / 2.),\n    //    1.0  * sin(camAngle / 2.)\n    //);\n    \n    //finalcolor.b += 0.01 * (  1.0 * 1.0  * sin(camAngle /2. ));\n    \n    \n    //finalcolor.b = .03;\n             \n    //if (cos(camAngle) < 0.)\n    // lightColor1 =  vec3(0.1,0.1,0.1);\n\t\n    \n    //attenuation = 0.2; // daytime\n\t//lightColor1 = vec3(0.7,0.7,0.7);\n    // at daylight we just need the pre lit map to show? in this case blue.\n    // in night time. yellow sun is cool.\n    \n       \n\n    int space = 0;\n    \n    for( int imoon=0; imoon<28; imoon++ )\n    {\n         vec2 tmat;\n        \n            vec3 ballPos = vec3(0.0, 0.0, 0.0);\n        \n        float mooncycle = float(imoon) / 28. * 3.14 * 2. ;\n\n\n        // will it work for shadows?\n        ballPos = \n            vec3(\n                 //sin(float(imoon)),\n                \n                0,\n\n                 // blue to red in 14 days\n                 //-2. * cos(float(iFrame) * 0.01), 0.)+\n            //-2. * cos(camAngle / 14.)\n\n                 // how far must the sun then be?\n                 // how hight can the moon be so we can still get an eclipse?\n                 //1.7\n\n                 //1. * 1300.0 * sin(iTime * 0.05)\n                 // 1. * 135.0 * sin(iTime * 0.005 * 12.)\n\n                 //1. * 135.0 * (float(imoon) / 28.)\n\n                 // 135.\n\n                 \n                 //float(-1 + imoon) * 20.\n                 \n                 //1.\n                 //20. * float(imoon)\n                \n                135. * sin (mooncycle)\n                 //0.1\n                 //0.000001 * float(imoon)\n\n                 \n                 //1.\n                 ,  \n                \n                0.\n                // cos(float(imoon))\n            )+\n\n            SATELITE_RADIUS * vec3(\n            sin(rotAngle + mooncycle),\n            0.0,\n            cos(rotAngle + mooncycle));\n\n\n      \n        finalcolor += draw(imoon,ballPos,\n                          camPosition,\n                           rayDir,\n                           lightPos1,\n                            lightColor1 ,\n                           \n                            attenuation,\n                           \n                           // out\n                            tmat,\n                           space\n                          );\n        \n       \n            // actually. it hase to be false for all moons\n            \n\t}\n    \n \t\t\tif (space == 0)\n            {\n                //stars achieved via noise texture\n                //vec2 angles = vec2(atan(rayDir.z/abs(rayDir.x)),acos(rayDir.y));\t\n                //float a1 = texture(iChannel1,angles).x;\n                //float a2 = texture(iChannel1,angles*2.0+0.01).x;\n                //float a3 = texture(iChannel1,angles*2.1+0.07).x;\n                //float a4 = texture(iChannel1,angles*5.0+0.03).x;\n\n                //float stars = smoothstep(0.1,1.0,a1*a2*a3*a4);\n\n                //stars = 0.;\n\n\n                float sun = 1000.0 * pow(max(dot(normalize(lightPos1 - camPosition),rayDir),0.1),100000.0);\n\n\n                // overrride. cant have stars be much brighter than unlit moon\n\n                // what about milkiway?\n\n\n                //if (p.y > -0.7 &&  p.y < 0.7)\n                {\n\n\n                    //if (p.x > -0.5)\n                    {\n                        // overide ISO\n                        //attenuation = 0.7;\n                    }\n\n                //\tfinalcolor += attenuation*(lightColor1*sun + stars*vec3(0.5));\n                    finalcolor += attenuation*(lightColor1*sun  );\n\n\n                    finalcolor+=finalcolor;\n\n\n                        //attenuation *= 0.005;\n                        //attenuation *= 0.05;\n                        attenuation *= 0.01;\n\n\n                    //attenuation -= 2.0;\n\n                    // will kill fps on fullscreen \n                    finalcolor += attenuation * startrails( rayDir);\n\n                }\n                //else\n                {\n                // show stars from scanline concept\n                }\n\n\n                attenuation = 0.0;\n            }\n    \n    \n    vec3 rgb1 = vec3(0.0);\n\n    vec3 rd1 = rayDir;\n    \n    float lat180 = (acos(-rd1.y) / 3.1415926535897932384626433832795) * 180. ;\n\nfloat hlat180 = (acos(-rd1.y) / 3.1415926535897932384626433832795) * 180. ;\n//float hlng360 = -(atan(rd0.z, rd0.x) / 6.283185307179586476925286766559) + 0.5;\n\n//if (hlat180  > 90.|| (mod(float(lng360blue), 2. * dashsize) >= dashsize))\n{\n line_rgb(rgb1, lat180, 90. +20., 0.3, vec3(1.0, 0, 0)* 0.5);\n //line_rgb(rgb1, lat180, 90. +16., 0.3, vec3(1.0, 0, 0) * 0.5);\n            \n            \n            // center line\n\n            //line(fragColorR, lat180, 90. - 19., 1., 0.8);\n            //line_rgb(rgb1, lat180, 90. , 0.19, vec3(1.0, 1.0, 0));\n            //line_rgb(rgb1, lat180, 90. + 3., 0.19, vec3(1.0, 1.0, 0)*0.5);\n\t\t\t//line_rgb(rgb1, lat180, 90. - 3., 0.19, vec3(1.0, 1.0, 0)*0.5);\n\n            \n              // lower line\n            //line(fragColorR, lat180, 90. + 19., 1., 0.4);\n            //line_rgb(rgb1, lat180, 90.- 16., 0.3, vec3(0.0, 0.0,1.0)* 0.7);\n            line_rgb(rgb1, lat180, 90.- 20., 0.3, vec3(0.0, 0.0,1.0)* 0.5);\n    \n}\n \n    // hide HUD after init\n    if (iFrame < 60)\n    if (camDist <50.)\n    \tfinalcolor+= rgb1;\n\t \n\t// desaturation, gamma correction\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\n    fragColor = vec4( finalcolor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBfDW", "name": "Spiraling", "author": "zaiyugi", "description": "Spiraling down", "tags": ["raymarching"], "likes": 1, "viewed": 94, "date": "1500401799", "time_retrieved": "2024-06-20T18:58:09.900420", "image_code": "#define M_PI 3.141592\n#define STEPS 150\n\nvec3 light_p = vec3(0.0, 0.0, 0.0);\nvec3 light_n = normalize(vec3(0.0, -1.0, 0.0));\nvec3 light_C = vec3(0.9, 1.0, 0.9);\n\nfloat rad2deg = 180.0 / M_PI;\nfloat deg2rad = M_PI / 180.0;\n\nfloat g_Epsilon = 0.002;\n\nvec3 rotate(in vec3 p, float t)\n{\n    float theta = t * deg2rad;\n\tmat3 mtx = mat3(\n   \t\tcos(theta), -sin(theta), 0.0,\n    \tsin(theta), cos(theta), 0.0,\n    \t0.0, 0.0, 1.0\n\t);\n    return p * mtx;\n}\n\nfloat sdf(vec3 p)\n{\n    p = rotate(p, 30.0 * p.z * 0.075);\n\tvec3 q;\n    q.x = mod(p.x, 5.0) - 2.5;\n    q.y = mod(p.y, 5.0) - 2.5;\n    q.z = mod(p.z, 0.3) - 0.15;\n    \n\treturn length(q) - 0.8;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = g_Epsilon;\n\treturn normalize(vec3(\n\t\tsdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n\t\tsdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n\t\tsdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))\n\t));\n}\n\nfloat shadow(vec3 r0, vec3 rd, float maxt, float k)\n{\n\tfloat t = g_Epsilon;\n\tfloat res = 1.0;\n    vec3 p;\n\tfor( int i = 0; i < 100; ++i )\n\t{\n\t\tif( t >= maxt )\n\t\t\tbreak;\n\n        p = rd*t + r0;\n\t\tfloat h = sdf(p);\n\t\tif(h < g_Epsilon*0.1)\n\t\t\treturn 0.0;\n\t\tres = min( res, k * h / t );\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nfloat light(vec3 p)\n{\n\tvec3 ro = light_p;\n\tvec3 rd = normalize(p - ro);\n\n\tfloat shadowFactor = 0.0;\n\t//if( acos(dot(rd, light_n)) * rad2deg < 45.0 )\n\t\tshadowFactor = shadow( p, -rd, length(p - ro), 5.0 );\n\t    \n\treturn shadowFactor;\n}\n\nvec3 raymarch(vec3 r0, vec3 rd)\n{\n\tvec3 color = vec3(0.0, 0.05, 0.1);\n\tfloat t = 0.0;\n                \n\tvec3 p; int j = 0;\n\tfor(int i = 0; i < STEPS; ++i)\n\t{\n\t\tp = rd * t + r0;\n\t\tfloat d = sdf(p);\n\t\tif(d < g_Epsilon)\n\t\t{\n\t\t\tj = i;\n            break;\n\t\t}\n\t\tt += d;\n\t}\n    \n    float sf = light(p);\n    \n    color = vec3(1.0, 0.5, 0.0);\n    \n    // Blinn-Phong shading\n    // Diffuse\n\tvec3 N = getNormal(p);\n\tvec3 toLgt = normalize(light_p - p);\n\tfloat Id = dot( N, toLgt );\n\tcolor = color * Id;\n    \n    // Specular\n    vec3 H = normalize(toLgt + -rd);\n\tfloat Is = pow( dot(H, N), 60.0 );\n\tcolor += vec3(1.0) * Is;\n\tcolor = clamp(color, 0.0, 1.0);\n    \n\tfloat b = 0.015;\n\tfloat fogStrength = 1.0 - exp(-t * b);\n\n    color = mix(color, vec3(0.1, 0.9, 1.0), fogStrength);\n    color *= sf;\n\t\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p_uv = fragCoord.xy / iResolution.xy;\n\t\n    float aspect_ratio = float(iResolution.x) / float(iResolution.y);\n    p_uv = p_uv * 2.0 - 1.0;\n    \n    float angle = -0.05 * iTime * 2.0 * M_PI;\n    float focal_length = 1.0 / tan( 75.0 / 2.0 * deg2rad );\n    \n    light_p = vec3(0.0, 0.0, iTime + 20.0);\n    light_n = vec3(0.0, 0.0, 1.0);\n    \n    vec3 eye = vec3(2.5 * cos(angle), 2.5 * sin(angle), iTime);\n    vec3 focus = vec3(eye.xy, iTime + 1.0);\n    vec3 view = normalize(focus - eye);\n    vec3 up = -normalize(vec3(eye.xy, 0.0));\n    vec3 right = cross(up, view);\n\n    vec3 rd = normalize(view * focal_length + up * p_uv.y + right * p_uv.x * aspect_ratio);\n    vec3 color = raymarch(eye, rd);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBfzy", "name": "[SH17B] Arctic Patrol", "author": "dr2", "description": "Help keep the north safe (mouse enabled)", "tags": ["raymarching", "voronoi", "landscape", "hexagon", "aircraft"], "likes": 3, "viewed": 568, "date": "1500909595", "time_retrieved": "2024-06-20T18:58:09.926744", "image_code": "// \"[SH17B] Arctic Patrol\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 flPos, sunDir, qHit, qHitTransObj;\nvec2 gVec[7], hVec[7], gId;\nfloat tCur, dstFar, fusLen, wSpan, vbOff, gRand;\nint idObj;\nbool transObj;\nconst int idFus = 11, idPipe = 12, idWing = 13, idStrut = 14, idHstab = 15,\n   idFin = 16, idLeg = 17, idAxl = 18, idWhl = 19, idNose = 20, idCkpit = 21,\n   idPlt = 22;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.1) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat GrndHt (vec2 p)\n{\n  vec4 sv;\n  float h1, h2, r, s;\n  r = 0.2 * length (Noisev3v2 (0.3 * p));\n  sv = HexVor (0.06 * p + r);\n  s = (0.8 + 0.5 * sv.w);\n  h1 = s * smoothstep (0.1, 0.3 + 0.1 * sv.w, sv.x);\n  h2 = 1.5 * s * smoothstep (0.2, 0.3 + 0.1 * sv.w, max (0.,\n     (0.45 - dot (sv.yz, sv.yz))));\n  return 2.5 * SmoothMax (h1, h2, 0.2) - 0.5;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - 6.) / rd.y;\n    sLo = s;\n    for (int j = 0; j < 150; j ++) {\n      p = ro + s * rd;\n      h = p.y - GrndHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > GrndHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = GrndHt (p.xz);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x, h - GrndHt (p.xz + e.yx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, wr;\n  dMin = dstFar;\n  q = p;\n  wr = -0.2 + q.z / fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n     0.11 * (1. - 0.6 * wr * wr), 1.) * fusLen, 0.05 * fusLen);\n  q -= vec3 (0., 0.1, 0.3) * fusLen;\n  d = max (d, - PrRoundBoxDf (q, vec3 (0.05, 0.1, 0.15) * fusLen,\n     0.03 * fusLen)); \n  if (d < dMin) { dMin = d;  idObj = idFus;  qHit = q; }\n  q = p;  q -= vec3 (0., 0.08, 0.3) * fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.02, 0.15) * fusLen, 0.03 * fusLen); \n  if (d < dMin) { dMin = d;  idObj = idCkpit;  qHit = q; }\n  q = p;  q.z = abs (q.z - 0.33 * fusLen) - 0.08 * fusLen;\n  q -= vec3 (0., 0.17, 0.) * fusLen;\n  d = PrSphDf (q, 0.04 * fusLen); \n  if (d < dMin) { dMin = d;  idObj = idPlt;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 0.8);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCapsDf (q, 0.02 * fusLen, 0.15 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idPipe;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 1.05);\n  d = PrCapsDf (q, 0.05 * fusLen, 0.02 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idNose;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.2);\n  qq = q;  qq.y = abs (qq.y) - 0.21 * fusLen;\n  wr = q.x / wSpan;\n  d = PrFlatCylDf (qq.zyx, 0.24 * (1. - 0.2 * wr * wr) * fusLen,\n     0.01 * (1. - 0.8 * wr * wr) * fusLen, wSpan);\n  if (d < dMin) { dMin = d;  idObj = idWing;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.25);\n  q.xz = abs (q.xz) - fusLen * vec2 (0.5, 0.1);\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.21 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idStrut;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.15, 0.25);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.15 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idStrut;  qHit = q; }\n  float tSpan = 0.35 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.9);\n  wr = q.x / tSpan;\n  d = PrFlatCylDf (q.zyx, 0.15 * (1. - 0.25 * wr * wr) * fusLen,\n     0.007 * (1. - 0.2 * wr * wr) * fusLen, tSpan);\n  q.x = abs (q.x);\n  d = max (d, 0.02 * fusLen - 1.5 * q.x - q.z);\n  if (d < dMin) { dMin = d;  idObj = idHstab;  qHit = q; }\n  float fSpan = 0.32 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.87);\n  q.yz = Rot2D (q.yz, 0.15);\n  wr = q.y / fSpan;\n  d = PrFlatCylDf (q.zxy, 0.15 * (1. - 0.3 * wr * wr) * fusLen,\n     0.007 * (1. - 0.3 * wr * wr) * fusLen, fSpan);\n  d = max (d, - q.y);\n  if (d < dMin) { dMin = d;  idObj = idFin;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.25, 0.5);\n  q.x = abs (q.x) - 0.14 * fusLen;\n  q.xy = Rot2D (q.xy, -0.55);  q.yz = Rot2D (q.yz, 0.15);\n  d = PrCylDf (q.xzy, 0.013 * fusLen, 0.12 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idLeg;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.34, 0.515);\n  q.x = abs (q.x) - 0.22 * fusLen;\n  d = PrCylDf (q.yzx, 0.01 * fusLen, 0.035 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idAxl;  qHit = q; }\n  q.x -= 0.01 * fusLen;\n  d = PrCylDf (q.yzx, 0.1 * fusLen, 0.015 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }\n  return dMin;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  vec3 q;\n  q = p - fusLen * vec3 (0., 0.02, 1.07);\n  qHitTransObj = q;\n  return PrCylDf (q, 0.3 * fusLen, 0.007 * fusLen);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP, rs;\n  float dHit, d, s, f;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., SQRT3);\n  edN[2] = 0.5 * vec2 (1., - SQRT3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  rs = ro.xz - flPos.xz;\n  vf = (SQRT3/2.) - vec3 (dot (rs, edN[0]), dot (rs, edN[1]), dot (rs, edN[2]));\n  pM = HexToPix (PixToHex (rs));\n  gIdP = vec2 (-10.);\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro - flPos + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (max (max (abs (gId.x), abs (gId.y)), abs (gId.x + gId.y)) <= 4.) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gRand = Hashfv2 (gId);\n        gIdP = gId;\n      }\n      p.y += vbOff * gRand - 0.5;\n      p.xz -= HexToPix (gId);\n      d = transObj ? TransObjDf (p) : ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.01;\n      pM += SQRT3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  p -= flPos;\n  p.y += vbOff * gRand - 0.5;\n  p.xz -= HexToPix (gId);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  p = ro - flPos;\n  p.y += vbOff * gRand - 0.5;\n  p.xz -= HexToPix (gId);\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (p + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.015;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.1, 0.2, 0.5) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  sd = pow (max (dot (rd, sunDir), 0.), 64.);\n  col = SkyBg (rd) + (0.35 * sd + 0.65 * min (pow (sd, 4.), 0.3)) *\n     vec3 (1., 1., 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec4 FlyerCol (vec3 n)\n{\n  vec3 col, qqHit;\n  float spec, b;\n  spec = 0.2;\n  qqHit = qHit / fusLen;\n  col = HsvToRgb (vec3 (mod (Hashfv2 (gId * vec2 (17., 27.) + 0.5), 1.), 0.8, 1.));\n  if (idObj == idFus) {\n    qqHit.yz -= vec2 (-0.1, -0.7);\n    col = mix (vec3 (0.5, 0.5, 1.), col,\n       (1. - SmoothBump (0.06, 0.09, 0.01, length (qqHit.yz))) *\n       (1. - SmoothBump (-0.01, 0.03, 0.01, length (qqHit.yz))));\n    if (n.z > 0.9 && qqHit.y < -0.03) col *= 0.3;\n  } else if (idObj == idWing) {\n    b = wSpan / (8. * fusLen);\n    b = mod (qqHit.x + 0.5 * b, b) - 0.5 * b;\n    col *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, b);\n    if (abs (qqHit.x) > 0.7)\n       col *= 1. - 0.6 * SmoothBump (-0.128, -0.117, 0.002, qqHit.z);\n    if (qqHit.z < -0.125)\n       col *= 1. - 0.6 * SmoothBump (0.695, 0.705, 0.002, abs (qqHit.x));\n    if (qqHit.y * n.y > 0.) {\n      qqHit.x = abs (qqHit.x) - 0.8;\n      qqHit.z -= 0.03;\n      col *= mix (vec3 (0.5, 0.5, 1.), col,\n         (1. - SmoothBump (0.08, 0.12, 0.01, length (qqHit.xz))) *\n         (1. - SmoothBump (-0.01, 0.03, 0.01, length (qqHit.xz))));\n    }\n  } else if (idObj == idFin || idObj == idHstab) {\n    col *= 1. - 0.6 * SmoothBump (-0.062, -0.052, 0.002, qqHit.z);\n  } else if (idObj == idStrut || idObj == idLeg) {\n    col = 0.6 * col + vec3 (0.4);\n  } else if (idObj == idPipe || idObj == idNose) {\n    col = HsvToRgb (vec3 (mod (Hashfv2 (gId * vec2 (17., 27.) + 0.5) + 0.5, 1.), 1., 1.));\n    spec = 0.7;\n  } else if (idObj == idAxl) {\n    col = vec3 (0.3, 0.2, 0.);\n  } else if (idObj == idCkpit) {\n    col = vec3 (0.2, 0.15, 0.05);\n  } else if (idObj == idPlt) {\n    col = vec3 (0.1, 0.07, 0.);\n    if (n.z > 0.7) {\n      col *= 2.;\n      qqHit.x = abs (qqHit.x) - 0.015 * fusLen;\n      col *= (1. - 0.9 * SmoothBump (0.003, 0.01, 0.001, length (qqHit.xy)));\n    }\n  } else if (idObj == idWhl) {\n    if (length (qqHit.yz) < 0.07) col = vec3 (0.4);\n    else {\n      col = vec3 (0.02);\n      spec = 0.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, dstPropel, dstGrnd, sh;\n  HexVorInit ();\n  dstGrnd = GrndRay (ro, rd);\n  transObj = true;\n  dstPropel = ObjRay (ro, rd);\n  transObj = false;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstPropel) dstPropel = dstFar;\n  if (dstGrnd < min (dstObj, dstFar)) {\n    ro += dstGrnd * rd;\n    if (ro.y > 0.1) {\n      vn = VaryNf (1.3 * ro, GrndNf (ro), 2.);\n      vn = VaryNf (15. * ro.zyx, vn, 0.5);\n      col = vec3 (1.);\n      col = col * (0.1 + 0.2 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n         0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    } else {\n      vn = VaryNf (5.1 * ro, vec3 (0., 1., 0.), 0.2);\n      rd = reflect (rd, vn);\n      col = mix (vec3 (0.15, 0.2, 0.15), vec3 (0.1, 0.1, 0.2), Fbm2 (ro.xz));\n      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.8, 0.95,\n          1. - pow (dot (rd, vn), 3.)));\n    }\n    col = mix (col, SkyBg (rd), max (pow (dstGrnd / dstFar, 4.) - 0.2, 0.));\n  } else if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (sunDir, vn), 0.)) +\n       col4.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n  } else col = SkyCol (ro, rd);\n  if (dstPropel < dstFar) col = vec3 (0.1) * (1. - 0.3 * SmoothBump (0.25, 0.27,\n     0.006, length (qHitTransObj.xy) / fusLen)) + 0.7 * col;\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, f, flyVel, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  rd = normalize (vec3 (uv, 1.7));\n  fusLen = 0.45;\n  wSpan = 1.2 * fusLen;\n  flyVel = 5.;\n  flPos = vec3 (0., 16., flyVel * tCur);\n  vbOff = 2. * cos (0.1 * tCur);\n  ro = vec3 (0., 2., -8.);\n  if (mPtr.z > 0.) {\n    el = 0.6 * pi * mPtr.y;\n    az = 2.1 * pi * mPtr.x;\n  } else {\n    t = mod (0.03 * tCur, 2.);\n    el = 0.2 * pi * sign (t - 1.) * SmoothBump (0.25, 0.75, 0.2, mod (t, 1.));\n    az = - pi * sin (0.005 * 2. * pi * tCur);\n  }\n  ro.yz = Rot2D (ro.yz, el);\n  ro.xz = Rot2D (ro.xz, az);\n  ro += flPos;\n  vd = normalize (flPos + vec3 (0., -8. * sin (el), 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * rd;\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 1., - sin (0.01 * tCur)));\n  dstFar = 200.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, cHashA3.xy));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsjBD1", "name": "Basic orbit trapping", "author": "Slyth", "description": "Just messing around with basic orbit trap layering. Change i to 0 to see the mandelbrot set.", "tags": ["fractal"], "likes": 1, "viewed": 129, "date": "1500349929", "time_retrieved": "2024-06-20T18:58:09.927741", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float maxIter = 256.0;\n    vec2 r = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 z = vec2(0.0);\n    float zoom = 0.1;\n    vec2 xy = vec2(r.x, r.y);\n    vec2 c = vec2(-0.245, 0.0) + xy / (zoom * 10.0);\n    float distD = 1e20;\n    float distP = distD;\n    vec2 pointD = vec2(sin(iTime), cos(iTime));\n    vec2 pointP = vec2(pointD.x, -pointD.y);\n    float l = ((sin(iTime * 0.5) + 1.0) * 0.5) * maxIter - 1.5;\n    for(int i = 0; i >= 0; i++) // change i to 0 for mandelbrot set\n\t{\n    \tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\t\tif(z.x * z.x + z.y * z.y > maxIter * maxIter || l > maxIter) break;\n        distD = min(distD, pow(cos(abs(z.x - pointD.x) + abs(z.y - pointD.y)), 2.0));\n        distP = min(distP, pow(sin(abs(z.x - pointP.x) + abs(z.y - pointP.y)), 2.0));\n        l++;\n\t}\n    \n    distD = pow(sqrt(distD), 0.6);\n    distP = pow(sqrt(distP), 0.6); \n    fragColor = vec4(vec3(distD, distP, (distD + distP) / 2.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsjBRc", "name": "36.0070", "author": "etrepum", "description": "sin", "tags": ["sin"], "likes": 1, "viewed": 91, "date": "1501532848", "time_retrieved": "2024-06-20T18:58:09.927741", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord / iResolution.xy;\n    float dt = 2.0 * sin(iTime * 0.1);\n    float theta = (iTime * (6.0 + dt)) + u.x * M_PI * 2.0;\n    vec3 rgb = 1.0 - abs(u.y - (0.5 + 0.25 * sin(theta + dt * vec3(0, 1, dt))));\n\tfragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsjBRD", "name": "Wigglestrips", "author": "cacheflowe", "description": "A quick little experiment in stripes & noise", "tags": ["noise", "blackandwhite", "sin", "moire"], "likes": 26, "viewed": 1235, "date": "1499833356", "time_retrieved": "2024-06-20T18:58:09.927741", "image_code": "// simple noise from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x += 0.2 * sin(iTime + uv.y * 4.);\n    float numLines = 15. + fragCoord.y * 0.4;\n    float colNoise = noise(0.6 * uv.x * numLines);\n    float colStripes = 0.5 + 0.5 * sin(uv.x * numLines * 0.75);\n    float col = mix(colNoise, colStripes, 0.5 + 0.5 * sin(iTime));\n    float aA = 1./(iResolution.x * 0.005) ;\n    col = smoothstep(0.5 - aA, 0.5 + aA, col);\n\tfragColor = vec4(vec3(col),1.0);\n}\n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjBRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsjBz1", "name": "Voronoi Of The Week", "author": "dr2", "description": "Another rounded Voronoi shader - see the source.", "tags": ["voronoi", "hexagon", "rounding", "partition"], "likes": 7, "viewed": 576, "date": "1499593978", "time_retrieved": "2024-06-20T18:58:10.791522", "image_code": "// \"Voronoi Of The Week\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Smoothed (rounded) Voronoi partitioning based on random points in the cells of a\n hexagonal lattice. Only 7 distances required - compare with 32 in Shane's latest, 34 in\n iq's second neighbor technique, or 9 for nearest neighbors on the square lattice. \n (More discussion in \"Honeycomb Voronoi\".) Chacun  son got.\n*/\n\nfloat SmoothMin (float a, float b, float r);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec2 gVec[7], hVec[7];\nfloat tCur;\nconst float pi = 3.14159;\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (SQRT3/2.) - p.x + 0.5 * min (p.x - SQRT3 * p.y, 0.);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5) * tCur;\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec3 ShowScene (vec2 p)\n{\n  vec4 vc;\n  vec3 col, vn, ltDir;\n  vec2 g;\n  ltDir = normalize (vec3 (-1., 0.7, -1.));\n  HexVorInit ();\n  vc = HexVor (p);\n  vn = normalize (vec3 (vc.y, 0.4, vc.z));\n  vc.yz *= smoothstep (0.1, 0.15, vc.x);\n  col = vec3 (1.) * (0.1 * vn.y * vn.y + 0.4 * dot (vn, ltDir)) +\n     0.3 * pow (max (dot (normalize (ltDir + vn), vn), 0.), 64.) +\n     mix (vec3 (0., 0.3, 1.), vec3 (1.),\n     min (Fbm2 (4. * tan (0.5 * vc.yz) + 10. * vc.w + 0.3 * tCur) + 0.1, 1.));\n  g = smoothstep (0.05, 0.1, mod (4. * tan (0.5 * vc.yz), 1.));\n  col = mix (col, vec3 (0.5, 0.5, 0.6) * (0.6 + 0.4 * g.x * g.y), 0.5);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  fragColor = vec4 (ShowScene ((canvas.x / 150.) * uv + 0.4 * (tCur + 20.)), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjBz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsjBzz", "name": "Cube Edges", "author": "wutzhuhn", "description": "This shader will iterate over all possible combinations of the edges of a cube. Since a cube has 12 edges there are 2^12 = 4096 variations.\n\nThe interpolation function used for the animation: http://www.wolframalpha.com/input/?i=1%2F(1%2Be%5E(sin(x)*8))", "tags": ["2d", "sdf", "animation"], "likes": 6, "viewed": 248, "date": "1499254316", "time_retrieved": "2024-06-20T18:58:10.791522", "image_code": "const vec2 edges[] = vec2[](\n    vec2(0.1, 0.25), vec2(0.5, 0.1 ), // a, b\n    vec2(0.5, 0.1 ), vec2(0.9, 0.25), // b, c\n    vec2(0.9, 0.25), vec2(0.5, 0.4 ), // c, d\n    vec2(0.5, 0.4 ), vec2(0.1, 0.25), // d, a\n    \n    vec2(0.1, 0.75), vec2(0.5, 0.6 ), // e, f\n    vec2(0.5, 0.6 ), vec2(0.9, 0.75), // f, g\n    vec2(0.9, 0.75), vec2(0.5, 0.9 ), // g, h\n    vec2(0.5, 0.9 ), vec2(0.1, 0.75), // h, e\n    \n    vec2(0.1, 0.25), vec2(0.1, 0.75), // a, e\n    vec2(0.5, 0.1 ), vec2(0.5, 0.6 ), // b, f\n    vec2(0.9, 0.25), vec2(0.9, 0.75), // c, g\n    vec2(0.5, 0.4 ), vec2(0.5, 0.9 ));// d, h\n\nfloat line(vec2 p1, vec2 p2, float f)\n{\n    vec2 d = (p1 - p2) * f;\n    return length(p1 - d * clamp(dot(p1, d) / dot(d, d), 0.0, 1.0));\n}\n\nfloat scene(vec2 p)\n{\n    float all = 100000.0;\n    for (int i = 0; i < 12; ++i)\n    {\n        float pwr = pow(2.0, float(i));\n        // feeding a sin into a sigmoid function to get a nice animation:\n        float t = 1.0 / (1.0 + exp(-sin(iTime / pwr + 1.0) * 8.0 * pwr)); \n        all = min(all, line(edges[i * 2] - p, edges[i * 2 + 1] - p, t));\n    }\n    return all;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float thickness = 0.5 / iResolution.y;\n\n\tvec2 uv = (fragCoord.xy - vec2((iResolution.x - iResolution.y) / 2.0, 0.0)) / iResolution.yy;\n    float d = scene(uv);\n    float p = clamp((d - thickness) * iResolution.y, 0.0, 1.0) * // main lines\n              (0.9 + 0.1 * (sin(d * iResolution.y * 2.0) * 0.5 + 0.5)) * // light background lines\n              smoothstep(0.0, 1.0, d * 1.25 + 0.75); // shadow around main lines\n\tfragColor = vec4(mix(vec3(0.25, 0.3, 0.35), vec3(0.75, 0.85, 0.9), p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjBzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslBDs", "name": "Flipping Truchet", "author": "AntoineC", "description": "Having fun with Truchet tiling.", "tags": ["2d", "truchet", "tiling"], "likes": 5, "viewed": 139, "date": "1498940804", "time_retrieved": "2024-06-20T18:58:11.476327", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Flipping Truchet\" by Antoine Clappier - July 2017\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n// Inspired by the paintings of Jean-Claude Ferry who studied Truchet tiles.\n// See: http://jcferry.pagesperso-orange.fr/peinture/peinture/talon_architecte.html\n\n\n\n// Antialiasing parameter:\nfloat Epsilon;\n\n// Draw antialiased disk:\nfloat Disk(vec2 P,float Radius, vec2 Center)\n{\n    float d = length(P-Center) - Radius;\n    return 1.0 - smoothstep(-Epsilon, Epsilon, d);\n}\n\n// Draw square:\nfloat Square(vec2 P, float Size)\n{\n  return step(abs(P.x), Size)*step(abs(P.y), Size);\n}\n\n// Draw pattern:\nfloat Pattern(vec2 P, float Flip)\n{\n    // Flip:\n\tP = mix(P, vec2(P.x, -P.y), Flip);\n    \n    // Parameters:\n    float a0 = 0.4;\n    float a1 = 2.0*a0;\n    float a2 = 3.0*a0;\n    float a3 = 4.0*a0;\n    float a4 = 5.0*a0;\n    vec2 c0 = vec2(-1.0, 1.0);\n    vec2 c1 = vec2( 1.0, 1.0);\n    vec2 c2 = vec2( 1.0,-1.0);\n    vec2 c3 = vec2(-1.0,-1.0);\n    \n    // Draw shapes:\n    float d0 = Disk(P, a4, c3), d1 = Disk(P, a3, c1);\n    float d2 = Disk(P, a4, c1), d3 = Disk(P, a3, c3);\n    \n    float d4 = Disk(P, a2, c3), d5 = Disk(P, a1, c3);\n    float d6 = Disk(P, a2, c1), d7 = Disk(P, a1, c1);\n    \n    float ds0 = Disk(P, a0, c0), ds1 = Disk(P, a0, c1);\n    float ds2 = Disk(P, a0, c2), ds3 = Disk(P, a0, c3);\n    \n    // Blend:\n    float d = (d0*d1 + d2*d3 + 1.0*(d4-d5) + 1.0*(d6-d7)) / 2.0 + (ds0+ds2)*(1.0-d0*d2) + ds1 + ds3;\n    return d;\n}\n\n\nfloat Rand(vec2 P)\n{\n    return fract(sin(dot(P.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Setup:\n    float minResolution = min(iResolution.x, iResolution.y);\n\tvec2 uv = 2.0*(fragCoord.xy - iResolution.xy/2.0) / minResolution;\n    float t = iTime / 5.0;\n    \n    // Antialiasing gradient size: \n    Epsilon = 2.0/minResolution;\n\n    // Geometry:\n    float blackDisk = Disk(uv, 0.81, vec2(0.0));\n    float whiteSquare = Square(uv, 0.675);\n    \n    // Grid:\n    float scaling = 2.77;\n    vec2 grid = scaling*(vec2(abs(uv.x), uv.y));\n    vec2 gridIndex = floor(grid);\n    vec2 tile = 2.0*fract(grid) - vec2(1.0);\n    \n    // Draw tile with random orientation:\n    Epsilon *= 2.0*scaling;\n    float tile0 = Pattern(tile, floor(2.0*Rand(gridIndex+floor(vec2(t)))));\n    float tile1 = Pattern(tile, floor(2.0*Rand(gridIndex+floor(vec2(1.0+t)))));\n    \n    // Smooth transition between randomm tiles:\n    float speed = 0.2;\n    float k = (1.0-speed)*Rand(floor(grid));\n    float d = mix(tile0, tile1, smoothstep(k, k+speed, fract(t)));\n    \n    // Shade:\n    vec3 back = vec3(121., 156., 210.) / 255.;\n    d = 0.05+0.94*d;\n    vec3 c1 = mix(back, d*back, blackDisk);\n    vec3 c2 = mix(back, vec3(1.0), d);\n    vec3 color = mix(mix(c1, c2, whiteSquare), vec3(d), whiteSquare*blackDisk);\n\n\t// Framing and vignetting:\n    color *= Square(uv, 1.0);\n    color *= 1.0 - 0.15*pow(length(uv), 3.0);\n                  \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslBDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSBWh", "name": "[SH17A] Space fungus", "author": "FabriceNeyret2", "description": "variant of [url]https://www.shadertoy.com/view/ldlyD2[/url]\ngolfed and inspired by [url]https://www.shadertoy.com/view/lslcWj[/url]", "tags": ["raymarching", "2tweets", "golf", "notgyroid"], "likes": 19, "viewed": 890, "date": "1500203645", "time_retrieved": "2024-06-20T18:58:11.779263", "image_code": "// variant of https://www.shadertoy.com/view/ldlyD2\n// golfed and inspired by https://www.shadertoy.com/view/lslcWj\n\n/**/\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime, a,b; // s =  10.; \n    mat2  R = mat2( sin(t+1.57*vec4(1,2,0,1)) );\n    vec3  q = iResolution,\n          D = vec3((U+U-q.xy)/q.y, -1),\n          p = 15./q;  // 1.5*s;\n\n    for ( O+=1.-O; O.x > 0. && t > .01 ; O-=.015)\n        q = p,\n        q.xz *= R,\n        q.yz *= R,\n        t = max( length(q) - 9.,  // -s                         // Sphere\n                 abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ), // /s   // EggCarton\n        p += t*D;\n\n    O.r -= b/30.;\n    O.g -= a;\n}\n/**/\n\n\n\n\n\n/**  // variants\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime*.5, a,b,c,\n          s =  17.; // 6.25 + 2.75* sin(t*.86);\n    mat2  R = mat2( sin(t+1.57*vec4(1,2,0,1)) );\n    vec3  q = iResolution,\n          D = vec3((U+U-q.xy)/q.y, -1),\n          p=q-q; p.z = 1.5;\n\n    for ( O+=1.-O; O.x > 0. && t > .001 ; O-=.015)\n        q = s*p,\n        q.xz *= R,\n        q.yz *= R,\n      //t = max( length(q) - s,                        // Sphere\n      //t = max( abs(length(q) - s)-.2,                // sliced\n        t = max( abs(abs(length(q) - s)-.8)-.2,        // sliced\n        //       abs(k=dot(q=sin(q),D/D))/6.) / s,     // EggCarton\n        //       abs(k=dot(q=sin(q),D/D))/6.-.06) / s, // EggCarton\n                 abs(c=abs(b=abs(a=dot(q=sin(q),D/D))-.6)-.3)/6.) / s, // EggCarton\n        p += t*D;\n    // O += vec4(c,b,a,0)/2.;\n    O *= sign(vec4(c,b,a,0));\n    //O.g *= sign(a);\n    //O = sin(O*vec4(1,9,19,0));\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssBWl", "name": "Checkerboard texture test", "author": "yumcyawiz", "description": "checkerboard texture test", "tags": ["raymarching"], "likes": 0, "viewed": 147, "date": "1499262378", "time_retrieved": "2024-06-20T18:58:11.779504", "image_code": "float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nstruct Obj {\n    int objType;\n    float d;\n};\nObj opU(Obj obj1, Obj obj2) {\n    if(obj1.d < obj2.d) {\n        return obj1;\n    }\n    else {\n        return obj2;\n    }\n}\n\n\nObj df(vec3 p) {\n    Obj obj1 = Obj(1, sdSphere(p, 1.0));\n    Obj obj2 = Obj(2, sdBox(p + vec3(0, -1, 0), vec3(5.0, 0.01, 5.0)));\n    Obj obj3 = Obj(1, sdSphere(p + vec3(2, -0.5, 0), 0.5));\n    Obj obj4 = Obj(1, sdSphere(p + vec3(-2, -0.5, 0), 0.5));\n    Obj obj = opU(obj1, obj2);\n    obj = opU(obj, obj3);\n    obj = opU(obj, obj4);\n    return obj;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        df(p + vec3(eps, 0, 0)).d - df(p - vec3(eps, 0, 0)).d,\n        df(p + vec3(0, eps, 0)).d - df(p - vec3(0, eps, 0)).d,\n        df(p + vec3(0, 0, eps)).d - df(p - vec3(0, 0, eps)).d\n        ));\n}\n\n\nstruct Ray {\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n    bool hit;\n    float minDist;\n    Obj hitObj;\n    vec3 rayDir;\n};\nconst int maxStep = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    float t = 0.0;\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float minDist = 10000.0;\n    Obj hitObj = Obj(0, 0.0);\n    \n    for(int i = 0; i < maxStep; i++) {\n        vec3 p = from + t*rayDir;\n        Obj obj = df(p);\n        if(obj.d < minDist) {\n            minDist = obj.d;\n        }\n        if(obj.d < 0.01) {\n            p -= 0.01*rayDir;\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            hitObj = obj;\n            break;\n        }\n        t += obj.d*0.9;\n    }\n    \n    return Ray(hitPos, hitNormal, steps, t, hit, minDist, hitObj, rayDir);\n}\n\n\n//checkerboard texture (u, v) -> color\nvec3 checkerboard(float u, float v, float interval) {\n    /*\n    float um = mod(u, interval);\n    float vm = mod(v, interval);\n    if(um < interval/2.0 && vm < interval/2.0) {\n        return vec3(0.1);\n    }\n    else if(um >= interval/2.0 && vm < interval/2.0) {\n        return vec3(1.0);\n    }\n    else if(um < interval/2.0 && vm >= interval/2.0) {\n        return vec3(1.0);\n    }\n    else {\n        return vec3(0.1);\n    }\n\t*/\n    u = floor(u/interval*2.0);\n    v = floor(v/interval*2.0);\n    float p = mod(u + v, 2.0);\n    return vec3(0.1 + 0.9*p);\n}\n\n\n//is light visible from point p\nbool isVisible(vec3 p, vec3 lightPos) {\n    Ray tr = trace(p, normalize(lightPos - p));\n    if(!tr.hit) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\nvec3 lightPos = vec3(0, -10, 0);\nvec3 shading(vec3 from, vec3 rayDir) {\n    //raymarch\n    Ray tr = trace(from, rayDir);\n    \n    //if nothing hit return black\n    if(!tr.hit) {\n        return vec3(0.5, 0.7, 0.8);\n    }\n    \n    //texture\n    vec3 tex = vec3(1);\n    Obj hitObj = tr.hitObj;\n    //sphere\n    if(hitObj.objType == 1) {\n        vec3 normal = tr.hitNormal;\n        float u = atan(normal.y, length(normal.xz)) + 3.14;\n        float v = atan(normal.z, normal.x) + 3.14;\n        tex = checkerboard(u, v, 1.0);\n    }\n    //plane\n    else {\n        vec3 hitPos = tr.hitPos;\n        float u = hitPos.x;\n        float v = hitPos.z;\n        tex = checkerboard(u, v, 1.0);\n    }\n    \n    vec3 color = vec3(0.0);\n    //stepsAO\n    vec3 stepsAO = (1.0 - pow(float(tr.steps)/float(maxStep), 1.0)) * vec3(0.5, 0.7, 0.8);\n    \n    //direct illumination\n    bool visible = isVisible(tr.hitPos, lightPos);\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    if(visible) {\n        vec3 lightDir = normalize(lightPos - tr.hitPos);\n        diffuse = max(dot(tr.hitNormal, lightDir), 0.0) * vec3(1.0);\n        specular = pow(max(dot(reflect(-lightDir, tr.hitNormal), -tr.rayDir), 0.0), 8.0) * vec3(1.0);\n    }\n    \n    color = 0.7*diffuse + 0.3*specular + 0.1*stepsAO;\n    \n    color = clamp(color*tex, vec3(0), vec3(1));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    float t = 0.2*iTime;\n    vec3 camPos = vec3(3.0*sin(t), 0, -3.0*cos(t));\n    vec3 camFront = normalize(-camPos);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = -cross(camFront, camUp);\n    float focus = 0.1;\n    vec3 focusPos = camPos + focus*camFront;\n    vec3 sensorPos = 0.1*uv.x*camRight + 0.1*uv.y*camUp + camPos;\n    vec3 rayDir = normalize(focusPos - sensorPos);\n    \n    lightPos = vec3(3.0*cos(2.0*t), -5, 2.0*sin(3.0*t));\n    \n    vec3 color = shading(sensorPos, rayDir);\n    color.x = pow(color.x, 1.0/2.2);\n    color.y = pow(color.y, 1.0/2.2);\n    color.z = pow(color.z, 1.0/2.2);\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssBWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSfR3", "name": "36.0", "author": "etrepum", "description": "bars", "tags": ["rgb"], "likes": 0, "viewed": 58, "date": "1501434530", "time_retrieved": "2024-06-20T18:58:11.779504", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat y = fragCoord.y / iResolution.y;\n    float t = iTime * 6.0;\n    float tr = 0.5 + 0.5 * sin(t * 1.0 + y * M_PI * 6.0 + 0.0 * M_PI);\n    float tg = 0.5 + 0.5 * sin(t * 1.1 + y * M_PI * 6.0 + 0.5 * M_PI * 6.0);\n    float tb = 0.5 + 0.5 * sin(t * 1.2 + y * M_PI * 6.0 + 1.5 * M_PI * 36.0);\n\tfragColor = vec4(tr, tg, tb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSfR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSfRW", "name": "GrowingShrinkingBall", "author": "andreasleeb", "description": "Growing and shrinking ball", "tags": ["2d", "animation", "ball"], "likes": 0, "viewed": 72, "date": "1499710589", "time_retrieved": "2024-06-20T18:58:11.779504", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 xy = 2. * (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(1.);\n    vec4 green = vec4(0., 1., 0., 1.);\n    \n    xy = xy * (1.6 - abs(sin(iTime)));\n    xy.x += sin(iTime * 1.1) / 1.75;\n    xy.y -= sin(iTime) / 10.;\n    \n    const float radius = .5;\n    float m = smoothstep(radius - .005, radius + .005, length(xy));\n    \n    fragColor = mix(green, fragColor, m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSfWD", "name": "[SH17A] 4 in 1 !  variant", "author": "FabriceNeyret2", "description": "variant of Greg's [url]https://www.shadertoy.com/view/MsSBDR[/url]\n\njust in case he can't save it on time (or if he prefers the previous version :-) ). But it's his !\n", "tags": ["2d", "multiple", "sh17a"], "likes": 2, "viewed": 465, "date": "1500409132", "time_retrieved": "2024-06-20T18:58:11.937178", "image_code": "// variant of Greg's https://www.shadertoy.com/view/MsSBDR\n\n#define F fract(iTime\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec2 R = iResolution.xy, U;\n    o = 3. * texture(iChannel1, u/R);\n    U = u / dot( u = u / R.x - .5, u);\n\n    o = mat4( max( U= F +U+U), U.x - U ).yyyy,\n              F+ u.x*u.yyyy*2e3 ),\n              o.g - o.rrrr,\n              texture( iChannel0, F *.2 - vec2(u.x,1)/u.y ) )* -u.y*3.\n        ) * sin( F*.1)*6.3 + vec4(0,2.1,-2.1,0) );\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXBWl", "name": "Shaded Horses (Smooth)", "author": "Ultraviolet", "description": "[WIP]\nAfter a lot of trial and errors, I eventually managed to pull a smooth shaded version of this one: https://www.shadertoy.com/view/lsXfDf\nMouse to zoom and rotate light.", "tags": ["3d", "escher", "tiling", "horses", "reproduction"], "likes": 10, "viewed": 290, "date": "1499181454", "time_retrieved": "2024-06-20T18:58:14.755356", "image_code": "const float M_PI = 3.1415972;\n\n// (half) contour\nconst vec2 vert[] = vec2[](vec2(0,0),\n                             vec2(-0.066934,0.073242), \n                             vec2(-0.096244,0.12762), \n                             vec2(-0.066934,0.22177), \n                             vec2(-0.056485,0.33263), \n                             vec2(0.094141,0.38494), \n                             vec2(0.19246,0.44143), \n                             vec2(0.11297,0.52929), \n                             vec2(-0.033483,0.56905), \n                             vec2(-0.056485,0.53974), \n                             vec2(0.043933,0.47909), \n                             vec2(-0.060658,0.40167), \n                             vec2(-0.16735,0.53557), \n                             vec2(-0.094141,0.65271), \n                             vec2(0.077416,0.67992), \n                             vec2(0.14435,0.83265), \n                             vec2(0.24477,0.95607), \n                             vec2(0.30963,1.0439), \n                             vec2(0.1548,1.0544), \n                             vec2(0.0,1), \n                             vec2(0.079487,1.09), \n                             vec2(0.014655,1.1422), \n                             vec2(0.03138,1.2531), \n                             vec2(0.16318,1.2803), \n                             vec2(0.24894,1.3096), \n                             vec2(0.3117,1.3159), \n                             vec2(0.32846,1.364), \n                             vec2(0.36819,1.318), \n                             vec2(0.4456,1.3054), \n                             vec2(0.61923,1.2824), \n                             vec2(0.61506,1.2197), \n                             vec2(0.66527,1.136), \n                             vec2(0.7092,1.092), \n                             vec2(0.70502,1.0649), \n                             vec2(0.63806,0.9749), \n                             vec2(0.48953,0.8452), \n                             vec2(0.4456,0.71758), \n                             vec2(0.54185,0.68409), \n                             vec2(0.64854,0.66319), \n                             vec2(0.62133,0.77196), \n                             vec2(0.74896,0.85775), \n                             vec2(0.88493,0.93096), \n                             vec2(1.0,1.0));\n\n\n// details (represented as 1 single contour for simplicity)\nconst vec2 det[] = vec2[](\n                            vec2(0.90106,-0.082627),\n                            vec2(1.0248,0.0075632),\n                            vec2(0.90311,-0.079755),\n                            vec2(0.77286,-0.17864),\n                            vec2(0.68331,-0.25935),\n                            vec2(0.6938,-0.34666),\n                            vec2(0.65268,-0.33832),\n                            vec2(0.54527,-0.31598),\n                            vec2(0.44902,-0.28249),\n                            vec2(0.49295,-0.15487),\n                            vec2(0.55592,-0.10055),\n                            vec2(0.50339,-0.09118),\n                            vec2(0.55527,-0.10103),\n                            vec2(0.64418,-0.024416),\n                            vec2(0.51365,-0.01939),\n                            vec2(0.64148,-0.025166),\n                            vec2(0.70729,0.063619),\n                            vec2(0.52041,0.056996),\n                            vec2(0.70844,0.064794),\n                            vec2(0.71262,0.091974),\n                            vec2(0.66869,0.1359),\n                            vec2(0.52323,0.11563),\n                            vec2(0.66969,0.13964),\n                            vec2(0.61848,0.21959),\n                            vec2(0.51691,0.20233),\n                            vec2(0.61918,0.21823),\n                            vec2(0.62265,0.28235),\n                            vec2(0.44889,0.30528),\n                            vec2(0.51704,0.23839),\n                            vec2(0.5199,0.15744),\n                            vec2(0.52367,0.064497),\n                            vec2(0.51128,-0.050781),\n                            vec2(0.49314,-0.15332),\n                            vec2(0.51149,-0.05024),\n                            vec2(0.52346,0.064667),\n                            vec2(0.52052,0.15831),\n                            vec2(0.51594,0.23975),\n                            vec2(0.44902,0.30536),\n                            vec2(0.37142,0.31567),\n                            vec2(0.37547,0.28106),\n                            vec2(0.36137,0.26746),\n                            vec2(0.37519,0.28121),\n                            vec2(0.37161,0.31791),\n                            vec2(0.33188,0.36394),\n                            vec2(0.32632,0.34797),\n                            vec2(0.34413,0.31933),\n                            vec2(0.34757,0.2892),\n                            vec2(0.33379,0.26771),\n                            vec2(0.34748,0.29045),\n                            vec2(0.3442,0.32047),\n                            vec2(0.32571,0.34736),\n                            vec2(0.31512,0.31584),\n                            vec2(0.30578,0.28931),\n                            vec2(0.30406,0.26799),\n                            vec2(0.32059,0.22776),\n                            vec2(0.32034,0.21043),\n                            vec2(0.32035,0.22748),\n                            vec2(0.26329,0.23816),\n                            vec2(0.24109,0.26012),\n                            vec2(0.22483,0.24894),\n                            vec2(0.23993,0.25952),\n                            vec2(0.25707,0.27098),\n                            vec2(0.30386,0.26814),\n                            vec2(0.30433,0.28921),\n                            vec2(0.31554,0.31352),\n                            vec2(0.25236,0.30956),\n                            vec2(0.1666,0.28025),\n                            vec2(0.034805,0.25308),\n                            vec2(0.030179,0.22242),\n                            vec2(0.077108,0.22381),\n                            vec2(0.074181,0.2043),\n                            vec2(0.030134,0.22326),\n                            vec2(0.018075,0.14218),\n                            vec2(0.084837,0.089569),\n                            vec2(0.11915,0.097959),\n                            vec2(0.082915,0.089903),\n                            vec2(-0.0025677,-6.5609e-05),\n                            vec2(0.15822,0.054315),\n                            vec2(0.31362,0.043885),\n                            vec2(0.3884,0.07841),\n                            vec2(0.43726,0.15746),\n                            vec2(0.38916,0.079136),\n                            vec2(0.31305,0.043865),\n                            vec2(0.24819,-0.043995),\n                            vec2(0.14777,-0.16742),\n                            vec2(0.080888,-0.32135),\n                            vec2(0.074893,-0.36311),\n                            vec2(0.080845,-0.32015),\n                            vec2(-0.090715,-0.34736),\n                            vec2(-0.16393,-0.4645),\n                            vec2(-0.057235,-0.5984),\n                            vec2(0.047355,-0.52098),\n                            vec2(-0.0099704,-0.48725),\n                            vec2(-0.098806,-0.54886),\n                            vec2(-0.0094202,-0.48841),\n                            vec2(-0.055624,-0.46084),\n                            vec2(-0.099665,-0.4635),\n                            vec2(-0.055028,-0.46012),\n                            vec2(-0.035162,-0.43163),\n                            vec2(-0.042237,-0.39288),\n                            vec2(-0.033727,-0.43134),\n                            vec2(0.11639,-0.47077),\n                            vec2(0.19626,-0.55953),\n                            vec2(0.21725,-0.49512),\n                            vec2(0.19588,-0.55863),\n                            vec2(0.097565,-0.61512),\n                            vec2(-0.053055,-0.66743),\n                            vec2(-0.063505,-0.77829),\n                            vec2(-0.092815,-0.87244),\n                            vec2(-0.063505,-0.92682),\n                            vec2(0.0034248,-1.0038),\n                            vec2(0.082915,-0.91383),\n                            vec2(0.039776,-0.88191),\n                            vec2(-0.037953,-0.95721),\n                            vec2(0.040105,-0.8818),\n                            vec2(0.015333,-0.86276),\n                            vec2(-0.013385,-0.87653),\n                            vec2(0.015834,-0.8629),\n                            vec2(0.031838,-0.7511),\n                            vec2(0.0063407,-0.71769),\n                            vec2(0.031542,-0.75074),\n                            vec2(0.1666,-0.72348),\n                            vec2(0.25236,-0.69417),\n                            vec2(0.31512,-0.68789),\n                            vec2(0.34387,-0.57387),\n                            vec2(0.32896,-0.64211),\n                            vec2(0.37161,-0.68582),\n                            vec2(0.44902,-0.69837),\n                            vec2(0.623,-0.72085),\n                            vec2(0.66386,-0.65508),\n                            vec2(0.6213,-0.72581),\n                            vec2(0.61848,-0.78414),\n                            vec2(0.66869,-0.86783),\n                            vec2(0.71262,-0.91176),\n                            vec2(0.70844,-0.93894),\n                            vec2(0.64148,-1.0289),\n                            vec2(0.49295,-1.1586),\n                            vec2(0.44902,-1.2862),\n                            vec2(0.4925,-1.3022),\n                            vec2(0.51582,-1.2356),\n                            vec2(0.47125,-1.2109),\n                            vec2(0.51602,-1.2353),\n                            vec2(0.55933,-1.1526),\n                            vec2(0.70232,-1.0529),\n                            vec2(0.77397,-0.95581),\n                            vec2(0.71159,-0.91187),\n                            vec2(0.77337,-0.95437),\n                            vec2(0.7009,-1.0515),\n                            vec2(0.55852,-1.1528),\n                            vec2(0.51422,-1.2402),\n                            vec2(0.62801,-1.2606),\n                            vec2(0.51456,-1.2401),\n                            vec2(0.49324,-1.3029),\n                            vec2(0.54276,-1.3205),\n                            vec2(0.65196,-1.3406),\n                            vec2(0.62475,-1.2318),\n                            vec2(0.75238,-1.146),\n                            vec2(0.88835,-1.0728),\n                            vec2(1.0034,-1.0038),\n                            vec2(0.93723,-0.92682),\n                            vec2(0.90792,-0.87244),\n                            vec2(0.93723,-0.77829),\n                            vec2(0.94768,-0.66743),\n                            vec2(1.0983,-0.61512),\n                            vec2(1.1966,-0.55863),\n                            vec2(1.1171,-0.47077),\n                            vec2(1.0153,-0.44313),\n                            vec2(1.1081,-0.51535),\n                            vec2(1.0797,-0.56628),\n                            vec2(0.97079,-0.62794),\n                            vec2(1.0796,-0.5657),\n                            vec2(1.1076,-0.51499),\n                            vec2(1.0156,-0.44376),\n                            vec2(0.97068,-0.43101),\n                            vec2(0.94768,-0.46032),\n                            vec2(1.0481,-0.52097),\n                            vec2(0.9435,-0.59839),\n                            vec2(0.83681,-0.46449),\n                            vec2(0.75549,-0.50029),\n                            vec2(0.66622,-0.48935),\n                            vec2(0.75619,-0.4978),\n                            vec2(0.83779,-0.46475),\n                            vec2(0.90486,-0.34559),\n                            vec2(0.80353,-0.33633),\n                            vec2(0.91002,-0.34735),\n                            vec2(1.08,-0.31943),\n                            vec2(1.101,-0.27377),\n                            vec2(0.87067,-0.27214),\n                            vec2(1.0966,-0.2737),\n                            vec2(1.1446,-0.16405),\n                            vec2(0.97482,-0.16882),\n                            vec2(1.1485,-0.16741),\n                            vec2(1.2466,-0.042572),\n                            vec2(1.0354,-0.060845),\n                            vec2(1.2489,-0.043995),\n                            vec2(1.3138,0.043865),\n                            vec2(1.1545,0.054315));\n\n\n\n// tiles to explore for creating the base shape\nconst vec2 textureTiles[] = vec2[](vec2(0.0), \n                                   vec2(0.0, 1.0), \n                                   vec2(-1.0, 0.0), \n                                   vec2(-1.0, 1.0));\n\n// tiles to explore for creating the details\nconst vec2 detailTiles[] = vec2[](vec2(0.0), \n                                  vec2(0.0,-1.0), \n                                  vec2(0.0,-2.0), \n                                  vec2(1.0,-1.0), \n                                  vec2(-1.0,-1.0));\n\nvec2 PointLineProj(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n\n    float t = dot(p - p0, d) / dot(d, d);\n    \n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return proj;\n}\n\nfloat PointLineDistance2(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 proj = PointLineProj(p, p0, p1);\n    \n    return dot(proj-p, proj-p);\n}\n\nfloat PointLineDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    return sqrt(PointLineDistance2(p, p0, p1));\n}\n\nvec2 PointSegProj(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n        \n    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return proj;\n}\n\nfloat PointSegDistance2(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 proj = PointSegProj(p, p0, p1);\n    \n    return dot(proj-p, proj-p);\n}\n\n\nvec2 PointSegDirection(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 proj = PointSegProj(p, p0, p1);\n    \n    return proj-p;\n}\n\n\n\nfloat horizontalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    if(p.y < min(p0.y, p1.y) || p.y > max(p0.y, p1.y))\n        return 100000000.0*sign(p1.y-p0.y);\n    \n    float h = p.y-p0.y;\n    float slope = (p1.x-p0.x)/(p1.y-p0.y);\n    float l = p.x-h*slope - p0.x;\n    \n    return l*sign(p1.y-p0.y);\n}\n\n\n\nfloat verticalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    if(p.x < min(p0.x, p1.x) || p.x > max(p0.x, p1.x))\n        return 100000000.0*sign(p1.x-p0.x);\n    \n    float h = p.x-p0.x;\n    float slope = (p1.y-p0.y)/(p1.x-p0.x);\n    float l = p.y-h*slope - p0.y;\n    \n    return l*sign(p1.x-p0.x);\n}\n\n\nfloat escherTextureX(vec2 p)\n{\n    vec2 pp = vec2(mod(p.x+0.5, 1.0)-0.5, mod(p.y,2.0));\n    \n    float d = 1000.0;\n    \n    for(int i=0; i<19; ++i)\n    \tif(abs(horizontalDistance(pp, vert[i], vert[i+1])) < abs(d))\n        {\n            d = horizontalDistance(pp, vert[i], vert[i+1]);\n        }\n    \n    pp = vec2(mod(p.x+0.5, 1.0)-0.5, mod(p.y-1.0,2.0));\n    \n    for(int i=0; i<19; ++i)\n    \tif(abs(horizontalDistance(pp, vert[i], vert[i+1])) < abs(d))\n        {\n            d = horizontalDistance(pp, vert[i], vert[i+1]);\n        }\n    \n    float val = smoothstep(0.0, 1.0, d/0.05);\n    val = d;\n    \n    \n    if(mod(p.x-0.5, 2.0)-1.0 > 0.)\n        val = -val;\n    \n    return val;\n}\n\n\nfloat escherTextureY(vec2 p)\n{\n    vec2 pp = vec2(mod(p.x, 2.0), mod(p.y-.5, 1.0)+0.5);\n    \n    float d = 1000.0;\n    for(int i=19; i<vert.length()-1; ++i)\n    \tif(abs(verticalDistance(pp, vert[i], vert[i+1])) < abs(d))\n            d=verticalDistance(pp, vert[i], vert[i+1]);\n    \n\n    pp = vec2(mod(p.x-1.0, 2.0), mod(p.y-.5, 1.0)+0.5);\n    for(int i=19; i<vert.length()-1; ++i)\n    \tif(abs(verticalDistance(pp, vert[i], vert[i+1])) < abs(d)) \n            d=verticalDistance(pp, vert[i], vert[i+1]);\n    \n    float val = smoothstep(0.0, 1.0, d/0.05);\n    val = d;\n    \n    if(mod(p.y-0.5, 2.0)-1.0 > 0.)\n        val = -val;\n    \n    return val;\n}\n\n\nfloat escherTexture(vec2 p, float pixel_size)\n{\n    float x = escherTextureX(p);\n    float y = escherTextureY(p);\n    \n    x = smoothstep(-1.0, 1.0, x/pixel_size);\n    y = smoothstep(-1.0, 1.0, y/pixel_size);\n    \n    float d = x+y - 2.0 * x*y;\n    \n    return d;\n}\n\n\nfloat escherTextureContour(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<vert.length(); ++i)\n    {       \n        for(int j=0; j<textureTiles.length(); ++j)\n        {\n            d = min(d, PointSegDistance2(pp+textureTiles[j], vert[i], vert[(i+1)%vert.length()]));\n        }\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\n\nfloat escherDetails(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<det.length()-1; ++i)\n    {\n        for(int j=0; j<detailTiles.length(); ++j)\n        {\n            d = min(d, PointSegDistance2(pp+detailTiles[j], det[i], det[i+1]));\n        }\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\nvoid ClosestSeg(vec2 p, out int i_min, out int j_min)\n{\n    \n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n\n    float d_temp;\n    \n    for(int i=0; i<vert.length()-1; ++i)\n    {\n        \n        for(int j=0; j<textureTiles.length(); ++j)\n        {\n            d_temp = PointSegDistance2(pp+textureTiles[j], vert[i], vert[i+1]);\n            if(d_temp < d)\n            {\n                d = d_temp;\n                i_min = i;\n                j_min = j;\n            }\n        }\n    }\n}\n\nvoid ClosestSegDetail(vec2 p, out int i_min, out int j_min)\n{\n    \n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n\n    float d_temp;\n    \n    for(int i=0; i<det.length()-1; ++i)\n    {\n        \n        for(int j=0; j<detailTiles.length()-1; ++j)\n        {\n            d_temp = PointSegDistance2(pp+textureTiles[j], det[i], det[i+1]);\n            if(d_temp < d)\n            {\n                d = d_temp;\n                i_min = i;\n                j_min = j;\n            }\n        }\n    }\n}\n\nfloat getClosestContourSegDistance(vec2 p)\n{\n    p = mod(p,1.0);\n    int i,j;\n    ClosestSeg(p, i, j);\n    return sqrt(PointSegDistance2(p+textureTiles[j], vert[i], vert[i+1]));\n}\n\nvec3 escherNormalSmooth(vec2 p)\n{\n    float d = getClosestContourSegDistance(p);\n    \n    float coef = 0.9*d;\n    vec2 dx = vec2(0.0, 1.0);\n    vec2 dy = vec2(1.0, 0.0);\n    \n    vec2 n = vec2(getClosestContourSegDistance(p+coef*dx) - getClosestContourSegDistance(p-coef*dx),\n                  getClosestContourSegDistance(p+coef*dy) - getClosestContourSegDistance(p-coef*dy));\n    \n    \n    //float alpha = M_PI/4.0;\n    //return vec3(normalize(n)*cos(alpha), sin(alpha));\n    return vec3(normalize(vec3(n, 0.25)));\n    //return vec3(normalize(vec3(normalize(n), 1.0)));\n}\n\nfloat getClosestDetailSegDistance(vec2 p)\n{\n    p = mod(p,1.0);\n    int i,j;\n    ClosestSegDetail(p, i, j);\n    return sqrt(PointSegDistance2(p+textureTiles[j], det[i], det[i+1]));\n}\n\nvec3 escherDetailNormalSmooth(vec2 p)\n{\n    float d = getClosestDetailSegDistance(p);\n    \n    float coef = 0.9*d;\n    vec2 dx = vec2(0.0, 1.0);\n    vec2 dy = vec2(1.0, 0.0);\n    \n    vec2 n = vec2(getClosestDetailSegDistance(p+coef*dx) - getClosestDetailSegDistance(p-coef*dx),\n                  getClosestDetailSegDistance(p+coef*dy) - getClosestDetailSegDistance(p-coef*dy));\n    \n    float alpha = M_PI/4.0;\n    return vec3(normalize(n)*cos(alpha), sin(alpha));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv -= vec2(0.5* iResolution.x / iResolution.y, 0.5);\n    float zoom = 3.5;\n    zoom = 5.0*iMouse.x / iResolution.x;\n    if(iMouse.x < 5.0)\n        zoom = 4.0 + sin(iTime);\n    \n    uv *= zoom;\n    \n    float pixel_size = 1.5*zoom/iResolution.y;\n    float t = escherTexture(uv, pixel_size);\n    \n\tfragColor = vec4(vec3(t),1.0);\n    \n    \n    //vec3 lightDir = vec3(-iResolution.xy/iResolution.y*0.5+iMouse.xy/ iResolution.y, 1.0);\n    //lightDir = lightDir/length(lightDir);\n    float alpha = M_PI / 3.0;\n    float beta = iMouse.y/ iResolution.y * 2.0*M_PI;\n    if(iMouse.y < 5.0)\n        beta = iTime;\n    vec3 lightDir = vec3(cos(alpha)*cos(beta), cos(alpha)*sin(beta), sin(alpha));\n    \n    //vec3 n = escherNormal(uv);\n    vec3 n = escherNormalSmooth(uv);\n    //vec3 n_det = escherDetailNormal(uv);\n    vec3 n_det = escherDetailNormalSmooth(uv);\n    float blend = 0.0;\n    n = (1.0-blend)*n + blend*n_det;\n    n = n/length(n);\n    n = n*vec3(vec2(2.0*t-1.0), 1.0);\n    float s = 0.15 + 0.85 * (dot(n, lightDir));\n    \n    float spec = 0.5;\n    float shin = 64.0;\n\tfragColor = vec4(vec3(0.8, vec2(0.8-0.5*t)) * s + spec * vec3(pow(s, shin)),1.0);\n\n    float line = escherTextureContour(uv, 0.002, pixel_size);\n\tfragColor = fragColor*line;\n    \n    float details = escherDetails(uv, 0.0002, pixel_size);\n\tfragColor = fragColor*details;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXBWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltjGWV", "name": "Star orbits and field lines", "author": "aadeon", "description": "You can move the red star.\nThe lighting follows the inverse square law.\n\n", "tags": ["line", "star", "field", "point", "gravity"], "likes": 2, "viewed": 166, "date": "1500429111", "time_retrieved": "2024-06-20T18:58:14.755356", "image_code": "#define PI 3.14159\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float diagonal = length(iResolution.xy);\n    \n    vec2 center = iResolution.xy / 2.0;\n    \n    float rad = iResolution.y/4.0;\n\tfloat t = 200.0/rad;\n    \n    \n    vec2 planet = vec2(center.x+rad*sin(1.0*iTime),center.y+rad*cos(1.0*iTime));\n    //vec2 planet2 = vec2(iMouse.x+rad/2.0*sin(2.83*t*iTime),iMouse.y+rad/2.0*cos(2.83*t*iTime));\n    vec2 planet2 = vec2(iMouse.x+rad/2.0*sin(2.83*iTime),iMouse.y+rad/2.0*cos(2.83*iTime));\n    \n    vec2 distCenter = center-fragCoord.xy;\n    vec2 distPlanet = planet-fragCoord.xy;\n    vec2 distPlanet2 = planet2-fragCoord.xy;\n    vec2 distCursor = abs(iMouse.xy-fragCoord.xy);\n    \n    float light1 = 1.5*inversesqrt(length(distCursor)); \n    float light2 = 2.0*inversesqrt(length(distCenter));\n    float light3 = inversesqrt(length(distPlanet));\n    float light4 = inversesqrt(length(distPlanet2));\n    \n    \n    float grav = (light1+light2+light3+light4);\n    float c = 30.0*grav-floor(30.0*grav);\n    \n    vec4 color1 = vec4(1.0, 0.5, 0.5, 0.0);\n    vec4 color2 = vec4(1.0, 1.0, 0.4, 0.0);\n    vec4 color3 = vec4(.5, .5, 1.0, 0.0);\n    vec4 color4 = vec4(.7, .7, .7, 0.0);\n\n    color1*=light1;\n    color2*=light2;\n    color3*=light3;\n    color4*=light4;\n\n    \n    vec4 color = (color1+color2+color3+color4);\n    \n    if (c< .01*grav)\n    {\n      fragColor = (color)+(color)*2.0*pow(clamp(sin(iTime),0.0, 1.0), 2.0);   \n        \n    }\n    else\n      fragColor = color;\n    \n\t\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2BDW", "name": "20170719", "author": "RitonAndRoll", "description": "Windscreen wiper : Sun and Rain", "tags": ["color"], "likes": 0, "viewed": 98, "date": "1500501487", "time_retrieved": "2024-06-20T18:58:14.894834", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(1, 1, .5);\n\tvec3 color2 = vec3(0.10, 0.30, 1.);\n\tvec3 pixel;\n\tfloat aze = (sin(2.*iTime)*iResolution.x/4.+iResolution.x/2.);\n    \n\t// sugar syntax for \"if\" conditional. It says\n\t// \"if the x coordinate of a pixel is greater than the half of\n\t// the width of the screen, then use color1, otherwise use\n\t// color2.\"\n\tpixel = ( fragCoord.x > aze ) ? color2 : color1;\n\t\n    fragColor = vec4(pixel, 1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2BDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2BWW", "name": "Quad - distance 3D", "author": "iq", "description": "Distance field to a quad, petty much an extension to [url]https://www.shadertoy.com/view/4sXXRN[/url]", "tags": ["3d", "raymarching", "distancefield", "distance", "quad"], "likes": 17, "viewed": 1528, "date": "1500492131", "time_retrieved": "2024-06-20T18:58:15.767709", "image_code": "// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// In case a mesh was rendered, only one square root would be needed for the\n// whole mesh. In this example the quad is given a thickness of 0.01 units,\n// for display purposes. Like the square root, this thickness should be added\n// only once for the whole mesh too.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udQuad( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 p )\n{\n    #if 1\n    // handle ill formed quads\n    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )\n    {\n        vec3 tmp = v3;\n        v3 = v4;\n        v4 = tmp;\n    }\n    #endif\n\n    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n//=====================================================\n\nfloat map( in vec3 p )\n{\n    // triangle\t\n\tvec3 v1 = 1.5*cos( iTime*1.1 + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( iTime*1.2 + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( iTime*1.3 + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 v4 = v1 + ( v3 - v2);\n\tfloat d1 = udQuad( v1, v2, v3, v4, p ) - 0.01;\n\n    // ground plane\n\tfloat d2 = p.y + 1.0;\n\n    return min( d1, d2 );\t\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.25, 2.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2BWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2fRh", "name": "revision 2017 livecoding plan", "author": "lovelyH", "description": "here is shader that I was planing to show on revision 2017 livecoding (except for few tricks to make it compile in webbrowser).\nUnfortunately there were some technical problems + I stress out", "tags": ["livecoding"], "likes": 3, "viewed": 120, "date": "1499533256", "time_retrieved": "2024-06-20T18:58:15.773838", "image_code": "\n#define fGlobalTime iTime\n\n/// float iTime;\n/// vec2 iResolution;\n/// sampler2D textures[];\n/// vec3 iCam;\n/// float iCamRZ;\n/// float iCamRX;\n\n#define E 0.01\n\n\nvec2 rot( vec2 p, float l){\n\tfloat sl=sin(l),cl=cos(l);\n\treturn vec2(\n\t\tcl*p.x-sl*p.y,\n\t\tsl*p.x+cl*p.y\n\t\t);\n}\n\nint matId= 0;\n\n\nfloat map(vec3 ap){\n\tvec3 p= ap;\n\tfloat r,rc,h,wi=2.0;\n\n\tmatId= 1;\n\tr= 2.1 - length(p.xz);\n\n\trc= length(p.xz-vec2(0,wi))-0.1;\n\tif( rc < r ){r= rc; matId= 2; }\n\n\tp= ap;\n\tp.y= mod( p.y, 1.0) - 0.5;\n\trc= length( vec2( length( p.xz)-wi, p.y ) )-0.1;\n\trc= max( rc, wi-length(p.xz-vec2(0,-0.1*wi)));\n\tif( rc < r ){r= rc; matId= 2; }\n\n\tp= ap;\n\trc= p.z + 1.0 - 0.4*sin(.2*fGlobalTime );\n\tif( rc < r ){r= rc; matId= 3; }\n\n\tp= ap;\n\tp.y= mod( p.y, 32.0 ) - 16.0;\n\th= mod( fGlobalTime, 4.0 ) - 2.0;\n\tp.z -= 0.5 + min( 6.0*h, -h );\n\tp.x= abs(abs(abs(p.x)-1.0)-0.5)-0.25;\n\tp.y= abs(abs(abs(p.y)-1.0)-0.5)-0.25;\n\trc= rot( vec2( length(p.xy), p.z ), 0.47*3.14 ).y;\n\tif( rc < r ){r= rc; matId= 2; }\n\n\tfor( float a=-2.0;a<4.0;a++){\n\t\tp= ap;\n\t\tp.xz= rot( p.xz, a );\n\t\tp.y -= -13.0*(fGlobalTime+a);\n\t\tp.z -= 1.0;\n\t\tp.y= mod( p.y, 100.0 + 23.0*a ) - 50.0;\n\t\trc= length(p)-0.15;\n\t\tif( rc < r ){r= rc; matId= 3; }\n\t}\n\n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 r= vec3(0);\n\tfloat power= 1.0;\n\tfloat disTotal= 0.0;\n\tfor( int i=0;i<2;i++){\n\t\tvec3 p= sp;\n\t\tfloat dis= map(p);\n\t\tdisTotal += dis;\n\t\tbool isHit = true;\n\n\t\tfor(int a=0;a<0x40;a++){\n\t\t\tp += dis * dir;\n\t\t\tdis= map(p);\n\t\t\tdisTotal += dis;\n\t\t\tif( 30.0 < disTotal ){isHit= false; break;}\n\t\t\tif( dis < E ){isHit= true; break;}\n\t\t}\n\n\t\tif( isHit ){\n\t\t\tvec3 c= vec3(1);\n\t\t\tfloat power2=0.0;\n\n            /// is there no switch on shadertoy.com ?\n\t\t\tif(matId==1){\n\t\t\t\tc= vec3(.7,.5,.1);\n\t\t\t\tvec3 ph= p;\n\t\t\t\tph.yz= rot(p.yz,0.1*3.14);\n\t\t\t\tph= mod( ph, 0.5 ) - 0.25;\n\t\t\t\tif( length(ph) < .2 )c *= 0.3;\n            }else if(matId==2){\n\t\t\t\tc= vec3(.9);\n            }else if(matId==3){\n\t\t\t\tc= vec3(.9,.1,.1); power2= 0.3;\n            }\n\n\t\t\tvec3 nor= normalize( vec3(\n\t\t\t\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t\t\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t\t\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t\t\t));\n\n\t\t\tfloat cs= 1.0;\n            {\n                float a=4.0;\n\t\t\t\t//for( float a=4.0;a<16.0;a*=2.0)\n                for(int jj=0;jj<2;jj++)\n                {\n                    a *= 2.0;\n                    float s= a*0.01;\n                    cs= clamp( min(cs,map(p+nor*s)/s), 0.0, 1.0);\n                }\n            }\n\n\t\t\tr += power * c\n\t\t\t\t* clamp( 1.0-disTotal/30.0, 0.0, 1.0)\n\t\t\t\t* (0.5+0.5*dot(nor,-dir))\n\t\t\t\t* (0.8+0.2*dot(nor,vec3(0,0,1)))\n\t\t\t\t* (0.5+0.5*cs)\n\t\t\t;\n\n\t\t\tpower= power2;\n\t\t\tdir= reflect( dir, nor );\n\t\t\tsp= p + 4.0*E*dir;\n\t\t\tif( power < 0.01 )return r;\n\t\t}else{\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 dir= normalize( vec3( uv.x, 4, uv.y ) );\n\tdir.xy= rot( dir.xy, 0.2*sin(iTime*0.2));\n\tdir.xz= rot( dir.xz, ((iTime-4.0)*0.1) );\n\n\tfragColor = vec4( render(vec3(0,-fGlobalTime,0), dir), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2fRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2fWD", "name": "diamond gears", "author": "hclarke", "description": "gears with diamond teeth", "tags": ["2d"], "likes": 5, "viewed": 161, "date": "1500530196", "time_retrieved": "2024-06-20T18:58:15.773838", "image_code": "vec2 sd_line(vec2 pos, vec2 a, vec2 b) {\n    pos -= a;\n    vec2 d = b-a;\n    float l = length(d);\n    d /= l;\n    \n    float t = dot(d,pos);\n    vec2 p = d*clamp(t,0.0,l);\n    vec2 perp = vec2(d.y,-d.x);\n    \n    return vec2(length(pos-p), dot(pos,perp));\n}\n\nfloat abs_min(float a, float b) {\n \treturn abs(a) < abs(b) ? a : b;   \n}\n\n\nvec2 lmin(vec2 a, vec2 b) {\n    if(abs(a.x-b.x) < 0.0001) {\n      return a.y > b.y ? a : b;\n    }\n    \n    return a.x < b.x ? a : b;\n}\n\nfloat to_sd(vec2 x) {\n \treturn x.x * sign(x.y);   \n}\n\nfloat sd_diamond(vec2 pos, vec2 tail, vec2 tip, float width, float mid) {\n\tvec2 d = tip-tail;\n    vec2 p = vec2(d.y,-d.x) * width * 0.5;\n    vec2 m = d*mid+tail;\n    \n    vec2 la = sd_line(pos,tail,m+p);\n    vec2 lb = sd_line(pos,m+p,tip);\n   \tvec2 lc = sd_line(pos,tip,m-p);\n    vec2 ld = sd_line(pos,m-p,tail);\n    \n    \n    return to_sd(lmin(lmin(la,lb),lmin(lc,ld)));\n}\n\nvec2 to_polar(vec2 x) {\n\treturn vec2(length(x), atan(-x.y, -x.x) + 3.14159);\n}\n\nvec2 from_polar(vec2 x) {\n \treturn vec2(cos(x.y),sin(x.y)) * x.x;   \n}\n\nvec2 radial_repeat(vec2 pos, float count) {\n    float offset = 0.5/count;\n    pos = to_polar(pos);\n    pos.y /= 2.0*3.14195;\n    pos.y += offset;\n   \tpos.y *= count;\n   \tpos.y = fract(pos.y);\n   \tpos.y /= count;\n    pos.y -= offset;\n    pos.y *= 2.0*3.14195;\n    pos = from_polar(pos);\n    return pos;\n}\n\nvec2 rotate(vec2 pos, float turns) {\n \tpos = to_polar(pos);\n    pos.y += turns * 2.0 * 3.14195;\n    return from_polar(pos);\n}\n\nfloat gear(vec2 uv, float teeth, float turns) {\n    uv = rotate(uv,turns);\n    uv = radial_repeat(uv, teeth);\n    \n    \n   \t\n    float d = 0.05;\n    return sd_diamond(uv, vec2(0.0+d,0.0), vec2(1.0,0.0), 4.0/teeth, 0.8);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / min(iResolution.x, iResolution.y) * 2.0;\n\n    \n    \n    float g0 = gear(uv*2.0,18.0,iTime*0.1);\n    float g1 = gear(uv*4.0-vec2(2.85,0.0),9.0,-iTime*0.2);\n    float g3 = gear(uv*3.0+vec2(2.35,0.0),12.0,-iTime*0.15 +0.125);\n    float sd = min(min(g0,g1),g3);\n    float val = smoothstep(0.0,0.01,sd);\n    \n    \n\tfragColor = vec4(vec3(1.0)*val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2fWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdBfzR", "name": "AuroraBorealis", "author": "albertelwin", "description": "Northern lights shader.", "tags": ["sky", "stars", "aurora"], "likes": 53, "viewed": 2641, "date": "1499089931", "time_retrieved": "2024-06-20T18:58:15.773838", "image_code": "\n#define TAU 6.2831853071\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float o = texture(iChannel1, uv * 0.25 + vec2(0.0, iTime * 0.025)).r;\n    float d = (texture(iChannel0, uv * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r * 2.0 - 1.0);\n    \n    float v = uv.y + d * 0.1;\n    v = 1.0 - abs(v * 2.0 - 1.0);\n    v = pow(v, 2.0 + sin((iTime * 0.2 + d * 0.25) * TAU) * 0.5);\n    \n    vec3 color = vec3(0.0);\n    \n    float x = (1.0 - uv.x * 0.75);\n    float y = 1.0 - abs(uv.y * 2.0 - 1.0);\n    color += vec3(x * 0.5, y, x) * v;\n    \n    vec2 seed = fragCoord.xy;\n    vec2 r;\n    r.x = fract(sin((seed.x * 12.9898) + (seed.y * 78.2330)) * 43758.5453);\n    r.y = fract(sin((seed.x * 53.7842) + (seed.y * 47.5134)) * 43758.5453);\n\n    float s = mix(r.x, (sin((iTime * 2.5 + 60.0) * r.y) * 0.5 + 0.5) * ((r.y * r.y) * (r.y * r.y)), 0.04); \n    color += pow(s, 70.0) * (1.0 - v);\n    \n    fragColor.rgb = color;\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBfzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjBDm", "name": "Pinwheel Infinite Spiral", "author": "ttoinou", "description": "Combining recent findings ! [url]https://www.shadertoy.com/view/4djBDw[/url] [url]https://www.shadertoy.com/view/ld2BWw[/url]\nClick horizontally to increase number of number of triangles", "tags": ["zoom", "spiral", "tiling", "infinite", "pinwheel"], "likes": 6, "viewed": 150, "date": "1500762442", "time_retrieved": "2024-06-20T18:58:15.773838", "image_code": "#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cnorm( vec2 z )  { return z/length(z); }\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n    \n    float r;\n    float ID;\n    float ID2;\n};\n\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C; \\\n    T.ID = Q.ID; \\\n    T.ID2 = Q.ID2; \\\n    T.r = Q.r; \n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(X,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(X,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(X,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(X,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nPinwheel Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindTriangle(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool k = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        k = false;\n    }\n    \n    return k;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    //uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat qLimit;\n\n\n\nvec3 colorTriangle(vec2 uv_s,Pinwheel Tri)\n{\n    \n    vec3 col = hash3point(vec2(\n        // coloring algorithm\n        Tri.ID+cos(Tri.ID2),sin(Tri.ID*3.)-Tri.ID2\n    ));\n    \n    //col = vec3(1.);\n    \n    //vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    return col*2./(1. + dot(uv_s,uv_s)/1e3 );\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindTriangle(r+1.,uv_s) )\n    {\n        // inside circle\n        FindTriangle(r,uv_s);\n    }\n    \n    \n    \n\tint nbIterations = 6;\n    \n    Pinwheel Tri_TMP;\n    Tri.ID2 = 0.;\n    \n    bool direction = false;\n    #define ID_DIRECTION(x) (direction ? 4.-x : x)\n      \n    EQUERRE_COPY(Tri_TMP,Tri);\n    float q;\n    qLimit = ( 1. / mix( 1. , 1./.14  , iMouse.x/iResolution.x ) )/5.*viewportMagnify;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        Tri_TMP.ID2 *= 5.;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv_s,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(0.);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(1.);\n                direction = !direction;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv_s,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(2.);\n                direction = !direction;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(3.);\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            Tri_TMP.ID2 += ID_DIRECTION(4.);\n        }\n        \n        q = length(Tri_TMP.B - Tri_TMP.A)/qLimit;\n        if( q < 1. )\n        {\n            break;\n        }\n        else\n        {\n        \tEQUERRE_COPY(Tri,Tri_TMP);\n        }\n    }\n    \n    \n    \n    \n    q = max( \n        (q-1./sqrt(5.))/(1. - 1./sqrt(5.))\n        // nice effects here\n        * pow(viewportMagnify/length(uv_s),.75)\n        * 1.\n    , 0. );\n    \n    return mix(\n        colorTriangle(uv_s,Tri),\n        colorTriangle(uv_s,Tri_TMP),\n        smoothstep(0.,1.,sqrt(q))\n    );\n    \n    //return colorTriangle(uv_s,Tri);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    TriangleAngle = atan(2.); // Pinwheel\n    //TriangleAngle = PI/3.; // Equerre \n    \n    //PI * ( mix( 1./12. ,  1./4. ,  iMouse.x/iResolution.x ) + .333 );\n    \n    angleShift = -iTime*.3;\n    logZoom = iTime/sqrt(3.);\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify = 1.;\n    //uv_s *= viewportMagnify;\n    \n    \n    fragColor.rgb = color(uv_s);\n    fragColor.rgb = tanh(fragColor.rgb * 26. / (.2 + qLimit/viewportMagnify*16.)  ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjBRy", "name": "Bright Contrast Saturation Hue", "author": "starea", "description": "Image enhancement / post processing with Brightness, Contrast, Saturation, and Hue shifts, all in one\nVibrance forked from https://shadertoy.com/view/llGSzK, performance optimized a little bit\nHueShift forked from https://shadertoy.com/view/MsjXRt", "tags": ["postprocessing", "imageprocessing", "saturation", "hue", "brightness", "rotation", "shift", "constrast"], "likes": 10, "viewed": 3727, "date": "1501083039", "time_retrieved": "2024-06-20T18:58:16.816298", "image_code": "/** \n * Brightness Contrast Saturation Hue\n * Demo: https://www.shadertoy.com/view/MdjBRy\n * starea @ ShaderToy\n * \n * Forked and remixed from: \n * [1] https://shadertoy.com/view/llGSzK\n * [2] https://shadertoy.com/view/MsjXRt\n *\n * Created 7/26/2017\n * Updated 8/11/2017\n **/\n\n/*\nmat4 brightnessMatrix( float b ) {\n    return mat4( \n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        b, b, b, 1 );\n}\n*/\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\n/*\nmat4 contrastMatrix( float c ) {\n\tfloat t = 0.5 - c * 0.5;\n    return mat4( \n        c, 0, 0, 0,\n        0, c, 0, 0,\n        0, 0, c, 0,\n        t, t, t, 1 );\n\n}\n*/\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\n// remixed from mAlk's https://www.shadertoy.com/view/MsjXRt\nvec4 shiftHue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n\tfloat brightness = 0.15;\n\tfloat contrast = 1.2;\n    float saturation = 1.5;\n    float _vibrance = 4.0;\n    float _hue = abs(sin(iTime * 0.1)); \n    \n    vec4 color = texture( iChannel0, fragCoord/iResolution.xy );\n    \n    fragColor = saturationMatrix(saturation) * color; \n    brightnessAdjust(color, brightness); \n    contrastAdjust(color, contrast); \n    fragColor = vibrance(fragColor, _vibrance);\n    fragColor = shiftHue(fragColor.rgb, _hue);\n    fragColor.a = 1.0;\n    if (iMouse.z > 0.5) fragColor = color; \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjBW1", "name": "Blooming Flower", "author": "Homaniac", "description": "First shader where I really focused on composition and color scheme. I love the result.", "tags": ["2d", "fbm", "composition"], "likes": 3, "viewed": 137, "date": "1500332668", "time_retrieved": "2024-06-20T18:58:16.816298", "image_code": "#define PI 3.141592654\n\nfloat random(vec2 st) {\n  return fract(\n      sin(\n          dot(st.xy,vec2(12.9898, 78.233))\n          ) * 43758.5453123);\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  float ll_corner = random(i);\n  float lr_corner = random(i + vec2(1.0,0.0));\n  float ul_corner = random(i + vec2(0.0,1.0));\n  float ur_corner = random(i + vec2(1.0,1.0));\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n\n  return mix(ll_corner, lr_corner, u.x) +\n      (ul_corner - ll_corner)*u.y*(1.0 - u.x) +\n      (ur_corner - lr_corner)*u.x*u.y;\n}\n\nfloat fbm(vec2 st) {\n  float val = 0.0;\n  float amp = 1.0;\n  val += noise(st); st *= 2.0;\n  val += 0.5000*noise(st); st *= 2.0;\n  val += 0.2500*noise(st); st *= 2.0;\n  val += 0.1250*noise(st); st *= 2.0;\n  val += 0.0625*noise(st); st *= 2.0;\n\n  return val / 0.9375;\n}\n\nfloat fbmWarp2(in vec2 st, out vec2 q, out vec2 r) {\n  q.x = fbm(st);\n  q.y = fbm(st + vec2(4.7, 1.5));\n\n  r.x = fbm(st + 4.0*q + vec2(1.4, 9.1));\n  r.y = fbm(st + 4.0*q + vec2(8.7, 2.9));\n  return fbm(q + st);\n}\n\nvec3 hsb2rgb( in vec3 c ){\n  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                           6.0)-3.0)-1.0,\n                   0.0,\n                   1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 hsb2rgb(float h, float s, float b) {\n  return hsb2rgb(vec3(h,s,b));\n}\n\nfloat uSin(float x) {\n  return 0.5*sin(x) + 0.5;\n}\n\nfloat uCos(float x) {\n  return 0.5*cos(x) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st = 2.0*st - 1.0;\n  st.x *= iResolution.x / iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  float a = atan(st.y, st.x);\n  float rad = length(st);\n\n  float ss = 0.5 + 0.5*sin(3.0*iTime);\n  float anim = 1.0 + 0.4*ss*(1.0 - rad);\n  rad *= anim;\n\n  a += 0.15*sin(fbm(10.0*st)) + 0.97;\n\n  float flowerR = 0.35 + 0.28*sin(8.0*a);\n  float flowerR2 = 0.35 + 0.28*sin(8.0*a);\n  float petalR = 0.35 + 0.28*sin(8.0*a + PI);\n  float petalR2 = 0.35 + 0.28*sin(8.0*a + PI);\n  flowerR2 += 0.2*sin(fbm(10.0*st + vec2(0.4,3.7)));\n  petalR2 += 0.2*sin(fbm(10.0*st + vec2(0.13,7.7)));\n\n  flowerR *= uSin(2.0*iTime/5.)*anim;\n  petalR *= uSin(2.0*iTime/2.)*anim;\n\n  flowerR2 *= uCos(2.0*iTime/3.)*anim;\n  petalR2 *= uCos(2.0*iTime/7.)*anim;\n\n  if (rad <= flowerR) {\n    color = vec3(0.0);\n    flowerR = rad / flowerR;\n    vec2 q;\n    vec2 r;\n    float f = fbmWarp2(15.0*st, q, r);\n    color = mix(color, hsb2rgb(0.45,0.99,0.99), f);\n\n    f = fbm(vec2(4.0*a, 7.0*flowerR));\n    color = mix(color, hsb2rgb(0.55,0.99,0.99), f);\n\n    color = mix(color, hsb2rgb(0.95,0.7,0.2 + length(q)), smoothstep(0.0,1.3,flowerR));\n  }\n  if (rad <= petalR) {\n    petalR = rad / petalR;\n    vec2 q;\n    vec2 r;\n    float f = fbmWarp2(25.0*st, q, r);\n    color += hsb2rgb(0.65,f,0.95);\n\n    f = fbm(vec2(8.0*a, 3.0*petalR));\n    color = mix(color, hsb2rgb(0.6,0.99,0.99), f);\n\n    color = mix(color, vec3(0.9,0.8,0.3), smoothstep(0.0,1.0,petalR));\n    color = mix(color, vec3(0.9,0.6,0.7), smoothstep(0.0,1.5,flowerR));\n  }\n  if (rad <= flowerR2) {\n    color = vec3(0.0);\n    flowerR2 = rad / flowerR2;\n    vec2 q;\n    vec2 r;\n    float f = fbmWarp2(9.0*st, q, r);\n    color += hsb2rgb(0.15,f,0.95);\n\n    a += 0.15*sin(f);\n    f = fbm(vec2(8.0*a, 9.0*flowerR2));\n    color = mix(color, hsb2rgb(0.0,0.99,0.99), f);\n\n    color = mix(color, hsb2rgb(0.8,0.9,r.x), smoothstep(0.0,1.3,petalR));\n    color = mix(color, hsb2rgb(0.1,0.9,length(q)), smoothstep(0.0,1.3,flowerR));\n    color = mix(color, hsb2rgb(0.5,0.9,f), smoothstep(0.0,1.5,flowerR2));\n  }\n  if (rad <= petalR2) {\n    petalR2 = rad / petalR2;\n    vec2 q;\n    vec2 r;\n    float f = fbmWarp2(5.0*st, q, r);\n    color += hsb2rgb(0.15,f,0.95);\n\n    a += 0.15*sin(f);\n    f = fbm(vec2(9.0*a, 3.0*petalR2));\n    color = mix(color, hsb2rgb(0.6,0.99,0.99), f);\n\n    color = mix(color, vec3(0.2,0.9,0.8), smoothstep(0.0,1.0,petalR));\n    color = mix(color, hsb2rgb(0.12,1.0,f), smoothstep(0.0,1.3,petalR2));\n    color = mix(color, vec3(0.9,0.6,r.x), smoothstep(0.0,1.5,flowerR));\n    color = mix(color, vec3(0.9,0.6,length(q)), smoothstep(0.0,1.5,flowerR2));\n  }\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjBWh", "name": "[SH17A] at least i tried", "author": "stduhpf", "description": "i had more ideas but i ran out of chars, so there is my failed submission", "tags": ["sh17a"], "likes": 1, "viewed": 97, "date": "1500324846", "time_retrieved": "2024-06-20T18:58:16.816298", "image_code": "void mainImage( out vec4 O, vec2 I )\n{\n    O.xy=iResolution.xy; \n    O=vec4(I+I-O.xy,O.y,0);\n    O/=length(O);\n    float l=0.,f,g,i,j;\n    for(i=1.;i++<9.;)\n        for(j=0.;j++<i;){\n            f=.2*i*(g=iTime)+6.*j/i;\n            vec4 P = vec4(i*cos(f),i*sin(f),3.*cos(g)-7.,0);\n           \tl=(f=dot(O,P))*f-dot(P,P)+exp2(-i)>0.?-4.*(O*f-P).y:l;\n    }\n    O=vec4(l);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjfRK", "name": "glow shader test", "author": "remonvv", "description": "glow shader test for effect. Intended to generate a glowing border around n-gons.", "tags": ["glowfire"], "likes": 48, "viewed": 1929, "date": "1501247131", "time_retrieved": "2024-06-20T18:58:16.816298", "image_code": "\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898,12.1414))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvec3 ramp(float t) {\n\treturn t <= .5 ? vec3( 1. - t * 1.4, .2, 1.05 ) / t : vec3( .3 * (1. - t) * 2., .2, 1.05 ) / t;\n}\n\nfloat fire(vec2 n) {\n    return noise(n) + noise(n * 2.1) * .6 + noise(n * 5.4) * .42;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float t = iTime;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    uv.x += uv.y < .5 ? 23.0 + t * .35 : -11.0 + t * .3;    \n    uv.y = abs(uv.y - .5);\n    uv *= 5.0;\n    \n    float q = fire(uv - t * .013) / 2.0;\n    vec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));\n    vec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .1) + 1.61, vec3(4.0))));\n    \n    float grad = pow((r.y + r.y) * max(.0, uv.y) + .1, 4.0);\n    color = ramp(grad);\n    color /= (1.50 + max(vec3(0), color));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdjfzh", "name": "voronoi voxel traversal", "author": "abje", "description": "a voxel traverser\n", "tags": ["voronoi", "voxels"], "likes": 6, "viewed": 1053, "date": "1499556707", "time_retrieved": "2024-06-20T18:58:16.816298", "image_code": "#define time iTime\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat planetrace(vec3 p, vec3 d,vec3 plane) {\n    float len = -min(dot(p,plane),0.0)/dot(d,plane);\n    return len;\n}\n\nfloat dot2(vec3 p) {\n    return dot(p,p);\n}\n\n//hash without sin by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash34(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return (fract((p4.xxyz+p4.zzyw)*p4.zywx).xyz-0.5)*0.7+0.5;\n}\n\nvec3 noise(vec3 p3)\n{\n    float floortime = floor(iTime);\n    return mix(hash34(vec4(p3,floortime)),hash34(vec4(p3,floortime+1.0)),iTime-floortime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 pos = vec3(0.0,2.0,-12.0);\n    vec3 dir = normalize(vec3(uv,0.5));\n    \n    float len = 10000.0;\n    vec3 cell;\n    vec3 cell2;\n    vec3 center = floor(pos);\n    vec3 center2;\n    \n    \n    //finding closest voronoi cell\n    for(float x = -1.0; x <= 1.0; x++) {\n    \tfor(float y = -1.0; y <= 1.0; y++) {\n    \t\tfor(float z = -1.0; z <= 1.0; z++) {\n                vec3 orig = vec3(x,y,z)+center;\n                orig += noise(orig)-0.5;\n                if (len > dot2(pos-orig)) {\n                    cell = orig;\n                    center2 = vec3(x,y,z)+center;\n                    len = dot2(pos-orig);\n                }\n            }\n    \t}\n    }\n    cell2 = cell;\n    \n    \n    center = floor(pos-0.5);\n    //raytracing\n    vec3 normal;\n    float dist = 0.0;\n    for ( int i = 0; i < 50; i++) {\n        \n        \n        len = 10000.0;\n        center = center2;\n        if (dot2(center) < 100.0 || center.y < -3.0 || dist > 20.0) break;\n        vec3 cell3;\n        for(float x = -1.0; x <= 1.0; x++) {\n            for(float y = -1.0; y <= 1.0; y++) {\n                for(float z = -1.0; z <= 1.0; z++) {\n                    vec3 orig = vec3(x,y,z)+center;\n                    orig += noise(orig)-0.5;\n                    if (max(dot2(orig-cell),dot2(orig-cell2))>0.0001)\n                    {\n                        vec3 mid = (orig+cell)*0.5;\n                        vec3 plane = vec3((orig-cell));\n                        float num = planetrace(pos-vec3(mid),dir,plane);\n\n                        if (num < len && num > 0.0) {\n                            len = num;\n                            cell3 = orig;\n                            center2 = vec3(x,y,z)+center;\n                            normal = -plane;\n                        }\n                    }\n                }\n            }\n        }\n        cell2 = cell;\n        cell = cell3;\n        dist += len;\n        pos += dir*len;\n    }\n    normal = normalize(normal);\n    //shading\n    if (dot2(center) < 100.0 || center.y < -3.0) {\n        vec3 sun = normalize(vec3(1.0,1.0,-1.0));\n        vec3 objnorm = normal;\n        vec3 reflectnorm = reflect(dir,objnorm);\n        vec3 color = normal*0.5+0.5;\n        fragColor = vec4(color*max(0.2,0.8*dot(objnorm,sun)),1.0);\n        fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*12.0);\n    }\n}\n\n\n/*\n#define time iTime\n\nfloat planetrace(vec3 p, vec3 d,vec3 plane) {\n    float len = (-dot(p,plane))/dot(d,plane);\n    len = max(len,0.0)-(sign(len)-1.0)*1000.0;\n    return len*step(dot(p,plane),0.0)*step(dot(p,plane),0.0)-0.01;\n}\n\nfloat dot2(vec3 p) {\n    return dot(p,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 pos = vec3(0.0,2.0,-12.0);\n    vec3 dir = normalize(vec3(uv,0.5));\n    \n    float len = 10000.0;\n    vec3 cell;\n    vec3 cell2;\n    vec3 center = floor(pos);\n    vec3 center2;\n    \n    \n    //finding closest voronoi cell\n    for(float x = -1.0; x <= 1.0; x++) {\n    \tfor(float y = -1.0; y <= 1.0; y++) {\n    \t\tfor(float z = -1.0; z <= 1.0; z++) {\n                vec3 orig = vec3(x,y,z)+center;\n                orig += 0.25*sin(orig.yzx+orig.zxy+iTime)*vec3(sin(time),cos(time),1.0);\n                if (len > dot2(pos-orig)) {\n                    cell = orig;\n                    center2 = vec3(x,y,z)+center;\n                    len = dot2(pos-orig);\n                }\n            }\n    \t}\n    }\n    cell2 = cell;\n    \n    \n    center = floor(pos-0.5);\n    //raytracing\n    vec3 normal;\n    float dist = 0.0;\n    for ( int i = 0; i < 50; i++) {\n        \n        \n        len = 10000.0;\n        center = center2;\n        if (dot2(center) < 100.0 || center.y < -3.0 || dist > 20.0) break;\n        vec3 cell3;\n        for(float x = -1.0; x <= 2.0; x++) {\n            for(float y = -1.0; y <= 2.0; y++) {\n                for(float z = -1.0; z <= 2.0; z++) {\n                    vec3 orig = vec3(x,y,z)+center;\n                    orig += 0.25*sin(orig.yzx+orig.zxy+iTime)*vec3(sin(time),cos(time),1.0);\n                    if (dot2(orig-cell)>0.0001&&dot2(orig-cell2)>0.0001)\n                    {\n                        vec3 mid = (orig+cell)*0.5;\n                        vec3 plane = vec3(normalize(orig-cell));\n                        float num = planetrace(pos-vec3(mid),dir,plane);\n\n                        if (num < len && num > 0.0) {\n                            len = num;\n                            cell3 = orig;\n                            center2 = vec3(x,y,z)+center;\n                            normal = -plane;\n                        }\n                    }\n                }\n            }\n        }\n        cell2 = cell;\n        cell = cell3;\n        dist += len;\n        pos += dir*len;\n    }\n    \n    //shading\n    if (dot2(center) < 100.0 || center.y < -3.0) {\n        vec3 sun = normalize(vec3(1.0,1.0,-1.0));\n        vec3 objnorm = normal;\n        vec3 reflectnorm = reflect(dir,objnorm);\n        vec3 color = vec3(0.7,0.3,0.6);\n        fragColor = vec4(color*max(0.2,0.8*dot(objnorm,sun)),1.0);\n        fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*12.0);\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdjfzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdSBzw", "name": "[SH17A] Inside the grid", "author": "lsdlive", "description": "Raymarching in 2^8 characters.", "tags": ["raymarching", "sh17a"], "likes": 4, "viewed": 146, "date": "1499873251", "time_retrieved": "2024-06-20T18:58:16.816298", "image_code": "void mainImage(out vec4 l, in vec2 v)\n{\n\tv = v / iResolution.xy - .5;v.x *= 2.;\n\tvec4 p = l + tan(iTime)*4., b = vec4(.3, .4, -.8, .5);\n\n    for (int i=0; i < 36; i++) {\n\t\tl = abs(p) - 6.;l.xz *= mat2(b);l = abs(mod(l, 9.) - 4.);\n\t\tp += vec4(v,-1, 0) * (min(max(l.x, l.y)+l.y, max(l.y, l.z)-.5) - .7);\n\t}\n\n\tl = b.yzww * -p * .03;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdsfDl", "name": "Solar_system", "author": "duvengar", "description": "One more solar system. WIP", "tags": ["2d", "burn", "fbm", "solar"], "likes": 10, "viewed": 305, "date": "1498948248", "time_retrieved": "2024-06-20T18:58:16.822384", "image_code": "#define T iTime\n\n//// COLORS ////\nconst vec3 ORANGE = vec3(1.0, 0.6, 0.2);\nconst vec3 BLUE   = vec3(0.0, 0.3, 0.6);\nconst vec3 PINK   = vec3(1.0, 0.3, 0.2);\nconst vec3 BLACK  = vec3(0.0, 0.0, 0.0);\n\n///// NOISE /////\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453123);   \n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\n////// FBM ////// \n// see iq // https://www.shadertoy.com/view/lsfGRr\n\nmat2 m = mat2( 0.6, 0.6, -0.6, 0.8);\nfloat fbm(vec2 p){\n \n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= m * 2.02;\n    f += 0.2500 * noise(p); p *= m * 2.03;\n    f += 0.1250 * noise(p); p *= m * 2.01;\n    f += 0.0625 * noise(p); p *= m * 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U ) \n{\n    \n    // Pixel ratio\n    vec2 uv = U.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;   \n    p.x *= iResolution.x / iResolution.y ;\n    p *= 8.0;\n    \n  \t/*_______________ CALCULS _______________*/\n    \n    // rotations angles\n    float def = fbm(p*0.4);\n    float angle  =  T;\n    float angle2 =  T * 2.7;\n    float angle3 =  T * 0.9;\n    float angle4 =  T * 0.6;\n   \t\n    // Perspective factor\n    float fac =  smoothstep(10.0, -4.0, p.y)*2.;\n    \n    // Positions\n    vec2 ctr = vec2(0.00 , 0.00);\n    vec2 pos0 = vec2(ctr.x  + 0.50 * cos(angle),  ctr.y  + 0.50 * sin(angle ));\n    vec2 pos1 = vec2(pos0.x + 6.00 * cos(angle),  pos0.y + 2.00 * sin(angle ));\n    vec2 pos2 = vec2(pos1.x + fac * 0.90 * cos(angle2), pos1.y + fac * 0.30 * sin(angle2));\n    vec2 pos3 = vec2(pos0.x + 9.50 * cos(angle3), pos0.y + 3.25 * sin(angle3));\n    vec2 pos4 = vec2(pos0.x + 13.5 * cos(angle4), pos0.y + 4.50 * sin(angle4));\n\t\n    // fbm angle\n \tfloat r = sqrt(dot(p+pos0,p+pos0));\n    \n    float alpha = r * 0.2 + atan(dot(0.5, pow(abs(p.x), p.y)), dot(0.5, pow(abs(p.x),p.y))) - (iTime * 0.1); \n    // Distortion\n    alpha +=  1.4 + fbm( 0.6 * p + pos0) ;\n    \n    \n    /*_______________ COLORS _______________*/\n \n    //------------------------//\n    // COLORFULL CLOUDY COSMOS \n    //------------------------//\n    \n    float ff = 1.0 - smoothstep(00.0,20.0, length(p)); \n    vec3 color = vec3(ff * 0.05) ;  \n     \n    ff = smoothstep(0.3, 1.4,fbm(0.3 * p + T * 0.2)); \n  \tcolor += mix(color, ORANGE, ff * 0.2);\n    \n    ff = smoothstep(0.3,0.9, fbm(0.1 * p + T * 0.4));\n    color += mix(color, PINK  , ff * 0.3);\n    \n    ff = smoothstep(0.3,1.9, fbm(0.1 * p + T * 0.6));\n  \tcolor += mix(color, BLUE  , ff * 0.9);\n    \n    ff = smoothstep(0.3,0.9, fbm( .4 * p + T * 0.8));\n  \tcolor += mix(color, BLACK , ff * 0.1);\n    \n    color += mix(BLUE,color,0.7)*0.3;\n    \n    float v = smoothstep(0.0,20.0,length(p.y + pos4.y));\n    \n    //------------------------//\n    // B&W SOLAR SYSTEM\n    //------------------------//\n    \n\tfloat col = 1.0 - smoothstep(02.,20.0, length(p));\n    float f = smoothstep(0.2,1.9, fbm( 0.5 * p + T * 0.3 )); \n    col = mix(col, 0.0, f*0.9)*0.99;\n    \n    // Kind of star Field \n    for(float k = 0.10; k < 0.15; k += 0.01){\n        if(fbm(vec2(10. * p + T)) < k){\n            col += mix(col, 0.0, 0.1 * (k * 50.0));\n        }\n    }\n\n \n    // Sun\n    ff   = smoothstep( 0.00,1.90, length(p + pos0));\n    col += mix(col,0.0,ff);   \n  \tcol *= mix(col*2., 0.8, fbm(vec2(f*0.7,alpha)))*0.6;\n\t\n    // Planete 01\n    ff   = smoothstep(fac * 0.30,fac * 0.35, length(p + pos1)); \n    col -= mix(col,0.0,ff);\n    ff   = smoothstep(fac * 0.20,fac * 0.53, length(p + pos1)); \n    col += mix(col,0.0,ff );\n    \n    // planete 02 / satelite \n    ff   = smoothstep(fac * 0.05,fac * 0.10, length(p + pos2));\n    col -= mix(col,0.0,ff);\n    ff   = smoothstep(0.00,fac * 0.20, length(p + pos2));\n    col += mix(col,0.0,ff);\n    \n    // Planete 03\n    ff   = smoothstep(fac * 0.45,fac * 0.50, length(p + pos3));\n    col -= mix(col,0.0,ff);\n    ff   = smoothstep(0.00,fac * 1.10, length(p + pos3)); \n    col += mix(col,0.0,ff);\n    \n    // Planete 04\n    ff   = smoothstep(fac * 0.35 ,fac * 0.40, length(p + pos4));\n    col -= mix(col,0.0,ff);\n    ff   = smoothstep(fac * 0.20 ,fac * 0.72, length(p + pos4));\n    col += mix(col,0.0,ff);\n    col -= smoothstep(0.30, 2.1, length(p + pos0));  \n    \n    \n \t//------------------------//\n    // postprocessing\n    //------------------------//\n    \n    // Final Color\n    vec3 cc = mix(color, vec3(col), 0.55);   \n    cc += mix(cc, BLUE,0.35);\n    \n    // Last sun burn\n    ff = smoothstep( 0.00,1.90, length(p + pos0));\n    cc += mix(cc,vec3(0.0),ff);\n    cc *= 1.12345;\n    \n \t// Final output\n\tC = vec4( cc,1.0);\n    \n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsfDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdSfW1", "name": "[SH17A] Twister", "author": "david_k", "description": "Recreated an old classic in less than 280 characters for the Shadertoy 2017 competition", "tags": ["shortsize"], "likes": 6, "viewed": 199, "date": "1500235769", "time_retrieved": "2024-06-20T18:58:16.822384", "image_code": "void mainImage(out vec4 c, vec2 P) {\n    c = vec4(.2);\n    P = P / iResolution.xy*4. - 2.;    \n    \n    float T = iTime,\n    a = P.y*sin(T) + T*2. + sin(P.y + T);\n        \n    for (int n = 0; n < 4; n++) {\n        float A = cos(a), B = sin(a);\n\n        if (P.x > A && P.x < -B) {\n            vec2 uv = vec2((P.x - A)/(-B - A), P.y*.5);            \n            c = texture(iChannel0, uv)*-(B + A)*(uv.x < 0.02 ? 1.5 : 1.);\n        }\n                \n        a += 1.5707;\n    }    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdSfWm", "name": "Glowing Ring II", "author": "ray7551", "description": "Dance of RGB.\nIt's not what I meant to write it, I just changed few lines and found it really beautiful.\n\nFork from http://glslsandbox.com/e#41607.0", "tags": ["ring", "glow", "in10line"], "likes": 6, "viewed": 699, "date": "1500653323", "time_retrieved": "2024-06-20T18:58:16.822384", "image_code": "const float pi = 3.14;\nconst float lineNum = 3.;\nconst float variation = 0.5;\nconst float petalNum = 5.;\nconst float glowing = 0.02;\nconst float ringWidth = 0.08;\nconst float rotateSpeed = 0.3;\nconst float radius = 0.28;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 pos = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y) * .5;\n\tfloat t = atan(pos.y + variation, pos.x);\n\t\n\tfloat color = 0.1;\n\tfor (float i = 1.0; i <= lineNum; i++) {\n\t  color += glowing / abs(\n          length(pos)\n\t\t  + ringWidth * sin(\n\t\t    petalNum * (t + i * iTime * rotateSpeed / lineNum) + pi\n\t\t  ) - radius\n\t  );\n\t}\n\tfloat base = (length(pos) - radius) * color;\n    vec3 baseColor = vec3(\n        base / cos(iTime / 4.),\n        base / cos(iTime / 4. + pi / 2.),\n        base / cos(iTime / 4. + pi)\n    );\t\n\tfragColor = vec4(baseColor * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2BRz", "name": "Chain Spell", "author": "leon", "description": "Raymarching sketch about magic. I've started with the three turning spells, then a broken chain and finally a storm trapped in a sphere.  \nUse mouse to move camera.", "tags": ["raymarching", "magic", "chain", "spell"], "likes": 46, "viewed": 851, "date": "1499820618", "time_retrieved": "2024-06-20T18:58:17.901231", "image_code": "\n// Raymarching sketch about magic.\n// I've started with the three turning spells,\n// then a broken chain and finally a storm trapped in a sphere.\n\n// Leon 12 / 07 / 2017\n// using lines of code of IQ, Mercury, LJ, Koltes, Duke\n\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\n\n// number of ray\n#define STEPS 30.\n\n// distance minimum for volume collision\n#define BIAS 0.001\n\n// distance minimum \n#define DIST_MIN 0.01\n\n// rotation matrix\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\n\n// distance field funtions\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdTorus( vec3 p, vec2 s ) {\n  vec2 q = vec2(length(p.xz)-s.x,p.y);\n  return length(q)-s.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// smooth minimum\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\n\n// dat one line random function \nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\n\n// polar domain repetition\nvec3 moda (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(a,an)-an/2.;\n    return vec3(vec2(cos(a),sin(a))*length(p),c);\n}\n\n// the rythm of animation\n// change the 3. to have more or less spell\nfloat getLocalWave (float x) { return sin(-t+x*3.); }\n\n// displacement in world space of the animation\nfloat getWorldWave (float x) { return 1.-.1*getLocalWave(x); }\n\n// camera control\nvec3 camera (vec3 p) {\n    p.yz *= rot((PI*(iMouse.y/iResolution.y-.5)));\n    p.xz *= rot((PI*(iMouse.x/iResolution.x-.5)));\n    return p;\n}\n \n// position of chain\nvec3 posChain (vec3 p, float count) {\n    float za = atan(p.z,p.x);\n    vec3 dir = normalize(p);\n    \n    // domain repetition\n    vec3 m = moda(p.xz, count);\n    p.xz = m.xy;\n    float lw = getLocalWave(m.z/PI);\n    p.x -= 1.-.1*lw;\n    \n    // the chain shape\n    p.z *= 1.-clamp(.03/abs(p.z),0.,1.);\n    \n    // animation of breaking chain\n    float r1 = lw*smoothstep(.1,.5,lw);\n    float r2 = lw*smoothstep(.4,.6,lw);\n    p += dir*mix(0., 0.3*sin(floor(za*3.)), r1);\n    p += dir*mix(0., 0.8*sin(floor(za*60.)), r2);\n    \n    // rotate chain for animation smoothness\n    float a = lw * .3;\n    p.xy *= rot(a);\n    p.xz *= rot(a);\n    return p;\n}\n\n// distance function for spell\nfloat mapSpell (vec3 p) {\n    float scene = 1.;\n    float a = atan(p.z,p.x);\n    float l = length(p);\n    float lw = getLocalWave(a);\n    \n    // warping space into cylinder\n    p.z = l-1.+.1*lw;\n    \n    // torsade effect\n    p.yz *= rot(t+a*2.);\n    \n    // long cube shape\n    scene = min(scene, sdBox(p, vec3(10.,vec2(.25-.1*lw))));\n    \n    // long cylinder cutting the box (intersection difference)\n    scene = max(scene, -sdCylinder(p.zy, .3-.2*lw));\n    return scene;\n}\n\n// distance function for the chain\nfloat mapChain (vec3 p) {\n    float scene = 1.;\n    \n    // number of chain\n    float count = 21.;\n    \n    // size of chain\n    vec2 size = vec2(.1,.02);\n    \n    // first set of chains\n    float torus = sdTorus(posChain(p,count).yxz,size);\n    scene = smin(scene, torus,.1);\n    \n    // second set of chains\n    p.xz *= rot(PI/count);\n    scene = min(scene, sdTorus(posChain(p,count).xyz,size));\n    return scene;\n}\n\n// position of core stuff\nvec3 posCore (vec3 p, float count) {\n    \n    // polar domain repetition\n    vec3 m = moda(p.xz, count);\n    p.xz = m.xy;\n    \n    // linear domain repetition\n    float c = .2;\n    p.x = mod(p.x,c)-c/2.;\n    return p;\n}\n\n// distance field for the core thing in the center\nfloat mapCore (vec3 p) {\n    float scene = 1.;\n    \n    // number of torus repeated\n    float count = 10.;\n    float a = p.x*2.;\n    \n    // displace space\n    p.xz *= rot(p.y*6.);\n    p.xz *= rot(t);\n    p.xy *= rot(t*.5);\n    p.yz *= rot(t*1.5);\n    vec3 p1 = posCore(p, count);\n    vec2 size = vec2(.1,.2);\n    \n    // tentacles torus shape\n    scene = min(scene, sdTorus(p1.xzy*1.5,size));\n    \n    // sphere used for intersection difference with the toruses\n    scene = max(-scene, sdSphere(p,.6));\n    return scene;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    // raymarch camera\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = camera(vec3(uv,-1.5));\n    vec3 ray = camera(normalize(vec3(uv,1.)));\n    vec3 pos = eye;\n    \n    // dithering\n\tvec2 dpos = ( coord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n    \n    float shade = 0.;\n    for (float i = 0.; i < STEPS; ++i) {\n        \n        // distance from the different shapes\n\t\tfloat distSpell = min(mapSpell(pos), mapCore(pos));\n\t\tfloat distChain = mapChain(pos);\n        float dist = min(distSpell, distChain);\n        \n        // hit volume\n        if (dist < BIAS) {\n            \n            // add shade\n            shade += 1.;\n            \n            // hit non transparent volume\n            if (distChain < distSpell) {\n                \n                // set shade and stop iteration\n                shade = STEPS-i-1.;\n                break;\n            }\n        }\n        \n        // dithering\n        dist=abs(dist)*(.8+0.2*rand(seed*vec2(i)));\n        \n        // minimum step\n        dist = max(DIST_MIN,dist);\n        \n        // raymarch\n        pos += ray*dist;\n    }\n    \n    // color from the normalized steps\n    color = vec4(shade/(STEPS-1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2BRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2BWm", "name": "Starwars Narrow Path", "author": "yumcyawiz", "description": ".", "tags": ["raymarching"], "likes": 4, "viewed": 88, "date": "1500760436", "time_retrieved": "2024-06-20T18:58:17.901231", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nfloat df(vec3 p) {\n    p = abs(p);\n    p = mod(p, 4.0) - vec3(2.0);\n    int n = 0;\n    while(n < 10) {\n        if(p.x + p.y < 0.0) p.xy = -p.yx;\n        if(p.x + p.z < 0.0) p.xz = -p.zx;\n        if(p.y + p.z < 0.0) p.yz = -p.yz;\n        p = p*2.0 - (2.0 - 1.0)*vec3(1.5);\n        p = p*vec3(-0.5, 1, 1);\n        n++;\n    }\n    return length(p)*pow(2.0, -float(n));\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(\n        vec3(df(p + vec3(eps, 0, 0)) - df(p + vec3(-eps, 0, 0)),\n             df(p + vec3(0, eps, 0)) - df(p + vec3(0, -eps, 0)),\n             df(p + vec3(0, 0, eps)) - df(p + vec3(0, 0, -eps))\n        ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n};\n\n\nconst int maxStep = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    for(int i = 0; i < maxStep; i++) {\n        vec3 p = from + t*rayDir;\n        float d = df(p);\n        if(d < 0.005) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            break;\n        }\n        t += d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t);\n}\n\n\nvec3 shading(vec3 from, vec3 rayDir) {\n    Ray tr = trace(from, rayDir);\n    if(!tr.hit) {\n        return vec3(0);\n    }\n    \n    //StepsAO\n    float stepsAO = float(tr.steps)/float(maxStep);\n    \n    //DetailedAO\n    float detailedAO = 0.0;\n    for(int i = 1; i <= 10; i++) {\n        float d1 = float(i)/float(10)*0.17;\n        vec3 p = tr.hitPos + tr.hitNormal * d1;\n        float d2 = df(p);\n        detailedAO += (d1 - d2)*1.0;\n    }\n    \n    float aoFactor = max(1.0 - detailedAO, 0.0);\n    float fogFactor = max(1.0 - tr.t/10.0, 0.0);\n    \n    vec3 n = tr.hitNormal;\n    float dist = length(tr.hitPos - from);\n    float diffuse = max(dot(-rayDir, n), 0.0);\n    float geometryTerm = 1.0/(pow(0.2*dist, 2.0) + 1.0);\n    \n    vec3 matColor = n + vec3(1);\n    \n    return (geometryTerm*diffuse*matColor*aoFactor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    \n    vec3 camPos = vec3(0, 0, -3.0 + iTime*0.5);\n    vec3 camFront = normalize(vec3(0.3*cos(iTime), 0.3*sin(iTime), 1));\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camFront, camUp);\n    vec3 rayDir = normalize(0.5*camFront + uv.x*camRight + uv.y*camUp);\n    \n    vec3 color = shading(camPos, rayDir);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2BWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2BWW", "name": "Hello sphere", "author": "etale_cohomology", "description": "I'm looking for the simplest example of a sphere with arbitrary radius and arbitrary position in 3D space such that one can map arbitrary colors/shapes onto its surface. Is this it?\n\nFork of https://www.shadertoy.com/view/4tKSDm", "tags": ["3d", "simple", "math", "raymarch", "tutorial", "sphere", "distance", "hello"], "likes": 4, "viewed": 158, "date": "1500495308", "time_retrieved": "2024-06-20T18:58:18.228365", "image_code": "// Fork of https://www.shadertoy.com/view/4tKSDm\n\n// I'm looking for the simplest example of a sphere\n// with arbitrary radius and arbitrary position in 3D space such that\n// one can map arbitrary colors/shapes onto its surface. No lighting, no shadows.\n// Is this it?\n// Also, I haven't figured out how to move the sphere in 3D space...\n\n// Fork of https://www.shadertoy.com/view/4tKSDm\n\n#define PI 3.14159\n#define LITTLE_CIRCLES 16.\n\nmat3 rotation_matrix;\n\nmat3 rotationXY(vec2 angle) {\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\treturn mat3(\n\t\t      c.y,   .0,       -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// I think this functions maps colors/shapes onto the surface of the sphere.\n// How does this work?\nvec3 render(vec2 uv) {\n    if (length(uv) <= 1.0) {\n        vec3 n = rotation_matrix * vec3(uv, sqrt(1. - dot(uv, uv)));  // Is this a normal vector?\n        vec2 s = vec2(acos(n.z), atan(n.y, n.x)) / PI;\n        vec2 uv = fract(s * vec2(LITTLE_CIRCLES));\n        float r = ceil(s.x * 32.0) / 64.0;\n        return length(uv - .5) < r ? vec3(.94) : vec3(.0, .5, 1.);\n    }\n    else\n        return vec3(.06);  // Background!\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = 1.4 * (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    rotation_matrix = rotationXY(vec2(200.*iTime / iResolution.yx));\n\n    // What does this double loop do?\n    vec3 sum = vec3(.0);\n    for (int x = -2; x <= 2; ++x)\n        for (int y = -2; y <= 2; ++y)\n            sum += render(p + vec2(x, y) / (2.*iResolution.xy));\n    fragColor.rgb = sum / 25.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2BWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2BzG", "name": "distorted procedural tiling", "author": "FabriceNeyret2", "description": "pure proceduralism means loopless : you draw only one object per pixel. \n-> cost = cheap + invariant to number of items. \nBut dealing with tiling distortion (i.e. distortion of objects center) is tricky when you don't want objects to be distorted.", "tags": ["procedural", "2d", "tiling"], "likes": 2, "viewed": 507, "date": "1501158828", "time_retrieved": "2024-06-20T18:58:18.228365", "image_code": "// used in https://www.shadertoy.com/view/XdjBRy\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O -= O; \n    vec2  R = iResolution.xy, U1;\n    float N = 40./2.,                                             // number of cells/birds vertically\n          Y, k = .1,                                              // flight acceleration\n       pix = N / R.y,                                             // pixel size\n         t = iTime/2., ft = fract(t);                             // scroll time\n    U *= pix; \n    U.y -= 6.;                                                    // trigger height \n    U1 = U;\n    U.y -= ft;                                                    // scrolled scaled coordinates\n\n    vec2 P = floor(U), V = fract(U)-.5;\n    \n    if (U1.y>0.) {                                                // acceleration ( = tiling distortion )\n        Y = log(1.+k*(U1.y-1.))/k;        // inv(Y) = (exp(k*Y)-1.)/k + 1.\n        Y -= ft;\n        if (Y>=-.5) {\n             if (P.x==0.) P.x-=3.;        // track 1st accelerated on 1st column for debug\n             P.y = ceil(Y); \n              V.y =  ( exp(k*Y) - exp(k*(P.y-.5)) ) / k // pseudofrac = ( inv(Y) - inv(center) )       \n                    * exp(k*ft);                        //             / jacobian( inv(Y) )\n             // if (abs(V.y)>.5) return;\n           }\n    }\n                                                                   \n    O += step(P.x,-1.) * clamp(1.-2.5*length(V),0.,1.)            // blob\n         +  smoothstep(.1,.0,abs(length(V)-.4))                   // circle\n           * sin(P.x+P.y-floor(t)+vec4(0,2.1,-2.1,0));            // col = cell Id\n\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2BzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2fR3", "name": "SDF tunnel", "author": "mikatalk", "description": "SDF tunnel", "tags": ["sdftunnel"], "likes": 1, "viewed": 464, "date": "1501511733", "time_retrieved": "2024-06-20T18:58:18.228365", "image_code": "#define PI 3.1415\n\nfloat stroke(float x, float s, float w) {\n  float d = step(s,x+w*.5) - step(s, x-w*.5);\n  return clamp(d, 0., 1.);\n}\n\nfloat fill(float x, float size) {\n  return 1. - step(size, x);\n}\n\nfloat rectSDF(vec2 st, vec2 s) {\n  st = st*2.-1.;\n  return max( abs(st.x/s.x), abs(st.y/s.y) );\n}\n\nfloat crossSDF(vec2 st, float s) {\n  vec2 size = vec2(.005, s);\n  return min( rectSDF(st, size.xy), rectSDF(st, size.yx) );\n}\n\nvec2 rotate(vec2 st, float a) {\n  st = mat2(cos(a), -sin(a), sin(a), cos(a)) * (st-.5);\n  return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy / iResolution.xy;\n  vec3 color = vec3(0.0, 0.0, 0.0);  \n  float timeSlow = iTime * .3;\n  vec2 offset = vec2(\n    sin(iTime*.7), \n    sin(iTime*.1)*.6\n  );\n  vec2 size = vec2(1.);\n  vec2 center = st*2.-1.;\n  vec2 ratio =  cos(abs((st-vec2(.5)) * 2. )/2. * PI);\n  center += offset * ratio/2.;    \n  float rect = max( abs(center.x/size.x), abs(center.y/size.y) );\n  color += fill(rect, .05);\n  color += stroke(rect, 0. + mod(timeSlow, .1), .02);\n  color += stroke(rect, .1 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .2 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .3 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .4 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .5 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .6 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .7 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .8 + mod(timeSlow, .1), .02);\n  color += stroke(rect, .9 + mod(timeSlow, .1), .02);\n  color += stroke(rect, 1. + mod(timeSlow, .1), .02);\n  float cross = crossSDF(  rotate( center+vec2(.5), radians(45.)), 10.);\n  color = max( color, fill(cross, 5.) );\n  //color.r *= 1.0 - .5/length(center);\n  //color.g *= 1.0 - .5/length(center);\n  //color.b *= 1.0 - .5/length(center);\n  color = 1. - color;\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2fR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2fWR", "name": "Riemann zeta function 2", "author": "etale_cohomology", "description": "The Riemann zeta function is one of the most legendary objects in mathematics. For reasons I don't understand, proving facts about it is very hard, as it encodes crucial arithmetic information from the ring of integers of the field of complex numbers", "tags": ["2d", "mathematics", "hsv", "function", "complex", "zeta", "riemann", "analysis"], "likes": 10, "viewed": 254, "date": "1500113982", "time_retrieved": "2024-06-20T18:58:18.434517", "image_code": "// Fork of https://www.shadertoy.com/view/4scSWB with tweaks by FabriceNeyret2\n// I don't know if the zeta computation is correct (yet!), but it doensn't look completely off!\n// Compare with https://en.wikipedia.org/wiki/Riemann_zeta_function\n// We look at the zeta function's domain around the so-called critical strip!\n\n#define ITERATIONS 256.\n#define hsv2rgb(v) abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.\n\n// Proof that this is correct? Fabrice?\nvec2 riemann_zeta_series(vec2 z){\n  vec2 sum = vec2(0);\n  for(float i = 1.; i < ITERATIONS; ++i)\n    sum += sin(-z.y * log(i) - vec2(1.57, 0.)) / pow(i, z.x);\n  return sum;\n}\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;  // Map y-coordinates to [-1;1]\n  uv *= 4.;  // Zoom out by a factor of 4\n  uv.y += iTime;  // Move up in uv-space!\n\n  vec2 sum = riemann_zeta_series(uv);\n\n  fragColor.rgb = hsv2rgb(atan(sum.y / sum.x));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2fWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBBzw", "name": "Easing Rhombus", "author": "r21nomi", "description": "Rhombuses with easing.", "tags": ["easing"], "likes": 0, "viewed": 347, "date": "1499875956", "time_retrieved": "2024-06-20T18:58:18.434517", "image_code": "float map(float value, float beforeMin, float beforeMax, float afterMin, float afterMax) {\n\treturn afterMin + (afterMax - afterMin) * ((value - beforeMin) / (beforeMax - beforeMin));\n}\n\nvec2 patternize(vec2 st) {\n\treturn fract(vec2(st));\n}\n\nfloat box(vec2 _st, vec2 _size){\n\t_size = vec2(0.5) - _size * 0.5;  // Adjust size.\n\tvec2 uv = step(_size, _st);\n\tuv *= step(_size, vec2(1.0) - _st);\n\treturn uv.x * uv.y;\n}\n\nmat2 rotate2d(float _angle){\n\treturn mat2(cos(_angle), -sin(_angle),  sin(_angle), cos(_angle));\n}\n\n// From Robert Penner's Easing Functions.\n// http://gizma.com/easing/\nfloat easeOutQuad(float t) {\n\treturn -t * (t - 2.0);\n}\n\nfloat exposeInOut(float t) {\n\tif (t == 0.0) {\n\t\treturn 0.0;\n\t\n\t} else if (t == 1.0) {\n\t\treturn 1.0;\n\t\n\t} else if ((t /= 0.5) < 1.0) {\n\t\treturn 0.5 * pow(2.0, 10.0 * (t - 1.0));\n\t\n\t} else {\n\t\treturn 0.5 * (-pow(2.0, -10.0 * --t) + 2.0);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n\tint count = 6;\n\t\n\t// Divide by 2 since the origin of display is center(the range of y is -1.0 ~ 1.0)\n\tst *= float(count / 2);\n\t\n\t// Apply easing.\n\tfloat easing =  exposeInOut(fract(iTime * 1.1));\n\tfloat speed = iTime + easing;\n\t\n\t// Animate\n\tst.x += mod(st.y, 2.0) < 1.0 ? -speed : speed;\n\t\n\t// Patternize\n\tvec2 p = patternize(st);\n\t\n\t// Rotate\n\tp -= 0.5;  // Move each items to center.\n\tp *= rotate2d(iTime);  // Rotate.\n\tp += 0.5;  // Set rotation axis to center.\n\n\tfloat minScale1 = 0.5;\n\tfloat minScale2 = 0.1;\n\tfloat maxScale = 1.0;\n\t\n\t// Scale with animation.\n\tfloat scale = easing < 0.5 ?  map(easing, 0.0, 1.0, maxScale, minScale1) : map(easing, 0.0, 1.0, minScale1, maxScale);\n\tfloat scale2 = easing < 0.7 ?  map(easing, 0.0, 1.0, maxScale, minScale2) : map(easing, 0.0, 1.0, minScale2, maxScale);\n\t\n\t// Box\n\tfloat b2 = box(p, vec2(0.6 * scale));\n\tfloat b1 = box(p, vec2(0.4 * scale2));\n\t\n\tfloat result = b1 + b2;\n\tfloat offset = 1.0 + sin(iTime * 5.0 + fract(st.x) * fract(st.y)) / 2.0;\n\t\n\tvec3 color = vec3(\n\t\tresult * offset * sin(iTime * 10.0 * fract(p.x)),  // This sin(time * fract(p.x)) make box noisy.\n\t\tresult * offset * 0.2,\n\t\tresult * offset * 0.9\n\t);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBfR1", "name": "Trisection in Smoothstep", "author": "iq", "description": "Professor Rahul Narain noticed that under the y=smoothstep(x) inversion ([url]https://www.shadertoy.com/view/MsSBRh[/url]) one gets cos(acos(v)/3) = cos(u/2), for uv = 2xy-1. Use the mouse to move the contruction.", "tags": ["2d", "acos", "smothstep", "trivision"], "likes": 7, "viewed": 758, "date": "1499416181", "time_retrieved": "2024-06-20T18:58:19.185815", "image_code": "// The MIT License\n// Copyright  2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// The inverse function of the smoothstep y(x) = x(3-2x) has analytic inverse of the form\n//\n//    y = 0.5 - sin(asin(1-2*x)/3)\n//\n// Professor Rahul Narain noticed that if uv = 2xy-1, then\n//\n//    asin(v)/3 = asin(u/2)\n//\n// which means that \n//\n//    cos( acos(v)/3 ) = u/2\n//\n// This shader shows the geometric construction behind this fact (the smoothstep is in xy and the circle is in uv)\n//\n// 1. We pick a value for v (with the mouse, orange point)\n// 2. We project vertically into the smoothstep\n// 3. We project horizontally into the unit circle\n// 4. We take tha angle produced\n// 5. We trisect it\n// 6. We project horizontally to get the green point\n// 7. The length of the green segment is half of the red segment\n\n\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt( in vec2 uv, in int value, const int maxDigits )\n{\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px = 1.0/iResolution.y;\n    vec2  uv = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n    \n    float  u = clamp( (-iResolution.x+2.0*iMouse.x)/iResolution.y, -1.0, 1.0 );\n\tif( iMouse.z<0.001 ) u = 0.98*sin(iTime*0.5);\n    vec3 col = vec3(0.0);\n    \n    if( uv.x>-1.0 && uv.x<1.0 )\n    {\n        // grid\n        col = vec3( 0.2 ) + 0.01*mod(floor(uv.x*10.0)+floor(uv.y*10.0),2.0);\n        // smoothstep\n        vec2 xy = uv*0.5 + 0.5;\n        float y1 = smoothstep( 0.0, 1.0, xy.x );\n        col = mix( col, vec3(0.0,0.4,0.7), 1.0-smoothstep( 0.0, 2.0*px, abs(xy.y-y1) ) );\n\t\t// circle\n        col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, 2.0*px, abs(length(uv)-1.0) ) );\n\t\t// axes\n        col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, 2.0*px, abs(uv.x) ) );\n        col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep( 0.0, 2.0*px, abs(uv.y) ) );\n\n\n        // compute geometry\n        \n        vec2 p0 = vec2(0.0,1.0);\n        // project vertically\n        vec2 p1 = vec2(u,1.0); \n        // project into smoothstep\n        vec2 p2 = vec2(u,(3.0*u-u*u*u)/2.0); // x(3-2x) becomes (3u-u^3)/2 under -1..1 normalization\n        // project into circle\n        vec2 p3 = vec2(sqrt(1.0-p2.y*p2.y),p2.y);\n        // trisection\n        float an = asin(p2.y);\n        vec2 p4 = vec2(cos(an*(2.0/3.0)),sin(an*(2.0/3.0)));\n        vec2 p5 = vec2(cos(an*(1.0/3.0)),sin(an*(1.0/3.0)));\n        // project horizontally\n        vec2 p6 = vec2(1.0,p5.y);\n        vec2 p7 = vec2(1.0,0.0);\n        vec2 p9 = vec2(0.0,0.0);\n\n        col = mix( col, vec3(1.0,0.3,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p0, p1) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p1, p2) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p2, p3) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p9, p3) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p9, p4) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, sdSegment(uv, p9, p5) ) );\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 3.0*px, sdSegment(uv, p5, p6) ) );\n        col = mix( col, vec3(0.0,0.7,0.3), 1.0-smoothstep( 0.0, 3.0*px, sdSegment(uv, p6, p7) ) );\n        col = mix( col, vec3(1.0,0.3,0.0), 1.0-smoothstep( 0.0, 2.0*px, length(uv-p1)-9.0*px ) );\n        col = mix( col, vec3(0.0,0.7,0.3), 1.0-smoothstep( 0.0, 2.0*px, length(uv-p6)-9.0*px ) );\n\n        col += vec3(1.0,0.3,0.0)*float( PrintInt( (uv-vec2(0.5,-0.80))*10.0, int(round(abs(10000.0*p1.x))), 5 ) );\n        col += vec3(0.0,0.7,0.3)*float( PrintInt( (uv-vec2(0.5,-0.95))*10.0, int(round(abs(10000.0*p6.y))), 5 ) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBfWR", "name": "holo 1", "author": "loganz", "description": "holo", "tags": ["procedural", "2d", "noise", "perlin"], "likes": 2, "viewed": 108, "date": "1500020090", "time_retrieved": "2024-06-20T18:58:19.186073", "image_code": "#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat grad(float hash, vec3 pos) {\n    float h = floor(mod(hash, 16.0));\n    float u = h<8.0 ? pos.x : pos.y,\n          v = h<4.0 ? pos.y : h==12.0||h==14.0 ? pos.x : pos.z;\n    return (mod(h, 2.0) == 0.0 ? u : -u) + (mod(h, 4.0) == 0.0 ? v : -v);\n}\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat hashx(float x) {return rand(vec2(x, x * 1.121)) * 256.0;}\nfloat hash(float x) {return mod(x * 15531.13513 + x * x * 24.98981, 256.0);}\nfloat lerp(float t, float a, float b) {return a+t*(b-a);}\n\nfloat cnoise(vec3 pos){\n    vec3 ipos = mod(floor(pos), 256.0);\n    pos = fract(pos);\n    vec3 faded = fade(pos);\n    \n    float A = hash(ipos.x)+ipos.y, AA = hash(A)+ipos.z, AB = hash(A+1.0)+ipos.z;\n    float B = hash(ipos.x+1.0)+ipos.y, BA = hash(B)+ipos.z, BB = hash(B+1.0)+ipos.z;\n\n    //gradient values\n    float g0 = grad(hash(AA), pos);\n    float g1 = grad(hash(BA), pos-vec3(1.0,0.0,0.0));\n    float g2 = grad(hash(AB), pos-vec3(0.0,1.0,0.0));\n    float g3 = grad(hash(BB), pos-vec3(1.0,1.0,0.0));\n    float g4 = grad(hash(AA+1.0), pos-vec3(0.0,0.0,1.0));\n    float g5 = grad(hash(BA+1.0), pos-vec3(1.0,0.0,1.0));\n    float g6 = grad(hash(AB+1.0), pos-vec3(0.0,1.0,1.0));\n    float g7 = grad(hash(BB+1.0), pos-vec3(1.0,1.0,1.0));\n    return lerp(faded.z, lerp(faded.y, lerp(faded.x, g0, g1), lerp(faded.x, g2, g3)), lerp(faded.y, lerp(faded.x, g4, g5), lerp(faded.x, g6, g7)));\n}\n\nconst float SPARKLE_INTENSITY = 0.8;\nconst float SPARKLE_SCALE = 0.5;\nconst float SPARKLE_SPEED = 0.917;\nconst float SHIMMER_SCALE = 0.00075;\nconst float SHIMMER_SPEED = 0.21;\nconst vec3 SHIMMER_COLOR = vec3(0.9, 0.4, 0.7) * 0.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dY = iTime * 0.1;\n    vec2 angle = iMouse.xy / iResolution.xy * 0.5 * vec2(12.0, 3.0) + vec2(17.12367, 91.77);\n    vec3 coord = vec3(1723.23, 91.2998, 272.122) * vec3(iResolution.xy, 1.0);\n    coord += vec3(fragCoord.xy, 0.0);\n\n    vec3 sparkle, shimmer;\n    sparkle.r = cnoise(coord * vec3(SPARKLE_SCALE) + vec3(0.9112, 0.712 + dY, angle.y*SPARKLE_SPEED + angle.x*SPARKLE_SPEED*3.0/8.0 + 0.17));\n    sparkle.g = cnoise(coord * vec3(SPARKLE_SCALE) + vec3(0.9112, 0.712*2.0 + dY, angle.y*SPARKLE_SPEED + angle.x*SPARKLE_SPEED*3.0/8.0 + 0.17));\n    sparkle.b = cnoise(coord * vec3(SPARKLE_SCALE) + vec3(0.9112, 0.712*3.0 + dY, angle.y*SPARKLE_SPEED + angle.x*SPARKLE_SPEED*3.0/8.0 + 0.17));\n    sparkle += 0.5;\n    sparkle *= sparkle;\n    sparkle *= sparkle;\n    sparkle *= SPARKLE_INTENSITY;\n\n    shimmer.r = cnoise(coord * vec3(SHIMMER_SCALE) + vec3(angle.x*SHIMMER_SPEED, 0.0 + dY, angle.y*SHIMMER_SPEED + 0.27));\n    shimmer.g = cnoise(coord * vec3(SHIMMER_SCALE) + vec3(angle.x*SHIMMER_SPEED*1.721, 1.711 + dY, angle.y*SHIMMER_SPEED + 0.27));\n    shimmer.b = cnoise(coord * vec3(SHIMMER_SCALE) + vec3(angle.x*SHIMMER_SPEED*0.914, 1.711*2.0 + dY, angle.y*SHIMMER_SPEED + 0.27));\n    shimmer += 0.5;\n    shimmer *= SHIMMER_COLOR;\n    fragColor = vec4(sparkle + shimmer, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBfWw", "name": "3D coordinate frame", "author": "etale_cohomology", "description": "Fork of iq's https://www.shadertoy.com/view/Xt3SzX\nA primitive 3D cartesian coordinate frame, using iq's capsule. I don't know how to \"merge\" the 3 line segments naturally, so that line segment that are closer to the camera take precedence!", "tags": ["3d", "simple", "line", "iq", "cartesian", "frame", "engine", "primitive", "coordinate"], "likes": 1, "viewed": 89, "date": "1500627320", "time_retrieved": "2024-06-20T18:58:19.785861", "image_code": "// Fork of iq's https://www.shadertoy.com/view/Xt3SzX\n\n// What iq calls a \"capsule\", I call a \"3D segment\" =) And I THINK this function computes the normal.\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction.\n// There's only one sphere involved, not two.\n// The MIT License. Copyright  2016 Inigo Quilez. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// cc center, ca orientation axis, cr thickness, ch length\nvec4 segment3d_normal(in vec3 ro, in vec3 rd, in vec3 cc, in vec3 ca, float cr, float ch){\n    ca = normalize(ca);\n    vec3 oc = ro - cc;\n    ch *= .5;\n\n    float card = dot(ca, rd);\n    float caoc = dot(ca, oc);\n\n    float a = 1. - card * card;\n    float b = dot(oc, rd) - caoc * card;\n    float c = dot(oc, oc) - caoc * caoc - cr*cr;\n    float h = b * b - a * c;\n    if(h < .0)\n        return vec4(-1.0);\n    float t = (-b-sqrt(h))/a;\n\n    float y = caoc + t * card;  // The ray equation!\n\n    // body\n    if(abs(y) < ch)\n        return vec4(t, normalize(oc + t * rd - ca * y));\n\n    // caps\n    float sy = sign(y);\n    oc = ro - (cc + sy * ca * ch);\n    b = dot(rd, oc);\n    c = dot(oc, oc) - cr * cr;\n    h = b * b - c;\n    if(h > .0){\n        t = -b - sqrt(h);\n        return vec4(t, normalize(oc + rd * t));\n    }\n\n    return vec4(-1.);\n}\n\nvec3 draw_segment3d(vec3 ro, vec3 rd, vec4 segment_nor){\n    vec3 segment = vec3(.0);\n\tif(segment_nor.x > .0){\n\t\tvec3 nor = segment_nor.yzw;  // Normal?\n\t\tfloat dif = clamp(dot(nor, vec3(0.57703)), .0, 1. );  // Diffuse?\n\t\tfloat amb = .5 + .5 * dot(nor, vec3(1.));  // Ambient?\n\t\tsegment = vec3(.2, .3, .4) * amb + vec3(.8, .7, .5) * dif;\n\t}\n    return segment;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;  // Map pixel y-coordinates to [-1;1]\n\n    // Camera\n\tvec3 ro = vec3(1.);\n    vec3 ta = vec3(.0, .0, .0);\n    // Camera matrix\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(.0, 1., .0)));\n    vec3 vv = normalize(cross(uu, ww));\n\t// Create view ray\n\tvec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    // Raytrace!\n    float grow = sin(iTime);  // Just some animated growth, for fun\n\tvec4 segment0_nor = segment3d_normal(ro, rd, vec3(.0), vec3(.1, .0, .0), .04, 1. + .3*grow);\n    vec4 segment1_nor = segment3d_normal(ro, rd, vec3(.0), vec3(0., .1, .0), .04, 1. + .2*grow);\n    vec4 segment2_nor = segment3d_normal(ro, rd, vec3(.0), vec3(0., .0, .1), .04, 1. + .1*grow);\n\n    // Shading/lighting.\n    // I don't know how to \"merge\" the line segments naturally, so that line segment that are\n    // closer to the camera take precedence over those that are further away!\n    // The max() function doesn't do what I want, either! Help!\n    vec3 rgb = vec3(.06);  // Background color!\n    rgb += draw_segment3d(ro, rd, segment0_nor);\n    rgb += draw_segment3d(ro, rd, segment1_nor);\n    rgb += draw_segment3d(ro, rd, segment2_nor);\n\n\tfragColor.rgb = vec3(rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBfzm", "name": "Halftone Lines", "author": "cacheflowe", "description": "Another halftone pattern for compositing purposes", "tags": ["lines", "halftone", "stripes"], "likes": 5, "viewed": 605, "date": "1499894783", "time_retrieved": "2024-06-20T18:58:19.962003", "image_code": "#define linesRows 5.0\n#define thickness 0.25\n#define invert 0\n\nvec2 rotateCoord(vec2 uv, float rads) {\n    uv *= mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // update layout params\n    float rows = linesRows * 0.5;//linesRows + 3. * sin(iTime);\n    float curThickness = 0.25 + 0.22 * cos(iTime);\n  \tfloat curRotation = 0.8 * sin(iTime);\n    // get original coordinate, translate & rotate\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    //uv += curCenter;\n    uv = rotateCoord(uv, curRotation);\n    // create grid coords\n    vec2 uvRepeat = fract(uv * rows);\t\t\n    // adaptive antialiasing, draw, invert\n    float aa = iResolution.y * 0.00003; \t\n    float col = smoothstep(curThickness - aa, curThickness + aa, length(uvRepeat.y - 0.5));\n    if(invert == 1) col = 1. - col;\t\t\t\n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBfzz", "name": "rayz 4 dayz", "author": "DJDoomz", "description": "first 3d thing\nfeedback/suggestions/improvements would be greatly appreciated", "tags": ["raymarching"], "likes": 4, "viewed": 555, "date": "1499127060", "time_retrieved": "2024-06-20T18:58:20.737784", "image_code": "#define t iTime\n#define pi 3.14159\n\n//marching codes from iq & http://www.alanzucconi.com/2016/07/01/volumetric-rendering/\n//and thank you to ollj for the tips\n\nfloat noise(float x){ return abs(sin(34343.338*(x-1.)*(x+485.)*x));}\n\nfloat cube(vec3 rp, vec3 c, float s){\n    return length(max(abs(rp-c)-s,0.))-.1;//slightly modified\n}\n\nfloat cylinder( vec3 p, vec3 c, vec2 h){\n\tp -= c;\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn length(max(d,0.0));\n}\n\nvec2 map(vec3 p){\n    \n    vec2 podium = vec2(cylinder(p, vec3(0.,5.,0.), vec2(1.,4.)),1.);\n    \n    p.y += .2*sin(t)+.2; //moves thing up & down\n    vec2 thing = vec2(length(p)-1.,0.);\n    float a = p.y*pi/2.+.4*t; //twists thing\n    float s = sin(a), c = cos(a);\n    p.xz *= mat2(s,c,c,-s);\n    p.y += .1*sin(4.*atan(p.x,p.z))*length(p.xz);\n    \n    //subtracts a (twisted) cube from 6 sides\n    vec3 i = vec3(0);\n    i.x++;\n    for(int j = 0; j < 3; j++)\n    {\n\t\tthing.x = max(thing.x,-cube(p,i,.5));\n        thing.x = max(thing.x,-cube(p,-i,.5));\n        i.xyz = i.yzx;\n    }\n    \n    return thing.x < podium.x ? thing : podium;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd){\n    //starts at surface, heads towards lightsource\n   \tfloat d =0.02;\n    \n    for( int a=0; a < 60; a++)\n    {\n        float h = map(ro + rd*d).x;\n        if( h<0.001 )\n            return .6;\n        d += h*.7;\n    }\n    return 1.0;\n}\n\nvec4 renderBackGround(vec2 uv){\n    vec3 col1 = vec3(.9,.6,.9);\n    vec3 col2 = vec3(0.6,.7,.9);\n    \n\treturn vec4(mix(col1,col2,-(uv.y-1.+sin(t+uv.x))),1.);\n}\n\nvec4 simpleLambert(vec3 ro, vec3 norm, vec3 rd, in float obj){\n\tvec3 lDir = normalize(vec3(.8*sin(t),-.2,.8*cos(t))); //light direction\n    vec3 lCol = normalize(renderBackGround(ro.xy).xyz); //light color\n    vec3 oCol;\n    if(obj < .5)\n    oCol = vec3(0.6,.6,1.); //weird thing color\n    else\n    oCol = vec3(1);\t//pillar color\n    \n    vec3 h = (lDir-rd)/2.;\n    float s = pow(dot(norm,h),8.)*.7; //shininess\n    \n    float NdotL = max(dot(norm,lDir),.5); \n    \n    float sh = shadow(ro, lDir);\n    \n    vec3 light = (oCol*lCol*NdotL+s)*sh;\n    return vec4(light,1.);\n}\n\nvec3 normal(in vec3 p){ //calcs angle of a surface\n\tconst float eps = 0.001; \n    \n    //float base = map(p).x;\n\n    return normalize(\n        vec3(\n            map(p+vec3(eps,0.,0.)).x - map(p-vec3(eps,0.,0.)).x,\n            map(p+vec3(0.,eps,0.)).x - map(p-vec3(0.,eps,0.)).x,\n            map(p+vec3(0.,0.,eps)).x - map(p-vec3(0.,0.,eps)).x\n            )\n        );\n}\n\nvec4 renderSurface(in vec3 p, in vec3 rd, in float obj){\n\tvec3 n = normal(p);\n    return simpleLambert(p, n, rd, obj);\n}\n\n\nvec4 march(vec3 ro, vec3 rd){\n\tfloat t = 0.; //distance marched along ray\n    vec2 d;\t//.x: dist from nearest obj, .y: nearest obj number\n    vec3 p; //current position\n    \n    for(int i = 0; i < 170; i++){\n        p = ro + rd*t;\n\t\td = map(p);\n        t += d.x*.7;\n        if(d.x < 0.001) break; //if we hit something, exit the loop\n        if(d.x > 6.) break;\n    }\n    if(d.x < 1.)\n  \t\treturn renderSurface(p, rd, d.y); //render whatever we were closest to on exiting the loop\n    else\n        return renderBackGround(ro.xy);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.*(uv-.5);\n    uv.y /= iResolution.x/iResolution.y;\n    \n    //uv += .01*noise(uv.x+sin(t)); //cool glass/rain-like effect\n    \n    //ray origin & ray direction\n    vec3 ro = vec3(0.,-1.,-3.+1.*sin(t/5.));\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    float a = 1.6*pi+.1*sin(t/5.); //camera rot up/down\n    rd.yz *= mat2(sin(a),cos(a),cos(a),-sin(a));\n    \n    float rot = 2.*pi*abs(fract(t/16.)-.5); //camera rot xz\n    float s = sin(rot), c = cos(rot);\n    rd.xz *= mat2(s,c,c,-s);\n    ro.xz *= mat2(s,c,c,-s);\t//camera move xz\n    \n    vec4 t = march(ro,rd);\n    \n\tfragColor = pow(t+cos(uv.y*2.)-1., vec4(.5));//vignettes make everything look nicer\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfBW8", "name": "Worley Sea", "author": "Ebanflo", "description": "2d sky with clouds that are a cross-section of 3d fbm. Ocean heightmap with 3d worley noise based ripples. ", "tags": ["procedural", "3d", "noise", "ocean", "worley"], "likes": 7, "viewed": 877, "date": "1499458102", "time_retrieved": "2024-06-20T18:58:20.737784", "image_code": "//clouds\n#define cloudIterations 4\n#define cloudScale .1\n#define cloudThickness .3\n#define cloudSpeed .1\n#define cloudDir vec2(.866, .5)\n#define skyHeight 40.0\n//waves\n#define bigWaveDir vec2(.866, .5)\n#define smallWaveDir vec2(.866, -.5)\n#define bigWaveHeight 10.0\n#define smallWaveHeight 5.0\n#define bigWaveSpeed 1.0\n#define smallWaveSpeed 2.0\n#define bigWaveLength 5.0\n#define smallWaveLength 5.0\n//ripples\n#define rippleHeight .5\n#define rippleDensity 1.0\n#define rippleFreq 3.0\n//colors\n#define skyColor vec3(.3, .8, 1)\n#define cloudColor vec3(.7, .84, .84)\n#define fogColor vec3(.74, .84, .94)\n#define waterColor vec3(.05, .546, .85)\n//util\n#define pi 3.141592654\n#define steps 20\n#define heightThreshold .01\n#define epsilon .01\n#define stepsize .1\n//misc\n#define cameraHeight 25.0\n#define light vec3(1)\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nvec3 hash33(vec3 p3)//Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat hash13(vec3 p3)//Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hashNoise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix(hash13(p+vec3(0,0,0)), \n                       hash13(p+vec3(1,0,0)),f.x),\n                   mix(hash13(p+vec3(0,1,0)), \n                       hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix(hash13(p+vec3(0,0,1)), \n                       hash13(p+vec3(1,0,1)),f.x),\n                   mix(hash13(p+vec3(0,1,1)), \n                       hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat ripples(vec2 x){\n    vec3 p = vec3(x, rippleFreq * iTime);\n    p *= rippleDensity;\n    float d = 9e9;\n    vec3 g = floor(p);\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++){\n            for(int k = -1; k < 2; k++){\n\t\t\t\tvec3 g0 = g + vec3(i, j, k);\n                vec3 v = p - g0 - hash33(g0);\n            \td = min(d, dot(v, v));\n            }\n        }\n    }\n    return rippleHeight*d;\n}\n                \nfloat heightMap(vec2 x){\n    float result = -2.0 * (bigWaveHeight + smallWaveHeight + 2.0 * rippleHeight);\n    result += bigWaveHeight * sin(dot(x, bigWaveDir) / bigWaveLength \n                                   + bigWaveSpeed * iTime);\n    result += smallWaveHeight * sin(dot(x, smallWaveDir) / smallWaveLength\n                                   + smallWaveSpeed * iTime);\n    result += ripples(x);\n\treturn result;\n}\n\nfloat hpotential(vec3 pos){return pos.y - heightMap(pos.xz);}\n\nvec3 getNormal(vec3 pos){\n    vec2 e = vec2(1.0, 0.0);\n    return normalize(vec3(\n        hpotential(pos + epsilon * e.xyy),\n        hpotential(pos + epsilon * e.yxy),\n        hpotential(pos + epsilon * e.yyx))\n        - hpotential(pos));\n}\n\nfloat doSun(vec3 rd){\n    float l = max(0.0, dot(rd, normalize(light)));\n    l *= l;\n    l *= l;\n    l *= l;\n    return l;\n}\n\nfloat doClouds(vec2 x){\n    x *= cloudScale;\n    x.x += 1000.0;\n    x += cloudSpeed * iTime * cloudDir;\n    float result = 0.0;\n    float scale = .5;\n    for(int n = 0; n < cloudIterations; n++){\n        result += hashNoise(vec3(x, cloudSpeed * iTime) * scale) / scale;\n        scale *= 2.0;\n        \n    }\n    result *= .5;\n    result = smoothstep(1.0 - cloudThickness, 1.0, result);\n    return result;\n}\n\nvec3 doSky(vec3 rd, vec3 ro){\n    vec2 skyPos = ro.xz + rd.xz * (skyHeight - ro.y) / rd.y;\n    vec3 result = cloudColor;\n    float sun = doSun(rd);\n    float clouds = doClouds(skyPos);\n    result += clouds;\n    result = mix(result, skyColor, clouds);\n    result += pow(vec3(.9, .4, .1), (.8 - vec3(sun * clouds)) * 20.0);\n    return result;\n}\n\nvec3 render(vec3 rd, vec3 ro){\n    if(rd.y < 0.0){\n        float rdParam = rd.y + length(rd.xz);\n        vec3 intersect = ro + cameraHeight * rd / rd.y;\n        float dist = length(intersect.xz);\n        float d = distance(intersect, ro);\n        vec3 pos = intersect;\n        for(int n = 0; n < steps; n++){\n        \tpos = d * rd + ro;\n        \tfloat h = hpotential(pos);\n        \tif(h < heightThreshold) break;\n        \telse d += rdParam/h;\n    \t}\n        vec3 n = getNormal(pos);\n        pos.y += cameraHeight;\n        vec3 refl = doSky(reflect(rd, n), pos);\n        return refl * waterColor;\n    }\n    else return doSky(rd, ro);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    fragColor = vec4(vec3(0.0), 1.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3(0.0, cameraHeight, 0.0);\n\tvec3 rd = normalize(vec3(xy, 2.5));\n    vec2 m = 2.0 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    if(iMouse.xy == vec2(0)) m = vec2(0);\n    rd = r(rd, m);\n    fragColor.xyz = mix(render(rd, ro), fogColor, max(0.0, 1.0 - abs(10.0 * rd.y)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjBDm", "name": "3lightsFork", "author": "Coolok", "description": "3lightsFork", "tags": ["3lightsfork"], "likes": 2, "viewed": 103, "date": "1500761543", "time_retrieved": "2024-06-20T18:58:20.737784", "image_code": "float beat = 0.;\nfloat mb(vec2 p1, vec2 p0) { return (0.04+beat)/(pow(p1.x-p0.x,2.)+pow(p1.y-p0.y,2.)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ct = iChannelTime[0];\n\tif ((ct > 8.0 && ct < 33.5)\n\t|| (ct > 38.0 && ct < 88.5)\n\t|| (ct > 93.0 && ct < 194.5))\n\t\tbeat = pow(sin(ct*3.1416*3.78+1.9)*0.5+0.5,15.0)*0.05;\n\n\tvec2 mbr,mbg,mbb;\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec2 o = vec2(pow(p.x,2.),pow(p.y,2.));\n\tvec3 col = vec3(pow(2.*abs(o.x+o.y)+abs(o.x-o.y),5.));\n\tcol = max(col,1.);\n\tfloat t=iTime+beat*2.;\n\t\n\tfloat t2=t*2.0,t3=t*3.0,s2=sin(t2),s3=sin(t3),s4=sin(t*4.0),c2=cos(t2),c3=cos(t3); // Let me extend this line a little more with an useless comment :-)\n\t\n\tmbr = mbg = mbb = vec2(0.);\n\tmbr += vec2(0.10*s4+0.40*c3,0.40*s2 +0.20*c3);\n\tmbg += vec2(0.15*s3+0.30*c2,0.10*-s4+0.30*c3);\n\tmbb += vec2(0.10*s3+0.50*c3,0.10*-s4+0.50*c2);\n\t\n\tcol.r *= length(mbr.xy-p.xy);\n\tcol.g *= length(mbg.xy-p.xy);\n\tcol.b *= length(mbb.xy-p.xy);\n\tcol   *= pow(mb(mbr,p)+mb(mbg,p)+mb(mbb,p),1.75);\n\t\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjBDR", "name": "[SH17A] Transparent Isoslices", "author": "Shane", "description": "A transparent organic field partitioned horizontally into 2D isosurface slices.", "tags": ["transparency", "code", "small", "tweet"], "likes": 60, "viewed": 1551, "date": "1500135748", "time_retrieved": "2024-06-20T18:58:21.392292", "image_code": "/*\n\n    Transparent Isoslices\n\t---------------------\n\n\tQuasi diffuse-lit transparent isosurface slices. I had to get a little inventive -\n\tboth with the character shuffling and the methodology - to make this work.\n\n\tI don't know if anyone's noticed this, but 280 characters is not a lot to work \n\twith. :) I mean, you could order a beer in under two tweets, but you couldn't chat \n\tup the bar maid... OK, some people on Shadertoy probably could. :D\n\n*/\n\n// Cheap organic distance field - partitioned into horizontal slices.\n//\nfloat m(vec3 p)\n{ \n    // Moving the scene itself forward - as opposed to the camera - to save on some lighting\n    // calculations later on. IQ does it in one of his small examples. \"iTime\" - IQ's suggestion.\n    // I didn't know that was an option... I need to read more. :)\n    p.z += iTime; \n    \n    \n    // Chopping the field into horizontal strips. It's quite a brutal approach, and it only works\n    // because of the volumetric-like traversal. By the way, if you comment the line out, the \n    // isolines disappear, along with 22 characters, but it wasn't the look I was after.\n    p.y = ceil(p.y*12.)/12.;\n    // Based on Public_int_i's suggestion. Saves a bunch of characters. If it matches the above\n    // speedwise, I'll be using it.\n    //p.y -= mod(p.y, .08); \n   \n    // Very cheap organic distortion. This line can be amalgamated below... I was a little suspicious\n    // about compilation order, but Greg Rostami is OK with it, so I am too. :)\n\t//p = cos(p*.6 + sin(p.zxy*1.8));\n\n    // Return the absolute field value to ensure that the ray doesn't backtrack.\n    return abs(dot(p = cos(p*.6 + sin(p.zxy*1.8)), p) - 1.1);\n}\n\nvoid mainImage( out vec4 c, vec2 u){\n\n    // The loosely centered and normalized unit direction ray, and the origin - initialized\n    // to zero. Characters can be saved by dropping \"d\" directly into the loop, but this way\n    // feels cleaner to me.\n    vec3 d = vec3(u/iResolution.y - .6, 1), o = d - d;\n    \n    // Initializing \"c\" to zero... in a less than satisfactory way.\n    c -= c;\n    \n\t// Loop variables. Declaring the loop iteration variable, \"i,\" outside of the loop in a \n    // shader environment makes me a little nervous, but things seem to be compiling.\n    float j, i = 0.;\n    \n    // In order to save characters, it's customary to dispense with the early break.\n    // Of course, that means we're effectively calling the function for the entire loop\n    // count. Therefore, I figured I may as well try to take advantage of that... in as\n    // few characters as possible. :)\n\n    // Compiler's nightmare loop. :)\n    //\n    // Sketchy way to write a 100-count loop. Thanks to Aeikick for reminding me of that.\n    // It's tempting to stick the first line after the second semicolon, but I think it'll be\n    // skipped on the first iteration.\n    //for(int i=99; i-->0;)\n    // Slower \"float\" based loop, but uses fewer charaters. \"i\" is declared with \"j\"... It was \n    // BigWings's suggestion to  Nesvi7, so if it doesn't work, blame him. D\n    //for(; i++<1e2;) \n    while (i++<1e2) // Cleaner Web 2.0 suggestion, but Abje.\n        \n        // The distance function. Normally, the \"/3.\" wouldn't be there, but things have \n        // been shuffled around to save a few characters. By the way, the return distance, \"m(o),\"\n        // is absolute to ensure that the ray continues travelling forward.    \n        j = m(o)/3.,\n        \n        // If the distance to the surface comes within a certain threshold, add some lighting\n        // based on said distance. The \"m(o + const)\" is an old trick. It's kind of a meld between \n        // directional derivative lighting and occlusion... Something like that anyway. \"j\" is\n        // represetative of the current ray-to-surface distance. \"o.z\" is a rough approximation\n        // of the total distance, and is used for attenuation. Using \"o.z\" has the added benefit of\n        // giving the lighting a slight parallax feel.\n        //\n        // On a side note, using an \"if\" statement cuts down on characters, but I wanted this to\n        // be branchless to save a few cycles.\n        //\n        // IQ's suggestion: Faster, and saves some characters. I'd originally used a step function,\n        // which is apparently slower than the following. I read somewhere that the ternary \n        // operator isn't guaranteed not to branch on nontrivial calculations, but chances are\n        // minimal, or something to that effect. I've also read that it never branches with certain\n        // shader languages? ... I'll leave the debate to the experts. :)\n        // Fabrice suggested a couple of obvious changes to cut it down some more.\n        c -= j<.01 ? (j - .01)*m(o + .1)/(.02 + o.z/2e2) : 0.,\n        \n        // Advance the ray in such a way that it encourages it to pass closely to the surface, but\n        // continue on its way.\n        o += max(.01, j)*d;\n                           \n\n    // Cheap color... I'd need to cut this down further to fit it in, but I prefer the black and \n    // white look anyway.\n    // c.xyz += d/o.z;\n    ////c.zyx += .1 + d*.2; //Etc.\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjBWD", "name": "Conway-Pinwheel Tiling (dual)", "author": "ttoinou", "description": "Modifying [url]https://www.shadertoy.com/view/XsBfzW[/url] with Conway - Pinwheel triangle (1 2 sqrt(5)) rep-tile tiling ! Here a weigthed center of each triangle is shown", "tags": ["triangle", "tiling", "conway", "pinwheel"], "likes": 10, "viewed": 210, "date": "1500524357", "time_retrieved": "2024-06-20T18:58:21.398389", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\n// pointA and pointB are on the same side of the half plane delimited by line (lineA,lineB)\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n} \n\nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n};\n   \nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - sin(iTime*3.14/17.0))/2.0,0.5)*6.1));\n    \n    vec2 base = vec2(2.0,1.0);\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1.25;\n    uv *= viewportMagnify;\n    uv += base/2.25;\n    \n    // Base Triangle\n    Pinwheel Tri;\n    Pinwheel Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    \n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n        }\n        \n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    fragColor.rgb = vec3(1.0);\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale;\n    \n    vec3 EquerreCoeffs = barycentricCoordinate(uv,Tri);\n    vec3 EquerreColor =\n          EquerreCoeffs.x * hash3point(Tri.A)\n        + EquerreCoeffs.y * hash3point(Tri.B)\n        + EquerreCoeffs.z * hash3point(Tri.C)\n    ;\n    \n    vec3 EquerreDualColor = vec3(0.0,0.0,0.0);\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    scale /= sqrt(float(nbIterations))/3.;\n   \n    #if SHOW_POINTS==1\n    \t#define OPERATION2(x) fragColor.rgb = mix( EquerreColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,x,scale))\n    \n        OPERATION2(Tri.A);\n        OPERATION2(Tri.B);\n        OPERATION2(Tri.C);\n    \n    #endif\n    \n    float k = iTime/1.0*3.14;\n    vec2 mouse = iMouse.z > .5 ?\n          iMouse.xy / iResolution.xy\n        : vec2(1.0/3.0) + 0.15 * vec2(cos(k),sin(k));\n    vec3 coeffs;\n    coeffs.xy = mouse.xy;\n    coeffs.z = 1.0 - mouse.x - mouse.y;\n    if( coeffs.z < 0.0 )\n    {\n        coeffs.x = 2.0;\n        coeffs.y = 1.0;\n        coeffs.z = sqrt(3.0);\n        coeffs /= coeffs.x + coeffs.y + coeffs.z;\n    }\n    \n    #define EQUERRE_CENTER_MIX(T) (T.A * coeffs.x + T.B * coeffs.y + T.C * coeffs.z)\n    vec2 TriCenterMix = EQUERRE_CENTER_MIX(Tri);\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb = mix( EquerreDualColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n           \n    \n    fragColor.rgb = tanh(fragColor.rgb*2.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjBzR", "name": "distance", "author": "Coolok", "description": "distance", "tags": ["distance"], "likes": 0, "viewed": 70, "date": "1499204439", "time_retrieved": "2024-06-20T18:58:21.398389", "image_code": "// Based on https://www.shadertoy.com/view/lsfyDn\n\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv.x = uv.x*ar;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    \n    float speed = 10.0;\n    float amp = .5;\n    float sep = 1.5;\n     \n    float comb = 1.;\n    \n    for (float i = 0.; i < 7.; i++) {\n        comb *= distance(uv,vec2(sin(t+i*TWO_PI/7.)/(3.*(sin(t)/5.+1.))+.9,cos(t+i*TWO_PI/7.)/(3.*(sin(t)/5.+1.))+.5))*3.0;\n    }\n    \n    float red = sin(comb*(3.0)-t*speed)/2.0+0.5;\n    float green = sin(comb*(3.0+sep)-t*speed)/2.0+0.5;\n    float blue = sin(comb*(3.0+sep*2.0)-t*speed)/2.0+0.5;\n    \n    vec3 color = vec3(red-comb+amp,green-comb+amp,blue-comb+amp);\n    \n\tfragColor = vec4(sin(t)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjBzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjfRm", "name": "[SH17A] Triangular Voro Lighted", "author": "aiekick", "description": "reduced version of my shader [url=https://www.shadertoy.com/view/ltK3WD] Triangular Voronoi Lighted [/url]\n", "tags": ["voronoi", "light", "sh17a", "triangula"], "likes": 6, "viewed": 473, "date": "1499969013", "time_retrieved": "2024-06-20T18:58:21.398389", "image_code": "void mainImage( out vec4 f, vec2 g )\n{\n\tvec2 p = g /= 80.,k; f-=f-6.;\n    \n    for(;f.x-->0.;)\n        for(f.y=6.;f.y-->0.;\n           p = f.xy - 3.,\n           p += sin( iTime + 9. * fract(sin((floor(g)+p)*mat2(2,5,5,2)))) - fract(g),\n           f.z = max(abs(p.x)*.87 - p.y*.5, p.y))\n                if (f.z < f.w)\n                    f.w = f.z, k = p;\n    \n    //f = vec4(3,2,1,1) * f.w * sign(f.w - vec4(vec2(-k.x,k.x)*.87-k.y*.5,k.yy)); // beautifull version but 293c :(     \n    f = f.w - sign(f.w - vec4(vec2(-k.x,k.x)*.87-k.y*.5,k.yy));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjfRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjfzK", "name": "Alia's Loading bar", "author": "Molive", "description": "Alia's infinite loading bar, based off of a story in the uk demoscene slack channel.", "tags": ["2d", "infinite"], "likes": 0, "viewed": 110, "date": "1501267994", "time_retrieved": "2024-06-20T18:58:21.580338", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 effect = vec2((iResolution.x / iResolution.y)*0.5,0.5);\n    vec2 uvx = (fragCoord.xy / iResolution.y)-effect;\n    float dist = length(uvx);\n    if (dist > abs(sin(0.3)))\n    {\n        fragColor =vec4(0.9,0.9,0.9,1.0);\n        return;\n    }\n    if (dist < abs(sin(0.25)))\n    {\n        fragColor =vec4(0.9,0.9,0.9,1.0);\n        return;\n    }\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    if (mod(iTime,8.0) <4.0) {\n    if (mod(atan(uvx.y/uvx.x),4.0) <mod(iTime,4.0)) {\n       \tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        return;\n    }\n    } else {\n    if (mod(atan(uvx.y/uvx.x),4.0) <4.0-mod(iTime,4.0)) {\n       \tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        return;\n    }\n    }\n    fragColor = vec4(0.9,0.9,0.9,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjfzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSBDR", "name": "[SH17A] 4 in 1 !", "author": "GregRostami", "description": "Here are 4 of my older shaders combined into 1.\nA BIG thanks to all of my fellow golfers!\nAt FOUR shaders, each shader is HALF a tweet. :)", "tags": ["2d", "multiple", "sh17a"], "likes": 3, "viewed": 445, "date": "1500014443", "time_retrieved": "2024-06-20T18:58:21.580338", "image_code": "// 267 chars - Thanks to Fabrice's help, we reduced shader to add transitions.\n\n#define F fract(t\nvoid mainImage(out vec4 o, vec2 V) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec2 R = iResolution.xy, U, u=V/R.x-.5;\n    o = 3. * texture(iChannel1, V/R);\n    U = u/dot(u,u);\n    float t = iTime, c = F*.1-u.x);\n    o =   c<.25 ? max( U= F +U+U), U.x - U ).yyyy\n        : c<.5 ? texture( iChannel0, F *.2 - vec2(u.x,1)/u.y ) )* -u.y*3.\n        : c<.75 ? vec4( F + u.x*u.y*2e3 ) )\n        : o + o.g - o.r - o; }  /*\n\n\n// 279 chars - Origianl Shader:\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec2 R = iResolution.xy, U;\n    o = 3. * texture(iChannel1, u/R);\n    U = u/dot(u = u / R.x - .5, u);\n    float t = iTime, c = fract(t*.1);\n    o =   c<.2 ? max( U= fract(U+U+t), U.x - U ).yyyy\n        : c<.5 ? texture( iChannel0, fract( .2*t - vec2(u.x,1)/u.y ) )* -u.y*3.\n        : c<.7 ? vec4( fract( t + u.x*u.y*2e3 ) )\n        : o + o.g - o.r - o;\n}\n*/", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSBWD", "name": "[SH17A] Bouncing lights", "author": "jope246", "description": "My sh17a submission. Thebookofshaders.com has been really helpful.", "tags": ["bouncing", "sh17a"], "likes": 0, "viewed": 73, "date": "1500404155", "time_retrieved": "2024-06-20T18:58:21.580338", "image_code": "#define d distance\n#define pi 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float r = sin(iTime*pi)/10.;\n\tvec2 u = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = vec4(vec3(1.,0.6,0.)-vec3(min(d(u, vec2(.4-r)),min(d(u, vec2(.6+r)),min(d(u, vec2(.6+r, .4-r)), d(u, vec2(.4-r,.6+r)))))),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSBWz", "name": "Austin Powers Accident", "author": "Flopine", "description": "Homework #1", "tags": ["raymarching", "cube", "green"], "likes": 1, "viewed": 123, "date": "1500029355", "time_retrieved": "2024-06-20T18:58:21.580338", "image_code": "float sphere(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\nfloat box (vec3 pos, vec3 corner)\n{\n    return length(max(abs(pos) - corner,0.));\n}\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\n\nvec3 albedo (vec3 pos)\n{\n\tpos *= 0.2;\n\t\n\tfloat f = smoothstep (0.08, 0.9, fract(pos.z));\n\t//return fract(pos.z) * vec3(0.0,1.0,0.0);\n\treturn f*vec3 (0.5,0.8,0.1)*8.0;\n}\n\nfloat SDF(vec3 pos)\n{\n    pos.z = mod(pos.z+4.,8.)-4.;\n    pos.xy = pos.xy*rotate(sin(iTime*2.0)+1.);\n    pos.yz = pos.yz*rotate(sin(iTime*0.9)+1.);\n    return max(-sphere(pos,1.9),box(pos, vec3(1.5)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy) -1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 pos = vec3 (0.,0.,-2.5*iTime*0.6);\n    vec3 frust = vec3 (uv*0.1,1.);\n    vec3 color = vec3(0.);\n    \n    for (int i = 0; i<120; i++)\n    {\n        float d = SDF(pos);\n        if (d<0.001)\n        {\n           color = albedo(pos); \n           break;\n        }   \n        \t\n        pos += d*frust;\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSBzw", "name": "polka dots - tbos", "author": "nckrlf", "description": "one of the exercises from chapter 9 of The Book of Shaders. I swear I didn't look at their solution until after I finished! I like my solution better anyway :p", "tags": ["2d", "dots", "thebookofshaders"], "likes": 3, "viewed": 137, "date": "1499874525", "time_retrieved": "2024-06-20T18:58:21.834884", "image_code": "// @nckrlf\n\nfloat circle(vec2 _st, float _size, float _smooth)\n{\n    float r = distance(_st, vec2(0.5));\n    float result = smoothstep(_size+_smooth, _size, r);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    fragColor = vec4(1.0, 0.0, 0.5, 1.0);\n\n    // tile\n    int N = 6;\n    st *= float(N);\n\n    // dx should be +/- 1.0 for alternating rows\n    float dx = step(1.0, mod(st.y, 2.0)) * 2.0 - 1.0;\n    // every other second dx should be 0.0\n    dx *= step(1.0, mod(iTime, 2.0));\n\tst.x += dx * fract(iTime);\n\n    // dy should act similarly to dx, but for columns\n    float dy = step(1.0, mod(st.x, 2.0)) * 2.0 - 1.0;\n    // add 1 to the time so dy is 0 when dx is non-zero and vice-versa.\n    dy *= step(1.0, mod(1.0+iTime, 2.0));\n    st.y += dy * fract(iTime);\n\n    st = fract(st);\n\n    float d = circle(st, 0.3, float(N) * 0.005);\n    vec3 color = vec3(1.0, 0.3, 0.6) * vec3(d);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MssfDl", "name": "radial gradiant with focale", "author": "tshirtman", "description": "forked from https://www.shadertoy.com/view/ldtSzM and @FabriceNeyret2 suggestions, trying to make it more general, missing now is the ability to use an ellipse basis instead of a circle.\nUse mouse to move the focale point.\n\nnow with choice of spread algo.", "tags": ["2d", "gradiant"], "likes": 0, "viewed": 98, "date": "1498924104", "time_retrieved": "2024-06-20T18:58:22.155975", "image_code": "vec2 r = vec2(.5, .25);\nconst vec4 yellow = vec4 (1, 1, 0, 1),\n             blue = vec4 (0, 0, 1, 1);\n\n#define PAD 1\n#define REPEAT 2\n#define REFLECT 3\n\n#define spread REFLECT\n\nvoid mainImage(out vec4 O, vec2 U ){\n    vec2 f = iMouse.xy / iResolution.xy,\n         p = U / iResolution.xy,\n         d = f - p,\n         c = vec2(\n            cos(iTime) * .5 * cos(iTime / 4.) - .5,\n            sin(iTime) * .25 - .5\n    \t ) + f;\n        \n    float l = length(d);\n    \n    d /= l;\n    c /= l;\n    r /= l;\n\n    float cd = dot(c, vec2(-d.y, d.x)),\n          cl = sqrt(r.x * r.x - cd * cd) + dot(c, d);\n\n    float a_cl = 1. / cl;\n    \n    // special case for when focale point is outside of radius\n    if (a_cl < 0.)\n        a_cl = 1.;\n\n    switch (spread) {\n        case PAD:\n            a_cl = min(1., a_cl);\n        \tbreak;\n    \n    \tcase REPEAT:\n    \t\ta_cl = mod(a_cl, 1.0);\n        \tbreak;\n    \n    \tcase REFLECT:\n    \t\tfloat n = floor(a_cl);\n    \t\tfloat r = fract(a_cl);\n    \t\tif (mod(n, 2.) >= 1.)\n       \t\t\ta_cl = 1. - r;\n            else\n       \t\t a_cl = r;\n        break;\n     }\n    \n    O = mix(yellow, blue, a_cl);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssfDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSfWh", "name": "[SH17A] 3 Tap 2nd Order Voronoi", "author": "Shane", "description": "More specifically, this is bump mapped, hashless, 3-Tap 2nd order cellular pattern. The pattern isn't perfect, but you get what you pay for. :D", "tags": ["voronoi", "bump", "cellular", "tweet"], "likes": 12, "viewed": 904, "date": "1500296892", "time_retrieved": "2024-06-20T18:58:22.974295", "image_code": "/*\n\n\t3 Tap 2nd Order Voronoi\n\t-----------------------\n\n\tNot really an entry per se, but it wouldn't be Shadertoy without a cliche Voronoi example, so I\n\tcoded one up. :)\n\n\tThis particular one is a bump mapped, hashless, 3-Tap 2nd order cellular pattern. OK, it isn't \n\tVoronoi in the strictest sense, but it's produced with a custom algorithm designed to give the \n\tsame feel.\n\n\tThe standard Voronoi algorithm requires a little too much information. Loops, cell positions,\n\tdistance checks, and some kind of workable two dimensional hash function. Someone could probably \n\tfit it into two tweets, but I don't imagine there'd be much room left for anything else.\n\n\tThis pattern was produced using a different method, which involves plotting repeat points on warped, \n\trotational layers, then finding the desired first and second order distances. The resultant pattern \n\tisn't perfect - that's for sure, but the algorithm takes up considerably less space, which leaves \n\troom for some very cheap bump mapping, coloring, etc.\n\n\tI'd originally raymarched this, but there wasn't enough room left to pretty it up, so instead, I \n\topted to perform some very cheap two-sample bump mapping and coloring. By the way, if someone could \n\tremove some characters and apply some environment mapping, that'd be great. :D\n\n*/\n\n\n// Declaring some floats globally for global access - Basically, the opposite of what you're supposed \n// to with shader code. It wouldn't make Ollj happy. :D\n\n// I tried to give them intuitive one letter names. In order: Closest distance, second closest distance,\n// current distance, storage for the function value (y-x), and an out-of-place looking global loop counter... \n// Bad programming practice at its finest. :)\nfloat x, y, d, f, i;\n\n// Self contained, hashless, 3 Tap, 2nd Order Voronoi function. Not written for speed due to character\n// restrictions, but at 3 taps, it's not going to be slow anyway.\nvoid v(vec2 p){\n    \n    // The trick here is to plot a wrapped cell point, rotate space, plot another, repeat the process for \n    // the final point, then determine the closest and second closest with some max\\min trickery. Simple, \n    // but quite effective. I've left a few details out, but that's the general idea.\n    x = y = i = 2.;\n    while(i++<5.) d = length(fract(p *= mat2(7, -5, 5, 7)*.1) - .5)/.6, y = max(x, min(y, d)), x = min(x, d);\n   \n}\n\nvoid mainImage(out vec4 o, vec2 u){    \n    \n    // Moving screen coordinates.\n    u = u/iResolution.y*5. + iTime;\n    \n    // Call the function. \"v\" for Voronoi.\n    v(u);\n    // Storing the \"Y - X\" distance (similar to the cool beveled looking one, Y*Y - X*X). To make it \n    // slighty more interesting, I've added an additional sinusoidal term to give the illusion that the \n    // pattern is lit via some kind of grated mechanism which causes a subtle interference pattern. I \n    // used the second order distance only for that - to match the cell structure.\n    f = y - x - sin(y*80.)/80.; \n    \n    // Take a second nearby sample.\n    v(u-.05);\n    \n    // Calculating the sample difference, which in effect provides a gradient bump value. It's a cheap way \n    // to bump things and is based, in part, on directional derivative lighting. IQ wrote an article about \n    // it, which should be easy enough to find. I've stored the value in \"i\" to save characters.\n    i = max(y - x - f, 0.); \n    \n    // Apply a colored gradient (ramped up for a bit of shine) to the Voronoi (with interfernce) value.\n    o = f + vec4(10, 6, 2, 1)*i*i*i*20. + .03; // Very subtle global ambience on the end.\n    \n    // Backing off the green with a duller gradient to give a sunrise hue, or the lamest SSS effect ever. :D\n    o.y -= i; \n    \n} \n\n/*\n// Red and blue highlights, but I couldn't find a way to make it fit. :)\nvoid mainImage(out vec4 o, vec2 u){    \n    \n    // Moving screen coordinates.\n    u = u/iResolution.y*5. + iTime;\n    \n    // Call the function. \"v\" for Voronoi.\n    v(u);\n    // Storing the \"Y - X\" distance (similar to the cool beveled looking one, Y*Y - X*X). To make it \n    // slighty more interesting, I've added an additional sinusoidal term to give the illusion that the \n    // pattern is lit via some kind of grated mechanism which causes a subtle interference pattern. I \n    // used the second order distance only for that - to match the cell structure.\n    f = y - x + sin(y*80.)/1e2; \n    \n    // Take a second nearby sample.\n    v(u-.05);\n    \n    // Calculating the sample difference, which in effect provides a gradient bump value. It's a cheap way \n    // to bump things and is based, in part, on directional derivative lighting. IQ wrote an article about \n    // it, which should be easy enough to find. I've stored the value in \"i\" to save characters.\n    i = max(y - x - f, 0.); \n    x = max(f - y + x, 0.); \n    \n    o = vec4(9, 6, 2, 1);\n    // Apply a colored gradient (ramped up for a bit of shine) to the Voronoi (with interfernce) value.\n    o = f + (o*i*i*i + o.zyxw*x*x*x)*20. + .03; // Very subtle global ambience on the end.\n    \n    // Backing off the green with a duller gradient to give a sunrise hue, or the lamest SSS effect ever. :D\n    o.y -= i; \n    \n} \n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2BDm", "name": "Geometric Eyez", "author": "ttoinou", "description": "Tuning [url]https://www.shadertoy.com/view/Xd2fWw[/url]...\nStraight Triangles bends into circles, from left source to right sink ", "tags": ["spiral", "complex", "equerre"], "likes": 10, "viewed": 296, "date": "1500733349", "time_retrieved": "2024-06-20T18:58:24.713666", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat k = 1. - sqrt(3.)*.5;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,-(n + logZoom)/2.) , (n)/3.*PI + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    vec2 q = vec2(.3,.0);\n    //uv = cexp( clog( uv + q ) - clog( uv - q ) );\n    uv = cdiv( uv + q , uv - q );\n    \n    // doesn't matter, infinite zoom :p\n    viewportMagnify = 1.; \n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.))) * exp(-iTime/8.);\n    uv *= viewportMagnify;\n    \n    \n    angleShift = iTime*1.5;\n    logZoom = iTime*1.;\n    \n    float r = floor( -log(dot(uv,uv))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv) )\n    {\n        // inside circle\n        FindEquerre(r,uv);\n    }\n    \n    fragColor.rgb = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID)); \n\n    float scale = 1./viewportMagnify/(1. + dot(uv,uv)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb *= 3.*(.5 + coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n    \n    \n    fragColor.rgb = tanh(fragColor.rgb*2./(1. + dot(uv,uv)/1e3 ) ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2BDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2BWm", "name": "[SH17B] Abstract Balloon Flight", "author": "Shane", "description": "An air balloon passing over some rocky wetlands. Rendered in an abstract faux low-poly style.", "tags": ["raymarch", "abstract", "lowpoly", "adventure"], "likes": 50, "viewed": 4061, "date": "1500820466", "time_retrieved": "2024-06-20T18:58:31.738748", "image_code": "/*\n\n\tAbstract Balloon Flight\n\t-----------------------\n\n\tOne of the things I like about this competition is that I don't have to come up with\n\tideas - since the organizers have already taken care of that part. Having said that, \n\tI really struggled to think of a scene that conveyed \"adventure\" that would fit into \n\ta shader that would compile and run. In the end, I went for a cliche \"balloon over \n\tsunset terrain\" scene. Not exactly \"out of the box\" thinking, but at least I got my \n\thomework in on time. :)\n\t\n\tI chose an abstract, semi realistic, low-poly rendering style. Ironically, in a shader \n\tenvironment, achieving a low-poly look requires more effort than producing the smoother\n\tlooking imagery usually associated with a high polygon count. \n\n\tThe balloon was hacked together on the fly. It was a bit fiddly, but not that big a deal.\n\tModeling is simple enough - Just add the right objects in the right places. However, more\n\tdetail means slower distance functions. I got around that by using an old trick which\n\tinvolves intersecting with a sphere surrounding the object, then only raymarching the\n\tpixels necessary. \n\n\tThe low-poly looking terrain with its random rocks and greenery required a little more\n\teffort. Basically, you need 3D Voronoi, or something similar, to achieve that. Of course,\n\tthat's prohibitively expensive, so I've used one smooth noise base layer overlayed with\n\ta lower quality repeat cell tile algorithm that I came up with some time ago - and have \n\texplained in other examples.\n\t\n    Anyway, I tried to keep the size down, but more detail requires more writing, so it's a \n\tlittle larger than usual. I've hacked this together pretty quickly, so it needs some\n\ttidying up, both codewise and algorithmically speaking. I'll set about that over the\n\tnext couple of days. I'll try to get compilation time down too - You should never blame\n\tyour tools, but I swear it's WebGL 2's fault. :D\n\n*/\n\n// Allowing a bit of mouse movement. The scene was designed to look straight ahead, but\n// uncomment it if you want.\n//#define MOUSE_LOOK\n\n#define FAR 100. // Maximum ray distance. Analogous to the far plane.\n\n#define WAT 0. // Water.\n#define TER 1. // Terrain.\n#define BAL 2. // Balloon.\n#define BAS 3. // Basket.\n#define VEG 4. // Vegetation.\n#define SKY 5. // Sky.\n#define FLA 6. // Flame.\n\n#define camSpeed 5.\n\n// Balloon postion - relative to the camera.\n#define balPos vec3(-6, 12, 40)\n\n// Scene object ID. Either the path (0) or the surroundings (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// A flag to check whether we need to do the expensive balloon calculations. A sphere surrounding\n// the balloon will be raytraced prior to entering the raymarching loop, then the flag will be set.\nfloat balHit; \n\n// Fabrice's concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(cos(dot(p, vec3(157, 113, 7)))*45758.5453); }\n\n\n// Minimum - with corresponding object ID.\nvec2 objMin(vec2 a, vec2 b){ \n    \n    // Returning the minimum distance along with the ID of the\n    // object. This is one way to do it. There are others.\n    return a.x < b.x ? a : b;\n    \n    //Equivalent to: return a.x < b.x ? a: b; \n    //float s = step(a.x, b.x);\n    //return s*a + (1. - s)*b;\n}\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p);\n    //return max(max(p.x, p.y), p.z);    \n    \n    // Cubic.\n    //p = abs(fract(p) - .5); \n    //return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    p = abs(fract(p) - .5); \n    p = max(p*.866025 + p.yzx*.5, p.yzx);\n    return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    //return 1. - min(d.x, d.y)*2.; // Scale between zero and one... roughly.\n    \n    // For anyone wanting to experiment with this, the following gives better variance:\n    const float scale = 1.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\nfloat drawObject2(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Cubic.\n    p = abs(fract(p) - .5); \n    return max(max(p.x, p.y), p.z);\n\n\n    // Hexagonal tube.\n    p = abs(fract(p) - .5); \n    p = max(p*.866025 + p.yzx*.5, p.yzx);\n    return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\nfloat cellTile2(in vec3 p, float scale){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject2(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject2(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject2(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject2(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    //return 1. - min(d.x, d.y)*2.; // Scale between zero and one... roughly.\n \n    // For anyone wanting to experiment with this, the following gives better variance:\n    //const float scale = 2.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\n/*\n// Second order version.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.; // Normalize.\n    \n}\n*/\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Path 1.\n    //return vec2(sin(z*.05)*cos(z*.1)*2.5, sin(z*.06)*2.); // Path 2.\n    return vec2(sin(z*.1)*2.5, cos(z*.12)*.5); // Path 3.\n}\n\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the object. Obviously, more layers would be more convincing. \n// However, this is a GPU-draining distance function, so any finer details should be bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    return cellTile(p/8.);//*.8 + dot(tri(p*0.384*2. + tri(p.yzx*0.192*2.)), vec3(0.666))*.2;\n     \n    // More interesting formations, and still quick, but not fast enough for this example.\n    //return cellTile(p/10.)*.75 + cellTile(p/10.*3.)*.25; \n \n    // Very cheap triangle noise. Looks OK, all things considering.\n    //p /= 4.;\n\t//float n = dot(tri(p*0.5 + tri(p.yzx*0.25)), vec3(0.666));\n    //return n*.75 + dot(tri(p*0.75 + tri(p.yzx*0.375)), vec3(0.666))*.25;\n\n}\n\n// Perturbing the sea floor. Just a very basic sinusoidal combination.\nfloat surfFunc2(in vec3 p){\n\n    \n\treturn dot(sin(p + sin(p.yzx*2. - vec3(0, 0, iTime*2.).yzx)), vec3(.1666)) + .5;\n \n\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n \n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n \n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); //p *= p*p*(p*(p*6. - 15.) + 10.);    \n    \n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n\n}\n\n// Producing some kind of prism shape.\nfloat doShape2(vec2 p){\n   \n    p = abs(p);\n    return max(p.x*.866025 + p.y*.5, p.y);\n    //return max((p.x + p.y)*.7, max(p.x, p.y));\n    \n}\n\n// To rotated hexagonal shapes combined together to produce a dodecahedron.\nfloat doShape(vec2 p){\n    \n    return max(doShape2(p), doShape2(p*r2(3.14159/6.)));\n    \n}\n\n\n// The scene. Hacked together in a hurry on the fly. A lot of it is pretty standard.\nfloat map(vec3 p){\n    \n   \n\n    // The noise layers.\n    float trSf = n2D(p.xz/12.);//terrain(p.xz);//triTerrain(p.xz);//\n    \n    float sf = surfFunc(p); // Surface perturbation.\n    \n \n    vec2 pth = path(p.z); // Wrap the gorge around the path.\n   \n    // Very basic water perturbation. The water follows the path, so the function is called after the\n    // path perturbation. It's also called here for reuse purposes.\n    float sf2 = surfFunc2(p); \n    \n   \n\n    \n    \n    p.xy -= pth;\n    \n    \n    float bas=1e4, bal=1e4, flame=1e4;\n  \n    if(balHit>0.){\n        \n        vec3 q = p;\n\n\n        vec3 bPos = q - balPos;//vec3(-6, 12, 40. + iTime*camSpeed);\n        bPos.z -= iTime*camSpeed;\n\n        bPos.xy *= r2(pth.x/64. + sin(iTime/4.)*.1);//r2(sin(iTime/8.)*.3);\n\n        // BALLOON\n        // Constructed with a series of conic dodecahedral prism-like objects.\n        bal = max(doShape(bPos.xz) - mix(.8, 2.9, (bPos.y + 1.8)/3.6), abs(bPos.y) - 1.8);\n\n        bPos.y -= 2.8;\n        float b2 = max(doShape(bPos.xz) - mix(2.9, 3., (bPos.y + 1.)/2.), abs(bPos.y) - 1.);\n        // Calculating the balloon frame ring - that holds the ropes.\n        float balRings = max(b2 - .1, -(-(bPos.y) - .8));\n        bal = min(bal, b2);\n\n        bPos.y -= 2.;\n        b2 = max(doShape(bPos.xz) - mix(3., 2., (bPos.y + 1.)/2.), abs(bPos.y) - 1.);\n        bal = min(bal, b2);\n\n\n        bPos.y -= 1.5;\n        b2 = max(doShape(bPos.xz) - mix(2., 0., (bPos.y + .5)/1.), abs(bPos.y) - .5);\n        bal = min(bal, b2);\n\n\n\t\t// BASKET\n        bPos.y += 10.4;\n        q = abs(bPos);\n        float hx = doShape2(q.xz);\n        bas = max(hx - .8, q.y - .8);\n        bas = max(bas, -max(max(hx - .9, -(hx-.7)), q.y - .4)); // Adding the top and bottom rim.\n        bas = min(bas, max(hx - .25, abs(bPos.y -.5) - .8)); // Flame stand - No such thing, but were keeping it simple.\n\n        // FLAME\n        // A volumetric approach to the flame would look better, but this will do.\n        // Mild flickering - Dave's suggestion.\n        float flicker = smoothstep(.25, .55, sin(iTime*3. - sf2*4.)*.3 + .7);\n        bPos.y -= (1. + flicker);\n        bal = max(bal, -max(length(bPos.xz) - .6, bPos.y - 4.)); // Bore out the ballon where the flame enters.\n        flame = length(bPos*vec3(1, .5, 1)) - (.35 + sf2*.1)*flicker; \n        bPos.y += (1. + flicker);   \n\n\t\t// The ropes that hold the basket. Basic repeat polar stuff.\n        bPos.y -= 3.2;\n        float ropes = max(doShape(bPos.xz) - mix(.8, 2.9, (bPos.y + 2.6)/5.2), abs(bPos.y) - 2.6);\n        bPos.xz += sin(bPos.xz*2. + cos(bPos.zx*2. + iTime))*.1;\n        float a = atan(bPos.z, bPos.x)/6.2831853; a = (floor(a*12.) + .5)/12.*6.2831853;\n        bPos.xz = bPos.xz*r2(a);\n        float bx = abs(bPos.z)-.5/12.;\n\n        ropes = max(max(ropes, bx), -(ropes+.1));\n\n        // Combining the basket frame, ropes and the basket itself.\n        bas = min(min(bas, ropes), balRings);\n        \n    }\n \n     \n    // Water. Just a plane with a little bit of sinusoidal perturbation. Nothing fancy.\n    float water = p.y + 4.2 + (sf2 - .5)*.4;\n    water += (.5 - sf)*.4;\n\n    // Used to carve out the channel.\n    vec2 ca = abs(p.xy*vec2(1, 1) - vec2(0, 1)); // Stretch and lower space.\n    \n    // The terrain. A flat plane with a base smooth noise layer. Some cellular noise is added to \n    // the base layer to make it look rocky.\n    float terrain = p.y + 1. + (.5 - trSf)*10.;\n    terrain = smax(5. - length(ca) + (.5 - sf)*1., terrain + (.5 - sf)*1., 4.) + (.5 - sf);\n    \n    // Finer cellular noise to provide the greenish abstract vegetation.\n    float sf3 = cellTile2(p + .5, 2.);\n   \n    \n    terrain = smax(terrain, -max(ca.x - 1., ca.y - 6.), 2.);\n    \n    // Vegetation.\n    float veg = terrain - .1 + terrain/4. + sf/4. - sf3*.2;\n    \n    \n    \n \n    \n    // Determine the overall closest object and its corresponding object ID. There's a way\n    // to save some cycles and take the object-ID calculations out of the distance function, \n    // but I'm leaving them here for simplicity.\n    vec2 d = objMin(vec2(water, WAT), vec2(terrain, TER));\n    d = objMin(d, vec2(bas, BAS));\n    d = objMin(d, vec2(bal, BAL));\n    d = objMin(d, vec2(veg, VEG));\n    d = objMin(d, vec2(flame, FLA));\n    \n    objID = d.y; // Set the global object ID.\n    ///////////////\n    \n\t// Return the minimum hit point. \n    return d.x*.9; // Shortening the ray step a fraction to alleviate any minor overstepping.\n \n}\n\n \n/*\n\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n\n\n    float c; //if(svObjID>.5 ) \n    c = 1. - surfFunc(p*3.); // cellTile(p/8.*3.);\n \n    return c; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(8./iResolution.y, 0); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x*2.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n*/\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<128; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n// Refective raymarching routine - More relaxed epsilon distance, and fewer iterations.\nfloat traceRef(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.25 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Intersection of a sphere. IQ's formula - trimmed down a little.\nfloat traceSphere( in vec3 ro, in vec3 rd, in vec4 sph ){\n\n\tro -= sph.xyz;\n\tfloat b = dot(ro, rd);\n\tfloat h = b*b - dot(ro, ro) + sph.w*sph.w;\n    return h<0. ? -1. : -b - sqrt( h );\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 48; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .02, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .15, 1.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(ef/iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n\n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return smoothstep(.15, .5, tx); \n    \n}\n*/\n \n\n/*\n// vec3 to float hash.\nfloat hash21( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\nfloat hash( float n ){ return fract(sin(n)*45758.5453); }\n\n// IQ's value noise, with analytical derivatives.\nvec4 n3D2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash(n+0.0);\n    float b = hash(n+1.0);\n    float c = hash(n+317.0);\n    float d = hash(n+318.0);\n    float e = hash(n+157.0);\n\tfloat f = hash(n+158.0);\n    float g = hash(n+474.0);\n    float h = hash(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n// Distance function.\nvec4 fmap2(vec3 p){\n\n    // Three layers of noise. More would be nicer.\n    p *= vec3(1, 4, 1)/400.;\n    \n    return n3D2(p)*0.57 + n3D2(p*4.)*0.28 + n3D2(p*8.)*0.15;\n}\n\n*/\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Distance function.\nfloat fmap(vec3 p){\n\n    // Three layers of noise. More would be nicer.\n    p *= vec3(1, 4, 1)/400.;\n    \n    return n3D(p)*0.57 + n3D(p*4.)*0.28 + n3D(p*8.)*0.15;\n}\n\n\n\n// Used in one of my volumetric examples. With only four layers, it's kind of going to waste\n// here. I might replace it with something more streamlined later.\nvec4 cloudLayers(vec3 ro, vec3 rd, vec3 lp, float far){\n    \n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*0.004-0.002)); \n    // Randomizing the length also. \n    rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.04-0.02); \n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    //vec3 rnd = hash33(rd+311.);\n\n    // Local density, total density, and weighting factor.\n    float ld=0., td=0., w=0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d=1., t=0.;\n    \n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n    \n    \n    vec4 d4 = vec4(1, 0, 0, 0);\n    \n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n    //vec4 ns4;\n\n    // Raymarching loop.\n    for (int i=0; i<4; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if(td>1. || t>far)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        // Noise with analytical derivatives. More expensive and didn't add enough to the scene,\n        // so they didn't make the cut. Diminishing returns, and all that.       \n        //ns4 = fmap(sp);\n        //sn = -normalize(ns4.yzw);\n        //d = ns4.x*.8 + .4;//fmap(sp); // Closest distance to the surface... particle.\n        d = fmap(sp); // Closest distance to the surface... particle.\n        \n        //d = d4.x;\n        //sn = normalize(d4.yzw);\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        ld = (h - d) * step(d, h); \n        w = (1. - td) * ld;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        //td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        td += w*.5 + 1./65.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 100./(1. + lDist*0.005 + lDist*lDist*0.00005);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n        \n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        //col += w*(1. + diff*.5 + spec*.5)*atten;\n \n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        col += w*(diff*diff + vec3(1, .75, .5)*spec + .5)*atten;//*1.25;\n        \n        // Optional extra: Color-based jittering. Roughens up the grey clouds that hit the camera lens.\n        //col += (fract(rnd*289. + t*41.)-.5)*0.02;;\n\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t += max(d4.x*.5, 0.25)*100.; //* 0.75\n        // t += 0.2; // t += d*0.5;// These also work, but don't seem as efficient.\n\n    }\n    \n    //t = min(t, FAR); //24.\n    \n    return vec4(col, t);\n        \n}\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp, float t){\n    \n\t// Sun strength.\n    float sun = max(dot(rd, normalize(lp - ro)), 0.0); \n    \n    // The blueish sky color. Tinging the sky redish around the sun. \t\n    vec3 col =  mix(vec3(.25, .6, .8), vec3(.8, .8, .6), 1.5*pow(sun, 8.))*(1.-.75*rd.y);\n    \n     \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n    col += 0.1*vec3(.7, .3, .9)*pow(sun, .5);\n    col += 0.4*vec3(1., .4, .2)*pow(sun, 1.);\n    col += 0.5*vec3(1.)*pow(sun, 512.);\n    \n    // Mixing this up to give the sky a bit more contrast and color. Not realistic, obviously.\n    col = mix(col*.7, col*col*1.25, .5);\n    col = mix(col.zyx, col, sun*.25+.75);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*.04 - .02, 0., 1.);\n    \n \n    //return col; // Clear sky day. Much easier. :)\n    \n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n \n    // If we haven't hit anything and are above the horizon point (there for completeness), render the sky.\n    \n    // Raytrace to a plane above the scene.\n    float tt = (1000. - ro.y)/(rd.y + .2);\n \n    if(t>=FAR && tt>0.){\n\n        // Trace out a very small number of layers. In fact, there are so few layer that the following\n        // is almost pointless, but I've left it in.\n        vec4 cl = cloudLayers(ro + rd*tt, rd, lp, FAR*3.);\n        vec3 clouds = cl.xyz;\n\n        // Mix in the clouds.\n        col = mix( col, col*.5 + .75, clouds); // *clamp(rd.y*4. + .0, 0., 1.)\n    }\n    \n    return col;\n\n}\n\n\n\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n    // Scene object coloring.\n    vec3 tx;\n\n    if(svObjID==TER) { // Terrain.\n        \n        tx = tex3D(iChannel0, p/8., n );\n        tx = smoothstep(-.1, .5, tx);\n\t\ttx *= vec3(1, .85, .7);\n        \n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - in addition to the shadows and AO. \n        tx *= smoothstep(.1, .6, surfFunc(p))*.6 + .4;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else if(svObjID==WAT) { // Water.\n        \n        //tx = tex3D(iChannel0, p/4., n );\n        //tx = smoothstep(-.1, .5, tx);\n        // To save calculations - and compilation time, the water will be purely\n        // reflective. This is just a dummy variable of sorts.\n        tx = vec3(1);\n    }\n    else if(svObjID==BAL) { // The ballon.\n        \n        // Matching the balloon's movement (in the distance function) to match \n        // texturing and coloring.\n        vec2 pth = path(p.z);\n \n        vec3 bPos = p;\n        bPos.xy -= pth;\n        bPos -= balPos; //vec3(-6, 12, 40. + iTime*camSpeed);\n        bPos.z -= iTime*camSpeed;\n     \tbPos.xy *= r2(pth.x/64. + sin(iTime/4.)*.1);\n        \n        tx = tex3D(iChannel0, bPos/4., n );\n        tx = smoothstep(-.1, .5, tx);\n       \n        // Polar modular calculations to give the red and white stripes.\n        float a = atan(bPos.z, bPos.x)/6.2831853*12.;\n        \n        if(mod(a + .5, 2.)<1. ) tx *= vec3(3, 1, .75); // Color every second one red.\n        else tx *= vec3(3, 2.5, 1.5); // Alternate ones white.\n        \n        \n    }\n    else if(svObjID==BAS) { // Basket.\n        tx = tex3D(iChannel0, p/4., n );\n        tx = smoothstep(-.1, .5, tx);\n        tx *= vec3(1.5, 1., .5); // Brownish timber color.\n    }\n    else if(svObjID==VEG) { // Vegetation.\n        \n        tx = tex3D(iChannel0, p/4., n );\n        tx = smoothstep(-.1, .5, tx);\n        tx *= vec3(.7, 1.2, .5); // Green.\n \n        \n    }\n    else if(svObjID==FLA) { // Flame.\n        tx = tex3D(iChannel0, p + iTime, n );\n        tx = smoothstep(-.1, .5, tx);\n        // Increase the flame intensity - since it's supposed to be hot, and stuff.\n        // A volometric approach to the flame would have been nice, but I'm trying\n        // to keep it simple.\n        tx *= vec3(8, 2, .8)*12.; // Ramp the color right up for the flame.\n        \n    }\n    \n    //tx *= bumpFunc(p.xyz, n);\n\n    \n    return tx;\n    \n}\n\n \n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t, float wf){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp, t);\n    \n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        float edge = 0., crv = 1.;\n        float ef = 16.;\n        if(svObjID==BAL) ef = 24.;\n        //if(svObjID==CLO) ef = 64.;\n        //if(svObjID==WAT) ef = 128.;\n        vec3 sn = getNormal(sp, edge, crv, ef);\n\n\n        float bf = .5;\n        if(svObjID<.5) bf = .01;\n\n        float edge2 = 0., crv2 = 1.; \n        //if(svObjID>.5)\n        //sn = doBumpMap(sp, sn, bf/(1. + t/FAR*.125), edge2, crv2); \n\n        bf = .07;\n        if(svObjID<.5) bf = .04;\n        //sn = doBumpMap(iChannel0, sp, sn, bf);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        /*\n        balHit = 1.;\n        float ao = calcAO(sp, sn);\n        ////////\n        // Flagging pixels over the balloon that don't need shadow calculations... Such a hassle,\n        // but it saves a lot of shadow calculations.\n        // Positioning the invisible collision sphere over the balloon. Used to flag pixels that\n        // contain the balloon, so that the expensive balloon rendering calculations are only\n        // performed on those pixels. See the distance function.\n        vec2 pth = path(sp.z);\n        vec3 bPos = vec3(0, 4, iTime*camSpeed);\n        bPos.xy *= r2(pth.x/64. + sin(iTime/4.)*.1);//r2(sin(iTime/8.)*.3);\n        bPos.xy -= pth;   \n        bPos += balPos; //vec3(-6, 12.-3., 40.);\n        bPos.y -= 3.;\n        balHit = traceSphere(sp + sn*.002, normalize(lp - (sp + sn*.002)), vec4(bPos, 8.)); // Balloon pixel flag.\n        ////////\n        //\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        sh = (sh + ao*.3)*ao;\n        balHit = 1.;\n        */\n        \n        float ao = calcAO(sp, sn);\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        sh = (sh + ao*.3)*ao;\n        \n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 2./(1. + lDist*0.01 + lDist*lDist*0.00008);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n        \n        // Changing materials, if the water's hit. Not used.\n        //if(wf<1.) { diff *= .5; spec *= .5; }\n        \n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec*1.);\n        \n         \n        // Edges.\n        //sceneCol *= 1. - edge2*.6; // Bump mapped edging for the terrain only.     \n        \n        sceneCol *= 1. - edge*.7; // Geometry based edging.\n        \n        // Reflection. Not really suitable for this example.\n        //sceneCol += eMap(reflect(rd, sn), sn);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n        \n        \n    \n    }\n    \n        // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0.75, .99, t/FAR); // t/FAR; \n \n\n    //if(wf<1.) sky = mix(sky, sky*sky, .5);\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    sceneCol = mix(sceneCol, sky,  fog); // exp(-.002*t*t), etc. fog.zxy \n\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n    vec3 offsCam = vec3(0, 6, 10)*0.;\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 4, iTime*camSpeed) + offsCam; // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(10, FAR*.26, FAR*.52)*2.;\n    \n    // Used for the balloon positioning. \n    vec2 pth = path(ro.z);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += pth;//path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/32.);\n    \n    // The scene wasn't really designed with mouse movement in mind, but it's\n    // here if desired.\n    #ifdef MOUSE_LOOK\n    // Mouse controls. A bit hacky, but I'll fix them.    \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n    #endif\n\n    \n    // Positioning the invisible collision sphere over the balloon. Used to flag pixels that\n    // contain the balloon, so that the expensive balloon rendering calculations are only\n    // performed on those pixels. See the distance function.\n    vec3 bPos = vec3(0, 4, iTime*camSpeed);\n    bPos.xy *= r2(pth.x/64. + sin(iTime/4.)*.1);//r2(sin(iTime/8.)*.3);\n\tbPos.xy -= pth;   \n    bPos += balPos; //vec3(-6, 12.-3., 40.);\n    bPos.y -= 3.;\n    balHit = traceSphere(ro, rd, vec4(bPos, 8.)); // Balloon pixel flag.\n    \n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    \n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    // Water factor. Used in this way to avoid calling \"doColor\" twice. The compiler would\n    // rather not do that.\n    float wf = 1.;\n    // Saving the background. The fog needs to be applied twice to the water. Once for the \n    // reflective color, and again for the overall scene.\n    vec4 fpBg; // First pass background... I named it in a hurry. :)\n    float fpSh; // Save the first pass shadow.\n    \n    // An overly simplistic water reflection pass. Basically, the water is given full reflection\n    // to avoid to many calculations. Ideally, you'd combine a tiny bit of the first pass color\n    // with a Fresnel combination of reflective and refractive passes, but the compiler has a \n    // fit (ever since WebGL 2, it seems), so just this. :)\n    if(svObjID==WAT && t<FAR){\n        // Save the sky color and fog factor, as viewed from the camera.\n        fpBg.xyz = getSky(ro, rd, lp, t);\n        fpBg.w = smoothstep(0.75, .99, t/FAR); // t/FAR; \n        \n        ro += rd*t;\n        vec3 n = getNormal(ro);\n        \n////    \n        // Fist pass shadow over the water. It's barely noticeable, so it was tempting to skip\n        // it, but I couldn't bring myself to have shadowless water. :)\n        balHit = 1.;  \n        //float ao = calcAO(ro, n);\n        fpSh = softShadow(ro + n*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        //fpSh = (fpSh + ao*.3)*ao;        \n///         \n        \n        rd = reflect(rd, n);\n        t = traceRef(ro + rd*.001*(t*.125 + 1.), rd);\n        svObjID = objID; // Save the reflected object ID.\n        wf = .8;\n    }\n    \n    \n    // Retrieving the color at the initial hit point.\n    // Soft shadows create problems with the flagging feature, so all pixels will be\n    // checked.\n    balHit = 1.; \n    vec3 sceneColor = doColor(ro, rd, lp, t, wf);\n \n    // Toning down the water color and applying camera fog... as opposed to the reflective fog.   \n    if(wf<.999){\n        sceneColor *= fpSh;\n        sceneColor *= wf; // Tone down the reflective water color a bit.\n        sceneColor = mix(sceneColor, fpBg.xyz,  fpBg.w);\n    }\n    \n\t// Debugger to see the region of pixels covered by the sphere that contain the balloon.\n    //if(balHit>0.) sceneColor *= 1.2;\n    \n    // POSTPROCESSING\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);//*.75 + .25;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                   //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125));\n    \n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    //uv = sin(uv*r2(3.14159/6.)*3.14159*iResolution.y/1.5)*.1 + 1.;\n    //sceneColor *= uv.x*uv.y;\n    \n    // Mild LCD overlay.\n    //vec2 rg = mix(mod(fragCoord, vec2(2))*sceneColor.xy, sceneColor.xy, .65);\n    //sceneColor = vec3(rg, sceneColor.z - mix(sceneColor.x - rg.x, sceneColor.y - rg.y, .65));\n    \n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2BWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2BWw", "name": "Pinwheel Snake", "author": "ttoinou", "description": "A snake walks through a pinwheel triangle", "tags": ["pinwheel"], "likes": 2, "viewed": 85, "date": "1500675245", "time_retrieved": "2024-06-20T18:58:31.738748", "image_code": "#define SHOW_SEGMENTS 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,(( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\n// pointA and pointB are on the same side of the half plane delimited by line (lineA,lineB)\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n} \n\nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n};\n   \nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int nbIterations = iMouse.z > .5 ? 5 : 4;\n    \n    vec2 base = vec2(2.0,1.0);\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1./1.;\n    uv *= viewportMagnify;\n    \n    //uv *= mat2(cos(iTime/48.+vec4(0.,1.6,-1.6,0.)));\n    \n    uv += base/2.3;\n    \n    // Base Triangle\n    Pinwheel Tri;\n    Pinwheel Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    \n    fragColor = vec4(1.);\n    vec3 coeffs = barycentricCoordinate(uv,Tri);\n    float e = -1e-2;\n    if( coeffs.x < e || coeffs.y < e || coeffs.z < e ) return;\n    \n    int PinwheelID = 0;\n    \n    int Mode = int(floor(mod(iTime/1.5,8.)));\n      \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        PinwheelID *= 5;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                PinwheelID += 1;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                PinwheelID += 2;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                PinwheelID += 3;\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            PinwheelID += 4;\n        }\n        \n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    //fragColor.rgb = hash3point(EQUERRE_CENTER(Tri));\n    float k = float(PinwheelID)/pow(5.,float(nbIterations));\n    k = ( \n            k - mod(iTime*.05,1.)\n        )/.2/(iMouse.z > .5 ? .2 : 1.);\n    fragColor.rgb -= step( abs(k) , 1. ) * (cos(k*vec3(7.,5.,3.)*3.)*.5+.5)*(1. - k*k);\n    \n    // interesting variation\n    // but needs tuning in color \n    //fragColor = sqrt( cos(fragColor*3.14*vec4(1.,2.,3.,1.))*.5+.5 );\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale*16.;\n    \n    vec3 EquerreColor = vec3(.0);//1. - fragColor.rgb;\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n           \n    \n    fragColor.rgb = tanh(fragColor.rgb*6.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2BWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2fDm", "name": "Perpetual Pipe Dream", "author": "KilledByAPixel", "description": "Flying through a slowly changing fractal of interconnected pipes.", "tags": ["2d", "fractal", "zoom", "pixel", "endless", "recursion"], "likes": 5, "viewed": 488, "date": "1500780979", "time_retrieved": "2024-06-20T18:58:33.484331", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Perpetual Pipe Dream - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.3;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 6;\t// how deep to recurse\nconst float recursionFadeDepth\t= 3.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 16;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.0;\t// how much to center the glyph in each pixel\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// glyph sheet - pipes corospond to neighbor connection bits\n/* 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x05760, 0x05776, 0x57760, 0x57776, 0x05760, 0x05776, 0x57760, 0x57776,\n 0x05760, 0x00576, 0x57600, 0x57776, 0x00000, 0x00576, 0x57600, 0x57776, 0x0DFE0, 0x0DFFE, 0xDFFE0, 0xDFFFE, 0x0DFE0, 0x0DFFE, 0xDFFE0, 0xDFFFE,\n 0x0DFE0, 0x00DFE, 0xDFE00, 0xDFFFE, 0x05760, 0x05FFE, 0xDFF60, 0xDFFFE, 0x09BA0, 0x09FFE, 0xDFFA0, 0xDFFFE, 0x0DFE0, 0x0DFFE, 0xDFFE0, 0xDFFFE,\n 0x09BA0, 0x009BA, 0x9BA00, 0x9BBBA, 0x0DFE0, 0x0DFFE, 0xDFFE0, 0xDFFFE, 0x00000, 0x009BA, 0x9BA00, 0x9BBBA, 0x0DFE0, 0x0DFFE, 0xDFFE0, 0xDFFFE,\n 0x00000, 0x00000, 0x00000, 0x00000, 0x09BA0, 0x09BBA, 0x9BBA0, 0x9BBBA, 0x00000, 0x00000, 0x00000, 0x00000, 0x09BA0, 0x09BBA, 0x9BBA0, 0x9BBBA\n */   \n \n 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF,\n 0x05760, 0x00577, 0x77600, 0x77777, 0x00000, 0x00577, 0x77600, 0x77777, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF,\n 0x0DFE0, 0x00DFF, 0xFFE00, 0xFFFFF, 0x05760, 0x05FFF, 0xFFF60, 0xFFFFF, 0x09BA0, 0x09FFF, 0xFFFA0, 0xFFFFF, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF,\n 0x09BA0, 0x009BB, 0xBBA00, 0xBBBBB, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF, 0x00000, 0x009BB, 0xBBA00, 0xBBBBB, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF,\n 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF, 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF\n    \n);// o       x-       -x               ,                             '                                                   \n//0000=0   0001=1   0010=2   0011=3   0100=4   0101=5   0110=6   0111=7   1000=8   1001=9   1010=A   1011=B   1100=C   1101=D   1110=E   1111=F\n//TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 8;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() \n{ \n    vec3 color = vec3(0,0.3,0.1);\n    color.x -= (0.033*iTime);\n    return color; \n}\n\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    float f = GetRecursionFade(r, timePercent);\n    if (f == 0.0)\n        return color;\n    \n    vec3 myColor = vec3\n    (\n    \tmix(-0.05, 0.05, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n    \tmix( 0.0, 0.3, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n        1.0\n    );\n\n    // combine with my color\n    color.x += myColor.x*f;\n    color.y = min( color.y + myColor.y*f, 1.0);\n    color.z = max(color.z, myColor.z*f);\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // rotate over time\n    float theta = 0.01177*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n    uv *= mat2(-s, c, c, s);\n    \n    // color wander\n    color.x += (0.1*uv.y + 0.1*uv.x + 0.02*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.005*sin(10.0*uv.y + 0.51*iTime);\n\tuv.y += 0.005*sin(10.0*uv.x + 0.53*iTime);\n\tuv.x += 0.05*sin(2.0*uv.y + 0.57*iTime);\n\tuv.y += 0.05*sin(2.0*uv.x + 0.55*iTime);\n    \n    // rotate over time\n    float theta = 0.01*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n    return uv;\n}\n\nfloat TimeWarp(vec2 uv)\n{\n    // time warp to add add some 3d curve\n    float c1 = 0.5*sin(0.3*iTime);\n    float c2 = 0.5*sin(0.23*iTime);\n    return (c1*length(uv) + c2*uv.x*uv.y)*zoomSpeed;\n    //return 1.0;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return min(1, 0xF & (glyphRow >> (glyphSize - 1 - pos.x) * 4));\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nint neighborsGrid[glyphSize*glyphSize];\nvoid GetNeighbors(int lastGlyph)\n{\n    for (int y = glyphCount*(glyphSize - 1), z = -1; y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[lastGlyph + y];\n        for (int x = 4*(glyphSize-1); x >= 0; x -= 4)\n            neighborsGrid[++z] = (0xF & (glyphRow >> x));\n    }\n    \n    // slower way of building neigbors if not precomputed\n    /*for (int y = 0; y < glyphSize; ++y)\n    for (int x = 0; x < glyphSize; ++x)\n    {\n        int neighbors = 0;\n        if (GetGlyphPixel(ivec2(x, y), lastGlyph) != 0)\n        {\n            neighbors |= GetGlyphPixel(ivec2(x+1, y), lastGlyph) << 0; // right\n            neighbors |= GetGlyphPixel(ivec2(x-1, y), lastGlyph) << 1; // left\n            neighbors |= GetGlyphPixel(ivec2(x, y-1), lastGlyph) << 2; // top\n            neighbors |= GetGlyphPixel(ivec2(x, y+1), lastGlyph) << 3; // bottom\n        }\n        \n        neighborsGrid[x + y*glyphSize] = neighbors;\n    }*/\n}\n\nivec2 CalculateFocusPos(int iterations)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n    \n  \t// current focus glyph must appear in correct location\n    int focusGlyph = GetFocusGlyph(iterations); \n    \n    // find all pixels that have the right neighbors (or more) for focus glyph\n    ivec2 validPlaces[glyphSize*glyphSize];\n    int c = 0;\n    \n    ivec2 pos;\n    for (int y = glyphCount*(glyphSize - 2), z = -1; y >= 1; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[glyphLast + y];\n        for (int x = 4*(glyphSize-2); x >= 1; x -= 4)\n        {\n            int neighbors = (0xF & (glyphRow >> x));\n            if (neighbors > 0 && ((neighbors & focusGlyph) == focusGlyph))\n                validPlaces[c++] = ivec2(glyphSize - 1 - x/4, glyphSize - 1 -y/glyphCount);\n        }\n    }\n\n    // pick one at random\n    return validPlaces[RandInt(iterations) % c];\n}\n\nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, bool isFocus, ivec2 focusPos)\n{ \n    GetNeighbors(glyphLast);\n\n    // randomly remove some links\n    int r = iterations + 17*glyphPosLast.x + 23*glyphPosLast.y;\n    // random change over time\n    r += 23*int(0.01*float((11*glyphPos.x + 7*glyphPos.y + 17*glyphPosLast.x + 13*glyphPosLast.y))+ float(glyphLast)/float(glyphCount) + 0.1*iTime);\n    \n   \tint removeCount = 15 + RandInt(++r) % 40;\n    for (int i = 0; i < removeCount; ++i)\n    {\n        int x = RandInt(++r) % (glyphSize);\n        int y = RandInt(++r) % (glyphSize);\n        \n        // remove a link\n        int neighbors = neighborsGrid[x + y*glyphSize];\n        int bit = 3*(RandInt(++r) % 2);\n        neighbors = neighbors & ~(1 << bit);\n        \n        // prevent orphans\n        if (neighbors == 0 && (RandInt(++r) % 5 < 4))\n            continue;\n        if (bit == 0)\n        {\n            if (x == glyphSize-1) continue;\n            int n = neighborsGrid[(x+1) + y*glyphSize] & ~(1 << 1);\n            if (n == 0) continue;\n            neighborsGrid[(x+1) + y*glyphSize] = n;\n        }\n         if (bit == 3)\n        {\n            if (y == glyphSize-1) continue;\n            int n = neighborsGrid[x + (y+1)*glyphSize] & ~(1 << 2);\n            if (n == 0) continue;\n            neighborsGrid[x + (y+1)*glyphSize] = n;\n        }\n        \n        neighborsGrid[x + y*glyphSize] = neighbors;\n    }\n    \n    if (isFocus)\n    {\n        // stamp down the focus glyph\n        int x = focusPos.x;\n        int y = focusPos.y*glyphSize;\n        int n = GetFocusGlyph(iterations);\n        neighborsGrid[x + y] = n; \n        \n        // fix up neighbors\n        neighborsGrid[(x-1) + y] = (0 == (n & (1 << 1)))? \n            neighborsGrid[(x-1) + y] & ~(1 << 0) : neighborsGrid[(x-1) + y] | (1 << 0);\n        neighborsGrid[(x+1) + y] = (0 == (n & (1 << 0)))?\n            neighborsGrid[(x+1) + y] & ~(1 << 1) : neighborsGrid[(x+1) + y] | (1 << 1);\n        neighborsGrid[x + y-glyphSize] = (0 == (n & (1 << 2)))?\n            neighborsGrid[x + y-glyphSize] & ~(1 << 3) : neighborsGrid[x + y-glyphSize] | (1 << 3);\n        neighborsGrid[x + y+glyphSize] = (0 == (n & (1 << 3)))?\n            neighborsGrid[x + y+glyphSize] & ~(1 << 2) : neighborsGrid[x + y+glyphSize] | (1 << 2);\n    }\n    \n    return neighborsGrid[glyphPos.x + glyphPos.y*glyphSize];\n}\n\n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, isFocus, focusPos);\n        isFocus = (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n    float timePercent = (10.0 + iTime)*zoomSpeed;\n    timePercent += TimeWarp(uv);\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);;\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2fDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2fRK", "name": "line segment withut division", "author": "ollj", "description": "mouse sets one vector.\n\nline segments without division inside the function, colinear segments are faster.\n\nmy approach to more symmetry is by substitution. buffer or delay slow functions as much as possible.", "tags": ["line", "complex", "smoothstep", "segment", "symmetry", "neon", "linesegment", "normalize", "disymmetry"], "likes": 4, "viewed": 673, "date": "1501176103", "time_retrieved": "2024-06-20T18:58:34.053924", "image_code": "/*\nhttps://www.shadertoy.com/view/4dBfzG\nmade me think about searching substitutions to utilize more symmetry in my line segment functions.\nI just love to find alternatives to dot()/dot():\n\nThis shader takes  normalize() out of length() and dot()/dot().\nIt makes m=normalize(m) the first step, which can easily be buffered outside the function.\n-> distance-to-line_segment/ray functions without any division and without atan()\n\nThis can be faster if you have many different colinear line segments and rays...\n...usually a straight hole is filled with something that is faiirly colinear to the hole\n...subway trains, pills on a conveyor, bulet in a gun.\nThis can be faster when working with already normalized vectors, like quaternions?\nThis can be faster for some complex numbers on a unit sphere?\n\nI am pretty sure this is also useful for polar, bipolar and spiral transformations.\nand any kind of transformed straight track.\n*/\n\n#define viewScale 4.\n\n#define frame(u) ((u-.5*iResolution.xy)*viewScale/iResolution.y)\n\n//return distance to line segment from vec2(0) to vec2(1,0)\nfloat lsNoDot(vec2 p){p.x-=.5;p=abs(p);return mix(length(p-vec2(.5,0)),p.y,step(p.x,.5));}\n\n//an alternative to the dotproduct line segment.\n\n//blurryness for anti aliasing\n#define blur 4.\n\n//pseudo-antialiasing, made dependant on screen resolution.\n#define crisp (blur/iResolution.y)\n\n\n\n\n//too bad this sucker has a division in it:\n//smoothstep also constains clamp() which has shown some inconsistencies for NaN\n#define ss(a) a=smoothstep(crisp,-crisp,a);\n//above is smoothstep, blow is smootheststep, which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss(a) (1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n//rotate counterclockwise by 90deg==make perpendicular\n#define perp(a) vec2(-a.y,a.x)\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat line(vec2 u,vec2 m){\n //return determinant(mat2(u,m));//determinant()==openGL_1.5, bad compatibility.\n return dot(m,perp(u));}//2d determinant==perpendicular dotproduct.\nfloat lineN(vec2 u,vec2 m){return line(u,normalize(m));}\n//https://www.shadertoy.com/view/4dBfzG\n//return unsigned distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat lsa(vec2 u,vec2 m){return abs(line(u,m));}\nfloat lsaN(vec2 u,vec2 m){return abs(line(u,normalize(m)));}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat ils(vec2 u,vec2 m){\n //return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\nfloat ilsN(vec2 u,vec2 m){return ils(u,normalize(m));}\n                         \n//return distance of [u] to line_segment from (0,0) to [m],m must be normalized!\n//this line segment has a length of 1.\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\nfloat ls1N(vec2 u,vec2 m){return ls1(u,normalize(m));}\n\n//return distance of [u] to line_segment from (0,0) to [m], n must be normalized\n//[m] must NOT be normalized!\nfloat ls(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless            \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lsN(vec2 u,vec2 m){return ls(u,normalize(m),m);}\n\n//return distance of [u] to line_segment from (0,0) to [n]*[a], n must be normalized\nfloat lss(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m); //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless            \n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless            \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lssN(vec2 u,vec2 n,float a){return lss(u,normalize(n),a);}\n\n\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=frame(U);\n vec2 m=frame(iMouse.xy);\n vec3 c=vec3(0);\n vec2 n=normalize(m);//we only normalize m once, and use that for 3 different lineX distances.\n //all divisions happen above this line, below this line is division-free zone.\n //length() happens, but is really not too important.\n c.r=lsa(u,n);\n c.b=ils(u,n);\n c.g=ls(u,n,m);\n //c.g=(1.-cos(clamp(u.x*acos(-1.),0.,1.*acos(-1.)))-u.y);\n //c.g=ls1(p,n);//line segment of length 1\n c-=sin(iTime)*.5+.5;  \n c=abs(c)-.25*(sin(iTime*.61)*.5+.5);\n c=sss(1.-c);//smoothstep does have 1 division. so we use \"smootheststep()\"\n //c*=.5;O=vec4(c+c.yzx,1);\n O=vec4(c.xyz,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2fRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2fWw", "name": "Equerre Infinite Spiral", "author": "ttoinou", "description": "Infinite Pythagorean Spiral made of Equerre triangles", "tags": ["zoom", "spiral", "infinite", "pythagoras", "equerre"], "likes": 3, "viewed": 131, "date": "1500690103", "time_retrieved": "2024-06-20T18:58:35.848001", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \n#define _AB_ (1)\n#define _BC_ (2)\n#define _CA_ (3)\n        \n#define _ALPHA_ _AB_\n#define _BETA_  _BC_\n#define _GAMMA_ _CA_\n        \n#define _REPLACE_(X,Y,Z,T) \\\n        if( Begin == X && End == Y && !operation ) { \\\n            Begin = Z; End = T; operation = true; \\\n        } else if( End == X && Begin == Y && !operation) { \\\n            End = Z; Begin = T; operation = true; \\\n        }\n\n#define _SWAP_(X,Y) _REPLACE_(X,Y,Y,X)\n\n#define _SWAP_KEEP_BETA_ \\\n\t_REPLACE_(_BETA_,_ALPHA_,_BETA_,_GAMMA_) \\\n\t_REPLACE_(_BETA_,_GAMMA_,_BETA_,_ALPHA_) \\\n\n#define _SWAP_KEEP_GAMMA_ \\\n\t_REPLACE_(_GAMMA_,_ALPHA_,_GAMMA_,_BETA_) \\\n\t_REPLACE_(_GAMMA_,_BETA_,_GAMMA_,_ALPHA_) \\\n\n        \n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\n// Base Triangle\nEquerre Tri;\n\nfloat k = 1. - sqrt(3.)*.5;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,-(n + logZoom)/2.) , (n)/3.*PI + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    // doesn't matter, infinite zoom :p\n    viewportMagnify = 1.; \n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.))) * exp(-iTime/8.);\n    uv *= viewportMagnify;\n    \n    \n    angleShift = iTime/2.;\n    logZoom = iTime/1.;\n    \n    float r = floor( -log(dot(uv,uv))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv) )\n    {\n        // inside circle\n        FindEquerre(r,uv);\n    }\n    \n    fragColor.rgb = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID)); \n\n    float scale = 1./viewportMagnify;\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb *= 3.*(.5 + coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n    \n    \n    fragColor.rgb = tanh(fragColor.rgb*1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2fWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2fz1", "name": "NoisePursuit_v1", "author": "Palliaci", "description": "I starderd playing with 3d noise and raymarching, then I discovered fractal brownian motion and got addicted...", "tags": ["raymarching", "fbm", "3dnoise", "blackbody"], "likes": 2, "viewed": 594, "date": "1500222842", "time_retrieved": "2024-06-20T18:58:37.478529", "image_code": "/**\n * Created by Palliaci\n * Inspired by revers shader : https://www.shadertoy.com/view/4ddXW4\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * I wanted to play around with 3d noise and the analytical normals from iq :\n * http://iquilezles.org/www/articles/morenoise/morenoise.htm\n *\n * The green thing is also a variation from iq's shader on raymarching primitives.\n */\nconst float FOV = 1.;\nconst float MarchDumping = .7579;\nconst float Far = 38.925;\nconst int MaxSteps = 128;\nconst float precis = .002;\nconst float CameraSpeed = 1.5099998;\nconst float TunnelSmoothFactor = 1.2;\nconst float TunnelRadius = 0.15660005;\nconst float TunnelFreqA = 0.318003;\nconst float TunnelFreqB = 0.25;\nconst float TunnelAmpA = 3.6230998;\nconst float TunnelAmpB = 2.4324;\nconst float NoiseIsoline = 0.119;\nconst float NoiseScale = 2.9980001;\n\n// Goes from 1 to 4\n#define COL1\n// Activates lightning, otherwise color depends only on the blackbody and COL define\n#define LIGHTS\n// If you want some \"fresh air\"\n#define OUT\n// Replace by the name of the fbm function to raymarch\n#define FBM fbm\n\nvec2\tuv;\nvec3\tnor;\nfloat\tt;\nfloat\tid_t;\nfloat\tst;\nfloat\tct;\n\n\nvec3\tcalcNormal( in vec3 pos );\nfloat\tiqhash(vec3 p);\nvec4\tnoised( in vec3 x );\nfloat\tcalculateAO(in vec3 p, in vec3 n);\nfloat\tsmax(float a, float b, float k);\nvec3 \tblackbody(float Temp);\nvec3\tcamera(vec2 uv, vec3 forw);\nmat3\trotX( float a );\nmat3\trotY( float a );\nmat3\trotZ(float a);\n\nfloat fbm(vec3 p) {\n\tvec4 res;\n\tres = 0.5000 * noised(p);\n\tp *= 2.01;\n\tres += 0.2500 * noised(p);//noise(p);\n\tp *= 2.02;\n\tres += 0.1250 * noised(p);//noise(p);\n    p *= 8.03;\n    p.x *= 2.0;\n\tres += 0.0150 * noised(p);//noise(p);\n\n    nor = res.yzw;\n\treturn res.x;\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.96, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.96, -0.48,\n                       0.60, -0.48,  0.64 );\nfloat fbm2(vec3 p)\n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    vec4 n;\n    for( int i=0; i < 3; i++ )\n    {\n\t\tn = noised(p);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        p = f*m3*p;\n        m = f*m3i*m;\n    }\n    nor = d;\n    return a;\n}\n\n// From \"Subterranean Fly-Through\" by Shane https://www.shadertoy.com/view/XlXXWj\nvec2 path(float z) {\n\treturn vec2(TunnelAmpA * sin(z * TunnelFreqA), TunnelAmpB * cos(z * TunnelFreqB));\n}\n\nfloat noiseDist(vec3 p) {\n\tp = p / NoiseScale;\n\treturn (FBM(p) - NoiseIsoline) * NoiseScale;\n}\n\nfloat map(vec3 p) {\n\tfloat d = noiseDist(p);\n    p.xy -= path(p.z);\n\tfloat d2 = length(p.xy) - TunnelRadius;\n    \n\td = smax(/*.25*st*/d, -d2, TunnelSmoothFactor);\n#ifdef OUT\n    vec3 pnor = vec3(0., 1., 0.);\n    d = smax(d, dot(p, pnor) - 1.2, 2.);\n#endif\n    \n    p.z -= t + .5;\n    id_t = d;\n    //d = min(d, length(p) - .1);\n    d = min(d, (length(p)-.1)+ st*0.03 * cos( 50.0 * p.x ) * sin( 50.0 * p.y)\n                             * sin(50.0 * p.z));\n    id_t = (id_t != d)? 1. : 0. ;\n\treturn d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat t = tmin;\n    float d;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\td = map(ro + rd * t);\n\t\tif (d < precis || t > Far) {\n\t\t\tbreak;\n\t\t}\n\t\tt += d * MarchDumping;\n\t}\n\treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n//    if (!(uv.x > .5 && uv.y > .25 && uv.x < 1.25 && uv.y < .75))\n//       discard;\n    st = sin(iTime);\n    ct = cos(iTime);\n    \n    t = iTime * CameraSpeed * (1.+.001*st) + 4.0 * 60.0;\n//    t = iTime * CameraSpeed + 4.0 * 60.0;\n    vec3 ro = vec3(path(t), t);\n    t += 0.5;\n    vec3 target = vec3(path(t), t);\n    vec3 rd = camera(uv, normalize(target - ro));\n\n    float d = march(ro, rd);\n    vec3 col;\n\t\n    vec3\tv = ro + d * rd;\n\n    if ( d <= Far )\n\t{\n        if (id_t == 1.)\n        {\n\t        col =   1. - blackbody(d*3000.).yzx;\n        \tnor =\tcalcNormal(v);\n        }\n        else\n#ifdef COL1\n            col =\tblackbody(d*300.+100.)* (.5+.5*texture(iChannel0, v.xy * .1).xyz);\n#endif\n#ifdef COL2\n    \t\tcol =\tblackbody(((d)*200.*(1.+.5*ct)+300.));\n#endif\n#ifdef COL3\n    \t\tcol =\tblackbody(((d)*200.*(1.+.5*ct)+300.)).xzy;\n#endif\n#ifdef COL4\n    \t\tcol =\t1.-blackbody((d)*3000.);\n#endif\n#ifdef LIGHTS\n        vec3\tev = normalize( v - ro );\n\t\tvec3\tref_ev = reflect( ev, nor );\n        t =\t\t(iTime + 2.) * CameraSpeed + 4.0 * 60.0;\n        vec3\tlight_pos   = vec3(path(t+.2), t+.2);\n\n        vec3\tvl = normalize( light_pos - v );\n\t\tfloat\tdiffuse  = max( 0.001, dot( vl, nor ) );\n\t\tfloat\tspecular = pow( max( 0.001, dot( vl, ref_ev ) ), 1. );\n        float\tao = calculateAO(v, nor);\n        float\tbrdf = (diffuse + specular + ao );// * .25 + .75;\n        col =\tcol * brdf;\n#endif\n    }\n\telse\n        col = vec3(uv, 0.);\n//    col = pow(col, vec3(.4545));\n    fragColor = vec4(col, 1.0);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat iqhash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = iqhash(p+vec3(0.0,0.0,0.0));\n    float b = iqhash(p+vec3(1.0,0.0,0.0));\n    float c = iqhash(p+vec3(0.0,1.0,0.0));\n    float d = iqhash(p+vec3(1.0,1.0,0.0));\n    float e = iqhash(p+vec3(0.0,0.0,1.0));\n\tfloat f = iqhash(p+vec3(1.0,0.0,1.0));\n    float g = iqhash(p+vec3(0.0,1.0,1.0));\n    float h = iqhash(p+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y +\n                 k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z,\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ));\n}\n\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n// by iq. http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nmat3\trotX( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( 1, 0, 0, 0, c, -s, 0, s, c );\n}\nmat3\trotY( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n}\nmat3\trotZ(float a) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat3( c, s, 0, -s, c, 0, 0, 0, 1.0 );\n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvec3\tcamera(vec2 uv, vec3 forw) {\n\tvec3    right = vec3( 1.0, 0.0, 0.0) ;\n\tvec3    up    = vec3( 0.0, 1.0, 0.0) ;\n\n    return ( normalize( ( uv.x - 1. ) * right\n                        + ( uv.y - 0.5 ) * up\n                        + FOV * forw ) );\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2fz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBDz", "name": "[SH17A] Hyperspace", "author": "public_int_i", "description": "hyperspace", "tags": ["hyperspace", "sh17a"], "likes": 27, "viewed": 1028, "date": "1500136346", "time_retrieved": "2024-06-20T18:58:37.478529", "image_code": "//Ethan Alexander Shulman 2017\n\n///*with x64 MSAA - 256 chars\nvoid mainImage( out vec4 o, vec2 p )\n{\n    o -= o;\n    for (int s = 0; s < 64; s++) {\n        vec2 R = iResolution.xy,\n        u = (p*2.-R+vec2(s%8,s/8)/4.-2.)/R.x;\n        u = floor((6.-vec2(atan(u.y,u.x)/3.,length(u)))*R)+.5;\n\n        o += max(1.-fract(vec4(7,6,4,0)*.02+(u.y*.02+u.x*.4)*fract(u.x*.61)+iTime)*5., 0.)/64.;\n    }\n}\n//*/\n\n/*no MSAA - 193 chars\nvoid mainImage( out vec4 o, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    u = (u*2.-R)/R.x;\n    u = floor(6.-vec2(atan(u.y,u.x)/3.,length(u))*R)+.5;\n \t\n    o = 1.-fract(vec4(7,6,4,0)*.02+(u.y*.02+u.x*.4)*fract(u.x*.61)+iTime)*5.;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBRG", "name": "ray march + lighting + camera", "author": "rjoudrey", "description": ".", "tags": ["raymarch"], "likes": 0, "viewed": 83, "date": "1500783312", "time_retrieved": "2024-06-20T18:58:37.478529", "image_code": "const float EPSILON = 0.0001;\n\nfloat opRep( vec3 p)\n{\n    vec3 c = 5.0 * vec3(1.0, 1.0, 1.0);\n    vec3 q = mod(p,c)-0.5*c;\n\t// distance to sphere surface\n    return length(q) - 1.0;\n}\n\nfloat sdf(vec3 p) \n{\n\treturn opRep(p);\n}\n\nbool rayMarch(vec3 start, vec3 direction, inout vec3 intersection)\n{ \t\n    vec3 current = start;\n    for (int i = 0; i < 64; ++i) \n    {\n        float d = sdf(current);\n        if (d <= EPSILON)\n        {\n\t\t\tintersection = current;\n            return true;\n        }\n        current += direction * d;\n    }\n    return false;\n}\n\nvec3 normal(vec3 p)    \n{\n    return normalize(\n        vec3(\n        \tsdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n\t        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n\t        sdf(vec3(p.x, p.y, p.z + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 a = fragCoord.xy / iResolution.xy;\n    // (0...1, 0...1) -> (-1...1, -1...1)\n    vec2 b = a * 2.0 - 1.0;\n    // change aspect ratio from 1:1 to x:y\n\tfloat ratio = iResolution.x / iResolution.y;\n    vec2 c = vec2(b.x * ratio, b.y);\n    float rayDistance = -10.0 * iTime;\n    vec3 rayOrigin = vec3(0.0, 0.0, -rayDistance);\n    vec3 rayDirection = normalize(vec3(c, -rayDistance + 2.0) - rayOrigin);\n    vec3 intersection;\n    float col = 0.0;\n    if (rayMarch(rayOrigin, rayDirection, intersection))\n    {\n        vec3 n = normal(intersection);\n        vec3 l = vec3(0.0, 0.0, -1.0);\n        col = dot(n, l) * .9 + .1;\n    }\n\tfragColor = vec4(col, col, col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBRh", "name": "Voronoi Towers", "author": "dr2", "description": "Architecture based on smoothed hexagonal-lattice-based Voronoi partitioning; mouse enabled.", "tags": ["raymarching", "voronoi", "lighting", "hexagon", "building"], "likes": 6, "viewed": 687, "date": "1499281509", "time_retrieved": "2024-06-20T18:58:39.060961", "image_code": "// \"Voronoi Towers\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Architecture based on smoothed hexagonal-lattice-based Voronoi partitioning\n (a bit like TekF's \"Infinite City\" but different); mouse enabled.\n*/\n\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 trkF, trkA, flPos, sunDir;\nvec2 gVec[7], hVec[7];\nfloat tCur, dstFar, dstObj, hBase;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.05) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 vc;\n  float h;\n  vc = HexVor (0.3 * p.xz);\n  h = 0.5 * floor (16. * vc.w) + 0.25 + 0.06 * dstObj *\n     smoothstep (0.6 * dstFar, dstFar, dstObj);\n  return min (0.25 * SmoothMax (0.75 - vc.x, p.y - h, 0.03), p.y + hBase);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  if (rd.y < 0.) {\n    dHit = - (ro.y - 9.) / rd.y;\n    for (int j = 0; j < 250; j ++) {\n      dstObj = dHit;\n      d = ObjDf (ro + dHit * rd);\n      dHit += d;\n      if (d < 0.001 || dHit > dstFar) break;\n    }\n  } else dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 16; j ++) {\n    dstObj = 0.;\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.5;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (50. - ro.y) / (rd.y + 0.0001) + ro.xz));\n  col = vec3 (0.1, 0.3, 0.5) + 0.3 * pow (1. - max (rd.y, 0.), 4.);\n  col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.));\n  return mix (col, vec3 (0.9), clamp (0.5 * (f - 0.1) * rd.y + 0.3, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, vn;\n  float sh, c, hw, dFade;\n  HexVorInit ();\n  dstObj = ObjRay (ro, rd);\n  dFade = dstObj / dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vc = HexVor (0.3 * ro.xz);\n    vn = ObjNf (ro);\n    hw = mod (2. * ro.y + 0.5, 1.) - 0.5;\n    if (abs (hw) < 0.18 && vn.y < 0.9) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n    else {\n      c = 0.1 * floor (73. * mod (vc.w, 1.) + 0.5);\n      col = HsvToRgb (vec3 (0.1 + 0.8 * c, 0.3 + 0.5 * mod (25. * c, 1.), 1.));\n      if (ro.y > 0.1 - hBase) col *= (0.5 + 0.3 * mod (37. * c, 1.)) *\n         ((vn.y > 0.99) ? 1.2 : (1. - 0.5 * step (abs (hw), 0.25) * sign (hw)));\n      else col = mix (col, vec3 (2.) * (0.1 +\n         0.9 * step (abs (vc.x - 0.04), 0.02)), step (vc.x, 0.4));\n      sh = ObjSShadow (ro, sunDir);\n      col = col * (0.2 + 0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) +\n         0.05 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    }\n    col *= 1. + 0.6 * min (ro.y / hBase, 0.);\n    col = mix (col, 0.6 * SkyCol (ro, rd), smoothstep (0.4, 0.95, dFade));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)),\n     -0.5 + 0.2 * sin (0.02 * pi * t), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec3 e = vec3 (1., 0., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col, gCol;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 50.;\n  trkF = vec3 (0.029, 0.021, 0.016);\n  trkA = vec3 (15., 23., 34.);\n  vFly = 2.;\n  ro = TrackPath (vFly * tCur);\n  ro.y += 12.;\n  vd = TrackVel (vFly * tCur);\n  el = sin (vd.y);\n  az = atan (vd.x, vd.z);\n  if (mPtr.z > 0.) {   \n    el += 0.7 * pi * mPtr.y;\n    az += 2. * pi * mPtr.x;\n  }\n  ori = vec2 (clamp (el, -0.5 * pi, 0.45 * pi), az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  rd.xy = Rot2D (rd.xy, -10. * TrackAcc (vFly * tCur).x);\n  dstFar = 150.;\n  hBase = 5.;\n  sunDir = normalize (vec3 (sin (0.02 * pi * tCur), 0.2, cos (0.02 * pi * tCur)));\n  col = ShowScene (ro, rd) + GlareCol (rd, sunDir * vuMat, uv);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBRR", "name": "Island Flight", "author": "dr2", "description": "Partly synchronized close formation flying over Voronoi islands (mouse enabled)", "tags": ["voronoi", "hexagon", "bird"], "likes": 7, "viewed": 508, "date": "1498992538", "time_retrieved": "2024-06-20T18:58:39.082057", "image_code": "// \"Island Flight\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 flPos, sunDir, qHit;\nvec2 gVec[7], hVec[7], gId;\nfloat tCur, dstFar, szFac, vbOff, wngAng, gRand;\nint idObj;\nconst int idWing = 21, idBdy = 22, idEye = 23, idBk = 24;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.1) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat GrndHt (vec2 p)\n{\n  vec4 sv;\n  float h1, h2, r, s;\n  r = 0.2 * length (Noisev3v2 (0.3 * p));\n  sv = HexVor (0.05 * p + r);\n  s = (0.8 + 0.5 * sv.w);\n  h1 = s * smoothstep (0.1, 0.4 + 0.1 * sv.w, sv.x);\n  h2 = 2. * s * smoothstep (0.2, 0.4 + 0.1 * sv.w, max (0.,\n     (0.45 - dot (sv.yz, sv.yz))));\n  return 3. * SmoothMax (h1, h2, 0.4) - 0.5;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - 6.) / rd.y;\n    sLo = s;\n    for (int j = 0; j < 150; j ++) {\n      p = ro + s * rd;\n      h = p.y - GrndHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > GrndHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = GrndHt (p.xz);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x, h - GrndHt (p.xz + e.yx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qh;\n  float wSegLen, wChord, wSpar, fTap, tFac, bkLen, dMin, d, dd, a, wr, wf, tr, u;\n  p /= szFac;\n  wSegLen = 0.15;\n  wChord = 0.3;\n  wSpar = 0.03;\n  fTap = 8.;\n  bkLen = 0.2;\n  tFac = (1. - 1. / fTap);\n  dMin = dstFar / szFac;\n  q = p;\n  q.z -= 0.3;\n  q.x = abs (q.x) - 0.1;\n  wf = 1.;\n  a = wngAng;\n  d = dMin;\n  qh = q;\n  for (int k = 0; k < 5; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSegLen;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSegLen));\n    dd = PrFlatCylDf (q.zyx, wr * wChord, wr * wSpar, wSegLen);\n    if (k < 4) {\n      q.x -= wSegLen;\n      dd = min (dd, PrCapsDf (q, wr * wSpar, wr * wChord));\n    } else {\n      q.x += wSegLen;\n      dd = max (dd, PrCylDf (q.xzy, wr * wChord, wSpar));\n      dd = min (dd, max (PrTorusDf (q.xzy, 0.98 * wr * wSpar,\n         wr * wChord), - q.x));\n    }\n    if (dd < d) { d = dd;  qh = q; }\n    a *= 1.03;\n    wf *= tFac;\n  }\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idWing;  qHit = qh; }\n  q = p;\n  wr = q.z;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr, 1.);\n  if (d < dMin) {\n    dMin = d;  idObj = idBdy;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  wr = (wr + 1.) * (wr + 1.);\n  q -= vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCylDf (q, 0.009, 0.2);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.08, 0.05, 0.9);\n  d = PrSphDf (q, 0.04);\n  if (d < dMin) { dMin = d;  idObj = idEye;  qHit = q; }\n  q = p;\n  q -= vec3 (0., -0.015, 1.15);\n  wr = clamp (0.5 - 0.3 * q.z / bkLen, 0., 1.);\n  d = PrFlatCylDf (q, 0.2 * wr * bkLen, 0.2 * wr * bkLen, bkLen);\n  if (d < dMin) { dMin = d;  idObj = idBk;  qHit = q; }\n  return 0.8 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP, rs;\n  float dHit, d, s, f;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., SQRT3);\n  edN[2] = 0.5 * vec2 (1., - SQRT3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  rs = ro.xz - flPos.xz;\n  vf = (SQRT3/2.) - vec3 (dot (rs, edN[0]), dot (rs, edN[1]), dot (rs, edN[2]));\n  pM = HexToPix (PixToHex (rs));\n  gIdP = vec2 (-10.);\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro - flPos + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (max (max (abs (gId.x), abs (gId.y)), abs (gId.x + gId.y)) <= 4.) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        f = SmoothBump (0.2, 0.7, 0.1, mod (0.03 * tCur, 1.));\n        gRand = Hashfv2 (gId);\n        wngAng = -0.1 + 0.2 * sin (5. * tCur + 0.3 * pi * (length (gId) +\n           f * (gRand - 0.5)) * f);\n        gIdP = gId;\n      }\n      p.y += vbOff * gRand - 0.5;\n      p.xz -= HexToPix (gId);\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.01;\n      pM += SQRT3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  p -= flPos;\n  p.y += vbOff * gRand - 0.5;\n  p.xz -= HexToPix (gId);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.1, 0.2, 0.5) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  sd = pow (max (dot (rd, sunDir), 0.), 64.);\n  col = SkyBg (rd) + (0.35 * sd + 0.65 * min (pow (sd, 4.), 0.3)) *\n     vec3 (1., 1., 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec4 BirdCol (vec3 n)\n{\n  vec3 col;\n  float gw, w, spec;\n  spec = 0.2;\n  if (idObj == idWing) {\n    gw = 0.3 * szFac;\n    w = mod (qHit.x, gw);\n    w = SmoothBump (0.15 * gw, 0.65 * gw, 0.1 * gw, w);\n    col = mix (vec3 (1.), vec3 (0.1), w);\n    col *= (gRand > 0.5) ? vec3 (1., 0., 0.) : vec3 (1., 1., 0.);\n  } else if (idObj == idEye) {\n    col = vec3 (0., 0., 0.6);\n    spec = 0.7;\n  } else if (idObj == idBdy) {\n    col = mix (mix (vec3 (1., 0.8, 0.8), vec3 (0.05, 0.2, 0.05),\n       smoothstep (0.5, 1., n.y)), vec3 (0., 0., 0.8),\n       1. - smoothstep (-1., -0.3, n.y));\n  } else if (idObj == idBk) {\n    col = vec3 (1., 0.4, 0.1);\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, dstGrnd, f;\n  HexVorInit ();\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstGrnd < min (dstObj, dstFar)) {\n    ro += dstGrnd * rd;\n    if (ro.y > 0.1) {\n      vn = VaryNf (1.3 * ro, GrndNf (ro), 5.);\n      f = clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.);\n      col = mix (mix (vec3 (0.4, 0.3, 0.3), vec3 (0.5, 0.5, 0.6), f),\n         mix (vec3 (0.3, 0.7, 0.3), vec3 (0.5, 0.6, 0.1), f),\n         (0.1 + 0.9 * smoothstep (0.1, 0.2, ro.y)) *\n         clamp (1.2 * vn.y - 0.2, 0.2, 1.)) *\n         (0.2 + 0.2 * max (dot (vn, - vec3 (sunDir.x, 0., sunDir.z)), 0.) +\n         0.8 * max (0., max (dot (vn, sunDir), 0.))) +\n         0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    } else {\n      vn = VaryNf (5.1 * ro, vec3 (0., 1., 0.), 0.2);\n      rd = reflect (rd, vn);\n      col = mix (vec3 (0.15, 0.2, 0.15), vec3 (0.1, 0.1, 0.2), Fbm2 (ro.xz));\n      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.8, 0.95,\n          1. - pow (dot (rd, vn), 3.)));\n    }\n    col = mix (col, SkyBg (rd), max (pow (dstGrnd / dstFar, 4.) - 0.1, 0.));\n  } else if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = BirdCol (vn);\n    col = col4.rgb * (0.2 + 0.8 * max (dot (sunDir, vn), 0.)) +\n       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, f, flyVel, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  rd = normalize (vec3 (uv, 1.5));\n  szFac = 0.5;\n  flyVel = 5.;\n  flPos = vec3 (0., 16., flyVel * tCur);\n  vbOff = 2. * cos (0.1 * tCur);\n  ro = vec3 (0., 2., -8.);\n  if (mPtr.z > 0.) {\n    el = 0.6 * pi * mPtr.y;\n    az = 2.1 * pi * mPtr.x;\n  } else {\n    t = mod (0.03 * tCur, 2.);\n    el = 0.2 * pi * sign (t - 1.) * SmoothBump (0.25, 0.75, 0.2, mod (t, 1.));\n    az = pi * sin (0.005 * 2. * pi * tCur);\n  }\n  ro.yz = Rot2D (ro.yz, el);\n  ro.xz = Rot2D (ro.xz, az);\n  ro += flPos;\n  vd = normalize (flPos + vec3 (0., -8. * sin (el), 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * rd;\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 1., - sin (0.01 * tCur)));\n  dstFar = 200.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, cHashA3.xy));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBRW", "name": "Monitor reaction time", "author": "Death", "description": "Test for monitors to test their reaction time with moving object in different color.\nMy monitor was 'blurring' ingame. To reproduce i made this shader and found out that the problem was \"OD\"(OverDrive)-Setting of my Acer monitor. Turning it off->OK.", "tags": ["2d"], "likes": 0, "viewed": 104, "date": "1499608003", "time_retrieved": "2024-06-20T18:58:39.082057", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float speed = 5.;\n    float width = .1;\n    float xMin = ((sin(iTime*speed)+1.-width)/2.) ;\n    float xMax = xMin + width;\n    \n    bool a = uv.x > xMin && uv.x < xMax;\n    \n        \n    fragColor = vec4(.4,.8,1,1.0);\n    fragColor = vec4(vec3(.9),1.0);\n    //fragColor = vec4(vec3(uv.y),1.0);\n\t//fragColor = vec4(vec3(sin(iTime),cos(iTime),tan(iTime)),1.0);\n    \n    if(a)\n        fragColor = vec4(1,1,1,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBWm", "name": "Cage I", "author": "zaiyugi", "description": "Raymarched scene with a moving light and soft shadows.", "tags": ["raymarching"], "likes": 0, "viewed": 103, "date": "1500574981", "time_retrieved": "2024-06-20T18:58:39.083054", "image_code": "// zshore\n#define MAX_ITERATIONS 256\n#define MAX_LIGHT_ITERATIONS 128\n#define M_PI 3.1415926535897932384626433832795\n\nfloat deg2rad = M_PI / 180.0;\nfloat rad2deg = 180.0 / M_PI;\n\nvec3 light_p = vec3(0.0, 100.0, 0.0); \nvec3 light_n = vec3(0.0, -1.0, 0.0);\nvec3 light_C = vec3(255.0, 153.0, 102.0) / 255.0;\n\nfloat epsilon = 0.0003;\n\nfloat sdf(vec3 p)\n{\n    vec3 c = vec3(3.0);\n    vec3 q = mod(p, c) - 0.5 * c;\n    \n    float d1 = length(q) - 1.7;\n    \n    q = p + vec3(0.0, 88.3, 0.0);\n    vec3 d = abs(q) - vec3(250.0, 100.0, 250.0);\n    float d2 = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    \n    float d3 = length(p) - 12.0;\n    \n    return max( -d3, max(-d1, d2) );\n}\n\nvec3 getNormal(vec3 p)\n{\n    float h = epsilon;\n    return normalize(vec3(\n        sdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n        sdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n        sdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))\n        ));\n}\n\nfloat shadow(vec3 r0, vec3 rd, float mint, float maxt, float k)\n{\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < MAX_LIGHT_ITERATIONS; ++i )\n    {\n        if( t >= maxt )\n            break;\n\n        float h = sdf(rd*t + r0);\n        if(h < epsilon/3.0)\n            return 0.0;\n\n        res = min( res, k * h / t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p, float dist)\n{\n    vec3 mcol = vec3(0.5, 0.25, 0.5);\n\n    // Top Light\n    vec3 ro = light_p;\n    vec3 rd = normalize(p - ro);\n\n    float shadowFactor = 0.0;\n    if( acos(dot(rd, light_n))*rad2deg < 15.0 )\n        shadowFactor = shadow( p, -rd, epsilon, length(p - ro), 192.0 );\n\n    vec3 lcol = light_C;\n    vec3 scol = lcol * mcol;\n\n    vec3 N = getNormal(p);\n    vec3 toLgt = normalize(light_p - p);\n    float Id = dot( N, toLgt );\n    vec3 H = normalize(toLgt + -rd);\n    float Is = pow( dot(H, N), 50.0 );\n\n    scol = scol * Id;\n    scol += vec3(1.0) * Is;\n    scol = clamp(scol, 0.0, 1.0);\n\n    return scol * shadowFactor;\n}\n\nvec3 raymarch(vec3 r0, vec3 rd)\n{\n    float t = 0.0;\n\n    vec3 p;\n    for(int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        p = rd * t + r0;\n        float d = sdf(p);\n        if(d < epsilon)\n            break;\n\n        t += d;\n    }\n\n    vec3 color = shade(p, t);\n    \n    float b = 0.01;\n    float fogStrength = 1.0 - exp(-t * b);\n    color = mix(color, vec3(0.5, 0.6, 0.7), fogStrength);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect_ratio = iResolution.x / iResolution.y;\n\tvec2 p_uv = fragCoord.xy / iResolution.xy;\n    p_uv = p_uv * 2.0 - 1.0;\n\n    float angle = iTime * 0.04 * M_PI;\n    float focal_length = 1.0 / tan( 37.5 * deg2rad );\n\n    light_p.y = sin(iTime * M_PI * 0.4) * 40.0 + 30.0;\n\n    vec3 eye = vec3(11.25 * cos(angle), 0.0, 11.25 * sin(angle));\n\n    vec3 focus = vec3(0.0, -5.0, 0.0);\n    vec3 view = normalize(focus - eye);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 right = vec3(cos(angle + M_PI / 2.0), 0.0, sin(angle + M_PI / 2.0));\n\n    vec3 rd = normalize(view * focal_length + up * p_uv.y + right * p_uv.x * aspect_ratio);\n    vec3 color = raymarch(eye, rd);\n\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBzG", "name": "ECG", "author": "Zibe", "description": "Trying to simulate ECG, based on this formula : https://www.reddit.com/r/Physics/comments/30royq/whats_the_equation_of_a_human_heart_beat/cpw81wj/", "tags": ["2d"], "likes": 1, "viewed": 276, "date": "1500907910", "time_retrieved": "2024-06-20T18:58:39.083054", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.005, pct, st.y) - \n          smoothstep( pct, pct+0.005, st.y);\n}\n\nfloat ecg(float x)\n{\n    \n    x = x - ceil(x/2.8 - 0.5)*2.8;\n    \n   return 0.2*(exp((-pow(x + 1.4, 2.)) / (2.*0.02)) + exp((-pow(x - 1.4,2.)) / (2.*0.02))) + \n       (1. - abs(x / 0.1) - x)*exp((-pow(7.*x,2.)) / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n\tfragColor = vec4(0., step( 0.245,mod(uv.x, 1./4.)) , 0., 1.);\n\tfragColor += vec4(0., step( 0.245,mod(uv.y, 1./4.)) , 0., 1.);\n    \n    fragColor +=  plot(uv, ecg(uv.x*2. + iTime / 1.5)/2. + 0.5) * vec4(0.,10.,0., 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBzV", "name": "Domain warping", "author": "lordjone", "description": "Dirty candies paint :)", "tags": ["procedural", "domain", "warp"], "likes": 2, "viewed": 150, "date": "1501079625", "time_retrieved": "2024-06-20T18:58:39.084733", "image_code": "#define PI 3.14\nmat2 m = mat2( vec2 (2.1, 1.0), vec2(-1.0, 2.1) );\n\nfloat noise_f(vec2 p)\n{\n    return sin(1.66*p.x)*sin(1.66*p.y);\n}\n\nfloat domain_pattern(vec2 p)\n{\n    float f = 0.0;\n    float amp = 2.0; \n    float kAmp = 0.5;\n    float freq = 2.63;\n    float kFreq = 0.53;\n    \n    f += amp*noise_f(p); \tp = m*p*freq; amp *=kAmp; freq *=kFreq;\n    f += amp*noise_f(p);  \tp = m*p*freq; amp *=kAmp; freq *=kFreq;\n    f += amp*noise_f(p);   \tp = m*p*freq; amp *=kAmp; freq *=kFreq;\n    f += amp*noise_f(p);\n    \n    f = fract(f);\n    \n    return f;\n}\n\nfloat domain_pattern_2(vec2 p)\n{\n    float f = 0.0;\n    float amp = 1.43; \n    float kAmp = 0.25;\n    float freq = 6.23;\n    float kFreq = 0.03;\n    \n    f += amp*noise_f(p); \tp = m*p*freq; amp *=kAmp; freq *=kFreq;\n    f += amp*noise_f(p);  \tp = m*p*freq; amp *=kAmp; freq *=kFreq;\n    f += amp*noise_f(p);   \tp = m*p*freq; amp *=kAmp; freq *=kFreq;\n    f += amp*noise_f(p);\n    \n    f = fract(f);\n    \n    return f;\n}\n\nfloat domain_pattern_3(vec2 p)\n{\n    return domain_pattern_2(p);\n}\n\nvec3 colorize(float hp, float gp, float fp)\n{\n   vec3 color = vec3(0.0);\n      \n    vec3 ch = mix(vec3(0.0, 1.0, 0.97), vec3(1.0, 0.0, 0.66), hp);\n    vec3 cg = mix(vec3(1.0, 1.0, 0.27), vec3(0.0, 1.0, 0.96), gp);\n    vec3 cf = mix(vec3(0.0, 1.0, 0.47), vec3(0.0, 0.3, 1.0), fp);\n    \n    //color = ch;\n    //color = cg;\n    //color = cf;\n    \n    // Colorize 1\n    //color = mix( cf, mix(cg, ch, gp), fp);\n    \n    // Colorize 2\n    color = mix(cg, ch, gp);\n    color += vec3(hp, gp, fp)*vec3(0.66,0.26,0.13)*(0.5 + 0.5*sin(iTime));\n    \n    //color = vec3(hp);\n    //color = vec3(gp);\n    //color = vec3(fp);\n    return color;\n}\n\nvec3 domain_warp(vec2 p)\n{\n\t// f(p) = f(g(p)) = f( p + h(p) ) = fbm( p + fbm(p) )\n    // g(p) = p + h(p) = p + fbm(p)\n    \n    float hp = domain_pattern(p);\n    float gp = domain_pattern_2(p + hp);\n \tfloat fp = domain_pattern_3(p + gp);\n    \n    return colorize(hp, gp, fp);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Uvs mapping\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0*uv -1.0;\n    \n    // Update rotation matrix\n    const float kSpeed = 0.002;\n    const float period = 2.0*PI;\n    const float gamma = kSpeed*period;\n    float alpha = gamma*iTime;\n    const float zoom = 1.9;\n    float sine = sin(alpha)*zoom;\n    float cose = cos(alpha)*zoom;\n    \n    m = mat2( vec2(cose, -sine), \n              vec2(sine, cose) );\n    \n    // Output color\n    fragColor = vec4(vec3(domain_warp(uv)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBBzW", "name": "Line with moving circle", "author": "Abvadabra", "description": "Learning how to do basic shapes in glsl", "tags": ["line"], "likes": 1, "viewed": 169, "date": "1499628386", "time_retrieved": "2024-06-20T18:58:39.085827", "image_code": "#define thickness 0.02\n#define iLine vec4(0.2, 0.2, 0.8, 0.8)\n\nfloat getPoint(vec4 line, vec2 position){\n\tfloat crotch = mod(iTime / 2., 1.);\n\tvec2 crPoint = line.xy + crotch * (line.zw - line.xy);\n\tfloat cd = length(crPoint - position);\n    float t = thickness * 3.;\n\tfloat f = (cd * cd) / (t * t);\n\tfloat cf = (1. - step(thickness * 4., cd)) * smoothstep(0.6, 0.85, 1. - f);\n\treturn cf;\n}\n\nfloat getLine(vec4 line, vec2 position){\n\tfloat a = length(line.xy - position);\n\tfloat b = length(line.zw - position);\n\tfloat c = length(line.zw - line.xy);\n\tfloat p = .5 * (a + b + c);\n\tfloat h = (2. / c) * sqrt(p * (p - a) * (p - b) * (p - c));\n\tfloat l = 1. - step(thickness, h);\n\tfloat f = 1. - (h * h) / (thickness * thickness);\n\n\tfloat lineColor = (abs(sin(iTime)) * .5 + .5) * smoothstep(0., 1., f) * l;\n\n\tvec2 center = (line.xy + line.zw) / 2.;\n\tfloat centerF = length(position - center);\n\tfloat centerLimit = c / 2.;\n\tfloat fadeout = centerLimit * .9;\n\tfloat limiter = 1. - step(centerLimit, centerF);\n\tfloat fade = step(fadeout, centerF);\n\tlimiter *= 1. - fade * smoothstep(0.0, 1., (centerF - fadeout) / (centerLimit - fadeout));\n\n\treturn lineColor * limiter;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = (fragCoord.xy / iResolution.xy);\n\tfloat r = iResolution.x / iResolution.y;\n\tposition.x *= r;\n\tvec4 l = iLine;\n\tl.xz *= r;\n\n\tvec4 color = vec4(1.);\n\tvec4 result = getLine(l, position) * color;\n\tresult = max(result, getPoint(l, position) * color);\n\n\tfragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBfDw", "name": "Cirdist", "author": "zaiyugi", "description": "Tiles with fractal sine waves sliding based on simplex noise", "tags": ["noise", "tiling"], "likes": 7, "viewed": 144, "date": "1500572547", "time_retrieved": "2024-06-20T18:58:40.078653", "image_code": "/*\nZachary Shore\nDPA8090: Rendering and Shading\nHW2: SDFs: fractal sine tiling\n*/\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(\n        0.211324865405187,   // (3.0-sqrt(3.0))/6.0\n        0.366025403784439,   // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626,  // -1.0 + 2.0 * C.x\n        0.024390243902439\t\t// 1.0 / 41.0\n    ); \n\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat noise(vec2 p)\n{\n    float freq = 1.0;\n    return snoise(freq * p);\n}\n\nfloat plot(vec2 st, float t)\n{\n    return smoothstep(t-0.03, t, st.y) - smoothstep(t, t+0.03, st.y);\n}\n\nvec2 tile(vec2 _st, float _zoom)\n{\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n     _st -= 0.5;\n     _st =  mat2(cos(_angle),-sin(_angle),\n                     sin(_angle),cos(_angle)) * _st;\n     _st += 0.5;\n     return _st;\n}\n\nfloat fractal_sin(float p, float t)\n{\n    int octaves = 7;\n    float amp = 0.9;\n    float freq = 1.0;\n    float fjump = 1.8;\n    float roughness = 1.1;\n    float t_amp = 0.4;\n    float gamma = 0.5;\n\n    float accum = 1.0;\n    float X = (p - t_amp * t) * freq;\n    for(int j = 0; j < 7; ++j)\n    {\n        accum *= amp * sin(X);\n        X *= fjump;\n        amp *= roughness;\n    }\n\n    return pow( accum, gamma );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    st.x *= aspect;\n\n    float t = iTime * 1.0;\n    float twist_t = iTime * 0.75;\n    vec2 uv = st;\n\n    // Shuffle tiles\n    float time_angle = (tan(cos(twist_t)) + sin(twist_t));\n    uv = rotate2D(uv, time_angle);\n\n    uv *= 20.0;\n\n    vec2 ndx = floor(uv);\n\n    float translate_noise_x = floor(t) + step(0.5, fract(t)) * 0.5;\n\n    float noise_val = noise(ndx + vec2(translate_noise_x, 0.0)) + 0.5;\n    int rand_dir = int(floor(noise_val * 2.0));\n\n    if( rand_dir == 0 )\n    {\n        int posneg = int(floor(noise_val * 2.0));\n        if( posneg == 0 )\n            uv.y -= t * 2.0 * (1.0 + float(rand_dir + posneg));\n        else\n            uv.y += t * 2.0 * (1.0 + float(rand_dir + posneg));\n    } else {\n        int posneg = int(floor(noise_val * 2.0));\n        if( posneg == 0 )\n            uv.x -= t * 2.0 * (1.0 + float(rand_dir + posneg));\n        else\n            uv.x += t * 2.0 * (1.0 + float(rand_dir + posneg));\n    }\n\n    uv = fract(uv);\n\n    uv -= 0.5;\n\n    vec2 p = uv;\n    float d = length(p);\n\n    float z = iTime;\n    vec3 color = vec3(0.0);\n    for(int i = 0; i < 3; ++i)\n    {\n        z += 0.1;\n        color[i] = fractal_sin(d, z);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBfR3", "name": "Daily 2017-07-29", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 8, "viewed": 402, "date": "1501337415", "time_retrieved": "2024-06-20T18:58:40.078653", "image_code": "float C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n\nfloat map(vec3 p, float i) {\n    p.xy*=rot(iTime*.3-.1*i);\n    p.yz*=rot(iTime*.5-.1*i);\n    p.xz*=rot(iTime*.7-.1*i);\n    vec2 q=vec2(length(p.xz)-1.,p.y);\n  \treturn length(q)-.2;\n}\n\nfloat clr(vec2 uv, float i) {\n    vec3 ro=vec3(uv,-2.),rd=normalize(vec3(uv,1.)),mp=ro;\n    float BR = 2e-2 + i * 1e-2,\n    \tEPS=1e-3,\n    \tBRMEPS=(BR+EPS)*.5;\n    float mdmin=BR;\n    for(float f=0.;f<30.;++f){\n        float md=map(mp, i);\n        mdmin=min(md,mdmin);\n        if(md<EPS)break;\n        mp+=rd*md;\n    }\n    return max((mdmin-BR)*(EPS-mdmin)/(BRMEPS*BRMEPS),0.);\n}\n\nconst float Samples = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float c=0.;\n    for (float i=0.;i<Samples;++i) {\n        vec2 center=vec2(sin(iTime*.3+.3+i*2.)*.2, sin(iTime*.5+.5+i*2.)*.2);\n        c += clr(center+(uv-center)/(1.+i*.2), i) * (1. - i/Samples);\n    }\n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBfR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBfRh", "name": "Please, don't eat me", "author": "lsdlive", "description": "Experimenting with raymarching: tentacular monster.", "tags": ["raymarching"], "likes": 5, "viewed": 182, "date": "1499292115", "time_retrieved": "2024-06-20T18:58:40.078653", "image_code": "\n\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n\n\tfloat c1 = .05;\n\tp.xz *= r2d(c1*cos(iTime));\n\tp.xy *= r2d(c1*sin(iTime));\n\n\n\tfloat t = 4.;\n\tp.x = mod(p.x + t*.5, t) - t * .5;\n\n\tt = 6.;\n\tp.y = mod(p.y + t*.5, t) - t * .5;\n\n\n\tvec3 pos = vec3(0., cos(sin(iTime) * p.z * .19), 0.);\n\n\n\tvec3 b = vec3(.3, .2, 1e7) * .01;\n\t\n    float d = length(max(abs(p - pos) - b, 0.)) - .2;\n    \n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(2., 2., 10.), p;\n\tvec3 rd = normalize(vec3(uv, -1));\n\tp = ro;\n\n\tint ri;\n\tfor (int i=0; i < 50; i++) {\n\t\tri = i;\n        float d = map(p);\n\t\tif (d < .001) break;\n\t\tp += rd * d;\n\t}\n\n\tfragColor = vec4(mix(vec3(0.8, .8, .7), vec3(.3, 0.1, 0.2), float(ri) / 50.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBfRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBfzm", "name": "[SH17A] Black Hole", "author": "ssell", "description": "First time code-golfing a shader. Was a fun challenge.", "tags": ["2d", "2tweet", "sh17a"], "likes": 16, "viewed": 717, "date": "1499905155", "time_retrieved": "2024-06-20T18:58:40.351891", "image_code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Contest entry for [SH17A] https://www.shadertoy.com/view/MsjBRD\n * Two-Tweet Challenge (<= 280 Characters)\n */\n\n#define P(A) vec2(cos(A - iTime * s) * r, sin(A - iTime * s) * r)\n\nvoid mainImage(out vec4 o, vec2 d)\n{\n\td  = (d - .5 * (o.xy = iResolution.xy)) / o.y;\n    o -= o;\n    \n    float r, s = .1, a = s;\n    \n    for(; a < 6.3; a += s)                                                         // Iterate angle around circle\n        for(r = s; r < 1.; r += s)                                                 // Iterate circle radius\n        {    \n            vec2 p = d - P(a),                                                     // One point on the infinite line\n                 b = P(a + s) - P(a);                                              // Another point on the line\n            \n            o += \n                smoothstep(.003, -.004, length(p - b * dot(p, b) / dot(b, b))) *   // Draw the tangent line\n                (1. - length(d));                                                  // Darken as we move away from the center\n        }\n}", "image_inputs": [{"id": "4sfXzl", "previewfilepath": "https://soundcloud.com/wirrzbow/01-outer-space-gemini-suite-side-a", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/wirrzbow/01-outer-space-gemini-suite-side-a", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjBDh", "name": "[SH17A] Spiral Circles", "author": "NinjaKoala", "description": "2 Tweet spiral thingy", "tags": ["2d", "spiral", "sh17a"], "likes": 13, "viewed": 539, "date": "1500291359", "time_retrieved": "2024-06-20T18:58:40.357491", "image_code": "#define L length\nvoid mainImage( out vec4 c, vec2 i ){\n    vec2 p,R=iResolution.xy;\n\tp = i.xy / R-.5;\n\tp.x *= R.x / R.y;\n\t\n\tfloat j = clamp(floor(L(p)*36.17+.5),1.,17.),r,t;\n\n\tr = j / 36.17;\n\n\tt = iTime * (18.-j) *.4189;\n\n\tc=vec4(smoothstep(0., 2./R.y, min(abs(L(p)-r),L(r * vec2(-sin(t),-cos(t))-p)-.006)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjBDw", "name": "A Thousand Suns", "author": "davl3232", "description": "Still shocked about Chester's suicide, may he rest in peace.", "tags": ["modulo", "rip", "linkinpark", "radialfunction", "chesterbennington"], "likes": 0, "viewed": 424, "date": "1500687804", "time_retrieved": "2024-06-20T18:58:40.551426", "image_code": "#define PI 3.141592653589793238462643383279502884197169399375105820974\n\nvec4 over (vec4 c1, vec4 c2)\n{\n    float w = mix(c2.w, 1.0, c1.w);\n    return vec4( mix(c2.xyz*c2.w, c1.xyz, c1.w)/w, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tfloat time = iTime;\n    vec3 resolution = iResolution;\n    float st = ( sin(time) + 1.0 )/2.0;\n    float stCam = ( sin(time*0.3) + 1.0 )/1.0 + 1.0/24.0;\n\n    uv = mod(uv*stCam*24.0 + 1.0, 2.0) - 1.0;\n\n    float at = atan(uv.x, uv.y);\n\n    float r1 = ( cos(10.0*at + time*2.0)*sin(41.0*at - time*3.0) )/100.0 + 0.36;\n    float r2 = ( cos(100.0*at + time)*sin(40.0*at - time*0.7*3.0) )/100.0 + 0.38;\n\n    float a1 = smoothstep( r1 + 0.06, r1, length(uv) );\n    float a2 = smoothstep( r2 + 0.2 + stCam/3.0, r2, length(uv) );\n    \n    vec4 col = over( vec4( vec3(1.0, 0.8, 0.4), a1*0.7 ), vec4( vec3(1.0, 0.5, 0.2), a2*1.0 ) );\n    col = over( col, vec4( vec3(0.0), 1.0 ) );\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjBRW", "name": "Color Transitions", "author": "ghoofman", "description": "Transitions from one color to the next", "tags": ["color"], "likes": 0, "viewed": 102, "date": "1499787090", "time_retrieved": "2024-06-20T18:58:40.551426", "image_code": "vec3 COLORS[ 8 ];\n\nvec3 getData(int id) {\n    for (int i=0; i<8; i++) {\n        if (i == id) return COLORS[i];\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    COLORS[0] = vec3(1,0,0);\n    COLORS[1] = vec3(0,1,0);\n    COLORS[2] = vec3(0,0,1);\n    COLORS[3] = vec3(1,1,1);\n    int colorMax = 4;\n    float speed = 4.0;\n    \n    int color0 = int(mod(iTime / speed, float(colorMax)));\n    int color1 = color0 + 1;\n    if(color1 >= colorMax) {\n        color1 = 0;\n    }\n    \n    float perc = mod(iTime, float(colorMax) ) / speed;\n    \n    vec3 col0 = getData(color0);\n    vec3 col1 = getData(color1);\n    \n    float r = col0.r + (col0.r - col1.r) * perc;\n    float g = col0.g + (col0.g - col1.g) * perc;\n    float b = col0.b + (col0.b - col1.b) * perc;\n    \n    vec3 color = col0 + (col1 - col0) * perc;\n   \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjBWm", "name": "city's night skyline", "author": "devshin", "description": "impressed by https://www.shadertoy.com/view/MlX3DM", "tags": ["2d", "skyline"], "likes": 0, "viewed": 100, "date": "1500713544", "time_retrieved": "2024-06-20T18:58:40.551426", "image_code": "\nfloat noise2d(vec2 p) {\n\treturn fract(sin(dot(p ,vec2(17.9898,78.233))) * 456367.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\tfloat a = 0.0;\n\n\tconst float size = 40.0;\n\n\tfor(float i = 0.; i < 1.; i+=1./size) {\n\t\tfloat t = size - i * size;\n\t\tp.x += iTime * i * 0.01;\n\t\tfloat px = floor((p.x + noise2d(vec2(i))) * t);\n\t\tfloat top = i * mix(i / size * sin(3.14 * 0.5 * iTime * 0.5), 0.7, 1.2);\n\t\tif(p.y + top < noise2d(vec2(px)))\n\t\t\ta = 1.0 * sin(3.14 * i);\n\t}\n\n\tfragColor = vec4(vec3(a), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjfD1", "name": "Epileptic Test", "author": "Coolok", "description": "Epileptic Test", "tags": ["epileptictest"], "likes": 3, "viewed": 387, "date": "1500315032", "time_retrieved": "2024-06-20T18:58:40.551426", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy / iResolution.xy;\n\t//coord.y = 1.0 - coord.y;\n\t\n\tvec4 modulator = texture(iChannel0, coord);\n\t\n\t//vec4 orig = texture(iChannel1, coord + ((modulator * 0.2) - 0.1).xy);\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor = rgb2hsv(color);\n\tcolor.x = mod(((modulator.x + modulator.y + modulator.z) * 0.7) + (iTime*5.5), 1.0);\n\tcolor.y = 1.0;\n\tcolor.z = 1.0;\n\tcolor = hsv2rgb(color);\n\t\n\tfragColor = mix(vec4(color, 1.0), modulator, 0.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjfD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjfRW", "name": "3 Moving Circles", "author": "andreasleeb", "description": "Three moving circles with additive color mixing", "tags": ["2d", "circles", "animation"], "likes": 0, "viewed": 90, "date": "1499793439", "time_retrieved": "2024-06-20T18:58:40.757504", "image_code": "float circle(vec2 ref, vec2 center, float radius) {\n    float dist = length(ref - center);\n    float outside = smoothstep(radius - .005, radius + .005, dist);\n    return 1. - outside;\n}\n\nconst vec4 blue = vec4(0., 0., .8, 1.);\nconst vec4 red = vec4(.8, 0., 0., 1.);\nconst vec4 yellow = vec4(.8, 0.8, 0., 1.);\n\nfloat xVar = 1./3.;\nfloat yVar = 1./3.;\nfloat radius = .25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ref = 2. * (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float xMax = iResolution.x / iResolution.y;\n    fragColor = vec4(0.);\n\t\n    float x = cos(iTime) * yVar;\n    float c = circle(ref, vec2(-xVar, x), radius);\n    fragColor += c * blue;\n    \n    x = -cos(iTime) * yVar;\n    c = circle(ref, vec2(xVar, x), radius);\n    fragColor += c * red;\n    \n    \n    x = sin(iTime) * xVar;\n    c = circle(ref, vec2(x, 0.), radius);\n    fragColor += c * yellow;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjfRz", "name": "Endless Mandelbox Tunnel", "author": "dr2", "description": "Travel through a repeating Mandelbox", "tags": ["fractal", "mandelbox"], "likes": 5, "viewed": 554, "date": "1499160102", "time_retrieved": "2024-06-20T18:58:40.769770", "image_code": "// \"Endless Mandelbox Tunnel\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 gloPos, ltPos;\nvec2 trkF, trkA;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nfloat MBoxDf (vec3 p)\n{\n  vec4 q, q0;\n  const float mScale = 2.62;\n  const int nIter = 10;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;\n  }\n  return length (q.xyz) / abs (q.w);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)),\n     dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)),\n     dot (trkF * trkF * trkA.yx, - cos (trkF * t)), 0.);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  p.xy -= TrackPath (p.z).xy;\n  d = 0.25 - max (abs (p.y), 0.866 * abs (p.x) + 0.5 * abs (p.y));\n  p.z = mod (p.z + 3., 6.) - 3.;\n  return max (MBoxDf (p), d);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.002, -0.002, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 gloDir;\n  float gloDist, wGlow;\n  wGlow = 0.;\n  gloDir = gloPos - ro;\n  gloDist = length (gloDir);\n  gloDir /= gloDist;\n  if (gloDist < dstHit) wGlow +=\n     pow (max (dot (rd, gloDir), 0.), 1024.) / sqrt (gloDist);\n  return 0.7 * (0.9 + 0.1 * sin (5. * tCur)) * clamp (wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltVec, roo, rdo;\n  float dstHit, ltDist, h;\n  roo = ro;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += dstHit * rd;\n    ltVec = ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    vn = ObjNf (ro);\n    vn = VaryNf (50. * ro, vn, 5.);\n    h = length ((ro.xy - TrackPath (ro.z).xy) - (roo.xy - TrackPath (roo.z).xy));\n    col = HsvToRgb (vec3 (mod (0.3 * h + 0.03 * ro.z, 1.), 0.8,\n       min (0.4 + 0.6 * h, 1.)));\n    col *= (0.3 + 0.7 * max (dot (vn, ltVec), 0.)) / (1. + 0.02 * ltDist * ltDist);\n  } else {\n    col = vec3 (0., 0., 0.1);\n    rdo = rd;\n    rdo += vec3 (1.);\n    for (int j = 0; j < 10; j ++)\n       rdo = 11. * abs (rdo) / dot (rdo, rdo) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rdo)), 5.)) *\n       vec3 (0.7, 0.6, 0.6);\n  }\n  col = mix (col, vec3 (1., 0.7, 0.5), GlowCol (roo, rd, dstHit));\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n  }\n  trkF = vec2 (0.1, 0.17);\n  trkA = vec2 (2.5, 0.9);\n  vFly = 1.;\n  ro = TrackPath (vFly * tCur);\n  ro.y += 0.05;\n  vd = normalize (TrackVel (vFly * tCur));\n  ori = vec2 (el + 1.5 * sin (vd.y), az + 2. * atan (vd.x, vd.z));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  rd.xy = Rot2D (rd.xy, -20. * TrackAcc (vFly * tCur).x);\n  gloPos = TrackPath (vFly * tCur + 1.);\n  ltPos = gloPos;\n  dstFar = 30.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjfRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlBWs", "name": "Accident - hotel lobby", "author": "bch", "description": "This bizarre accident occurred while trying to learn to identify voxel cells by shading.. Thought it looked kind of like a cool ultramodern space filled with glass and mirrors, thought I'd share. Mousing around will reveal some \"backstage\" geometry.", "tags": ["voxel", "random", "opart", "mistake"], "likes": 1, "viewed": 124, "date": "1501482138", "time_retrieved": "2024-06-20T18:58:42.885106", "image_code": "/*  As a casual glance will show, this shader is mostly  hamneggs' Distance Field\n    Playbox, lsc3z8. I added only some minor bits -- getCellID(), ChangingColor(),\n    camPolar(), various twiddles and changes to march().\n\n/*\n    see https://www.shadertoy.com/view/lsc3z8 for hamneggs' original readme...\n*/\n\t\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.5\n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 100\n// Shadow marching steps.\n#define S_STEPS 20\n// Maximum successful marching distance.\n#define EPSILON .00025\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// This is for texturing. For each item you want textured,\n// give it an ID and add it to the distID function using\n// the unioning function u(), then add code to check for \n// the ID in tex().\n#define ID_PLANE 1.0\n#define ID_BOX 2.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.408248, 0.816497, -0.408248); \t// Sun direction.\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t\t\t    // Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t\t\t\t// High angle sky.\nconst vec3 SUN_COLOR = vec3(4.0);\t\t\t\t\t\t\t// Sun color.\nconst vec3 GROUND_COLOR = vec3(0.73,0.60,0.47);\t\t\t\t// Average color of the ground for GI.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t\t\t\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t\t\t// ... and the second as well.\n\n// Camera parameters.\nconst vec3 CAM_LOOK_AT = vec3(0.0, 0.0, 0.0);\nconst float CAM_DIST_AWAY = 3.0; // How far away the camera is from CAM_LOOK_AT.\nconst float CAM_ZOOM = 1.;\nint flag = 0;\nvec3 gColor = vec3(0.0,0.0,0.0);\n// if offset is (0,0,0) then p(0,0,0) maps to center of cell (0,0,0)\n// r is the complete (not half) cell size\nivec3 getCellID(vec3 p, float r, ivec3 offset)\n{\n\treturn ivec3(int(floor((p.x )/r)),\n                 int(floor((p.y )/r)),\n                 int(floor((p.z )/r)))\n                 + offset;\n}\n\n\nvec3 ChangingColor(in vec3 p)\n{\n\n\treturn clamp(abs(mod(iTime + fract(p.x) + fract(p.y) + fract(p.z) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\n/*\n\tTEKF's wonderful polar camera. (https://www.shadertoy.com/view/XdsGDB)\n*/\nvoid camPolar( out vec3 p, out vec3 d, in vec3 o, in vec2 r, in float dist, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = cos(r);\n\tvec4 s;\n\ts.xy = sin(r);\n\ts.zw = -s.xy;\n\n\n    // ray in view space\n\td.xy = fragCoord.xy - iResolution.xy*.5;\n\td.z = iResolution.y*zoom;\n\td = normalize(d);\n\t\n\t// rotate ray\n\td.yz = d.yz*c.x + d.zy*s.zx;\n\td.xz = d.xz*c.y + d.zx*s.yw;\n\n    \n    \n\t// position camera\n\tp = o - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tReturns the distance to an XZ plane at Y=0.\n*/\nfloat plane( in vec3 p )\n{\n    return p.y;\n}\n\n// Distance from p to box whose half-dimensions are b.x, b.y, b.z\nfloat sdBox(vec3 p, vec3 b) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - b;\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n\n/////////////////////////////////////////////////\n// ADD EXTRA DISTANCE FIELD STUFF HERE AND ABOVE.\n/*\n\tThe scene's distance function.\n\tAdd what ever distance field primitives you want above, then\n\tuse them to create your object in this function.\n*/\nfloat dist( in vec3 p)\n{\n    \tfloat d= min(sdBox(mod(p, 2.)-1.,vec3(.1)),plane(p));\n    \t\n    return d;\n    \n}\n\nfloat distGrid( in vec3 p)\n{\n\tfloat d = sdBox(mod(p,.25)-.125,vec3(.125));\n    \n    return d;\n\t\n}\n\n\n/////////////////////////////////////////////////\n// REGISTER YOUR NEW OBJECT HERE FOR TEXTURING.\n/*\n\tReturns the id and distance of the nearest object.\n*/\nvec2 distID( in vec3 p )\n{\n    return u(vec2(plane(p),ID_PLANE), vec2(sdBox(mod(p,2.)-1.,vec3(.3)),ID_BOX));\n    /* E.g.\n\tvec2 closest = u(vec2(yourObjectA(p), ID_YOUR_OBJ_A),\n\t\t\t         vec2(yourObjectB(p), ID_YOUR_OBJ_B);\n\t\t closest = u(closest, vec2(plane(p), ID_PLANE);\n\t*/\n}\n\n/*\n\tMixes between two colors based on the upward angle of the\n\tray direction for a plausible sky.\n*/\nvec3 sky( vec3 d )\n{\n    vec3 flatD = normalize(vec3(d.x,0.0,d.z));\n    return mix(SKY_COLOR_B, SKY_COLOR_A, clamp(dot(flatD,d),0.0,1.0));\n}\n\n/*\n\tReturns a \"texel\" in a tile texture, whose contrast is reduced by distance.\n*/\nvec3 tile_tex( vec3 p, vec3 e )\n{    \n    // The tile is absolute value of the difference in the modulo of the x and z terms of the position.\n    float tile = abs(floor(mod(p.x, 2.0)) - floor(mod(p.z, 2.0)));\n    // We add a term to soften the edge with distance for psuedo anisotropic filtering.\n    tile += (length(p-e)/MAX_DEPTH);\n    \n    // Finally we return the mix of the two tile colors, based on the tile difference.\n    return mix( TILEA, TILEB, smoothstep(0.0, 1.0, tile));\n}\n\n/////////////////////////////////////////////////\n// WRITE SOME SWEET TEXTURE FUNCTIONS AND THROW\n// 'EM IN HERE\n/*\n\tTakes a position and eye coordinate and returns the\n\ttexture of the nearest object to the given position.\n*/\nvec3 tex( vec3 p, vec3 e )\n{\n    float id = distID(p).t;\n    if(id == ID_PLANE) return tile_tex(p,e);\n    \n\telse if(id == ID_BOX) return ChangingColor(p);\n\t/*else if(id == YOUR_OBJ_B) return radTexB(whatevs);\n\t*/\n    else return vec3(.8);\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, vec3 d )\n{\n\n    \n    float r = distGrid(p+d*EPSILON);// reset r\n \t\n    if (int(fract(d.x)*50.)== 0 || int(fract(d.y)*50.) == 0)\n        flag = 1;\n    float rr = 0.;\n    ivec3 id = ivec3(0,0,0);\n    for(int j = 0; j < 15; j++)  // arbitrary number of gridboxes to search; this\n        // would have a max based on number of gridboxes per large cube\n    {\n    \tr = distGrid(p-d*10.*EPSILON);\n        if (j == 0) r = distGrid(p+d);\n        rr = 0.;\n        for(int i = 0; i < 20/*V_STEPS*/; i++)\n        {\n            if(abs(r) < EPSILON/*|| r > MAX_DEPTH*/)\n            { \n                /*ivec3 id = getCellID(p, 2., ivec3(0,0,0));\n                if (id.z >-3 && id.z < -2){\n                   /* flag = 1;*/ break;\n            \t//}\n        \t}\n            p += d*r;\n\n            r = distGrid(p);\n        }\n\n        ivec3 id = getCellID(p, .5, ivec3(0,0,0));\n       // id = ivec3(0,2,1);\n       if (id.z >8 && id.z < 13 && id.x >-3 && id.x < 3 && id.y > -3&& id.y <  3)\n        gColor += normalize(mod(vec3(float(id.x),float(id.y),float(id.z)),10.))/(float(j+1)*2.);\n\t\n\n        //if (id == ivec3(0,0,-3))\n        //    flag = 1;\n        //    break;\n    if (id.x >0 && id.x < 2)\n    \t{\n\t\t\tflag = 0;\n            for(int i = 0; i < V_STEPS; i++)\n            {\n                rr = dist(p+d*EPSILON);\n                if(rr < EPSILON || r > MAX_DEPTH)\n                    return;\n                p += d*rr;\n\n                rr = dist(p);\n        \t}    \n        }}\n\n    \n    \n\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir, in float p )\n{    \n\tfloat t = EPSILON;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float d = dist( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n )\n{\n    // Get ambient occlusion and shadow values.\n    float amb = occlusion(p,n);\n    float sdw = shadow(p,SUN_DIR,PENUMBRA_FACTOR);\n    \n    // Get light colors and irradiance for the three lights.\n    vec3 skc = orenNayar(n,-d,UP)*sky(d);\n    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;\n    vec3 gnd = orenNayar(n,-d,-SUN_DIR)*GROUND_COLOR;\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= sdw;\n    \n    // Return the sum.\n    return skc+gnd+sun+vec3(.05);\n}\n/*\n\tShades a point, giving it lighting and taking into account distance.\n*/\nvec3 shade(vec3 p, vec3 d, vec3 e)\n{\n    // Get the position's distance from the camera.\n    float l = length(p-e);\n    // Also get the surface normal.\n    vec3 n = norm(p);\n    // And let's get the sky color since we need it.\n    vec3 s = sky(d);\n    // If the ray didn't hit anything, we shortcut out.\n    if(l >= MAX_DEPTH)return s;\n    // Otherwise we do texturing and lighting for this point.\n    vec3 result = tex(p,e)*light(p,d,e,n);\n    // Smooth out the transition between geometry and emptiness.\n\treturn mix(s,result,clamp(MAX_DEPTH-l,0.0,1.0));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( vec2 uv, vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Camera position and direction.\n    vec3 cp = vec3(0.0, 1.0, -5.0);\n    vec3 cd = normalize(vec3(0.0, 0., 1.0));\n    \n    // Set up the camera.\n    vec2 m;\n    if(length(iMouse.xy)<=.001) m = vec2(.5,.1);\n    else m = iMouse.yx/iResolution.yx;\n    m *= vec2(1.5,6.28); // Movement scaling.\n \n\n    \n    camPolar(p, d, CAM_LOOK_AT, m, CAM_DIST_AWAY, CAM_ZOOM, fragCoord );\n\t// Store the eye position.\n    e = vec3(p);\n    \n\n    \n    // Do the actual ray marching.\n    march(p,d);\n    \n    // Store the final pixel color.\n    if (flag == 0)\n    \t{\n        fragColor = postProcess(uv,shade(p,d,e)).rgbb;\n        fragColor = mix( vec4(gColor, 1.),fragColor, .5);\n        }\n    else \n        fragColor = vec4(0.,0.,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSBD1", "name": "[SH17A] Starfall / KaliSet", "author": "unbird", "description": "Minimal KaliSet shader to generate falling stars. No textures.\nOriginal:[url=https://www.shadertoy.com/view/4ljGDd]Magic Fractal[/url] by dgreensp.\n[url=http://casual-effects.blogspot.ch/2013/08/starfield-shader]Article about the KaliSet[/url].", "tags": ["star", "kaliset", "storm", "minimal", "competition", "alu", "sh17a"], "likes": 19, "viewed": 887, "date": "1500185504", "time_retrieved": "2024-06-20T18:58:44.463896", "image_code": "// [SH17A] Starfall / minimal KaliSet by unbird\n// Someone complained about the load of comments, so here's another switch.\n// Bare minimum first, so it fits into the page's view.\n// /*  <- uncomment to switch to commented version further below\n\n\n// \"canonical\" loop: change step size for fidelity and performance\n#define F for(float i = .1; i <.9; i+=.04)\nvoid mainImage( out vec4 f, in vec2 u )\n{\t\n    u /= iResolution.y;\n    f -= f;    \n    F \n    {\n        // vec2 on the next line defines direction and speed of the animation\n        vec3 p = vec3(u + (iTime/i - i)/vec2(30,10), i);\n\t\t            \t\n        p = abs(1.-mod(p, 2.));\n        float a = length(p),\n              b,\n              c = 0.;\n        F\n          p = abs(p)/a/a - .57,   // <- Kali magic constant (between .5 .. .6 gives good results)\n          b = length(p),\n          c += abs(a-b),\n          a = b;        \n        \n        c*=c;\n                \n        f += c*vec4(i, 1, 2, 0) / 3e4 ; // <- overall scaling constant, play here if you're \"blind\"\n    }\t\n}\n\n// - Thanks to Bananaft for the comma trick in the inner loop.\n// - Cleaned a bit and commented the knobs for deadline (only short version above)\n\n\n// careful: switch comment, don't touch\n/*/\n// careful: switch comment, don't touch\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// \n// [SH17A] Starfall / minimal KaliSet\n// Shadertoy 2017 Competition contribution\n// by unbird\n// July 2017\n// License : Use at your own risk, do whatever you want, gimme the least headache license 1.0.\n//\n// Original used: \n// Magic Fractal by dgreensp \n// https://www.shadertoy.com/view/4ljGDd\n// I would like to thank dgreensp for this pearl.\n// It's a bare Kaliset variant, has little fluff, so I chose this to work from.\n// He didn't put a license, so I hope it's ok.\n// \n// I left the original comments somewhat, marked as //--\n// \n// \n// Goal: \n// Meteorite/Shooting star storm animation \n// 1Get it down to reach the 280 character limit (competition rule round 1)\n// Mostly code jugglery, renaming, inlining etc. so far\n// I now got it down, though saving more space would let me play with polishing/effects.\n// \n//\n// Current problems:\n// - Delicate. No convincing central knob (and too many) or even autoexposure. \n//   Missing the spot means black or white.\n// - Potentian platform problems. Not yet run on different hardware/compilers, need feedback.\n//   Here NVidia GTX 960.\n// - Still too big... Nope, as of now at 280... Hooray. But it looks boring.\n//   The pow accentuation was better, but maybe one can fake something else.\n// - Minor: Initial looks regular, needs about 15 sec to disperse the planes.\n//          I can't use offsets now.\n// - It's messy, but hey.\n// \n// \n// Reference: Technical/math read about Kaliset : http://casual-effects.blogspot.ch/2013/08/starfield-shader.html\n//            \n// History:\n// 2017-07-15 Created. Brought down to 320 chars.\n// 2017-07-16 Cleanup, somments, further reductions. 302 chars.\n//            Oh. Wow I have 280 chars!!!\n\n\n  // <- put switch comment start here (/*) for sompetition vs older, more convenient code later\n\n// Attempt at a \"canonical\" loop. Idea: provides approx. unit range (without surprises). \n// Loop count/resolution controlled through stepsize (last constant). I nest then two of them.\n// \n// Also performance control. Increase step size if it runs too slow for you.\n#define F for(float i = .1; i <.9; i+=0.04){\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\t\n    u = u.xy / iResolution.yy;\n    \n    //uv.x = (uv.x - 1.0)*(1.0 + uv.y*uv.y * 0.4) + 1.0;\n    //--scroll a certain number of screenfuls/second\n    //uv.y += iTime*vec2(-0.1,0.05);\n    \n    // Clear. \n    f *= 0.;\n    \n    // I'd like to add background (planet/atmosphere) but I got no place yet.\n \n\n    // Here I eliminated a 3D rotation. \"Expensive\" source code wise,\n    // Doesn't seem to be needed. Problem: Takes some time to \n    // \"mix the planes\" at the start.\n    //vec3 p = 0.5*M*vec3(uv, z);\n\n\n    // No longer needed, time is used only once, so inlined\n    // float t = .1 * iTime;\n    \n    \n    // outer/planes loop\n    //for(float i = 0.1; i <= 0.9; i+= 0.05)\n      F  \n    //{\n        // \n        //\n        // scaling the planes, including \"perspective\" (/i)  \n        vec3 p = vec3(u + (.1 * iTime/i - i) * vec2(.4,.5), 0\n                          //sin(t*.4)*.2  // <- wobbling z gives the stars some \"burning\". Too costly for now\n                          );\n        \n        // abs is enough\n        //p = 1. - abs(1. - mod(p, 2.));\n    \tp = abs(1.-mod(p, 2.));\n\n        float a = length(p),\n              b = a,\n              c = 0.;\n        //--This is the fractal.  More iterations gives a more detailed\n        //--fractal at the expense of more computation.\n        F\n        //{\n          //--The number subtracted here is a \"magic\" paremeter that\n          //--produces rather different fractals for different values.\n            \n\t\t  // The magic number below (the constant) controls the overall shape. \n          // Again somewhat delicate: Viable values aroung 0.5..0.6. \n          // Annoyingly, those two numbers \n          p = abs(p)/(a*a) - .57;    \n          b = length(p);\n          c += abs(a-b);\n          a = b;\n    \n          // tricky problem: can I remove a variable here ? it's all interlocked it seems.\n              \n        }\n        \n        // Nope, if I clamp the thing is gone, and I somehow need pow though to accentuate.\n\t\t// I need stats to normalize this :P\n        //v = clamp(v, 0., 1.);\n        \n\t\t// Accentuate. Disable for now, too costly.\n\t\t//c = pow(c, 5.);\n\t\t// If you enable this, choose 4e-4 for the later constant\n        //c*=c;\n\n        f.rgb +=                   \n                 // Color. This sort of gives a fiery fireball storm.\n                 // Not what I'm after, but it's a start.\n                 vec3(c, .5*c, i * c) \n                 // Here's currently the \"central\" knob, a scale constant. Play here if you're blind.\n                 // division saves 1 char\n                 / 4e2;\n             \t \n    }\n\t\n}\n\n// careful: switch comment, don't touch\n/*\n// careful: switch comment, don't touch\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// working, older variant.\n\n\nfloat finish (float x)\n{\n    x *= 0.3;\n    x = pow(x, 5.0);\n    //result = pow(result, 5.);\n    //result -= 0.5;\n    return x-10.0;\n}\n\nfloat m(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1. - abs(1. - mod(p, 2.));\n    \n    float r = length(p),\n          s = r,\n          t = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < 12; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(r*r) - 0.57;\n      s = length(p);\n      t += abs(s-r);\n      r = s;\n    }\n\n    return t;\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n\t//vec2 u = fragCoord.xy / iResolution.yy;\n    u = u.xy / iResolution.yy;\n    \n    //uv.x = (uv.x - 1.0)*(1.0 + uv.y*uv.y * 0.4) + 1.0;\n    // scroll a certain number of screenfuls/second\n    //uv.y += iTime*vec2(-0.1,0.05);\n    \n    \n    float t = 0.1 * iTime;\n    float z = t*0.01;\n    z = sin(t*0.4)*0.2;\n\tf *= 0.;\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    \n    //vec3 p = 0.5*M*vec3(uv, z);\n    \n    \n    for(float i = 0.1; i <= 0.9; i+= 0.05)\n    {\n        vec2 xy = u + i * vec2(11.,-26.);\n        xy.xy += t*0.05/i;        \n        vec3 p = 0.5*vec3(xy, z);\n        \n        p *= 1.1;\n        p.yz += 2.;        \n        \n        float v = m(p);\n        v = pow(v, 3.0);        \n        f.rgb += 0.00001 * v * mix(vec3(1.,1.,.8), vec3(.3, .1, .2), i);\n    }\n        \n     \n\t\n}\n/* */", "image_inputs": [{"id": "4dXSDS", "previewfilepath": "https://soundcloud.com/jensemann-jr/depeche-mode-waiting-for-the", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jensemann-jr/depeche-mode-waiting-for-the", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSBRG", "name": "Chebyshev Voronoi", "author": "Ebanflo", "description": "I'm surprised I haven't seen anything like this on the site yet, so I thought I'd do it. ", "tags": ["2d", "voronoi", "worley", "chebyshev"], "likes": 1, "viewed": 500, "date": "1501471767", "time_retrieved": "2024-06-20T18:58:44.464903", "image_code": "#define pi 3.141592654\n\nvec2 hash22(vec2 p)//Dave Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash32(vec2 p)//Dave Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat chebyshevMetric(vec2 a, vec2 b){return max(abs(a.x - b.x), abs(a.y - b.y));}\n                    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 10.0;\n    uv += 2.0;\n    float d0 = 9e9;\n    vec2 p0;\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++){\n            vec2 p = floor(uv) + vec2(i, j);\n            vec2 h = hash22(p);\n            vec2 g = p + .5 + .5 * sin(iTime * h);\n            float d = chebyshevMetric(uv, g);\n            if(d < d0){d0 = d; p0 = p;}\n        }\n    }\n    fragColor.xyz = hash32(p0);\n    fragColor.xyz /= fragColor.x + fragColor.y + fragColor.z;\n    fragColor.xyz = pow(fragColor.xyz, vec3(2.0 * d0));\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSBWm", "name": "Digital Cell", "author": "cdata", "description": "This is a prototype for a POI indicator system.", "tags": ["2d", "random", "glow", "organic", "ui", "cell", "poi"], "likes": 0, "viewed": 380, "date": "1500585820", "time_retrieved": "2024-06-20T18:58:44.465908", "image_code": "#define PI 3.14159\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nvec4 circle(vec2 uv, vec2 center, float radius) {\n    vec2 pos = uv - center;\n    float dist = radius - length(pos);\n    float circle = step(0.0, dist);\n    \n    return vec4(circle);\n}\n\nfloat random(float index) {\n    float row = mod(index, 1.0);\n    float col = (mod(index, 100.0) - row) / 100.0;\n    vec2 samplePos = vec2(col, row);\n    \n    return texture(iChannel0, samplePos).r;\n}\n\nfloat tick(float duration) {\n    return mod(iTime, duration) / duration;\n}\n\nvec2 interpolate(vec2 start, vec2 end, float ease) {\n    return start * (1.0 - ease) + end * ease;\n}\n\nfloat interpolate(float start, float end, float ease) {\n    return start * (1.0 - ease) + end * ease;\n}\n\nvec2 nucleusPosition() {\n    float interval = 5.0;\n    float index = floor(iTime / interval) * 2.0;\n    \n    vec2 pos0 = vec2(random(index), random(index + 1.0)) * 0.2 + 0.4;\n    vec2 pos1 = vec2(random(index + 2.0), random(index + 3.0)) * 0.2 + 0.4;\n    \n    float ease = quadraticInOut(tick(interval));\n    \n    return interpolate(pos0, pos1, ease);\n}\n\nfloat nucleusSize() {\n    float interval = 1.75;\n    float index = floor(iTime / interval) * 3.0;\n    float ease = quadraticInOut(tick(interval));\n    float third = 1.0/3.0;\n    \n    float radius0 = random(index) / 25.0 + third;\n    float radius1 = random(index + 3.0) / 25.0 + third;\n    \n    return interpolate(radius0, radius1, ease);\n}\n\nfloat circularInnerGlow(vec2 uv, vec2 center, float radius) {\n   \tvec2 pos = uv - center;\n   \treturn (1.0 - step(radius, length(pos))) * length(pos); \n}\n\nvec4 cellWall(vec2 uv) {\n    vec2 innerPos = vec2(\n        sin(iTime / 5.0 * PI),\n        cos(iTime / 7.0 * PI)) * 0.01 + 0.5;\n    \n    vec4 outerline = circle(\n        uv,\n        vec2(0.5),\n        0.5);\n\n    vec4 innerline = circle(\n        uv,\n        innerPos,\n        0.475);\n    \n    return outerline - innerline;\n}\n\nfloat pulse(vec2 uv) {\n    float interval = 2.0;\n    float time = tick(interval);\n    float ease = cubicOut(time);\n    \n    float radius = 0.5 * ease;\n    vec2 pos = vec2(0.5);\n    float dist = distance(uv, pos);\n    \n    vec4 shape = circle(uv, pos, radius);\n    \n    float glow = step(dist, radius) * dist * 2.0;\n    float alpha = 1.0 - ease;\n    \n    float thickness = (0.5 - length(uv - pos)) * 3.0;\n    float background = \n        (length(circle(uv, pos, 0.5)) + thickness) * 0.25;\n    \n    return glow * alpha + background;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = nucleusPosition();\n    float size = nucleusSize();\n    \n    vec4 nucleus = circle(\n        uv,\n        pos,\n        size);\n    \n    vec4 color = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n    vec4 wall = cellWall(uv);\n    vec4 cell = nucleus + wall;\n    float glow = circularInnerGlow(uv, pos, size);\n    \n    fragColor =\n        mix(cell * color, cell, 0.6) +\n        wall * 0.2 +\n        glow * 0.75 +\n        max(pulse(uv) - length(cell), 0.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSBWw", "name": "Summertime", "author": "lordjone", "description": "Based on the great works of other talented coders, this is my farewell ticket for my company :)\nI hope you like it,\n\nCheers!", "tags": ["sea", "sun", "ocean", "stars", "rayleigh", "gerstner"], "likes": 11, "viewed": 1308, "date": "1500544622", "time_retrieved": "2024-06-20T18:58:46.412518", "image_code": "/*\n * \"Summertime\" by Diego Rodriguez aka Inferno - 2017\n * Based on \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * https://www.shadertoy.com/view/Ms2SD1\n * \n * Sun and Sky based on \"Two lines atmospheric scattering\" by Bananaft\n * https://www.shadertoy.com/view/MdtXD2\n *\n * Starz based on \"Star Nursery\" by Dave_Hoskins\n * https://www.shadertoy.com/view/XsfGzH\n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: drodrigu86@gmail.com\n */\n\n#define NUM_STEPS 15\n#define PI\t \t3.141592\n#define EPSILON 1e-3\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\n#define NUM_WAVES 9\n#define SEA_SPEED 0.26\n#define SEA_FREQ 0.8\n\nfloat SEA_HEIGHT = 0.019;\nfloat SEA_STEEPNESS = 0.1;\n\nconst vec3 SEA_WATER_COLOR = vec3(0,0.22,0.33);\nconst vec3 SEA_WATER_DEPTH_COLOR = vec3(0.0,0.22,0.83);\n\nvec3 SUN_DIR = normalize( vec3(0.0,0.0,1.0) );\n\n#define SEA_CHOPPY 2.0\n#define ITER_FRAGMENT 12\n#define SEA_TIME (iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nstruct Wave \n{ \n    vec2 direction;\n    float steepness;\n    float amplitude;\n    float frequency;\n    float speed;\n};\n\nWave[NUM_WAVES] waves;    \n\n// math\nmat3 fromEuler(vec3 ang) \n{\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\nfloat hash( vec2 p ) \n{\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) \n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat star_hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat star_noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( star_hash(n+  0.0), star_hash(n+  1.0),f.x),\n                    mix( star_hash(n+ 57.0), star_hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\n\nfloat sea_octave(vec2 uv, float choppy) \n{\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_detailed(vec3 p) \n{\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) \n    {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.66; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) \n{\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) \n{    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// ambient\nvec3 getAmbientColor(vec3 rd) \n{\n    rd.y = max(rd.y,0.0);\n    \n    vec3 col = vec3(0.0);\n    \n    float sun = max(1.0 - (1.0 + 10.0 * SUN_DIR.y + 1.0 * rd.y) * length(rd - SUN_DIR), 0.0);\n    float falloff = mix(0.1, 0.3, sun) * pow(1.0-rd.y,12.0) * (1.6-SUN_DIR.y);\n    float kOrbit = pow(SUN_DIR.y,0.03);   \n    \n    sun += falloff;\n    sun *= kOrbit;\n    \n    float h = mix(0.3, 1.33, kOrbit); \n\n    col += mix(vec3(0.3984,0.5117,0.7305), vec3(0.7031,0.4687,0.1055), sun)\n              * ( (0.5 + pow(SUN_DIR.y,0.4) ) * (h-rd.y) \n                 + pow(sun, 5.2) * SUN_DIR.y * (5.0 + 15.0 * SUN_DIR.y)\n                );\n    \n#define time (iTime+46.0)  \n    // starz\n   \tfloat v = 1.0/( 2. * ( 1. + rd.z ) );\n\tvec2 xy = vec2(rd.y * v, rd.x * v);\n    rd.z += time*.002;\n    float s = noise(rd.xz*134.0);\n\ts += star_noise(rd.xz*370.);\n\ts += star_noise(rd.xz*870.);\n\ts = pow(s,19.0) * 0.00000001 * max(rd.y, 0.0);\n\tif (s > 0.0)\n\t{\n\t\tvec3 backStars = vec3((1.0-sin(xy.x*20.0+time*13.0*rd.x+xy.y*30.0))*.5*s,s, s); \n\t\tcol += (1.0 - kOrbit) * backStars;\n\t}\n    \n    return col;\n}\n\n// sea\nvoid fill_waves(int index, int count, \n                float steepness, float freq, float amp, float speed, \n                float kFreq, float kAmp, float kSpeed,\n                vec2 direction, in mat2 directionTransform)\n{\n    for(int i=index; i < count; ++i)\n    {\n        waves[i] = Wave(normalize(direction), steepness/(amp*freq), amp, freq, speed);\n        \n        // update\n        direction *= directionTransform;\n        freq *=kFreq;\n        amp *= kAmp;\n        speed *= kSpeed;\n    }\n}\n\nvoid initWaves()\n{\n    vec2 direction = vec2(-1.0, 0.0);\n    float fwaves = float(NUM_WAVES);\n    \n    float steepness = SEA_STEEPNESS/fwaves;\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float speed = SEA_SPEED;\n    \n    float angle = -2.0*PI/fwaves;\n    float cosa = cos(angle);\n    float sina = sin(angle);\n    mat2 directionTransform = mat2(cosa, sina, -sina, cosa);\n    \n    int lowWaves = int(0.5*fwaves);\n    int highWaves = NUM_WAVES - lowWaves;\n    \n    // Low freq waves\n    fill_waves(0, lowWaves, steepness, freq, amp, speed, 0.66, 1.9, 0.33, direction, directionTransform);\n    \n    // High freq waves\n    fill_waves(lowWaves, NUM_WAVES, steepness, freq, 0.001, speed, 1.33, 1.43, 0.99, direction, directionTransform);\n}\n\nvec3 getSeaColor(vec3 origin, vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) \n{  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getAmbientColor(reflect(eye,n));    \n    vec3 refracted = SEA_WATER_COLOR + diffuse(n,l,80.0) * SEA_WATER_DEPTH_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_DEPTH_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;  \n}\n\n// tracing\nvec3 gerstner(in vec3 p)\n{\n    vec3 g = vec3(p.xz, 0.0);\n    \n    const int len = waves.length();\n    vec3 acc = vec3(0.0);\n    for(int i = 0; i < len; i++) \n    {   \n        Wave wave = waves[i];\n        float period = wave.frequency * dot(wave.direction, g.xy) + iTime * wave.speed;\n        float offset = wave.amplitude * wave.steepness * cos( period );\n        acc.x += offset * wave.direction.x; \n        acc.y += offset * wave.direction.y;\n    \tacc.z += wave.amplitude*sin( period );\n    }\n    \n    g += acc;\n    \n    return g;\n}\n\nvec3 gerstner_normal(in vec3 p)\n{\n    vec2 uv = p.xz; \n    vec3 n = vec3(0.0);\n    \n    const int len = waves.length();\n    for(int i = 0; i < len; i++) \n    { \n        Wave wave = waves[i];\n        float period = wave.frequency*dot(wave.direction, uv) + iTime * wave.speed;\n        float WA = wave.frequency*wave.amplitude;\n        float C = cos(period); \n        float S = sin(period);\n        float WAC = WA*C;\n        \n\t\tn.x += wave.direction.x * WAC;\n        n.y += wave.direction.y * WAC;\n        n.z += wave.steepness * WA * S;\n    }\n    \n    n.x = - n.x;\n    n.y = - n.y;\n    n.z = 1.0 - n.z;\n    \n    return normalize(n.xzy);\n}\n\nvec3 gerstner_noise_normal(vec3 g, float eps)\n{   \n    // noise normal\n    vec3 n;\n    n.y = map_detailed(g);    \n    n.x = map_detailed(vec3(g.x+eps,g.y,g.z)) - n.y;\n    n.z = map_detailed(vec3(g.x,g.y,g.z+eps)) - n.y;\n    n.y = eps;\n    n = normalize(n);\n    \n    // gerstner normal\n    vec3 gn = gerstner_normal(g).xzy;\n    \n    // mix normals\n    n.x += gn.x;\n    n.y += gn.y;\n    n.z *= gn.z;\n    \n    return normalize(n);\n}\n\nvec3 getNormal(vec3 p, float eps) \n{\n    vec3 n;\n    n.y = p.y - gerstner(p).z;    \n    n.x = p.y -gerstner(vec3(p.x+eps,0.0,p.z)).z - n.y;\n    n.z = p.y -gerstner(vec3(p.x,0.0,p.z+eps)).z - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nvoid gerstner_tracer(vec3 ori, vec3 dir, out vec3 p)\n{\n    float tm = 0.0;\n    float tx = 1000.0;\n    vec3 pos = ori + dir * tx;\n    vec3 g = gerstner(pos);\n    float hx = pos.y - g.z;\n    if(hx > 0.0)\n    {\n        p = g.xzy;\n        return;\n    }\n    \n    pos = ori + dir * tm;\n    float hm = pos.y - gerstner(pos).z;    \n    float tmid = 0.0;\n    g = vec3(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) \n    {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;             \n        g = gerstner(p);\n    \tfloat hmid = p.y -g.z;\n\t\tif(hmid < 0.0) \n        {\n        \ttx = tmid;\n            hx = hmid;\n        } \n        else \n        {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    \n    p = g.xzy;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // uv map\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n\n    // sun\n    const float kSpeed = 0.02;\n    const float period = 2.0*PI;\n    const float gamma = kSpeed*period;\n    float alpha = gamma*iTime;\n    float sine = sin(alpha);\n    float inOrbit = sine > 0.0 ? 1.0 : 0.0;\n    \n    float sunAngle = -alpha;\n    mat3 sunRotation = fromEuler( vec3(0.0, sunAngle, 0.0) );\n    SUN_DIR = inOrbit*normalize(sunRotation * SUN_DIR) + (1.0 -inOrbit)*vec3(0.0);\n    \n    //sea\n    float amount = max(sine, 0.0);\n    SEA_HEIGHT = mix( 0.022, 0.099, amount );\n    SEA_STEEPNESS = mix( 0.1, 1.0, amount );\n    initWaves();\n    \n    // ray  \n    vec3 ang = vec3(0.0, iMouse.y*0.01, iMouse.x*0.01);\n    vec3 ori = vec3(0.0,3.0,5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    gerstner_tracer(ori, dir, p);\n    vec3 dist = p - ori;\n    //vec3 n = gerstner_normal(p);\n    //vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 n = gerstner_noise_normal(p, dot(dist,dist) * EPSILON_NRM);\n    \n    // color\n    vec3 color = mix(\n        getAmbientColor(dir),\n        getSeaColor(ori, p,n,SUN_DIR,dir,dist), \n    \tpow(smoothstep(0.0,-0.05,dir.y),0.2));\n    \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSBzm", "name": "shader challenge", "author": "bezo97", "description": "yes", "tags": ["challenge"], "likes": 4, "viewed": 103, "date": "1499864009", "time_retrieved": "2024-06-20T18:58:46.412518", "image_code": "float agak = 7.0f;\nfloat radius;//iResolution.y/2.2f;\n\n#define CS(a) vec2(cos(a),sin(a))\n#define cross(a,b) (a.x*b.y-b.x*a.y)\n//thanks @FabriceNeyret2 for the suggestion^\n\nvec3 backColor = vec3(0.05,0.05,0.15);\nvec3 insideColor = vec3(1.0,0.7,0.5);\n\nfloat intersect(vec2 csucs1, vec2 csucs2, vec2 p)\n{\n    vec2 mid=-(csucs1+csucs2)*100.0;//far away\n    \n    vec2 s1 = csucs2-csucs1;\n    vec2 s2 = p-mid;\n    vec2 s3 = csucs1-mid;\n    \n    float s = cross(s1,s3)/cross(s1,s2);\n    float t = cross(s2,s3)/cross(s1,s2);\n    \n    if (s >= 0.0f && s <= 1.0f && t >= -0.1f && t <= 1.1f)\n    {\n        // Collision detected\n        vec2 inters = csucs1+t*s1;\n       \tfloat len = length(inters-p);\n        return ((len<10.0f&&len>7.0f)||(len<3.0f&&len>0.0f))?-1.0:(len>=3.0&&len<7.0)?-2.0:len;\n        //-1:white, -2:black\n    }\n\n    return 0.0f; // No collision\n}\n\nvec3 f(vec2 pos, float t)\n{\n    vec2 mid = iResolution.xy/2.0f;\n    \n    float len = length(pos-mid);\n    if(len>radius+25.0f)\n\t\treturn backColor;\n    if(len>radius+20.0)\n\t\treturn vec3(1.0f);\n    \n    int intersCnt=0;\n    bool white=false;\n    float ramp = 0.0f;\n    for(float ag=0.0f;ag<agak;ag+=1.0f)\n    {\n        float agAngle=3.141592f/2.0f+t - ag*2.0f*3.141592f/agak;\n        vec2 csucs=radius*CS(agAngle);\n        vec2 csucsNext=radius*CS(agAngle-3.0f * 2.0f*3.141592f/agak);\n        \n        float result = intersect(csucs, csucsNext, pos-mid);\n        ramp=max(ramp,result);\n        if(result == -2.0f)\n            return vec3(0.0f);\n        if(result == -1.0f)\n        {\n            if(len > radius/2.2)\n            \twhite=true;\n            else\n                return vec3(1.0f);\n        }\n        else if(result != 0.0f)\n            intersCnt++;\n    }\n    \n    float darken = ramp*ramp/(radius*radius*0.8f);\n  \treturn white?vec3(1.0f-darken):insideColor*(0.75f-float(intersCnt)/4.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    radius=iResolution.y/2.5f;\n    \n    vec3 colorsum = vec3(0.0f);//aa\n    for(float aax = -1.0f; aax<1.0f;aax+=0.2f)\n    {\n        for(float aay = -1.0f; aay<1.0f;aay+=0.2f)\n    \t{\n            float aar = sqrt(aax*aax+aay*aay);\n        \tcolorsum += f(vec2(fragCoord.x+aax,fragCoord.y+aay), (-iTime)/10.0)*(1.0f-aar);\n    \t}\n    }\n    fragColor = vec4(colorsum/20.0f,1.0f);\n        \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSBzW", "name": "voronoi tunnel", "author": "public_int_i", "description": "voronoi tunnel", "tags": ["voronoi", "tunnel"], "likes": 2, "viewed": 424, "date": "1499686607", "time_retrieved": "2024-06-20T18:58:46.412518", "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    u = u-iResolution.xy*.5;\n    u = vec2(abs(atan(u.x,u.y)),mod(log(length(u))+iTime,6.))*100.;\n    #define l(i) length(fract(abs(u)*.01+fract(i*vec2(1,8))+cos(u.yx*.024+i*8.))-.5)\n\to += min(l(.6),l(.1))*1.66-o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSfWD", "name": "Tree Vines", "author": "Ruzzyr", "description": "Another 2 hour fiddle. Using relatively simple raymarching. Inspired by trees.", "tags": ["raymarching", "simple", "tree"], "likes": 10, "viewed": 283, "date": "1500378463", "time_retrieved": "2024-06-20T18:58:46.412518", "image_code": "#define Z(n) mat2(cos(n), -sin(n), sin(n), cos(n))\n#define theme(x) mix(vec4(.05, .24, .3, 1.), vec4(.27, .64, .28, 1.), x)\n#define r iResolution.yx\nvoid mainImage( out vec4 f, in vec2 c )\n{\n\tvec2 u = c.yx*2. / r;\n    float j = ceil(u.x), t = 99., D, a = 5.;\n    u.x = fract(u.x);    \n\n    u = u*2.-1.;\n\n    vec3 o = vec3(0.,0.,-4.), d = vec3(u,1.),p,s;\n    for (; a <16.; a++)\n    {\n        s.xy = Z(a*j)*vec2(cos(u.y*3.), \n                      sin(u.y*2.+a+iTime*2.))*1.4;\n        s.z = 0.25;\n        D = 0.;\n        for (int i = 0; i < 10; i++)\n        {\n            p = o + D*d;\n\n            D += length(p.xz - s.xy) - s.z;\n        }\n        t = min(t,D);\n\n    }\n\tt=2./(t*t);\n    f = theme(smoothstep(0.9, 0., c.y/r.y))*0.2;\n    f += mix(theme(c.y/r.y)*6., vec4(t),1./(1.+t));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSfWW", "name": "Holomorphic checkerboard", "author": "etale_cohomology", "description": "Fork of AA Grid https://www.shadertoy.com/view/Md2XWt", "tags": ["math", "tutorial", "checkerboard", "map", "checker", "complex", "conformal", "analysis", "holomorphic"], "likes": 12, "viewed": 384, "date": "1500359832", "time_retrieved": "2024-06-20T18:58:46.679194", "image_code": "// Fork of AA Grid shadertoy.com/view/Md2XWt\n\n// The complex plane, as a black & white grid, under the action of the holomorphic map f : z -> z^2\n\n// Notice how all squares intersect at right angles, even on the deformed parts!\n// A map that preserves angles like that is called a conformal map\n// I think that all conformal functions are holomorphic,\n// and that the converse holds everywhere the Jacobian is invertible\n\n#define HOLOMORPHIC_MAP  // Undefine to see a vanilla grid!\n//#define LINES  // Define to see lines, not a checkerboard!\n\n#define SCALE 4.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE *(2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n\n    #ifdef HOLOMORPHIC_MAP\n    uv = vec2(uv.x * uv.x - uv.y * uv.y, 2. * uv.x * uv.y);  // Holomorphic map f : z -> z^2\n    #endif\n\n    uv.x -= .4 * iTime;  // Move the til2pes along the u-direction, just for teh lulz\n\n    // I don't understand this part at all. Someone care to explain, please?\n    vec2 sine_uv = sin(uv);\n    vec2 jacobian = fwidth(sine_uv);\n\n    #ifdef LINES\n    sine_uv = abs(sine_uv) - jacobian;\n    #endif\n\n    //vec2 uv_aa = smoothstep(-jacobian, jacobian, sine_uv);  // Original version\n    vec2 uv_aa = smoothstep(-1., 1., sine_uv / jacobian);  // Fabrice's version\n    //vec2 uv_aa = sine_uv / jacobian;  // No antialiasing version\n\n    uv_aa = 2. * uv_aa - 1.;  // Remap to [-1;1]\n    float checkerboard = .5 * uv_aa.x * uv_aa.y + .5;  // Combine sine waves and remap to [0; 1]\n    fragColor.rgb = vec3(checkerboard);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSfz3", "name": "polygonal creature", "author": "mahalis", "description": "WIP thing for a Ludum Dare entry", "tags": ["polygon", "vaporwave"], "likes": 21, "viewed": 991, "date": "1501346413", "time_retrieved": "2024-06-20T18:58:47.212629", "image_code": "// -- utility stuff\n\n#define PI 3.14159\n#define TWO_PI 6.28319\n\n#define SIDES 3\n\n// stripes without fmod discontinuity\nfloat smoothStripe(float v, float stripeWidth, float smoothingWidth, float offset) {\n    return smoothstep(-smoothingWidth,smoothingWidth,abs(1. - 2. * fract(v / stripeWidth)) - 0.5 + offset);\n}\n\n// rotate p by a\nvec2 r(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\n\n// inscribed polygon\nfloat polygonDistance(vec2 p, float r, int sides) {\n    float apothem = r * cos(PI / float(sides));\n    float a = atan(p.x, p.y);\n    float b = TWO_PI / float(sides);\n    return cos(floor(0.5 + a / b) * b - a) * length(p) - apothem;\n}\n\n// repeats the area in positive Y around the number of sectors\nvec2 opRepeatRadial(vec2 p, int sectorCount) {\n    float fSectors = float(sectorCount);\n    float segmentAngle = (floor((atan(p.x, p.y) / TWO_PI - 0.5) * fSectors) + 0.5) * TWO_PI / fSectors;\n    return -r(p, segmentAngle);\n}\n\n\n// -- main\n\nfloat layerValue(vec2 uv, float time) {\n    float sw = 0.1; // smoothing width multiplier\n    float mainDistance = polygonDistance(uv, 0.5, SIDES);\n    float mainStripes = smoothStripe(mainDistance + time * 0.08, 0.1, sw * 3., 0.);\n    float baseCrop = smoothstep(0., -sw * 0.2, mainDistance);\n    float v = baseCrop * max(mainStripes, smoothstep(-sw, 0., mainDistance + 0.05) /* border */);\n    \n    vec2 subspace = opRepeatRadial(vec2(uv.x, -uv.y), SIDES);\n    float v2 = smoothstep(sw * 0.1, 0., polygonDistance(subspace - vec2(0., 0.2 + sin(time) * 0.3), 0.2, SIDES));\n    v *= v2;\n    v = mix(baseCrop * smoothStripe(mainDistance - time * 0.16, 0.2, sw, -0.3), v, v2);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy / iResolution.xy - vec2(0.5));\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 c1, c2, c3;\n    \n\t// mostly green/blue, some purple\n    c1 = vec3(0.05, 0.94, 0.58);\n    c2 = vec3(0.03, 0.47, 0.93);\n    c3 = vec3(0.4, 0.15, 0.95);\n\n    // mostly pink, slightly purple\n/*\n\tc1 = vec3(0.94, 0.05, 0.65);\n    c2 = vec3(0.85, 0.15, 0.35);\n    c3 = vec3(0.4, 0.15, 0.95);\n*/\n\n    // mostly blue, some cyan (thought I was gonna say purple, didnt you?)\n/*\n    c1 = vec3(0.2, 0.05, 0.95);\n    c2 = vec3(0.4, 0.05, 0.9);\n    c3 = vec3(0.25, 0.6, 0.93);\n*/\n    /*\n    c1 = vec3(0.05, 0.4, 0.95);\n    c2 = vec3(0.3, 0.8, 0.6);\n    c3 = vec3(0.05, 0.1, 0.9);\n  */\n    // mostly orange \n    /*\n    c1 = vec3(0.95, 0.6, 0.05);\n    c2 = vec3(0.93, 0.4, 0.03);\n    c3 = vec3(0.8, 0.2, 0.05);\n    */\n    \n    // mostly purple, some blue\n    /*\n    c1 = vec3(0.6, 0.05, 0.93);\n    c2 = vec3(0.4, 0.03, 0.95);\n    c3 = vec3(0.1, 0.4, 0.9);\n*/\n    \n    vec3 v1 = layerValue(uv, iTime) * c1;\n    vec3 v2 = layerValue(uv, iTime * -0.9 + 0.8) * c2;\n    vec3 v3 = layerValue(uv, iTime * 1.1 + 0.3) * c3;\n    \n    vec3 color = v1 + v2 + v3;\n    color *= 1.5;\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2BRc", "name": "Warp Drive / Falling Stars", "author": "Retrotation", "description": "fork of https://www.shadertoy.com/view/XsXBzM", "tags": ["warp"], "likes": 8, "viewed": 1076, "date": "1501475910", "time_retrieved": "2024-06-20T18:58:47.406599", "image_code": "float Cell(vec2 c) {\n    vec2 uv = fract(c);\n    c -= uv;\n    return (3.0 - length(uv)) * step(fract( sin(c.x + c.y*100.0) *1000.0), 0.04); // 3.0 :: star width and fade strength, 0.04 :: star count\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 projection = fragCoord.xy / vec2(1024.0,1024.0); // TEXCOORD divided by image resolution\n    float projX = fract(projection.x) / 1.; // XY direction divided by scale of stars along X\n    float projY = pow(projection.y, 0.014); // 0.014 :: speed1 of stars \n    float time = -iTime; //reverse or forward speed\n    vec3 color;\n    \n    for(int rgb=0; rgb<3; rgb++)\n    {\n        time -= 0.02; // color shift distance\n        vec2 coord = vec2(projY, projX)*256.0; // *512 :: star count, adjust star-count and scale for scaling along Y axis \n        vec2 delta = vec2(time*7.0, 0.0); // time*7.0 :: speed2 of stars, adjust both^^ speeds for length of stars\n        float c = Cell(coord -= delta);\n        c += Cell(coord -= delta);\n        color[rgb]= c * projection.y * 16.0; // fade distance at bottom of screen\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2BRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2BRG", "name": "Temple of Evil", "author": "lsdlive", "description": "This was the primer idea for shadertoy 2017 competition B, but I wasn't satisfied.\n\nThis is the shader, I submit instead : https://www.shadertoy.com/view/Xd2BzG", "tags": ["raymarching", "hglib"], "likes": 2, "viewed": 142, "date": "1500914314", "time_retrieved": "2024-06-20T18:58:51.649327", "image_code": "// Work in progress\n\n\n//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\t // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.) ? -1. : 1.;\n}\n\nfloat square(float x) {\n\treturn x*x;\n}\n\nvec2 square(vec2 x) {\n\treturn x*x;\n}\n\nvec3 square(vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner(vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI + 1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n\t\tfGDFExp(GDFVector17) fGDFExp(GDFVector18)\n\t\tfGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n\t\tfGDFExp(GDFVector11) fGDFExp(GDFVector12)\n\t\tfGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n\t\tfGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n\t\tfGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n\t\tfGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n\t\tfGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n\t\tfGDF(GDFVector17) fGDF(GDFVector18)\n\t\tfGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n\t\tfGDF(GDFVector11) fGDF(GDFVector12)\n\t\tfGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n\t\tfGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n\t\tfGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n\t\tfGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n\t\tfGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c < start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle / 2.;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a, angle) - angle / 2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5) / size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c, vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5) / size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c, vec2(2))*2. - vec2(1);\n\tp -= size / 2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c / 2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5) / size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror(inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p) - dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant(inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal) + offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t}\n\telse {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer(float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r)) {\n\t\treturn min(m, r - sqrt((r - a)*(r - a) + (r - b)*(r - b)));\n\t}\n\telse {\n\t\treturn m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r + a)*(r + a) + (r + b)*(r + b))));\n\t}\n\telse {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound(float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.) / ((n - 1.)*2. + sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.) / 2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n, 2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t}\n\telse {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.) / n / 2.0;\n\t\tcolumnradius = r*sqrt(2.) / ((n - 1.)*2. + sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.) / 2.*r;\n\t\tp.x += -columnradius*sqrt(2.) / 2.;\n\n\t\tif (mod(n, 2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y, columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t}\n\telse {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a, -b, r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r - r / n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r / n;\n\tfloat x = r*sqrt(2.) / n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p - vec2(0.5*r / n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//                           MY_STUFF\n////////////////////////////////////////////////////////////////\n\n\n#define m1 (iMouse.xy / iResolution.xy).x\n#define m2 (iMouse.xy / iResolution.xy).y\n#define m3 (iMouse.zw / iResolution.xy).x\n#define m4 (iMouse.zw / iResolution.xy).y\n\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 amod(vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y), m) - m * .5;\n\treturn vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat sc(vec3 p, float s) {\n\tp = abs(p);\n\tfloat a = max(p.x, p.y);\n\tfloat b = max(p.y, p.z);\n\tfloat c = max(p.z, p.x);\n\treturn min(min(a, b), c) - s;\n\n}\n\n// octohedron\nfloat so(vec3 p, float d) {\n\treturn dot(p, normalize(sign(p + 1e-7))) - d;\n}\n\nfloat map(vec3 p) {\n\tmat2 r = r2d(.1 * iTime);\n    vec3 op;\n\n\t// cheap camera\n\t//p.yz *= r2d(m2 * 3.14);\n    \n    // rotation\n\tp.xz *= r;\n\t//p.xz *= r2d(-.3);\n\n\tfloat plan = p.y + 8.;// texture(iChannel1, p.xz).r;\n\n\t/////// YOUR GEOMETRY HERE ///////\n\n\t// You have to think in reverse to apply operations to the scene.\n\n\t//pMirrorOctant(p.xz, vec2(1., 5.));\n\t\n    op = p;\n    \n    p.y -= 10. + cos(iTime*1.5) * 2.;\n    float d = so(p, 3.);\n    p = op;\n    \n    d = min(d, fBoxCheap(p - vec3(35., -3.3, 0.), vec3(3.)));\n    d = fOpUnionStairs(d, fBoxCheap(p - vec3(40., -6.6, 0.), vec3(3.)), 3.2, 4.);\n    \n    pMirrorOctant(p.xz, vec2(10., 6.));\n    \n\n\tp.x = -abs(p.x) + 15.;\n\n\tp.y -= 3.;\n\tfloat torus = fTorus(p, 1., 2.2);\n\tfloat cylinder = fCylinder(p, 2., 16.) + sin(p.z*10.) * 0.05 + cos(p.x*10.) * 0.05;\n\tfloat cylinder2 = fCylinder(p, 2.2, 1.5);\n\tp.y += 3.8;\n\tfloat box = fBox(p, vec3(3.2));\n\tp.y += 2.5;\n\tfloat box2 = fBox(p, vec3(3.6));\n\n\tfloat box3 = fBox(p - vec2(0., 22.).xyx, vec3(2.7, 1., 2.7));\n\tfloat box4 = fBox(p - vec2(0., 21.).xyx, vec3(2.4, .3, 2.4));\n\n\td = min(d, fOpUnionStairs(cylinder2, torus, .3, 3.));\n\td = fOpUnionRound(box, d, .05);\n\td = min(d, cylinder);\n\td = min(d, box2);\n    \n    //d = min(d, fBox(p - vec2(15. + cos(iTime*0.75) * 4., 0.).xyy, vec3(6., 4., 6.)));\n\n\td = min(d, fOpUnionColumns(box3, box4, .2, 3.));\n    \n    op = p;\n    p.y -= 25.;\n    d = fOpUnionChamfer(d, fHexagonIncircle(p.yzx, vec2(3., 20.)), 1.2);\n    \n    //d = min(d, fBox(p.xyz, vec3(6, 1., 5.)));\n    \n    p=op;\n    \n    p.y += 7.;\n    d = min(d, fBox(p, vec3(10.)));\n\n\n\treturn fOpUnionStairs(plan, d,3., 3.);\n\t\n}\n\nvec3 normal(in vec3 p) {\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx));\n\treturn normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// pseudo free-camera\n    //vec3 ro = vec3(0., 8., 200. * m1), p;\n    \n    vec3 ro = vec3(0., 8., 57.), p;\n\t\n    \n    vec3 rd = normalize(vec3(uv, -1.));\n\tp = ro;\n\n\tint ri;\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tri = i;\n\t\t//p = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001) break;\n\t\tp += d * rd;\n\t\t//t += d;\n\t}\n\n\tvec3 c = vec3(0.2, 0.1, 0.2) + .015 * texture(iChannel1, (.5+uv)*.1).rgb;\n    vec3 c2 = vec3(.1, .1, .2);\n\n\t// lambert : old dos game mode\n\t//c = vec3(0.7, 0.3, 0.3) * max(0., dot(-rd, normal(p)));\n\n\t// normals\n\t//c = normal(p);\n\n\t// distance\n\t//c = mix(vec3(0.9, 0.3, 0.3), c, length(ro - p) * .01);\n\n\n    // highly experimental storm\n    float noisy = texture(iChannel0, vec2(iTime, iTime)).r * .01 * tan(mod(iTime, 30.));\n    c = mix(c2 + noisy, c, float(ri) / 40.);\n    \n    c = c * pow(1. - length(uv), 1./4.);\n    \n    // tiny flickering + scanline\n    c = c + cos(1e3*uv.y) * .02;\n    //c = c + cos(iTime*1e3) * .01;\n    \n    \n    //c = mix(vec3(.1, .1, .2), .1 * vec3(.5, .1, .1), mix(vec3(0.9, 0.3, 0.3), c, float(ri) / 40.));\n    \n\n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dlXDB", "previewfilepath": "https://soundcloud.com/renan-britto-5/e1m8?in=user8060134/sets/brutal-doom", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/renan-britto-5/e1m8?in=user8060134/sets/brutal-doom", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2BRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2BWh", "name": "[SH17A] Filtered Checkerboard", "author": "Klems", "description": "Checkerboard travelling with \"analytical\" filtering.", "tags": ["filtering", "sh17a"], "likes": 10, "viewed": 517, "date": "1500284113", "time_retrieved": "2024-06-20T18:58:51.649327", "image_code": "\n// fab's version, modified to improve the filtering\nvoid mainImage( out vec4 c, vec2 u ) {\n    u += u - (c.xy = iResolution.xy);\n    \n    // trace\n    vec2 p = 2.* vec2( u.x, iTime*3.*abs(u.y) + ( .6 + sin(iTime*.5)*.3 ) *c.x ) / u.y,\n         d = fwidth( p ),\n         f = ceil(p)-.5,\n         m = abs(p-f)-.5+d;\n    \n    c = vec4(mix(mod(f.x+f.y, 2.), // 2*2 pattern\n                 .5,\n                 mix(max(0., max(m/=d, m.y).x), // edge based filtering\n                     1.,\n                     min(1., length(d)*.5)) ) ) // distance based filtering\n        *abs(u.y/c.x/.4); // fog\n}\n\n/* // original, 268 chars\nvoid mainImage( out vec4 c, vec2 p ) {\n    \n    c.xy = iResolution.xy;\n    vec3 n = vec3((p-c.xy*.5)/c.x, .5 + sin(iTime*.5)*.4);\n    \n    float e = 2./n.y;\n    n += n*e;\n\tp = n.xz;\n    p.y += iTime*3.;\n    \n    vec2 m, d = fwidth(p), f = floor(p)+.5;\n    m = (abs(p-f)-.5+d)/d;\n    \n    c = vec4(mix(mod(f.x+f.y, 2.), .5, clamp(max(m.x, m.y), 0., 1.))) / abs(e*.1);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2BWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2Bz3", "name": "Flob Noise", "author": "TinyTexel", "description": "left: flob \nright: white", "tags": ["noise"], "likes": 3, "viewed": 99, "date": "1501457908", "time_retrieved": "2024-06-20T18:58:52.922184", "image_code": "// The MIT License\n// Copyright  2017 Tiny Texel\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nleft: flob \nright: white\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2 = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n\n//float AvgC(float v0, float v1)\n//{\n//    if(v1 < v0)\n//    {\n//        float t = v0;\n//        v0 = v1;\n//        v1 = t;\n//    }\n//    \n//    return (v1 - v0) < (v0 + (1.0-v1)) ? (v0+v1)*0.5 : fract(v0 + (v0 + (1.0-v1)*0.5));\n//}\n//\n//float AvgC2(float v0, float v1)\n//{\n//    if(v1 < v0)\n//    {\n//        float t = v0;\n//        v0 = v1;\n//        v1 = t;\n//    }\n//    \n//    return (v1 - v0) > (v0 + (1.0-v1)) ? (v0+v1)*0.5 : fract(v0 + (v0 + (1.0-v1)*0.5));\n//}\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n\tvec2 c1 = vec2(cos(ang), sin(ang));\n\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\n\nvec2 SmplCircle(float s)\n{\n    return AngToVec(s * Pi2);\n}\n\nfloat FNoise(vec2 uv)\n{\n    float v = Hash12I(uv);\n    \n    float v0 = Hash12I(uv + vec2(-1.0, 0.0));\n    float v1 = Hash12I(uv + vec2( 1.0, 0.0));\n    float v2 = Hash12I(uv + vec2( 0.0,-1.0));\n    float v3 = Hash12I(uv + vec2( 0.0, 1.0));\n \n    float v4 = Hash12I(uv + vec2(-1.0, 1.0));\n    float v5 = Hash12I(uv + vec2( 1.0, 1.0));\n    float v6 = Hash12I(uv + vec2( 1.0,-1.0));\n    float v7 = Hash12I(uv + vec2(-1.0,-1.0));\n    \n    #define f SmplCircle\n    vec2 vec = (f(v0) + f(v1) + f(v2) + f(v3)) * 0.5 + f(v);\n         vec+= (f(v4) + f(v5) + f(v6) + f(v7)) * 0.25;\n    #undef f\n    \n    vec = CmplxMul(vec, iTime);\n\n    float vf = 0.0;\n    \n    vf = atan(vec.x, vec.y) / Pi;\n    //vf = vf * 0.5 + 0.5;// flake noise\n    vf = abs(vf); \n    \n    //vf = acos(vec.x)/Pi;// wtf noise\n    \n    return vf;  \n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    //if(tex.y <= 0.5) uv.y += PixelCount.y * 0.5;\n    \n    float noiseW = Hash12I(uv);\n    float noiseF = FNoise(uv);\n    \n#if 0    \n    if(tex.y > 0.5)\n        outCol = vec4(tex.x > noiseW ? 1.0 : 0.0);// top\n    else\n        outCol = vec4(tex.x > noiseF ? 1.0 : 0.0);// bottom\n#else\n    if(tex.x > 0.5)\n        outCol = vec4(noiseW);// right\n    else\n        outCol = vec4(noiseF);// left\n#endif\n    \n    outCol = vec4(GammaEncode(clamp01(outCol.rgb)), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2Bz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2Bzm", "name": "SH17A failed, :) Spiral", "author": "aiekick", "description": "[SH17A] Spiral", "tags": ["spiral"], "likes": 2, "viewed": 406, "date": "1500917872", "time_retrieved": "2024-06-20T18:58:52.927983", "image_code": "#define E (n=n.zxy, d(p+n)-d(p-n))\n#define t normalize\n\nfloat d(vec3 p)\n{\n    p.xy *= mat2(cos(p.z*=.1),-sin(p.z),sin(p.z),cos(p.z));\n    return 9. - abs(p.y * .5);\n}\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    vec3 \n        n = iResolution,\n        r = t(vec3(g+g-n.xy,n.y)),\n    \tp=n-n; \t\n    p.z = iTime * 15.;\n    for (int i=80;i-->0;n.z=.1,p+=r*d(p)*.3);\n\tf = vec4(1,2,1,1) * d(p - t(vec3(E,E,E)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2Bzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2fDD", "name": "Simple smooth hegaxon primitive", "author": "etale_cohomology", "description": "Fork of Fabrice's https://www.shadertoy.com/view/4scXWS", "tags": ["simple", "math", "tutorial", "distance", "field", "fabrice"], "likes": 1, "viewed": 100, "date": "1500487353", "time_retrieved": "2024-06-20T18:58:53.067809", "image_code": "// Fork of Fabrice's https://www.shadertoy.com/view/4scXWS\n// A simple smooth hexagon primitive\n\n#define HEXAGON_SIZE .8\n\nfloat sdf_hexagon(in vec2 uv, in float size, in vec2 center){\n\tvec2 hexagon_vec = smoothstep(.51, .49, abs(uv - center) * mat2(1, 0, .5, .87) / size);\n\treturn min(hexagon_vec.x, hexagon_vec.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;\n\n    float hexagon_size   = HEXAGON_SIZE;\n    vec2  hexagon_center = .4 * vec2(2.*cos(iTime), sin(iTime));\n    float hexagon = sdf_hexagon(uv, hexagon_size, hexagon_center);\n\n    fragColor.rgb = vec3(hexagon);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2fDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsBfzW", "name": "querre Recursive Filling Curve", "author": "ttoinou", "description": "A few recursives rules about which sides the curve goes from and to generate a nice curve that goes through each sub equerre. I'm not sure the curve is 2D filling the main Equerre (maybe only by taking the incenter point... click on the upper right)\n", "tags": ["triangle", "tiling", "kisrhombille", "reptile", "equerre"], "likes": 12, "viewed": 165, "date": "1499651861", "time_retrieved": "2024-06-20T18:58:54.879861", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \n#define _AB_ (1)\n#define _BC_ (2)\n#define _CA_ (3)\n        \n#define _ALPHA_ _AB_\n#define _BETA_  _BC_\n#define _GAMMA_ _CA_\n        \n#define _REPLACE_(X,Y,Z,T) \\\n        if( Begin == X && End == Y && !operation ) { \\\n            Begin = Z; End = T; operation = true; \\\n        } else if( End == X && Begin == Y && !operation) { \\\n            End = Z; Begin = T; operation = true; \\\n        }\n\n#define _SWAP_(X,Y) _REPLACE_(X,Y,Y,X)\n\n#define _SWAP_KEEP_BETA_ \\\n\t_REPLACE_(_BETA_,_ALPHA_,_BETA_,_GAMMA_) \\\n\t_REPLACE_(_BETA_,_GAMMA_,_BETA_,_ALPHA_) \\\n\n#define _SWAP_KEEP_GAMMA_ \\\n\t_REPLACE_(_GAMMA_,_ALPHA_,_GAMMA_,_BETA_) \\\n\t_REPLACE_(_GAMMA_,_BETA_,_GAMMA_,_ALPHA_) \\\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tint EquerreVersion = 1;\n    vec2 base = vec2(sqrt(3.0),1.0);\n    base *= 1.0;\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1.25;\n    uv *= viewportMagnify;\n    uv += base/2.25;\n    \n    // Base Triangle\n    Equerre Tri;\n    Equerre Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    \n    int Begin = _GAMMA_;\n    int End   = _ALPHA_;\n    bool operation;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        EQUERRE_COMPUTE_DE(Tri);\n        operation = false;\n        \n        if( EQUERRE_COND1(uv,Tri) )\n        {\n            EQUERRE_GET1(Tri_TMP,Tri);\n            \n            _REPLACE_(_ALPHA_,_GAMMA_,_BETA_,_ALPHA_)\n            _SWAP_KEEP_BETA_\n        }\n        else if( EQUERRE_COND2(uv,Tri) )\n        {\n            EQUERRE_GET2(Tri_TMP,Tri);\n            \n            _SWAP_KEEP_GAMMA_\n            _REPLACE_(_ALPHA_,_BETA_,_GAMMA_,_ALPHA_)\n        }\n        else \n        {\n            EQUERRE_GET3(Tri_TMP,Tri);\n            \n            _SWAP_(_GAMMA_,_BETA_)\n                \n            _REPLACE_(_ALPHA_,_BETA_,_BETA_,_GAMMA_)\n            _REPLACE_(_ALPHA_,_GAMMA_,_GAMMA_,_BETA_)\n        }\n        \n        fragColor.rgb = 1.15 - fragColor.gbr;\n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    fragColor.rgb = vec3(1.0);\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale;\n    \n    vec3 EquerreCoeffs = barycentricCoordinate(uv,Tri);\n    vec3 EquerreColor =\n          EquerreCoeffs.x * hash3point(Tri.A)\n        + EquerreCoeffs.y * hash3point(Tri.B)\n        + EquerreCoeffs.z * hash3point(Tri.C)\n    ;//vec3(1.0,0.0,0.0);\n    \n    vec3 EquerreDualColor = vec3(0.0,0.0,0.0);\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    scale /= sqrt(float(nbIterations));\n   \n    #if SHOW_POINTS==1\n    \t#define OPERATION2(x) fragColor.rgb = mix( EquerreColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,x,scale))\n    \n        OPERATION2(Tri.A);\n        OPERATION2(Tri.B);\n        OPERATION2(Tri.C);\n    \n    #endif\n    \n    float k = iTime/1.0*3.14;\n    vec2 mouse = iMouse.z > .5 ?\n          iMouse.xy / iResolution.xy\n        : vec2(1.0/3.0) + 0.15 * vec2(cos(k),sin(k));\n    vec3 coeffs;\n    coeffs.xy = mouse.xy;\n    coeffs.z = 1.0 - mouse.x - mouse.y;\n    if( coeffs.z < 0.0 )\n    {\n        coeffs.x = 2.0;\n        coeffs.y = 1.0;\n        coeffs.z = sqrt(3.0);\n        coeffs /= coeffs.x + coeffs.y + coeffs.z;\n    }\n    \n    #define EQUERRE_CENTER_MIX(T) (T.A * coeffs.x + T.B * coeffs.y + T.C * coeffs.z)\n    vec2 TriCenterMix = EQUERRE_CENTER_MIX(Tri);\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb = mix( EquerreDualColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n           \n    scale = 1.0 / iResolution.y * viewportMagnify;\n    float lineCoeff = 1000.0;\n           \n    \n    \n    #if SHOW_DUAL==1\n    \tEquerre Neighbour;\n    \n        #define OPERATION3(X,Y) \\\n    \t\tlineCoeff = min(lineCoeff,segment(uv,X,Y).x);\n    \n    \tif( Begin == _AB_ || End == _AB_) {\n    \t  EQUERRE_GET_NEIGHBOUR_AB(Neighbour,Tri);\n    \t  OPERATION3(EQUERRE_CENTER_MIX(Neighbour),TriCenterMix);\n    \t}\n    \n    \tif( Begin == _BC_ || End == _BC_) {\n    \t  EQUERRE_GET_NEIGHBOUR_BC(Neighbour,Tri);\n    \t  OPERATION3(EQUERRE_CENTER_MIX(Neighbour),TriCenterMix);\n    \t}\n    \n    \tif( Begin == _CA_ || End == _CA_) {\n    \t  EQUERRE_GET_NEIGHBOUR_AC(Neighbour,Tri);\n    \t  OPERATION3(EQUERRE_CENTER_MIX(Neighbour),TriCenterMix);\n    \t}\n    \n    \tlineCoeff = smoothFunction(lineCoeff/scale);\n    \n    \tfragColor.rgb = mix(\n              fragColor.rgb\n            , EquerreDualColor\n            , clamp(lineCoeff,0.0,1.0)\n        );\n    \n    #endif\n    \n    fragColor.rgb = tanh(fragColor.rgb*2.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBfzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsffW2", "name": "Tiny Checkerboard", "author": "DJDoomz", "description": "(I feel like someone else probably already did this)", "tags": ["3d", "onetweet", "golf"], "likes": 1, "viewed": 433, "date": "1500954236", "time_retrieved": "2024-06-20T18:58:54.879861", "image_code": "//132\nvoid mainImage( out vec4 f,vec2 u )\n{\n\tu=u/iResolution.xy-.5;\n    u = vec2(u.x*35.,9)/(f.a=abs(u.y*9.)-1.)+iTime*4.;    \n    f = sign(sin(u.xyxx))+f.a-1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsffW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjBD1", "name": "[SH17A] Mandelbrot Log Distance", "author": "ttoinou", "description": "Updated [url=https://www.shadertoy.com/view/lllGWH]IQ's Mandelbrot[/url] with Distance Estimator (using dZ/dC), like in [url]https://www.shadertoy.com/view/MttXz8[/url]", "tags": ["mandelbrot", "distance", "sh17a"], "likes": 3, "viewed": 486, "date": "1500315431", "time_retrieved": "2024-06-20T18:58:55.485996", "image_code": "// 269\n// Modified version of inigo quilez - iq/2015\n// https://www.shadertoy.com/view/lllGWH\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 z,  vec2 p )\n{\n    float n = 0.,m; // need them after the loop\n    \n    for(  z -= z;\n           n++ < 99.\n        && m   < 1e7;\n       )\n        // z.xy is Z, z.zw id dZ/dC\n        z = vec4(\n            (z.x*z.x - z.y*z.y)/2. - 2.08 ,\n            z.x*z.y + .6975 ,\n            z.x*z.z-z.y*z.w + 1.,\n            dot(z.xy,z.wz)\n        ),\n\t\tm = length(z.xy +=\n              (p/iResolution.y-.5)*exp(sin(iTime)*4.-3.) // C\n        );\n    \n    // from https://www.shadertoy.com/view/MttXz8\n\t// d(c) = |Z|^2log|Z|/|Z'|\n    // here we take log of 1/d(c) and length(z) instead of length(z.zw)\n    n = log(length(z/m/log(m)));\n    z = .5 + .5*cos( vec4(3,2,7,1)  - n );\n    //z *= sqrt(1.3 - n/8. - sin(iTime)*.5)*1.5; // removes flickering, 2 many chars :-(\n}\n\n/* // 280, mandelbrot formulae is broken\nprecision highp float;\n\nvoid mainImage( out vec4 z,  vec2 p )\n{\n    float n = 0.,m; // need them after the loop\n    \n    for( ; n<99. && m < 3e5; n++ )\n        // z.xy is Z, z.zw id dZ/dC\n        z = vec4(\n            (z.x*z.x - z.y*z.y)/2. - 2.1 ,\n            z.x*z.y + .5 ,\n            z.x*z.z-z.y*z.w + 1.,\n            dot(z.xy,z.wz)\n        ),\n\t\tm = length(z.xy +=\n              (p/iResolution.y-.6)*exp(sin(iTime)*5.-3.) // C\n        );\n    \n    // from https://www.shadertoy.com/view/MttXz8\n\t// d(c) = |Z|^2log|Z|/|Z'|\n    // here we take log of d(c) and length(z) instead of length(z.zw)\n    \n    z = .5 + .5*cos( vec4(3,2,7,1) +\n                    log( m/length(z) * log(m) )\n                   );\n}\n*/\n\n/* // 267 with derivative and optim, without using dZ/dC\nvoid mainImage( out vec4 z,  vec2 p )\n{\n    float n = 0.,m;\n    p = 4. * (p/iResolution.y-.5)*exp(-iTime*.2);\n    \n    for( ; n<99. && m < 1e4; n++ )\n        z = vec4(\n            z.x*z.x - z.y*z.y - 1.26 ,\n            2.*z.x*z.y + 0.34 ,\n            2.*z.x*z.z-z.y*z.w + 2.,\n            2.*(z.x*z.w + z.y*z.z)\n        ),\n\t\tm = length(z.xy+=p);\n    \n    \n    z = .5 + .5*cos( vec4(3,4,11,0) + .05*(n - log2(log2(m))) );\n}\n*/\n/* // 230 optim from IQ original Mandelbrot 2 tweets\nvoid mainImage( out vec4 f,  vec2 p )\n{\n    float n = 0.,m;\n    p = 4. * (p/iResolution.y-.5)*exp(-iTime*.2); \n    vec2 z = p*n;\n    \n    for( ; n<99. && m < 1e4; n++ )\n        z = vec2(\n            z.x*z.x - z.y*z.y -1.26,\n            2.*z.x*z.y + 0.34\n        ) + p,\n\t\tm = dot(z,z);\n    \n    \n    f = .5 + .5*cos( vec4(3,4,11,0) + .05*(n - log2(log2(m))) );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjBRh", "name": "FractalShizzle7", "author": "JulesPommier", "description": "Modification of Fractal Land by Kali (https://www.shadertoy.com/view/XsBXWt)", "tags": ["fractal"], "likes": 2, "viewed": 124, "date": "1499432386", "time_retrieved": "2024-06-20T18:58:56.479997", "image_code": "// \"Fractal Cartoon\" - former \"DE edge detection\" by Kali\n\n// Cartoon-like effect using eiffies's edge detection found here: \n// https://www.shadertoy.com/view/4ss3WB\n// I used my own method previously but was too complicated and not compiling everywhere.\n// Thanks to the suggestion by WouterVanNifterick. \n\n// There are no lights and no AO, only color by normals and dark edges.\n\n// update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\n\n\n//#define SHOWONLYEDGES\n#define WAVES\n//#define BORDER\n\n#define RAY_STEPS 200\n\n#define BRIGHTNESS 2.\n#define GAMMA 1.4\n#define SATURATION 1.5\n//*sin(iTime)+0.659\n\n\n#define detail .001\n#define t iTime*0.5\n\n\n\nconst vec3 origin=vec3(-1.6,1.,0.);\nfloat det=0.0;\n\n\n// 2D rotation function\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat sphereDE(vec3 point, vec3 pos){\n\treturn length(point - pos) -1.;   \n}\n\n// \"Amazing Surface\" fractal\nvec4 formula(vec4 p) {\n   \t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\n\t\t//p.xz = abs(sin(p.xz+1.))-abs((p.xz-1.))-mod(p.xz, p.y);\n\t\tp.y-=.25;\n\t\t//p.xz*=rot(radians(35.*sin(iTime)+50.)); //Hier Sinus rein!\n    \tp.xy*=rot(radians(20.));\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\n\n\n// Distance function\nfloat de(vec3 pos) {\n#ifdef WAVES\n\t//pos.y+=sin(pos.z-t*6.)*.15; //waves!\n    pos.y+= tan(pos.z * 0.1); //waves!\n#endif\n    pos.z = mix(pos.z, pos.z*(4. - min(3.1,iTime)), max(iTime - 1., 1. )); //Zeit Raum Kontinuum brechen\n\t//float hid=0.;\n\tvec3 tpos=sin(pos);\n\ttpos.z=abs(3.-mod(tpos.z,6.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\t/*float ro=max(abs(pos.x+1.)-.3,pos.y);\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y));\n\tpos.z=abs(.25-mod(pos.z,.5));\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y));\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,pos.y));MACHT DEN WEG WEG!!!*/\n\t\n\n    \n\treturn fr;\n}\n\n\n// Camera path\nvec3 path(float ti) {\n\tti*=1.5;\n\tvec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\n\treturn p;\n}\n\n// Calc normals, and here is edge detection, set to variable \"edge\"\n\nfloat edge=1.5;\nvec3 normal(vec3 p) { \n\tvec3 e = vec3(0.0,det*5.,0.0);\n\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\tfloat d=de(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.55)*15.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n\n\n\n// Raymarching and 2D graphics\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n    \n    \n\tedge=2.0;\n\tvec3 p, norm;\n\tfloat d=100.;\n\tfloat totdist=0.;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<(30.0/**cos(iTime)+35.*/)) { //HIER *sin(iTime)+35.\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*exp(.13*totdist);//det=tan((detail /* tan(iTime)*10.*/*exp(.23*totdist)));\n            //det=(10.*sin((detail/**sin(iTime)*10.*/*exp(.13*totdist)))+10.);\n\t\t\ttotdist+=d; \n\t\t}\n\t}\n\tvec3 col=vec3(0.);\n\tp-=(det-d)*dir;\n\tnorm=normal(p)*dir;\n    \n    \n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(edge); // show wireframe version\n#else\n    if(totdist < pow(t, 3.)){\n    \tcol=(1.-abs(norm))*max(.2,1.-edge*1.6); // set normal as color with dark edges\n        if(totdist > pow(t, 3.5)-1.){\n        \tcol = vec3(0,0,0);   \n        }\n    }\n    else{\n    \tcol = vec3(0.3,0.3,0.3);   \n    }\n\t\n#endif\t\t\n\ttotdist=clamp(totdist,0.,26.);\n\tdir.y-=.02;\n\tfloat sunsize=0.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*5.; // responsive sun size\n\tfloat an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\n\t\n\t// set up background with sky and sun\n\tvec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\n\t\t backg+=vec3(1.,.9,.1)*s;\n\t\t backg=max(backg,sg*vec3(1.,.9,.5));\n\t\n\tcol=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\n\tif (totdist>(35.)) col=backg; // hit background ANIMATE FOR DISTANCE VARIATION *sin(iTime)+35.\n\tcol=pow(col,vec3(GAMMA))*BRIGHTNESS;\n\tcol=mix(vec3(length(col)),col,SATURATION);\n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(length(col));\n#else\n\tcol*=vec3(.2,0.5,.7);\n#endif\n\treturn col;\n}\n\n// get camera position\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 oriuv=uv;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.,-0.05);\n\tfloat fov=2.-max(0.,.7-iTime*.3);\n\tvec3 dir=normalize(vec3(uv*fov,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tvec3 from=origin ;//+ move(dir);\n\tvec3 color=raymarch(from,dir); \n\t#ifdef BORDER\n\tcolor=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\n\t#endif\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjBRy", "name": "[SH17B] Reign of Pharaoh", "author": "lsdlive", "description": "I had no inspiration for the theme at the beginning of the week, finally today I started to scratch some code on shadertoy & experimenting with the HGSDF lib.\n\nI hope, you will like it.\n\nShader accompanied by a soundcloud's music created by \"Theme Cloud\".", "tags": ["raymarching", "temple", "sh17b", "hglib", "egypt"], "likes": 10, "viewed": 435, "date": "1500930982", "time_retrieved": "2024-06-20T18:59:00.831887", "image_code": "// Released\n\n// Changelog\n// 24/07 first draft\n// 24/07 daytime/nighttime\n// 25/07 sun/skynight\n// 25/07 remove the fbm (add nothing to the scene & eat gpu)\n// 25/07 horizon line + moving skynight\n// 25/07 small adjustment\n// 25/07 realeased for the deadline\n\n// First part is the import of HG_SDF lib by Mercury ported by Tom for shadertoy.\n// My code is below the import\n\n\n\n// From: https://www.shadertoy.com/view/Xs3GRB\n//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\t // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.) ? -1. : 1.;\n}\n\nfloat square(float x) {\n\treturn x*x;\n}\n\nvec2 square(vec2 x) {\n\treturn x*x;\n}\n\nvec3 square(vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner(vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI + 1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n\t\tfGDFExp(GDFVector17) fGDFExp(GDFVector18)\n\t\tfGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n\t\tfGDFExp(GDFVector11) fGDFExp(GDFVector12)\n\t\tfGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n\t\tfGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n\t\tfGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n\t\tfGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n\t\tfGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n\t\tfGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n\t\tfGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n\t\tfGDF(GDFVector17) fGDF(GDFVector18)\n\t\tfGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n\t\tfGDF(GDFVector11) fGDF(GDFVector12)\n\t\tfGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n\t\tfGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n\t\tfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n\t\tfGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n\t\tfGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n\t\tfGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n\t\tfGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c < start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle / 2.;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a, angle) - angle / 2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5) / size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c, vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5) / size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c, vec2(2))*2. - vec2(1);\n\tp -= size / 2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c / 2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5) / size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror(inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p) - dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant(inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal) + offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t}\n\telse {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer(float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r)) {\n\t\treturn min(m, r - sqrt((r - a)*(r - a) + (r - b)*(r - b)));\n\t}\n\telse {\n\t\treturn m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r + a)*(r + a) + (r + b)*(r + b))));\n\t}\n\telse {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound(float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.) / ((n - 1.)*2. + sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.) / 2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n, 2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t}\n\telse {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.) / n / 2.0;\n\t\tcolumnradius = r*sqrt(2.) / ((n - 1.)*2. + sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.) / 2.*r;\n\t\tp.x += -columnradius*sqrt(2.) / 2.;\n\n\t\tif (mod(n, 2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y, columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t}\n\telse {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a, -b, r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r - r / n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r / n;\n\tfloat x = r*sqrt(2.) / n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p - vec2(0.5*r / n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\n// For debug\n#define m1 (iMouse.xy / iResolution.xy).x\n#define m2 (iMouse.xy / iResolution.xy).y\n#define m3 (iMouse.zw / iResolution.xy).x\n#define m4 (iMouse.zw / iResolution.xy).y\n\n\n// my helpers\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0 - 2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x),\n\t\tmix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);\n\treturn res*res;\n}\n\nfloat map(vec3 p) {\n\tvec3 op;\n    p.xz *= r2d(.1 * iTime);\n\n\t// pseudo free camera for debug\n\t//p.yz *= r2d(m2 * 3.14);\n\n\t\n\n    // The floor (double floor for small noise + clean opUnionStairs\n\tfloat plan = p.y + 7. + noise(p.xz*.05);\n\tfloat plan2 = p.y + 8.;\n\n\top = p;\n\n\t// cheap & lazy random pyramids\n\tpMirrorOctant(p.xz, vec2(50., 150));\n\tpMirrorOctant(p.xz, vec2(10., 50.));\n\tp.x = abs(p.x) - 100.;\n\tp.z = abs(p.z) - 90.;\n\tfloat d = fOctahedron(p + vec2(0., 20.).xyx, 40.);\n\n\n\tp = op;\n\n    // centered octo\n\tp.y -= 10. + cos(iTime*1.5) * 2.;\n\td = min(d, fOctahedron(p, 3.));\n\tp = op;\n\n    // cheap & lazy stairs\n\td = min(d, fBoxCheap(p - vec3(35., -3.3, 0.), vec3(3.)));\n\td = fOpUnionStairs(d, fBoxCheap(p - vec3(40., -6.6, 0.), vec3(3.)), 3.2, 4.);\n\n    \n    // Here start the temple\n\tpMirrorOctant(p.xz, vec2(10., 6.));\n\n\tp.x = -abs(p.x) + 15.;\n\n    // pillars\n\tp.y -= 3.;\n\tfloat torus = fTorus(p, 1., 2.2);\n\tfloat cylinder = fCylinder(p, 2., 16.);\n\tfloat cylinder2 = fCylinder(p, 2.2, 1.5);\n\tp.y += 3.8;\n\tfloat box = fBox(p, vec3(3.2));\n\tp.y += 2.5;\n\tfloat box2 = fBox(p, vec3(3.6));\n\n\tfloat box3 = fBox(p - vec2(0., 22.).xyx, vec3(2.7, 1., 2.7));\n\tfloat box4 = fBox(p - vec2(0., 21.).xyx, vec3(2.4, .3, 2.4));\n\n\td = min(d, fOpUnionStairs(cylinder2, torus, .3, 3.));\n\td = fOpUnionRound(box, d, .05);\n\td = min(d, cylinder);\n\td = min(d, box2);\n\n\t//d = min(d, fBox(p - vec2(15. + cos(iTime*0.75) * 4., 0.).xyy, vec3(6., 4., 6.)));\n\n\td = min(d, fOpUnionColumns(box3, box4, .2, 3.));\n\n\top = p;\n    \n    // roof\n\tp.y -= 25.;\n\td = fOpUnionChamfer(d, fHexagonIncircle(p.yzx, vec2(3., 20.)), 1.2);\n\n\t//d = min(d, fBox(p.xyz, vec3(6, 1., 5.)));\n\n\tp = op;\n\n    // temple's floor\n\tp.y += 7.;\n\td = min(d, fBox(p, vec3(10.)));\n\n\treturn min(plan, fOpUnionStairs(plan2, d, 3., 3.));\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// pseudo free-camera for debug\n\t//vec3 ro = vec3(0., 8., 200. * m1), p;\n\n\tvec3 ro = vec3(0., 8., 57.), p;\n\tvec3 rd = normalize(vec3(uv, -1.));\n\tp = ro;\n\n\tint ri;\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tri = i;\n\t\tfloat d = map(p);\n\t\tif (d < .001) break;\n\t\tp += d * rd;\n\t}\n\n    float daylight = abs(sin(iTime*.007));\n    vec3 ambiant_color;\n    if(daylight < .8) {\n        ambiant_color = mix(vec3(0.8, .8, .7), vec3(.3, .2, .2), smoothstep(0., .8, daylight));\n    } else {\n        ambiant_color = mix(vec3(.3, .2, .2) , vec3(.2, .2, .4), smoothstep(0.8, 1., daylight));\n    }\n    \n    float tempest_amnt = mix(0.2, 0.01, smoothstep(0., .8, daylight));\n    float apert = mix(3., 1., daylight);\n\n\tvec3 c = ambiant_color + tempest_amnt * texture(iChannel0, (uv - vec2(iTime, .1*cos(iTime*2.)))*.1).rgb;\n\tvec3 c2 = vec3(.1, .1, .2);\n\n    // rendering\n\tc = mix(c2, c, float(ri) / 40.);\n\n    // background\n    if(ri >= 99 && uv.y + uv.x*uv.x*.05 + noise(uv.x)*.01 > -.02) {\n        vec3 stars = c + texture(iChannel2, uv- vec2(iTime*.1, 0.) ).rgb * .2 * daylight;\n        vec3 sun = c + pow(1. - length(uv  - cos((1.+daylight))), 5.);\n        \n        c = mix(sun, stars, smoothstep(.84, 1., daylight));    \n    }\n    \n\tc = c * pow(1. - length(uv), 1. / apert);\n\n\t// tiny flickering + scanline\n\tc = c + cos(1e3*uv.y) * .02;\n\tc = c + cos(iTime*1e3) * .01;\n\n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "XdXSWj", "previewfilepath": "https://soundcloud.com/dfiechter2/pharoah-ramses-ii", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dfiechter2/pharoah-ramses-ii", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjBWm", "name": "Planet Equinox Eclipse", "author": "zproxy", "description": "https://www.shadertoy.com/view/4sjGzc", "tags": ["sun", "space", "stars", "moon", "globe"], "likes": 2, "viewed": 120, "date": "1500739088", "time_retrieved": "2024-06-20T18:59:04.753573", "image_code": "// inspired by Ramon Viladomat\n\n#define DRAW_RED_MAGIC \n//#define DRAW_GREEN_MAGIC \n#define DRAW_BLUE_MAGIC \n#define DRAW_YELLOW_MAGIC \n \n#define PI 3.1415\n#define EPSILON 0.002\n\n// 384,400 km\n#define SATELITE_RADIUS 384.400\n//#define MAGIC_RADIUS\t384.400\n#define MAGIC_RADIUS\t(384.400  + 7.)\n\n// 1,737 km\n#define SATELLITE_RADIUS 1.737\n\n// 6,371 km\n#define PLANET_RADIUS \t6.371\n\n// camera rotation basically means one rotates with a planet.\n// the texture has to also rotate for that effect\n//#define CAM_ROTATION_SPEED 0.01\n// moon is supposed to do a real orbit in 28days\n//#define SAT_ROTATION_SPEED 0.1\n\n//#define CAM_ROTATION_SPEED 0.0\n//#define SAT_ROTATION_SPEED 0.0\n\n#define CAM_ROTATION_SPEED 0.02\n#define SAT_ROTATION_SPEED 0.01\n// if its the same speed. its basically at the same spot.\n// it has to fall back on x axis full circle within 28days\n// yet it has to travel from blue to red in 14 days\n//#define SAT_ROTATION_SPEED 0.1\n//#define SAT_ROTATION_SPEED (CAM_ROTATION_SPEED/28.)\n\n\n\n// ah. so this defines how the shadow should behave, per expected distance of the sun\n#define SOFTSHADOW_BANDWIDTH 0.7\n//#define SOFTSHADOW_BANDWIDTH 0.2\n\n\n\n\n\n// moon pos. can we make it move?\nvec3 ballPos = vec3(0.0, 0.0, 0.0);\n\n///////////////\n// MATERIALS //\n///////////////\n\n\n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\n\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\nvec2 GetNormalMap(in sampler2D s, in vec2 resolution, in vec2 uv)\n{\n\tvec3 eps=vec3(1.0/resolution,0.0);\n\tvec2 norm = vec2(length(texture(s,uv+eps.xz)) - length(texture(s,uv-eps.xz)),\n\t\t\t\t\t length(texture(s,uv+eps.zy)) - length(texture(s,uv-eps.zy)));\n\t\n\treturn norm;\n}\t\n\nvec4 calcColor( in vec3 pos, in vec3 nor, in float material, out vec3 normal )\n{\n\tvec4 materialColor = vec4(0.0);\n\t\n\tvec3 q = pos - mix(ballPos,vec3(0.0),material);\n\tfloat radius = mix(0.5,3.0,material);\n\tvec2 angles = vec2(atan(abs(q.z)/abs(q.x)),acos(q.y/radius));\n\t\n\tfloat mixer = step(1.0,material);\n\t\n\t\n    // material ?\n    //materialColor = vec4(0.01,0.01,0.7*material, 0.01);\n    \n    // float1 is earth.\n    // float0 is moon?\n    if (material < 0.5)\n    \t//materialColor = vec4(material,material,1.0-material, 0.01);\n        //materialColor = vec4(0.4,0.4,0.4, 0.01);\n    \n        // does the light hit it the right way?\n        materialColor = vec4(0.4,0.4,0.4, 0.01);\n    else\n        materialColor = vec4(\n            \n                        0.01,0.01,0.7, \n\n             //0.01,0.01,0.7 - startrails(angles.xyy).x,\n            //0.01,0.01,0.7, \n            \n            0.01);\n    \n    //materialColor = vec4(0.01,0.01,0.01, 0.01);\n    \n  \n\tvec2 normalMap = //mix(\n        \n        // looks like a golfball?\n        //hash33(angles.xyy).xy\n        //hash33(pos * 0.00001).yx * 0.1\n        \n        0.\n        //startrails(pos).xy\n        //4.0 * sin(float(iFrame) * 0.1)//*GetNormalMap(iChannel1,iChannelResolution[1].xy,angles)\n        * vec2(1)\n        ;\n        \n        //GetNormalMap(iChannel0,iChannelResolution[0].xy,angles),mixer);\n\t\t\n\tvec3 left = normalize(cross(vec3(0.0,1.0,0.0),nor));\n\tvec3 up = normalize(cross(left,nor));\n\tnormal = normalize(normalMap.x*left + nor + normalMap.y*up);\n\t\n\treturn materialColor;\n}\n\n// can it become a scanline?\n//float GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params, in vec2 sine)\nfloat GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params)\n{\n\tfloat rotAngle = movement.x+iTime*movement.y;\n\tvec2 refPos = MAGIC_RADIUS*vec2(sin(rotAngle),cos(rotAngle));\n\tvec2 refFwd = vec2(-refPos.y,refPos.x);\n\t\n\tfloat hVert = pos.y - movement.z;\n\tfloat hDist = length(pos.xz - refPos);\n\t\n\t//float fl = max(dot(pos.xz,refFwd),0.0)*(1.0 - smoothstep(0.0,params.x,hDist));\n\tfloat fl = max(dot(pos.xz,refFwd),0.0)\n        \n        *(1.0 - smoothstep(0.0,params.x,hDist));\n    \n    \n\t//float fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z*sin(sine.x*angle+sine.y)));\n\tfloat fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z\n                                                // *sin(sine.x*angle+sine.y)\n                                                ));\n\t\n\treturn fl*fh;\n}\n\nvec3 GetAlphaColor(in vec3 pos)\n{\n\tvec3 ret = vec3(0.0);\n\tfloat angle = atan(pos.z/pos.x);\n\t\n#ifdef DRAW_RED_MAGIC\n\tret +=  0.000001 \n        * vec3(1.,0.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle,\n            \n            \n            vec3(0.0,-4., 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                1270.0,\n                \n                // width\n                2.,\n                \n                // moves it up or down?\n                \n                // up\n                -135.\n            \n                // down\n                //5.\n            \n                // center\n                //0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n#endif\n#ifdef DRAW_GREEN_MAGIC\n\tret += vec3(0.0,1.0,0.0)*GetTrail(pos,angle,vec3(0.5,2.1, 0.5),vec3(8.0,0.1,0.8),vec2(2.0,1.0));\n#endif\n#ifdef DRAW_BLUE_MAGIC\n\tret +=  0.000001 \n        * vec3(0.,0.0,1.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle,\n            \n            \n            vec3(0.0,4.1, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                1270.0,\n                \n                // width\n                2.,\n                \n                // moves it up or down?\n                \n                // up\n                //-2.\n            \n                // down\n                135.\n            \n                // center\n                //0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    #endif\n#ifdef DRAW_YELLOW_MAGIC\n\tret +=0.00001 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                -4.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    ret += 0.00001 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                4.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n      ret += 0.00001 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    #endif\n\treturn ret;\n}\n\n/////////////////\n// RAY METHODS //\n/////////////////\n\nfloat raySphereIntersection( in vec3 ro, in vec3 rd, in vec3 center, in float radius, float multiplier)\n{\n\tfloat res = 9999.0;\n\tvec3 oc = ro - center;\n\tfloat b = dot(rd,oc); //should be 2*rd*oc but the 2 gets eliminated after expanding the quadratic equation\n\tfloat c = dot(oc,oc)-(radius*radius);\n\t\n\tfloat bminac = (b*b)-c;\n\tif (bminac >= 0.0)\n\t{\n\t\t//intersection\n\t\tfloat sqrtbminac = sqrt(bminac);\n\t\tfloat t = (-b + multiplier*sqrtbminac);\n\t\tres = mix(res,t,step(0.0,t));\n \t}\n\t\n\treturn res;\n\t\n}\n\nfloat shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)\n{\n\tfloat lambda = dot(-(ro - sphere.xyz),rd);\n\tfloat dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;\n\treturn mix(9999.0,dist,step(0.0,lambda)); \n}\n\n////////////////\n// RAY TRACER //\n////////////////\n\nvec2 intersect( in vec3 ro, in vec3 rd)\n{\n\tvec2 res = vec2(9999.0,-1.0);\n\t\n\tvec2 centerSatellite = vec2(raySphereIntersection(ro,rd,ballPos,SATELLITE_RADIUS,-1.0),0.0);\n\tvec2 centerPlanet = vec2(raySphereIntersection(ro,rd,vec3(0.0),PLANET_RADIUS,-1.0),1.0);\n\t\n\tif (centerSatellite.x < res.x) res = centerSatellite; \n\tif (centerPlanet.x < res.x) res = centerPlanet; \n\t\n\treturn res;\n}\n\nfloat GetShadows( in vec3 ro, in vec3 rd)\n{\n\tfloat shadowSatellite = shadowRaySphere(ro,rd,vec4(ballPos,SATELLITE_RADIUS));\n    \n    \n\tfloat shadowPlanet = shadowRaySphere(ro,rd,vec4(0.0,0.0,0.0,PLANET_RADIUS));\n\t\n\treturn smoothstep(0.0,SOFTSHADOW_BANDWIDTH,min(shadowSatellite,shadowPlanet));\n}\n\nvec3 GetTransparency( in vec3 ro, in vec3 rd, float depth)\n{\n\tfloat back = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,1.0);\n\tfloat front = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,-1.0);\n\n\treturn GetAlphaColor(ro+rd*back)*step(back,depth) \n        // what does this do?\n        + GetAlphaColor(ro+rd*front)*step(front,depth)\n        ;\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nvec3 calcNormal( in vec3 pos, in vec2 tmat)\n{\n\treturn normalize(pos-mix(ballPos,vec3(0.0),tmat.y));\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd )\n{\n\tfloat scene = GetShadows(ro,rd);\n\tfloat alpha = 1.0 - 0.8*clamp(length(GetTransparency(ro,rd,9999.0)),0.0,1.0);\n    return min(alpha,scene);\n\t\n}\n\n\n\n\n\n\nvoid line_rgb (\n    //inout vec4 fragColorR,\n\tinout vec3 rgb1,\n\n    in float lat180,  \n    in float lat180target, \n    in float lat180radius,\n\n\tvec3 rgb)\n{\n    if (lat180 < (lat180target + lat180radius))\n        if (lat180 >( lat180target - lat180radius))\n            \n \t\t//if (lat180 < 108.)\n     //   if (lat180 > 72.)            \n        {\n\n            \n            //float a = 0.3;\n\n            \n\n            rgb1.rgb = rgb;\n\n            //fragColorR.b = a;\n            //fragColorR.g = a;\n\n        }\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // need SIRIUS from\n    // https://www.shadertoy.com/view/XdXcDB\n    \n    // need scanlines from\n    // https://www.shadertoy.com/view/ldXyzs\n    \n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\t//move camera when clicking\n\tfloat animatedCamAngle = -0.7 + iTime*CAM_ROTATION_SPEED;\n\t//float inputCamAngle = PI + 2.0*PI*(mousePos.x*14.);\n    float inputCamAngle = PI + 2.0*PI*(mousePos.x);\n\t//float inputCamAngle = PI + 2.0*PI*(mousePos.x*7.);\n\t\n\t//float camAngle = mix(animatedCamAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\n    float camAngle = animatedCamAngle+inputCamAngle;\n    \n    //float camDist = 5.0; \n\t//float camDist = 10.0; \n\t//float camDist = 10.0 +1.* sin(iTime);  \n\t//float camDist = 50.0  ;  \n\t//float camDist = 6.3715  ;  \n\t float camDist = 5. * 6.3715  ;  \n\t//float camDist = 384.400 + 6.; \n    \n    // #define PLANET_RADIUS \t6.371\n\n    // #define MAGIC_RADIUS\t384.400\n\n    \n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), \n                                              \n                                              \n                                              0.0, cos(camAngle)));\n    \n    // will rock the boat\n    //camPosition.y += 2. * sin(iTime * 0.5);\n    //camPosition.y += .2 * sin(iTime * 0.5);\n    \n    \n    //vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    // the closer we get. the more horizon we need to look at in 2D\n    vec3 camTarget\t = vec3( -8.0, 0.0, 0.0 );\n    \n    if (camDist > 10.)\n        camTarget.x = 0.;\n    \n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n\tvec3 rayRaw \t = p.x*camRight + p.y*camUp + 2.0*camFront;\n    vec3 rayDir \t = normalize( rayRaw );\n\t\n    //rayDir *=  rotationMatrix(vec3(1., 0., 0.), radians(90.0 )); // make it wavy\n    //camPosition *=  rotationMatrix(vec3(1., 0., 0.), radians(90.0 )); // make it wavy\n    \n\t// light compute (fake fire light)\n\t// how does the eclipse behve if we move the lightsource?\n    \n    // so if it needs to be northern minight sun sun has too appear at +20?\n    //vec3 lightPos1 = vec3(00.0,1300.0,-3840.400);\n    \n    // recenter scanline 0\n//    vec3 lightPos1 = vec3(00.0, 0. * 1300.0,-3840.400);\n    \n    \n    \n    // looky sun as seen within a year.\n    vec3 lightPos1 = vec3(00.0, \n                          1. * 1300.0 * sin(iTime * 0.005),\n                          -3840.400);\n    \n    \n\t\n\t//vec3 lightColor1 = vec3(1.0,0.7,0.0);\n\t//vec3 lightColor1 = vec3(0.7,0.7,0.7);\n\t\n\t//Update World\n\tfloat rotAngle = PI + SAT_ROTATION_SPEED * iTime; \n    \n    \n    //#define SATELITE_RADIUS 12.0\n    \n    // will it work for shadows?\n\tballPos = \n        vec3(0,\n             \n             // blue to red in 14 days\n             //-2. * cos(float(iFrame) * 0.01), 0.)+\n        //-2. * cos(camAngle / 14.)\n             \n             // how far must the sun then be?\n             // how hight can the moon be so we can still get an eclipse?\n             //1.7\n             \n             //1. * 1300.0 * sin(iTime * 0.05)\n             1. * 135.0 * sin(iTime * 0.005 * 12.)\n              \n             \n             //0.\n             \n             //1.\n             , 0.)+\n             \n        SATELITE_RADIUS * vec3(\n        sin(rotAngle),\n        0.0,\n        cos(rotAngle));\n\t\t\n\t//Compute Screen Shadow\n\t//vec3 barPos = camPosition + rayRaw*0.5*BAR_DEPTH;\n\t//vec3 lightDirExt = normalize(camPosition - barPos);\n\t//float screen_shadow = GetShadows(barPos,lightDirExt);\n\t\n\t//Start Ray\n    vec3 finalcolor = vec3(0.0);\n    \n    // need it be dynamic?\n    // ISO\n\t\n    // degamma?\n    float attenuation = 11.0;\n    attenuation += 8.5 * (cos(camAngle));  \n    //attenuation = 5.0;\n    \n    \n    vec3 lightColor1 = vec3(2.0,2.*0.7,0.0);\n    \n//    lightColor1 = 0.01 * vec3(2.0,2., 2. - (1.+cos(camAngle)));\n    \n    //finalcolor += 0.05 * vec3(\n    //    0.2* sin(camAngle / 2.),\n    //    0.2 * sin(camAngle / 2.),\n    //    1.0  * sin(camAngle / 2.)\n    //);\n    \n    //finalcolor.b += 0.01 * (  1.0 * 1.0  * sin(camAngle /2. ));\n    \n             \n    //if (cos(camAngle) < 0.)\n    // lightColor1 =  vec3(0.1,0.1,0.1);\n\t\n    \n    //attenuation = 0.2; // daytime\n\t//lightColor1 = vec3(0.7,0.7,0.7);\n    // at daylight we just need the pre lit map to show? in this case blue.\n    // in night time. yellow sun is cool.\n    \n\tfloat depth = 9999.0;\n\tfor( int reflectCount=0; reflectCount<2; reflectCount++ )\n\t{\n\t\tfloat isFirst = min(float(reflectCount),1.0);\n\t\t\n\t\t// Compute color for single ray\n    \tvec2 tmat = intersect(camPosition,rayDir);\n\t\tvec3 alpha = GetTransparency(camPosition,rayDir,tmat.x);\n\t\t\n\t\t//finalcolor += attenuation*alpha;\n\t\tfinalcolor += alpha;\n\t\t\n\t\tif (tmat.y > -0.5)\n\t\t{\n\t\t\tdepth = mix(tmat.x,depth,isFirst);\n\t\t\t\n\t\t\t// results extraction\n\t\t\tvec3 position \t= camPosition + tmat.x*rayDir;\n\t\t\tvec3 normal \t= calcNormal(position,tmat);\n\t\t\t\n\t\t\t// lights and materials \n\t\t\tvec3 normalMod = vec3(0.0);\n\t\t\tvec4 materialColor \t= calcColor( position, normal, tmat.y , normalMod);\n\t\t\tnormal = normalMod;\n\t\t\t\n\t\t\tfloat ambient  \t\t= 0.1 + 0.1*normal.y;\n\t\t\tvec3 ambientColor \t= ambient*materialColor.rgb;\n\t\t\t\n\t\t\t//light 1 ( specular computed through reflections )\n\t\t\tvec3 lightDir1 \t= normalize(lightPos1 - position);\n\t\t\t\n\t\t\tfloat diffuse1  = max(dot(normal,lightDir1),0.0);\n\t\t\tfloat shadow1   = softShadow( position, lightDir1 );\n\t\t\t\n            // HDR bright\n\t\t\tvec3 diffuseColor1 = 10.0* diffuse1*lightColor1*materialColor.rgb;\n\t\t\tvec3 ilumColor1 = shadow1*diffuseColor1;\n\t\t\t\n\t\t\t// mixing lights\n\t\t\tfinalcolor += attenuation*mix(ambientColor,ilumColor1,0.8);\n\t\t\t\n\t\t\t// prepare next ray for reflections \n\t\t\trayDir = reflect(rayDir,normal);\n\t\t\tattenuation *= 2.0*materialColor.w;\n\t\t\tcamPosition = position + EPSILON*normal;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//stars achieved via noise texture\n\t\t\tvec2 angles = vec2(atan(rayDir.z/abs(rayDir.x)),acos(rayDir.y));\t\n\t\t\t//float a1 = texture(iChannel1,angles).x;\n\t\t\t//float a2 = texture(iChannel1,angles*2.0+0.01).x;\n\t\t\t//float a3 = texture(iChannel1,angles*2.1+0.07).x;\n\t\t\t//float a4 = texture(iChannel1,angles*5.0+0.03).x;\n\t\t\t\n\t\t\t//float stars = smoothstep(0.1,1.0,a1*a2*a3*a4);\n            \n            //stars = 0.;\n            \n            \n\t\t\tfloat sun = 1000.0 * pow(max(dot(normalize(lightPos1 - camPosition),rayDir),0.1),100000.0);\n\t\t\t\n            \n            // overrride. cant have stars be much brighter than unlit moon\n            \n            // what about milkiway?\n           \n            \n            //if (p.y > -0.7 &&  p.y < 0.7)\n            {\n           \t\n                \n                if (p.x > -0.5)\n                {\n                    // overide ISO\n                    //attenuation = 0.7;\n                }\n                \n\t\t\t//\tfinalcolor += attenuation*(lightColor1*sun + stars*vec3(0.5));\n              \tfinalcolor += attenuation*(lightColor1*sun  );\n                \n            \n                finalcolor+=finalcolor;\n                \n                \n                \t//attenuation *= 0.005;\n                \tattenuation *= 0.05;\n            \n            \n                //attenuation -= 2.0;\n                \n                // will kill fps on fullscreen \n                finalcolor += attenuation * startrails( rayDir);\n   \n            }\n            //else\n            {\n            // show stars from scanline concept\n            }\n            \n            \n\t\t\tattenuation = 0.0;\n\t\t}\n\t\t\t\t\t\n\t}\n    \n    \n    vec3 rgb1 = vec3(0.0);\n\n    vec3 rd1 = rayDir;\n    \n    float lat180 = (acos(-rd1.y) / 3.1415926535897932384626433832795) * 180. ;\n\nfloat hlat180 = (acos(-rd1.y) / 3.1415926535897932384626433832795) * 180. ;\n//float hlng360 = -(atan(rd0.z, rd0.x) / 6.283185307179586476925286766559) + 0.5;\n\n//if (hlat180  > 90.|| (mod(float(lng360blue), 2. * dashsize) >= dashsize))\n{\n line_rgb(rgb1, lat180, 90. +20., 0.3, vec3(1.0, 0, 0)* 0.5);\n //line_rgb(rgb1, lat180, 90. +16., 0.3, vec3(1.0, 0, 0) * 0.5);\n            \n            \n            // center line\n\n            //line(fragColorR, lat180, 90. - 19., 1., 0.8);\n            //line_rgb(rgb1, lat180, 90. , 0.19, vec3(1.0, 1.0, 0));\n            //line_rgb(rgb1, lat180, 90. + 3., 0.19, vec3(1.0, 1.0, 0)*0.5);\n\t\t\t//line_rgb(rgb1, lat180, 90. - 3., 0.19, vec3(1.0, 1.0, 0)*0.5);\n\n            \n              // lower line\n            //line(fragColorR, lat180, 90. + 19., 1., 0.4);\n            //line_rgb(rgb1, lat180, 90.- 16., 0.3, vec3(0.0, 0.0,1.0)* 0.7);\n            line_rgb(rgb1, lat180, 90.- 20., 0.3, vec3(0.0, 0.0,1.0)* 0.5);\n    \n}\n \n    // hide HUD after init\n    if (iFrame < 60)\n    if (camDist <50.)\n    \tfinalcolor+= rgb1;\n\t \n\t// desaturation, gamma correction\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\n    fragColor = vec4( finalcolor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjBWW", "name": "[SH17A] The Ancient Code", "author": "otaviogood", "description": "Ah yes, the ancient code could only be understood by the meta-code decoder hidden in the infinite far reaches of the higher dimension's sub-void region.", "tags": ["spiral", "symbols", "sh17a"], "likes": 18, "viewed": 1179, "date": "1500441444", "time_retrieved": "2024-06-20T18:59:05.147449", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// .44 ~= 7/16 (the texture offset for greek letters and math symbols)\n#define T texture(iChannel0, vec2(z, x/16.) + .44).xxxx\n\nvoid mainImage(out vec4 c, vec2 u)\n{\n    // Set up UV coordinates and get the aspect ratio right\n    vec3 R = iResolution;\n    u = (R.xy - u - u) / R.y;\n\n    float t = iTime,\n          // Map UV space to an animated spiral\n          y = atan(u.x, u.y) - t,\n          z = y*.159,  // .159 ~= 0.5 / PI\n          x = fract(log(length(u)) + z) * 2. -1.;\n\n    // Make a shaded spiral that sorta looks 3d\n    c = x * sin(y) *\n        // Make animated radial lines for maximum mesmerization\n        pow(sin(y*16.+ t*18.)+1., .1) -\n        // Make the drop-shadow for the letters\n        T*.2;\n    // Sepia tone color makes it look old and mysterious\n    c.x += .2;\n    // Shift the texture offset for the drop shadow.\n    x -= .1;\n    // Draw the white foreground letters\n    c += T;\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjBzw", "name": "[SH17A] Stand Strong - Guts", "author": "ttoinou", "description": "My first entry ! Looks weird, I know :D ", "tags": ["sound", "fft", "wave", "music", "sh17a"], "likes": 0, "viewed": 423, "date": "1499903359", "time_retrieved": "2024-06-20T18:59:05.147449", "image_code": "#define T(x) texture(iChannel0,x).r\n\nvoid mainImage( out vec4 a, vec2 b )\n{\n    float k = cos(iTime/4.)*.5+.5;\n    \n\tvec2 c = b / iResolution.xy + k;\n    \n    a = vec4(T(c),T(c*c),T(c*k),1.);\n    \n    float d = mod(\n        cos(iTime-c.y*2.+T(vec2( c.x/2.0 , k )))\n      , c.x);\n    \n    a *= pow( T(vec2(.2)) ,4.)*6.;\n    \n    a = tanh( abs( vec4(k,c.x,d,1)*pow(d*k,.2) - a*3. ) );\n\n}\n/*\n#define T(x) texture(iChannel0,x).r\n\nvoid mainImage( out vec4 a, in vec2 b )\n{\n    float k = cos(iTime/3.)*.5+.5;\n    \n\tvec2 c = b / iResolution.xy + k;\n    a = vec4(T(c));\n    float d = \n        mod(\n              cos(iTime-c.y*2.+T(vec2( c.x/2.0 , k )))\n            ,c.x)\n    \n    ;\n    \n    \ta *= T(vec2(.1,0.))*2.;\n    \n    if( d < c.y*c.x\n    ) {\n        a = abs( vec4(k,c.x,d,1)*pow(d*k,.2) - a*1.5 );\n    }\n    //else {\n    \n    //}\n    //c -= .5;\n    //c = vec2(length(c)*k,atan(c));\n    //a.g += T(c)/2.;\n    \n    \n    //a = tanh( a+a-dot(a,vec4(.2)));\n\n}\n*/\n/*\n#define T(x) texture(iChannel0,x).r\nvoid mainImage( out vec4 a, in vec2 b )\n{\n\tvec2 c = b / iResolution.xy;\n    a = vec4(T(c));\n    float k = cos(iTime/3.)*.5+.5;\n    float d = \n        mod(\n              cos(iTime-c.y+T(vec2( c.x/2.0 , k )))\n            ,c.x)\n    \n    ;\n    \n    if( d < c.y*c.x\n    ) {\n        a = abs( d*k*3. - a );\n        return;\n    }\n    \n    //c -= .5;\n    //c = vec2(length(c)*k,atan(c));\n    //a.g += T(c)/2.;\n    \n    \n    //a = tanh( a+a-dot(a,vec4(.2)));\n\n}\n*/\n/*\n\n#define T(x) texture(iChannel0,x).r\nvoid mainImage( out vec4 a, in vec2 b )\n{\n\tvec2 c = b / iResolution.xy;\n    a = vec4(T(c));\n    float k = cos(iTime/3.)*.5+.5;\n    \n    if( mod(\n          cos(iTime-c.y+T(vec2( c.x/2.0 , k )))\n        ,c.x)\n       < c.y*c.x\n    ) {\n        a = 1.0 - a;\n        return;\n    }\n    \n    //c.x *= 1.0 - c.x;\n    //a.b *= T(c);\n    \n    c -= .5;\n    c = vec2(length(c)*k,atan(c));\n    a.g += T(c)/2.;\n    //a.b *= T(1. - c)*4.;\n    \n    \n    a = tanh( a+a-dot(a,vec4(.2)));\n\n}\n\n*/", "image_inputs": [{"id": "4sXSRs", "previewfilepath": "https://soundcloud.com/guts/stand-strong", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/guts/stand-strong", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjfDm", "name": "4 Infinite Spirals", "author": "ttoinou", "description": "Improving [url]https://www.shadertoy.com/view/Xd2BDm[/url]", "tags": ["spiral", "complex", "log", "equerre"], "likes": 11, "viewed": 195, "date": "1500741635", "time_retrieved": "2024-06-20T18:59:07.080900", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \n#define _AB_ (1)\n#define _BC_ (2)\n#define _CA_ (3)\n        \n#define _ALPHA_ _AB_\n#define _BETA_  _BC_\n#define _GAMMA_ _CA_\n        \n#define _REPLACE_(X,Y,Z,T) \\\n        if( Begin == X && End == Y && !operation ) { \\\n            Begin = Z; End = T; operation = true; \\\n        } else if( End == X && Begin == Y && !operation) { \\\n            End = Z; Begin = T; operation = true; \\\n        }\n\n#define _SWAP_(X,Y) _REPLACE_(X,Y,Y,X)\n\n#define _SWAP_KEEP_BETA_ \\\n\t_REPLACE_(_BETA_,_ALPHA_,_BETA_,_GAMMA_) \\\n\t_REPLACE_(_BETA_,_GAMMA_,_BETA_,_ALPHA_) \\\n\n#define _SWAP_KEEP_GAMMA_ \\\n\t_REPLACE_(_GAMMA_,_ALPHA_,_GAMMA_,_BETA_) \\\n\t_REPLACE_(_GAMMA_,_BETA_,_GAMMA_,_ALPHA_) \\\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat k = 1. - sqrt(3.)*.5;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,-(n + logZoom)/2.) , (n)/3.*PI + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\nvec2 deformation_pole = vec2(.3,.0);\n\nvec2 deformation( vec2 uv )\n{\n    uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    uv_s = cdiv(vec2(1.,0.),uv_s)+uv_s;\n    \n    viewportMagnify = 1.; \n    //uv_s *= viewportMagnify;\n    \n    \n    angleShift = cos(iTime/7.5)*8.;\n    logZoom = sin(iTime/4.)*13.;\n    \n    float r = floor( -log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    fragColor.rgb = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv_s,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n    #endif\n    \n    \n    fragColor.rgb = tanh(fragColor.rgb *2./(1. + dot(uv_s,uv_s)/1e3 ) ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjfDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjfRD", "name": "just some colors", "author": "DJDoomz", "description": "title says it all \\_()_/", "tags": ["2d", "acid"], "likes": 3, "viewed": 116, "date": "1499788034", "time_retrieved": "2024-06-20T18:59:07.080900", "image_code": "//apparently bitwise operations aren't supported before GL version 3.0...\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float t = iTime/2.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    \n    uv.y /= iResolution.x/iResolution.y;\n    uv *= 2.*sin(t/5.)+3.;\n    \n    float s = sin(t/3.), c = cos(t/3.);\n    uv *= mat2(s,c,c,-s);\n    \n    uv = abs(fract(abs(uv))-.5);\n    \n    s = sin(t-uv.x*4.), c = cos(t+uv.y*4.);\n    uv *= mat2(s,c,c,-s);\n    \n    uv = fract(uv);\n    uv *= sin(t/10.)*50.+60.;\n    uv = fract(uv/32.)*64.;\n    \n    uv *= mat2(s,c,c,-s);\n    \n    for(float i = -4.; i < 4.; i ++)\n    {\n        t+=.1;\n        uv += 32.*sin(i*2.);\n\t\tfragColor += sign( sin(uv.x/4.)-sin(uv.y/4.) );\n    }\n    \n    fragColor = vec4(abs(sin(.15*fragColor.xyz*vec3(.4,.8,1.6)+2.*(t+uv.x/64.))),0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjfRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjfRm", "name": "2D vector field 1", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/XlfSRj by nmz (twitter: @stormoid)", "tags": ["math", "visualization", "field", "vector", "equation", "arrow", "differential", "manifold", "calculus"], "likes": 6, "viewed": 234, "date": "1499925861", "time_retrieved": "2024-06-20T18:59:07.456895", "image_code": "// Fork of https://www.shadertoy.com/view/XlfSRj by nmz (twitter: @stormoid)\n// A visualizer for 2D vector fields, originally by nmz\n// Default field: a gentle vortex vector field  https://en.wikipedia.org/wiki/One-form#Differential\n// The color is the norm field of the vector field, using iq's cosine palette function, although\n// the length of each arrow is also intended to represent the norm of the vector at that point!\n\n#define arrow_density  8.\n#define arrow_length   .3\n#define arrow_thinness 100.\n#define arrow_head .5\n#define arrow_openness .2\n#define time -.1 * iTime\n\n//---------------Field to visualize defined here-----------------\nvec2 field(in vec2 p){\n  return vec2(-p.y, p.x);\n  //return vec2(-p.y / dot(p,p), p.x / dot(p,p));  // THIS is the true vortex vector field!\n}\n\n//-------------------------------------------------------------\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){  // from iq\n  return a + b*cos( 6.28318 * (c*t + d));\n}\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b){  // from iq\n  vec2 ap = p - a;\n  vec2 ab = b - a;\n  float projection_factor = clamp(dot(ap,ab) / dot(ab,ab), 0., 1.);\n  vec2 ap_proj_ab = ab * projection_factor;\n  return length(ap - ap_proj_ab) * arrow_thinness;\n}\n\nfloat draw_arrows(in vec2 p){\n  vec2 ip = floor(p * arrow_density) / arrow_density + .5 / arrow_density;   \n  vec2 field_image = field(ip);\n  float norm = length(field_image) * (arrow_length / arrow_density);\n\n  vec2 b = normalize(field_image) * norm;\n  vec2 prp = vec2(-b.y, b.x);\n\n  float rz = segm(p, ip, ip+b);\n  rz = min(rz, segm(p, ip + b, ip + b * arrow_head + prp * arrow_openness));\n  rz = min(rz, segm(p, ip + b, ip + b * arrow_head - prp * arrow_openness));\n  return rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  //vec2 p = fragCoord.xy / iResolution.xy;\n  //p = 2. * (p + -.5);\n  //p.x *= iResolution.x / iResolution.y;\n  vec2 p = 2. * (fragCoord + -.5*iResolution.xy) / iResolution.y;  // The Fabrice map!\n\n  p = vec2(cos(time)*p.x - sin(time)*p.y, sin(time)*p.x + cos(time)*p.y);  // Rotation: multiplication of `p` by a unit complex number (cos(time), sin(time))\n\n  vec2 field_image = field(p);\n  vec3 norm_field = palette(.4 * length(field_image), vec3(.5, .5, .5), vec3(.5, .5, .5), vec3(1., 1., 1.), vec3(.00, .33, .67));  // iq's palette function <3\n  float arrow = draw_arrows(p);\n  vec3 rgb = max(1. - norm_field, 1. - arrow);\n  \n  fragColor.rgb = rgb;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjfRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSBWm", "name": "Conway - Pinwheel Snakes", "author": "ttoinou", "description": "From : [url]https://www.shadertoy.com/view/Md2BWD[/url], each triangle has a unique ID computed from the subtriangles recursion, watch in fullscreen there's a lot of details !", "tags": ["tiling", "conway", "pinwheel"], "likes": 2, "viewed": 113, "date": "1500577583", "time_retrieved": "2024-06-20T18:59:07.456895", "image_code": "#define SHOW_SEGMENTS 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\n// pointA and pointB are on the same side of the half plane delimited by line (lineA,lineB)\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n} \n\nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n};\n   \nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 5;// 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*4.6));\n    \n    vec2 base = vec2(2.0,1.0);\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1.3;\n    uv *= viewportMagnify;\n    uv += base/2.;\n    \n    // Base Triangle\n    Pinwheel Tri;\n    Pinwheel Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    int PinwheelID = 0;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        PinwheelID *= 5;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                PinwheelID += 1;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                PinwheelID += 2;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                PinwheelID += 3;\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            PinwheelID += 4;\n        }\n        \n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    //fragColor.rgb = hash3point(EQUERRE_CENTER(Tri));\n    vec3 v = vec3(sin(iTime/57.)*23.+43.,33.,23.);\n    vec3 s = vec3(.5,iMouse.xy/iResolution.xy);\n    fragColor.rgb = mod(vec3(PinwheelID),v)/(v-1.);\n    fragColor.rgb = mod(fragColor.rgb+s,1.);\n    //fragColor = cos(fragColor*3.14*vec4(1.,2.,3.,1.))*.5+.5;\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale*16.;\n    \n    vec3 EquerreCoeffs = barycentricCoordinate(uv,Tri);\n    vec3 EquerreColor = vec3(0.);\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n           \n    \n    fragColor.rgb = tanh(fragColor.rgb*2.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XssBWs", "name": "2D Lighting (Updated)", "author": "Davislast19", "description": "2D Lighting shader with a brightness aspect. Blends colours!\nPlease comment if you think there are improvements to be made :)\nPS: If intensity is more than 1.0, it looks unnatural. Intensity is supposed to be between 0 and 1", "tags": ["2d", "lighting"], "likes": 1, "viewed": 223, "date": "1498861207", "time_retrieved": "2024-06-20T18:59:07.456895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 colours = vec3(0.0, 0.0, 1.0);\n    float backGroundLight = 0.25;\n    vec3 lightColours = vec3(1.0, 0.0, 0.0);\n    float brightness;\n    float intensity = abs(cos(iTime));\n    float size = 100.0;\n    vec2 lightPos = iResolution.xy / 2.0;\n    float dist = distance(fragCoord, lightPos);\n    float distFromEdge = size - dist;\n    \n    brightness = 1.0 / (dist * ((1.0 / intensity) / size)); // distFromEdge * intensity (original calc)\n    brightness -= brightness * (size / dist);\n    if(distFromEdge <= 0.0) {\n    \tbrightness = 0.0;\n    }\n    \n    lightColours.xyz *= abs(brightness);\n    colours.xyz *= abs(brightness) + backGroundLight;\n    colours.xyz += lightColours.xyz;\n    \n\tfragColor = vec4(colours.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XssBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSBzm", "name": "[SH17A]Circles", "author": "EvilRyu", "description": "size coding", "tags": ["2d", "fractal", "sh17a"], "likes": 3, "viewed": 426, "date": "1500037813", "time_retrieved": "2024-06-20T18:59:07.456895", "image_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define h(q,s) min((q-s)/.01,.9)+max((q-s+.01)/-.01,0.)\n\nvoid mainImage(out vec4 o,vec2 c)\n{\n    vec2 q=c/iResolution.x*2.-1.;o=vec4(1);\n    for(float i=0.,s=.3;i++<8.;s*=.8)q=abs(q),q-=s*2.,\n        o*=h(length(q)-.1*sin(iTime),s),o.y=pow(o.y,.9);\n\n}\n\n\n/*\nvoid mainImage(out vec4 o,vec2 c)\n{\n    vec2 q=mod(c/iResolution.y*2.,2.)-.78;\n    o=vec4(1);\n    float s=.115;\n    for(int i=0;i<5;i++)\n    {\n        q=abs(q);\n        s*=.8;\n        o*=h(length(q)-.1,sin(iTime)*s);\n        q-=s*2.;\n        o*=h(length(q)-.1,cos(iTime)*s);\n        o.y=pow(o.y,.9);\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSBzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSfW1", "name": "[SH17A] Rainbow Twister", "author": "Flyguy", "description": " Similar to the ring twister shader I made a few years ago but a lot smaller. ", "tags": ["ring", "twist", "small", "sh17a"], "likes": 69, "viewed": 4583, "date": "1500192159", "time_retrieved": "2024-06-20T18:59:07.456895", "image_code": "//With AA (239 c)\n\nvoid mainImage( out vec4 c, vec2 o )\n{\n    vec2 r = iResolution.xy;\n    o = vec2(length(o -= r/2.) / r.y - .3, atan(o.y,o.x));    \n    vec4 s = c.yzwx = .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.),\n    f = min(o.x-s, c-o.x);\n    c = dot(40.*(s-c), clamp(f*r.y, 0., 1.)) * (s-.1) - f;\n}\n\n\n//No AA (233c)\n/*\nvoid mainImage( out vec4 c, vec2 o )\n{\n    vec2 r = iResolution.xy;\n    o = vec2(length(o -= r/2.) / r.y - .3, atan(o.y,o.x));    \n    vec4 s = c.yzwx = .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.);\n    c = dot(40.*(s-c), step(1./r.y, c = min(o.x-s,c-o.x))) * (s-.1) - c;\n}\n*/\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSfWm", "name": "Pinwheel Triangles ScreenSaver", "author": "ttoinou", "description": "I think I understand now why it's called pinwheel :D \nClick for more triangles", "tags": ["triangle", "conway", "pinwheel"], "likes": 7, "viewed": 234, "date": "1500579014", "time_retrieved": "2024-06-20T18:59:07.464538", "image_code": "#define SHOW_SEGMENTS 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\n// pointA and pointB are on the same side of the half plane delimited by line (lineA,lineB)\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n} \n\nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n};\n   \nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = iMouse.z > .5 ? 6 : 5;\n    \n    vec2 base = vec2(2.0,1.0);\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1./3.2;\n    uv *= viewportMagnify;\n    \n    uv *= mat2(cos(iTime/48.+vec4(0.,1.6,-1.6,0.)));\n    \n    uv += base/3.2;\n    \n    // Base Triangle\n    Pinwheel Tri;\n    Pinwheel Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    int PinwheelID = 0;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        PinwheelID *= 5;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                PinwheelID += 1;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                PinwheelID += 2;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                PinwheelID += 3;\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            PinwheelID += 4;\n        }\n        \n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    //fragColor.rgb = hash3point(EQUERRE_CENTER(Tri));\n    vec3 v = cos(\n             iTime/vec3(63.,54.,69.)/float(nbIterations)/1.2\n              + vec3(.0,.95,1.22)\n             )\n             * vec3(36.,34.,31.)\n             + vec3(25.,19.,42.);\n    vec3 s = vec3( sin(iTime/3.0)*.5+.5 ,iMouse.xy/iResolution.xy);\n    fragColor.rgb = mod(vec3(PinwheelID),v)/(v-1.);\n    fragColor.rgb = mod(fragColor.rgb+s,1.);\n    // interesting variation\n    // but needs tuning in color \n    //fragColor = sqrt( cos(fragColor*3.14*vec4(1.,2.,3.,1.))*.5+.5 );\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale*5.5;\n    \n    vec3 EquerreColor = vec3(0.);\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n           \n    \n    fragColor.rgb = tanh(fragColor.rgb*6.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSfWw", "name": "Julia set sinus wave", "author": "Balint", "description": "A very basic Julia set renderer", "tags": ["juliafractal"], "likes": 0, "viewed": 435, "date": "1500552335", "time_retrieved": "2024-06-20T18:59:07.464538", "image_code": "const int STEPS_INT = 500;\nconst float STEPS_FLOAT = float(STEPS_INT);\nconst vec4 BLACK = vec4(vec3(0.0), 1.0);\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    while(hsl.x > 1.0) {\n    \thsl.x -= 1.0;\n    }\n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 z = ((fragCoord / iResolution.yy * 2.0 - vec2(1.0 * iResolution.x / iResolution.y, 1)));\n    vec2 c = vec2(mod(iTime / 10.0, 4.0) - 2.0 + sin(iTime / 10.0) * 0.5);\n    bool escaped = false;\n    for (int i = 0; i < STEPS_INT; i++) \n    {\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (length(z) > 2.0) {\n\t\t\t// Escaped\n            escaped = true;\n            fragColor = vec4(hsl2rgb(vec3(float(i) / STEPS_FLOAT * 10.0, 1.0, 0.8)), 1.0);\n            break;\n\t\t}\n\t}\n    if (!escaped)\n        fragColor = BLACK;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
