{"id": "4tVcRz", "name": "Simple Raytracing", "author": "drcd1", "description": "Raytracer", "tags": ["pathtracer"], "likes": 3, "viewed": 67, "published": "Public", "date": "1637336495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 1\n#define TRIANGLE 2\n#define INF 1e9\n#define EPS 1e-3\n#define N_SHAPES 3\n#define N_LIGHTS 2\n#define DEPTH 3\n#define M_PI 3.14159265358979323846 \nstruct shape{\n\tvec3 q[3];\n    int type;\n    int material;\n};\n\n\nstruct ray{\n\tvec3 o;\n    vec3 d;\n    float tMax;\n    int depth;\n    \n};\nshape make_sphere(vec3 center, float r){\n\tshape ret;\n    ret.q[0] = center;\n    ret.q[1].x = r;\n    ret.type = SPHERE;\n    ret.material = 0;\n    return ret;\n}\n\nstruct intersection{\n    float t;\n    vec3 normal;\n    int material;\n};\n\nbool solve_quadratic(float a, float b, float c, out float tMin, out float tMax){\n\tfloat d = b*b-4.0f*a*c;\n    if(d<0.0f)\n        return false;\n    tMin = (-b-sqrt(d))/(2.0f*a);\n    tMax = (-b+sqrt(d))/(2.0f*a);\n    return true;\n}\n\nbool intersect_sphere(inout ray r, in shape s, inout intersection i){\n    vec3 delta = s.q[0] - r.o;\n   \tfloat c = dot(delta,delta) - s.q[1].x*s.q[1].x;\n    float b = -2.0f*dot(r.d, delta);\n    float a = dot(r.d, r.d);\n    \n    float tMin, tMax;\n    \n    if(solve_quadratic(a,b,c,tMin,tMax)){\n        if(tMin>EPS && tMin<r.tMax){\n            i.t = tMin;\n            i.normal = normalize(i.t*r.d - delta);\n            r.tMax = i.t;\n            i.material = s.material;\n            return true;\n        } else if(tMax>EPS && tMax<r.tMax){\n        \ti.t = tMax;\n            i.normal =  normalize(i.t*r.d - delta);\n            r.tMax = i.t;\n            i.material = s.material;\n            return true;\n        } else {\n        \treturn false;\n        }\n    \n    } else {\n       return false;\n    }    \n\treturn false;\n}\n\n\n\nshape make_tri(vec3 v1, vec3 v2, vec3 v3){\n\tshape ret;\n    ret.q[0] = v1;\n    ret.q[1] = v2;\n    ret.q[2] = v3;\n    return ret;\n    \n}\n\nray getRay(vec2 fragCoord, mat3 rot){\n\tvec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    ray r;\n    r.o.x=0.0f;\n    r.o.y=0.0f;\n    r.o.z=3.0f;\n    \n\tr.d.x = (uv.x-0.5f)*aspect;\n    r.d.y = uv.y-0.5f;\n    r.d.z = -1.0f;\n    \n    r.o = rot*r.o;\n    r.d = rot*r.d;\n    \n    r.d = normalize(r.d);\n    \n    r.tMax = INF;\n    return r;\n\n}\n\nray makeRay(){\n    ray r;\n    r.o = vec3(0,0,0);\n    r.d = vec3(0,0,0);\n    r.tMax = INF;\n    r.depth = 0;\n    return r;\n}\nstruct light{\n\tvec3 o;\n    vec3 col;\n};\n\nstruct material{\n\tvec3 diff_col;\n    vec3 spec_col;\n    vec3 trans_col;\n    float d; //albedo\n    float r; //reflectance\n    float t; //transmittance\n    \n};\nstruct scene{\n   \tshape shapes[N_SHAPES];\n\tlight lights[N_LIGHTS];\n\tmaterial materials[2];\n};\n\n\n\nvec3 raycast(ray r, scene s){\n    vec3 colFin = vec3(0,0,0);\n    vec3 colMul = vec3(1,1,1);\n    while(r.depth<=DEPTH){ \n        vec3 col = vec3(0,0,0);\n    \n   \t\tbool hit = false;\n   \t\tintersection inter;\n   \t\tfor(int i = 0; i<N_SHAPES; i++){\n   \t\t    bool prev_hit = hit;\n   \t\t\thit = intersect_sphere(r, s.shapes[i], inter);\n   \t\t   \thit = hit || prev_hit;\n   \t\t}\n   \t\t\n   \t\t\n   \t\t\n   \t\tif(hit){\n            \n            //for every light\n            for(int i = 0 ; i<N_LIGHTS; i++){\n                \n           \t\thit = false;\n                ray sr;\n                sr.o = r.o + inter.t*r.d;\n                sr.d = s.lights[i].o-sr.o;\n                float l_sq = dot(sr.d,sr.d);\n                sr.d = normalize(sr.d);\n                sr.tMax = sqrt(l_sq);\n                //for all the scene\n           \t\tfor(int j = 0; j<N_SHAPES; j++){\n                intersection dummy;\n   \t\t   \t\t \tbool prev_hit = hit;\n   \t\t\t\t\thit = intersect_sphere(sr, s.shapes[j], dummy);\n   \t\t   \t\t\thit = hit || prev_hit;\n   \t\t\t\t}\n                \n                //add light if not hit\n                if(!hit){\n                    vec3 l_dir = sr.d;\n                    \n                    col += s.materials[inter.material].diff_col*s.lights[i].col\n                        \t*max(dot(l_dir, inter.normal),0.0f)*(1.0f/l_sq); \n   \t\t    \n                }\n                \n                \n            }\n            \n            //global illumination\n            if(s.materials[inter.material].r>EPS){\n                ray rr;\n                rr.o =  r.o + inter.t*r.d;\n                rr.d = normalize(r.d - 2.0f*dot(inter.normal, r.d)*inter.normal);\n                rr.depth = r.depth+1;\n                rr.tMax = INF;\n                r = rr;\n                colFin+=col*colMul;\n       \n                colMul = colMul*s.materials[inter.material].spec_col*s.materials[inter.material].r;\n    \n            } else {\n            \tcolFin+=col*colMul;\n            }\n        } else {\n        \tcol = vec3(1,0,1);\n            colFin+=col*colMul;\n            break;\n        }\n    }\n    return colFin;\n}\n\nmaterial make_material(vec3 dif, vec3 spec, vec3 trans,float d, float r, float t){\n\tmaterial mat;\n    mat.diff_col = dif;\n    mat.spec_col = spec;\n    mat.trans_col = trans;\n    mat.d = d;\n    mat.r = r;\n    mat.t = t;\n    return mat;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scene s;\n    s.shapes[0] = make_sphere(vec3(0.0f,0.0f,-1000.5f), 1000.0f);\n    s.shapes[1] = make_sphere(vec3(0.0f,0.0f,0.2f), 0.7f);\n    s.shapes[2] = make_sphere(vec3(0.0f,0.9f,-0.1f), 0.4f);\n    s.shapes[1].material = 1;\n    s.materials[0] = make_material(vec3(.8f, .2f, .8f), vec3(1,1,1),vec3(0.9f,0.2f,0.0f), .8f, .2f, 0.0f);\n    s.materials[1] = make_material(vec3(.5f, .5f, .5f), vec3(0.1f,0.1f,1.0f),vec3(0.0f,0.0f,0.9f), .8f, .2f, 0.0f);\n\n    \n    s.lights[0].o = vec3(2,2,2);\n    s.lights[0].col = vec3(2,2,2);\n    s.lights[1].col = vec3(4,1,1);\n    s.lights[1].o = vec3(-4,-1,2);\n\n   \n\tfloat theta = (iMouse.x/iResolution.x-0.5f)*2.0f*M_PI;\n\tfloat phi = iMouse.y/iResolution.y*M_PI;\n    theta = iTime;\n    phi= 1.0;\n\n   \tmat3 rot;\n    \n    float a = cos(-theta);\n    float b = sin(-theta);\n    float c = cos(phi);\n    float d = sin(phi);\n    \n    rot[0][0]=a;\n    rot[1][0]=-b*c;\n    rot[2][0]= b*d;\n    rot[0][1]= b;\n    rot[1][1]= a*c;\n    rot[2][1]= -a*d;\n    rot[0][2]= 0.0f;\n    rot[1][2]= d;\n    rot[2][2]= c;\n    \n  \tray r = getRay(fragCoord, rot);\n    \n   \t\t        \n   \tfragColor = vec4(raycast(r,s), 1.0f);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 335, 335, 453], [528, 528, 608, 608, 757], [759, 759, 828, 828, 1572], [1576, 1576, 1618, 1618, 1710], [1712, 1712, 1749, 1749, 2083], [2085, 2085, 2099, 2099, 2207], [2504, 2504, 2533, 2533, 4577], [4579, 4579, 4661, 4661, 4815], [4819, 4819, 4876, 4876, 6015]], "test": "valid"}
{"id": "7dXGD8", "name": "2D Distance Clipping", "author": "kick", "description": "clipping successive shapes on minimum distance.  Simple.  A lot more eye candy could be done here.", "tags": ["sdf"], "likes": 8, "viewed": 211, "published": "Public API", "date": "1636899332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r(x) fract(sin(x*12.9898)* 43758.5453123)\n#define rs(x) (r(x)*2.-1.)\n#define t iTime\n#define NOCLIP false\n#define I 7\n\nfloat lineWidth;\n\n#define glow(x,f) (1. - pow(smoothstep(0.,(f)*lineWidth,abs(x)),0.2))\n\n// Misc Functions\n\nvoid pR(inout vec2 p,float a) {\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec3 pal(float t) {\n\treturn (0.5+0.5*cos(3.*(1.*t+vec3(0,0.33,0.67))));\n}\n\n// 2D Functions\n\n// IQ's distance to line segment\nfloat sdSegment2( vec2 p, vec2 a, vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 get2dColor( vec2 p ) {\n  vec3 color = vec3(0), c; float d, md=1e2;\n  vec4 l;\n  for( int i=0; i < I; i++ ) {\n    float a = r(float(i)+112.);\n    l = vec4(rs(a+1.),rs(a+2.1),rs(a+3.8),rs(a+6.7))*2.;\n    c = vec3(rs(a+1.),rs(a+2.1),r(a+3.8)*1.5+0.2);\n    pR(l.xy, t*l.x);\n    pR(l.zw, -t*l.z*0.1);\n    d = sdSegment2(p, l.xy, l.zw);\n    if(NOCLIP || d<md){ md = d; color += glow(d, 10.) * (0.5+0.5*cos(3.*(1.*length(l.xz)+vec3(0,0.33,0.67)))); }\n    c.z *= sin(t*(c.z*c.x*2.1+0.1))*0.5+0.7;\n    pR(c.xy,t*c.y);\n    d = dot(p-c.xy,p-c.xy) - c.z;\n    if(NOCLIP || d<md){ md = d; color += glow( d, 10. ) * (0.5+0.5*cos(3.*(1.*c.z*2.+vec3(0,0.33,0.67)))); }\n  }\n  return color;\n}\n\nvoid mainImage( out vec4 oc, in vec2 p ) {\n  float minD = min(iResolution.x, iResolution.y);\n  float maxD = max(iResolution.x, iResolution.y);\n  lineWidth = minD*0.0003;\n  vec2 st = 2.*(p-iResolution.xy*0.5) / maxD;\n\n  vec3 col = get2dColor( 2.*(st) );\n\n  oc = vec4(col*1.0,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 266, 266, 303], [305, 305, 324, 324, 378], [397, 430, 474, 474, 587], [589, 589, 616, 616, 1266], [1268, 1268, 1310, 1310, 1547]], "test": "valid"}
{"id": "7l33W8", "name": "Voxel cave", "author": "StarikTenger", "description": "If it seems to be wrong try to set FOG_STRENGTH to 0.0 (line 5)", "tags": ["raycasting", "water", "voxel"], "likes": 11, "viewed": 105, "published": "Public", "date": "1636148278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141693\n#define CAVE_STRETCH 1.\n#define RAYCASTING_STEPS 50\n#define FOG_POWER 5.\n#define FOG_STRENGTH .01\n#define SHADOW_K .3\n#define FIREFLY_SIZE 0.1\n#define FIREFLY_REFLECTION_SIZE 0.3\n#define FIREFLY_REFLECTION_STRENGTH 1.\n#define WATER_LEVEL -3.2\n#define REFRACTION_K 1.03\n#define CAM_WIDTH 2500.\n#define COLOR_SATURATION .5\n#define TIME_SPEEDUP 2.;\n\nfloat time;\n\n// Sine function with frequency, amplitude and phase\nfloat wave(float x, float freq, float amp, float phase) {\n    return sin(x * freq + phase) * amp;\n}\n\n// Form of the tunnel\nvec2 main_curve(float x) {\n    x *= CAVE_STRETCH;\n    // Some weird sine composition\n    return vec2(\n        wave(x, 0.0067, 2., 2.3) + wave(x, 0.1, 1., 0.), \n        wave(x, 0.01, 16., 2.) + wave(x, 0.23, 6., 0.2)\n    );\n}\n\n// Checks if this coordinates is in solid block\nbool checkVox(vec3 pos) {\n    // Round coordinates\n    pos = floor(pos);\n    // Just another sine composition\n    return distance(pos.yz, \n        vec2(\n            wave(pos.x, 1., 1., 0.) + main_curve(pos.x).x, \n            wave(pos.x, 1., 1., 1.) + main_curve(pos.x).y\n        )) > 6. + 2.*sin(pos.x * 0.1);\n}\n\n// Light source\nvec3 light_pos;\n\n\n// Rotate funcs\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\nvec3 rotate(vec3 v, vec2 ang){\n    v = v.zxy;\n    vec2 p = rotate(vec2(v.x, v.z), ang.y);\n\tv = vec3(p.x, v.y, p.y);\n    v = vec3(rotate(vec2(v.x, v.y), ang.x), v.z);\n    return v.xzy;\n}\n\n// Actual ray direction, position\nvec3 cam_pos;\nvec3 ray_dir;\nvec3 ray_pos;\nvec3 normal;\nbool contact = false;\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n    vec3 cam;\n    vec3 normal;\n};\nint ray_stack_top = 0;\nray ray_stack[3];\nvec3 ray_pos_prev;\nvec3 ray_dir_prev;\nvec3 cam_pos_prev;\nvec3 normal_prev;\n\nvoid ray_save() {\n    ray_stack[ray_stack_top].pos = ray_pos;\n    ray_stack[ray_stack_top].dir = ray_dir;\n    ray_stack[ray_stack_top].cam = cam_pos;\n    ray_stack[ray_stack_top].normal = normal;\n    ray_stack_top++;\n}\n\nvoid ray_restore() {\n    ray_stack_top--;\n    ray_pos = ray_stack[ray_stack_top].pos;\n    ray_dir = ray_stack[ray_stack_top].dir;\n    cam_pos = ray_stack[ray_stack_top].cam;\n    normal = ray_stack[ray_stack_top].normal;\n    contact = false;\n}\n\nvoid ray_reflect(){\n    ray_pos += normal * 0.01;\n    cam_pos = ray_pos;\n    ray_dir -= normal * dot(normal, ray_dir) * 2.;\n}\n\nvoid ray_refract() {\n    float eta = REFRACTION_K;\n    vec3 I = ray_dir;\n    vec3 N = normal;\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    k *= -1.;\n    if (k >= 0.0)\n        ray_dir = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\n// Step of raycasting\nvoid raycastStep() {\n    // Find corner coresponding to ray direction\n    vec3 pos_cornered = floor(ray_pos);\n    if (ray_dir.x > 0.) pos_cornered.x += 1.;\n    if (ray_dir.y > 0.) pos_cornered.y += 1.;\n    if (ray_dir.z > 0.) pos_cornered.z += 1.;\n    \n    // Get intersections\n    vec4 intersections[3];\n    intersections[0].xyz = ray_dir * (pos_cornered.xxx - ray_pos.xxx) / ray_dir.xxx + ray_pos;\n    intersections[1].xyz = ray_dir * (pos_cornered.yyy - ray_pos.yyy) / ray_dir.yyy + ray_pos;\n    intersections[2].xyz = ray_dir * (pos_cornered.zzz - ray_pos.zzz) / ray_dir.zzz + ray_pos;\n    for (int i = 0; i < 3; i++) intersections[i].w = distance(ray_pos, intersections[i].xyz);\n    \n    // Find closest intersection\n    float min_dist = intersections[0].w;\n    int closest_intersection = 0;\n    for (int i = 1; i < 3; i++) {\n        if (intersections[i].w < min_dist) {\n            closest_intersection = i;\n            min_dist = intersections[i].w;\n        }\n    }\n    \n    ray_pos = intersections[closest_intersection].xyz;\n    \n    // Calculate normal vector\n    normal = vec3(0.,0.,0.);\n    switch (closest_intersection) {\n        case 0: normal.x = -sign(ray_dir.x); break;\n        case 1: normal.y = -sign(ray_dir.y); break;\n        case 2: normal.z = -sign(ray_dir.z); break;\n    }\n    \n    // If we should terminate, contact=true. If not, we apply micromovement to avoid ray_pos on very edge of voxel\n    if (checkVox(ray_pos - normal*0.5))\n        contact = true;\n    else\n        ray_pos -= normal*0.001;\n}\n\n// Returns color of a pixel\nvec3 raycast() {\n    vec3 col = vec3(0.4,0.4,0.4);\n    \n    // Find closest intersection\n    for (int i = 0; i < RAYCASTING_STEPS && !contact; i++)\n        raycastStep();\n        \n    // Texture & surface\n    if (contact) {\n    \n        // Get right point on texture\n        float k = 8.;\n        vec3 pos = (ray_pos / k - floor(ray_pos / k));\n        if (normal.x != 0.) pos.xy = pos.yz;\n        if (normal.y != 0.) pos.xy = pos.xz;\n        if (normal.z != 0.) pos.xy = pos.xy;\n        \n        // Texture\n        col = texture(iChannel0, pos.xy).xyz * 0.4;\n        \n        // Surface\n        normal += texture(iChannel1, pos.xy*4.).xyz * 0.4;\n        normal = normalize(normal);\n        //col = normal;\n        \n    }\n    // Light\n    float light = dot(light_pos - ray_pos, normal) * 5. / pow(distance(light_pos, ray_pos), 2.);\n    col *= light;\n    \n    // Shadow\n    bool shadow = false;\n    // save ray parameters\n    ray_save();\n    // Find obastacles between light and current point\n    cam_pos = ray_pos;\n    ray_pos += normal * 0.01;\n    ray_dir = normalize(light_pos - ray_pos);\n    contact = false;\n    float lim_dist = distance(cam_pos, light_pos);\n    for (int i = 0; distance(cam_pos, ray_pos) < lim_dist && !contact; i++)\n        raycastStep();\n    shadow = contact;\n    \n    // restore ray parameters\n    ray_restore();\n    \n    \n    // Firefly\n    {\n        vec3 proj = cam_pos + dot(ray_dir, light_pos - cam_pos) * ray_dir;\n        float dist = distance(proj, light_pos);\n        if (distance(cam_pos, light_pos) < distance(cam_pos, ray_pos))\n            col += vec3(FIREFLY_SIZE/pow(dist, 0.7),0.,0.).xxx;\n    }\n    \n    \n    \n    // Firefly reflection\n    ray_reflect();\n    if (!shadow && dot(ray_dir, light_pos - cam_pos) > 0.) {\n        vec3 proj = cam_pos + dot(ray_dir, light_pos - cam_pos) * ray_dir;\n        float dist = distance(proj, light_pos);\n        col += vec3(FIREFLY_REFLECTION_SIZE/pow(dist, .9),0.,0.).xxx * FIREFLY_REFLECTION_STRENGTH;\n    }\n    \n    \n    // Apply shadow\n    if (shadow)\n        col *= SHADOW_K;\n    \n   \n    \n    return col;\n}\n\n// Raycasting with water\nvec3 raycast_water() {\n    vec3 col = vec3(0,0,0);\n    // Find intersection with water\n    vec3 water_intersection = ray_dir * (WATER_LEVEL - ray_pos.yyy) / ray_dir.yyy + ray_pos;\n    \n    \n    // Find closest intersection\n    for (int i = 0; i < RAYCASTING_STEPS && !contact; i++)\n        raycastStep();\n    ray_save();\n    \n    // Water\n    float opacity = 1.;\n    if (dot(ray_dir, water_intersection-cam_pos) > 0. && distance(cam_pos, water_intersection) < distance(cam_pos, ray_pos)) {\n        col += vec3(0.,0.05,0.1) * 0.5;\n        normal = vec3(0,1.,0.);        \n        contact = false;\n        ray_pos = water_intersection;\n        \n        // Surface\n        // Get right point on texture\n        float k = 16.;\n        vec3 pos = (ray_pos / k - floor(ray_pos / k));\n        normal += \n            texture(iChannel2, (pos.xz + vec2(0., time * 0.1))/8.).xyz * 0.2 +\n            texture(iChannel2, pos.xz + vec2(-time * 0.02, time * 0.02)/4.).xyz * 0.1 +\n            texture(iChannel2, pos.xz + vec2(time * 0.02, -time * 0.02)).xyz * 0.05;\n        normal = normalize(normal);\n        \n        ray_save();\n        ray_reflect();\n        col += raycast() * 0.8;\n        \n        opacity = 0.4;\n        \n        // Refraction\n        ray_restore();\n        ray_refract();\n    } else {\n        ray_restore();\n        contact = true;\n    }\n    \n    col += raycast() * opacity;\n    // Calculate fog\n    cam_pos = ray_stack[ray_stack_top - 1].cam;\n    vec3 fog = vec3(.6, 0.8, 1.) * 0.5;\n    float fogK = pow(distance(cam_pos, ray_pos) * 0.1, FOG_POWER) * FOG_STRENGTH;\n    // Apply fog\n    col = (col + fog * fogK) / (1. + fogK);\n    \n    return col;\n}\n\n// Coordinates based on x-pos (to process cam and light positions)\nvec3 current_coordinates(float t) {\n    return vec3(\n        t,\n        main_curve(t).xy\n    );\n}\n\n// vec2-dir from direction vector\nvec2 get_dir(vec3 dir) {\n    return vec2(\n        atan(dir.xz).y,\n        atan(vec2(sqrt(dir.x * dir.x + dir.z * dir.z), dir.y)).y\n    );\n}\n\n// Cubic saturation; x from 0 to 1\nfloat saturate(float x) {\n    float t = 2.*x-1.;\n    return (3.*t-t*t*t)/4. + 0.5;\n}\n\n// Post-processing func\nvec3 post_proc(vec3 col) {\n    return col * (1. - COLOR_SATURATION) + \n        vec3(\n            saturate(col.x),\n            saturate(col.y),\n            saturate(col.z)\n        ) * COLOR_SATURATION;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = 235. + iTime * TIME_SPEEDUP;\n    float x = time * 1.;\n    // Camera position\n    cam_pos = current_coordinates(x);\n    // Light position\n    light_pos = current_coordinates(x + 5. + 3.*sin(time));\n    light_pos.y += 1. + 2.*sin(time * 0.33);\n    // Some kind of camera velocity\n    x += 5.;\n    vec3 move_dir = normalize(current_coordinates(x+1.) - current_coordinates(x));\n    // Camera direction\n    vec2 cam_dir = vec2(2.*PI*(iMouse.x/iResolution.x - 0.5), PI* (1./2.0*(iMouse.y/iResolution.y - 1.0) +0.25)) * 2.; \n    \n    float cam_width = CAM_WIDTH;\n    cam_width /= iResolution.x;\n    cam_dir = get_dir(move_dir);\n    ray_pos = cam_pos ;\n    \n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord/iResolution.xy- vec2(0.5, 0.5)) * iResolution.xy * 0.001;\n    // Rotation according to velocity\n    uv = rotate(uv, -move_dir.z * 0.5);\n    // Ray direction\n    ray_dir = rotate(normalize(vec3(uv.xy, (1. ) / cam_width)), cam_dir);\n\n    // Raycasting\n    vec3 col = raycast_water();\n    \n    // Limiting color\n    col.x = min(1., col.x);\n    col.y = min(1., col.y);\n    col.z = min(1., col.z);\n    \n    // Post-processing\n    col = post_proc(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l33W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[380, 433, 490, 490, 532], [534, 556, 582, 582, 780], [782, 830, 855, 880, 1141], [1177, 1193, 1223, 1223, 1297], [1299, 1299, 1329, 1329, 1484], [1789, 1789, 1806, 1806, 2007], [2009, 2009, 2029, 2029, 2251], [2253, 2253, 2272, 2272, 2378], [2380, 2380, 2400, 2400, 2631], [2633, 2655, 2675, 2724, 4178], [4180, 4208, 4224, 4224, 6292], [6294, 6319, 6341, 6341, 7973], [7975, 8042, 8077, 8077, 8139], [8141, 8175, 8199, 8199, 8314], [8316, 8351, 8376, 8376, 8435], [8437, 8461, 8487, 8487, 8663], [8665, 8665, 8722, 8722, 9953]], "test": "error"}
{"id": "7l33zl", "name": "Lavaballs", "author": "Cavouc", "description": "Efficient and cool lavaball screen saver. ", "tags": ["screensaver"], "likes": 0, "viewed": 40, "published": "Public", "date": "1636530617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float GetBallValue(vec3 ball, vec2 uv) {\n    return ball.z/((ball.x-uv.x)*(ball.x-uv.x) + ((ball.y-uv.y)*(ball.y-uv.y)));//distance(ball.xy, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ball1 = vec3(0.9 + 0.5*cos(0.5*iTime),  0.5 + 0.3*sin(0.5*iTime), 0.02);\n    vec3 ball2 = vec3(0.9 + 0.5*cos(0.37*iTime), 0.5 - 0.3*sin(0.2*iTime), 0.02);\n    vec3 ball3 = vec3(0.9 + 0.5*cos(0.43*iTime), 0.5 + 0.3*sin(0.24*iTime), 0.01);\n\n    float val\n        = GetBallValue(ball1, uv)\n        + GetBallValue(ball2, uv)\n        + GetBallValue(ball3, uv);\n\n    fragColor = vec4(0.1, 0.1, 0.1, 1);\n    fragColor += step(1.0, val) * 1.4 * vec4(0.5 + 0.5*cos(0.5*iTime+uv.xyx+vec3(0.0,2.0,4.0)), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l33zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 147], [149, 149, 206, 206, 798]], "test": "valid"}
{"id": "7l3GW2", "name": "Voronoi Incircles Approximation", "author": "nr4", "description": "Numeric approximation of cell centers. Applied to incircles of the voronoi cells.", "tags": ["voronoi", "circle", "approximation", "incircle", "inscribed"], "likes": 9, "viewed": 107, "published": "Public", "date": "1636974536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Voronoi Incircles Approximation\n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\n\nfloat sm(float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nvec2 lf2(vec2 t)\n{\n    return .5+.5*vec2(lfnoise(t+.5*iTime), lfnoise(13.327+t+.5*iTime));\n}\n\nstruct VoronoiCell2\n{\n    vec2 controlPoint;\n    vec2 center;\n    float incircleRadius;\n    vec2 gridIndex;\n    float dist;\n};\n\nvec2 scramble2(vec2 x)\n{\n    x = floor(x);\n    return x + lf2(x);\n}\n\nvec3 dnvoronoi(vec2 x)\n{\n    float n,\n        ret = 1.e3,\n        df = 1.e3,\n        d,\n        rc = 1.e3;\n    vec2 y = floor(x),\n        pf = c.yy,\n        ps = c.yy,\n        p,\n        nv;\n    \n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = scramble2(y+vec2(ivec2(i,j)));\n            \n            d = length(x-p);\n            \n            if(d < df)\n            {\n                df = d;\n                pf = p;\n            }\n        }\n    d = 1.e3;\n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = scramble2(y+vec2(ivec2(i,j)));\n            \n            vec2 o = p-pf;\n            float na = .5*length(o)-dot(x-pf,normalize(o));\n            if(na < ret)\n            {\n                ret = na;\n                nv = o;\n            }\n        }\n        \n    return vec3(ret, nv);\n}\n\nVoronoiCell2 voronoi2(vec2 x, float cellSize)\n{\n    // Scale to grid size 1\n    x /= cellSize;\n\n    VoronoiCell2 cell;\n    \n    float dmin = 1.e3, d;\n    vec2 p;\n    \n    cell.gridIndex = floor(x);\n    \n    // Find nearest control point\n    for(int i=-1; i<=1; ++i)\n        for(int j=-1; j<=1; ++j)\n        {\n            p = scramble2(cell.gridIndex + vec2(ivec2(i,j)));\n            d = length(x-p);\n            \n            if(d < dmin)\n            {\n                dmin = d;\n                cell.controlPoint = p;\n            }\n        }\n    \n    // Approximate cell center\n    // TODO: Is there a better way than this? 3 Sides determine an incircle, and the biggest one of these\n    // is the polygon incircle. But that requires the polygon vertices! Those are annoying to determine.\n    cell.center = cell.controlPoint;\n    for(int i=0; i<55; ++i)\n    {\n        cell.center -= dnvoronoi(cell.center).yz/float(i+1)*.4;\n    }\n    \n    // Find voronoi distance\n    cell.dist = 1.e3;\n    cell.incircleRadius = dnvoronoi(cell.center).x;\n    for(int i=-1; i<=1; ++i)\n        for(int j=-1; j<=1; ++j)\n        {\n            p = scramble2(cell.gridIndex + vec2(ivec2(i,j)));\n            vec2 o = p-cell.controlPoint;\n            cell.dist = min(cell.dist, .5*length(o)-dot(x-cell.controlPoint,normalize(o)));\n        }\n        \n    // Rescale\n    cell.controlPoint *= cellSize;\n    cell.center *= cellSize;\n    cell.dist *= cellSize;\n    cell.incircleRadius *= cellSize;\n    \n    return cell;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    uv += 5.3;\n\n    float size = 1./8.;\n    VoronoiCell2 cell = voronoi2(uv, size);\n    \n    // Cell color, grid cell color and bounds\n    vec3 col = mix(c.xxx-.4*c.yxx*(.5+.5*lfnoise(13.*cell.controlPoint))/*-.4*c.xxy*hash12(cell.gridIndex)*/, c.yyy, sm(cell.dist-.002));\n    \n    // Distance isolines\n    col = mix(col, col - .4*c.yxx, sm(abs(mod(cell.dist+.005,.01)-.005)));\n    \n    // Cell centers\n    float d = length(uv-cell.center)-.003;\n    col = mix(col, c.xxx, sm(d));\n    col = mix(col, c.yyy, sm(abs(d-.002)-.001));\n    \n    // Cell incircles\n    col = mix(col, mix(col, c.yyy,.5), sm(length(uv-cell.center)-cell.incircleRadius));\n    \n    // Cell control points\n    d = length(uv-cell.controlPoint)-.003;\n    col = mix(col, c.yyy, sm(d));\n    col = mix(col, c.xxx, sm(abs(d-.002)-.001));\n    \n    // Rectangular base grid\n    col = mix(col, .1*c.xxx, sm(min(abs(uv.x/size-cell.gridIndex.x),abs(uv.y/size-cell.gridIndex.y))-.002/size));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3GW2.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[777, 777, 796, 796, 863], [865, 1015, 1036, 1036, 1169], [1171, 1321, 1343, 1343, 1460], [1462, 1462, 1485, 1485, 1730], [1732, 1732, 1750, 1750, 1824], [1954, 1954, 1978, 1978, 2021], [2023, 2023, 2047, 2047, 2888], [2890, 2890, 2937, 2965, 4380], [4382, 4382, 4439, 4439, 5494]], "test": "valid"}
{"id": "7lc3R4", "name": "Gradient Orange", "author": "amyraar", "description": "random background with noise rotation / mesh warp / wave warp", "tags": ["distortion", "flow"], "likes": 1, "viewed": 234, "published": "Public", "date": "1635777133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix( mix( dot( -1.0+2.0*hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn 0.5 + 0.5*n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    vec2 tuv = uv;\n    tuv -= .5;\n\n    // rotate with Noise\n    float degree = noise(vec2(iTime*.1, tuv.x*tuv.y));\n\n    tuv.y *= 1./ratio;\n    tuv *= Rot(radians((degree-.5)*720.+180.));\n\ttuv.y *= ratio;\n\n    \n    // Wave warp with sin\n    float frequency = 5.;\n    float amplitude = 30.;\n    float speed = iTime * 2.;\n    tuv.x += sin(tuv.y*frequency+speed)/amplitude;\n   \ttuv.y += sin(tuv.x*frequency*1.5+speed)/(amplitude*.5);\n    \n    \n    // draw the image\n    vec3 colorWhite = vec3(.999, .999, .999);\n    vec3 colorDeepBlue = vec3(.999, .999, .999);\n    vec3 layer1 = mix(colorWhite, colorDeepBlue, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 colorRed = vec3(3.0, 0.4, 0.2);\n    vec3 colorBlue = vec3(3.0, 0.4, 0.2);\n    vec3 layer2 = mix(colorRed, colorBlue, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 finalComp = mix(layer1, layer2, S(.5, -.3, tuv.y));\n    \n    vec3 col = finalComp;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lc3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 55, 55, 131], [134, 258, 279, 279, 386], [388, 388, 414, 414, 881], [884, 884, 941, 941, 1983]], "test": "valid"}
{"id": "7lc3RM", "name": "Gooey-Effect", "author": "charles", "description": "clamp", "tags": ["clamp"], "likes": 3, "viewed": 53, "published": "Public", "date": "1635912645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 规范化UV (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // 定义动画\n    float delta = sin(iTime * 0.75) * 0.5;\n    \n    // 定义圆形场\n    // 1\n    vec2 circle1Center = vec2(0.78,0.5);\n    float d1 = distance(uv,circle1Center);\n    float f1 = 1. / (pow(d1, 2.) * 100.);\n    // 2\n    vec2 circle2Center = vec2(0.78 + delta,0.5);\n    float d2 = distance(uv,circle2Center);\n    float f2 = 1. / (pow(d2, 2.) * 100.);\n    \n    // 截取并平滑边缘\n    float clampped = (clamp(f1 + f2, 0.7, 1.) - 0.7) / (1. - 0.7);\n    clampped = clampped > 0.1 ? 1. : (clampped * 10.);\n\n    // Output to screen\n    fragColor = vec4(vec3(0.27, 0.6, 1.) * clampped, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lc3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 791]], "test": "valid"}
{"id": "7lcGDs", "name": "Grid with circles inside?", "author": "shigi242", "description": "circles ", "tags": ["dasdas"], "likes": 2, "viewed": 34, "published": "Public", "date": "1637320610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n\n    uv = fract(uv * 2.);\n\n    float d = length(uv.xy - 0.5 );\n    \n    float c = smoothstep(0.1, 0.44 + abs(sin(iTime)) -0.2, d);\n    c= fract(c * 45.);\n\n    float b = smoothstep(0.01, 0.009, uv.x);\n    float a = smoothstep(0.01, 0.009, uv.y);\n\n    fragColor = vec4(c + b + a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 430]], "test": "valid"}
{"id": "7lcGWn", "name": "Rotating circle in circle", "author": "LargeBee", "description": "my first attempt at making a shader", "tags": ["beginner", "circle"], "likes": 1, "viewed": 89, "published": "Public API", "date": "1635957352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nUsed Part 1 and 2 of the tutorial by the art of code\nhttps://www.youtube.com/watch?v=u5HAYVHsasc\nhttps://www.youtube.com/watch?v=GgGBR4z8C9o\n\nand borrowed some code from this shader\nhttps://www.shadertoy.com/view/XsGfWw\n*/\n\nfloat Circle (vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur, d);\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalize coordinates to values 0 -> 1\n    vec2 uv = fragCoord/iResolution.xy; //0 -> 1\n\n    //Map centre to origin\n    uv -= 0.5;                           //-0.5 -> 0.5\n\n    //Multiply uv.x by aspect ratio of screen\n    uv.x *= iResolution.x/iResolution.y;\n\n    float c = Circle(uv, vec2(0, 0), 0.4, 0.05);\n\n    float speed = 1.0;\n    float rotDist = 4.0;\n    vec2 pos = vec2(sin(iTime * speed) / rotDist, cos(iTime * speed) / rotDist);\n    c -= Circle(uv, pos, 0.1, 0.01);\n\n    //Output colour per pixel\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 280, 280, 369], [371, 371, 428, 473, 979]], "test": "valid"}
{"id": "7ld3DX", "name": "Desert Bloom", "author": "panna_pudi", "description": "Purge this desert!", "tags": ["voronoi", "flower", "grass", "hex", "desert", "cracks"], "likes": 31, "viewed": 193, "published": "Public", "date": "1636888836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Desert Bloom by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I felt like I wanted to do something cute and I didn't have\n// much experience with 2D effects. So I came across some shaders\n// from Fabrice that impressed me. For desert there're 2nd order\n// Voronoi and applied noise on the edges between individual cell. \n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane,\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Vorocracks marble/cracks by Fabrice\n// https://www.shadertoy.com/view/Xd3fRN\n//\n// Hexagonal Voronoi Line Distance by Shane\n// https://www.shadertoy.com/view/4dSfzD\n// \n// Sakura Bliss by Philippe Desgranges\n// https://www.shadertoy.com/view/ts33DX\n\nconst float PI = 3.14159265359;\nconst float TAU = 2. * PI;\n\n// 2d rotation matrix\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct HexGrid {\n    vec2 uv;\n    vec2 id;\n    float dist;\n};\n\nconst float SQRT3 = sqrt(3.);\nfloat hex_dist(vec2 p) {\n    p = abs(p);\n    // Multiplying by 0.5 is the same as using normalize()\n    float d = dot(p, 0.5 * vec2(1., SQRT3));\n    return max(d, p.x);\n}\n\nHexGrid hex_coords(vec2 p) {\n    const vec2 r = vec2(1., SQRT3);\n    const vec2 h = r / 2.;\n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h, r) - h;\n\n    vec2 gv = dot(a, a) < dot(b, b) ? a : b;\n\n    vec2 id = p - gv;\n    float dist = 0.5 - hex_dist(gv);\n    return HexGrid(gv, id, dist);\n}\n\nvec2 pix_to_hex(vec2 p) {\n    return floor(vec2(p.x + p.y / SQRT3, 2. * p.y / SQRT3));\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n\nvec2 hash22(vec2 p) {\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(262144, 32768) * n);\n    return sin(p * TAU) * 0.5 + 0.5;\n}\n\n// Random point on the hexagonal grid\nvec2 hex_pt(vec2 p) {\n    return vec2(p.x - p.y * 0.5, SQRT3 / 2. * p.y) +\n           (hash22(p) - 0.5) * SQRT3 / 2. / 2.;\n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// 2-pass voronoi traversal\nfloat voronoi(vec2 p) {\n    vec2 hex_p = pix_to_hex(p);\n\n    // LUT for possible cells for traversal\n    const vec2 offsets[7] = vec2[7](vec2(-1), vec2(0, -1), vec2(-1, 0), vec2(0),\n                               vec2(1), vec2(1, 0), vec2(0, 1));\n\n    vec2 min_cell_id = vec2(0.);\n\n    vec2 mo;\n\n    float min_dist = 8., smooth_edge_dist = 8., ln_dist, d;\n    for (int i = 0; i < 7; ++i) {\n        vec2 h = hex_pt(hex_p + offsets[i]) - p;\n        d = dot(h,h);\n        if (d < min_dist) {\n            min_dist = d;\n            mo = h;\n            min_cell_id = offsets[i];\n        }\n    }\n\n    for (int i = 0; i < 7; ++i) {\n        vec2 h = hex_pt(hex_p + offsets[i] + min_cell_id) - p - mo;\n\n        if (dot(h,h) > 0.00001) {\n            ln_dist = dot(mo + h * 0.5, normalize(h));\n            smooth_edge_dist = smin(smooth_edge_dist, ln_dist, 0.1);\n        }\n    }\n\n    return max(smooth_edge_dist, 0.);\n}\n\n// type of Perlin noise\nint MOD = 0;\n\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = smoothstep(0., 1., f);\n\n    float v =\n        mix(mix(hash21(i + vec2(0, 0)), hash21(i + vec2(1, 0)), f.x),\n            mix(hash21(i + vec2(0, 1)), hash21(i + vec2(1, 1)), f.x), f.y);\n    return MOD == 0 ? v\n           // Other two has more sharp edges.\n           : MOD == 1 ? 2. * v - 1.\n           : MOD == 2 ? abs(2. * v - 1.)\n                      : 1. - abs(2. * v - 1.);\n}\n\n#define noise22(p) vec2(noise2(p), noise2(p + 17.7))\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p *= 2., a /= 2.)\n        p *= R,\n        v += a * noise22(p);\n\n    return v;\n}\n\nvec3 cracks(vec2 p) {\n    const float RATIO = 0.9;\n    const float STONE_SLOPE = .2;\n    const float FRACTAL_DEPTH = 2.;\n    const float FRACTAL_SCALE = 1.9;\n    const float NOISE_SCALE = 1.73;\n    const float NOISE_AMP = 0.6;\n    const float BEVEL = 50.;\n    const float GAP = .01;\n\n    vec3 col = vec3(0.);\n    for (float i = 0.; i < FRACTAL_DEPTH; ++i) {\n        // Scale down\n        vec2 crack_cell = p / RATIO;\n        // Compute the magnitude of distortions on the path\n        vec2 deviation = NOISE_AMP * fbm22(p / NOISE_SCALE) * NOISE_SCALE;\n        // Find the distance to the neares crack\n        float dist = voronoi(crack_cell + deviation);\n        dist = clamp(BEVEL * (dist - GAP), 0., 1.);\n\n        dist *= 1. - STONE_SLOPE * dist;\n\n        // Exposure\n        col += vec3(1. - dist) / exp2(i);\n\n        // Shrink and rotate next layer\n        p *= FRACTAL_SCALE * rot(0.37);\n    }\n\n    return 1. - col;\n}\n\nfloat back_out(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 2.0) - f * 0.8 *sin(f * PI));\n}\n\n// Returns vec4(color, distance)\nvec4 draw_lotus(vec2 uv, vec2 id, float blur, float len) {\n    vec2 rnd = noise22(id);\n    // Computes the angle of the flower with a random rotation speed\n    float angle =\n        atan(uv.y, uv.x) * sign(rnd.x + 1e-10) + iTime * mix(-0.8, 0.8, rnd.y);\n\n    // Distance to the center of the flower\n    float transit = clamp(len, 0., 1.);\n    transit = back_out(transit);\n\n    float dist = length(uv) - (transit - 1.);\n\n    // Flower shaped distance function form the center\n    float petal = 1.0 - abs(sin(angle * 2.5));\n    float sqpetal = petal * petal;\n    petal = mix(petal, sqpetal, 0.7);\n    float sepal = 1.0 - abs(sin(angle * 2.5 + 1.5));\n    petal += sepal * 0.2;\n\n    float lotus_dist = dist + petal * 0.2;\n\n    // Compute a blurry shadow mask.\n    float shadow_blur = 0.3;\n    float shadow = smoothstep(0.5 + shadow_blur, 0.5 - shadow_blur, lotus_dist) * 0.4;\n\n    //Computes the sharper mask of the flower\n    float lotus_mask = smoothstep(0.5 + blur, 0.5 - blur, lotus_dist);\n\n    // The flower has a pink hue and is lighter in the center\n    vec3 lotus_col = vec3(1.1, 0.8, 0.7);\n    lotus_col += (0.5 - dist) * 0.2;\n\n    // Computes the border mask of the flower\n    vec3 outline_col = vec3(1.0, 0.3, 0.3);\n    float outline_mask = smoothstep(0.5 - blur, 0.5, lotus_dist + 0.045);\n\n    // Defines a tiling polar_space for the pistil pattern\n    float polar_space = angle * 1.9098 + 0.5;\n    float polar_pistil = fract(polar_space) - 0.5; // 12 / (2 * pi)\n\n    // Round dot in the center\n    outline_mask += smoothstep(0.035 + blur, 0.035 - blur, dist);\n\n    float petal_blur = blur * 2.0;\n    float pistil_mask = smoothstep(0.12 + blur, 0.12, dist) *\n                        smoothstep(0.05, 0.05 + blur, dist);\n\n    // Compute the pistil 'bars' in polar space\n    float barw = 0.2 - dist * 0.7;\n    float pistil_bar = smoothstep(-barw, -barw + petal_blur, polar_pistil) *\n                      smoothstep(barw + petal_blur, barw, polar_pistil);\n\n    // Compute the little dots in polar space\n    float pistil_dot_len = length(vec2(polar_pistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;\n    float pistil_dot = smoothstep(0.1 + petal_blur, 0.1 - petal_blur, pistil_dot_len);\n\n    //combines the middle an border color\n    outline_mask += pistil_mask * pistil_bar + pistil_dot;\n    lotus_col = mix(lotus_col, outline_col, clamp(outline_mask, 0., 1.) * 0.5);\n\n    //sets the background to the shadow color\n    lotus_col = mix(vec3(0.2, 0.2, 0.8) * shadow, lotus_col, lotus_mask);\n\n    //incorporates the shadow mask into alpha channel\n    lotus_mask = clamp(lotus_mask + shadow, 0., 1.);\n\n    // returns the flower in pre-multiplied rgba\n    return vec4(lotus_col, lotus_mask);\n}\n\n// vec4(color, distance)\nvec4 draw_leaf(vec2 q, float factor, vec2 dir) {\n    float scale = 12.;\n\n    // Rotate uv in particular direction.\n    {\n        // Originally each leaf facing up.\n        vec2 a = vec2(0., 1.);\n        // Find orthogonal direction by computing vector product in 3D\n        // cross(vec3(dir, 0), vec3(0, 0, 1))\n        dir = vec2(-dir.y, dir.x);\n\n        float angle =\n            atan(dir.y * a.x - dir.x * a.y, dir.x * a.x - dir.y * a.y);\n        q *= rot(angle);\n    }\n\n    // Distance from the center.\n    float r = length(q * scale) / factor;\n    // Mirrored polar angle.\n    float t = abs(atan(q.x, q.y) / PI);\n\n    // Scary polynomial to define the edge of leaf.\n    float leaf_edge = (11.0 * t - 6.0 * t * t * t + 6.0 * t * t * t * t * t) /\n                      (4.0 - 3.0 * t);\n    float leaf_blur = 0.9;\n\n    // Make darkened borders, but without of soft blur outside because\n    // of the limitations? of texture bombing.\n    float leaf =\n        1. - smoothstep(leaf_edge - leaf_blur, leaf_edge + leaf_blur, r);\n\n    // False shading for folded in half leaf.\n    leaf *= smoothstep(-0.3, 0.5, abs(q.x)) * 0.5;\n\n    vec3 leaf_color = 2.8 * vec3(0.11 * leaf, 0.69 * leaf, 0.14 * leaf);\n    return vec4(leaf_color, leaf);\n}\n\n\n// Defines the border between the different parts.\nfloat transit(vec2 uv) {\n    return uv.x - 0.5 + 0.35 * sin(uv.y * 3.);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord ) {\n    // Screen coordinates in [-1, 1] range with aspect.\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.);\n    uv *= 3.;\n    \n    // Distance between pixels for antialiasing.\n    float pix = fwidth(uv.x);\n    \n    // Separate coordinates and shifted from 0 by y to remove artifacts.\n    vec2 p = uv;\n    p -= vec2(iTime * 0.5, -4.5);\n    \n    // Initialize base color.\n    vec3 col = vec3(0.);\n    \n    // Hexagonal grid.\n    HexGrid gv = hex_coords(p);\n    vec2 id = gv.id;\n    \n    // Antialiazed mask to the border of hexagonal grid.\n    float hex_grid_border = smoothstep(0.02 - pix, 0.02 + pix, gv.dist);\n    vec2 gr = id + iTime * 0.5;\n    float edge = transit(gr);\n    \n    // Broken clay\n    {\n        // Compute broken clay pattern on local hex coordinates\n        // with offset based on index.\n        vec3 crack = cracks(gv.uv * 2.5 + id * 4.);\n        const vec3 desert = vec3(0.9726, 0.851, 0.300);\n        col = vec3(hex_grid_border * crack * desert);\n\n        // Add basic shading.\n        float shade = 1. - dot(gv.uv, normalize(vec2(1., -1.)));\n        col *= shade * crack * 1.5;\n    }\n\n    \n    // Flooding water\n    {\n        // Combine two masks.\n        edge = smoothstep(-0.1, 0.7, edge);\n\n        vec3 water = vec3(0.61, 0.705, 0.752);\n        col = mix(col, water, edge);\n        // To keep hex edge from disappearing\n        // float border = edge * hex_grid_border;\n        // col = mix(col, water, border);\n    }\n    \n    \n    vec2 q = p * 3.; // scaled screen coordinates.\n    vec2 cell = floor(q); // divide space on cells.\n    vec2 offset = fract(q); // local cell coordinates.\n\n    // Keep track of layering separate leaf based on priority.\n    float priority = 999.;\n\n    // The amount of neighbours to visit\n    int nbors = 1;\n    // Texture Bombing 101\n    // https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch20.html\n    // The basic idea behind texture bombing is to divide UV space into a regular\n    // grid of cells. We then place an image within each cell at a random location,\n    // using a noise or pseudo-random number function. The final result is the composite\n    // of these images over the background.\n    for (int u = -nbors; u <= nbors; ++u) {\n        for (int v = -nbors; v <= nbors; ++v) {\n            // Compute a new cell coordinates by shifting origin on integral offset.\n            vec2 cell_n = cell - vec2(u, v);\n            vec2 cell_offset = offset + vec2(u, v);\n\n            // Add more leaves in each cell for crowded overlapping.\n            for (float  n = 0.5; n < 3.; ++n) {\n                // Choose random place inside of cell\n                vec2 random_uv = hash22(cell_n + n);\n                vec2 off = cell_offset - random_uv;\n\n                float leaf_size; vec2 dir;\n                {\n                    // Recalculate hex coordinates for each cell\n                    // in very cumbersome way and will visit this\n                    // place later to:\n                    // 1. Choose leaf direction orthogonal to hex coords.\n                    // 2. Vary length depending on the distance to the edge.\n                    vec2 lu = cell_n + vec2(iTime * 1.5, 0.);\n                    lu /= 7.;\n                    HexGrid hb = hex_coords(lu - vec2(iTime * 0.5, 0.));\n\n                    float curvy_wall = lu.x + 0.5 + 0.2 * sin(lu.y * 3. + iTime * 0.3);\n                    float edge_mask = smoothstep(0.1 - 0.3, 0.1 , hb.id.y);\n\n                    leaf_size = clamp(curvy_wall * edge_mask, 0., 1.);\n\n                    vec2 k = hex_coords(cell_n).id - cell_n;\n                    dir = k + (hash22(random_uv + n) * 2. - 1.) * 0.25;\n                }\n\n                // We need to check adjacent cells for overlapping leaves.\n                // This process is computationally heavy and might be logical to\n                // split this function on two. The first for checking the hit `leaf.w`\n                // and coloring.\n                vec4 leaf = draw_leaf(off, leaf_size, dir);\n                if (leaf.w > 0. && random_uv.x < priority) {\n                    col = leaf.rgb;\n                    priority = random_uv.x;\n                }\n            }\n        }\n    }\n\n    \n    // Lotus flowers\n    {\n        float len = transit(gr + vec2(0.6, 0.));\n\n        float blur = 0.1;\n        vec4 lotus = draw_lotus(gv.uv * 1.3, gv.id, blur, len);\n        col = mix(col, lotus.rgb, lotus.w);\n    }\n\n    // Vignette\n    vec2 d = abs(fragCoord / iResolution.xy - vec2(0.5)) * 1.15;\n    d = pow(d, vec2(2.0));\n    col *= pow(clamp(1.0 - dot(d, d), 0., 1.0), 3.5);\n    \n    // Gamma Correction\n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColour = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ld3DX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[867, 889, 908, 908, 974], [1069, 1069, 1093, 1093, 1239], [1241, 1241, 1269, 1269, 1534], [1536, 1536, 1561, 1561, 1624], [1626, 1626, 1648, 1648, 1717], [1720, 1720, 1741, 1741, 1862], [1864, 1902, 1923, 1923, 2026], [2028, 2078, 2117, 2117, 2217], [2219, 2247, 2270, 2270, 3154], [3194, 3194, 3216, 3216, 3650], [3705, 3705, 3725, 3725, 3901], [3903, 3903, 3924, 3924, 4825], [4827, 4827, 4852, 4852, 4928], [4930, 4963, 5021, 5021, 7651], [7653, 7678, 7726, 7726, 8912], [8915, 8966, 8990, 8990, 9039], [9041, 9041, 9099, 9155, 13851]], "test": "error"}
{"id": "7ldGD2", "name": "Stained Glass Window", "author": "1j01", "description": "Based on [url=https://www.shadertoy.com/view/Xdj3Wh]Xmas Fractal 2Tweets[/url]", "tags": ["fractals", "glass", "kaleidoscope", "windows", "window", "cathedral", "stainedglass", "church", "pane", "panes", "mosque", "shattered"], "likes": 6, "viewed": 192, "published": "Public API", "date": "1636786369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on Xmas Fractal 2Tweets by mplanck https://www.shadertoy.com/view/Xdj3Wh\n\nvoid imageSample( out vec4 f, in vec2 w )\n{\n\tfloat t = .001 * iTime + .3;\n\tvec4 p = abs(4.-8.*w.xyxx / iResolution.x), c=p*.0;\n\tp.yx *= 60. * t * 0.3;\n    t *= 0.9; // not just affecting time\n\tfor (float d=.2;d<3.;d+=.3) {\n\t\tp -= .5*d;\n\t\tfor (int i=0;i<8;i++) p.xy=mat2(\n            cos(t),sin(t),-sin(t),cos(t))*(p.xy+sign(p.yx)*vec2(-.2,1.6)\n        );\n        //p = mod(p+c, 10.);\n\t\tc += .1*p;\n        c = mod(c, 4.);\n        //c.xz = c.zx;\n        c *= w.y/1000.; // gradient\n\t}\n\t\n\tf = c;\n}\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    // I'm doing some sort of naive edge detection,\n    // in order to make the border of the imagined stained glass panes.\n    vec4 s1, s2, s3, s4;\n    float d = 1.2;\n\timageSample(s1, w+vec2(-d, 0.));\n\timageSample(s2, w+vec2(+d, 0.));\n\timageSample(s3, w+vec2(0., -d));\n\timageSample(s4, w+vec2(0., +d));\n    \n    // color components -> single value (not weighted perceptually or anything)\n    s1.xyzw = vec4(s1.x + s1.y + s1.z);\n    s2.xyzw = vec4(s2.x + s2.y + s2.z);\n    \n    // take main sample\n\timageSample(f, w);\n    \n    // apply black borders\n    f -= abs(s1 - s2) * 20.;\n    f -= abs(s3 - s3) * 20.;\n    \n    //f -= 0.2;\n    //f = pow(f, vec4(0.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 126, 126, 577], [579, 579, 620, 744, 1280]], "test": "valid"}
{"id": "7ldGR4", "name": "rgb for life", "author": "ifdita_hasan", "description": "Moving circles", "tags": ["circles"], "likes": 0, "viewed": 33, "published": "Public", "date": "1635804864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r,r-blur,d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    // Corrected for aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    float r = circle(uv,vec2(sin(iTime)*.5,cos(iTime)*.5),.5,.005);\n    float g = circle(uv,vec2(sin(iTime*2.)*.5,cos(iTime*2.)*.5),.3,.005);\n    float b = circle(uv,vec2(sin(iTime*3.)*.5,cos(iTime*3.)*.5),.4,.005);\n\n    // Output to screen\n    fragColor = vec4(r,g,b,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 134], [136, 136, 193, 244, 640]], "test": "valid"}
{"id": "7ldGWf", "name": "Smooth Fog Shader", "author": "deusnovus", "description": "Just something I created to hopefully use in RetroArch someday.", "tags": ["noise", "fog", "smoke"], "likes": 4, "viewed": 75, "published": "Public", "date": "1636881890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a remix of pontino's Fog Shader: https://www.shadertoy.com/view/tst3zr\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst vec3 COLOR = vec3(0.25, 0.31, 0.49);\nconst vec3 BG = vec3(0.0, 0.0, 0.0);\nconst float ZOOM = 3.;\nconst int OCTAVES = 4;\nconst float INTENSITY = 2.;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9818,79.279)))*43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0 * fract(sin(st) * 7.);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // smootstep\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat fractal_brownian_motion(vec2 coord) {\n\tfloat value = 0.0;\n\tfloat scale = 0.2;\n\tfor (int i = 0; i < 4; i++) {\n\t\tvalue += noise(coord) * scale;\n\t\tcoord *= 2.0;\n\t\tscale *= 0.5;\n\t}\n\treturn value + 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n\tst *= iResolution.xy  / iResolution.y;    \n    vec2 pos = vec2(st * ZOOM);\n\tvec2 motion = vec2(fractal_brownian_motion(pos + vec2(iTime * -0.5, iTime * -0.3)));\n\tfloat final = fractal_brownian_motion(pos + motion) * INTENSITY;\n    fragColor = vec4(mix(BG, COLOR, final), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 300, 300, 373], [375, 375, 397, 397, 515], [517, 517, 539, 539, 960], [963, 963, 1006, 1006, 1168], [1170, 1170, 1227, 1227, 1552]], "test": "valid"}
{"id": "7lG3RV", "name": "Late Night Waves", "author": "acoo", "description": "Some simple waves and space transformations.", "tags": ["waves"], "likes": 1, "viewed": 50, "published": "Public", "date": "1638032301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n    vec3 mainColor = vec3(0.4, 0.5, 0.8);\n\n    vec2 st = uv;\n    uv.x += sin(st.y * iTime) * cos(st.y + iTime);\n    uv.y += cos(st.x * iTime) * sin(st.x - iTime);\n\n    float c = cos(iTime) * 2.0 - 1.0;\n    float s = -sin(iTime) * 2.0 - 1.0;\n    mat2 rot = mat2\n    (\n         c, -s, \n         s,  c\n    );\n    \n    uv *= rot;\n    uv.x += sin(iTime) * 2.0 - 1.0;\n    uv.y -= cos(iTime) * 2.0 - 1.0;\n\n    uv.x = mod(10.0, abs(uv.x));\n    uv.y = mod(10.0, abs(uv.y));\n    \n    color = mix(vec3(1.0), mainColor, 1.0 - length(uv)) * (vec3(1.0) - vec3(abs(uv), 0.0));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lG3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 798]], "test": "valid"}
{"id": "7lG3zd", "name": "Magical King Granzort", "author": "luolin", "description": "A moving picture in animation（Magical King Granzort）", "tags": ["2dcirletesttime"], "likes": 0, "viewed": 87, "published": "Public API", "date": "1638272016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float isInSector(vec2 tex, vec2 center, float dis, float t) // 是否在扇形中\n{\n\tfloat res = 0.;\n\tfloat theta = radians(clamp(t, 0., 360.));\n    \n\tfloat rotate_x = sin(theta/2.) + center.x;\n\tfloat rotate_y = cos(theta/2.) + center.y;\n\tvec2 half_theta_v = normalize(vec2(rotate_x, rotate_y) - center);\n\tvec2 c_top = vec2(0, 1);\n\tvec2 cur_v = normalize(tex - center);\n\tfloat cur_theta = acos(dot(half_theta_v, cur_v));\n\treturn step(cur_theta, theta/2.) * step(0., -length(vec2(tex - center)) + dis);\n}\n\nfloat sdfCircle(vec2 tex, vec2 center, float dis)\n{\n    return dis - length(vec2(tex - center)) ;\n}\n\nfloat getPointLineDis(vec2 tex, vec2 p1, vec2 p2)\n{\n\tif((tex.y - p2.y)*(p1.x - p2.x) == (p1.y - p2.y) * (tex.x - p2.x))\n\t{\n\t\treturn 0.0;//共线\n\t}\n\tfloat len1 = length(tex -p1);\n\tfloat len2 = length(tex -p2);\n\tfloat len3 = length(p1 -p2);\n\tfloat half_p = 0.5 * (len1 + len2 + len3);\n\tfloat s = sqrt(half_p * (half_p - len1) * (half_p-len2) * (half_p-len3));\n\tfloat dis = s * 2. / len3;\n\treturn dis;\n}\n\n\nfloat sdfPloygon(mat4x4 points, vec2 tex, float is_in ) // 计算多边形距离场\n{\n\tfloat c=0.;\n\tfloat cur_dis = 100.;\n\n\tint j=0;\n\tint k=0;\n\tint temp_j = 0;\n\tint temp_k = 0;\n\tfor (int i = 0; i < 3; i++) \n\t{\t\n\t\tj = (i*2) / 4;\n\t\ttemp_j = i*2 - i*2 / 4 * 4;\n\t\tvec2 p = vec2(points[j][temp_j], points[j][temp_j + 1]);\n\t\tk = (i*2 + 2) / 4;\n\t\ttemp_k = (i+1)*2 - (i+1)*2 / 4 * 4;\n\t\tvec2 p1 = vec2(points[k][temp_k], points[k][temp_k + 1]);\n\t\n\t\tfloat tmp = p1.x - p.x;\n\t\tvec2 cur_center = 0.5 *(p + p1);\n\t\tfloat dis_c = length(cur_center - tex);\n\t\tfloat length_line = length(p1 - p);\n\t\tfloat dis_l = getPointLineDis(tex, p, p1);\n\t\tfloat dis_2p = min(length(tex - p), length(tex - p1));\n\t\tfloat flag_in_range_line = dot(p-tex, p-p1) * dot(p1-tex, p1-p);\n        cur_dis = min(cur_dis, max(dis_l * step(0., flag_in_range_line),  dis_2p * step(flag_in_range_line, 0.)));\n    }\n\n\treturn cur_dis * (1. - 2. *step(is_in, 0.5));\n}\n\nfloat IsInPloygon(mat4x4 points, vec2 tex ) // 判断是否在多边形内\n{\n\tfloat c=0.;\n\tint j=0;\n\tint k=0;\n\tint temp_j = 0;\n\tint temp_k = 0;\n\tfor (int i = 0; i < 3; i++) \n\t{\t\n\t\tfloat flag = 1.0f;\n\t\tj = (i*2) / 4;\n\t\ttemp_j = i*2 - (i*2 / 4) * 4;\n\t\tvec2 p = vec2(points[j][temp_j], points[j][temp_j + 1]);\n\t\tk = (i*2 + 2) / 4;\n\t\ttemp_k = (i+1)*2 - (i+1)*2 / 4 * 4;\n\t\tvec2 p1 = vec2(points[k][temp_k], points[k][temp_k + 1]);\n\t\tfloat tmp = p1.x - p.x;\n\t\tflag = step(0.00001, abs(tmp));\n\t\tfloat slope = (p1.y - p.y) / tmp;\n\t\tfloat cond1 = step(p.x, tex.x) * step(tex.x, p1.x);\n\t\tfloat cond2 = step(p1.x, tex.x) * step(tex.x, p.x);\n\t\tfloat above = step(tex.y, (slope * (tex.x - p.x) + p.y));\n\t\tfloat cur_val = above* flag *(cond1 + cond2);\n\t\tc = c + cur_val;\n    }\n\treturn mod(c, 2.);\n}\n\nfloat sdfTrigle(vec2 tex, vec2 p0, vec2 p1, vec2 p2)\n{\n\tmat4x4 points;\n\tpoints[0].xy = p0;\n\tpoints[0].zw = p1;\n\tpoints[1].xy = p2;\n\tpoints[1].zw = p0;\n\n\tfloat is_in_tri = IsInPloygon(points, tex);\n\tfloat res = sdfPloygon(points, tex,  is_in_tri );\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 center = 0.5 * iResolution.xy;\n    vec3 background_color = vec3(0.5, 0.5, 0.5);\n    vec3 c1 = vec3(1.0, 0., 0.);\n    vec3 c2 = vec3(0., 1., 0.);\n    vec3 c3 = vec3(0., 0., 1.);\n\tfloat edge_width =iResolution.y * 0.025; \n\tfloat radius = iResolution.y * 0.25;\n    \n    float cir_d = sdfCircle(uv, center, radius);\n    float anti = fwidth(cir_d);\n\tvec3 col =  mix(background_color, c1, smoothstep(-anti, anti, cir_d ));\n    float d1 = sdfCircle(uv, center, radius - edge_width);\n\tfloat anti1 = fwidth(d1);\n\tfloat edge_alpha = smoothstep(-anti1, anti1, d1);\n\tcol = mix(col, background_color, edge_alpha);\n    // Output to screen\n\n\tfloat is_in_0 = isInSector(uv, center, radius + anti, iTime*100.);\n\n\tif(is_in_0 <= 0.)\n\t{\n\t\tcol = background_color.xyz;\n\t}\n\n\tfloat tri_d0 = 0.;\n\tfloat tri1_anti = 0.;\n\tfloat tri1_anti1 = 0.;\n\n\tfloat tri2_anti = 0.;\n\tfloat tri2_anti1 = 0.;\n\n\tvec3 col1 = col;\n\tvec3 col2 = col;\n\tfloat tri_radius = radius - edge_width - anti1;\n\n\tif((cir_d > (edge_width + anti1) || cir_d <0. - anti )&& iTime*100. > 360.)\n\t{\n\t\tvec2 p0 = vec2(center.x, center.y + tri_radius);\n\t\tvec2 p1 = vec2(center.x + tri_radius * cos(radians(30.)), center.y - tri_radius* sin(radians(30.)));\n\t\tvec2 p2 = vec2(center.x - tri_radius * cos(radians(30.)), center.y - tri_radius* sin(radians(30.)));\n\n\t\ttri_d0 = sdfTrigle(uv, p0, p1, p2);\n\t\ttri1_anti = fwidth(tri_d0);\n\t\tcol1 = mix(background_color, c2, smoothstep(-tri1_anti, tri1_anti,tri_d0 ));\n\n\t\ttri1_anti1 = fwidth(tri_d0 - edge_width);\n\t\tcol1 = mix(col1, background_color, smoothstep(-tri1_anti1, tri1_anti1,tri_d0 - edge_width ));\n\n\t\tfloat is_in_1 = isInSector(uv, center, radius + tri1_anti, iTime*100. - 360.);\n\n\t\tif(is_in_1 <= 0.)\n\t\t{\n\t\t\tcol1 = background_color.xyz;\n\t\t}\n\t\tcol = col1;\n\t}\n\n\tvec2 p0 = vec2(center.x - tri_radius * cos(radians(30.)),  center.y + tri_radius * sin(radians(30.)));\n\tvec2 p1 = vec2(center.x + tri_radius * cos(radians(30.)), center.y + tri_radius* sin(radians(30.)));\n\tvec2 p2 = vec2(center.x , center.y  - tri_radius);\n\n\tfloat tri_d1 = sdfTrigle(uv, p0, p1, p2);\n\ttri2_anti = fwidth(tri_d1);\n\ttri2_anti1 = fwidth(tri_d1 - edge_width);\n\n\tbool flag0 = tri_d0 > edge_width + tri1_anti || tri_d0 < 0. - tri1_anti1;\n\tbool flag1 = (tri_d0 <= edge_width + tri1_anti && tri_d0 >= 0. - tri1_anti1) &&  (tri_d1 <= edge_width + tri2_anti && tri_d1 >= 0. - tri2_anti1);\n\n\tif((cir_d > (edge_width + anti1) || cir_d < 0. - anti ) && (flag0 || flag1 ) && iTime*100. > 720.)\n\t{\n        \n        if(flag1)\n        {\n            col2 = mix(col, c3, smoothstep(-tri2_anti, tri2_anti,tri_d1 ));\n            col2 = mix(col2, col, smoothstep(-tri2_anti1, tri2_anti1,tri_d1 - edge_width ));\n        }\n        else\n        {\n            col2 = mix(background_color, c3, smoothstep(-tri2_anti, tri2_anti,tri_d1 ));\n            col2 = mix(col2, background_color, smoothstep(-tri2_anti1, tri2_anti1,tri_d1 - edge_width ));\n        }\n\n\t\tfloat is_in_2 = isInSector(uv, center, radius + tri2_anti1, iTime*100. - 720.);\n\n\t\tif(is_in_2 <= 0.)\n\t\t{\n\t\t\tcol2 = col;\n\t\t}\n\t\tcol = col2;\n\t}\n\t\n    fragColor = vec4(col,1.0);\n   }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lG3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 503], [505, 505, 556, 556, 604], [606, 606, 657, 657, 1007], [1010, 1010, 1095, 1095, 1928], [1930, 1930, 2006, 2006, 2714], [2716, 2716, 2770, 2770, 2978], [2980, 2980, 3036, 3086, 6187]], "test": "error"}
{"id": "7lG3zR", "name": "My first 2D SDF line", "author": "Jpg3D", "description": "Just that. Trying to derive a line LOL", "tags": ["simple", "sdf", "line"], "likes": 0, "viewed": 21, "published": "Public", "date": "1637056643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n#define lineSpeed 0.2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 50.0*(fragCoord-0.5)/iResolution.x; //Center the UV and make it bigger\n    //P1 and P2 are point 1 and point 2 positions\n    vec2 p1 = vec2(22.0+sin(iTime*1.123456789*lineSpeed)*12.5,15.0+sin(iTime*1.3210987654*lineSpeed)*10.0);\n    vec2 p2 = vec2(33.0+sin(iTime*1.987654321*lineSpeed)*12.5,15.0+sin(iTime*1.6789012345*lineSpeed)*10.0);\n    vec2 dir = normalize(p2-p1);\n    \n    float h = min(1.0,max(0.0,dot(dir,uv-p1)/length(p1-p2))); //from 0.0 to 1.0 wich point is closer p1 or p2\n    float d = length((uv-p1)-h*(p2-p1));//<- This line is possibly why scientist believe in god.\n    //The SDF is already on d\n    float mask = smoothstep(0.95,1.05,d);\n    \n    //Add it some color\n    vec3 color1=vec3(0.0,0.0,1.0);\n    vec3 color2=vec3(0.0,1.0,1.0);\n    \n    vec3 color3=vec3(1.0,0.0,1.0);\n    vec3 color4=vec3(1.0,1.0,0.0);\n    \n    vec3 bg1=vec3(0.0,0.5,0.75);\n    vec3 bg2=vec3(0.0,0.75,1.0);\n    \n    fragColor = vec4(lerp(lerp(color1,color2,d),lerp(color3,color4,d),h)*(1.0-mask)+mask*lerp(bg1,bg2,(sin(-iTime*8.0-d*3.1415)*0.5+0.5)),1.0);\n    \n}\n\n\n\n/*\n//This is the old version. It should be easier to understand.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5)/iResolution.x*100.0;\n\n    vec2 p1 = vec2(35.0+sin(iTime+1.123456789)*25.0,30.0+sin(iTime*1.3210987654)*20.0);\n    vec2 p2 = vec2(65.0+sin(iTime-1.987654321)*25.0,30.0+sin(iTime*1.6789012345)*20.0);\n    vec2 dir = normalize(p2-p1);\n\n    float d1 = length(p1-uv); //<-Distance to point 1\n    float d2 = length(p2-uv); //<-Distance to poinr 2\n    \n    float d3 = length(dot(vec2(dir.y,-dir.x),uv-p1)); //<-Distance to line center\n    \n    float d;\n    float ll = dot(dir,uv-p1)/length(p1-p2); //line length? This line was a pure faith act\n    if(ll<0.0||ll>1.0){\n        d = smoothstep(0.9,1.1,min(d1,d2));\n    }else{\n        d = smoothstep(0.9,1.1,d3);\n    }\n    \n    fragColor = vec4(d,d,d,1.0);\n}\n\n*/\n\n\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lG3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 104], [127, 127, 184, 184, 1253]], "test": "valid"}
{"id": "7lGGDR", "name": "solar radiant", "author": "Mr_Steve", "description": "pulsing emissions", "tags": ["pulsing"], "likes": 0, "viewed": 13, "published": "Public", "date": "1637701381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = vec3(0.0);\n  \n  float angle = atan(-fragCoord.x + 0.25, fragCoord.x - 0.5) * 0.05;\n  float len = length(fragCoord * .0125 -vec2(0.5, 0.25))*.7;\n  \n  color.r += (len * 40.0 + angle * 40.0 + iTime);\n  color.g += cos(len * 3.0 + angle * 6.0 - iTime);\n  color.b += cos(len * 50.0 + angle * 50.0 + 3.0);\n   \n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 409]], "test": "valid"}
{"id": "7lGGRV", "name": "eindacor_gears", "author": "Eindacor_DS", "description": "they're gears, you dolt!", "tags": ["gears"], "likes": 2, "viewed": 252, "published": "Public API", "date": "1637982326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA .002\n#define PI 3.1415926\n#define MIN_GEAR_RADIUS .1\n#define MIN_GEAR_DIVISION 16.\n#define TOOTH_LENGTH .01\n#define GEAR_ROTATION_SPEED .5\n#define SHADOW_MODIFIER .8\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\n#define DRAW_SHADOWS true\n\n/*\n    TODO:\n        - reduce draw passes by incorporated shadow pass into gear/peg process\n*/\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getGearRadius(float gearIndex) {\n    float randValue = hash(vec2(gearIndex, gearIndex));\n    if (randValue < .333) {\n        return MIN_GEAR_RADIUS;\n    } else if (randValue < .666) {\n        return MIN_GEAR_RADIUS * 2.;\n    } else {\n        return MIN_GEAR_RADIUS * 4.;\n    }\n}\n\nvec4 getGearLocations(float gearLinkValue, float firstIndex, float secondIndex) {\n    vec2 first = vec2(0.);\n    \n    float radialOffsetIncrement = PI / MIN_GEAR_DIVISION * 2.;\n    float maxOffset = PI / 4.;\n    float maxIncrements = 4.;\n    float radialOffset = radialOffsetIncrement * floor(maxIncrements * hash(vec2(gearLinkValue * gearLinkValue, gearLinkValue * 2.)));\n    float rotationVariance = PI / 2.;\n    float rotation = mix(rotationVariance / -2., rotationVariance / 2., hash(vec2(gearLinkValue * gearLinkValue, gearLinkValue * 2.)));\n  \n    mat2x2 rotationMatrix = createRotationMatrix(radialOffset);\n    \n    float dist = getGearRadius(firstIndex) + getGearRadius(secondIndex);\n    \n    vec2 second = (vec2(dist, 0.) * rotationMatrix) + first;\n    \n    return vec4(first.x, first.y, second.x, second.y);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nfloat getPegSmoothStep(vec2 uv, vec2 gearLocation, float gearIndex) {\n    float dist = distance(uv, gearLocation);\n    float holeRadius = .03;\n    \n    if (dist < holeRadius) {\n        return smoothstep(holeRadius - AA, holeRadius - AA * 2., dist);\n    }\n}\n\nbool getHasSpokes(float gearIndex) {\n    return hash(vec2(gearIndex * .23, gearIndex + 89.)) < .75;\n}\n\nvec2 rotateAroundPoint (vec2 anchor, vec2 p, float rads) {\n    mat2x2 rotationMatrix = createRotationMatrix(rads);\n    return (p - anchor) * rotationMatrix + anchor;\n}\n\nint getSpokeCount(float gearIndex) {\n    return int(mix(3., 8., hash(vec2(gearIndex * -.118, gearIndex + 2.))));\n}\n\nfloat getGearSmoothStep(vec2 uv, vec2 gearLocation, float gearIndex, mat2x2 rotationMatrix) {\n    float dist = distance(uv, gearLocation);\n\n    float gearRadius = getGearRadius(gearIndex);\n\n    float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n    float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n    \n    uv = ((uv - gearLocation) * rotationMatrix) + gearLocation;\n    \n    float rads = atan(uv.y - gearLocation.y, uv.x - gearLocation.x);\n    \n    float minVal = gearRadius - TOOTH_LENGTH;\n    float maxVal = gearRadius + TOOTH_LENGTH;\n\n    float val = 0.;\n    int spokeCount = getSpokeCount(gearIndex);\n    float innerRadiusDimension = minVal * .4 * hash(vec2(gearIndex, gearIndex));\n    float outerRadiusDimension = minVal * mix(.7, .85, hash(vec2(-gearIndex, -gearIndex)));\n    float spokeWidth = minVal * mix(.02, .1, hash(vec2(gearIndex, -gearIndex)));\n    if (getHasSpokes(gearIndex)) {\n        bool renderRadius = false;\n        for (int i=0; i<spokeCount && !renderRadius; ++i) {\n            vec2 rotatedUv = rotateAroundPoint(gearLocation, uv, float(i) * 2. * PI / float(spokeCount));\n            if (rotatedUv.x < gearLocation.x && abs(rotatedUv.y - gearLocation.y) < spokeWidth) {\n                renderRadius = true;\n            }\n        }\n        \n        if (!renderRadius) {\n            if (dist < innerRadiusDimension) {\n                return smoothstep(innerRadiusDimension, innerRadiusDimension - 2. * AA, dist);\n            }\n            \n            if (dist > outerRadiusDimension && dist <= minVal) {\n                return smoothstep(outerRadiusDimension, outerRadiusDimension + 2. * AA, dist);\n            }\n            \n            if (dist < minVal) {\n                float spokeVal = 0.;\n                for (int i=0; i<spokeCount && !renderRadius; ++i) {\n                    vec2 rotatedUv = rotateAroundPoint(gearLocation, uv, float(i) * 2. * PI / float(spokeCount));\n                    if (rotatedUv.x < gearLocation.x) {\n                        spokeVal = mix(spokeVal, 1., smoothstep(spokeWidth + AA, spokeWidth, abs(rotatedUv.y - gearLocation.y)));\n                    }\n                }\n            \n                return spokeVal;\n            }\n        }\n    }\n    \n    float radIncrements = 2. * PI / gearDivisions;\n    \n    float radIndex = floor(rads / radIncrements);\n    float toothPos = fract(rads / radIncrements);\n\n    // max tooth width is .5\n    float toothWidth = .4;\n    \n    if (mod(radIndex, 2.) == 0.) {\n        float toothVal = smoothstep(toothWidth / 2., 1. - toothWidth / 2., toothPos);\n        gearRadius = mix(minVal, maxVal, toothVal);\n    } else {\n        float toothVal = smoothstep(toothWidth / 2., 1. - toothWidth / 2., toothPos);\n        gearRadius = mix(maxVal, minVal, toothVal);\n    }\n   \n    return mix(val, 1., smoothstep(gearRadius + AA, gearRadius - AA, dist));\n}\n\nvec3 getNextGearLocationAndIndex(float previousIndex, vec2 previousGearLocation) {\n    float gearIndex = previousIndex + 1.;\n    float gearLinkValue = hash(vec2(previousIndex, gearIndex));\n    vec4 gearLocations = getGearLocations(gearLinkValue, previousIndex, gearIndex);\n    vec2 gearLocation = previousGearLocation + (gearLocations.zw - gearLocations.xy);\n    \n    return vec3(gearLocation.x, gearLocation.y, gearIndex);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nvec4 getPreceedingGearsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    float rotationSpeed,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float targetIndex = referenceFirstIndex - 1.;\n        float linkValue = hash(vec2(targetIndex, referenceFirstIndex));\n        \n        bool isEven = floor(mod(targetIndex, 2.)) <= 0.1;\n        \n        float gearRadius = getGearRadius(targetIndex);\n        float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n        float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n        \n        float startingAngle = isEven ? PI / gearDivisions : PI / gearDivisions;\n        \n        float gearSizeSpeedAmplification = MIN_GEAR_RADIUS / gearRadius;\n        \n        float rotation = rotationSpeed * gearSizeSpeedAmplification;\n        if (isEven) {\n            rotation *= -1.;\n        }\n        \n        mat2x2 rotationMatrix = createRotationMatrix(startingAngle + rotation);\n        \n        vec3 gearColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : getRandomColor(linkValue);\n        \n        vec4 targetReferenceFirstLocations = getGearLocations(linkValue, targetIndex, referenceFirstIndex);\n        vec2 targetLocation = targetReferenceFirstLocations.xy - targetReferenceFirstLocations.zw + referenceLocations.xy;\n        \n        outColor = mix(outColor, vec4(gearColor, 1.), getGearSmoothStep(uv, targetLocation, targetIndex, rotationMatrix)); \n        \n        referenceFirstIndex = targetIndex;\n        referenceSecondIndex = targetIndex - 1.;\n        referenceLocations = vec4(targetLocation.x, targetLocation.y, referenceLocations.x, referenceLocations.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getPreceedingPegsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    vec3 pegColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : vec3(.2);\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float targetIndex = referenceFirstIndex - 1.;\n        float linkValue = hash(vec2(targetIndex, referenceFirstIndex));\n        \n        vec4 targetReferenceFirstLocations = getGearLocations(linkValue, targetIndex, referenceFirstIndex);\n        vec2 targetLocation = targetReferenceFirstLocations.xy - targetReferenceFirstLocations.zw + referenceLocations.xy;\n        \n        outColor = mix(outColor, vec4(pegColor, 1.), getPegSmoothStep(uv, targetLocation, targetIndex)); \n        \n        referenceFirstIndex = targetIndex;\n        referenceSecondIndex = targetIndex - 1.;\n        referenceLocations = vec4(targetLocation.x, targetLocation.y, referenceLocations.x, referenceLocations.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getSucceedingGearsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    float rotationSpeed,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float linkValue = hash(vec2(referenceFirstIndex, referenceSecondIndex));\n        \n        bool isEven = floor(mod(referenceFirstIndex, 2.)) <= 0.1;\n        \n        float gearRadius = getGearRadius(referenceFirstIndex);\n        float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n        float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n        \n        float startingAngle = isEven ? PI / gearDivisions : PI / gearDivisions;\n        \n        float gearSizeSpeedAmplification = MIN_GEAR_RADIUS / gearRadius;\n        \n        float rotation = rotationSpeed * gearSizeSpeedAmplification;\n        if (isEven) {\n            rotation *= -1.;\n        }\n\n        mat2x2 rotationMatrix = createRotationMatrix(startingAngle + rotation);\n        \n        vec3 gearColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : getRandomColor(linkValue);\n        \n        outColor = mix(outColor, vec4(gearColor, 1.), getGearSmoothStep(uv, referenceLocations.xy, referenceFirstIndex, rotationMatrix)); \n        \n        vec3 nextLocationAndIndex = getNextGearLocationAndIndex(referenceSecondIndex, referenceLocations.zw);\n        \n        referenceFirstIndex = referenceSecondIndex;\n        referenceSecondIndex = referenceSecondIndex + 1.;\n        referenceLocations = vec4(referenceLocations.z, referenceLocations.w, nextLocationAndIndex.x, nextLocationAndIndex.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getSucceedingPegsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    vec3 pegColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : vec3(.2);\n    \n    for (int i=0; i<gearsToRender; i++) {  \n        outColor = mix(outColor, vec4(pegColor, 1.), getPegSmoothStep(uv, referenceLocations.xy, referenceFirstIndex)); \n        \n        vec3 nextLocationAndIndex = getNextGearLocationAndIndex(referenceSecondIndex, referenceLocations.zw);\n        \n        referenceFirstIndex = referenceSecondIndex;\n        referenceSecondIndex = referenceSecondIndex + 1.;\n        referenceLocations = vec4(referenceLocations.z, referenceLocations.w, nextLocationAndIndex.x, nextLocationAndIndex.y);\n    }\n    \n    return outColor;\n}\n\nfloat sinestep(float edge1, float edge2, float val) {\n    float lower = edge1 < edge2 ? edge1 : edge2;\n    float upper = edge1 < edge2 ? edge2 : edge1;\n\n    if (val < lower) {\n        return 0.;\n    } else if (val > upper) {\n        return 1.;\n    }\n    \n    return -1. * cos(1. / (upper - lower));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    float travelTime = 2.;\n    \n    float dotRadius = .1;\n    \n    float timelerp = fract(iTime / travelTime);\n    \n    int gearsToRender = 16;\n    \n    float originFirstIndex = floor(iTime / travelTime);\n    float originSecondIndex = originFirstIndex + 1.;\n    float linkValue = hash(vec2(originFirstIndex, originSecondIndex));\n    vec4 originLocations = getGearLocations(linkValue, originFirstIndex, originSecondIndex);\n    vec2 firstLocation = originLocations.xy;\n    vec2 secondLocation = originLocations.zw;\n    \n    float previousIndex = originFirstIndex - 1.;\n    float prevLinkValue = hash(vec2(previousIndex, originFirstIndex));\n    vec4 prevFirstLocations = getGearLocations(prevLinkValue, previousIndex, originFirstIndex);\n    vec2 previousLocation = prevFirstLocations.xy - prevFirstLocations.zw + firstLocation;\n    \n    vec2 prevFirstMid = mix(previousLocation, firstLocation, .5);\n    vec2 firstSecondMid = mix(firstLocation, secondLocation, .5);\n    \n    vec2 lerpA = mix(prevFirstMid, firstLocation, timelerp);\n    vec2 lerpB = mix(firstLocation, firstSecondMid, timelerp);\n    vec2 lerpC = mix(lerpA, lerpB, timelerp);\n \n    // modify uv's by bezier curves between midpoints for smooth transitions\n    uv += lerpC - vec2(.5 * aspectRatio, .5);\n    \n    float rotation = 15. * sin(iTime / 5.);\n\n    fragColor = vec4(.8);\n    \n    float shadowDepth = .02;\n    vec2 shadowUv = uv + vec2(shadowDepth);\n    \n    if (DRAW_SHADOWS) {\n        fragColor = getSucceedingGearsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            shadowUv, \n            rotation,\n            true);\n\n        fragColor = getPreceedingGearsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            shadowUv,\n            rotation,\n            true);\n    }\n    \n    fragColor = getPreceedingGearsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        rotation,\n        false);\n        \n    fragColor = getSucceedingGearsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv, \n        rotation,\n        false);\n        \n    if (DRAW_SHADOWS) {\n        fragColor = getSucceedingPegsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            mix(uv, shadowUv, .35),\n            true);\n\n        fragColor = getPreceedingPegsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            mix(uv, shadowUv, .35),\n            true);\n    }\n        \n    fragColor = getSucceedingPegsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        false);\n        \n    fragColor = getPreceedingPegsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        false);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 645, 665, 665, 731], [733, 733, 778, 778, 882], [884, 884, 922, 922, 1168], [1170, 1170, 1251, 1251, 1989], [1991, 1991, 2024, 2024, 2780], [2782, 2782, 2851, 2851, 3038], [3040, 3040, 3076, 3076, 3141], [3143, 3143, 3201, 3201, 3310], [3312, 3312, 3348, 3348, 3426], [3428, 3428, 3521, 3521, 6282], [6284, 6284, 6366, 6366, 6709], [6711, 6711, 6791, 6791, 6880], [6882, 6882, 6995, 6995, 7629], [7631, 7631, 7853, 7853, 9452], [9454, 9454, 9650, 9650, 10543], [10545, 10545, 10767, 10767, 12253], [12255, 12255, 12451, 12451, 13135], [13137, 13137, 13190, 13190, 13437], [13439, 13439, 13496, 13496, 16964]], "test": "error"}
{"id": "7lGGzw", "name": "Black and white spiral", "author": "SnoopethDuckDuck", "description": "Somehow achieved a velvety/milky texture, lots of distortions", "tags": ["spiral"], "likes": 2, "viewed": 136, "published": "Public API", "date": "1637350872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord- 0.5 * iResolution.xy)/iResolution.y;\n    float a = atan(uv.y, uv.x);\n\n    float sc = 24. / (2. + thc(1.5, 8. * mlength(uv) + iTime));\n    float sc2 = -24. / (2. + thc(1.5, 8. * mlength(uv) + iTime));\n    \n    float m1 = mix(sc, sc2, .5 + .5 * ths(0.5, 0.3 / length(uv) + 3. * a - iTime));\n    float m2 = mix(sc, sc2, .5 + .5 * ths(0.5, 6. * length(uv) + 3. * a - iTime));\n       \n    sc = mix(m1, m2, .5 + .5 * thc(1., 4. * length(uv)+ iTime));\n    \n    uv *= 0.55 * sc;\n    //vec2 ipos = floor(uv) + 0.5;\n    vec2 fpos = fract(uv) - 0.5;\n\n    float l = 0.4 * mlength(fpos);\n    float d = 0.1 * min(abs(fpos.x) , abs(fpos.y));\n    float s = smoothstep(-l, l,\n    0.1 - d + 0.1 * thc(2., 2. * mlength(uv) - 32. * a));\n    s *= s;\n    vec3 col = vec3(s);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [145, 145, 169, 169, 209], [211, 211, 268, 318, 1156]], "test": "valid"}
{"id": "7lK3WR", "name": "Spinning Circles.SV", "author": "turtlelover891", "description": "Just a bunch of spinning circles", "tags": ["circle", "spinning"], "likes": 4, "viewed": 49, "published": "Public", "date": "1637519736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932;\n\nfloat circle(vec2 uv, vec2 pos, float r, float blur){\n    vec2 a = uv-pos;\n    return smoothstep(r+blur, r-blur, sqrt(a.x*a.x + a.y*a.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    //Parameters\n    int amount = 100;    //amount of circles\n    float speed = 50.; //speed of circles\n    float radius = 10.; //radius of circles\n    float spacing = .0; //spacing between each circle\n    float blur = 1.;    //blur of each circle\n    \n    float t = float(iFrame)/5000000.*speed;\n    vec2 R = iResolution.xy;\n    vec3 col = vec3(0.);\n    vec2 pos1 = vec2(R.x/2., R.y/2.);\n\n    //circle loop\n    for(float i=1.;i<2.+float(amount);i++){\n        col += circle(fragCoord, pos1, radius, blur);\n        pos1 = vec2(sin(t*i*i), cos(t*i*i))*2.*radius+vec2(pos1);\n    }\n    //invert color every other circle\n    col = sin(col*pi/2.);\n\n    //cyan/red center circle\n    col = abs(col-vec3((circle(fragCoord, vec2(R.x/2., R.y/2.), radius, blur)/2.), 0., 0.));\n\n    fragColor = vec4(col,1.0);\n\n    //prevents lag after too much time passes\n    t = float(int(t)%1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lK3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 91, 91, 178], [180, 180, 236, 253, 1107]], "test": "valid"}
{"id": "7lt3D2", "name": "St Elmo's Fire", "author": "Sasquatch5", "description": "St Elmo's Fire", "tags": ["iterated"], "likes": 0, "viewed": 39, "published": "Public", "date": "1636791056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14;\n\nfloat steps = 12.0;\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\n\nvec2 applyTransformation(vec2 pos,float iteration){\n\n    float angle = atan(pos.y,pos.x);\n    float initialDist = length(vec3(pos,1)) * (iteration+1.0);\n    float currentStep = mod(floor(initialDist * steps),steps);\n    vec2 outVec = vec2(1);\n    float sinDist = (sin(angle*(3.0 * currentStep) + iTime * sin(currentStep))*0.05 + 1.0);\n    \n    outVec.xy = pos.xy * sinDist;\n    \n    return outVec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 center = vec2(0.5,0.5);\n    \n    vec2 offset = (uv - center);\n    offset.y *= iResolution.y/iResolution.x;\n\n    offset *= 4.5;\n    for(float i = 0.0; i < 4.0; i++){\n    offset = applyTransformation(offset,i/0.1);\n    }\n    \n    \n    float initialDist = length(offset);\n    float currentStep = mod(floor(initialDist * steps),steps);\n    \n    \n    float clampedDist = step(fract(length(offset)*steps),0.5);\n    \n    \n    vec3 col = HSVtoRGB(vec3(currentStep/steps,1,1));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 154, 268], [269, 269, 297, 346, 426], [429, 429, 480, 480, 828], [831, 831, 888, 938, 1523]], "test": "valid"}
{"id": "7lt3D4", "name": "Prismatic Synapse", "author": "Drakyen", "description": "this is what happens when i'm tired in class and just start writing shader code\n\nalso the first with my own lighting equations, thanks evvvil for the ones i originally learned and used before these <3", "tags": ["3d", "raymarching", "transparency", "glow"], "likes": 38, "viewed": 423, "published": "Public", "date": "1636143435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 glw; //glow\n\nfloat bx(vec3 p, vec3 s) //box\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)),0.) + length(max(q,0.));\n}\n\nvec2 mp(vec3 p) //scene\n{\n \n  float scl=0.8;\n \n  for(int i=0;i<3;i++)\n  {\n    p.yz*=rot(scl-0.3);\n    p.y=abs(p.y)-scl;\n    p.x+=p.y*scl;\n    scl-=abs(p.y)*0.2;\n    p.xz*=rot(iTime*0.4);\n  }\n\n  float s = length(p-vec3(0,0,2));\n \n  float b = bx(p,vec3(scl)) - 0.1;\n  b*=0.5;\n  b=min(s,b);\n  s*=8.;\n  glw += 0.01/(0.01*s*s)*normalize(p*p);\n \n  return vec2(b,1);\n}\n\nvec2 tr(vec3 ro, vec3 rd, float z) //raymarch\n{\n  vec2 d=vec2(0);\n  for(int i=0;i<256;i++)\n  {\n    vec2 s=mp(ro+rd*d.x);\n    s.x*=z;d.x+=s.x;d.y=s.y;\n    if(s.x<0.0001||d.x>64.)break;\n  }\n  return d;\n}\n\nvec3 nm(vec3 p) //get normal\n{\n  vec2 e=vec2(0.001,0); return normalize(mp(p).x - vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec2 h, vec3 p, vec3 n, vec3 r) //shade pixel\n{\n  vec4 bg = vec4(0.1,0.1,0.8,0) + length(r*r)*0.5;\n  if(h.x>64.) return bg;\n \n  vec4 fc = vec4(0.4,0.4,01,1);\n \n  vec3 ld = normalize(vec3(0.6,0.4,0.8));\n \n  float diff = length(n*ld);\n  float fres = abs(1.-length(n*r))*0.2;\n  float spec = pow(max(dot(reflect(ld,n)*ld,-r),0.),6.);\n  float ao = clamp(1.-mp(p+n*0.1).x*10.,0.,1.)*0.1;\n  float sss = smoothstep(0.,1.,mp(p*ld*3.).x)*0.6;\n \n  fc.rgb+=fc.rgb*sss;\n  fc*=diff;\n  fc+=spec;\n  fc+=fres;\n  fc-=ao;\n \n  return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(0,0,-5),rd=normalize(vec3(uv,1));\n  vec3 cp,cn,cr,h=vec3(1);\n  vec4 cc,fc=vec4(1);\n  \n  //adjust this value for different amounts of refraction\n  //higher = more refraction; lower = less refraction (1.0 is none)\n  //below 1.0 makes them.. inverted i think? kinda interesting\n  float io = 1.4; \n \n  for(int i=0;i<4*2;i++) //more efficient transparency loop\n  {\n     h.xy=tr(ro,rd,h.z);cp=ro+rd*h.x;\n     cn=nm(cp);cr=rd;ro=cp-cn*(0.01*h.z);\n     rd=refract(cr,cn*h.z,h.z>0.?1./io:io);\n     if(dot(rd,rd)==0.)rd=reflect(cr,cn*h.z);\n     cc=px(h.xy,cp,cn,cr);h.z*=-1.;\n     if(h.z<0.)fc.rgb=mix(fc.rgb,cc.rgb,fc.a);\n     fc.a*=cc.a;if(fc.a<=0.||h.x>64.)break;\n  }\n  \n  //various interesting effects to try\n  fragColor = vec4(fc+glw.rgbb);\n  //fragColor = vec4(fc+sqrt(glw.rgbb*0.6));\n  //fragColor = vec4(fc+sqrt(glw.rgbb-0.005));\n  //fragColor = vec4(fc*sqrt(glw.rgbb-0.005));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 101, 101, 182], [184, 184, 209, 209, 545], [547, 547, 594, 594, 748], [750, 750, 780, 780, 883], [885, 885, 940, 940, 1412], [1414, 1414, 1471, 1471, 2503]], "test": "valid"}
{"id": "7lt3RX", "name": "rot2D refactorings", "author": "akohdr", "description": "macro refactoring of rotation and quarternion gists\nWARNING: likely includes errors YMMV \nShould take time to delve into SPIR-V output of various compilers", "tags": ["test"], "likes": 2, "viewed": 27, "published": "Public", "date": "1636505530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define rot2D(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define PI2 1.5705\n// incorrect but can suffice in certain cases\n//#define rotErr(a) mat2(sin(a*vec3(1,2.5705,-1).yxzy))\n\n#define rot(a) mat2(sin(vec3(a,a+PI2,-a).yxzy))\n//#define rot(a) mat2(sin(vec3(a+PI2,-a,a).xzyx))\n//#define rot(a) mat2(sin(vec3(a,-a,a+PI2).zxyz))\n\n// use _s,_c support vars declared in scope\n#define _rotV float _s,_c\n#define _rot(a) mat2(_c = cos(a),_s = sin(a),-_s,_c)\n\n// as functions\nmat2 _rot1(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c,s,-s,c);\n}\n\nmat2 _rot2(float a) {\n  vec2 s = sin(vec2(a,-a));\n  float c = cos(a);\n  return mat2(c,s,c);\n}\n\n\n// Quarternions\nvec4 conjQ(vec4 a) \n{\n    return vec4(-a.x,-a.y,-a.z,a.w);\n}\n\n// library def from C source\nvec4 mulQ_c(vec4 q1,vec4 q2) \n{\n    vec4 v = vec4(0);\n    v.x =  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;\n    v.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;\n    v.z =  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;\n    v.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;\n    return v;\n}\n\nvec4 mulQ2(vec4 a,vec4 b) \n{\n    return vec4( a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x,\n                -a.x * b.z + a.y * b.w + a.z * b.x + a.w * b.y,\n                 a.x * b.y - a.y * b.x + a.z * b.w + a.w * b.z,\n                -a.x * b.x - a.y * b.y - a.z * b.z + a.w * b.w);\n}\n\nvec4 mulQ3(vec4 a,vec4 b) \n{\n    return vec4(dot(a.xyzw, b.wzyx * vec4( 1, 1,-1, 1)),\n                dot(a.xyzw, b.zwxy * vec4(-1, 1, 1, 1)),\n                dot(a.xyzw, b.yxwz * vec4( 1,-1, 1, 1)),\n                dot(a.xyzw, b.xyzw * vec4(-1,-1,-1, 1)));\n}\n\n#define CONJQ(a) vec4(-(a).x,-(a).y,-(a).z,(a).w)\n#define NX(a) vec4(-(a).x,(a).yzw)\n//#define NY(a) vec4((a).x,-(a).y,(a).zw)\n#define NY(a) NX((a).yxzw).yxzw\n//#define NZ(a) vec4((a).xy,-(a).z,(a).w)\n#define NZ(a) NX((a).zyxw).zyxw\n\n// with bit of swizzling (would imagine amortized in load opcode)\nvec4 mulQ4(vec4 a,vec4 b)\n{\n    return vec4(dot(a, NZ(b.wzyx)), dot(a, NX(b.zwxy)),\n                dot(a, NY(b.yxwz)), dot(a, CONJQ(b)));\n}\n\n// with mat4 operation on negated swizzled components\nvec4 mulQ5(vec4 a,vec4 b) \n{\n    return a*mat4(NZ(b.wzyx), NX(b.zwxy), NY(b.yxwz), CONJQ(b));\n}\n\n// GLSL vec4 dot(u,v)   = u.x * v.x + u.y * v.y + u.z * v.z + u.w * v.w\n//           cross(u,v) = {u.y * v.z - v.y * u.z, u.z * v.x - v.z * u.x, u.x * v.y - v.x * u.y}\n//                      = u.yzx * v.zxy - v.yzx * u.zxy\n//                      = (u * v.yzx - v * u.yzx).yzx\n#define CROSS(a,b) ((a * b.yzx - b * a.yzx).yzx)\n\n// quarternion multiplication with cross() and dot() believe this is prefered approach\nvec4 mulQ(vec4 a, vec4 b)\n{\n    vec3 u = a.xyz, v = b.xyz;\n\treturn vec4(v * a.w + u * b.w + cross(u,v), a.w * b.w - dot(u,v));\n}\n\n#define RED vec4(1,0,0,0)\n#define GRN vec4(0,1,0,0)\n#define BLU vec4(0,0,1,0)\n\n#define SC(a) vec2(sin(a),cos(a))\n#define CS(a) vec2(cos(a),sin(a))\n\n#define CONJQ(a) vec4(-(a).x,-(a).y,-(a).z,(a).w)\n#define NX(a) vec4(-(a).x,(a).yzw)\n//#define NY(a) vec4((a).x,-(a).y,(a).zw)\n#define NY(a) NX((a).yxzw).yxzw\n//#define NZ(a) vec4((a).xy,-(a).z,(a).w)\n#define NZ(a) NX((a).zyxw).zyxw\n\n#define MULQ(a,b) ((a)*mat4(NZ((b).wzyx), NX((b).zwxy), NY((b).yxwz), CONJQ(b)))\n#define QROT2D(v,a) (MULQ(vec4(v,0,0),vec4(SC(a).xxxy)).xy)\n\n// obtuse but offers slightly better fps(?!)\n#define _QROTV vec2 _sc\n//per mla\n//#define QROTV2D(v,a) (MULQ(vec4(v,(_sc=sin(vec2(a,a+PI2)))-_sc),_sc.xxxy).xy)\n#define QROTV2D(v,a) (_sc=sin(vec2(a,a+PI2)),MULQ(vec4(v,0,0),_sc.xxxy).xy)\n\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    float t = iTime;\n    vec2 ir = iResolution.xy, \n          c = p-ir.xy/2.; c /= ir.y;\n          \n    vec2 v = c;                  // use v for dynamic coords\n    v *= 9.+t;                   // zoom out \n\n    float rt = length(c)*t;      // increasing rotation radially produces spiral\n\n// mat2 based rotation\n//    v *= rot2D(rt);\n//    v *= rot(rt);\n\n// quarternion based rotations.\n//    v = mulQ(vec4(CS(rt).yxxx),vec4(0,0,v)).xy;\n//    v = mulQ(vec4(SC(rt).xyxx),vec4(0,0,v)).xy;\n//    v = mulQ(vec4(v,0,0),vec4(CS(rt).xxyx)).xy;\n//    v = mulQ(vec4(v,0,0),vec4(SC(rt).xxxy)).xy;\n//    v = MULQ(vec4(v,0,0),vec4(SC(rt).xxxy)).xy;\n//    v = QROT2D(v,rt);\n    _QROTV; v = QROTV2D(v,rt);\n    \n//   v *= rot(-rt); //opposite rotation i.e should result in original coords\n    \n    vec2 d = v*v;\n    float e = d.x-d.y-1.;        // unit hyperbola  x^2 - y^2 = 1\n    \n    k  = RED *  vec4(e < t-3.);  // including t animates the black boundary stripe\n    k += GRN * float(e > t+3.);\n\n    k += mulQ(v.xyyy,k);         // makes things a little more colourful\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3RX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[576, 592, 613, 613, 672], [674, 674, 695, 695, 767], [770, 786, 807, 807, 846], [848, 877, 908, 908, 1210], [1212, 1212, 1240, 1240, 1499], [1501, 1501, 1529, 1529, 1760], [1996, 2062, 2089, 2089, 2202], [2204, 2258, 2286, 2286, 2353], [2683, 2770, 2797, 2797, 2898], [3661, 3661, 3702, 3702, 4762]], "test": "valid"}
{"id": "7lt3W2", "name": "Footwear Design 005", "author": "yasuo", "description": "・Modified version of the footwear design 004.\n・Implemented vertically wavy upper shape\n・Implemented wavy traction pattern as the outsole.", "tags": ["footwear"], "likes": 5, "viewed": 116, "published": "Public API", "date": "1636781578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    // wave traction pattern\n    p.z+=sin(p.x*100.0)*0.01;\n    p.z = mod(p.z,0.08)-0.04;\n    float d2 = sdBox(p,vec3(0.2,0.03,0.03))*0.6;\n    \n\n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP2 = p;\n    p.y+=sin(p.z*300.0)*0.005;\n    p.x+=cos(p.y*70.0)*0.005;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.145),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.115),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    d =  opSmoothUnion(d,d2,0.03);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 evaTex(vec2 uv, vec3 col){\n    uv.y+=iTime*0.1;\n    vec2 prevUV = uv;\n    uv*=30.0;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    gv.y*=n;\n    \n   // gv.x+=cos(uv.y*5.0)*0.2+sin(uv.y*2.0)*0.05;\n    float d = length(gv)-0.5*abs(n);\n    if(n<0.5){\n            col = mix(col,vec3(1.3),S(prevUV,d,0.0));\n    }\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,vec3(0.7)*evaTex(p.xz+p.yy,col));\n        //col = diffuseMaterial(n,rd,p,vec3(0.7,0.8,0.7));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1273, 1306, 1306, 1371], [1373, 1448, 1500, 1500, 1607], [1609, 1684, 1715, 1715, 1802], [1804, 1879, 1916, 1916, 1999], [2001, 2076, 2135, 2135, 2448], [2450, 2450, 2499, 2499, 2572], [2574, 2574, 2609, 2609, 3017], [3019, 3019, 3041, 3041, 3786], [3789, 3789, 3813, 3813, 4899], [4901, 4901, 4921, 4921, 5712], [5714, 5714, 5736, 5736, 5990], [5992, 5992, 6050, 6050, 6317], [6319, 6319, 6343, 6343, 6544], [6546, 6546, 6588, 6588, 6783], [6785, 6826, 6875, 6875, 7169], [7171, 7171, 7228, 7228, 7847], [7849, 7849, 7871, 7871, 7961], [7963, 7963, 7994, 7994, 8344], [8346, 8346, 8405, 8405, 8584], [8586, 8586, 8643, 8643, 9687]], "test": "valid"}
{"id": "7ltGDB", "name": "PATARTY instrumental mix", "author": "phase", "description": "spread the Patarty!", "tags": ["amiga", "remix", "fork", "boom"], "likes": 3, "viewed": 47, "published": "Public", "date": "1636674738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Patarty Remix\" by Lanza. https://www.shadertoy.com/view/3lXGD4\n// Fork of \"Patarty\" by MrsBeanbag. https://shadertoy.com/view/wtXGWr\n// 2019-04-26 12:45:38\n\nfloat random (in vec2 st){\n    // Wrapping the random value to work within\n    // the specified range.\n    st = mod(st, 24.);\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat plasma (in vec2 st) {\n    // Mapping the angle to a similar integer range.\n    float value = 4.*noise(st/6.2831*6.);\n    // Triangle function based smoothstep with derivative \n    // smoothing factor.\n    value = abs(fract(value) - .5)*2. - .5;\n    return smoothstep(0., fwidth(value), value);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bounce = fract(iTime*1.2)-0.5; //\n    bounce *= bounce;\n\tfloat boomr = pow(cos(bounce), 15.);\n\tfloat boomg = pow(cos(bounce), 25.);\n\tfloat boomb = pow(cos(bounce), 35.);\n\n    vec2 st0 = vec2(.9, .5) - fragCoord.xy/iResolution.y;\n    vec2 st = vec2(length(st0), atan(st0.x, st0.y));\n\n\tvec3 color = vec3((1.- boomg));\n    color.x += plasma(vec2(log(st.x) * boomr, st.y + iTime*0.1)*4.0);\n    color.y += plasma(vec2(log(st.x) * boomg, st.y + iTime*0.1)*4.0);\n    color.z += plasma(vec2(log(st.x) * boomb, st.y + iTime*0.1)*4.0);\n\n\tfragColor = vec4(color*0.5,1.0);\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 195, 271, 401], [403, 481, 507, 507, 838], [840, 840, 867, 920, 1141], [1144, 1144, 1201, 1201, 1786]], "test": "valid"}
{"id": "7ltGDj", "name": "Simple linear gradient ", "author": "Desdby", "description": "Generate a linear gradient of two colors using the lerp function which is the interpolation of two numbers.", "tags": ["color", "gradient", "lineargradient"], "likes": 3, "viewed": 29, "published": "Public", "date": "1636765771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// a any number , b any number , 0 <= t <= 1.0\nfloat lerp (float a, float b, float t){\n\n    //interpolation of two numbers\n    return (1.0-t)*a + t*b;\n}\n\n\n\nvec3 lerpColor (vec3 c1 , vec3 c2 , float t){\n    \n    vec3 color_interpolation = vec3 ( lerp (c1.x,c2.x,t) , lerp (c1.y,c2.y,t) , lerp (c1.z,c2.z,t) ); \n    \n    return  color_interpolation;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime; \n    float x = uv.x , y = uv.y;\n    \n    //Two colors\n    vec3 c1 = vec3 ( 23.0/255.0 , 194.0/255.0 , 131.0/255.0);\n    vec3 c2 = vec3 ( 33.0/255.0 , 38.0/255.0 , 204.0/255.0); \n    \n    \n    //Example\n    \n    //Linear gradient parting line in y-axis\n    //vec3 col = vec3 (lerpColor ( c1 , c2 , uv.x) ); \n    \n    //Linear gradient parting line in x-axis\n    //vec3 col = vec3 (lerpColor ( c1 , c2 , uv.y) ); \n    \n    \n    vec3 col = vec3 (lerpColor ( c1 , c2 , abs(sin(t-x)*cos(x+t-sin(t)) ) )); \n    \n    \n\n    //Play non-linear gradient with any function from 0.0 to 1.0\n    //vec3 col = vec3 (lerpColor ( c1 , c2 , func ) );\n    \n    //vec3 col = vec3 (lerpColor ( c1 , c2 , sin(2.0*tanh(cos(t)-y)*y )*sin(4.0*x-t) ) ); \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 48, 87, 123, 153], [157, 157, 202, 202, 350], [355, 355, 411, 461, 1317]], "test": "valid"}
{"id": "7ltGDl", "name": "A green thing in a bathroom RT", "author": "PauloFalcao", "description": "Original shade here - https://www.shadertoy.com/view/st3GDs\nThis is the same shader but using a different render node using a local illumination, non path tracing version", "tags": ["materialmaker", "nodes"], "likes": 4, "viewed": 136, "published": "Public API", "date": "1636984454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A green thing in a bathroom - Realtime Version\n//\n// Original shade here - https://www.shadertoy.com/view/st3GDs\n//\n// This is the same shader but using a different render node, plus some animated parameters\n// Using local illumination, non path tracing version\n//\n// By https://twitter.com/paulofalcao\n//\n//\n// To generate your own shaders you need:\n//\n// - Material Maker - https://rodzilla.itch.io/material-maker\n// - My Ray Marching library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// Here is a 2 hour video explaining how to use it - https://youtu.be/PvmIohbf93Q\n// \n\n/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\n//Adapted from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm - Finite Repetition\n\nvec3 opRepLim(vec3 p,vec3 c,vec3 l){\n    p+=(c*l)/2.0;\n    return p-c*clamp(floor(p/c+0.5),vec3(0.0),l);\n}vec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 brick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float round, float bevel) {\n\tfloat color;\n\tvec2 size = bmax - bmin;\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tbevel *= min_size;\n\tround *= min_size;\n\tvec2 center = 0.5*(bmin+bmax);\n    vec2 d = abs(uv-center)-0.5*(size)+vec2(round+mortar);\n    color = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n\tvec2 tiled_brick_pos = mod(bmin, vec2(1.0, 1.0));\n\treturn vec4(color, center, tiled_brick_pos.x+7.0*tiled_brick_pos.y);\n}\n\nvec3 brick_random_color(vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\treturn rand3(fract(center + vec2(seed)));\n}\n\nvec3 brick_uv(vec2 uv, vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\treturn vec3(0.5+(uv-center)/max_size, rand(fract(center)+vec2(seed)));\n}\n\nvec3 brick_corner_uv(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float corner, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tcorner *= min_size;\n\treturn vec3(clamp((0.5*size-vec2(mortar)-abs(uv-center))/corner, vec2(0.0), vec2(1.0)), rand(fract(center)+vec2(seed)+ceil(vec2(uv-center))));\n}\n\nvec4 bricks_rb(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_rb2(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_hb(vec2 uv, vec2 count, float repeat, float offset) {\n\tfloat pc = count.x+count.y;\n\tfloat c = pc*repeat;\n\tvec2 corner = floor(uv*c);\n\tfloat cdiff = mod(corner.x-corner.y, pc);\n\tif (cdiff < count.x) {\n\t\treturn vec4((corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c);\n\t} else {\n\t\treturn vec4((corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c);\n\t}\n}\n\nvec4 bricks_bw(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = 2.0*count*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\tvec2 corner;\n\tvec2 size;\n\tif (cdiff == 0.0) {\n\t\tcorner = vec2(corner1.x, corner2.y);\n\t\tsize = vec2(1.0, count.y);\n\t} else {\n\t\tcorner = vec2(corner2.x, corner1.y);\n\t\tsize = vec2(count.x, 1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}\n\nvec4 bricks_sb(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = (count+vec2(1.0))*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\tvec2 rcorner = corner1 - corner2;\n\tvec2 corner;\n\tvec2 size;\n\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\tcorner = corner2;\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == 0.0) {\n\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\tsize = vec2(count.x, 1.0);\n\t} else if (rcorner.x == count.x) {\n\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == count.y) {\n\t\tcorner = corner2+vec2(0.0, count.y);\n\t\tsize = vec2(count.x, 1.0);\n\t} else {\n\t\tcorner = corner2+vec2(1.0);\n\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright © 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}vec2 transform2_clamp(vec2 uv) {\n\treturn clamp(uv, vec2(0.0), vec2(1.0));\n}\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}vec4 sdf3dc_union(vec4 a, vec4 b) {\n\treturn vec4((a.w<b.w)?vec4(a):vec4(b));\n}\nvec4 sdf3dc_sub(vec4 a, vec4 b) {\n\treturn vec4((-a.w>b.w)?vec4(a.xyz,-a.w):vec4(b));\n}\nvec4 sdf3dc_inter(vec4 a, vec4 b) {\n\treturn vec4((a.w>b.w)?vec4(a):vec4(b));\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 MFSDF_Union(vec4 in1,vec4 in2,vec4 in3,vec4 in4,vec4 in5,vec4 in6,vec4 in7,vec4 in8){\n    vec4 t=(in1.w<in2.w)?vec4(in1):vec4(in2);\n    t=(t.w<in2.w)?vec4(t):vec4(in2);\n    t=(t.w<in3.w)?vec4(t):vec4(in3);\n    t=(t.w<in4.w)?vec4(t):vec4(in4);\n    t=(t.w<in5.w)?vec4(t):vec4(in5);\n    t=(t.w<in6.w)?vec4(t):vec4(in6);\n    t=(t.w<in7.w)?vec4(t):vec4(in7);\n    t=(t.w<in8.w)?vec4(t):vec4(in8);\n    return t;\n}\n\nfloat mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec2 twist_rot(vec2 v, float a) {\n\ta=a*0.01745329251;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s),vec2(s, c));\n\treturn m * v;\n}\n\nvec3 twistX(vec3 v, float a){\n\tv.yz=twist_rot(v.yz,v.x*a);\n\treturn v;\n}\n\nvec3 twistY(vec3 v, float a){\n\tv.xz=twist_rot(v.xz,v.y*a);\n\treturn v;\n}\n\nvec3 twistZ(vec3 v, float a){\n\tv.xy=twist_rot(v.xy,v.z*a);\n\treturn v;\n}\n\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o15436_CamX = -3.342999935;\nconst float p_o15436_LookAtX = 1.984000000;\nconst float p_o15436_LookAtY = 1.984000000;\nconst float p_o15436_LookAtZ = -0.406000000;\nconst float p_o15436_CamD = 1.133000000;\nconst float p_o15436_CamZoom = 1.000000000;\nconst float p_o15436_SunX = -1.477000000;\nconst float p_o15436_SunY = 3.016000000;\nconst float p_o15436_SunZ = 1.352000000;\nconst float p_o15436_AmbLight = 0.250000000;\nconst float p_o15436_AmbOcclusion = 0.000000000;\nconst float p_o15436_Shadow = 0.000000000;\nconst float p_o15436_Gamma = 1.346000000;\nconst float p_o10143_BaseColor_r = 1.000000000;\nconst float p_o10143_BaseColor_g = 1.000000000;\nconst float p_o10143_BaseColor_b = 1.000000000;\nconst float p_o10143_BaseColor_a = 1.000000000;\nconst float p_o10143_Metallic = 0.000000000;\nconst float p_o10143_Specular = 0.500000000;\nconst float p_o10143_Roughness = 0.000000000;\nconst float p_o10143_Emission = 10.000000000;\nconst float p_o10143_Normal = 0.000000000;\nconst float p_o10143_Alpha = 0.000000000;\nconst float p_o10143_AmbientOcclusion = 0.000000000;\nconst float p_o10143_scale = 1.000000000;\nconst float p_o10143_TranlateX = 0.000000000;\nconst float p_o10143_TranlateY = 3.512000000;\nconst float p_o10143_TranlateZ = 0.000000000;\nconst float p_o10143_RotateX = 0.000000000;\nconst float p_o10143_RotateY = 0.250000000;\nconst float p_o10143_RotateZ = 0.000000000;\nvec3 o10143_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10143_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10143_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10143_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10143_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10143_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10143_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10143_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10142_X = 1.000000000;\nconst float p_o10142_Y = 1.000000000;\nconst float p_o10142_Z = 0.400000000;\nconst float p_o10142_RepX = 1.000000000;\nconst float p_o10142_RepY = 1.000000000;\nconst float p_o10142_RepZ = 6.000000000;\nconst float p_o10141_l = 2.880000000;\nconst float p_o10141_r = 0.120000000;\nfloat o10143_input_sdf3d(vec3 p, float _seed_variation_) {\nvec2 o10141_0_d = abs(vec2(length((opRepLim((p),vec3(p_o10142_X,p_o10142_Y,p_o10142_Z)*2.0,vec3(p_o10142_RepX-1.0,p_o10142_RepY-1.0,p_o10142_RepZ-1.0))).yz),(opRepLim((p),vec3(p_o10142_X,p_o10142_Y,p_o10142_Z)*2.0,vec3(p_o10142_RepX-1.0,p_o10142_RepY-1.0,p_o10142_RepZ-1.0))).x)) - vec2(p_o10141_r,p_o10141_l);\nfloat o10141_0_1_sdf3d = min(max(o10141_0_d.x,o10141_0_d.y),0.0) + length(max(o10141_0_d,0.0));\nfloat o10142_0_1_sdf3d = o10141_0_1_sdf3d;\n\nreturn o10142_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10143(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10143_TranlateX,p_o10143_TranlateY,p_o10143_TranlateZ),vec3(p_o10143_RotateX,p_o10143_RotateY,p_o10143_RotateZ)*6.28318530718)/p_o10143_scale;\n\tfloat sdf=o10143_input_sdf3d(uv.xyz, _seed_variation_)*p_o10143_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10143_AmbientOcclusion*o10143_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10143_Alpha*o10143_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10143_Normal*o10143_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10143_Emission*o10143_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10143_Roughness*o10143_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10143_Specular*o10143_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10143_Metallic*o10143_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10143_BaseColor_r, p_o10143_BaseColor_g, p_o10143_BaseColor_b, p_o10143_BaseColor_a).rgb*o10143_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10168_x = 3.701340000;\nconst float p_o10168_y = 0.000000000;\nconst float p_o10168_z = 0.000000000;\nconst float p_o10156_BaseColor_r = 1.000000000;\nconst float p_o10156_BaseColor_g = 1.000000000;\nconst float p_o10156_BaseColor_b = 1.000000000;\nconst float p_o10156_BaseColor_a = 1.000000000;\nconst float p_o10156_Metallic = 0.705000000;\nconst float p_o10156_Specular = 0.373000000;\nconst float p_o10156_Roughness = 1.000000000;\nconst float p_o10156_Emission = 0.000000000;\nconst float p_o10156_Normal = 0.000000000;\nconst float p_o10156_Alpha = 0.000000000;\nconst float p_o10156_AmbientOcclusion = 0.000000000;\nconst float p_o10156_scale = 1.000000000;\nconst float p_o10156_TranlateX = 0.000000000;\nconst float p_o10156_TranlateY = 0.000000000;\nconst float p_o10156_TranlateZ = 0.000000000;\nconst float p_o10156_RotateX = 0.000000000;\nconst float p_o10156_RotateY = 0.000000000;\nconst float p_o10156_RotateZ = 0.000000000;\nconst float p_o10193_translate_x = -0.530000000;\nconst float p_o10193_translate_y = -0.010000000;\nconst float p_o10191_translate_x = 6.470000000;\nconst float p_o10191_translate_y = 3.123150000;\nconst float p_o10191_rotate = 197.957800000;\nconst float p_o10191_scale_x = 1.000000000;\nconst float p_o10191_scale_y = 1.000000000;\nconst float seed_o10189 = 0.692989000;\nconst float p_o10189_repeat = 1.000000000;\nconst float p_o10189_rows = 1.930000000;\nconst float p_o10189_columns = 1.930000000;\nconst float p_o10189_row_offset = 1.000000000;\nconst float p_o10189_mortar = 0.000000000;\nconst float p_o10189_bevel = 0.000000000;\nconst float p_o10189_round = 0.000000000;\nconst float p_o10189_corner = 0.000000000;\nconst float p_o10190_f = 0.000000000;\nconst float p_o10175_g_0_pos = 0.190909000;\nconst float p_o10175_g_0_r = 1.000000000;\nconst float p_o10175_g_0_g = 1.000000000;\nconst float p_o10175_g_0_b = 1.000000000;\nconst float p_o10175_g_0_a = 1.000000000;\nconst float p_o10175_g_1_pos = 0.390909000;\nconst float p_o10175_g_1_r = 0.507812977;\nconst float p_o10175_g_1_g = 0.451000005;\nconst float p_o10175_g_1_b = 0.353087991;\nconst float p_o10175_g_1_a = 1.000000000;\nconst float p_o10175_g_2_pos = 0.663636000;\nconst float p_o10175_g_2_r = 1.000000000;\nconst float p_o10175_g_2_g = 1.000000000;\nconst float p_o10175_g_2_b = 1.000000000;\nconst float p_o10175_g_2_a = 1.000000000;\nvec4 o10175_g_gradient_fct(float x) {\n  if (x < p_o10175_g_0_pos) {\n    return vec4(p_o10175_g_0_r,p_o10175_g_0_g,p_o10175_g_0_b,p_o10175_g_0_a);\n  } else if (x < p_o10175_g_1_pos) {\n    return mix(vec4(p_o10175_g_0_r,p_o10175_g_0_g,p_o10175_g_0_b,p_o10175_g_0_a), vec4(p_o10175_g_1_r,p_o10175_g_1_g,p_o10175_g_1_b,p_o10175_g_1_a), ((x-p_o10175_g_0_pos)/(p_o10175_g_1_pos-p_o10175_g_0_pos)));\n  } else if (x < p_o10175_g_2_pos) {\n    return mix(vec4(p_o10175_g_1_r,p_o10175_g_1_g,p_o10175_g_1_b,p_o10175_g_1_a), vec4(p_o10175_g_2_r,p_o10175_g_2_g,p_o10175_g_2_b,p_o10175_g_2_a), ((x-p_o10175_g_1_pos)/(p_o10175_g_2_pos-p_o10175_g_1_pos)));\n  }\n  return vec4(p_o10175_g_2_r,p_o10175_g_2_g,p_o10175_g_2_b,p_o10175_g_2_a);\n}\nconst float p_o10170_scale = 5.635000000;\nconst float p_o10170_scale_x = 1.000000000;\nconst float p_o10170_scale_y = 1.000000000;\nconst float p_o10170_scale_z = 1.000000000;\nconst float p_o10170_transx = 0.000000000;\nconst float p_o10170_transy = 0.000000000;\nconst float p_o10170_transz = 0.000000000;\nconst float p_o10170_persistence = 0.500000000;\nconst float p_o10170_brightness = 0.000000000;\nconst float p_o10170_contrast = 7.556000000;\nfloat o10170_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o10170_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o10156_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10189_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10189_columns, p_o10189_rows), p_o10189_repeat, p_o10189_row_offset);\nvec4 o10189_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), o10189_0_rect.xy, o10189_0_rect.zw, p_o10189_mortar*1.0, p_o10189_round*1.0, max(0.001, p_o10189_bevel*1.0));\nvec3 o10189_1_2_rgb = brick_random_color(o10189_0_rect.xy, o10189_0_rect.zw, float((seed_o10189+_seed_variation_)));\nvec3 o10170_0_out = vec3(o10170_bc(o10170_fbm((vec3(p_o10190_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10170_scale_x,p_o10170_scale_y,p_o10170_scale_z)*0.5*p_o10170_scale+vec3(p_o10170_transx,p_o10170_transy,p_o10170_transz),p_o10170_persistence, _seed_variation_)*0.5+0.5,p_o10170_contrast,p_o10170_brightness, _seed_variation_));vec3 o10170_0_1_tex3d = clamp(o10170_0_out,vec3(0),vec3(1));\nvec3 o10175_0_1_tex3d = o10175_g_gradient_fct(dot(o10170_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10190_0_1_rgb = o10175_0_1_tex3d.rgb;\nvec4 o10191_0_1_rgba = vec4(o10190_0_1_rgb, 1.0);\nvec4 o10193_0_1_rgba = o10191_0_1_rgba;\nvec3 o10192_0_1_tex3d = ((o10193_0_1_rgba).rgb);\n\nreturn o10192_0_1_tex3d;\n}\nfloat o10156_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10156_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10194_g_0_pos = 0.000000000;\nconst float p_o10194_g_0_r = 1.000000000;\nconst float p_o10194_g_0_g = 1.000000000;\nconst float p_o10194_g_0_b = 1.000000000;\nconst float p_o10194_g_0_a = 1.000000000;\nconst float p_o10194_g_1_pos = 1.000000000;\nconst float p_o10194_g_1_r = 0.000000000;\nconst float p_o10194_g_1_g = 0.000000000;\nconst float p_o10194_g_1_b = 0.000000000;\nconst float p_o10194_g_1_a = 1.000000000;\nvec4 o10194_g_gradient_fct(float x) {\n  if (x < p_o10194_g_0_pos) {\n    return vec4(p_o10194_g_0_r,p_o10194_g_0_g,p_o10194_g_0_b,p_o10194_g_0_a);\n  } else if (x < p_o10194_g_1_pos) {\n    return mix(vec4(p_o10194_g_0_r,p_o10194_g_0_g,p_o10194_g_0_b,p_o10194_g_0_a), vec4(p_o10194_g_1_r,p_o10194_g_1_g,p_o10194_g_1_b,p_o10194_g_1_a), ((x-p_o10194_g_0_pos)/(p_o10194_g_1_pos-p_o10194_g_0_pos)));\n  }\n  return vec4(p_o10194_g_1_r,p_o10194_g_1_g,p_o10194_g_1_b,p_o10194_g_1_a);\n}\nfloat o10156_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10189_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10189_columns, p_o10189_rows), p_o10189_repeat, p_o10189_row_offset);\nvec4 o10189_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), o10189_0_rect.xy, o10189_0_rect.zw, p_o10189_mortar*1.0, p_o10189_round*1.0, max(0.001, p_o10189_bevel*1.0));\nvec3 o10189_1_2_rgb = brick_random_color(o10189_0_rect.xy, o10189_0_rect.zw, float((seed_o10189+_seed_variation_)));\nvec3 o10170_0_out = vec3(o10170_bc(o10170_fbm((vec3(p_o10190_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10170_scale_x,p_o10170_scale_y,p_o10170_scale_z)*0.5*p_o10170_scale+vec3(p_o10170_transx,p_o10170_transy,p_o10170_transz),p_o10170_persistence, _seed_variation_)*0.5+0.5,p_o10170_contrast,p_o10170_brightness, _seed_variation_));vec3 o10170_0_1_tex3d = clamp(o10170_0_out,vec3(0),vec3(1));\nvec3 o10175_0_1_tex3d = o10175_g_gradient_fct(dot(o10170_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10190_0_1_rgb = o10175_0_1_tex3d.rgb;\nvec4 o10191_0_1_rgba = vec4(o10190_0_1_rgb, 1.0);\nvec4 o10193_0_1_rgba = o10191_0_1_rgba;\nvec3 o10192_0_1_tex3d = ((o10193_0_1_rgba).rgb);\nvec3 o10194_0_1_tex3d = o10194_g_gradient_fct(dot(o10192_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o10194_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o10156_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10156_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10156_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10156_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10161_X = 1.000000000;\nconst float p_o10161_Y = 0.260000000;\nconst float p_o10161_Z = 0.260000000;\nconst float p_o10161_RepX = 1.000000000;\nconst float p_o10161_RepY = 24.000000000;\nconst float p_o10161_RepZ = 24.000000000;\nconst float p_o10160_sx = 0.050000000;\nconst float p_o10160_sy = 0.235000000;\nconst float p_o10160_sz = 0.235000000;\nconst float p_o10160_r = 0.020000000;\nfloat o10156_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10160_0_q = abs((opRepLim((p),vec3(p_o10161_X,p_o10161_Y,p_o10161_Z)*2.0,vec3(p_o10161_RepX-1.0,p_o10161_RepY-1.0,p_o10161_RepZ-1.0)))) - vec3(p_o10160_sx, p_o10160_sy, p_o10160_sz);\nfloat o10160_0_1_sdf3d = length(max(o10160_0_q,0.0))+min(max(o10160_0_q.x,max(o10160_0_q.y,o10160_0_q.z)),0.0)-p_o10160_r;\nfloat o10161_0_1_sdf3d = o10160_0_1_sdf3d;\n\nreturn o10161_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10156(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10156_TranlateX,p_o10156_TranlateY,p_o10156_TranlateZ),vec3(p_o10156_RotateX,p_o10156_RotateY,p_o10156_RotateZ)*6.28318530718)/p_o10156_scale;\n\tfloat sdf=o10156_input_sdf3d(uv.xyz, _seed_variation_)*p_o10156_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10156_AmbientOcclusion*o10156_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10156_Alpha*o10156_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10156_Normal*o10156_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10156_Emission*o10156_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10156_Roughness*o10156_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10156_Specular*o10156_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10156_Metallic*o10156_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10156_BaseColor_r, p_o10156_BaseColor_g, p_o10156_BaseColor_b, p_o10156_BaseColor_a).rgb*o10156_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10167_x = -0.049000000;\nconst float p_o10167_y = 0.000000000;\nconst float p_o10167_z = 0.000000000;\nconst float p_o10162_BaseColor_r = 0.324218988;\nconst float p_o10162_BaseColor_g = 0.324218988;\nconst float p_o10162_BaseColor_b = 0.324218988;\nconst float p_o10162_BaseColor_a = 1.000000000;\nconst float p_o10162_Metallic = 0.000000000;\nconst float p_o10162_Specular = 0.000000000;\nconst float p_o10162_Roughness = 1.000000000;\nconst float p_o10162_Emission = 0.000000000;\nconst float p_o10162_Normal = 0.000000000;\nconst float p_o10162_Alpha = 0.000000000;\nconst float p_o10162_AmbientOcclusion = 0.000000000;\nconst float p_o10162_scale = 1.000000000;\nconst float p_o10162_TranlateX = 0.000000000;\nconst float p_o10162_TranlateY = 0.000000000;\nconst float p_o10162_TranlateZ = 0.000000000;\nconst float p_o10162_RotateX = 0.000000000;\nconst float p_o10162_RotateY = 0.000000000;\nconst float p_o10162_RotateZ = 0.000000000;\nvec3 o10162_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10162_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10162_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10162_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10162_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10162_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10162_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10162_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10166_sx = 0.000000000;\nconst float p_o10166_sy = 6.270000000;\nconst float p_o10166_sz = 6.140000000;\nconst float p_o10166_r = 0.000000000;\nfloat o10162_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10166_0_q = abs((p)) - vec3(p_o10166_sx, p_o10166_sy, p_o10166_sz);\nfloat o10166_0_1_sdf3d = length(max(o10166_0_q,0.0))+min(max(o10166_0_q.x,max(o10166_0_q.y,o10166_0_q.z)),0.0)-p_o10166_r;\n\nreturn o10166_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10162(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10162_TranlateX,p_o10162_TranlateY,p_o10162_TranlateZ),vec3(p_o10162_RotateX,p_o10162_RotateY,p_o10162_RotateZ)*6.28318530718)/p_o10162_scale;\n\tfloat sdf=o10162_input_sdf3d(uv.xyz, _seed_variation_)*p_o10162_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10162_AmbientOcclusion*o10162_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10162_Alpha*o10162_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10162_Normal*o10162_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10162_Emission*o10162_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10162_Roughness*o10162_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10162_Specular*o10162_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10162_Metallic*o10162_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10162_BaseColor_r, p_o10162_BaseColor_g, p_o10162_BaseColor_b, p_o10162_BaseColor_a).rgb*o10162_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10209_ax = 0.000000000;\nconst float p_o10209_ay = 90.000000000;\nconst float p_o10209_az = 0.000000000;\nconst float p_o10210_BaseColor_r = 1.000000000;\nconst float p_o10210_BaseColor_g = 1.000000000;\nconst float p_o10210_BaseColor_b = 1.000000000;\nconst float p_o10210_BaseColor_a = 1.000000000;\nconst float p_o10210_Metallic = 0.000000000;\nconst float p_o10210_Specular = 0.000000000;\nconst float p_o10210_Roughness = 1.000000000;\nconst float p_o10210_Emission = 0.000000000;\nconst float p_o10210_Normal = 0.000000000;\nconst float p_o10210_Alpha = 0.000000000;\nconst float p_o10210_AmbientOcclusion = 0.000000000;\nconst float p_o10210_scale = 1.000000000;\nconst float p_o10210_TranlateX = 0.000000000;\nconst float p_o10210_TranlateY = 4.420000000;\nconst float p_o10210_TranlateZ = 0.000000000;\nconst float p_o10210_RotateX = 0.000000000;\nconst float p_o10210_RotateY = 0.000000000;\nconst float p_o10210_RotateZ = 0.000000000;\nvec3 o10210_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10210_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10210_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10210_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10210_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10210_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10210_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10210_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10214_sx = 4.250000000;\nconst float p_o10214_sy = 0.250000000;\nconst float p_o10214_sz = 4.010000000;\nconst float p_o10214_r = 0.010000000;\nfloat o10210_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10214_0_q = abs((p)) - vec3(p_o10214_sx, p_o10214_sy, p_o10214_sz);\nfloat o10214_0_1_sdf3d = length(max(o10214_0_q,0.0))+min(max(o10214_0_q.x,max(o10214_0_q.y,o10214_0_q.z)),0.0)-p_o10214_r;\n\nreturn o10214_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10210(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10210_TranlateX,p_o10210_TranlateY,p_o10210_TranlateZ),vec3(p_o10210_RotateX,p_o10210_RotateY,p_o10210_RotateZ)*6.28318530718)/p_o10210_scale;\n\tfloat sdf=o10210_input_sdf3d(uv.xyz, _seed_variation_)*p_o10210_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10210_AmbientOcclusion*o10210_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10210_Alpha*o10210_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10210_Normal*o10210_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10210_Emission*o10210_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10210_Roughness*o10210_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10210_Specular*o10210_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10210_Metallic*o10210_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10210_BaseColor_r, p_o10210_BaseColor_g, p_o10210_BaseColor_b, p_o10210_BaseColor_a).rgb*o10210_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10267_x = 0.000000000;\nconst float p_o10267_y = -0.119530000;\nconst float p_o10267_z = 0.000000000;\nconst float p_o10268_xyz = 1.785000000;\nconst float p_o10268_x = 1.000000000;\nconst float p_o10268_y = 1.000000000;\nconst float p_o10268_z = 1.000000000;\nconst float p_o10266_ax = 0.000000000;\nconst float p_o10266_ay = 90.000000000;\nconst float p_o10266_az = 90.000000000;\nconst float p_o10259_BaseColor_r = 1.000000000;\nconst float p_o10259_BaseColor_g = 1.000000000;\nconst float p_o10259_BaseColor_b = 1.000000000;\nconst float p_o10259_BaseColor_a = 1.000000000;\nconst float p_o10259_Metallic = 0.705000000;\nconst float p_o10259_Specular = 0.917000000;\nconst float p_o10259_Roughness = 1.000000000;\nconst float p_o10259_Emission = 0.000000000;\nconst float p_o10259_Normal = 0.000000000;\nconst float p_o10259_Alpha = 0.000000000;\nconst float p_o10259_AmbientOcclusion = 0.000000000;\nconst float p_o10259_scale = 1.000000000;\nconst float p_o10259_TranlateX = 0.000000000;\nconst float p_o10259_TranlateY = 0.000000000;\nconst float p_o10259_TranlateZ = 0.000000000;\nconst float p_o10259_RotateX = 0.000000000;\nconst float p_o10259_RotateY = 0.000000000;\nconst float p_o10259_RotateZ = 0.000000000;\nconst float p_o10245_translate_x = -0.530000000;\nconst float p_o10245_translate_y = -0.010000000;\nconst float p_o10243_translate_x = 2.180000000;\nconst float p_o10243_translate_y = 4.575000000;\nconst float p_o10243_rotate = 456.220000000;\nconst float p_o10243_scale_x = 1.000000000;\nconst float p_o10243_scale_y = 1.000000000;\nconst float seed_o10242 = 0.692989000;\nconst float p_o10242_repeat = 1.000000000;\nconst float p_o10242_rows = 1.930000000;\nconst float p_o10242_columns = 1.930000000;\nconst float p_o10242_row_offset = 1.000000000;\nconst float p_o10242_mortar = 0.000000000;\nconst float p_o10242_bevel = 0.000000000;\nconst float p_o10242_round = 0.000000000;\nconst float p_o10242_corner = 0.000000000;\nconst float p_o10241_f = 0.000000000;\nconst float p_o10227_g_0_pos = 0.081110000;\nconst float p_o10227_g_0_r = 0.000000000;\nconst float p_o10227_g_0_g = 0.000000000;\nconst float p_o10227_g_0_b = 0.000000000;\nconst float p_o10227_g_0_a = 1.000000000;\nconst float p_o10227_g_1_pos = 0.390909000;\nconst float p_o10227_g_1_r = 0.796875000;\nconst float p_o10227_g_1_g = 0.604830027;\nconst float p_o10227_g_1_b = 0.333068997;\nconst float p_o10227_g_1_a = 1.000000000;\nconst float p_o10227_g_2_pos = 0.772019000;\nconst float p_o10227_g_2_r = 0.000000000;\nconst float p_o10227_g_2_g = 0.000000000;\nconst float p_o10227_g_2_b = 0.000000000;\nconst float p_o10227_g_2_a = 1.000000000;\nvec4 o10227_g_gradient_fct(float x) {\n  if (x < p_o10227_g_0_pos) {\n    return vec4(p_o10227_g_0_r,p_o10227_g_0_g,p_o10227_g_0_b,p_o10227_g_0_a);\n  } else if (x < p_o10227_g_1_pos) {\n    return mix(vec4(p_o10227_g_0_r,p_o10227_g_0_g,p_o10227_g_0_b,p_o10227_g_0_a), vec4(p_o10227_g_1_r,p_o10227_g_1_g,p_o10227_g_1_b,p_o10227_g_1_a), ((x-p_o10227_g_0_pos)/(p_o10227_g_1_pos-p_o10227_g_0_pos)));\n  } else if (x < p_o10227_g_2_pos) {\n    return mix(vec4(p_o10227_g_1_r,p_o10227_g_1_g,p_o10227_g_1_b,p_o10227_g_1_a), vec4(p_o10227_g_2_r,p_o10227_g_2_g,p_o10227_g_2_b,p_o10227_g_2_a), ((x-p_o10227_g_1_pos)/(p_o10227_g_2_pos-p_o10227_g_1_pos)));\n  }\n  return vec4(p_o10227_g_2_r,p_o10227_g_2_g,p_o10227_g_2_b,p_o10227_g_2_a);\n}\nconst float p_o10216_scale = 2.706000000;\nconst float p_o10216_scale_x = 1.000000000;\nconst float p_o10216_scale_y = 1.000000000;\nconst float p_o10216_scale_z = 1.000000000;\nconst float p_o10216_transx = 0.000000000;\nconst float p_o10216_transy = 0.000000000;\nconst float p_o10216_transz = 0.000000000;\nconst float p_o10216_persistence = 0.500000000;\nconst float p_o10216_brightness = 0.000000000;\nconst float p_o10216_contrast = 14.000000000;\nfloat o10216_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o10216_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o10259_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10242_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10242_columns, p_o10242_rows), p_o10242_repeat, p_o10242_row_offset);\nvec4 o10242_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), o10242_0_rect.xy, o10242_0_rect.zw, p_o10242_mortar*1.0, p_o10242_round*1.0, max(0.001, p_o10242_bevel*1.0));\nvec3 o10242_1_2_rgb = brick_random_color(o10242_0_rect.xy, o10242_0_rect.zw, float((seed_o10242+_seed_variation_)));\nvec3 o10216_0_out = vec3(o10216_bc(o10216_fbm((vec3(p_o10241_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10216_scale_x,p_o10216_scale_y,p_o10216_scale_z)*0.5*p_o10216_scale+vec3(p_o10216_transx,p_o10216_transy,p_o10216_transz),p_o10216_persistence, _seed_variation_)*0.5+0.5,p_o10216_contrast,p_o10216_brightness, _seed_variation_));vec3 o10216_0_1_tex3d = clamp(o10216_0_out,vec3(0),vec3(1));\nvec3 o10227_0_1_tex3d = o10227_g_gradient_fct(dot(o10216_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10241_0_1_rgb = o10227_0_1_tex3d.rgb;\nvec4 o10243_0_1_rgba = vec4(o10241_0_1_rgb, 1.0);\nvec4 o10245_0_1_rgba = o10243_0_1_rgba;\nvec3 o10244_0_1_tex3d = ((o10245_0_1_rgba).rgb);\n\nreturn o10244_0_1_tex3d;\n}\nfloat o10259_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10259_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10246_g_0_pos = 0.000000000;\nconst float p_o10246_g_0_r = 0.066405997;\nconst float p_o10246_g_0_g = 0.066405997;\nconst float p_o10246_g_0_b = 0.066405997;\nconst float p_o10246_g_0_a = 1.000000000;\nconst float p_o10246_g_1_pos = 1.000000000;\nconst float p_o10246_g_1_r = 1.000000000;\nconst float p_o10246_g_1_g = 1.000000000;\nconst float p_o10246_g_1_b = 1.000000000;\nconst float p_o10246_g_1_a = 1.000000000;\nvec4 o10246_g_gradient_fct(float x) {\n  if (x < p_o10246_g_0_pos) {\n    return vec4(p_o10246_g_0_r,p_o10246_g_0_g,p_o10246_g_0_b,p_o10246_g_0_a);\n  } else if (x < p_o10246_g_1_pos) {\n    return mix(vec4(p_o10246_g_0_r,p_o10246_g_0_g,p_o10246_g_0_b,p_o10246_g_0_a), vec4(p_o10246_g_1_r,p_o10246_g_1_g,p_o10246_g_1_b,p_o10246_g_1_a), ((x-p_o10246_g_0_pos)/(p_o10246_g_1_pos-p_o10246_g_0_pos)));\n  }\n  return vec4(p_o10246_g_1_r,p_o10246_g_1_g,p_o10246_g_1_b,p_o10246_g_1_a);\n}\nfloat o10259_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10242_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10242_columns, p_o10242_rows), p_o10242_repeat, p_o10242_row_offset);\nvec4 o10242_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), o10242_0_rect.xy, o10242_0_rect.zw, p_o10242_mortar*1.0, p_o10242_round*1.0, max(0.001, p_o10242_bevel*1.0));\nvec3 o10242_1_2_rgb = brick_random_color(o10242_0_rect.xy, o10242_0_rect.zw, float((seed_o10242+_seed_variation_)));\nvec3 o10216_0_out = vec3(o10216_bc(o10216_fbm((vec3(p_o10241_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10216_scale_x,p_o10216_scale_y,p_o10216_scale_z)*0.5*p_o10216_scale+vec3(p_o10216_transx,p_o10216_transy,p_o10216_transz),p_o10216_persistence, _seed_variation_)*0.5+0.5,p_o10216_contrast,p_o10216_brightness, _seed_variation_));vec3 o10216_0_1_tex3d = clamp(o10216_0_out,vec3(0),vec3(1));\nvec3 o10227_0_1_tex3d = o10227_g_gradient_fct(dot(o10216_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10241_0_1_rgb = o10227_0_1_tex3d.rgb;\nvec4 o10243_0_1_rgba = vec4(o10241_0_1_rgb, 1.0);\nvec4 o10245_0_1_rgba = o10243_0_1_rgba;\nvec3 o10244_0_1_tex3d = ((o10245_0_1_rgba).rgb);\nvec3 o10246_0_1_tex3d = o10246_g_gradient_fct(dot(o10244_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o10246_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o10259_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10259_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10259_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10259_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10263_X = 1.000000000;\nconst float p_o10263_Y = 0.260000000;\nconst float p_o10263_Z = 0.260000000;\nconst float p_o10263_RepX = 1.000000000;\nconst float p_o10263_RepY = 24.000000000;\nconst float p_o10263_RepZ = 24.000000000;\nconst float p_o10222_sx = 0.050000000;\nconst float p_o10222_sy = 0.235000000;\nconst float p_o10222_sz = 0.235000000;\nconst float p_o10222_r = 0.020000000;\nfloat o10259_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10222_0_q = abs((opRepLim((p),vec3(p_o10263_X,p_o10263_Y,p_o10263_Z)*2.0,vec3(p_o10263_RepX-1.0,p_o10263_RepY-1.0,p_o10263_RepZ-1.0)))) - vec3(p_o10222_sx, p_o10222_sy, p_o10222_sz);\nfloat o10222_0_1_sdf3d = length(max(o10222_0_q,0.0))+min(max(o10222_0_q.x,max(o10222_0_q.y,o10222_0_q.z)),0.0)-p_o10222_r;\nfloat o10263_0_1_sdf3d = o10222_0_1_sdf3d;\n\nreturn o10263_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10259(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10259_TranlateX,p_o10259_TranlateY,p_o10259_TranlateZ),vec3(p_o10259_RotateX,p_o10259_RotateY,p_o10259_RotateZ)*6.28318530718)/p_o10259_scale;\n\tfloat sdf=o10259_input_sdf3d(uv.xyz, _seed_variation_)*p_o10259_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10259_AmbientOcclusion*o10259_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10259_Alpha*o10259_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10259_Normal*o10259_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10259_Emission*o10259_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10259_Roughness*o10259_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10259_Specular*o10259_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10259_Metallic*o10259_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10259_BaseColor_r, p_o10259_BaseColor_g, p_o10259_BaseColor_b, p_o10259_BaseColor_a).rgb*o10259_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10264_x = -0.058000000;\nconst float p_o10264_y = 0.000000000;\nconst float p_o10264_z = 0.000000000;\nconst float p_o10223_BaseColor_r = 0.324218988;\nconst float p_o10223_BaseColor_g = 0.324218988;\nconst float p_o10223_BaseColor_b = 0.324218988;\nconst float p_o10223_BaseColor_a = 1.000000000;\nconst float p_o10223_Metallic = 0.000000000;\nconst float p_o10223_Specular = 0.000000000;\nconst float p_o10223_Roughness = 1.000000000;\nconst float p_o10223_Emission = 0.000000000;\nconst float p_o10223_Normal = 0.000000000;\nconst float p_o10223_Alpha = 0.000000000;\nconst float p_o10223_AmbientOcclusion = 0.000000000;\nconst float p_o10223_scale = 1.000000000;\nconst float p_o10223_TranlateX = 0.000000000;\nconst float p_o10223_TranlateY = 0.000000000;\nconst float p_o10223_TranlateZ = 0.000000000;\nconst float p_o10223_RotateX = 0.000000000;\nconst float p_o10223_RotateY = 0.000000000;\nconst float p_o10223_RotateZ = 0.000000000;\nvec3 o10223_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10223_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10223_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10223_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10223_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10223_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10223_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10223_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10221_sx = 0.000000000;\nconst float p_o10221_sy = 6.270000000;\nconst float p_o10221_sz = 6.140000000;\nconst float p_o10221_r = 0.000000000;\nfloat o10223_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10221_0_q = abs((p)) - vec3(p_o10221_sx, p_o10221_sy, p_o10221_sz);\nfloat o10221_0_1_sdf3d = length(max(o10221_0_q,0.0))+min(max(o10221_0_q.x,max(o10221_0_q.y,o10221_0_q.z)),0.0)-p_o10221_r;\n\nreturn o10221_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10223(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10223_TranlateX,p_o10223_TranlateY,p_o10223_TranlateZ),vec3(p_o10223_RotateX,p_o10223_RotateY,p_o10223_RotateZ)*6.28318530718)/p_o10223_scale;\n\tfloat sdf=o10223_input_sdf3d(uv.xyz, _seed_variation_)*p_o10223_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10223_AmbientOcclusion*o10223_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10223_Alpha*o10223_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10223_Normal*o10223_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10223_Emission*o10223_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10223_Roughness*o10223_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10223_Specular*o10223_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10223_Metallic*o10223_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10223_BaseColor_r, p_o10223_BaseColor_g, p_o10223_BaseColor_b, p_o10223_BaseColor_a).rgb*o10223_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10215_x = 0.000000000;\nconst float p_o10215_y = 1.071000000;\nconst float p_o10215_z = 0.000000000;\nconst float p_o10155_correction = 0.000000000;\nconst float p_o10148_k = 0.062000000;\nconst float p_o10149_BaseColor_r = 0.000000000;\nconst float p_o10149_BaseColor_g = 0.000000000;\nconst float p_o10149_BaseColor_b = 0.000000000;\nconst float p_o10149_BaseColor_a = 1.000000000;\nconst float p_o10149_Metallic = 0.250000000;\nconst float p_o10149_Specular = 1.000000000;\nconst float p_o10149_Roughness = 0.000000000;\nconst float p_o10149_Emission = 0.000000000;\nconst float p_o10149_Normal = 0.000000000;\nconst float p_o10149_Alpha = 0.000000000;\nconst float p_o10149_AmbientOcclusion = 0.000000000;\nconst float p_o10149_scale = 0.306000000;\nconst float p_o10149_TranlateX = 0.000000000;\nconst float p_o10149_TranlateY = 0.000000000;\nconst float p_o10149_TranlateZ = 0.000000000;\nconst float p_o10149_RotateX = 0.000000000;\nconst float p_o10149_RotateY = 0.000000000;\nconst float p_o10149_RotateZ = 0.000000000;\nvec3 o10149_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10149_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10149_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10149_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10149_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10149_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10149_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10149_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10153_X = 0.500000000;\nconst float p_o10153_Y = 0.500000000;\nconst float p_o10153_Z = 0.500000000;\nconst float p_o10153_RepX = 14.000000000;\nconst float p_o10153_RepY = 14.000000000;\nconst float p_o10153_RepZ = 17.000000000;\nconst float p_o10154_r = 0.320000000;\nfloat o10149_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o10154_0_1_sdf3d = length((opRepLim((p),vec3(p_o10153_X,p_o10153_Y,p_o10153_Z)*2.0,vec3(p_o10153_RepX-1.0,p_o10153_RepY-1.0,p_o10153_RepZ-1.0))))-p_o10154_r;\nfloat o10153_0_1_sdf3d = o10154_0_1_sdf3d;\n\nreturn o10153_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10149(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10149_TranlateX,p_o10149_TranlateY,p_o10149_TranlateZ),vec3(p_o10149_RotateX,p_o10149_RotateY,p_o10149_RotateZ)*6.28318530718)/p_o10149_scale;\n\tfloat sdf=o10149_input_sdf3d(uv.xyz, _seed_variation_)*p_o10149_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10149_AmbientOcclusion*o10149_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10149_Alpha*o10149_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10149_Normal*o10149_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10149_Emission*o10149_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10149_Roughness*o10149_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10149_Specular*o10149_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10149_Metallic*o10149_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10149_BaseColor_r, p_o10149_BaseColor_g, p_o10149_BaseColor_b, p_o10149_BaseColor_a).rgb*o10149_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10137_BaseColor_r = 0.159263998;\nconst float p_o10137_BaseColor_g = 1.000000000;\nconst float p_o10137_BaseColor_b = 0.000000000;\nconst float p_o10137_BaseColor_a = 1.000000000;\nconst float p_o10137_Metallic = 0.547000000;\nconst float p_o10137_Specular = 0.500000000;\nconst float p_o10137_Roughness = 0.059000000;\nconst float p_o10137_Emission = 0.000000000;\nconst float p_o10137_Normal = 0.000000000;\nconst float p_o10137_Alpha = 0.000000000;\nconst float p_o10137_AmbientOcclusion = 0.000000000;\nconst float p_o10137_scale = 1.000000000;\nconst float p_o10137_TranlateX = 0.000000000;\nconst float p_o10137_TranlateY = 0.000000000;\nconst float p_o10137_TranlateZ = 0.000000000;\nconst float p_o10137_RotateX = 0.000000000;\nconst float p_o10137_RotateY = 0.000000000;\nconst float p_o10137_RotateZ = 0.000000000;\nvec3 o10137_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10137_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10137_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10137_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10137_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10137_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10137_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10137_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10147_sx = 0.250000000;\nconst float p_o10147_sy = 0.250000000;\nconst float p_o10147_sz = 1.940000000;\nconst float p_o10147_r = 0.280000000;\nfloat o10137_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10147_0_q = abs((p)) - vec3(p_o10147_sx, p_o10147_sy, p_o10147_sz);\nfloat o10147_0_1_sdf3d = length(max(o10147_0_q,0.0))+min(max(o10147_0_q.x,max(o10147_0_q.y,o10147_0_q.z)),0.0)-p_o10147_r;\n\nreturn o10147_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10137(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10137_TranlateX,p_o10137_TranlateY,p_o10137_TranlateZ),vec3(p_o10137_RotateX,p_o10137_RotateY,p_o10137_RotateZ)*6.28318530718)/p_o10137_scale;\n\tfloat sdf=o10137_input_sdf3d(uv.xyz, _seed_variation_)*p_o10137_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10137_AmbientOcclusion*o10137_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10137_Alpha*o10137_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10137_Normal*o10137_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10137_Emission*o10137_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10137_Roughness*o10137_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10137_Specular*o10137_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10137_Metallic*o10137_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10137_BaseColor_r, p_o10137_BaseColor_g, p_o10137_BaseColor_b, p_o10137_BaseColor_a).rgb*o10137_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o15436_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o10143_0_1_v4v4 = PBRObjectMaker_o10143((p), _seed_variation_);\nvec4 o10156_0_1_v4v4 = PBRObjectMaker_o10156((vec4((p).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(p).w)), _seed_variation_);\nvec4 o10162_0_1_v4v4 = PBRObjectMaker_o10162((vec4((vec4((p).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(p).w)).xyz-vec3(p_o10167_x, p_o10167_y, p_o10167_z),(vec4((p).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(p).w)).w)), _seed_variation_);\nvec4 o10167_0_1_v4v4 = o10162_0_1_v4v4;\nvec4 o10169_0_1_v4v4 = sdf3dc_union(o10156_0_1_v4v4, o10167_0_1_v4v4);\nvec4 o10168_0_1_v4v4 = o10169_0_1_v4v4;\nvec4 o10156_0_3_v4v4 = PBRObjectMaker_o10156((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)), _seed_variation_);\nvec4 o10162_0_3_v4v4 = PBRObjectMaker_o10162((vec4((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).xyz-vec3(p_o10167_x, p_o10167_y, p_o10167_z),(vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).w)), _seed_variation_);\nvec4 o10167_0_3_v4v4 = o10162_0_3_v4v4;\nvec4 o10169_0_3_v4v4 = sdf3dc_union(o10156_0_3_v4v4, o10167_0_3_v4v4);\nvec4 o10168_0_3_v4v4 = o10169_0_3_v4v4;\nvec4 o10208_0_1_v4v4 = o10168_0_3_v4v4;\nvec4 o10156_0_5_v4v4 = PBRObjectMaker_o10156((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).w)), _seed_variation_);\nvec4 o10162_0_5_v4v4 = PBRObjectMaker_o10162((vec4((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).w)).xyz-vec3(p_o10167_x, p_o10167_y, p_o10167_z),(vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).w)).w)), _seed_variation_);\nvec4 o10167_0_5_v4v4 = o10162_0_5_v4v4;\nvec4 o10169_0_5_v4v4 = sdf3dc_union(o10156_0_5_v4v4, o10167_0_5_v4v4);\nvec4 o10168_0_5_v4v4 = o10169_0_5_v4v4;\nvec4 o10208_0_3_v4v4 = o10168_0_5_v4v4;\nvec4 o10209_0_1_v4v4 = o10208_0_3_v4v4;\nvec4 o10210_0_1_v4v4 = PBRObjectMaker_o10210((p), _seed_variation_);\nvec4 o10259_0_1_v4v4 = PBRObjectMaker_o10259((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).xyz, -vec3(p_o10266_ax, p_o10266_ay, p_o10266_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).w)), _seed_variation_);\nvec4 o10223_0_1_v4v4 = PBRObjectMaker_o10223((vec4((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).xyz, -vec3(p_o10266_ax, p_o10266_ay, p_o10266_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).w)).xyz-vec3(p_o10264_x, p_o10264_y, p_o10264_z),(vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).xyz, -vec3(p_o10266_ax, p_o10266_ay, p_o10266_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).w)).w)), _seed_variation_);\nvec4 o10264_0_1_v4v4 = o10223_0_1_v4v4;\nvec4 o10265_0_1_v4v4 = sdf3dc_union(o10259_0_1_v4v4, o10264_0_1_v4v4);\nvec4 o10266_0_1_v4v4 = o10265_0_1_v4v4;\nvec4 o_o10268_0=o10266_0_1_v4v4;vec4 o10268_0_1_v4v4 = vec4(o_o10268_0.xyz,o_o10268_0.w*min(min(p_o10268_x, p_o10268_y), p_o10268_z)*p_o10268_xyz);\nvec4 o10267_0_1_v4v4 = o10268_0_1_v4v4;\nvec4 o10207_0_1_v4v4 = MFSDF_Union(o10168_0_1_v4v4,o10208_0_1_v4v4,o10209_0_1_v4v4,o10210_0_1_v4v4,o10267_0_1_v4v4,o10267_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\nvec4 o10149_0_1_v4v4 = PBRObjectMaker_o10149((vec4(twistZ((vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).xyz,(sin(iTime)*90.0)),(vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).w)), _seed_variation_);\nvec4 o10137_0_1_v4v4 = PBRObjectMaker_o10137((vec4(twistZ((vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).xyz,(sin(iTime)*90.0)),(vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).w)), _seed_variation_);\nvec4 o10148_0_1_v4v4 = mfsdf3d_smooth_subtraction(o10149_0_1_v4v4, o10137_0_1_v4v4,p_o10148_k);\nvec4 o10155_0_o=o10148_0_1_v4v4;vec4 o10155_0_1_v4v4 = vec4(o10155_0_o.xyz,o10155_0_o.w/(1.0+p_o10155_correction));\nvec4 o10215_0_1_v4v4 = o10155_0_1_v4v4;\nvec4 o10136_0_1_v4v4 = MFSDF_Union(o10143_0_1_v4v4,o10207_0_1_v4v4,o10215_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\n\nreturn o10136_0_1_v4v4;\n}\nvec3 o15436_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o15436_SunX,p_o15436_SunY,-p_o15436_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o15436(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.01,-0.001,0.0);\n  float v1=o15436_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o15436_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o15436_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o15436_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o15436(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 64; i++) {\n    \tp = ro + rd*d;\n        dS = o15436_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 14.0 || abs(dS) < 0.001) break;\n    }\n}\n\nvec3 raymarch_o15436(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3(p_o15436_CamX,(sin(iTime*0.5)*0.8+1.3),(sin(iTime*0.9)*2.0))*p_o15436_CamZoom;\n\tvec3 lookat=vec3(p_o15436_LookAtX,p_o15436_LookAtY,p_o15436_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o15436_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o15436(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o15436_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o15436_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o15436_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o15436_SunX,p_o15436_SunY,p_o15436_SunZ));\n\tif (d<14.0) {\n\t    vec3 n=normal_o15436(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tcolor=max(vec3(p_o15436_AmbLight),max(l,p_o15436_AmbLight))*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o15436(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<14.0) {\n\t\t\tobjColorRef=o15436_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o15436(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o15436_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o15436_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o15436_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o15436_Gamma));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o15436_0_1_rgb = raymarch_o15436((UV), _seed_variation_);\nfragColor = vec4(o15436_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 667, 687, 687, 766], [768, 768, 788, 788, 921], [923, 923, 943, 943, 1132], [1134, 1134, 1156, 1156, 1453], [1455, 1455, 1477, 1477, 1637], [1640, 1640, 1699, 1699, 1753], [1862, 1862, 1898, 1898, 1968], [1968, 1968, 2015, 2015, 2319], [2320, 2320, 2403, 2403, 2863], [2865, 2865, 2924, 2924, 3003], [3005, 3005, 3063, 3063, 3236], [3238, 3238, 3331, 3331, 3657], [3659, 3659, 3724, 3724, 3947], [3949, 3949, 4015, 4015, 4299], [4301, 4301, 4366, 4366, 4725], [4727, 4727, 4792, 4792, 5222], [5224, 5224, 5289, 5289, 6022], [7328, 7399, 7432, 7432, 7605], [7731, 7751, 7787, 8029, 9021], [9021, 9021, 9053, 9053, 9096], [9098, 9098, 9166, 9166, 9351], [9351, 9351, 9386, 9386, 9429], [9430, 9430, 9463, 9463, 9516], [9517, 9517, 9552, 9552, 9595], [9595, 9595, 9629, 9629, 9933], [9934, 9934, 10024, 10024, 10345], [10347, 10347, 10401, 10401, 10469], [10471, 10471, 10523, 10523, 10885], [10887, 10887, 10947, 10947, 11017], [11019, 11019, 11077, 11077, 11466], [11468, 11468, 11529, 11529, 11597], [11599, 11599, 11658, 11658, 12052], [12052, 12052, 12085, 12085, 12200], [12202, 12202, 12231, 12231, 12273], [12275, 12275, 12304, 12304, 12346], [12348, 12348, 12377, 12377, 12419], [12452, 12452, 12487, 12487, 12576], [12600, 12674, 12709, 12709, 12826], [12828, 12828, 12861, 12861, 13157], [13159, 13159, 13195, 13195, 13402], [13404, 13404, 13439, 13439, 13648], [13650, 13650, 13687, 13687, 13776], [13778, 13778, 13828, 13828, 14375], [14377, 14377, 14425, 14425, 14695], [16102, 16102, 16169, 16169, 16190], [16191, 16191, 16258, 16258, 16273], [16274, 16274, 16341, 16341, 16356], [16357, 16357, 16425, 16425, 16440], [16441, 16441, 16507, 16507, 16536], [16537, 16537, 16601, 16601, 16630], [16631, 16631, 16695, 16695, 16710], [16711, 16711, 16786, 16786, 16801], [17115, 17115, 17173, 17173, 17651], [18117, 18117, 18178, 18178, 19780], [22102, 22102, 22139, 22139, 22823], [23267, 23267, 23340, 23340, 23621], [23623, 23623, 23706, 23706, 23756], [23757, 23757, 23824, 23824, 25746], [25747, 25747, 25814, 25814, 25829], [25830, 25830, 25897, 25897, 25912], [26337, 26337, 26374, 26374, 26811], [26812, 26812, 26880, 26880, 28913], [28914, 28914, 28980, 28980, 29009], [29010, 29010, 29074, 29074, 29103], [29104, 29104, 29168, 29168, 29183], [29184, 29184, 29259, 29259, 29274], [29669, 29669, 29727, 29727, 30110], [30576, 30576, 30637, 30637, 32239], [33177, 33177, 33244, 33244, 33265], [33266, 33266, 33333, 33333, 33348], [33349, 33349, 33416, 33416, 33431], [33432, 33432, 33500, 33500, 33515], [33516, 33516, 33582, 33582, 33611], [33612, 33612, 33676, 33676, 33705], [33706, 33706, 33770, 33770, 33785], [33786, 33786, 33861, 33861, 33876], [34032, 34032, 34090, 34090, 34315], [34781, 34781, 34842, 34842, 36444], [37385, 37385, 37452, 37452, 37473], [37474, 37474, 37541, 37541, 37556], [37557, 37557, 37624, 37624, 37639], [37640, 37640, 37708, 37708, 37723], [37724, 37724, 37790, 37790, 37819], [37820, 37820, 37884, 37884, 37913], [37914, 37914, 37978, 37978, 37993], [37994, 37994, 38069, 38069, 38084], [38240, 38240, 38298, 38298, 38523], [38989, 38989, 39050, 39050, 40652], [43248, 43248, 43285, 43285, 43969], [44414, 44414, 44487, 44487, 44769], [44771, 44771, 44854, 44854, 44904], [44905, 44905, 44972, 44972, 46894], [46895, 46895, 46962, 46962, 46977], [46978, 46978, 47045, 47045, 47060], [47485, 47485, 47522, 47522, 47959], [47960, 47960, 48028, 48028, 50061], [50062, 50062, 50128, 50128, 50157], [50158, 50158, 50222, 50222, 50251], [50252, 50252, 50316, 50316, 50331], [50332, 50332, 50407, 50407, 50422], [50817, 50817, 50875, 50875, 51258], [51724, 51724, 51785, 51785, 53387], [54325, 54325, 54392, 54392, 54413], [54414, 54414, 54481, 54481, 54496], [54497, 54497, 54564, 54564, 54579], [54580, 54580, 54648, 54648, 54663], [54664, 54664, 54730, 54730, 54759], [54760, 54760, 54824, 54824, 54853], [54854, 54854, 54918, 54918, 54933], [54934, 54934, 55009, 55009, 55024], [55180, 55180, 55238, 55238, 55463], [55929, 55929, 55990, 55990, 57592], [58614, 58614, 58681, 58681, 58702], [58703, 58703, 58770, 58770, 58785], [58786, 58786, 58853, 58853, 58868], [58869, 58869, 58937, 58937, 58952], [58953, 58953, 59019, 59019, 59048], [59049, 59049, 59113, 59113, 59142], [59143, 59143, 59207, 59207, 59222], [59223, 59223, 59298, 59298, 59313], [59592, 59592, 59650, 59650, 59885], [60351, 60351, 60412, 60412, 62014], [62837, 62837, 62904, 62904, 62925], [62926, 62926, 62993, 62993, 63008], [63009, 63009, 63076, 63076, 63091], [63092, 63092, 63160, 63160, 63175], [63176, 63176, 63242, 63242, 63271], [63272, 63272, 63336, 63336, 63365], [63366, 63366, 63430, 63430, 63445], [63446, 63446, 63521, 63521, 63536], [63692, 63692, 63750, 63750, 63975], [64441, 64441, 64502, 64502, 66104], [66104, 66104, 66161, 66161, 73165], [73166, 73166, 73223, 73223, 73346], [73348, 73424, 73476, 73476, 73861], [73863, 73863, 73961, 73961, 74153], [74155, 74155, 74210, 74210, 76002], [76003, 76003, 76058, 76058, 76355]], "test": "valid"}
{"id": "7lV3z1", "name": "LCD Gone Wrong (Trippy)", "author": "spenceryonce", "description": "Whoops. My lcd broke, this is what it looked like. lol.", "tags": ["trippy", "lcd", "gonewrong"], "likes": 1, "viewed": 23, "published": "Public", "date": "1637198090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    col.r += sin(uv.x*iTime*5.0);\n    col.b += sin(uv.y*iTime*5.1);\n    \n    col.g += sin(uv.x*uv.y*iTime*5.0);\n    \n    col *= vec3(fract(abs(sin(uv.x*iTime*2.0*uv.y))));\n    \n    col *= vec3(abs(cos(uv.y*uv.x)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 382]], "test": "valid"}
{"id": "7lV3zt", "name": "ChessSet2", "author": "Artleet", "description": "chess set, part of some inner jam", "tags": ["raymarching", "golf", "golfing"], "likes": 8, "viewed": 98, "published": "Public", "date": "1638233183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//some further compression is possible\n//chess figures are stylized and abstract so do not judge too strict :)\n#define A abs\nvoid mainImage(out vec4 o, vec2 F)\n{\n    float c,s,d,i,e=.5,h=e,y,t=iTime;\n    for(vec3 p,R=iResolution,f;\n      ++i<5e2&&e>1e-3;\n      p=d*normalize(vec3(F/h-R.xy,R))+vec3(sin(t)/h,4,cos(t)-15.),f=floor(p*h),\n      c=mod(f.x+f.z,2.),\n      c=(y=p.y)>1e-2?1.-c:c,\n      s=y>3.1||A(p.x)>8.||A(p.z)>8.?c=-h:--p.z>-1.3?\n          max(\n              max(\n                  1.-A(h*mod(s=y+12.-4.*f.x,4.)-h*h),\n                  h-abs(14.-A(s-16.))),\n              max(\n                  h-A(3.-A(s*h-8.)),\n                  max(1.-A(s-17.5),h-A(2.-A(s-16.5)))\n                  )\n              ):max(.7-y*h,h-A(y-1.))+0.*(p.z+=2.),\n      p.x=mod(p.x,2.)-1.,\n      d+=e=h*min(y,length(p.xz)-s*.9)\n    );\n    o+=8./i;o*=c+h;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 161, 161, 844]], "test": "valid"}
{"id": "7lVGDw", "name": "Mandelbrot x4 Animated", "author": "adamjmurray", "description": "Animated version of https://www.shadertoy.com/view/7lKGDw", "tags": ["fractals"], "likes": 2, "viewed": 35, "published": "Public", "date": "1637992038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float iterations = 40.;\nconst float zoom = 1.2;\nconst float quality = 2.;\n\nvec2 cmul(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) { // complex division\n    return vec2(a.x*b.x+a.y*b.y, -a.x*b.y+a.y*b.x) / (b.x*b.x+b.y*b.y);\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n  float hp = 6. * mod(h,1.);\n  float c = s - s * abs(2.*l - 1.);\n  float x = c - c * abs(mod(hp,2.) - 1.);\n  float m = l - c/2.;\n  if      (hp <= 1.) return vec3(c,x,0) + m;\n  else if (hp <= 2.) return vec3(x,c,0) + m;\n  else if (hp <= 3.) return vec3(0,c,x) + m;\n  else if (hp <= 4.) return vec3(0,x,c) + m;\n  else if (hp <= 5.) return vec3(x,0,c) + m;\n  else               return vec3(c,0,x) + m;\n}\n\nvec3 draw(vec2 c) {\n    vec2 z = vec2(1, 0);\n    vec2 shift = vec2(cos(iTime/5.)/2., 0);\n        \n    float i = 0.;    \n    while (i < iterations) {\n        vec2 z2 = cmul(z, z);\n        z =  cmul(c, (z2 + cdiv(vec2(1, 0), shift + z2)));\n        \n        if (length(z) > 16.) break;\n        i++;\n    }\n  \n    if (i >= iterations) {\n        return vec3(0,0,0);\n    } else {\n        float hue = (i - log2(log(length(z))))/iterations;\n        return hsl2rgb(hue, 0.5, 0.5);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {     \n    vec3 color = vec3(0,0,0);\n    float samples = 0.;\n  \n    float subpixel = 1./quality;\n    for (float x=0.; x<1.; x+=subpixel) {\n        for (float y=0.; y<1.; y+=subpixel) {\n            vec2 subCoord = fragCoord + vec2(x,y);\n            vec2 coord = (2.*subCoord - iResolution.xy)/iResolution.y;\n            color += draw(coord/zoom);\n            samples++;\n        }\n    }\n    fragColor = vec4(color/samples, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 108, 134, 187], [188, 188, 215, 235, 309], [311, 311, 352, 352, 753], [755, 755, 774, 774, 1233], [1235, 1235, 1292, 1292, 1717]], "test": "valid"}
{"id": "7lVGWW", "name": "The Cell Void", "author": "lambmeow", "description": "testing out voronoi in 3d space", "tags": ["voronoi", "sdf", "cellular", "void"], "likes": 5, "viewed": 180, "published": "Public API", "date": "1637746961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time (iTime + 100.)\n\n//color\n//#define COLOR\n\n//see all spheres\n//#define SHOW_ALL\n\n\nvec3 rand(vec3 p)\n{\n    float x = dot(p, vec3(105.2523, 323.6236, 246.634)),\n    y = dot(p , vec3(225,123.35235,352.235)),\n    z = dot(p, vec3(373,164.352,273.46343));\n    \n    return fract(sin(vec3(x,y,z))* 45364.623624);\n}\n\nmat2 rot(float a)\n{\n    float c= cos(a), s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\nvec4 voro(vec3 p)\n{\n    vec3 ip = floor(p), fp = fract(p);\n    \n    float dd = 1.;\n    vec3 pos = vec3(0);\n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j ++)\n        {\n            for(int k = -1; k <= 1; k++)\n            {\n                vec3 n = vec3 (j, i ,k); \n                vec3 o = ip + n;\n                //o.xy *= rot(iTime * 0.01) *0.01;\n                vec3 p = rand(o);\n                \n                //p.xz += 0.25 * sin(iTime + p.x) + cos(p.z + iTime) * 0.25;\n                float d = length(n + p - fp);\n            \n                if(d < dd)\n                {\n                    dd = d;\n                    pos = n + p - fp;\n                }\n            }\n        }\n    }\n    return vec4(pos,dd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r = iResolution.xy,uv = (2. * fragCoord - r)/r.y;\n    \n    \n    vec3 ro = vec3(0, time* 0.01, time),rd = normalize(vec3 (uv,2.));\n    \n    // Time varying pixel color\n    \n    vec3 col = vec3(0);\n    \n    float dd = 0.;\n\n    for(int i = 0; i < 255; i ++)\n    {\n        vec3 p = ro + rd * dd;\n       // p.xy -= ro.xy;\n        //p.xy *= mat2(cos(iTime + p.z), -sin(iTime + p.z), sin(iTime + p.z), cos(iTime + p.z)) * 0.5;\n       //p.xy += ro.xy;\n        vec4 vp = voro(p);\n        float ll = vp.w - length(p - ro)* 0.03 + length(uv) * 0.1;\n        \n        if ( ll < 0.001)\n        {\n            col = 1.-vec3(max(dot(vp.xyz, p), 0.)) * 1.- length(p - ro) * .01; //col = vec3(1) * 100/;\n#ifdef COLOR\n            col.gb *= 0.5 + sin(time * 5. + length(ro-p) ) * 0.3;\n#endif\n\n#ifdef SHOW_ALL\n            col = 1.-vec3(length(p - ro) * 0.01);\n#endif\n\n            break;\n        }\n        dd += ll;\n        \n        if(dd > 100.)\n            break;\n    }\n\n    // Output to screen\n    \n#ifdef SHOW_ALL\n    fragColor = vec4(col,1.0);\n#else\n    fragColor = vec4(col * length(uv /2.) ,1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 317], [319, 319, 338, 338, 405], [406, 406, 425, 425, 1153], [1155, 1155, 1212, 1262, 2361]], "test": "valid"}
{"id": "7lVGzh", "name": "Autumn mushrooms", "author": "iapafoto", "description": "Leprechauns love mushrooms, when they find an owl they party a lot\nWith party sound on, they only dance when there is music!", "tags": ["bezier", "automn", "elf", "lutin", "leprechaun"], "likes": 27, "viewed": 237, "published": "Public API", "date": "1637616224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by sebastien durand - 11/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n// Based on\n// iq - Quadratic Bezier - https://www.shadertoy.com/view/ldj3Wh\n// *****************************************************************************\n\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n\n#define nose 2.\n#define hat 3.\n#define dress 4.\n#define leg 5.\n#define foot 6.\n#define bear 7.\n#define mushrom 9.\n\n//-----------------------------------------------------------------------------------\n\nvec3 getPtOnBez(vec3 p0, vec3 p1, vec3 p2, float t) {\n    return (1. - t) * (1. - t) * p0 + 2. * (1. - t) * t * p1 + t * t * p2;\n}\n\n//-----------------------------------------------------------------------------------\n// Mercury\nfloat fOpUnionRound(float a, float b, float r) {\n\treturn max(r, min (a, b)) - length(max(vec2(r - a,r - b), vec2(0)));\n}\n\nfloat pModPolar(inout vec2 p, float rep) {\n\tfloat an = 3.141592/rep,\n         a = atan(p.y, p.x) + an,\n         r = length(p),\n         c = floor(.5*a/an);\n\ta = mod(a,2.*an) - an;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= rep*.5) c = abs(c);\n\treturn c;\n}\n\n//-----------------------------------------------------------------------------------\n// iq - https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(in vec3 p,in vec3 b0,in vec3 b1,in vec3 b2 ) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)/dot(g,g))/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\nvec2 sdCapsule(in vec3 p,in vec3 a,in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n  return vec2(length(pa - ba*h), h);\n}\n\nfloat sdEllipsoid(in vec3 p,in vec3 r) {\n  float k0 = length(p/r);\n  return k0*(k0-1.)/length(p/(r*r));\n}\n\n//-----------------------------------------------------------------------------------\n// Scene modeling\nvec2 sdMush(in vec3 p) {\n    float d = .5*(sdBezier(p, vec3(0,0,0), vec3(.4,3,0), vec3(.2,4.2,.3)).x-.1);\n\td = fOpUnionRound(d,max(sdEllipsoid(p-vec3(.3,3.3,.3), vec3(1.2,.7,1.2)),\n                    -sdEllipsoid(p-vec3(.27,3.,.25), vec3(1.3,.7,1.5))),.5);\n\td = min(d,sdEllipsoid(p-vec3(-3.,.6,6.), vec3(.8,.6,.8)));\n\td = min(d,sdEllipsoid(p-vec3(4.5,.5,2.5), vec3(.6,.5,.6)));\n\td = min(d,sdEllipsoid(p-vec3(-6.5,.5,-8.5), vec3(.6,.5,.6)));\n\treturn vec2(d, mushrom);\n}\n\nvec2 sdHand(vec3 p, vec3 p10, vec3 p11, vec3 n) {\n    vec3 knee = .5*(p11+p10) + n,\n         p2 = getPtOnBez(p10, knee, p11, .2),\n         nn = normalize(p10-p2);\n    // harm     \n    vec2 h = sdBezier(p, p11, knee, p10);\n    float d,\n          dm = max(h.x - .1 - .05*h.y, -length(p-p10)+.2),\n          hm=h.y;\n    // fingers\n    d = sdCapsule(p, p10+vec3(.03*sign(n.x),0,0), p2).x;\n    p += nn*.05;\n    d = min(d, sdCapsule(p, p10+vec3(0,.05,0), p2+vec3(0,.05,0)).x);\n    d = min(d, sdCapsule(p, p10-vec3(-.02*sign(n.x),.05,0), p2-vec3(0,.05,0)).x);\n    p += nn*.05;\n    d = min(d, sdCapsule(p, p10-vec3(0,.1,0), p2-vec3(0,.1,0)).x);\n    d -= .05;\n    return d < dm ? vec2(d, nose) : vec2(dm, dress);\n}\n\nvec2 sdLeg(vec3 p, vec3 foot10, vec3 foot11, vec3 n) {\n    vec3 knee = .5*(foot11+foot10) + n,\n         p4 = getPtOnBez(foot10, knee, foot11, .2);\n    vec2 h = sdBezier(p, foot11, knee, foot10);\n    float d,dm = h.x - .1, \n          hm = leg + h.y;\n    // foot\n    h = sdCapsule(p, foot10, p4);\n    d = max(h.x - .2, -length(p- mix(foot10, p4, 2.5)) + .4);\n    if (d<dm) { dm=d; hm=dress;}\n    p.y += .1; \n    h = sdCapsule(p, foot10, foot10 + n);\n    d = h.x - .2;\n    if (d<dm) { dm=d; hm=hat; }\n    return vec2(dm,hm);\n}\n\nfloat invMix(float v0, float v1, float v) {\n    return v1 == v0 ? 1. : (v-v0)/(v1-v0);\n}\n\nfloat getAmp(float frequency) { return texture(iChannel2, vec2(frequency / 512.0, 0)).x; }\n\n#define BPM 127.\nvec2 sdLutin(in vec3 p, in float lid) {\n    float t = iChannelTime[2]*2.11666,\n          a1 = (getAmp(lid*lid * 20.)*.5+.5)*cos(9.*t+1.57 * lid),\n          anim = (getAmp(lid*lid * 40.)*.5+.5)*cos(6.*t+1.57 * lid),\n          gg = .5*cos(lid*110.);\n          \n    vec3 head = vec3(0,2.5+gg,0),\n         hips = vec3(0,1.2+gg,0);\n   \n    head += .2*vec3(.5,.5,.2)*(a1 + .5*anim);\n    hips += .3*vec3(.5,.2,.2)*anim;   \n    \n    vec3 epaule = head - vec3(0,.7,0),\n         c = head + vec3(0,.9,-.8),\n         b = head + vec3(0,.65,-.3);\n\n    float d, dm, hm = nose;\n    \n    // nez\n    dm = sdEllipsoid(p- head - vec3(0,0,.5), vec3(.3,.15,.3));\n    \n    // bras\n    float s = p.x>0.?1.:-1.;\n    vec2 h = sdHand(p, epaule + vec3(s*1.,-.7+s*.3*anim- .3*gg,.5+ .4*gg), epaule+vec3(s*.4,0.,-.05), vec3(s*.2,-.2,-.2));\n    if( h.x<dm ) { dm=h.x; hm = h.y; }\n \n    // body\n    vec3 pb = p;\n    pb.z /= .7;\n    pb.z -= .2*cos(p.y)*smoothstep(epaule.y,hips.y,invMix(epaule.y,hips.y, p.y));\n    h = sdCapsule(pb, epaule+vec3(0,-.15,0), hips-vec3(0,.7,0));\n    d = max(h.x - mix(.4,.6,h.y), -length(pb-hips+vec3(0,.8,0)) + .7);\n    if (d<dm) { hm = dress; }\n    dm = .7*fOpUnionRound(d, dm, .15);\n    \n    // legs  \n    h = sdLeg(p, vec3(s*.5,-.7,0), hips + vec3(s*.25,-.2,0), vec3(s*.2,0,.3));\n    if (h.x<dm) { dm=h.x; hm=h.y; }\n    \n     // bonet\n    vec3 p3 = p + vec3(0,.1,-.1);\n    h = sdBezier( p3, head-vec3(0,.05,0), b, c );\n    d = .7*max( h.x - .5 + .5*h.y, -length(p3-(head-vec3(0,.8,-.6))) + 1.);\n    if( d<dm ) { dm=d; hm=hat; }\n\n    // barbe\n    vec3 p4 = p;\n    float k = mix(1.,3.,smoothstep(head.y, head.y-1., p4.y));\n    p4.z*=k;\n    h = sdBezier( p4, head, head - vec3(0,1.,.0), vec3(head.x, head.y, head.z*k) - vec3(-.2*anim,1,-3.));\n    d = .7*fOpUnionRound(h.x - .3*sin(3.14*h.y), length(p-(head-vec3(0,.4,-.2)))-.5, .15);\n    if (d<dm) { dm=d; hm=bear; }\n\n\treturn vec2(dm*.9, 10.*lid + hm );\n}\n\nvec2 map(in vec3 p) {\n\tvec2 h2, h1 = sdMush(p-vec3(0,-1.05,0));\n    float id = pModPolar(p.xz, 6.),\n          d = sdEllipsoid(p-vec3(3,1.35,0), vec3(1.3,2.9,1.6));\n    if (d>0.) h2 = vec2(d+.1,0);\n    else      h2 = sdLutin((p - vec3(3,0,0)).zyx, id);\n    return h1.x<h2.x ? h1 : h2;\n}\n\n//-------------------------------------------------------\n// Ray marching\nvec3 intersect( in vec3 ro, in vec3 rd ) {\n    vec3 res = vec3(-1.);\n    float maxd = 25.;\n    // plane\n    float tp = (-.85-ro.y)/rd.y;\n    if (tp>0.) {\n        res = vec3(tp,0,0);\n        maxd = min(maxd,tp);\n    }\n    // Lutins\n    float t = 2., l = 0.;\n    for( int i=ZERO; i<92; i++ ) {\n\t    vec2 h = map(ro+rd*t);\n        if (h.x<.004 || t>maxd) break;\n        t += h.x;\n\t\tl = h.y;\n    }\n    return t<maxd ? vec3(t, l, 1.) : res;\n}\n\nvec3 calcNormal( in vec3 pos ) {\n // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+.002*e).x;\n    }\n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k ) {\n    float res = 1., t = mint, h = 1.;\n    for( int i=ZERO; i<48; i++ ) {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, .002, 2. );\n        if( res<.001 ) break;\n    }\n    return clamp(res,0.,1.);\n}\n\nfloat map2( in vec3 pos ) {\n    return min(pos.y+.85, map(pos).x);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n    float h,d,ao = 0.;\n    for( int i=ZERO; i<8; i++ ) {\n        h = .02 + .5*float(i)/7.;\n        d = map2( pos + h*nor );\n        ao += h-d;\n    }\n    return clamp( 1.5 - ao*.6, 0., 1. );\n}\n\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Grey scale.\nfloat grey(vec3 p){ return dot(p, vec3(.299, .587, .114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( grey(tex3D(tex, vec3(p.x-ep, p.y, p.z), n)),\n                      grey(tex3D(tex, vec3(p.x, p.y-ep, p.z), n)),\n                      grey(tex3D(tex, vec3(p.x, p.y, p.z-ep), n)));\n    grad = (grad - grey(tex3D(tex, p, n)))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n// iq palette\nvec3 pal(in float t) {\n    return .5 + .5*cos(6.28318*(t+vec3(.0,.33,.67)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec4 tot = vec4(0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5,\n             p = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n#endif\n\n        //-----------------------------------------------------\n        // camera\n        //-----------------------------------------------------\n        float an = 2. + .3*iTime + 3.*smoothstep(.9,.95, sin(.32*iTime)) +  3.*smoothstep(.9,.95, sin(.06*iTime));\n\n        vec3 ro = mix(1.75,1.2,smoothstep(-.9,-.8, cos(.15*iTime+.001*iTime*iTime)))*vec3(10.0*sin(an),5.0,10.0*cos(an)),\n             ta = vec3(.02*an,0,0);\n\n        // camera matrix\n        float a = .1*cos(.1*iTime);\n        vec3 ww = normalize(ta - ro),\n             uu = normalize(cross(ww,normalize(vec3(sin(a),cos(a),0)))),\n             vv = normalize(cross(uu,ww));\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        //-----------------------------------------------------\n        // render\n        //-----------------------------------------------------\n\n        vec3 lig = normalize(vec3(-.2,.6,.9));\n        float sun = pow( clamp( dot(rd,lig), 0., 1. ), 8. );\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n\n        // geometry\n        vec3 nor, pos = ro + tmat.x*rd;\n        if( tmat.z<.5)\n             nor = vec3(0,1,0);\n        else nor = calcNormal(pos);\n        \n        vec3 ref = reflect( rd, nor );\n\n        // materials\n        vec3 mate = vec3(.5);\n\n        float lid = floor(tmat.y*.1);\n        tmat.y = mod(tmat.y,10.);\n        vec3 col, \n             col1 = pal(lid/6.),\n             col2 = pal(lid/6. + .33);\n\n        if (tmat.y < nose) {\n            float k = texture(iChannel1, .051*pos.xz).x;\n            mate = texture(iChannel1, .2*pos.xz).xyz;\n            mate = .12*pow(mate,vec3(.3));\n            mate = .5*mix(mate, vec3(.65,.5,.0), .2*smoothstep(.5,.6,k));\n            nor = doBumpMap(iChannel1, .2*pos, nor, .02);\n        } else if (tmat.y < hat) {\n            mate = vec3(.68,.475,.446);\n        } else if (tmat.y < dress) {\n            mate = col2;\n        } else if (tmat.y < leg) {\n            mate = col1;\n        } else if (tmat.y < bear) {\n            mate = mix(col2, vec3(.2), smoothstep( -0.1, 0.1, cos( 40.0*tmat.y )));\n        } else if (tmat.y < mushrom) {\n            vec3 p2 = pos;\n            float lid2 = pModPolar(p2.xz, 6.),\n            a1 = cos(6.*iTime+1.57 * lid2),\n            anim = cos(4.*iTime+1.57 * lid2);\n            vec3 head = vec3(0,2.5,0) + vec3(0,.5*cos(lid2*110.),0),\n            hips = vec3(0,1.2,0) + vec3(0,.5*cos(lid2*110.),0);\n            head += .2*vec3(.5,.5,.2)*(a1 + .5*anim);\n            nor = doBumpMap(iChannel0, 1.5*(pos-head)*vec3(1,.2,1), nor, .12);\n            mate = lid2<0. ? vec3(211,110,76)/256. : vec3(1.);\n        } else {\n            vec3 p = pos - vec3(.2,4.2,.3);\n            float r = length(p.xz);\n            if (r<2.) {\n                mate = mix(vec3(.7), .5*vec3(1,.5,1), smoothstep(.5,1.5,pos.y));\n                nor = doBumpMap(iChannel0, vec3(.1*atan(p.x,p.z),.1*r,0), nor, .01);\n            } else {\n                mate = vec3(.7);\n            }\n            mate = 2.*mix(.25*vec3(1,.7,.6),mate,smoothstep(.2,.3,tex3D(iChannel1, .5*pos, nor).x));\n        }\n\n        float occ = calcAO(pos, nor);\n\n        // lighting\n        float sky = clamp(nor.y,0.,1.),\n             bou = clamp(-nor.y,0.,1.),\n             dif = max(dot(nor,lig),0.),\n             bac = max(.3 + .7*dot(nor,-lig),0.),\n             fre = pow( clamp( 1. + dot(nor,rd), 0., 1. ), 5.),\n             spe = .5*max( 0., pow( clamp( dot(lig,reflect(rd,nor)), 0., 1.), 8.)),\n             sha = 0.; \n        if (dif>.001) sha=softshadow(pos+.01*nor, lig, .0005, 32.);\n\n        // lights\n        vec3 brdf = 2.*dif*vec3(1.25,.9,.6)*sha;\n        brdf += 1.5*sky*vec3(.1,.15,.35)*occ;\n        brdf += bou*vec3(.3)*occ;\n        brdf += bac*vec3(.3,.25,.2)*occ;\n        brdf += fre*occ*dif;\n\n        // surface-light interacion\n        col = mate.xyz* brdf;\n        col += (1.-mate.xyz)*spe*vec3(1,.95,.9)*sha*2.*(.2+.8*fre)*occ;\n\n        // fog\n        col = mix( col, 3.*vec3(.09,.13,.15), smoothstep(7.,30.,tmat.x) );\n\t\tcol += .4*vec3(1,.68,.7)*sun;\n        tot += vec4(col, tmat.x);\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // Gamma\n\ttot.xyz = pow(clamp(tot.xyz,0.,1.), vec3(0.5));\n    // Vigneting\n    vec2 q = fragCoord/iResolution.xy;\n    tot.xyz *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .32); \n    fragColor = vec4(tot.xyz,1.);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGzh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[614, 614, 667, 667, 744], [746, 843, 891, 891, 963], [965, 965, 1007, 1007, 1221], [1223, 1355, 1415, 1415, 1822], [1824, 1824, 1871, 1871, 1991], [1993, 1993, 2033, 2033, 2098], [2100, 2204, 2228, 2228, 2673], [2675, 2675, 2724, 2724, 3379], [3381, 3381, 3435, 3435, 3904], [3906, 3906, 3949, 3949, 3994], [3996, 3996, 4027, 4027, 4086], [4105, 4105, 4144, 4144, 6008], [6010, 6010, 6031, 6031, 6295], [6297, 6371, 6413, 6413, 6808], [6810, 6810, 6842, 6937, 7129], [7131, 7131, 7196, 7196, 7428], [7430, 7430, 7457, 7457, 7498], [7501, 7501, 7542, 7542, 7734], [7737, 8108, 8156, 8156, 8301], [8303, 8318, 8337, 8337, 8378], [8380, 8462, 8524, 8524, 8887], [8889, 8903, 8925, 8925, 8982]], "test": "error"}
{"id": "7ly3D1", "name": "Lightspeed effect", "author": "peremoya2000", "description": "Extremely simple star wars lightspeed effect. Pure 2D.", "tags": ["stars", "uvs", "starwars", "short", "lightspeed"], "likes": 7, "viewed": 96, "published": "Public", "date": "1637683359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 suv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Radial UVs    \n    vec2 uv = vec2(length(suv),atan(suv.y,suv.x));\n    \n    //Stars\n    float offset = .1*sin(uv.y*10.f-iTime*.6)*cos(uv.y*48.f+iTime*.3)*cos(uv.y*3.7f+iTime);\n    vec3 rays = vec3(sin(uv.y*150.f+iTime)*.5+.5)* \n    vec3(sin(uv.y*80.f-iTime*0.6)*.5+.5)*\n    vec3(sin(uv.y*45.f+iTime*0.8)*.5+.5)*\n    vec3(1.f-cos(uv.y+22.f*iTime-pow(uv.x+offset,.3f)*60.f))*\n    vec3(uv.x*2.f);\n\n    // Output to screen\n    fragColor = vec4(rays.xy*.7,rays.z, 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 645]], "test": "valid"}
{"id": "7ly3RR", "name": "rgb spheres", "author": "venturecapital", "description": "limited range diffuse light shading with multiple \"materials\"", "tags": ["shadow", "beginner", "checkerboard", "messy"], "likes": 1, "viewed": 50, "published": "Public", "date": "1637045040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int MAXIMUM_RAY_STEPS = 1024;\nfloat MIN_DIST = .001;\nfloat MAX_DIST = 69.;\n\n// EPSILON ϵ - usually used to denote a small quantity\nfloat EPSILON = 0.0001;\n\n// Materials\nint m_n = 99;\nint m_s1 = 0;\nint m_s2 = 1;\nint m_s3 = 2;\nint m_plane = 3;\n\n// n is a Plane Equation. .xyz is the normal vector of the plane and .w is the distance from origin.\n// n must be normalized\nfloat sdfPlane(vec3 p, vec4 n) {\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdfSphere(vec3 p, float r, vec3 c) {\n    return distance(p, c)-r;\n}\n\n// returns [dist, material]\nvec2 sdf(vec3 p) {\n    // floaty point modifier gives the sphere centers a slight wobble\n    float fp1 = sin(iTime) * 0.02;\n    float fp2 = sin(iTime) * 0.021;\n    float fp3 = sin(iTime) * 0.022;\n\n    float speed = 0.4;\n\n    float r = .25;\n\n    float outer_y = sin(iTime*speed) * .4;\n\n    float plane = sdfPlane(p, vec4(0., 1., 0., 1.));\n\n    float s1 = sdfSphere(p, r, vec3(-r*1.5, -outer_y+fp1, cos(iTime*speed)*r*1.5));\n    float s2 = sdfSphere(p, r, vec3(.0, .0+fp2, .0));\n    float s3 = sdfSphere(p, r, vec3(r*1.5, outer_y+fp3, -cos(iTime*speed)*r*1.5));\n\n    float dist = min(plane, min(min(s1,s2),s3));\n\n    if (dist == plane) return vec2(dist, m_plane);\n    if (dist == s1) return vec2(dist, m_s1);\n    if (dist == s2) return vec2(dist, m_s2);\n    if (dist == s3) return vec2(dist, m_s3);\n}\n\n// via iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdf(ro + rd*t).x;\n        if( h<0.001 ) return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// via https://www.iquilezles.org/\nvec3 getNormal( vec3 p) {\n    vec2 h = vec2(EPSILON, 0);\n    return normalize(vec3(\n        sdf(p + h.xyy).x - sdf(p - h.xyy).x,\n        sdf(p + h.yxy).x - sdf(p - h.yxy).x,\n        sdf(p + h.yyx).x - sdf(p - h.yyx).x\n    ));\n}\n\nfloat checkerboard(vec3 p) {\n    float cx = floor(1. * p.x);\n    float cy = floor(1. * p.z); \n    float result = mod(cx + cy, 2.0);\n    return sign(result);\n}\n\n// diffuse lighting\nfloat diffuse(vec3 origin, vec3 p) {\n    float d = distance(origin, p);\n    vec3 l = normalize((origin - p) * d);\n    vec3 n = getNormal(p);\n\n    // dot gives value between -1 and 1\n    // clamp between 0 and 1\n    float diffuse = clamp(dot(n, l), 0., 1.);\n    return clamp(diffuse * (5./distance(origin.xz, p.xz)), 0., 1.);\n}\n\n// src - https://www.shadertoy.com/view/4tByzD\nvec2 rayMarch(vec3 origin, vec3 direction) {\n    // used to store current and last distance\n    vec2 dist = vec2(MIN_DIST);\n\n    for (int i = 0; i < MAXIMUM_RAY_STEPS; i++) {\n        // get the point we hit\n        vec3 p = origin + direction * dist.y;\n\n        // get minimal distance from objects in the scene\n        vec2 d = sdf(p);\n        dist.x = d.x;\n\n        // collision detection\n        if (dist.x <= EPSILON) {\n            // return the last depth\n            return vec2(dist.y, d.y);\n        }\n\n        // increase last distance\n        dist.y += dist.x;\n\n        if (dist.y >= MAX_DIST) {\n            return vec2(MAX_DIST, m_n);\n        }\n    }\n\n    return vec2(MAX_DIST, m_n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // this makes it so that the zero uvs are in the center of the view\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\n    // rayMarch scene\n    vec3 cam = vec3(0., .25, 3);\n    vec3 light = vec3(-sin(iTime*.3)*7., 4., (sin(iTime*.6)*5. + 10.)/2. - 1.);\n    \n    vec3 direction = normalize(vec3(uv, -1));\n    vec2 result = rayMarch(cam, direction);\n    float dist = result.x;\n    int mat = int(result.y);\n\n    vec3 color = vec3(0., 0., 0.);\n    if (dist < MAX_DIST) {\n        vec3 p = cam + direction * dist;\n        vec3 normal = getNormal(p);\n\n        if (mat == m_s1) color=vec3(.8,0,0);\n        if (mat == m_s2) color=vec3(0,.8,0);\n        if (mat == m_s3) color=vec3(0,0,.8);\n        if (mat == m_plane) color = vec3(checkerboard(p)+0.3);\n\n        float diffuse = diffuse(light, p);\n        color *= vec3(diffuse);\n\n        // brighten things up a bit\n        color *= 1.05;\n\n        float softShadow = softshadow(p, normalize(light), .1, 10., 40.);\n        color *= (softShadow+0.1);\n    }\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 369, 401, 401, 434], [436, 436, 478, 478, 509], [511, 539, 557, 627, 1337], [1339, 1349, 1426, 1426, 1629], [1631, 1666, 1691, 1691, 1893], [1895, 1895, 1923, 1923, 2053], [2055, 2075, 2111, 2111, 2401], [2403, 2450, 2494, 2541, 3145], [3147, 3147, 3204, 3276, 4257]], "test": "error"}
{"id": "7ly3Rt", "name": "Mushroom Imperfection", "author": "ivatronx", "description": "Singularity ", "tags": ["mushroom"], "likes": 1, "viewed": 28, "published": "Public", "date": "1638162020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932;\n\nfloat atanM(float y, float x){\n    if(x >= 0.){\n        return atan(y/x)/pi/2.+.75;\n    }\n    return (pi+2.*atan(y/x))/4./pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    int amount = 2;\n    float width = 2.5;\n    float speed = 0.05;\n    float speed2 = 0.075;\n    float speed3 = 0.10;\n    vec3 color1 = vec3(1.0, 1.5, 2.0);\n    vec3 color2 = vec3(-0.1, 0.0, 0.1);\n    vec3 color12 = vec3(1.0, 2.5, 2.0);\n    vec3 color22 = vec3(-0.11, 0.11, 0.11);\n    vec3 color13 = vec3(2.0, 2.5, 2.0);\n    vec3 color23 = vec3(-0.01, 0.01, 0.01);\n    \n\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col;\n    vec3 col2;\n    vec3 col3;\n    float d = length(uv);\n    float d2 = length(uv)/50.;\n    float d3 = length(uv)/75.0;\n    d -= iTime*speed;\n    d2 -= iTime*speed2;\n    d3 -= iTime*speed3;\n\n    float mascara = smoothstep(R.y/2.+width*4., R.y/2.-width*4., length(uv));\n    float mascara2 = smoothstep(R.y/2.+width*4., R.y/2.-width*4., sqrt(pow(uv.x, -2.) + pow(5.+uv.y, -1.0)));\n    \n    col = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d*width)*float(amount))+1.)/2.;\n    col2 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d2*width)*float(amount))+1.)/2.;\n    col3 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d3*width)*float(amount))+1.)/2.;\n    col = color1+col*(color2-color1);\n    col *= mascara2;\n    col2 = color23+col3*(color13-color23);\n    col2 *= mascara2;\n    col3 = color22+col3*(color12-color22);\n    col3 *= mascara2;\n    fragColor = vec4(col-col2-col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 165], [167, 167, 224, 224, 1517]], "test": "valid"}
{"id": "7ly3Wh", "name": "infinite mandelbrot zoom", "author": "peabrainiac", "description": "An infinite zoom into the mandelbrot set. Coloring sadly breaks after a while, but the fractal continues on forever.", "tags": ["mandelbrot", "zoom", "infinite"], "likes": 14, "viewed": 314, "published": "Public API", "date": "1637604839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// zoom locations. comment this one and uncomment one of the others to zoom somewhere else\n// needle\nconst vec2 MINIBROT_C = vec2(-1.98542425,0.0);\nconst vec2 MINIBROT_SCALE = vec2(5.81884941e-5,0.0);\nconst vec2 MINIBROT_A = vec2(-161.347726,0.0);\nconst float MINIBROT_PERIOD = 5.0;\n\n// seahorse valley 1\n/*const vec2 MINIBROT_C = vec2(-0.862612214,-0.274371722);\nconst vec2 MINIBROT_SCALE = vec2(-5.33653763e-6,-1.60082654e-5);\nconst vec2 MINIBROT_A = vec2(187.960106,92.5553918);\nconst float MINIBROT_PERIOD = 12.0;*/\n\n// seahorse valley 2\n/*const vec2 MINIBROT_C = vec2(-0.722551290,-0.260810603);\nconst vec2 MINIBROT_SCALE = vec2(1.73516282e-5,-6.24633482e-6);\nconst vec2 MINIBROT_A = vec2(157.460179,-16.4403340);\nconst float MINIBROT_PERIOD = 21.0;*/\n\n// elephant valley\n/*const vec2 MINIBROT_C = vec2(0.34462359,0.0564018310);\nconst vec2 MINIBROT_SCALE = vec2(-2.21366831e-6,8.05314001e-7);\nconst vec2 MINIBROT_A = vec2(-113.398177,231.589991);\nconst float MINIBROT_PERIOD = 17.0;*/\n\n// alternating whatever\n/*const vec2 MINIBROT_C = vec2(-0.162415772,-1.04133681);\nconst vec2 MINIBROT_SCALE = vec2(-1.07141152e-6,1.02473337e-6);\nconst vec2 MINIBROT_A = vec2(30.7304447,-1057.92453);\nconst float MINIBROT_PERIOD = 24.0;*/\n\nconst float MINIBROT_R = 8.0;\nconst float MINIBROT_R2 = 32.0;\n\nconst int ITER = 500;\nconst float BAILOUT = 32.0;\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\n// sort of a minimal example of an algorithm I've been working on for a while now.\n// this version only supports zooming into the same minibrot again and again, but\n// there's really nothing stopping one from changing the parameters for each minibrot,\n// and adjusting them automatically as one explores the fractal.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime*iTime/(iTime+1.0);\n    float s = -log(length(MINIBROT_SCALE));\n    int n = int(ceil(t/s));\n    float zoom = exp(-(t-s*float(n)));\n    float theta = float(n)*atan(MINIBROT_SCALE.y,MINIBROT_SCALE.x);\n    vec2 C = cmul(MINIBROT_C,cdiv(vec2(1.0,0.0),vec2(1.0,0.0)-MINIBROT_SCALE));\n    vec2 dc = vec2(cos(theta),-sin(theta))*10.0*zoom/length(iResolution);\n    vec2 c = C+cmul(dc,vec2(1.0,-1.0)*(fragCoord-iResolution.xy*0.5));\n    while (n>0&&dot(c-MINIBROT_C,c-MINIBROT_C)>MINIBROT_R2){\n        c = MINIBROT_C+cmul(c,MINIBROT_SCALE);\n        dc = cmul(dc,MINIBROT_SCALE);\n        n--;\n    }\n    \n    vec2 z = vec2(0.0);\n    vec2 dz = dc;\n    int i = 0;\n    float i2 = 0.0;\n    float escapeRadius = n==0?BAILOUT:MINIBROT_R;\n    while(i<ITER){\n        if (dot(z,z)>escapeRadius){\n            if (n==0){\n                break;\n            }else{\n                z = cdiv(z,MINIBROT_A);\n                dz = cdiv(dz,MINIBROT_A);\n                c = MINIBROT_C+cmul(c,MINIBROT_SCALE);\n                dc = cmul(dc,MINIBROT_SCALE);\n                n--;\n                i2 *= MINIBROT_PERIOD;\n                float escapeRadius = n==0?BAILOUT:MINIBROT_R;\n            }\n        }\n        dz = 2.0*cmul(dz,z)+dc;\n        z = cmul(z,z)+c;\n        i++;\n        i2++;\n    }\n    // mixture of distance estimation and logarithmic coloring. sadly, both break after a while.\n    float d = !(i<ITER)?0.0:sqrt(dot(z,z)/dot(dz,dz))*0.5*log(dot(z,z));\n    fragColor = vec4(vec3((1.0-d)*(0.5+0.5*cos(log(1.0+i2*2.0e-5)))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1344, 1344, 1370, 1370, 1426], [1428, 1428, 1454, 1454, 1519], [1521, 1838, 1892, 1892, 3418]], "test": "valid"}
{"id": "7lyGDz", "name": "FBM-Ridge", "author": "celns", "description": "FBM-Ridge", "tags": ["fbmridge"], "likes": 1, "viewed": 90, "published": "Public API", "date": "1637484790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Random(vec2 iuv)\n{\n    vec2 point = vec2(dot(iuv,vec2(123.45,678.90)),\n                    dot(iuv,vec2(234.56,345.67)));\n    return -1.0+2.0*fract(sin(point)*45678.7654321);\n}\n\n\n\nfloat PerlinNoise(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 cuv = ceil(uv);\n    vec2 fuv = fract(uv);\n    \n    float a = dot(Random(iuv),fuv);\n    float b = dot(Random(iuv + vec2(1.0,0.0)),fuv - vec2(1.0,0.0));\n    float c = dot(Random(iuv + vec2(0.0,1.0)),fuv - vec2(0.0,1.0));\n    float d = dot(Random(cuv),fuv - vec2(1.0,1.0));\n    \n    vec2 interuv = fuv*fuv*(3.0-2.0*fuv);\n    \n    return mix(mix(a,b,interuv.x),mix(c,d,interuv.x),interuv.y);\n    \n  \n}\n\nfloat FBM(vec2 uv)\n{\n    float fbm = 0.0;\n    float amp = 5.;\n    float offset = 1.0;\n    int epoch = 5;\n    \n    for(int i = 0; i < epoch; i++)\n    {\n        fbm += amp * abs(PerlinNoise(uv*0.3));\n        fbm = offset - fbm;\n        fbm = fbm*fbm;\n        uv *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return fbm;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 5.;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float value = FBM(tan(iTime) + uv);\n    \n    vec3 col = vec3((value));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 181], [185, 185, 213, 213, 646], [648, 648, 668, 668, 964], [967, 967, 1024, 1074, 1352]], "test": "valid"}
{"id": "7lyGRt", "name": "[TDF2021] Quake", "author": "soma_arc", "description": "For Tokyo Demo Fest 2021 GLSL Graphics Compo https://tokyodemofest.jp/", "tags": ["3d", "fractal"], "likes": 1, "viewed": 40, "published": "Public API", "date": "1638155013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2021\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nstruct Plane{\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    vec3 normal;\n};\n\n\nconst vec3 BLACK = vec3(0);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 LIGHT_POS = vec3(100, 100, 100);\nconst vec3 LIGHT_DIR = normalize(LIGHT_POS);\nconst float AMBIENT_FACTOR = 0.1;\n\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\nconst float RT_3 = sqrt(3.);\nconst float RT_3_INV = 1.0 / sqrt(3.);\n\nconst Plane PL1 = Plane(vec3(0, 5, RT_3_INV),\n                vec3(1, 1, 0),\n                vec3(2, 2, -RT_3_INV),\n                normalize(vec3(RT_3 * 0.5, 0, 1.5)));\n\nconst Plane PL2 = Plane(vec3(0, 3, -RT_3_INV),\n                        vec3(1, 3, 0),\n                        vec3(2, 2, RT_3_INV),\n                        normalize(vec3(RT_3 * 0.5, 0, -1.5)));\nconst Plane PL3 = Plane(\n    vec3(-0.5, 0, 1),\n    vec3(-0.5, 1, 0),\n    vec3(-0.5, 2, 1),\n    vec3(-1, 0, 0));\n\nvec4 s2, s4, s6;\nvec4 s2A, s4A, s6A;\nvec4 s2B, s4B, s6B;\nvec4 s2C, s4C, s6C;\nvec4 gSpheres0, gSpheres1, gSpheres2, gSpheres3, gSpheres4, gSpheres5;\nvec4 inversionSphere;\n\nvec3 vertexes0, vertexes1, vertexes2, vertexes3, vertexes4,vertexes5, vertexes6, vertexes7;\nPlane dividePlane;\nvec4 convexSphere;\n\nfloat gInvNum = 0.;\nfloat gBoundingPlaneY = -9999999999.;\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 Hsv2rgb(float h, float s, float v){\n    vec3 c = vec3(h, s, v);\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid computeCubeSphairahedronA(float zb, float zc) {\n    float r2 = 0.5 + (zb * zc) / 3.0;\n    float r4 = 0.5 + (zb * zb - zb * zc) / 3.0;\n    float r6 = 0.5 + (-zb * zc + zc * zc) / 3.0;\n    s2 = s2A = vec4(1. - r2, 0, 0, r2);\n    s4 = s4A = vec4(-(1. - r4) * 0.5, zb, sqrt(3.) * (1. - r4) * 0.5, r4);\n    s6 = s6A = vec4(-(1. - r6) * 0.5, zc, -sqrt(3.) * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\nvoid computeCubeSphairahedronB(float zb, float zc) {\n    float r2 = (3. * RT_3 + 2. * RT_3 * zb * zc) / 9.0;\n    float r4 = (3. * zb * zb - 4. * zb * zc + 3.) / 9.0;\n    float r6 = (3. * zc * zc - 2. * zb * zc + 6.) / 9.0;\n    s2 = s2B = vec4((2. - RT_3 * r2) * 0.5, 0, r2 * 0.5, r2);\n    s4 = s4B = vec4(-(1. - r4) * 0.5, zb, RT_3 * (1. - r4) * 0.5, r4);\n    s6 = s6B = vec4(-(1. - r6) * 0.5, zc, -RT_3 * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\nvoid computeCubeSphairahedronC(float zb, float zc) {\n    float r2 = (zb * zb + 2. * zb * zc + 6.) / (5. * RT_3);\n    float r4 = (3. * zb * zb - 4. * zb * zc + 3.) / (5. * RT_3);\n    float r6 = (-zb * zb - 2. * zb * zc + 5. * zc * zc + 9.) / 15.0;\n    s2 = s2C = vec4((2. - RT_3 * r2) * 0.5, 0, r2 * 0.5, r2);\n    s4 = s4C = vec4(-0.5, zb, RT_3 / 2. - r4, r4);\n    s6 = s6C = vec4(-(1. - r6) * 0.5, zc, -RT_3 * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\n\nfloat MAX_FLOAT = 1e20;\nconst float THRESHOLD = 0.001;\n\nbool intersectBoundingPlane(const vec3 n, const vec3 p,\n\t\t\t\t\t\t\tconst vec3 rayOrigin, const vec3 rayDir,\n\t\t\t\t\t\t\tinout float t0, inout float t1) {\n\tfloat d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(THRESHOLD < t){\n\t\tif(v < 0.) {\n\t\t\tt0 = max(t, t0);\n\t\t\tt1 = MAX_FLOAT;\n\t\t} else {\n\t\t\tt0 = t0;\n\t\t\tt1 = t;\n\t\t}\n\t\treturn true;\n    }\n    t0 = t0;\n    t1 = MAX_FLOAT;\n\treturn (v < 0.);\n}\n\n/*\nfloat[12] pivoting(float[12] mat, int n, int k){\n    int col = k;\n    float maxValue = abs(mat[k*4 + k]);\n    for (int i = k + 1; i < n; i++) {\n        if (abs(mat[i*4 + k]) > maxValue) {\n            col = i;\n            maxValue = abs(mat[i*4 + k]);\n        }\n    }\n    if (k != col) {\n        float tmp[4];\n        tmp[0] = mat[col*4 + 0];\n        tmp[1] = mat[col*4 + 1];\n        tmp[2] = mat[col*4 + 2];\n        tmp[3] = mat[col*4 + 3];\n        mat[col*4 + 0] = mat[k*4 + 0];\n        mat[col*4 + 1] = mat[k*4 + 1];\n        mat[col*4 + 2] = mat[k*4 + 2];\n        mat[col*4 + 3] = mat[k*4 + 3];\n        mat[k*4 + 0] = tmp[0];\n        mat[k*4 + 1] = tmp[1];\n        mat[k*4 + 2] = tmp[2];\n        mat[k*4 + 3] = tmp[3];\n    }\n    return mat;\n}\n*/\n\nvec4 sphereFromPoints(vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n    /*\n    float coefficient[12];\n    for (int i = 0; i < 3; i++) {\n        coefficient[i * 4 + 0] = 2. * (p[i + 1].x - p[i].x);\n        coefficient[i * 4 + 1] = 2. * (p[i + 1].y - p[i].y);\n        coefficient[i * 4 + 2] = 2. * (p[i + 1].z - p[i].z);\n        coefficient[i * 4 + 3] = -(pow(p[i].x, 2.) + pow(p[i].y, 2.) + pow(p[i].z, 2.)) +\n                pow(p[i + 1].x, 2.) + pow(p[i + 1].y, 2.) + pow(p[i + 1].z, 2.);\n    }\n    */\n    float coefficient0, coefficient1, coefficient2, coefficient3, coefficient4;\n    float coefficient5, coefficient6, coefficient7, coefficient8, coefficient9;\n    float coefficient10, coefficient11;\n    coefficient0 = 2. * (p1.x - p0.x);\n    coefficient1 = 2. * (p1.y - p0.y);\n    coefficient2 = 2. * (p1.z - p0.z);\n    coefficient3 = -(pow(p0.x, 2.) + pow(p0.y, 2.) + pow(p0.z, 2.)) +\n                     pow(p1.x, 2.) + pow(p1.y, 2.) + pow(p1.z, 2.);\n    coefficient4 = 2. * (p2.x - p1.x);\n    coefficient5 = 2. * (p2.y - p1.y);\n    coefficient6 = 2. * (p2.z - p1.z);\n    coefficient7 = -(pow(p1.x, 2.) + pow(p1.y, 2.) + pow(p1.z, 2.)) +\n                     pow(p2.x, 2.) + pow(p2.y, 2.) + pow(p2.z, 2.);\n    coefficient8 = 2. * (p3.x - p2.x);\n    coefficient9 = 2. * (p3.y - p2.y);\n    coefficient10 = 2. * (p3.z - p2.z);\n    coefficient11 = -(pow(p2.x, 2.) + pow(p2.y, 2.) + pow(p2.z, 2.)) +\n                      pow(p3.x, 2.) + pow(p3.y, 2.) + pow(p3.z, 2.);\n    \n    /*\n    const int n = 3;\n    for (int k = 0; k < n - 1; k++) {\n        coefficient = pivoting(coefficient, n, k);\n\n        float vkk = coefficient[k * 4 + k];\n        for (int i = k + 1; i < n; i++) {\n            float vik = coefficient[i * 4 + k];\n            for (int j = k; j < n + 1; ++j) {\n                coefficient[i * 4 + j] = coefficient[i*4 + j] - vik * (coefficient[k * 4 + j] / vkk);\n            }\n        }\n    }\n    \n    coefficient[(n - 1) * 4 + n] = coefficient[(n - 1) * 4 + n] / coefficient[(n - 1) * 4 + n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        float acc = 0.0;\n        for (int j = i + 1; j < n; j++) {\n            acc += coefficient[i * 4 + j] * coefficient[j * 4 + n];\n        }\n        coefficient[i * 4 + n] = (coefficient[i * 4 + n] - acc) / coefficient[i * 4 + i];\n    }\n    */\n        //coefficient = pivoting(coefficient, 3, 0);\n    int col = 0;\n    float maxValue = abs(coefficient0);\n    if (abs(coefficient4) > maxValue) {\n        col = 1;\n        maxValue = abs(coefficient4);\n    }\n    if (abs(coefficient8) > maxValue) {\n        col = 2;\n        maxValue = abs(coefficient8);\n    }\n    \n    if (col == 1) {\n        float tmp0 = coefficient4;\n        float tmp1 = coefficient5;\n        float tmp2 = coefficient6;\n        float tmp3 = coefficient7;\n        coefficient4 = coefficient0;\n        coefficient5 = coefficient1;\n        coefficient6 = coefficient2;\n        coefficient7 = coefficient3;\n        coefficient0 = tmp0;\n        coefficient1 = tmp1;\n        coefficient2 = tmp2;\n        coefficient3 = tmp3;\n    }\n    \n    if (col == 2) {\n        float tmp0 = coefficient8;\n        float tmp1 = coefficient9;\n        float tmp2 = coefficient10;\n        float tmp3 = coefficient11;\n        coefficient8 = coefficient0;\n        coefficient9 = coefficient1;\n        coefficient10 = coefficient2;\n        coefficient11 = coefficient3;\n        coefficient0 = tmp0;\n        coefficient1 = tmp1;\n        coefficient2 = tmp2;\n        coefficient3 = tmp3;\n    }\n\n    \n        float vkk = coefficient0;\n        float vik = coefficient4;    \n        coefficient4 = coefficient4 - vik * (coefficient0 / vkk);\n        coefficient5 = coefficient5 - vik * (coefficient1 / vkk);\n        coefficient6 = coefficient6 - vik * (coefficient2 / vkk);\n        coefficient7 = coefficient7 - vik * (coefficient3 / vkk);\n    \n        vik = coefficient8;            \n        coefficient8 = coefficient8 - vik * (coefficient0 / vkk);\n        coefficient9 = coefficient9 - vik * (coefficient1 / vkk);\n        coefficient10 = coefficient10 - vik * (coefficient2 / vkk);\n        coefficient11 = coefficient11 - vik * (coefficient3 / vkk);\n\n        \n        //coefficient = pivoting(coefficient, 3, 1);\n    col = 1;\n    maxValue = abs(coefficient5);\n    \n        if (abs(coefficient9) > maxValue) {\n            col = 2;\n            maxValue = abs(coefficient9);\n        }\n    \n    if (col == 2) {\n        float tmp0 = coefficient8;\n        float tmp1 = coefficient9;\n        float tmp2 = coefficient10;\n        float tmp3 = coefficient11;\n        coefficient8 = coefficient4;\n        coefficient9 = coefficient5;\n        coefficient10 = coefficient6;\n        coefficient11 = coefficient7;\n        coefficient4 = tmp0;\n        coefficient5 = tmp1;\n        coefficient6 = tmp2;\n        coefficient7 = tmp3;\n    }\n\n        vkk = coefficient5;\n        vik = coefficient9;\n            \n        coefficient9 = coefficient9 - vik * (coefficient5 / vkk);\n        coefficient10 = coefficient10 - vik * (coefficient6 / vkk);\n        coefficient11 = coefficient11 - vik * (coefficient7 / vkk);\n\n\n    \n    coefficient11 = coefficient11 / coefficient10;\n\n    float acc = 0.0;\n    acc += coefficient6 * coefficient11;\n        \n    coefficient7 = (coefficient7 - acc) / coefficient5;\n        \n    acc = 0.0;\n    acc += coefficient1 * coefficient7;\n    acc += coefficient2 * coefficient11;\n\n    coefficient3 = (coefficient3 - acc) / coefficient0;\n    \n    //vec3 center = vec3(coefficient[0 * 4 + 3], coefficient[1 * 4 + 3], coefficient[2 * 4 + 3]);\n    vec3 center = vec3(coefficient3, coefficient7, coefficient11);\n    float r = length(center - p0);\n    return vec4(center, r);\n}\n\nvec3 invertOnPoint(vec4 sphere, vec3 p) {\n    vec3 d = p - sphere.xyz;\n    float len = length(d);\n    return d * (sphere.r * sphere.r / (len * len)) + sphere.xyz;\n}\n\nvec4 invertOnSphere(vec4 invSphere, vec4 s) {\n    float r = s.w;\n    float coeffR = r * RT_3 / 3.;\n    vec3 p1 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, coeffR, coeffR));\n    vec3 p2 = invertOnPoint(invSphere, s.xyz + vec3(-coeffR, -coeffR, -coeffR));\n    vec3 p3 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, -coeffR, -coeffR));\n    vec3 p4 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, coeffR, -coeffR));\n    return sphereFromPoints(p1, p2, p3, p4);\n}\n\nvec4 invertOnPlane(vec4 invSphere, Plane p) {\n    return sphereFromPoints(invertOnPoint(invSphere, p.p1),\n                            invertOnPoint(invSphere, p.p2),\n                            invertOnPoint(invSphere, p.p3),\n                            invSphere.xyz);\n}\n\nvoid computeGSpheres(){\n    gSpheres0 = invertOnPlane(inversionSphere, PL1);\n    gSpheres1 = invertOnSphere(inversionSphere, s2);\n    gSpheres2 = invertOnPlane(inversionSphere, PL2);\n    gSpheres3 = invertOnSphere(inversionSphere, s4);\n    gSpheres4 = invertOnPlane(inversionSphere, PL3);\n    gSpheres5 = invertOnSphere(inversionSphere, s6);\n    \n}\n\nvec3 computeVertex(vec4 a, vec4 b, vec4 c) {\n    float AB = (dot(a.xyz, a.xyz) - dot(b.xyz, b.xyz) - a.w * a.w + b.w * b.w) * 0.5 -\n               dot(a.xyz, a.xyz) + dot(a.xyz, b.xyz);\n    float AC = (dot(a.xyz, a.xyz) - dot(c.xyz, c.xyz) - a.w * a.w + c.w * c.w) * 0.5 -\n               dot(a.xyz, a.xyz) + dot(a.xyz, c.xyz);\n    float x = -dot(a.xyz, a.xyz) - dot(b.xyz, b.xyz) + 2. * dot(a.xyz, b.xyz);\n    float y = -dot(a.xyz, a.xyz) - dot(c.xyz, c.xyz) + 2. * dot(a.xyz, c.xyz);\n    float z = -dot(a.xyz, a.xyz) + dot(a.xyz, b.xyz) +\n               dot(a.xyz, c.xyz) - dot(b.xyz, c.xyz);\n    float s = (AB * y - AC * z) / (x * y - z * z);\n    float t = (AC * x - AB * z) / (x * y - z * z);\n    return a.xyz + (b.xyz - a.xyz) * s + (c.xyz - a.xyz) * t;\n}\n\n\n/*\n0, 1, 2, \n0, 3, 4, \n2, 4, 5,\n0, 1, 3,\n3, 4, 5,\n1, 2, 5,\n1, 3, 5,\n0, 2, 4\n*/\nvoid computeVertexes(){\n    vertexes0 = computeVertex(gSpheres0,\n                                gSpheres1,\n                                gSpheres2);\n    vertexes1 = computeVertex(gSpheres0,\n                                gSpheres3,\n                                gSpheres4);\n    vertexes2 = computeVertex(gSpheres2,\n                                gSpheres4,\n                                gSpheres5);\n    vertexes3 = computeVertex(gSpheres0,\n                                gSpheres1,\n                                gSpheres3);\n    vertexes4 = computeVertex(gSpheres3,\n                                gSpheres4,\n                                gSpheres5);\n    vertexes5 = computeVertex(gSpheres1,\n                                gSpheres2,\n                                gSpheres5);\n    vertexes6 = computeVertex(gSpheres1,\n                                gSpheres3,\n                                gSpheres5);\n    vertexes7 = computeVertex(gSpheres0,\n                                gSpheres2,\n                                gSpheres4);\n    /*\n    for(int i = 0; i < 8; i++) {\n        vertexes[i] = computeVertex(gSpheres[index[i*3 + 0]],\n                                    gSpheres[index[i*3 + 1]],\n                                    gSpheres[index[i*3 + 2]]);\n    }\n    */\n}\n\nPlane computePlane() {\n        vec3 p1 = invertOnPoint(inversionSphere, vertexes0);\n        vec3 p2 = invertOnPoint(inversionSphere, vertexes1);\n        vec3 p3 = invertOnPoint(inversionSphere, vertexes2);\n\n        vec3 v1 = p2 - p1;\n        vec3 v2 = p3 - p1;\n        vec3 normal = normalize(cross(v1, v2));\n        if (normal.y < 0.) {\n            normal = normal * -1.;\n        }\n        Plane p = Plane(p1, p2, p3, normal);\n        \n        return p;\n}\n\nvec4 computeConvexSphere(){\n    return invertOnPlane(inversionSphere, dividePlane);\n}\n\n// p: center of the plane\n// n: normal of the plane\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir,\n                     inout float minDist,\n                    inout vec3 intersection, inout vec3 normal){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < minDist){\n\t\tintersection = rayOrigin + t * rayDir;\n        normal = n;\n        minDist = t;\n        return true;\n    }\n    return false;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\nfloat distPlane(vec3 pos, vec3 p, vec3 n) {\n    return dot(pos - p, n);\n}\n\nfloat distPrism(const vec3 pos) {\n    float d = -1.;\n\td = max(distPlane(pos, PL1.p1,\n\t\t\t\t\t  PL1.normal),\n\t\t\td);\n    d = max(distPlane(pos, PL2.p1,\n\t\t\t\t\t  PL2.normal),\n\t\t\td);\n    d = max(distPlane(pos, PL3.p1,\n\t\t\t\t\t  PL3.normal),\n\t\t\td);\n    return d;\n}\n\nfloat distInfSphairahedra(const vec3 pos) {\n    float d = distPrism(pos);\n    d = max(distPlane(pos, dividePlane.p1,\n                           dividePlane.normal),\n            d);\n\td = max(-distSphere(pos, s2),\n\t\t\td);\n    d = max(-distSphere(pos, s4),\n\t\t\td);\n    d = max(-distSphere(pos, s6),\n\t\t\td);\n    return d;\n}\n\nvoid SphereInvert(inout vec3 pos, inout float dr, vec4 s) {\n    vec3 diff = pos - s.xyz;\n    float lenSq = dot(diff, diff);\n    float k = (s.w * s.w) / lenSq;\n    dr *= k; // (r * r) / lenSq\n    pos = (diff * k) + s.xyz;\n}\n\nfloat distLimitSetTerrain(vec3 pos, out float invNum) {\n    float dr = 1.;\n    invNum = 0.;\n\n    float d;\n    for(int i = 0; i < 200; i++) {\n        if(25 <= i) break;\n        bool inFund = true;\n\t\tif(distance(pos, s2.xyz) < s2.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s2);\n\t\t\tinFund = false;\n\t\t}\n        if(distance(pos, s4.xyz) < s4.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s4);\n\t\t\tinFund = false;\n\t\t}\n        if(distance(pos, s6.xyz) < s6.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s6);\n\t\t\tinFund = false;\n\t\t}\n\n\t\tpos -= PL1.p1;\n\t\td = dot(pos, PL1.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL1.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL1.p1;\n        \n        pos -= PL2.p1;\n\t\td = dot(pos, PL2.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL2.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL2.p1;\n        \n        pos -= PL3.p1;\n\t\td = dot(pos, PL3.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL3.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL3.p1;\n\n        if(inFund) break;\n    }\n    return distInfSphairahedra(pos) / abs(dr) * 0.1;\n}\n\nvec2 distFunc(vec3 p) {\n\tvec2 d = vec2(distLimitSetTerrain(p, gInvNum), 1);\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.001, 0.);\nvec3 computeNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                        distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                        distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCH = 300;\nint march (vec3 rayOrg, vec3 rayDir, inout float minDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec2 dist = vec2(-1);\n    float rayLength = minDist;\n    vec3 rayPos = rayOrg + rayDir * rayLength;\n\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 getMatColor(int objId, vec3 normal, vec3 intersection, float t){\n    if(objId == 1){\n        vec3 col = Hsv2rgb((1., -0.01 + (gInvNum) * 0.02), 1., 1.);;\n        return col; \n    }\n\treturn BLACK;\n}\n\nvec3 sky(vec3 rayDir){\n\treturn clamp(vec3(.7, .8, 1.) + exp(dot(rayDir, LIGHT_DIR))*0.1, 0.0, 1.0);\n}\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    float t = mint;\n    for(int n = 0; n < 1000; n++){\n        if(t > maxt) break;\n        float d = distFunc(rayOrg + rayDir * t).x;\n        if(d < 0.0001) return 0.;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(clamp(dot(reflect(e,n),l),0.0, 1.),s);\n}\n\nconst float FOG_START = 5.;\nconst float FOG_END = 100.;\nconst float FOG_END_START_RECIPROCAL = 1. / (FOG_END - FOG_START);\nconst vec3 FOG_F = vec3(1.);\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n\n    float tmin = 0.;\n    float t = 9999999.;\n    const int maxLoop = 10;\n    \tvec3 intersection, normal;\n    \tbool isect;\n    \tint objId = -1;\n        \n        \n    bool hit = intersectBoundingPlane(vec3(0, 1, 0), vec3(0, gBoundingPlaneY, 0),\n                                 eye, ray,\n                                 tmin, t);\n    if(hit && tmin < 30.) {\n        objId = march(eye, ray, tmin,\n                      intersection, normal);\n        if(objId != -1){\n            vec3 matColor = getMatColor(objId, normal, intersection, t);\n            float k = computeShadowFactor(intersection + 0.0001 * normal,\n                                         LIGHT_DIR,\n                                         0.001, 5., 100.);\n            vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n            vec3 ambient = matColor * AMBIENT_FACTOR;\n    \t\tl += k * diffuse + ambient;\n            \n            l = mix(FOG_F, l, clamp((FOG_END - tmin) * FOG_END_START_RECIPROCAL, 0.1, 1.0));\n        }\n                      \n    } else {\n        l = mix( sky(ray), l, exp( -0.000000009*t * t ) );\n    }\n    \n  \treturn l;\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;\n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nfloat circEasingOut(float t){\n    return sqrt(1. - pow(t - 1., 2.));\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nconst vec3 target = vec3(0, 0, 0);\nvec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 31.);\n    \n    float rad = mix(0.0001, 1.0, circEasingInOut(scene(t, 1.0, 15.)));\n    float rotationT = mix(0., 50., (scene(t, 0., 15.)));\n    if(t < 21.) {\n        \n        float tb = rad * cos(rotationT);\n        float tc = rad * sin(rotationT);\n        tb = mix(tb, 0., circEasingInOut(scene(t, 15., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 15., 1.)));\n        \n        tb = mix(tb, 1.2224464245160123, circEasingInOut(scene(t, 16., 1.)));\n        tc = mix(tc, 0.612090457867328, circEasingInOut(scene(t, 16., 1.)));\n        \n        tb = mix(tb, -0.8661174154839888, circEasingInOut(scene(t, 17., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 17., 1.)));\n        \n        tb = mix(tb, 0.61096041060052, circEasingInOut(scene(t, 18., 1.)));\n        tc = mix(tc, -0.6110480831254523, circEasingInOut(scene(t, 18., 1.)));\n        \n        tb = mix(tb, -0.6144427845492827, circEasingInOut(scene(t, 19., 1.)));\n        tc = mix(tc, 0.6155169219301033, circEasingInOut(scene(t, 19., 1.)));\n        \n        tb = mix(tb, -0.6492253932449349, circEasingInOut(scene(t, 20., 1.)));\n        tc = mix(tc, -1.1670917737220714, circEasingInOut(scene(t, 20., 1.)));\n        \n        computeCubeSphairahedronA(tb, tc);\n    } else if(t < 22.) {\n        computeCubeSphairahedronA(-0.6492253932449349, -1.1670917737220714);\n        computeCubeSphairahedronB(-1.4263771231354925, -0.4114778978502866);\n        s2 = mix(s2A, s2B, circEasingInOut(scene(t, 21., 1.)));\n        s4 = mix(s4A, s4B, circEasingInOut(scene(t, 21., 1.)));\n        s6 = mix(s6A, s6B, circEasingInOut(scene(t, 21., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n    } else if(t < 26.){\n        float tb = -1.4263771231354925;\n        float tc = -0.4114778978502866;\n        tb = mix(tb, 0.9480876782578194, circEasingInOut(scene(t, 22., 1.)));\n        tc = mix(tc, -0.27487295833102093, circEasingInOut(scene(t, 22., 1.)));\n        \n        tb = mix(tb, -0.7341647058410344, circEasingInOut(scene(t, 23., 1.)));\n        tc = mix(tc, -0.8016177852310659, circEasingInOut(scene(t, 23., 1.)));\n        \n        tb = mix(tb, -1.1021579831206387, circEasingInOut(scene(t, 24., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 24., 1.)));\n        \n        tb = mix(tb, 0.7341944231647511, circEasingInOut(scene(t, 25., 1.)));\n        tc = mix(tc, 0.8010951070853616, circEasingInOut(scene(t, 25., 1.)));\n        computeCubeSphairahedronB(tb, tc);\n    } else if(t < 27.){\n        computeCubeSphairahedronB(0.7341944231647511, 0.8010951070853616);\n        computeCubeSphairahedronC(0.80897179163727, -0.6172090398213005);\n        s2 = mix(s2B, s2C, circEasingInOut(scene(t, 26., 1.)));\n        s4 = mix(s4B, s4C, circEasingInOut(scene(t, 26., 1.)));\n        s6 = mix(s6B, s6C, circEasingInOut(scene(t, 26., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n\n    } else if(t < 30.){\n        float tb = 0.80897179163727;\n        float tc = -0.6172090398213005;\n        tb = mix(tb, -1.0724597039839807, circEasingInOut(scene(t, 27., 1.)));\n        tc = mix(tc, 0.10239062161550339, circEasingInOut(scene(t, 27., 1.)));\n        \n        tb = mix(tb, -0.4626628191468804, circEasingInOut(scene(t, 28., 1.)));\n        tc = mix(tc, -0.7985798919860417, circEasingInOut(scene(t, 28., 1.)));\n        \n        tb = mix(tb, 1.0842163989231046, circEasingInOut(scene(t, 29., 1.)));\n        tc = mix(tc, -0.09944669059450531, circEasingInOut(scene(t, 29., 1.)));\n        \n        computeCubeSphairahedronC(tb, tc);\n    } else {\n        computeCubeSphairahedronC(1.0842163989231046, -0.09944669059450531);\n        computeCubeSphairahedronA(0., 0.);\n        s2 = mix(s2C, s2A, circEasingInOut(scene(t, 30., 1.)));\n        s4 = mix(s4C, s4A, circEasingInOut(scene(t, 30., 1.)));\n        s6 = mix(s6C, s6A, circEasingInOut(scene(t, 30., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n    }\n\n    computeGSpheres();\n    computeVertexes();\n    dividePlane = computePlane();\n    convexSphere = computeConvexSphere();\n    gBoundingPlaneY = max(gBoundingPlaneY, s2.y + .01);\n    gBoundingPlaneY = max(gBoundingPlaneY, s4.y + .01);\n    gBoundingPlaneY = max(gBoundingPlaneY, s6.y + .01);\n    vec3 eye = vec3(2. , 2., 2. );\n    eye = mix(eye, vec3(-2, 2, 2), circEasingInOut(scene(t, 15.0, 1.)));\n    eye = mix(eye, vec3(-2, 2, -2), circEasingInOut(scene(t, 20.0, 1.)));\n    eye = mix(eye, vec3(2, 2, -2), circEasingInOut(scene(t, 25.0, 1.)));\n    eye = mix(eye, vec3(2, 2, 2), circEasingInOut(scene(t, 30.0, 1.)));\n    \n    vec3 sum = vec3(0);\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n        \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGRt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[130, 219, 260, 260, 541], [1849, 1849, 1878, 1878, 2055], [2057, 2057, 2097, 2097, 2300], [2303, 2303, 2355, 2355, 2737], [2739, 2739, 2791, 2791, 3222], [3224, 3224, 3276, 3276, 3711], [3770, 3770, 3914, 3914, 4200], [4954, 4954, 5012, 5447, 10609], [10611, 10611, 10652, 10652, 10775], [10777, 10777, 10822, 10822, 11240], [11242, 11242, 11287, 11287, 11513], [11515, 11515, 11538, 11538, 11863], [11865, 11865, 11909, 11909, 12624], [12627, 12706, 12729, 12729, 13995], [13997, 13997, 14019, 14019, 14453], [14455, 14455, 14482, 14482, 14540], [14542, 14594, 14786, 14786, 15051], [15053, 15053, 15085, 15085, 15120], [15122, 15122, 15160, 15160, 15206], [15208, 15208, 15251, 15251, 15281], [15283, 15283, 15316, 15316, 15534], [15536, 15536, 15579, 15579, 15852], [15854, 15854, 15913, 15913, 16076], [16078, 16078, 16133, 16133, 17220], [17222, 17222, 17245, 17245, 17313], [17358, 17358, 17391, 17391, 17674], [17703, 17703, 17817, 17817, 18316], [18318, 18318, 18470, 18470, 18830], [18881, 18881, 18908, 18908, 19022], [19025, 19025, 19094, 19094, 19227], [19229, 19229, 19251, 19251, 19330], [19332, 19332, 19446, 19446, 19764], [19767, 19767, 19813, 19813, 19873], [20027, 20027, 20074, 20074, 21220], [21222, 21252, 21300, 21300, 21339], [21341, 21341, 21368, 21368, 21408], [21410, 21410, 21438, 21438, 21474], [21476, 21476, 21505, 21505, 21546], [21548, 21548, 21579, 21579, 21686], [21804, 21804, 21860, 21860, 26840]], "test": "error"}
{"id": "7lyGW1", "name": "eindacor_perlin", "author": "Eindacor_DS", "description": "it's perlin noise, you dolt!", "tags": ["perlin"], "likes": 0, "viewed": 82, "published": "Public API", "date": "1637594966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GRID_DIMENSION .1f\n#define AA .02f\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n#define PI 3.1415926\n#define DEBUG false\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    if (seed < .25) {\n        return vec2(1., 1.);\n    } else if (seed < .5) {\n        return vec2(-1., 1.);\n    } else if (seed < .75) {\n        return vec2(1., -1.);\n    } else {\n        return vec2(-1., -1.);\n    }\n}\n\nfloat getNonPeriodic(float seed) {\n    return (sin(2. * seed) + sin(PI * seed)+ 2.) / 4.;\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nvec3 getColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorIncrement =.25;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= .25) {\n        return mix(PINK * .5, ORANGE, lerpVal);\n    } else if (seed <= .5) {\n        return mix(ORANGE, PINK * .8, lerpVal);\n    } else if (seed <= .75) {\n        return mix(PINK * .8, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, WHITE, lerpVal);\n    } \n}\n\nvec3 getMixedColor(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorIncrement = .2;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= .2) {\n        return color0;\n    } else if (seed <= .4) {\n        return mix(color0, color1, lerpVal);\n    } else if (seed <= .6) {\n        return mix(color1, color2, lerpVal);\n    } else if (seed <= .8) {\n        return mix(color2, color3, lerpVal);\n    } else {\n        return color3;\n    }\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nfloat getPerlinValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float dot0 = dot((uv - p0) / gridDimension, getRandomVector(p0Hash));\n    float dot1 = dot((uv - p1) / gridDimension, getRandomVector(p1Hash));\n    float dot2 = dot((uv - p2) / gridDimension, getRandomVector(p2Hash));\n    float dot3 = dot((uv - p3) / gridDimension, getRandomVector(p3Hash));\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n    \n    // normalizes the perlin value, but inhibits additive perlin functionality upstream\n    //val = (val + 1.) / 2.;\n    \n    if (DEBUG) {\n        float distp0 = distance(p0, uv);\n        \n        float debugDotRadius = .005;\n        float debugAA = debugDotRadius * .5;\n        \n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p0, uv));\n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p1, uv));\n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p2, uv));\n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p3, uv));\n    }\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    float timeScale = .2f;\n    \n    uv.x += iTime * timeScale;\n    \n    uv.y += getNonPeriodic(uv.x) * .8;\n    \n    float gridDimension = .1f;\n    \n    float perlinValue = getPerlinValue(uv, gridDimension);\n    \n    perlinValue += getPerlinValue(uv + vec2(sin(iTime * .1f)), gridDimension * 10.f);\n    perlinValue += getPerlinValue(uv + vec2(sin(iTime * .1f)), gridDimension * .8f);\n    perlinValue += getPerlinValue(uv + vec2(cos(iTime * .3f)), gridDimension * 2.f);\n    perlinValue += getPerlinValue(uv + vec2(cos(iTime * .2)), gridDimension * .33f);\n    perlinValue += getPerlinValue(uv - vec2(iTime * .02f, -iTime * .02f), gridDimension * .5f);\n    \n    float clampedPerlin = clamp(perlinValue, 0., 1.);\n    \n    fragColor = vec4(getColor(clampedPerlin) * mix(PINK, WHITE, .5), 1.0);\n    fragColor = vec4(getMixedColor(GREEN * .8, BLUE, CYAN, WHITE, clampedPerlin) * mix(YELLOW, WHITE, .5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 429, 449, 449, 515], [517, 517, 551, 551, 771], [773, 773, 807, 807, 864], [866, 866, 899, 899, 1655], [1657, 1657, 1684, 1684, 2188], [2190, 2190, 2274, 2274, 2795], [2797, 2797, 2877, 2877, 2997], [2999, 2999, 3051, 3051, 4885], [4887, 4887, 4944, 4944, 5940]], "test": "valid"}
{"id": "7sKXzG", "name": "Waves Morph (06)", "author": "spenceryonce", "description": "Time to switch it up a bit, let's try something a bit different here :)", "tags": ["waves", "math", "sin", "color", "cos", "trippy", "weird", "morphing"], "likes": 4, "viewed": 56, "published": "Public", "date": "1635794291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int AMOUNT = 10;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 20.0 * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    float len;\n    \n    for(int i = 0; i < AMOUNT; i++){\n        len = length(vec2(coord.x, coord.y))*sin(3.0) / cos(3.14159265358);\n        \n        coord.x = coord.x - cos(coord.y + sin(len)) + cos(iTime / 12.0);\n        coord.y = coord.y + sin(coord.x + cos(len)) + sin(iTime / 9.0);\n    }\n    \n    fragColor = vec4(cos(len * 1.1), cos(len * 1.05), cos(len * 1.01), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 562]], "test": "valid"}
{"id": "7sSGDV", "name": "Alien terrain", "author": "z0rg", "description": "A simple lil shader :)", "tags": ["3d", "terrain", "landscape", "alien"], "likes": 8, "viewed": 162, "published": "Public API", "date": "1637744412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x,l.y),l.z);\n}\n\nfloat map(vec3 p)\n{\n    float limits = _cube(p,vec3(3.,1.,3.));\n    p.xz *= r2d(iTime*.01);\n    p.xz += vec2(0., iTime);\n    p.xz*=.5;\n\n    float land = -p.y + .5-(\n    texture(iChannel0, p.xz*.01).x\n    -asin(sin(p.x*10.*sin(p.z*2.)))*.05\n    -sin(p.z*7.+p.x*2.)*.2\n    -sin(p.z*10.+p.x*20.)*.05\n    -sin(p.z*50.+p.x*2.+length(p))*.02)*1.25\n    ;\n    return max(land, limits);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    \n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        float d = map(p);\n        if (d < 0.01)\n            return vec2(d, distance(ro, p));\n        p+= rd*d*.5;\n    }\n    return vec2(-1.);\n}\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.01,0.);\n    return -normalize(vec3(d)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)));\n}\n\nvec3 gradient(float f)\n{\n    //return vec3(1.)*sat((sin(f*100.)-.9)*10.);\n    float stp = 0.025;\n    vec3 col;\n    col = mix(vec3(0.996,0.663,0.086), vec3(0.847,0.133,0.788), f);\n    col = floor(col/stp)*stp;\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = 1.-gradient(sat((uv.y+.5)*1.));\n    float dist = 10.;\n    vec3 ro = vec3(dist, -dist, -dist);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec2 res = trace(ro, rd, 64);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNormal(res.x, p);//normalize(cross(dFdx(p), dFdy(p)));\n        vec3 lpos = vec3(15.);\n        vec3 ldir = lpos-p;\n        vec3 rgb = gradient(p.y);\n        \n        col = rgb;//*sat(dot(normalize(rd+ldir), n));\n        if (dot(n, vec3(0.,1.,0.)) > 0.01)\n        col -= sat((sin(p.y*25.)-.975)*50.);\n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    { // Not so cheap antialiasing SSAA x4\n\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot);\n        acc += rdr(uv-off.xy*rot);\n        acc += rdr(uv-off.yy*rot);\n        acc += rdr(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    col = col.yxz;\n    col = pow(col, vec3(1.45));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGDV.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[429, 429, 448, 448, 502], [503, 503, 532, 532, 591], [593, 593, 612, 612, 972], [974, 974, 1005, 1005, 1167], [1169, 1169, 1210, 1210, 1413], [1414, 1414, 1447, 1447, 1554], [1556, 1556, 1580, 1629, 1782], [1784, 1784, 1803, 1803, 2437], [2441, 2441, 2498, 2498, 3118]], "test": "error"}
{"id": "7t3GRB", "name": "sidewinder maze", "author": "e000", "description": "modified sidewinder", "tags": ["maze"], "likes": 3, "viewed": 41, "published": "Public", "date": "1636257236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 6\n#define MAX_RUN_SIZE 7\n#define MIN_RUN_SIZE 1\n#define SUBDIVIDE_PROB 0.5\n#define TILE_SIZE 80\n\n// Random number in [0, 1)\nfloat rand(int seed)\n{\n    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n    int mod = 134456;\n    int a = 8121;\n    int c = 28411;\n    int x = seed;\n    for (int i = 0; i < 5; ++i)\n    {\n        x = (a * x + c) % mod;\n    }\n    return float(x) / float(mod);\n}\n\n// Random number in [0, n)\nint randn(int seed, int n)\n{\n    return int(rand(seed) * float(n));\n}\n\n// Find the run that the given row, col is contained in.\n// Output left, right column boundary of the run.\nvoid findRunBounds(int row, int col, out int outLeft, out int outRight)\n{\n    int left = 0;\n    int right = TILE_SIZE - 1;\n\n    while (true)\n    {\n        if (col >= left && col <= right)\n        {\n            int size = 1 + right - left;\n            if (size <= MIN_RUN_SIZE)\n            {\n                outLeft = left;\n                outRight = right;\n                return;\n            }\n            else if (size <= MAX_RUN_SIZE)\n            {\n                int seed = (randn(row, TILE_SIZE) + 1) + (left + right * TILE_SIZE);\n                if (rand(seed) > SUBDIVIDE_PROB)\n                {\n                    outLeft = left;\n                    outRight = right;\n                    return;\n                }\n            }\n        }\n\n        int middle = (left + right) / 2;\n        if (col <= middle)\n        {\n            right = middle;\n        }\n        else\n        {\n            left = middle + 1;\n        }\n    }\n}\n\n// https://www.shadertoy.com/new\nvec3 rainbowColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    return 0.5 + 0.5 * cos(iTime+uv.xyx + vec3(0, 2, 4));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int ix = int(fragCoord.x) / SCALE;\n    int iy = int(fragCoord.y) / SCALE;\n\n    bool isOpen = false;\n    if (ix % 2 == 0 && iy % 2 == 0)\n    {\n        isOpen = true;\n    }\n    else if (ix % 2 != 1 || iy % 2 != 1)\n    {\n        int row = (iy / 2) % TILE_SIZE;\n        int colOffset = randn(row, TILE_SIZE); // add a random offset to prevent rows from aligning\n        int col = (ix / 2 + colOffset) % TILE_SIZE;\n\n        int left;\n        int right;\n        findRunBounds(row, col, left, right);\n\n        if (iy % 2 == 1) {\n            // detect escape from run\n            int runSize = 1 + right - left;\n            int escapeIndex = randn(row * left, runSize);\n            if (col % runSize == escapeIndex) {\n                isOpen = true;\n            }\n        } else if (col != right) {\n            isOpen = true;  // open unless hit end of run\n        }\n    }\n\n    fragColor = vec4(\n        isOpen ? rainbowColor(fragCoord) : vec3(0., 0., 0.),\n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3GRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 138, 160, 227, 415], [417, 444, 472, 472, 513], [515, 622, 695, 695, 1558], [1560, 1593, 1628, 1628, 1730], [1732, 1732, 1787, 1787, 2759]], "test": "valid"}
{"id": "7tcGWB", "name": "Hyper Dough", "author": "Tater", "description": "experimenting with some complicated diffuse lighting. ", "tags": ["3d", "raymarch", "glow", "halfprism"], "likes": 51, "viewed": 3461, "published": "Public API", "date": "1637429335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//very inspired by this work from halfprism\n//https://twitter.com/halfprism_/status/1434909264951263243\n\n#define STEPS 200.0\n#define MDIST 50.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n#define range(a,b,r,x) (smoothstep(a-r,a+r,x)*smoothstep(b+r,b-r,x))\n#define s(a) smoothstep(0.0,1.0,a)\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n//smin & smax, probably based on IQ's version \nfloat smin(float a,float b, float k){ \n    float h=max(0.,k-abs(a-b));\n    return min(a,b)-h*h*.25/k;\n}\n\nfloat smax(float d1,float d2,float k){\n    float h=clamp(0.5-0.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h)+k*h*(1.0-h);\n}\n\n//https://www.shadertoy.com/view/3tjGWm\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\n//iq box sdf\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 moda (vec2 p, float per){\n    float a = atan(p.y,p.x);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*length(p);\n}\n\nfloat box(vec2 p, float r){\n  vec2 d = abs(p);\n  return max(d.x,d.y)-r;\n}\n\nfloat superGon(vec2 p, float r){\n  float a = box(p,r);\n  p*=rot(pi/4.);\n  float b = box(p,r);\n  a = max(a,b);\n  p*=rot(pi/8.);\n  b = box(p,r);\n  a = max(a,b);\n  p*=rot(pi/4.);\n  b = box(p,r);\n  a = max(a,b);\n  return a;\n}\n\nfloat octGon(vec2 p, float r){\n  float a = box(p,r);\n  p*=rot(pi/4.);\n  float b = box(p,r);\n  a = max(a,b);\n  return a;\n}\n\nfloat glow = 0.;\nfloat glow2 = 0.;\nvec2 map(vec3 p){\n    float t = iTime*0.85;\n    vec3 po2 = p;\n    p.xz*=rot(pi/4.0);\n    vec3 po = p;\n    \n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    a.x = 999.;\n    float ballscl = 3.4;\n    \n    for(float i = 0.; i<13.0; i++){\n        p.x+=tanh(cos(t*2.0+i*1.4)*8.0)*ballscl;\n        p.x+=tanh(cos(t*1.0+i*2.0)*20.0)*ballscl;\n        p.z+=tanh(sin(t*2.0+i*0.5)*8.0)*ballscl;\n        p.z+=tanh(sin(t*1.0+i*3.5)*8.0)*ballscl;\n        p.y+=sin(t*0.33+i*2.3+tanh(sin(t*1.1)*8.)*1.5)*7.5;\n\n        b.x = length(p)-1.7;\n        a.x = smin(a.x,b.x,1.3);\n        p = po;\n    }\n    \n    p.xy*=rot(pi/4.);\n    float wv = 0.6;\n    float disp = sin(p.x*wv+t*2.0)*sin(p.z*wv);\n    p+=disp;\n    p.xz = abs(p.xz)-2.6;\n    \n    float size = 2.75;\n    b.x = ebox(p, vec3(size,0.,size))-1.7;\n    b.x = smax(a.x-0.2,b.x,2.);\n    a.x = min(a.x,b.x);\n    \n    glow+=0.6/(2.9+a.x*a.x);\n    \n    //outer lines\n    p = po2;\n    \n    p.xy*=rot(0.8);\n    float space = .3;\n    float width = .2;\n    p.y+=t*0.75;\n    vec2 c = vec2(a.x,3.0);\n    \n    p.y = pmod(p.y,space+width);\n    float cut = abs(p.y)-space*0.5;\n    \n    c.x-=.3;\n    c.x = abs(c.x)-0.15;\n    c.x = max(c.x,-cut);\n    if(c.x<0.01){\n    glow2+=1.3/(2.9+c.x*c.x);\n    glow-=0.5/(2.9+c.x*c.x);\n    }\n    glow-=0.05/(0.4+c.x*c.x);\n    c.x = max(0.03,abs(c.x));\n\n    a=(a.x<c.x)?a:c;\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0,0,-28.0);\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0.1,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(1.0)+uv.x*r+uv.y*cross(f,r));  \n    vec3 p = ro;\n    vec2 d = vec2(0);\n    bool hit = false;\n    float dO = 0.;\n    float blueNoise = texelFetch(iChannel0, ivec2(fragCoord)% textureSize(iChannel0, 0) , 0).r;\n    ro+=rd*(blueNoise*min(10.0,map(ro).x*0.8)-0.5);\n\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.005){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            break;\n        }\n    }\n    vec3 red = vec3(0.957,0.176,0.310);\n    vec3 redish = vec3(0.706,0.094,0.278);\n    if(hit){\n        vec3 n = norm(p);\n        vec3 rr = reflect(rd,n);\n        vec3 ld = normalize(vec3(-1,1.6,-0.1));\n        ld.xz*=rot(0.3);\n        vec3 h = normalize(ld - rd);\n        float diff = max(0.0,dot(n,ld));\n        float amb = dot(n,ld)*0.5+0.5;\n        float fres = pow(dot(rd,rr)*0.4+0.6,1.0);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float diff2 = dot(n,ld)*0.7+0.3;\n\n        vec3 diffcol = vec3(0);\n        \n        //Base top red color\n        diffcol+=mix(red,redish,0.5);\n        //Sorta shift yellow towards top of diff but keep bottom end\n        float bias = 0.3;\n        //Base Top Yellow \n        vec3 top1=vec3(diff2*0.5,pow(diff2,0.9),diff2*0.1)*smoothstep(0.0,0.4+bias,dot(n,ld)+0.15);\n        //Second version of Top Yellow \n        vec3 top2 =vec3(diff2*0.6,diff2*0.9,diff2*-0.3)*smoothstep(0.0,0.5+bias,dot(n,ld));\n        //Idk I liked both of them\n        diffcol+=mix(top1,top2,0.6);\n        //White top hightlight\n        diffcol+=vec3(0,0,1)*smoothstep(0.75,1.15,diff)*0.3;\n        //Saturate \n        diffcol=pow(diffcol,vec3(1.05));\n        //Add diffcol\n        col+=diffcol;\n        //Transition between dark and light\n        float cutdiff = smoothstep(0.3,0.55,amb)+0.1;\n        //Remove previous lighting in dark\n        col*=cutdiff;\n        //add purple fresnal in dark area\n        col+=mix(fres,1.0,0.3)*pow(redish,vec3(1.3))*sat(1.0-cutdiff)*0.8;\n        //I think the hueshift breaks without this idk\n        col = sat(col);\n        //col = vec3(amb);\n    }\n    else {\n        float px = 2.5/min(iResolution.x,iResolution.y);\n        \n        col+=sat(min(glow*0.05,0.3)*2.5)*redish;\n        uv-=vec2(-0.9,0.6);\n        col+=redish*length(uv)*smoothstep(0.5,5.8,length(uv));\n\n        \n        uv+=vec2(0.08,-0.06);\n        vec2 uv2 = uv;\n        uv2*=rot(-iTime*0.02);\n        col+=0.55*mix(vec3(0.973,0.004,0.369),vec3(0.537,0.200,0.910),uv.y+0.5)\n        *smoothstep(0.5+px,0.5-px,superGon(uv2,-0.01));\n\n\n        vec2 uvo = uv;\n        uv.xy*=rot(iTime*0.0075);\n        uv=moda(uv,0.18);\n        uv.x-=0.55;\n\n        col+=0.3*vec3(0.973,0.004,0.369)*smoothstep(0.025+px,0.025-px,octGon(uv,0.0));\n\n        uv = uvo;\n        uv.xy*=rot(iTime*0.0125);\n        uv=moda(uv,0.17);\n        uv.x-=0.62;\n\n        uv=moda(uv,2.);\n        uv.x-=0.03;\n\n        col+=0.3*vec3(0.973,0.004,0.369)*smoothstep(0.0125+px,0.0125-px,octGon(uv,0.0));\n    \n    }  \n    col +=min(glow2*0.06,0.7)*pow(redish,vec3(0.5));\n\n    //Hue Shift\n    col = hs(col,0.3);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 439, 476, 476, 542], [544, 544, 582, 582, 666], [668, 708, 733, 733, 825], [827, 840, 867, 867, 954], [956, 956, 986, 986, 1094], [1096, 1096, 1123, 1123, 1169], [1171, 1171, 1203, 1203, 1392], [1394, 1394, 1424, 1424, 1515], [1552, 1552, 1569, 1569, 2899], [2901, 2901, 2919, 2919, 3046], [3048, 3048, 3102, 3102, 6607]], "test": "error"}
{"id": "7td3Dj", "name": "Persian mosaic", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "glass", "mosaic", "ceramic"], "likes": 2, "viewed": 121, "published": "Public API", "date": "1636776106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            float bend = 1.;\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.+1./3.;\n                //float bend = 1.;\n                \n                uv.yx = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                //uv.yx = triangle_wave(uv.yx+offset,scale)*bend-triangle_wave(uv+offset/1.5,scale)/bend;\n\n                \n                //bend = (((uv.x-uv.y)))/2.+1.5;\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1. + uv.x;\n                uv += vec2(random1[k]/bend,random2[k]*bend);\n                \n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2501]], "test": "valid"}
{"id": "7td3RN", "name": "MarksExperiment002", "author": "Mr_Steve", "description": "martijn's eyes", "tags": ["noob"], "likes": 2, "viewed": 32, "published": "Public", "date": "1636255149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// the eyes from Art of Code Lesson 4\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\n// eye function\nvec4 Eye(vec2 uv, vec2 pos, float scale){\n    uv = uv-pos;\n    \n    float t = iTime*.4;\n    uv.x += sin(t+uv.y*15.)*.02;\n    uv.y += sin(t+uv.x*25.)*.04;\n    \n    vec2 offs = vec2(sin(t+uv.y*15.),sin(t+uv.x*15.));\n    offs += 1.1;  \n    uv *= offs;\n \n    float d = length(uv)*scale;\n    \n    vec4 irisCol = vec4(.3,.5,1.,1.);\n    vec4 col = mix(vec4(1.),irisCol,S(.1,.7,d)*.5);  // outer eye circle\n    \n    col.rgb *= 1.-S(.45,.5,d)*.5*sat(-uv.y-uv.x);  // \"shadow\" effect\n    col.rgb = mix(col.rgb,vec3(0.),S(.3,.28,d));  // iris outline\n    irisCol.rgb *= 1.+S(.3,.05,d);  // fade on iris\n    col.rgb = mix(col.rgb,irisCol.rgb,S(.28,.25,d)); // iris\n    col.rgb = mix(col.rgb,vec3(.75,0.,1.),S(.16,.14,d));  // pupil\n        \n    col.a = S(.5,.48,d);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 col = vec3(1.);\n\n    vec4 eye = Eye(uv,vec2(.1,.1),7.);    \n    col.rgb = mix(col.rgb,eye.rgb,eye.a);\n \n    eye = Eye(uv,vec2(-.7,.3),2.);    \n    col.rgb = mix(col.rgb,eye.rgb,eye.a);\n    \n    eye = Eye(uv,vec2(.3,-.1),2.);    \n    col.rgb = mix(col.rgb,eye.rgb,eye.a);\n    \n    eye = Eye(uv,vec2(-.3,-.2),4.);    \n    col.rgb = mix(col.rgb,eye.rgb,eye.a);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 127, 168, 168, 898], [900, 900, 957, 974, 1478]], "test": "valid"}
{"id": "7tdGDf", "name": "OM SDF Test", "author": "onemore", "description": "test signed distance function", "tags": ["sdf"], "likes": 1, "viewed": 29, "published": "Public", "date": "1636890510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 关于鼠标输入 https://www.shadertoy.com/view/Mss3zH\n\n\n// https://stackoverflow.com/questions/30545052/calculate-signed-distance-between-point-and-rectangle/30545544\n// https://www.shadertoy.com/view/MtBGWc\nfloat sdfRect(vec2 c, vec2 h, vec2 p){\n    vec2 v = abs(p-c);\n    vec2 u = v - h;\n    return length(max(u,0.0)) + min(0.0,max(u.x,u.y));\n}\n\nfloat sdfCircle(vec2 c, float r, vec2 p){\n     return length(p-c) - r;\n}\n\nvec2 sdfToColor(float d){\n    float m = 1.0 - abs(d)/0.2;\n    float s = sin(d*400.0) * 0.5 + 0.5;\n    return vec2(s*m*(-sign(d)*0.5+0.5),s*m*(sign(d)*0.5+0.5));\n}\n\nfloat sdfBlend(float d1, float d2){\n    return mix(d1,d2,sin(iTime)*0.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 circleCenter = vec2(0.75,0.75);\n    float radius = 0.24;\n    if(iMouse.z > 0.0){\n        circleCenter = iMouse.xy / iResolution.xy;\n    }\n    \n    vec2 rectCenter = vec2(0.25,0.25);\n    vec2 rectSize = vec2(0.2,0.2);\n    \n    float d1 = sdfRect(rectCenter, rectSize, uv);\n    float d2 = sdfCircle(circleCenter, radius, uv);\n    \n    float t1 = sdfBlend(d1,d2);\n    float d = t1;\n    \n    fragColor = vec4(sdfToColor(d),0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 214, 252, 252, 352], [354, 354, 395, 395, 426], [428, 428, 453, 453, 590], [592, 592, 627, 627, 671], [673, 673, 730, 780, 1261]], "test": "valid"}
{"id": "7tdGDs", "name": "Lab 2 student version", "author": "gdrett", "description": "Student version of path tracing lab", "tags": ["pathtracing", "lab"], "likes": 4, "viewed": 116, "published": "Public", "date": "1637666381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Lab #2: path-tracing in shadertoy\n *\n *\n * This shader implements a path tracer that treats diffuse materials only. \n * \n * 1. The first task is to add a sphere in the scene.\n *\n *    You will need to complete the function \"intersect_sphere\" to achieve this. \n *    To do this you can use the formula for line/sphere intersection (eg https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection)\n *    This requires you to compute the distance \"d\" to the intersection along the ray from the ray origin.\n *\n *    If you return this distance correctly you will get a black sphere: to get diffuse shading, \n *    you also need to compute the (normalize) normal.\n * \n *\n *    You can use ray from the center to the intersection point which defines this normal. Use ray_at\n *    to fine the intersection point.\n *\n *    Once you have finished this routine, you should have a diffuse sphere in the middle of the scene.\n *    Question: Explain what happened when you correctly assigned the normal.\n *       Answer: ....\n * \n * 2. We will now add a glossy BRDF, and in particular the Ward BRDF. We will be using the\n *    notes from Bruce Walter for this:\n *\n *    http://www.graphics.cornell.edu/pubs/2005/Wal05.html\n *\n *    Start by carefully reading section 1 and 2 to understand the method.\n *    \n *    Change the material property of the sphere to be MAT_GLOSSY (after the intersection)\n *    and write the function WardBRDF, using Eq.(4) of the pdf above. All vectors are given in\n *    local coordinate space. Currently, the BRDF is sampled using the uniform distribution,\n *    same as the diffuse case.\n *\n *    You will need to understand how the half vector is parameterized, and how to convert\n *    into spherical coordinates (see Eq. (1) and (5)) so you can find theta and phi.\n *\n *    Questions: \n *        What do you observe for pixels of the glossy sphere ? \n *        Answer:....\n *        What do you observe for the scene in general ?\n *        Answer:....\n *\n *    Save the image (right button, save image as) and provide this with your lab code.\n *\n *\n * 3. We will now add importance sampling. To do this, you need to modify WardPDF so that \n *    it uses Eq.(9) of the pdf above. \n *    First you need to modify getOutDir to find the outgoing direction.\n *    To do this, you need to use Eq. (6), (7) and (8) from the pdf file to get the\n *    half-vector of the outgoing direction. You need to understand the geometry\n *    explained in Fig. 2 to achieve this correctly.\n *\n *    You will need to use the following helper functions:\n *       - get_random that gives a random number between 0 and 1\n *       - WorldToLocal and LocalToWorld that transform vectors between the world \n *         coordinate system and the local coordinate system of the BRDF( see Fig. 1\n *         of the pdf file and the slides in class.)\n *    You will again need to use Eq(5) to convert from angles to vectors.\n *    Dont forget to ouput the values of theta_h and phi_h\n *\n *    Be careful about the orientation of the vectors. \n *\n *    Once you have this, you need to modify the function WardPDF to compute the correct \n *    value, using Eq. (9) of the pdf. You can use g_alpha which is a global variable\n *    holding the alpha value of the sphere.\n *   \n *    Questions: \n *        What do you observe for pixels of the glossy sphere before and after each step, \n *         ie changing getOutDir ? \n *        Answer:....\n *        What do you observe for the scene in general ?\n *        Answer:....\n *    Save the image (right button, save image as) and provide this with your lab coe.\n *    \n *    Numerical precision:\n *    Make the image full screen: \n *    Question: What do you observe at the borders of the sphere ?\n *    Answer:...\n *\n *    This problem is due to the fact that Eq.(8) sometimes generates directions in the opposite\n *    direction of the normal. To reduce these problems, identify and ignore these cases (add a parameter to \n *    return an error from getOutDir, and break the loop).\n *\n *    Question: What do you observe ?\n *    Answer:...\n * \n *  4. Experiment with various parameters:\n *\n *     - Change the roughness (alpha parameter) of the sphere and save the images (change between 0.08 and 0.25).\n *\n *     Question: What do you observe ?\n *     Answer: ....\n *\n *    - The version so far sets g_alpha = alpha_x == alpha_y which is the isotropic version of the Ward BRDF\n *      Modify the code to take separate values and show the effect of changing the values on the final image.\n *      Verify all equations to make sure you use the correct values everywhere.\n * \n *     Question: What do you observe ?\n *     Answer: ....\n *\n *     Save several images with different values of alpha_x and alpha_y\n *  \n *\n *     - Change the number of samples and save the images\n *     Question: What do you observe ?\n *     Answer: ....\n * \n *     - Change the number of bounces and save the images\n *     Question: What do you observe ?\n *     Answer: ....\n *\n *    \n *\n *  5. Output and save several images that you will use for denoising with a neural network. Run the network on the\n *     noisy images with different numbers of samples, and save the pairs \"noisy/denoised\".\n * \n *  Extensions for Projects:\n *         * Implement simple version of bi-directional path tracing\n *              Reference: http://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/M2MRI/2006/veach-combine.pdf\n *        (Also PBRT book http://pbrt.org )\n *\n *         * Implement simple version of practical path guiding\n *              References: https://tom94.net/data/publications/hart20practical/hart20practical.pdf\n *         * Bonus: Evaluate pre-trained denoisers (required access to a linux machine with a GPU)\n *              References: E.g., https://groups.csail.mit.edu/graphics/rendernet/\n * \n */\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n#define INFINITY 9999999.0\n#define PI 3.141592653589\n#define NUM_SAMPLES 8\n#define NUM_BOUNCES 2\n\n#define MAT_UNDEF   0\n#define MAT_DIFFUSE 1\n#define MAT_GLOSSY  2\n#define MAT_EMISSION 3\n\n#define EPSILON 0.00001\n\nfloat g_light_size;\nfloat g_light_area;\nvec3 g_light_position;\nvec3 g_light_normal;\nint g_seed;\nvec4 g_light_albedo;\nint g_flat_idx;\nfloat g_rho_s = 0.7, g_rho_d = 0.2, g_alpha = 0.1;\n\nvec3 sphere2_center = vec3(0.5, -0.4,  -0.1);\n\n// Sampling routines\n\nvec2\nsample_disk(vec2 uv)\n{\n\tfloat theta = 2.0 * 3.141592653589 * uv.x;\n\tfloat r = sqrt(uv.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3\nsample_cos_hemisphere(vec2 uv)\n{\n\tvec2 disk = sample_disk(uv);\n\treturn vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);\n}\n\nvec3\nsample_light(vec2 rng)\n{\n\treturn g_light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * g_light_size;\n}\n\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\n// Routines for random number generation\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\n// return a random 2D vector\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(g_flat_idx, g_seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\n\n// Basic Ray data structures\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\n// Axis Aligned Bounding Box\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\n// intersection\nstruct its {\n    float t; // distance to intersection\n    int material; // MAT_GLOSSY or MAT_DIFFUSE\n    vec4 albedo; \n    vec3 position;\n    vec3 normal;\n};\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\n\n// intersection routines\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\n\n\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_light(Ray ray)\n{\n\tfloat t = intersect_plane(ray, g_light_position, g_light_normal);\n\n\tvec3 p = ray_at(ray, t);\n\tif(all(lessThan(abs(g_light_position - p).xz, vec2(g_light_size * 0.5)))) {\n\t\treturn t;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_sphere(in Ray ray, inout float t_max, inout vec3 normal, in vec3 c /* center*/ , in float r /* radius */)\n{\n    float t_min = 1000.0;\n    return INFINITY;\n}\n\n\n\n\n// Intersect the scene by visiting each object\n\nits\nintersect(Ray ray)\n{\n\tfloat t_min = INFINITY;\n    its ret_its;\n    \n    ret_its.t = 0.0;\n    ret_its.material = MAT_UNDEF;\n    ret_its.albedo = vec4(0.0);\n\n\t{\n\t\tfloat t = intersect_light(ray);\n\t\tif(t < t_min) {\n\t\t\t//albedo = vec3(100);\n\t\t\tret_its.albedo = g_light_albedo;\n\t\t\t//albedo = vec3(dot(ray.dir, g_light_normal) < 0.0 ? 1.0 : 0.0);\n\t\t\tret_its.normal = g_light_normal;\n\t\t\tt_min  = t;\n\t\t\tret_its.position = ray_at(ray, t);\n            ret_its.material = MAT_EMISSION;\n\t\t}\n\t}\n\n    // small box\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(0.5, -0.75, 0.35);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.25, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tret_its.position = ray_at(ray, t);\n\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tret_its.normal = normal_tmp;\n            ret_its.material = MAT_DIFFUSE;\n\t\t}\n\t}\n    \n    // sphere\n    {\n        vec3 c = vec3(0, 0, 0);\n        float r = 0.4;\n        vec3 normal_tmp;\n     \n\t\tRay ray_tmp = ray;\n        float t_max;\n        \n\t\tfloat t = intersect_sphere(ray_tmp, t_max, normal_tmp, c, r);\n        if(t < t_min) {\n                t_min = t;\n                ret_its.position = ray_at(ray, t);\n                ret_its.albedo = vec4(.9, .9, .9, 0);\n                ret_its.normal = normal_tmp;\n                ret_its.material = MAT_DIFFUSE;\n        }\n    }\n\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tret_its.albedo = vec4(0.9, 0.1, 0.1, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tret_its.albedo = vec4(0.1, 0.9, 0.1, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tret_its.normal = normalize(ret_its.normal);\n\n    ret_its.t = t_min;\n    \n\treturn ret_its;\n}\n\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\t\n\tits t_shadow = intersect(r);\n\n\treturn t_shadow.t > distance(p1, p2) - 2.0 * eps;\n}\n\n// BRDF routines\n\n// all vectors wcs\n\nvec3 WorldToLocal( vec3 v, vec3 ss, vec3 ts, vec3 ns)  {\n    \n    return vec3(dot(v, ss), dot(v, ts), dot(v, ns));\n}\n\nvec3 LocalToWorld( vec3 v, vec3 ss, vec3 ts, vec3 ns)  \n{\n    return vec3(ss.x * v.x + ts.x * v.y + ns.x * v.z,\n                    ss.y * v.x + ts.y * v.y + ns.y * v.z,\n                    ss.z * v.x + ts.z * v.y + ns.z * v.z);\n}\n\n// define tangent space; all vectors in *world frame*\nvoid\ndefineTangents(vec3 outdir, vec3 normal, inout vec3 s, inout vec3 t)\n{\n      s = cross(outdir, normal);\n      s = normalize(s);\n      t = cross(s, normal);\n      t = normalize(t);\n}\n\n// indir is in World Coordinates \nvec3\ngetOutDir(its inters, vec3 s, vec3 t, vec3 indir, inout float theta, inout float phi)\n{\n    // TODO switch to ours\n    theta = phi = 0.0;\n    mat3 onb = construct_ONB_frisvad(inters.normal);\n    \n    vec3 wcs_odir = normalize(onb * sample_cos_hemisphere(get_random()));\n        \n    // Modify this for Question 3.; add if statement for diffuse vs glossy case\n    return wcs_odir;\n    \n}\n\nfloat\ncdot(vec3 v1, vec3 v2)\n{\n    return max (0., dot(v1, v2));\n}\n\n\n// all vectors in local frame !\nfloat\nWardBRDF(vec3 i, vec3 o, float alpha, float rho) \n{\n   float res = 0.;\n   return res ;  \n}\n\n\n\nfloat\nWardPDF(vec3 o, vec3 i, float thh, float phih)\n{\n  \n    float rval = 1./PI; // Uniform sampling change for Question 3.\n    return  (rval);\n   \n}\n\n\n\nvec3\nevalBRDF(its inter, inout float brdf_pdf, vec3 wcs_indir, vec3 wcs_outdir, vec3 s, vec3 t, float th, float ph)\n{\n    if( inter.material == MAT_DIFFUSE ) {\n        vec3 brdf = inter.albedo.rgb / PI;\n        brdf_pdf = 1.0 / PI;\n        return brdf;\n    }\n    else if( inter.material == MAT_GLOSSY ) {\n        vec3 local_idir =  normalize( WorldToLocal(wcs_indir, s, t, inter.normal  ));\n        vec3 local_odir =  normalize( WorldToLocal(wcs_outdir, s, t, inter.normal  )); \n  \n        vec3 brdf = g_rho_d * 1./PI * inter.albedo.rgb + g_rho_s * WardBRDF( local_idir, local_odir, g_alpha, g_rho_s);                    \n        brdf_pdf = g_rho_s * WardPDF(-local_odir, local_idir, th, ph);      \n     \n        return brdf;\n    }\n}\n\n// path tracing with MIS\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tits inters = intersect(ray);\n    \n    position = inters.position;\n    normal = inters.normal;\n    albedo = inters.albedo;\n    float t = inters.t;\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { /* hit light source */\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n    Ray currRay = ray;\n    \n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\t\n\n\t\t{ /* NEE */\n\t\t\tvec3 pos_ls = sample_light(get_random());\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee /= sqrt(rr_nee);\n\t\t\tfloat G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, g_light_normal)) / rr_nee;\n            vec3 sv, tv;\n            float theta =0.0, phi=0.0;\n        \n            defineTangents(currRay.dir, inters.normal, sv, tv);\n      \n\t\t\tif(G > 0.0) {\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\t\t\t\tfloat brdf_pdf;\n\n\t\t\t\tfloat w = light_pdf / (light_pdf + brdf_pdf);\n                \n                vec3 h_wcs = normalize(l_nee+currRay.dir);\n                vec3 h_local = WorldToLocal(h_wcs, sv, tv, inters.normal);\n                \n                float theta = acos(h_local.z);\n                float phi = h_local.y/(sin(theta));           \n\n\t\t\t\tvec3 brdf = evalBRDF(inters, brdf_pdf, l_nee, -currRay.dir, sv, tv, theta, phi);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\t\tcontrib += tp * (Le * w * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n            \n\t\t}\n\t\n\n    { /* brdf */            \n            vec3 sv, tv;\n            \n            defineTangents(-currRay.dir, inters.normal, sv, tv);\n            float theta, phi;\n        \n\t\t\tvec3 dir = getOutDir(inters, sv, tv, -currRay.dir, theta, phi);\n            \n        \n\t\t\tRay ray_next = Ray(position, dir);\n\t\t\tray_next.origin += ray_next.dir * 1e-5;\n            \n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tits inters_next = intersect(ray_next);\n            position_next = inters_next.position, normal_next = inters_next.normal, albedo_next = inters_next.albedo;\n            t = inters_next.t;\n           \n            \n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            float brdf_pdf;\n            \n            vec3 brdf = evalBRDF(inters, brdf_pdf, -dir, currRay.dir, sv, tv, theta, phi);\n\n\t\t\tif(albedo_next.a > 0.0) { /* hit light_source */\n\t\t\t\tfloat G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) / (t * t);\n\t\t\t\tif(G <= 0.0) /* hit back side of light source */\n\t\t\t\t\tbreak;\n\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\n\t\t\t\tfloat w = brdf_pdf / (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\tcontrib += tp * (Le * w * brdf) / brdf_pdf;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttp *= brdf / brdf_pdf;\n            \n            currRay = ray_next;\n\n            inters = inters_next;\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t} \n\n\t}\n\n\n\treturn contrib;\n}\n\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    g_light_size = 0.6;\n\tg_light_area = g_light_size * g_light_size;\n    \n\t// Uncomment to make light move (comment following line)\n    g_light_position = vec3(0.5 * sin(iTime), 0.90, 0.5 * cos(iTime));\n   \n\tg_light_normal = vec3(0, -1, 0);\n\tg_seed = 0;\n\tg_light_albedo = vec4(1, 1, 1, 2.0 / (g_light_size * g_light_size));\n\tg_flat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n    vec4 m = iMouse / iResolution.x;\n\n\tif( m.z>0.0 ) { // button is down\n        sphere2_center = sphere2_center +  vec3(-0.1, 0., 0.3);\n        // move light down\n        g_light_position += vec3(0, -0.4, 0);\n    }\n    \n    // Make image square\n\tvec2 p = fragCoord.xy  / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\tvec3 cam_center = vec3(0, 0, 3.125);\n\n\tvec3 s = vec3(0);\n    \n    // trace NUM_SAMPLES per pixel\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n        \n        // get random 2-D vector\n\t\tvec2 r = get_random();\n        \n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -1));\n\t\tray.dir = ray_dir;\n        \n        // do path tracing and MIS \n\t\tvec3 c = pt_mis(ray);\n        \n        // accumulate color in variable s\n\t\ts += c;\n\t}\n\n    // gamma correct\n\tfragColor = vec4(pow(s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6406, 6406, 6433, 6433, 6544], [6546, 6546, 6583, 6583, 6684], [6686, 6686, 6715, 6715, 6794], [6797, 6797, 6838, 6838, 7191], [7235, 7235, 7270, 7270, 7626], [7628, 7657, 7676, 7676, 7791], [8101, 8101, 8125, 8125, 8242], [8271, 8271, 8356, 8356, 8681], [8683, 8683, 8717, 8717, 8753], [8758, 8758, 8826, 8826, 8956], [8959, 8959, 9017, 9017, 9535], [9537, 9537, 9569, 9569, 9776], [9778, 9778, 9901, 9901, 9950], [10003, 10003, 10027, 10027, 13519], [13522, 13522, 13562, 13562, 13739], [13779, 13779, 13835, 13835, 13895], [13897, 13897, 13954, 13954, 14127], [14129, 14183, 14258, 14258, 14369], [14371, 14405, 14497, 14524, 14796], [14798, 14798, 14828, 14828, 14864], [14867, 14899, 14956, 14956, 14995], [14999, 14999, 15053, 15053, 15149], [15153, 15153, 15270, 15270, 15886], [15914, 15914, 15936, 15936, 18886], [18889, 18889, 18944, 18944, 20301]], "test": "error"}
{"id": "7tdGW4", "name": "Idk what I did but it looks cool", "author": "gingerphoenix10", "description": "I switched 0.5 to 10.5", "tags": ["unexpected"], "likes": 0, "viewed": 98, "published": "Public API", "date": "1636135055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 10.5 + 10.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 296]], "test": "valid"}
{"id": "7tdGWr", "name": "Plant microstructures", "author": "sinvec", "description": "Simple pattern based on [url=https://archive.bridgesmathart.org/2018/bridges2018-39.pdf]this article[/url].", "tags": ["2d", "sdf", "truchet", "pattern", "multiscale"], "likes": 7, "viewed": 98, "published": "Public", "date": "1636074994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define R (iResolution.xy)\n#define s(v,l) smoothstep(l/R.y,0.,v) // AA\n#define ro(a) (mat2(cos(a),sin(a),-sin(a),cos(a))) // 2d rotation matrix\n\nfloat hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nfloat cir (vec2 p, vec2 c, float r, float w) {return abs(length(p-c)-r)- w;}\n\nvoid mainImage(out vec4 O, in vec2 E) {\n   \n    vec2 o = (E - R*.5) / R.x;\n    o *= 5.;\n    o += vec2(iTime * .1);\n    \n    vec3 col = vec3(1.);\n    vec3 oc = col;\n    vec2 u;\n    \n    float id, aa;\n    \n    vec2 gr, ce;\n    for (float g = 0.; g < 3.; g++){\n        for (float i = 0.; i < 1. ; i+=.5) {\n            for (float j = 0.; j < 1.; j+=.5) {\n                u = o + vec2(i, j);\n            \n                gr = floor(u);\n                id = hash21(gr);\n                if (id * g > .25) continue;\n                \n                ce = (u - gr - .5) * 2.;\n                ce *= ro((PI / 2.) * floor(id * 10.));\n    \n                vec3 c1 = mod(g, 2.) == 0. ? oc : vec3(.6,.9,.6);\n                vec3 c2 = mod(g, 2.) == 0. ? vec3(.7,.95,.5) : oc;\n                vec3 c3 = mod(g, 2.) == 0. ? vec3(.6,.95,.8) : oc;\n                vec3 c4 = mod(g, 2.) == 0. ? vec3(.7,.9,.7) : vec3(1.,1.,.8);\n                \n                aa = 2. * (g * 2. + 2.);\n               \n                col = mix(col, c1, s(cir(ce, vec2(0.), .0, .5), aa));\n                col = mix(col, c2, s(cir(ce, vec2(0.), .0, .11), aa));\n                col = mix(col, c1, s(cir(ce, vec2(0.), .0, .05), aa));\n                col = mix(col, c4, s(cir(ce, vec2(0.), .0, .02), aa));\n                \n                col = mix(col, c1, s(cir(ce, vec2( .5, .5), .0, 1. / 3.), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.5, .5), .0, 1. / 3.), aa));\n                col = mix(col, c1, s(cir(ce, vec2( .5,-.5), .0, 1. / 3.), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.5,-.5), .0, 1. / 3.), aa));\n\n                col = mix(col, c2, s(cir(ce, vec2( .5, .5), .0, 1. / 4.), aa));\n                col = mix(col, c2, s(cir(ce, vec2(-.5, .5), .0, 1. / 4.), aa));\n                col = mix(col, c2, s(cir(ce, vec2( .5,-.5), .0, 1. / 4.), aa));\n                col = mix(col, c2, s(cir(ce, vec2(-.5,-.5), .0, 1. / 4.), aa));\n\n                col = mix(col, c3, s(cir(ce, vec2( .5, .5), .0, 1. / 5.), aa));\n                col = mix(col, c3, s(cir(ce, vec2(-.5, .5), .0, 1. / 5.), aa));\n                col = mix(col, c3, s(cir(ce, vec2( .5,-.5), .0, 1. / 5.), aa));\n                col = mix(col, c3, s(cir(ce, vec2(-.5,-.5), .0, 1. / 5.), aa));\n \n                col = mix(col, c4, s(cir(ce, vec2( .5, .5), .0, 1. / 6.1), aa));\n                col = mix(col, c4, s(cir(ce, vec2(-.5, .5), .0, 1. / 6.1), aa));\n                col = mix(col, c4, s(cir(ce, vec2( .5,-.5), .0, 1. / 6.1), aa));\n                col = mix(col, c4, s(cir(ce, vec2(-.5,-.5), .0, 1. / 6.1), aa));\n                \n                col = mix(col, c1, s(cir(ce, vec2( .5, .5), .0, 1. / 12.1), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.5, .5), .0, 1. / 12.1), aa));\n                col = mix(col, c1, s(cir(ce, vec2( .5,-.5), .0, 1. / 12.1), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.5,-.5), .0, 1. / 12.1), aa));\n                \n                col = mix(col, c3, s(cir(ce, vec2(-.18, .18), .0, 1. / 9.), aa));\n                col = mix(col, c3, s(cir(ce, vec2( .18,-.18), .0, 1. / 9.), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.18, .18), .0, 1. / 18.), aa));\n                col = mix(col, c1, s(cir(ce, vec2( .18,-.18), .0, 1. / 18.), aa));\n\n                col = mix(col, c3, s(cir(ce, vec2(-.5, .0), .0, 1. / 6.1), aa));\n                col = mix(col, c3, s(cir(ce, vec2( .5, .0), .0, 1. / 6.1), aa));\n                col = mix(col, c3, s(cir(ce, vec2( .0,-.5), .0, 1. / 6.1), aa));\n                col = mix(col, c3, s(cir(ce, vec2( .0, .5), .0, 1. / 6.1), aa));\n                \n                col = mix(col, c2, s(cir(ce, vec2(-.5, .0), .0, 1. / 9.), aa));\n                col = mix(col, c2, s(cir(ce, vec2( .5, .0), .0, 1. / 9.), aa));\n                col = mix(col, c2, s(cir(ce, vec2( .0,-.5), .0, 1. / 9.), aa));\n                col = mix(col, c2, s(cir(ce, vec2( .0, .5), .0, 1. / 9.), aa)); \n         \n                if (ce.y > -(1. / .6) && ce.y < .5 && ce.x < .5)\n                    col = mix(col, c2, s(cir(ce, vec2(.5), .5, 1. /  20.), aa));\n                if (ce.y <  (1. / .6) && ce.y >-.5 && ce.x >-.5) \n                    col = mix(col, c2, s(cir(ce, vec2(-.5), .5, 1. / 20.), aa)); \n                \n                col = mix(col, c1, s(cir(ce, vec2(-.147,-.147), .0, 1. / 40.), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.25,-.065), .0, 1. / 40.), aa));\n                col = mix(col, c1, s(cir(ce, vec2(-.065,-.25), .0, 1. / 40.), aa));\n                \n                col = mix(col, c1, s(cir(ce, vec2( .147, .147), .0, 1. / 40.), aa));\n                col = mix(col, c1, s(cir(ce, vec2( .25, .065), .0, 1. / 40.), aa));\n                col = mix(col, c1, s(cir(ce, vec2( .065, .25), .0, 1. / 40.), aa));\n            }\n        }\n        // magic formula (works only for g < 3.), i gonna fix this in the near future\n        o += pow(1./8., g + 1.) * (g * 7. + 1.);\n        o *= 2.;\n    }\n    \n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 186, 186, 280], [282, 282, 328, 328, 358], [360, 360, 399, 399, 5336]], "test": "valid"}
{"id": "7tdGzH", "name": "vnoise fun", "author": "rockhard", "description": "20 mins of time just for fun.", "tags": ["vnoisesimple"], "likes": 11, "viewed": 118, "published": "Public", "date": "1635742833", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original shader\n//https://www.shadertoy.com/view/flt3zH\n\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(363.42, 524.87, 239.66));\n    a += dot(a, a+34.51);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float asp=iResolution.x / iResolution.y;\n \n    float m = 0.;\n    float t = iTime*.05+10.0;\n    \n    float minD = 100.;\n    \n    for(float i=0.0; i<65.; i++)\n    {\n        vec2 n = N22(vec2(i+0.5,i-0.5));\n        vec2 p = (sin(n*t));\n        \n        float d = length(uv-p);\n        \n        m+= 0.15*d;\n        \n        if(d < minD) minD =d;       \n    }\n    \n    minD = pow(m,minD);\n    vec3 col = mix(vec3(.35, 0.25, .05),vec3(0.12,0.32,0.5),minD*sin(iTime*0.5));\n    \n    col+= texture(iChannel0, uv+vec2(minD)).xyz*(1.25/minD); \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 77, 77, 203], [205, 205, 262, 262, 921]], "test": "error"}
{"id": "7tGGWz", "name": "geometry hole animation", "author": "yasuo", "description": "geometry hole animation", "tags": ["animation"], "likes": 6, "viewed": 136, "published": "Public API", "date": "1637473246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .6, cos(z * .5), z);\n    return p;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z+=iTime*1.0;\n    p.xy -= path(p.z).xy;\n    p.z+=iTime*0.5;\n    p.z=mod(p.z,1.0)-0.5;\n    float d = B3D(p,vec3(0.01));\n    for (float i = 0.; i < 5.; i++) {\n            p.xz*=Rot(radians(90.0));\n            p.yz*=Rot(radians(38.0));\n            p=abs(p)-(3.3*pow(.54, i));\n            d=B3D(p,vec3(0.18));\n\t}\n    \n    vec3 col = vec3(1.0);\n    \n    return vec4(col,d*0.6);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(3,5,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.2;\n    \n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*2.0;\n    vec3 col = vec3(1.0);\n    vec3 ro = vec3(0.0,0.0,1.0);\n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    rd*=matRotateZ(radians(iTime*15.0));\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n        vec3 n = GetNormal(p);\n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        col *= exp( -0.0001*r.w*r.w*r.w );\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 513, 533, 533, 597], [599, 599, 635, 635, 677], [679, 679, 706, 706, 760], [761, 761, 783, 783, 1184], [1186, 1186, 1219, 1219, 1526], [1528, 1528, 1552, 1552, 1753], [1755, 1755, 1778, 1778, 2068], [2070, 2070, 2112, 2112, 2307], [2309, 2309, 2366, 2366, 2889]], "test": "valid"}
{"id": "7tGGz3", "name": "Walk 2d-n3 using Structs", "author": "pyBlob", "description": "Mouse: change strength of action (bottom left: base pose, top right: good walk).\n\nGraphs from Top to Bottom (dashed line shows strength of an action):\n- angles of left leg\n- angles of right leg\n- ankle.y of both legs\n- ankle.x of both legs", "tags": ["mouse", "walk", "struct", "camtimer"], "likes": 8, "viewed": 145, "published": "Public API", "date": "1638054809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Body Design and Base Animation by jorge2017a2: https://www.shadertoy.com/view/ftGGzy\n\nconst float     PI = radians(180.);\nconst float TWO_PI = 2. * PI;\n\nmat2 R(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\n//\n// Position structs\n//\n\nstruct XArm\n{\n    vec2 shoulder, elbow, hand;\n};\n\nstruct XLeg\n{\n    vec2 hip, knee, ankle, toe;\n};\n\nstruct XBody\n{\n    vec2 head;\n    XArm armLeft, armRight;\n    XLeg legLeft, legRight;\n};\n\nconst XArm xarm = XArm(\n    vec2(3, 12),\n    vec2(3, 9),\n    vec2(3, 6)\n);\n\nconst XLeg xleg = XLeg(\n    vec2(3, 8),\n    vec2(3, 5),\n    vec2(3, 2),\n    vec2(4, 2)\n);\n\nconst XBody xbody = XBody(\n    vec2(3, 13),\n    xarm, xarm,\n    xleg, xleg\n);\n\n\n//\n// Color structs\n//\n\nstruct ColArm\n{\n    vec3 upper, lower;\n};\n\nstruct ColLeg\n{\n    vec3 upper, lower, foot;\n};\n\nstruct ColBody\n{\n    vec3 head, spine;\n    ColArm armLeft, armRight;\n    ColLeg legLeft, legRight;\n};\n\nconst vec3 lightgreen = vec3(0,1,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 blue = vec3(0,0,1);\nconst vec3 pink = vec3(1,.3,.5);\nconst vec3 orange = vec3(1,.5,0);\nconst vec3 yellow = vec3(1,1,0);\nconst vec3 sky = vec3(.5,.7,1);\nconst vec3 water = vec3(.2,.7,1);\nconst vec3 gray = vec3(.5);\nconst vec3 black = vec3(0);\nconst vec3 white = vec3(1);\n\nconst ColBody colBody = ColBody(\n    sky, lightgreen,\n    ColArm(yellow, pink),\n    ColArm(lightgreen, orange),\n    ColLeg(lightgreen, pink, blue),\n    ColLeg(lightgreen, red, blue)\n);\n\n//\n// Drawing\n//\n\nvec3 drawOver(vec3 c, vec3 color, float r)\n{\n    float a = smoothstep(0., fwidth(r), r);\n    return mix(color, c, a);\n}\n\nvec3 drawGraph(vec3 c, vec2 uv, vec3 color, float y)\n{\n    y -= uv.y;\n    float a = smoothstep(0., fwidth(y), abs(y));\n    return mix(color, c, a);\n}\n\nvec3 drawDashed(vec3 c, vec2 uv, vec3 color, float y)\n{\n    y -= uv.y;\n    float a = smoothstep(0., fwidth(y), abs(y));\n\n    float dash = sin(uv.x/fwidth(uv.x)*TWO_PI/16.);\n    float b = smoothstep(0., fwidth(dash), dash);\n\n    return mix(color, c, max(a, b));\n}\n\nvec3 drawSegment(vec3 c, vec2 p, vec2 a, vec2 b, vec3 color, float radius)\n{\n    return drawOver(c, color, sdSegment(p, a, b) - radius);\n}\n\nconst float figureThickness = 0.04;\n\nvec3 drawArm(vec3 c, vec2 p, XArm xarm, ColArm colArm)\n{\n    c = drawSegment(c, p, xarm.shoulder, xarm.elbow, colArm.upper, figureThickness);\n    c = drawSegment(c, p, xarm.elbow   , xarm.hand , colArm.lower, figureThickness);\n    return c;\n}\n\nvec3 drawLeg(vec3 c, vec2 p, XLeg xleg, ColLeg colLeg)\n{\n    c = drawSegment(c, p, xleg.hip  , xleg.knee , colLeg.upper, figureThickness);\n    c = drawSegment(c, p, xleg.knee , xleg.ankle, colLeg.lower, figureThickness);\n    c = drawSegment(c, p, xleg.ankle, xleg.toe  , colLeg.foot , figureThickness);\n    return c;\n}\n\nvec3 drawCircle(vec3 c, vec2 p, vec2 center, float radius, vec3 color)\n{\n    return drawOver(c, color, distance(p, center) - radius);\n}\n\nvec3 drawBody(vec3 c, vec2 p, XBody xbody, ColBody colBody)\n{\n    c = drawArm(c, p, xbody.armLeft, colBody.armLeft);\n    c = drawLeg(c, p, xbody.legLeft, colBody.legLeft);\n    c = drawCircle(c, p, xbody.head, 0.5, colBody.head);\n    c = drawSegment(c, p, xbody.armLeft.shoulder, xbody.legLeft.hip, colBody.spine, figureThickness);\n    c = drawLeg(c, p, xbody.legRight, colBody.legRight);\n    c = drawArm(c, p, xbody.armRight, colBody.armRight);\n    return c;\n}\n\n\n//\n// Animation curves\n//\n\nvoid base_pose(out float ang1, out float ang2, out float ang3, float t, float r1, float r2, float r3)\n{\n    float t1, t2, t3;\n\n    t1=t;\n    t2=(1.0 + sin(t+PI));\n    t3=(1.0 + sin(t+PI));\n\n    ang1 = r1 * sin(t1);\n    ang2 = r2 * sin(t2);\n    ang3 = r3 * sin(t3);\n}\n\nvoid dont_trip_over(inout float f, inout float ang2, inout float ang3, float t)\n{\n    float lift = 1.2;\n    float drop = 4.7;\n    float b2 =  0.7;\n    float b3 = -0.9;\n\n    float phase = mod(t, TWO_PI);\n\n    // use this, to see where the action is active\n    // also helps with adjusting lift, drop, b2 and b3.\n    //if (lift < phase && phase < drop) ang2 += b2;\n    //if (lift < phase && phase < drop) ang3 += b3;\n\n    f *=\n      + smoothstep(lift, lift + 1.8, phase) // lift the leg smoothly\n      - smoothstep(drop - 1.5, drop, phase) // drop the leg smoothly\n      ;\n\n    // use this, to get the final smooth motion.\n    ang2 += b2 * f;\n    ang3 += b3 * f;\n}\n\nvoid horizontal_while_foot_on_ground(inout float f, inout float ang3, float t, float ang1, float ang2)\n{\n    float start = 4.7;\n    float duration = 2.8;\n\n    float phase = mod(t - start, TWO_PI);\n    \n    float angFlat = -ang1-ang2;\n\n    // use this, to see where the action is active\n    // also helps with adjusting start and duration.\n    //if (phase < duration) ang3 = angFlat-1.;\n\n    f *=\n      + smoothstep(0., 0.5, phase) // lift the leg smoothly\n      - smoothstep(duration - 1.2, duration, phase) // drop the leg smoothly\n      ;\n\n    // use this, to get the final smooth motion.\n    ang3 = mix(ang3, angFlat, f);\n}\n\n\n//\n// Action + Angle structs\n//\n\nstruct ActLeg\n{\n    float trip, ground;\n};\n\nstruct ActBody\n{\n    ActLeg legLeft, legRight;\n};\n\nstruct AngArm\n{\n    float shoulder, elbow;\n};\n\nstruct AngLeg\n{\n    float hip, knee, foot;\n    float fTrip, fGround;\n};\n\nstruct AngBody\n{\n    AngArm armLeft, armRight;\n    AngLeg legLeft, legRight;\n};\n\nAngLeg poseLeg(float t, ActLeg actLeg)\n{\n    float ang1, ang2, ang3;\n\n    base_pose(ang1, ang2, ang3, t, 0.6, 0.3, 0.2);\n    dont_trip_over(actLeg.trip, ang2, ang3, t);\n    horizontal_while_foot_on_ground(actLeg.ground, ang3, t, ang1, ang2);\n    \n    return AngLeg(ang1, ang2, ang3, actLeg.trip, actLeg.ground);\n}\n\nAngArm poseArm(float t)\n{\n    float ang1, ang2, ang3;\n\n    base_pose(ang1, ang2, ang3, t, 0.6, 0.2, 0.2);\n    \n    return AngArm(ang1, ang2);\n}\n\nAngBody poseBody(float t, ActBody actBody)\n{\n    return AngBody(\n        poseArm(t + .3                 ), poseArm(t + PI + .3                  ),\n        poseLeg(t     , actBody.legLeft), poseLeg(t + PI     , actBody.legRight)\n    );\n}\n\n\n//\n// Transforms\n//\n\nXArm bendArm(XArm xarm, AngArm angArm)\n{\n    vec2 v0 =                           xarm.shoulder;\n    vec2 v1 =              xarm.elbow - xarm.shoulder;\n    vec2 v2 = xarm.hand  - xarm.elbow                ;\n\n    vec2 q0 =                                          v0;\n    vec2 q1 = q0 + R(angArm.shoulder               ) * v1;\n    vec2 q2 = q1 + R(angArm.shoulder + angArm.elbow) * v2;\n\n    return XArm(q0, q1, q2);\n}\n\nXLeg bendLeg(XLeg xleg, AngLeg angLeg)\n{\n    vec2 v0 =                                      xleg.hip;\n    vec2 v1 =                          xleg.knee - xleg.hip;\n    vec2 v2 =             xleg.ankle - xleg.knee           ;\n    vec2 v3 = xleg.toe  - xleg.ankle                       ;\n\n    vec2 q0 =                                                  v0;\n    vec2 q1 = q0 + R(angLeg.hip                            ) * v1;\n    vec2 q2 = q1 + R(angLeg.hip + angLeg.knee              ) * v2;\n    vec2 q3 = q2 + R(angLeg.hip + angLeg.knee + angLeg.foot) * v3;\n\n    return XLeg(q0, q1, q2, q3);\n}\n\nXBody bendBody(XBody xbody, AngBody angBody)\n{\n    return XBody(\n        xbody.head,\n        bendArm(xbody.armLeft, angBody.armLeft),\n        bendArm(xbody.armRight, angBody.armRight),\n        bendLeg(xbody.legLeft, angBody.legLeft),\n        bendLeg(xbody.legRight, angBody.legRight)\n    );\n}\n\nfloat lowest_point_on_leg(XLeg xleg)\n{\n    return min(xleg.ankle, xleg.toe).y;\n}\n\nfloat lowest_point_on_body(XBody xbody)\n{\n    return min(lowest_point_on_leg(xbody.legLeft), lowest_point_on_leg(xbody.legRight));\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 col = gray;\n    \n    vec2 mouse = vec2(1);\n    if (iMouse.z > .5)\n        mouse = iMouse.xy / iResolution.xy;\n    \n    ActLeg actLeg = ActLeg(mouse.x, mouse.y);\n    ActBody actBody = ActBody(actLeg, actLeg);\n\n    float t = iTime;\n    AngBody angBody = poseBody(t, actBody);\n    XBody worldBody = bendBody(xbody, angBody);\n\n    // animation\n    {\n        float ground = lowest_point_on_body(worldBody);\n\n        vec2 uv = fragCoord / iResolution.y * 2.;\n        uv *= 7.;\n        uv -= vec2(2, 1. - ground);\n\n        col = drawBody(col, uv, worldBody, colBody);\n        col = drawSegment(col, uv - vec2(-0.8, ground), vec2(0, 0), vec2(6.5, 0), water, 0.08);\n    }\n    \n    // graphs\n    {\n        vec2 uv = (fragCoord + .5 - iResolution.xy / 2.) / iResolution.y * 2.;\n        uv -= vec2(.65, 0.);\n        uv /= 2.;\n\n        float t1 = uv.x * TWO_PI;\n        AngBody angBody1 = poseBody(t1, actBody);\n        XBody worldBody1 = bendBody(xbody, angBody1);\n        float ground1 = lowest_point_on_body(worldBody1);\n        \n        if (uv.x >= -.5 && uv.x <= +.5)\n        {\n            float phase = mod(t + PI, TWO_PI);\n            vec2 offset = vec2(.5, 0.);\n            vec2 scale = vec2(1. / TWO_PI, .1);\n\n            uv.y -= .35;\n            col = drawDashed(col, uv, colBody.legLeft.lower*.5, angBody1.legLeft.fTrip * .1);\n            col = drawDashed(col, uv, colBody.legLeft.foot*.5, angBody1.legLeft.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft.upper, angBody1.legLeft.hip  * scale.y);\n            col = drawGraph(col, uv, colBody.legLeft.lower, angBody1.legLeft.knee * scale.y);\n            col = drawGraph(col, uv, colBody.legLeft.foot , angBody1.legLeft.foot * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.hip )*scale-offset, .01, colBody.legLeft.upper);\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.knee)*scale-offset, .01, colBody.legLeft.lower);\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.foot)*scale-offset, .01, colBody.legLeft.foot );\n\n            uv.y += .25;\n            col = drawDashed(col, uv, colBody.legRight.lower*.5, angBody1.legRight.fTrip * .1);\n            col = drawDashed(col, uv, colBody.legRight.foot*.5, angBody1.legRight.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legRight.upper, angBody1.legRight.hip  * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, angBody1.legRight.knee * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.foot , angBody1.legRight.foot * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.hip )*scale-offset, .01, colBody.legRight.upper);\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.knee)*scale-offset, .01, colBody.legRight.lower);\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.foot)*scale-offset, .01, colBody.legRight.foot );\n\n            uv.y += .25;\n            scale.y = .05;\n            col = drawDashed(col, uv, colBody.legLeft.lower*.5, angBody1.legLeft.fGround * .1);\n            col = drawDashed(col, uv, colBody.legRight.lower*.5, angBody1.legRight.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft .lower, (worldBody1.legLeft .ankle.y-ground1) * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, (worldBody1.legRight.ankle.y-ground1) * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legLeft .ankle.y-ground1)*scale-offset, .01, colBody.legLeft .lower);\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legRight.ankle.y-ground1)*scale-offset, .01, colBody.legRight.lower);\n\n            uv.y += .25;\n            scale.y = .02;\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft .lower, (worldBody1.legLeft .ankle.x) * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, (worldBody1.legRight.ankle.x) * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legLeft .ankle.x)*scale-offset, .01, colBody.legLeft .lower);\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legRight.ankle.x)*scale-offset, .01, colBody.legRight.lower);\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 173, 173, 239], [241, 241, 293, 372, 489], [1728, 1728, 1772, 1772, 1847], [1849, 1849, 1903, 1903, 1998], [2000, 2000, 2055, 2055, 2262], [2264, 2264, 2340, 2340, 2402], [2441, 2441, 2497, 2497, 2683], [2685, 2685, 2741, 2741, 3003], [3005, 3005, 3077, 3077, 3140], [3142, 3142, 3203, 3203, 3602], [3632, 3632, 3735, 3735, 3898], [3900, 3900, 3981, 3981, 4562], [4564, 4564, 4668, 4668, 5190], [5522, 5522, 5562, 5562, 5835], [5837, 5837, 5862, 5862, 5980], [5982, 5982, 6026, 6026, 6218], [6242, 6242, 6282, 6282, 6657], [6659, 6659, 6699, 6699, 7248], [7250, 7250, 7296, 7296, 7542], [7544, 7544, 7582, 7582, 7624], [7626, 7626, 7667, 7667, 7758], [7775, 7775, 7827, 7827, 12228]], "test": "error"}
{"id": "7tGGzV", "name": "Mandelbrot Point Traps", "author": "adamjmurray", "description": "Colored using a moving point trap", "tags": ["fractals"], "likes": 4, "viewed": 36, "published": "Public", "date": "1637992552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_ITERATIONS = 50.0;\nconst vec2 CENTER = vec2(-0.5, 0);\nconst float INFINITY = 10000000000.; // 1./0.; dividing by zero seems to give infinity in WebGL2 outside shadertoy\n\nvec3 hsl2rgb(float h, float s, float l) {\n  float hp = 6. * mod(h,1.);\n  float c = s - s * abs(2.*l - 1.);\n  float x = c - c * abs(mod(hp,2.) - 1.);\n  float m = l - c/2.;\n  if      (hp <= 1.) return vec3(c,x,0) + m;\n  else if (hp <= 2.) return vec3(x,c,0) + m;\n  else if (hp <= 3.) return vec3(0,c,x) + m;\n  else if (hp <= 4.) return vec3(0,x,c) + m;\n  else if (hp <= 5.) return vec3(x,0,c) + m;\n  else               return vec3(c,0,x) + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 coord = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 z = vec2(0, 0);\n    vec2 c = coord + CENTER;\n     \n    vec2 trap = vec2(\n      sin(iTime/1.3),\n      sin(iTime/1.7)\n    );    \n    float trapDistance = INFINITY;\n\n    float i = 0.0;\n    while (i < MAX_ITERATIONS) { \n      z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n\n      trapDistance = min(trapDistance, length(z - trap));\n      \n      if (length(z) > 4.) break;\n      i++;\n    }\n\n    if (i >= MAX_ITERATIONS) {\n      fragColor = vec4(0,0,0,1);      \n    } \n    else {  \n      float escapeSpeed = (i - log2(log(length(z)))) / MAX_ITERATIONS;\n      float trapDistance = min(trapDistance, 1.);\n      fragColor = vec4(\n        hsl2rgb(\n          escapeSpeed + iTime/10.,          \n          .7,\n          1. - trapDistance\n        ),\n        1\n      );     \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 227, 227, 628], [630, 630, 687, 687, 1527]], "test": "valid"}
{"id": "7tj3RD", "name": "Twinkle Twinkle little star", "author": "eurigilberto", "description": "Testing sigmoid functions", "tags": ["star"], "likes": 0, "viewed": 66, "published": "Public", "date": "1637091861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sigmoid(float x, float k){\n    return (x - k*x)/(k - 2.*k*abs(x) + 1.);\n}\n\nvec4 twinkleStar(vec2 uv, vec2 offset, float scale, float timeOffset){\n    uv += offset;\n    \n    uv -= 0.5;\n    uv *= 2.;\n    uv *= scale;\n    \n    vec2 normalUV  = uv;\n    \n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n    \n    float limit = step(1.0, step(1.0, uv.x) + step(1.0, uv.y));\n    \n    limit = 1. - limit;\n    \n    uv.x = 1.-uv.x;\n    \n    float currentTime = iTime + timeOffset;\n    float animTime = sin(currentTime * 3.14 * 2.)*0.5 + 0.5;\n    float value = 1. - step(sigmoid(uv.x - 0.005, 0.9 + animTime*0.1) - 0.005, uv.y);\n    \n    float animTime2 = sin(currentTime * 5.)*0.5 + 0.5;\n    float ring = sigmoid(1.-length(normalUV), 0.8);\n    value *= sigmoid(1.-length(normalUV), 0.1) * 1.5;\n    value = min(1., value);\n    \n    return vec4(1.,1.,1.,1.0)*value*limit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/(iResolution.y/2.);\n    \n    fragColor = twinkleStar(uv, vec2(-0.5,-0.5), 3.0, 1.0) + \n    twinkleStar(uv, vec2(-1.2,-0.8), 2.0, 0.25) + \n    twinkleStar(uv, vec2(-1.5,0.3), 1.5, 0.4) +\n    twinkleStar(uv, vec2(-2.1,-0.5), 1.75, 0.15);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 79], [81, 81, 151, 151, 862], [864, 864, 921, 971, 1233]], "test": "valid"}
{"id": "7tK3zh", "name": "Ray Marching with a sphere", "author": "mvilay02", "description": "cs44n baby", "tags": ["raymarching"], "likes": 4, "viewed": 74, "published": "Public", "date": "1637187861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// BASIC RAY-MARCHING CLASS DEMO!\n//\n// Numerous methods borrowed from iq articles:\n//   https://iquilezles.org/www/index.htm\n// \n// 3D signed distance functions:\n//   https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// \n// Shadows:\n//   https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// \n// Ray-marching SDFs:\n//   https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n// \n// Normals for SDFs:\n//   https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n// subtracts d1 from d2\n\n//lighting from spsherk_ https://www.shadertoy.com/view/Wlc3WN\n//based on https://www.shadertoy.com/view/XtGfWG\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define MIN_DIST .0001\n\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n        return distance(p, c) - r + texture(iChannel2, p.xy).r / ((sin(iTime) + 1.) * 100.);\n\n}\n//gets distance from point p to edge of a sphere\nfloat getDist(vec3 p) {\n    return sdfSphere(p, vec3(0.), 1.);\n}\n\n//normalizing the vector by getting an epsilon and subtracting it from our \n//2d vector and normalizing the values into a 3d vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0025, -.0025); \n    return normalize(vec3(getDist(p - e.xyy), getDist(p + e.yxy), getDist(p + e.yyx)));\n}\nfloat rayMarch(vec3 rayOrigin, vec3 rayDist) {\n    float dist = 0.;\n    \n    //using iteration for our ray marching loop \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 itPos = rayOrigin + rayDist * dist;\n        float itDist = getDist(itPos);\n        \n        dist += itDist;\n        \n        //once we've reached our desired \"MAX_DIST\", then we break the loop\n        if (dist > MAX_DIST || dist < MIN_DIST) {\n            break;\n        }\n    }\n    return dist;\n}\n\n//using dot product to create lighting \nfloat getLight(vec3 p)\n{\n    vec3 lightPos = vec3(sin(iTime * 4.), 3., -3.);\n    vec3 lightDirection = normalize(p - lightPos);\n    \n    return -dot(getNormal(p), lightDirection);    \n    //float d = -dot(getNormal(p), lightDirection);\n\t//float col =   1. / (5.5* d + 1.5*d);\n\t//float col = .1*exp(1./(5.5*d + 3.*d));\n    //return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y; // w/h are equal\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float focalDist = .7;\n    vec3 rayOrigin = vec3(-1,0.,-2);\n    vec3 rayOrigin2 = vec3(1,0.,-2);\n    vec3 rayDist = vec3(uv.x, uv.y, focalDist);\n    \n    float dist = rayMarch(rayOrigin, rayDist);\n    float dist2 = rayMarch(rayOrigin2, rayDist);\n    \n    if (dist < MAX_DIST) {\n        //point to edge of a sphere (SDF)\n        vec3 pEdge = rayOrigin + rayDist * dist;\n        col = vec3(2., 0.4, 0.3);\n        col *= vec3(getLight(pEdge));\n        \n    }\n    \n    if (dist2 < MAX_DIST) {\n        vec3 pEdge = rayOrigin2 + rayDist * dist2;\n        col = vec3(2., 0.4, 0.3);\n        col *= vec3(getLight(pEdge));\n        \n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[726, 726, 768, 768, 864], [865, 914, 937, 937, 978], [980, 1112, 1136, 1136, 1261], [1262, 1262, 1308, 1308, 1735], [1737, 1777, 1801, 1801, 2114], [2117, 2117, 2174, 2211, 3072]], "test": "error"}
{"id": "7tKGz1", "name": "Picture frames", "author": "jarble", "description": "An arrangement of decorated wooden frames.", "tags": ["fractal", "wood", "frame", "carving"], "likes": 3, "viewed": 109, "published": "Public API", "date": "1637192027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 9.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    //vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    //vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 9; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                \n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv-offset/scale2,scale)*bend;\n                //bend += 1./(1.+uv.x+uv.y);\n                bend *= -1.;\n                //bend -= 1./3.-col.x;\n                \n                //uv += vec2(random1[k],random2[k]);                \n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2456]], "test": "valid"}
{"id": "7tKGzh", "name": "Dithering pattern no sampling", "author": "smarchevsky", "description": "Function only 16x16 dither.\nFeel free to optimize, if you want.", "tags": ["dither"], "likes": 3, "viewed": 56, "published": "Public", "date": "1637176508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// personal implementation\nfloat pattern(vec2 pos){\n    vec4 p0 = floor(mod(vec4(pos, pos * 0.5), vec4(2)));\n    vec4 p1 = floor(mod(vec4(pos * 0.25, pos * 0.125), vec4(2)));\n    \n    //  |0 2|\n    //  |3 1| pattern is used in 2x2, 4x4, 8x8, 16x16 scales (p.xy, p.zw, p2.xy, p2.zw)\n\n    float res = 0.;\n    \n    // ver 1 is slower!\n    //res += dot(mod(p0 * vec4(2, 3, 2, 3) * mat2x4(1,1,0,0,0,0,1,1), 4.),  vec2(64, 16)); // 2x2 & 4x4\n    //res += dot(mod(p1 * vec4(2, 3, 2, 3) * mat2x4(1,1,0,0,0,0,1,1), 4.),  vec2(4, 1));   // 8x8 & 16x16\n    \n    // ver 0\n    res += mod(dot(p0.xy * vec2(2, 3), vec2(1)), 4.) * 64.;   // 2x2\n    res += mod(dot(p0.zw * vec2(2, 3), vec2(1)), 4.) * 16.;   // 4x4\n    res += mod(dot(p1.xy * vec2(2, 3), vec2(1)), 4.) * 4.;   // 8x8\n    res += mod(dot(p1.zw * vec2(2, 3), vec2(1)), 4.);        // 16x16\n    \n    return float(res + 0.5) / 256.;\n}\n\n// Bayer implementation matrix https://www.shadertoy.com/view/XtV3RGx\n#define iterBayerMat 6 //size of bayer\n#define bayer2x2(a)(4-(a).x-((a).y<<1))%4\n//return bayer matrix(bitwise operands for speed over compatibility)\nfloat GetBayerFromCoordLevel(vec2 pixelpos) //https://www.shadertoy.com/view/XtV3RG\n{\n    ivec2 p = ivec2(pixelpos); int a=0; \n    for(int i=0;i<iterBayerMat;i++)\n        a += bayer2x2(p>>(iterBayerMat - 1 - i) & 1) << ( 2 * i);\n    return float(a) / float( 2 << (iterBayerMat * 2-1) );\n}\n\n\nfloat dither(vec2 fragCoord, float value){\n    //return float(value > GetBayerFromCoordLevel(fragCoord));\n    return float(value > pattern(fragCoord));\n}\n\nvec3 dither3(vec2 fragCoord, vec3 val){\n    return vec3(greaterThan(val, vec3(pattern(fragCoord))));\n}\n\nvec3 getColor(vec2 uv) { return pow(sin(iTime * 0.1 * vec3(0.2, 0.13, .923) + vec3(uv.x * 2., uv.y * 2.3, (uv.y + uv.x * .7444))), vec3(2));}\nfloat getFloat(vec2 uv) { return pow(sin(iTime * 0.1 + uv.x * 3.1415926), 2.); }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // performance check\n    int num = 1000000;\n    float fnum = float(num);\n    \n    vec3 col = getColor(uv);\n    //for(int i = 0; i < num; ++i)\n    fragColor.rgb += dither3(fragCoord, col);\n    \n    \n    \n    \n    //fragColor = vec4(dither3(fragCoord, col), 0.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 51, 51, 878], [1031, 1100, 1185, 1185, 1388], [1391, 1391, 1433, 1496, 1544], [1546, 1546, 1585, 1585, 1648], [1650, 1650, 1674, 1674, 1791], [1792, 1792, 1817, 1817, 1872], [1875, 1875, 1930, 1930, 2243]], "test": "valid"}
{"id": "7tt3Dj", "name": "Shifty States", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 2, "viewed": 97, "published": "Public API", "date": "1636769932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv.x /= cosh(1.5 * uv.x);\n    \n    float a = atan(uv.y, uv.x);\n    float r = uv.x * thc(4., 1. * length(uv) + 0.5 * iTime) + uv.y * ths(4.,0.5 * iTime);\n\n    float time = 40. * r + 1. * a + 2. * iTime;\n    float str = 4.;// * cos(uv.x * 20.);\n    float v = 100.;\n\n    float sc = 0.75 + 0.25 * thc(4., .25 * iTime);\n    vec2 p = 0.3 * vec2(thc(cos(v * uv.x + time) * str, sc * v * uv.x + time), \n                        ths(sin(v * uv.y + time) * str, sc * v * uv.y + time));\n                        \n    float d = length(uv-p);\n    float s = smoothstep(-0.01,0.01,0.1 - d);\n    vec3 col = vec3(s);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 201, 201, 904]], "test": "valid"}
{"id": "7tt3RH", "name": "wavy lines", "author": "megan023", "description": "time varying sine and cosine curves", "tags": ["graphs"], "likes": 0, "viewed": 11, "published": "Public", "date": "1635740047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2( fragCoord.xy / iResolution.xy );\n    \n    vec4 col1=vec4(0.5,0.8,0.9,1.0);\n    vec4 col2 = vec4(0.4,0.75,0.9,1);\n    \n    float x = (iTime/2.0)+uv.x;\n    float line1 = ((0.3)*sin(5.0*x)+(0.5)*sin(2.0*x)+0.2*sin(0.2*x)+1.0);//4.0;\n    float line2 = 0.3*sin(0.2*x)+(0.2)*sin(7.0*x)+0.3*sin(-7.0*x)+1.0;\n    float line3 = 0.2*cos(4.0*x)+(0.5)*cos(0.3*x)+0.2*cos(9.0*x)+1.0;\n    float line4 = (0.33*cos(5.0*x)+(0.75)*cos(2.0*x)+0.8*cos(0.2*x)+1.0);\n    //float line3 = 0.2*cos(4.0*x)+(0.5)*cos(0.3*x)+0.2*cos(9.0*x)+1.0;\n    \n    vec4 c = col2;\n    if (uv.y < line1 && uv.y > line1-0.02) c = col1;\n    if (uv.y < line2 && uv.y > line2-0.02) c = col1;\n    if (uv.y < line3 && uv.y > line3-0.01) c = col1;\n    if (uv.y < line4 && uv.y > line4-0.01) c = col1;\n    \n    fragColor=c;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 905]], "test": "valid"}
{"id": "7tt3W2", "name": "Footwear Design 004", "author": "yasuo", "description": "・Modeled as the EVA form shoes that all materials are being used the EVA material included the outsole.\n・Implemented wavy upper shape with small holes for breathability\n・Implemented hexagonal traction pattern as the outsole.", "tags": ["footwear"], "likes": 4, "viewed": 107, "published": "Public API", "date": "1636781418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    p.x = mod(p.x,0.1)-0.05;\n    p.z = mod(p.z,0.08)-0.04;\n    p.zy*=Rot(radians(90.0));\n    float d2 = sdHexPrism(p,vec2(0.03,0.03))*0.6;\n    \n    p = prevP;\n    p.x-=0.05;\n    p.z-=0.065;\n    p.x = mod(p.x,0.1)-0.05;\n    p.z = mod(p.z,0.08)-0.04;\n    p.zy*=Rot(radians(90.0));\n    float d3 = sdHexPrism(p,vec2(0.03,0.03))*0.6;\n    d2 = min(d2,d3);\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\n    //vec3 prevP = p;\n    //p.y+=sin(p.z*200.0)*0.0025;\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    p.x+=sin(p.y*100.0)*0.0025;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n        \n    \n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.15;\n    p.z+=0.015;\n    p.z=abs(p.z);\n    p.z-=0.035;\n    d2 =sdSimpleCylinder(p-vec3(-0.18,0.0,-0.015),0.015,0.5);\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.23;\n    d2 =sdSimpleCylinder(p-vec3(-0.18,0.0,0.06),0.015,0.5);\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.145),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.115),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    d =  opSmoothUnion(d,d2,0.03);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.8,0.7));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1273, 1309, 1309, 1582], [1584, 1659, 1692, 1692, 1757], [1759, 1834, 1886, 1886, 1993], [1995, 2070, 2101, 2101, 2188], [2190, 2265, 2302, 2302, 2385], [2387, 2462, 2521, 2521, 2834], [2836, 2836, 2885, 2885, 2958], [2960, 2960, 2995, 2995, 3403], [3405, 3405, 3427, 3427, 4383], [4386, 4386, 4410, 4410, 5412], [5471, 5471, 5491, 5491, 6735], [6737, 6737, 6759, 6759, 7013], [7015, 7015, 7073, 7073, 7340], [7342, 7342, 7366, 7366, 7567], [7569, 7569, 7611, 7611, 7806], [7808, 7849, 7898, 7898, 8192], [8194, 8194, 8251, 8251, 8870], [8872, 8872, 8894, 8894, 8984], [8986, 8986, 9045, 9045, 9151], [9153, 9153, 9210, 9210, 10254]], "test": "valid"}
{"id": "7tt3Wr", "name": "BrickTileable", "author": "EvilRyu", "description": "hmm...", "tags": ["normalmap", "brick", "tileable", "tile"], "likes": 6, "viewed": 154, "published": "Public API", "date": "1636043090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat brick(vec2 p)\n{\n    // offset for each row\n    float offset = sqrt(floor(mod(p.y,2.)+16.)*16.);\n    p.x += offset;\n    \n    vec2 m = floor(p);\n    vec2 n = fract(p)*2.-1.;\n        \n    vec2 nn = pow(n, vec2(10.));\n    float d = pow(nn.x+nn.y, .1)-0.07; // controls size of the brick\n    \n    // tune softness\n    //return pow(smoothstep(1., .8,d),5.);\n    return pow(smoothstep(1., .8,d),1.);\n}\n\nvec3 shading(vec3 n)\n{\n    vec3 L = normalize(vec3(-.7,.8,1.));\n    float dif = max(0., dot(L, n));\n    return vec3(dif);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= vec2(4.*iResolution.x/iResolution.y,6.);\n    uv.xy += iTime;\n        \n    vec2 eps=vec2(.012,0);\n    vec3 nor = normalize(vec3(brick(uv-eps.xy) - brick(uv+eps.xy),\n                              brick(uv-eps.yx) - brick(uv+eps.yx),1.));\n    \n    vec3 col = shading(nor);\n    if(fragCoord.x > iResolution.x*.5) col = vec3(nor*.5+.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3Wr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[111, 111, 132, 159, 511], [513, 513, 535, 535, 636], [638, 638, 695, 695, 1111]], "test": "valid"}
{"id": "7tt3z2", "name": "Path of the shader - 1.", "author": "SOMATICBITS", "description": "1. shader on the path to learning shaders.", "tags": ["somaticbits"], "likes": 3, "viewed": 74, "published": "Public", "date": "1636392786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Note: using clamp a lot to keep sure values stay between 0. and 1. \n// and act in a consistent way with colors\n// Most of the knowledge acquired in this shader comes from Flopine's tutorials\n// https://www.twitch.tv/flopine/\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat circle(vec2 uv) {\n    return length(uv);\n}\n\nfloat square(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, uv.y);;\n}\n\n// smoothstep on pixel width\nfloat ss(float s, float size) {\n    float w = fwidth(s);\n    return smoothstep(size+w, size-w, s);\n}\n\nfloat shape(vec2 uv) {\n    return clamp(ss(square(uv),.2) - ss(circle(uv),.15),0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv *= 6.;\n    uv += .5; // adjustment for centering\n    \n    vec2 guv = fract(uv)-.5; // grid + center coords\n    vec2 id = floor(uv); // gives id of each cell\n    guv *= rot(iTime - (length(id)+0.1)*0.3); // rotate uv starting from center\n    guv *= cos(.3*(length(id)-iTime)); // scale uv\n    \n    float s = shape(guv); // add shape\n    \n    vec3 col = clamp(vec3(s),0.,1.) + 0.1;\n    col.r += clamp(cos(.2*(length(id)-iTime)),0.,1.); // cycle color\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 248, 248, 300], [302, 302, 325, 325, 350], [352, 352, 375, 375, 424], [426, 455, 486, 486, 555], [557, 557, 579, 579, 645], [648, 648, 705, 705, 1269]], "test": "valid"}
{"id": "7tt3zM", "name": "jneen - volumetric fog", "author": "jneen", "description": "fog! in a shape!", "tags": ["fog"], "likes": 4, "viewed": 66, "published": "Public", "date": "1635905706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rad(x) (radians(360.*(x)))\n#define time (iTime*.1)\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat glow;\n\n#define tri(x) (abs(fract((x)*.5)-.5)*2.)\n\nfloat scene(vec3 p) {\n  float bg = box(p+vec3(0,5+1,0),vec3(5));//p.y + 2.;\n  vec3 orig_p = p.xyz;\n  p.xz *= rot(rad(3.*time));\n  p.xy *= rot(rad(3.*time*sqrt(2.)));\n  p.yz *= rot(rad(2./6.));\n  \n  // define the glow as a regular sdf float\n  float B = box(p, vec3(1))-.3;\n  float S = sphere(p, 2.*(tri(time*2.)));\n  float glowbox = max(B,-S);\n\n  p = orig_p;\n  p -= sin(time*6.);\n  p.xz *= rot(time*10.);\n  p.yz *= rot(time*20.);\n  p.xy *= rot(time*30.);\n  float squeeze = 4.8;\n  float solid = mix(sphere(p,.1+2.*tri(time*2.)),box(p,vec3(.5)-.2),.5+.5*sin(time*17.));\n  \n  // a buffer between the solid and the fog to prevent\n  // super-bright areas on the solid as the raymarcher\n  // slows down. try setting this to 0 and see what happens\n  // should be at least DENSITY\n  // raising this is the best way to deal with edge glow around\n  // the solid\n  float BUFFER_ZONE = 0.05;\n  \n  \n  // lower = more dense fog. should be at least 1/stepcount\n  // (100 here)\n  float FOGSTEP = .001;\n\n  // ==== and here's the 2-line fog effect ====\n  // * if we're inside the glowbox, increase the glow by how far\n  // we have penetrated into the box.\n  // * however, if we're passing close to the solid object, we have to\n  // not increase the glow because it will overcount as we step closer\n  // and closer to the solid. so we zero it out below the buffer zone\n  glow += max(0., -glowbox)*smoothstep(0.,BUFFER_ZONE*2.,solid);\n  // step towards the glowbox by the distance we are inside the cube,\n  // plus a little buffer to get us inside the box. if we're *in* the\n  // box, we want to keep moving, and abs(glowbox) will make sure we're\n  // approximately inside the box still. note that we will *never* detect\n  // a surface at any point of the glowbox, because the minimum distance is\n  // always positive.\n  glowbox = abs(glowbox) + FOGSTEP;\n  return min(bg,min(solid,glowbox));\n}\n\n\nfloat ray(vec3 start, vec3 dir) {\n  float dist=0.;\n  glow=0.;\n  \n  for (int i=0;i<700;i++) {\n    float c = scene(start+dir*dist);\n    dist += c;\n    if (c < .0001) return dist;\n    if (dist > 1000.) return 10001.;\n  }\n  \n  return min(dist,10001.);\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p) - mat3(.01);\n  return scene(p)-vec3(scene(K[0]),scene(K[1]),scene(K[2]));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float focus=2.;\n    vec3 cam = vec3(0,0,-5.*focus);\n    vec3 dir = normalize(vec3(uv,focus));\n    \n    float dist = ray(cam, dir);\n    float G = glow; \n    vec3 hit = cam+dir*dist;\n    vec3 norm = normalize(grad(hit));\n    \n    vec3 refl = reflect(dir,norm);\n    float refldist = ray(hit+refl*.1, refl);\n    float reflglow = glow;\n    \n    // thanks blackle for the awesome fake image lighting :3\n    float diff = 0.;\n\n    if (dist < 1000.) diff = length(sin(norm)*.5+.5)/sqrt(3.);\n\n    \n    vec3 col = diff*diff*vec3(.5,.9,1);\n    \n    // lower numbers are a denser, more uniform fog\n    // high numbers are very glowy and a little glitchy\n    float UNIFORMITY = 0.8;\n    col += pow(G, UNIFORMITY) *.2 * vec3(.9, .1,.5);;\n    col += reflglow * vec3(.9,.1,.5)*.2;\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 87, 87, 168], [170, 170, 201, 201, 225], [227, 227, 246, 246, 296], [353, 353, 374, 374, 2225], [2228, 2228, 2261, 2261, 2477], [2479, 2479, 2498, 2498, 2597], [2600, 2600, 2657, 2707, 3638]], "test": "valid"}
{"id": "7ttGDn", "name": "Lava planet shader", "author": "pancakespeople", "description": "A modification of my planet shader to make a lava planet", "tags": ["lavaplanet"], "likes": 7, "viewed": 182, "published": "Public API", "date": "1636017494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.7;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * 4.0;\n    vec3 sph = vec3(uv.x, uv.y, cos(length(uv)));\n\n    float r = length(uv);\n\tfloat f = (1.0 - sqrt(1.0 - r)) / r;\n    vec3 sunPos = vec3(cos(iTime / 4.0), 0.0, sin(iTime / 4.0));\n    float light = dot(sph, sunPos);\n    float reflectivity = 1.0;\n\n    float noiseVal = fbm((uv * f * 5.0) + 500.0) + 0.5;\n    float cloudNoise = fbm((uv * f * 2.0 + vec2(-iTime / 8.0, 0.0)) + 1000.0) + 0.5;\n    //cloudNoise *= rotate(iTime);\n    vec3 col = vec3(0.0);\n    \n    if (r < 1.0) {\n        if (noiseVal < 0.35) {\n            col = vec3(1.0, 0.0, 0.0);\n            light = 0.5;\n        }\n        else if (noiseVal > 0.65) {\n            col = vec3(1.0, 1.0, 1.0) * noiseVal;\n        }\n        else {\n            col = vec3(noiseVal / 4.0, noiseVal / 4.0, noiseVal / 4.0);\n        }\n        reflectivity = noiseVal * 2.0;\n        //col += smoothstep(0.55, 0.6, cloudNoise);\n    }\n    else {\n        col = vec3(0.8, 0.3, 0.3) * smoothstep(1.1, 1.0, r);\n        reflectivity = 0.5;\n    }\n    \n    col *= light;\n    col += smoothstep(1.1, 1.0, r) * light * reflectivity * vec3(1.0, 0.5, 0.5);\n    \n    vec2 suv = uv - sunPos.xy * 3.0;\n    col += 0.1 / length(suv) * smoothstep(0.99, 1.0, r) * smoothstep(0.5, 0.8, -sunPos.z);\n    \n    float flareCol = 0.0;\n    vec2 fuv = suv;\n    float angle = atan(fuv.y, fuv.x) + 3.14159 / 8.0;\n    flareCol += 0.1/abs(sin(angle*4.0)*cos(angle*4.0)) * smoothstep(0.6, 0.0, length(fuv));\n    flareCol *= 0.1/abs(sin(angle*2.0)*cos(angle*2.0)) * smoothstep(0.6, 0.0, length(fuv));\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 4.0;\n    //fuv *= rotate(3.14159 / 4.0);\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 16.0;\n\n    flareCol *= smoothstep(0.7, 0.8, -sunPos.z);\n    flareCol *= smoothstep(0.99, 1.0, length(uv-suv));\n    //flareCol *= smoothstep(0.99, 1.0, r);\n    if (light < 0.01 && r < 1.0) col = vec3(0.0);\n    col += flareCol;\n    \n    col += smoothstep(0.75, 0.0, noiseVal) * vec3(1.0, 0.0, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1143, 3269]], "test": "valid"}
{"id": "7ttGR4", "name": "Turbulent wind", "author": "jarble", "description": "This is not a real fluid simulation, but it looks realistic enough.", "tags": ["fluid", "turbulence", "weather", "wind"], "likes": 5, "viewed": 160, "published": "Public API", "date": "1635802914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fluid(vec2 uv1){\n vec2 uv = uv1;\n float t = iTime;\n for (float i = 1.; i < 15.; i++)\n  {\n    uv.x -= (t+sin(t+uv.y*i/1.5))/i;\n    uv.y -= cos(uv.x*i/1.5)/i;\n  }\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord/iResolution.xy*10.;\n uv = fluid(uv);\n float r = abs(sin(uv.x))+.5;\n float g =abs(sin(uv.x+2.+iTime*.2))-.2;\n float b = abs(sin(uv.x+4.));   \n vec3 col = vec3(r,g,b);   \n \n fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 180], [182, 182, 239, 239, 462]], "test": "valid"}
{"id": "7tV3RR", "name": "Julia-Sets Danny", "author": "danieletaat", "description": "Renders julia sets.", "tags": ["fractals"], "likes": 2, "viewed": 39, "published": "Public", "date": "1637086111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float NUM_ITERATIONS = 512.0;\nconst float zoomSpeed = 10.0;\nconst float width = 6.5;\n//const vec2 center = vec2(-0.742978, 0.1);\n//const vec2 center = vec2(-0.747005, 0.150006);\nconst vec2 center = vec2(0.0, 0.0);\n\n\nvec2 C = vec2(0.0, 1.0);\n\nvec2 f(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.y * z.x) + C;\n}\n\nfloat iter(vec2 z) {\n\n    // float nrm = dot(c, c);\n    // http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n    // if( 256.0*nrm*nrm - 96.0*nrm + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n    // http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n    //if( 16.0*(nrm+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    \n    float i;\n    for (i = 0.0; i < NUM_ITERATIONS; i += 1.0) {\n        z = f(z);\n        if (dot(z, z) > 4.0) break;\n    }\n    if (i >= NUM_ITERATIONS) \n        return 0.0;  \n        \n    // smooth out the coloring\n    float si = i - log2(log2(dot(z,z))) + 4.0;\n    float ai = smoothstep( -0.1, 0.0, 0.0);\n    i = mix(i, si, ai);\n\n    return i;\n}\n\nvec2 rotateCoord(vec2 c) {\n    float theta = 3.14 + 3.14 * cos(iTime / 10.0);\n    float x = (c.x - center.x) * cos(theta) - (c.y - center.y) * sin(theta) + center.x;\n    float y = (c.x - center.x) * sin(theta) + (c.y - center.y) * cos(theta) + center.y;\n    return vec2(x, y);\n    \n}\n\nvec2 transformCoord(vec2 fragCoord) {\n    //float rescale = pow(zoomSpeed, -2.75 + 2.75*cos(iTime / 10.0));\n    float rescale = 2.0 - cos(iTime/10.0);\n    vec2 size = vec2(width, iResolution.y / iResolution.x * width) * rescale;\n    vec2 uv = fragCoord/iResolution.xy;\n    return rotateCoord((uv - 0.5) * size + center);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    C.x = 2.0*sin(iTime/20.0);\n    C.y = cos(1.3) + 0.25*cos(iTime);\n    vec2 c = transformCoord(fragCoord);\n    float i = iter(c);    \n    // color calculation\n    vec3 col = 0.5 + 0.5*cos(3.0 + 0.25*i + vec3(0.50, cos(iTime/5.0)/2.0 + 0.5, 0.05));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tV3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 264, 264, 327], [329, 329, 349, 646, 998], [1000, 1000, 1026, 1026, 1283], [1285, 1285, 1322, 1392, 1607], [1609, 1609, 1664, 1664, 1948]], "test": "valid"}
{"id": "7tV3z1", "name": "Transition playground", "author": "Golui", "description": "Playground for a transition animation.\n\nPlease let me know what this pattern is called.", "tags": ["transition"], "likes": 0, "viewed": 27, "published": "Public", "date": "1637199007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n//#define SINGLE_SHOT\n\nconst vec4 color1 = vec4(136.0, 199.0, 220.0, 255.0) / 255.;\nconst vec4 color2 = vec4(199.0, 220.0, 136.0, 255.0) / 255.;\nconst vec4 color3 = vec4(220.0, 136.0, 199.0, 255.0) / 255.;\nconst vec4 color4 = vec4(199.0, 136.0, 220.0, 255.0) / 255.;\nconst vec4 color5 = vec4(220.0, 199.0, 136.0, 255.0) / 255.;\nconst vec4 color6 = vec4(136.0, 220.0, 199.0, 255.0) / 255.;\nconst vec4 color7 = vec4(236.0, 120.0, 109.0, 255.0) / 255.;\nconst vec4 color8 = vec4(120.0, 109.0, 236.0, 255.0) / 255.;\n\n\nconst float delta = 0.8;\nconst float e = exp(1.0);\n\nstruct ColorFun\n{\n    vec4 color;\n    vec2 fun;\n};\n\n// Some trial functions to generate the checkerboard.\n\nvec2 squareWave(vec2 x)\n{\n    return (1.0/atan(1.0/delta))*atan(sin(x)/delta);\n}\n\n// This one seems the most pleasing\nvec2 doubleSine(vec2 x)\n{\n    return sin(sin(x)) / sin(1.0);\n}\n\nvec2 polynomialWave(vec2 x, float powerOverTwo)\n{\n    vec2 z = fract(abs(x / PI));\n    vec2 periodize = sign(fract(abs(x) / (2.0 * PI)) - 0.5) * sign(x);\n    vec2 zPow = pow((z - 0.5) * (z - 0.5), vec2(powerOverTwo));\n    vec2 singleWave = pow(2.0, powerOverTwo * 2.0) * zPow - 1.0;\n    return singleWave * periodize;\n}\n\nvec2 expWave(vec2 x)\n{\n    return 1.0 - 2.0*(exp(sin(x) - 1.0 / e)) / (e - 1.0 / e);\n}\n\nvec2 expWave2(vec2 x)\n{\n    return 1.0 - 2.0*(exp(sin(sin(x)) / sin(1.0) - 1.0 / e)) / (e - 1.0 / e);\n}\n\nColorFun resolveSection(vec2 uv)\n{\n    vec2 arg = uv * 128.0;\n    int num = int(fract(uv.x) * 8.0);\n    vec2 adjArg = vec2(2.0 * arg.x - 0.5 * arg.y, -0.5 * arg.x - 2.0 * arg.y);\n    vec2 val = vec2(0.0);\n    vec4 color;\n    vec2 fun;\n    switch(num)\n    {\n        case 0: return ColorFun(color1, sin(adjArg));\n        case 1: return ColorFun(color2, doubleSine(adjArg));\n        case 2: return ColorFun(color3, squareWave(adjArg));\n        case 3: return ColorFun(color4, polynomialWave(adjArg, 1.0));\n        case 4: return ColorFun(color5, polynomialWave(adjArg, 2.0));\n        case 5: return ColorFun(color6, polynomialWave(adjArg, 3.0));\n        case 6: return ColorFun(color7, expWave(adjArg));\n        case 7: return ColorFun(color8, expWave2(adjArg));\n    }\n}\n\n\nfloat createBandMask(float x, float blurRadius, float width, float base)\n{\n    width -= 2. * blurRadius;\n    return smoothstep(0.0, blurRadius, abs(x - base - width / 2. - blurRadius) - width / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float adjTime = iTime + 0.3;\n#ifdef SINGLE_SHOT\n    adjTime = min(5.0, adjTime);\n#endif\n\n    vec2 uv = fragCoord / iResolution.x;\n\n    float streakAngle = (-1.0 / 3.0 * uv.x - 3.0 * uv.y) / 6.0; // As with the checkerboard, we want the wave at an angle, but a different one.\n    float animProgress = streakAngle + 0.10 * adjTime; // Let's animate it\n    animProgress = fract(animProgress);\n    ColorFun cf = resolveSection(uv);\n    // Get the checkerboard.\n    float mask = (cf.fun.x + cf.fun.y) / 4.0 - 0.5;\n    // Now, we will offset the checkerboard with a smoothed line.\n    // This will create the effect of the checkerboard dots appearing\n    // On the wavefront.\n    // Scaling was used so that when there is no wave, the whole checkerboard is < 0, and behind the front it's > 1\n    float shiftVal = 2.0 * (1.0 - createBandMask(animProgress, 0.21, 0.75, 0.0));\n    float alpha = mask + shiftVal;\n    // https://github.com/glslify/glsl-aastep\n    float aawidth = length(vec2(dFdx(alpha), dFdy(alpha))) / sqrt(2.0);\n    alpha = smoothstep(0.5 - aawidth, 0.5 + aawidth, alpha);\n    float result = clamp(alpha, 0.0, 1.0);\n    fragColor = cf.color * result + cf.color * (1.0 - result) * 0.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tV3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[717, 717, 742, 742, 797], [799, 835, 860, 860, 897], [899, 899, 948, 948, 1218], [1220, 1220, 1242, 1242, 1306], [1308, 1308, 1331, 1331, 1411], [1413, 1413, 1447, 1447, 2180], [2183, 2183, 2257, 2257, 2383], [2385, 2385, 2442, 2442, 3643]], "test": "error"}
{"id": "7tVGWh", "name": "Persian carpet 27", "author": "jarble", "description": "These carpets have many braided knot patterns.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 95, "published": "Public API", "date": "1637633252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change this constant to get different patterns!\n#define c2 0.\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float bend = 1.;\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 9; k++){       \n                uv /= -scale2;\n                vec2 s1 = triangle_wave(uv.yx-offset,scale)*bend;\n                vec2 s2 = triangle_wave(uv+offset/scale2,scale)/bend;\n                uv = s1+s2;\n                //bend = 1.+(uv.x)/3.;\n            }\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n            col[c] = abs(col[c] - ((uv.x)-(uv.y)));\n            //col[c] = abs(col[c] + ((uv.x)+(uv.y)))/4.;\n\n        }\n\t}\n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 142, 142, 187], [189, 189, 246, 246, 1138]], "test": "valid"}
{"id": "7tVGz1", "name": "Psychedelic 3D raymarching", "author": "zlynch", "description": "Raymarching sphere graphic", "tags": ["raymarching"], "likes": 1, "viewed": 65, "published": "Public", "date": "1637194022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thingy(vec3 var){\n  vec3 b=vec3(0.9);\n  vec3 q=var-b;\n  return length(max(q,4.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat displacement(vec3 var){\n\tfloat height = ((sin(6.0*var.y)*cos(10.0*var.x)*tan(6.0*var.z))*cos(60.1));\n\treturn height;\n}\n\nmat2 rotation(float theta){\n\tfloat sinx=sin(theta);\n\tfloat cosx=cos(theta);\n\treturn mat2(cosx,-sinx,sinx,cosx);\n}\n\nfloat mainShapeSphere(vec3 var){\n\treturn length(var)-(cos(iTime)+.7);\n}\n\n\n\nvec3 getNormal(vec3 var){\n\treturn normalize(var);\n}\n\n\n\n\nfloat dist(vec3 var){\n\tvar.xy*=rotation(iTime);\n\tvar.xz*=rotation(iTime);\n\tfloat x=displacement(var);\n\tfloat mysphere=mainShapeSphere(var);\n\tfloat box=thingy(var);\n\treturn x+mysphere;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 mouse = vec2(iMouse)/vec2(iResolution);\n\tvec3 look=vec3(1.0,0.0,0.0);\n\n\n\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    \n\tvec3 ro=vec3(0.0,0.0,-5.0);\n\tfloat zoom= 3.0;\n\n\tvec3 focus=normalize(look-ro);\n\tvec3 ray=normalize(cross(vec3(3.0,1.0,0.0),focus));\n    \n\tvec3 u=cross(focus,ray);\n\tvec3 c=ro+focus*zoom;\n\tvec3 i=c+uv.x*ray+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n    vec3 k,l;\n\n\n    float d,t;\n\tvec3 color;\n    \n    for(int i=0;i<40;i++){\n        vec3 k=ro+rd*t;\n\n        d=dist(k);\n        l=getNormal(k);\n        if(d<.02)break;\n        t+=d;\n    }\n\t\n\tcolor=reflect(cos(l),l);\n\n\tfragColor=vec4(color,6.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 121], [123, 123, 152, 152, 247], [249, 249, 276, 276, 362], [364, 364, 396, 396, 435], [439, 439, 464, 464, 490], [495, 495, 516, 516, 680], [685, 685, 738, 738, 1375]], "test": "valid"}
{"id": "7tVGzm", "name": "metaball character test", "author": "Ornibulon", "description": "Test to assemble a character with metaballs and render a sdf with an attempt at sphere-tracing.", "tags": ["raymarching", "sdf", "metaball", "head"], "likes": 8, "viewed": 75, "published": "Public", "date": "1637422180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\n\nmat3 rotMatrix(vec3 rotation){\n    rotation *= PI/180.;\n    float rx = rotation.x;\n    float ry = rotation.y;\n    float rz = rotation.z;\n    \n    mat3 rotationX = mat3( 1      , 0      , 0      ,\n                           0      , cos(rx),-sin(rx),\n                           0      , sin(rx), cos(rx));\n                          \n    mat3 rotationY = mat3( cos(ry), 0      , sin(ry),\n                          0       , 1      , 0      ,\n                          -sin(ry), 0      , cos(ry));\n                          \n    mat3 rotationZ = mat3( cos(rz),-sin(rz), 0      ,\n                           sin(rz), cos(rz), 0      ,\n                           0      , 0      , 1);\n                           \n    return rotationX * rotationY * rotationZ;\n}\n\n\nfloat sphere(vec3 position, vec3 center, float size){\n    return length(position-center)-size;\n}\n\n\nfloat metaball(vec3 position, vec3 center, vec3 rotation, vec3 scale){\n    float size = 2.;\n    float l = length(rotMatrix(rotation)*(position-center)/(scale));\n    return -1./l/l/l/l*size;\n}\n\n/*\nfloat sq(float a){\n    return a*a;\n}\n\nvec3 sq(vec3 a){\n    return a*a;\n}\n\nfloat metaball(vec3 position, vec3 center, vec3 rotation, vec3 scale)\n{\n    float size = 0.81;\n    float l = length(rotMatrix(rotation)*(position-center)/(scale));\n \treturn -sq(size) / sq(l);\n}*/\n\nfloat head(vec3 position){\n    return \n            metaball(position, vec3(0.,0.,0.), vec3(0,0,0), vec3(0.671,1,1))\n          + metaball(position, vec3(0.,-0.5,-0.9), vec3(0,0,0), vec3(0.400,0.472,0.538))\n          // jaw\n          + metaball(position, vec3(0.3,-0.3,0.1), vec3(0,0,0), vec3(0.450,0.472,0.538))\n          + metaball(position, vec3(-0.3,-0.3,0.1), vec3(0,0,0), vec3(0.450,0.472,0.538))\n          // ears\n          + metaball(position, vec3(1.,0.71,0.47), vec3(0,60,-50), vec3(0.2,0.75,0.415))\n          + metaball(position, vec3(-1.,0.71,0.47), vec3(0,-60,50), vec3(0.2,0.75,0.415))\n          // ears interior\n          - metaball(position, vec3(1.2,0.8,0.32), vec3(0,60,-50), vec3(0.07,0.40,0.255))/1.5\n          - metaball(position, vec3(-1.2,0.8,0.32), vec3(0,-60,50), vec3(0.07,0.40,0.255))/1.5\n          // neck\n          + metaball(position, vec3(0,-1.729,0.15), vec3(-1.6,0,0), vec3(0.363,0.683,0.435))\n          + metaball(position, vec3(1.04,-2.64,0.383), vec3(0,0,0), vec3(0.671,0.671,0.671))\n          + metaball(position, vec3(-1.04,-2.64,0.383), vec3(0,0,0), vec3(0.671,0.671,0.671))\n          + metaball(position, vec3(0,-2.729,0.15), vec3(0,0,0), vec3(0.6,0.6,0.6))\n          // left brow\n          + metaball(position, vec3(0.9-0.1,0.45,-0.33), vec3(35.6,-7.,0), vec3(0.213,0.162,0.269))\n          + metaball(position, vec3(0.647-0.1,0.49,-0.55), vec3(20, 0, 0), vec3(0.213,0.184,0.269))\n          + metaball(position, vec3(0.86-0.1,0.02,-0.41), vec3(0, 0, 0), vec3(0.213,0.158,0.269))\n          - metaball(position, vec3(0.66-0.1,0.13,-1.21), vec3(0, 0, 0), vec3(0.15,0.15,0.3))\n          // right brow\n          + metaball(position, vec3(-0.9+0.1,0.45,-0.33), vec3(35.6,7.,0), vec3(0.213,0.162,0.269))\n          + metaball(position, vec3(-0.647+0.1,0.49,-0.55), vec3(-20, 0, 0), vec3(0.213,0.184,0.269))\n          + metaball(position, vec3(-0.86+0.1,0.02,-0.41), vec3(0, 0, 0), vec3(0.213,0.158,0.269))\n          - metaball(position, vec3(-0.66+0.1,0.13,-1.21), vec3(0, 0, 0), vec3(0.15,0.15,0.3))\n          // end\n          + 1.\n            ;\n}\n\n/*\nfloat sdf(vec3 position){\n    return \n            min(sphere(position, vec3(1.5*sin(iTime),0,3.+1.5*cos(iTime)), 0.3),\n               max(sphere(position, vec3(0,0,3), 1.), \n                   -min(sphere(position, vec3(.2,.2+0.04*sin(10.*iTime),2.1), .2),\n                        sphere(position, vec3(.6,.2+0.04*sin(10.*iTime),2.3), .2)\n               \n           )));\n}*/\n\n\nfloat sdf(vec3 position){\n    return \n            min(max(head(position), \n                -min(sphere(position, vec3(0.18, -0.26, -1.468), 0.06), \n                     sphere(position, vec3(-0.18, -0.26, -1.468), 0.06))),\n            min(sphere(position, vec3(0.81-0.12, 0.27, -0.468), 0.4),\n                sphere(position, vec3(-0.81+0.12, 0.27, -0.468), 0.4)\n            ));\n}\n\n\nfloat sdfIntersect(out bool intersect, out vec3 position, out vec3 normal, in vec3 rayOrigin, in vec3 rayDir){\n    float advStep = .1;\n    int dichoSteps = 10;\n    \n    vec3 rayPos = rayOrigin;\n    \n    float sdfValue = 10.;//sdf(rayPos);\n    float newSdfValue = sdf(rayPos);\n    int nbSteps = 0;\n    vec3 a = rayPos;\n    vec3 b = rayPos;\n    while (newSdfValue >= 0.){\n        //rayPos += rayDir*advStep;  //constant step\n        rayPos += (newSdfValue/3.4+0.01)*rayDir;\n        a = b;\n        b = rayPos;\n        /*\n        if (newSdfValue < sdfValue) {\n            rayPos += (newSdfValue/3.+0.01)*rayDir;\n        } else {\n            rayPos += (0.01)*rayDir;\n        }*/\n       \n        sdfValue = newSdfValue;\n        newSdfValue = sdf(rayPos);\n        \n        /*\n        if (newSdfValue > sdfValue){\n            intersect = false;\n            return;\n        }*/\n        \n        if (nbSteps > 100 || sdfValue > .998){\n            intersect = false;\n            return 0.;\n        }\n        \n        nbSteps += 1;\n    }\n    \n    // dichotomy\n    //vec3 a = rayPos - rayDir*advStep;\n    //vec3 b = rayPos;\n    vec3 ab = vec3(0,0,0);\n    float sdfA;\n    float sdfB;\n    float sdfAB;\n    for (int i; i<dichoSteps; i++){\n        sdfA = sdf(a);\n        sdfB = sdf(b);\n        \n        ab = (a+b)*0.5;\n        sdfAB = sdf(ab);\n        \n        if (sdfAB < 0.){\n            b = ab;\n        } else {\n            a = ab;\n        }\n    }\n    sdfValue = sdfAB;\n    \n    intersect = true;\n    position = ab;\n    \n    float epsilon = 0.0001;\n    vec3 preNormal = vec3(sdf(position + epsilon*vec3(1,0,0)) - sdfValue,\n                          sdf(position + epsilon*vec3(0,1,0)) - sdfValue,\n                          sdf(position + epsilon*vec3(0,0,1)) - sdfValue);\n                     \n    normal = normalize(preNormal);\n    \n    return length(preNormal);\n}\n\n\nvec3 light(in vec3 lightsource, in vec3 color, in vec3 position, in vec3 normal){\n    bool intersect = false;\n    vec3 position2 = vec3(0,0,0);\n    vec3 normal2 = vec3(0,0,0);\n    \n    vec3 rayDir = normalize(lightsource - position); \n    vec3 rayOrigin = position + 0.1*rayDir;\n    \n    sdfIntersect(intersect, position2, normal2, rayOrigin, rayDir);\n    \n    if (intersect){\n        return vec3(0,0,0);\n    } else {\n        return color * dot(normal, rayDir);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    \n    vec2 sensorDims = vec2(16, 9);\n    float focal = 10.;\n    \n    bool intersect = false;\n    vec3 position = vec3(0,0,0);\n    vec3 normal = vec3(0,0,0);\n    \n    float time = iTime;\n    \n    vec3 rayOrigin = vec3(5.*sin(time),0,-5.*cos(time));\n    vec3 rayDir = normalize(vec3(uv.x*sensorDims.x, uv.y*sensorDims.y, focal));\n    \n    mat3 rotation = mat3( cos(time), 0       , sin(time),\n                          0        , 1       , 0        ,\n                          -sin(time), 0       , cos(time));\n                         \n    rayDir = rotation * rayDir;\n    \n    float pointiness = sdfIntersect(intersect, position, normal, rayOrigin, rayDir);\n    \n    vec3 col = vec3(1,1,1);\n    if (intersect){\n        //col = 0.5*normal + vec3(0.5, 0.5, 0.5);//vec3(1,1,1);   //vec3(0.4, 0.4, 0.8)\n        col = light(vec3(5,5,-4), vec3(1,1,1), position, normal) + light(vec3(-3,1,1), vec3(0.4, 0.4, 0.8), position, normal);\n        if (pointiness*1000. > 0.15){\n            col *= vec3(1,.8,.8)*(1.-min(0.6,max(0., pointiness*1000.)));\n        }\n    } else {\n        col.x = (uv.y+.5)/4.;\n        col.y = (uv.y+.5)/4.;\n        col.z = .1+(uv.y+.5)/4.;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 54, 54, 778], [781, 781, 834, 834, 877], [880, 880, 950, 950, 1071], [1347, 1347, 1373, 1373, 3425], [3807, 3807, 3832, 3832, 4187], [4190, 4190, 4300, 4300, 6041], [6044, 6044, 6125, 6125, 6513], [6516, 6516, 6573, 6623, 7900]], "test": "valid"}
{"id": "7tyGRG", "name": "Infinitely Many Touching Circles", "author": "__mk_km__", "description": "Visualization, inspired by a numberphile video \"Infinitely Many Touching Circles\"(https://youtu.be/hSsRcpIsunk)\nAnimated and draggable", "tags": ["math", "visualization"], "likes": 7, "viewed": 85, "published": "Public", "date": "1637859070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 invertPoint(vec2 p) {\n    vec2 p2 = vec2(p.y, -p.x);\n    p2 /= dot(p, p);\n    return p2;\n}\n\nfloat sdfCircles(vec2 p) {\n    // Start with the infinite line\n    float d = abs(p.y - 1.0);\n    // How about another infinite line, and we only draw circles inbetween?\n    d = min(d, abs(p.y - 6.0));\n    \n    if((p.y > 1.0) && (p.y < 6.0)) {\n        // Then draw all of the grid circles\n        p = fract(p);\n        d = min(d, abs(0.5 - length(p - 0.5)));\n    }\n    return d;\n}\n\nconst float PI = 3.141592653589793;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    if(iMouse.xy == vec2(0.0))\n        mouse = vec2(0.0);\n    \n    float anim = 0.5-0.5*cos(PI * iTime / 12.0);\n    float zoom = 0.1 * exp(4.0*anim);\n    vec2 offset = mix(vec2(0.0, 2.0), vec2(-0.001, 0.0), pow(anim, 0.3));\n    \n    offset -= mouse / zoom;\n    \n    vec2 p = uv / zoom + offset;\n    vec2 p2 = invertPoint(p);\n    \n    vec2 tmp = 2.0*abs(fract(p) - 0.5);\n    float grid = 1.0 - max(tmp.x, tmp.y);\n    grid *= 8.0 * zoom;\n    \n    float d1 = sdfCircles(p);\n    float d2 = sdfCircles(p2);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    col += smoothstep(0.05, 0.03, grid) * vec3(0.3);\n    col += smoothstep(0.03, 0.01, d1) * vec3(0.9, 0.2, 0.1);\n    col += smoothstep(0.03, 0.01, d2) * vec3(abs(p2.xy), 0.9);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 95], [97, 97, 123, 159, 476], [514, 514, 571, 622, 1554]], "test": "valid"}
{"id": "7tyGWm", "name": "spqr: volumetric light study", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 6, "viewed": 145, "published": "Public API", "date": "1637796075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat sph (vec3 p, float r) {\n  return length(p) -r;\n}\nfloat cyl (vec2 p,float r) {\n  return length(p) - r;\n}\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat map(vec3 p) {\n\n  // geo\n  \n  float outside = cyl(p.xz, 3.);\n  float inside = -cyl(p.xz, 2.8);\n  float tunnel = max(inside,outside);\n  p.xz *= rot((p.y/10.) * sin(iTime) * 5.1);\n  p = rep(p, vec3(.52));\n  float holes = sph(p, .27);\n \n  tunnel = max(tunnel,-holes);\n  return tunnel;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  \n  \n  \n\n\n // vec3 r=normalize(vec3(-uv, 1));\n  \n  \n  // nav\n  float tt = iTime * .01 + 16.5;\n  vec3 s,t;\n  s += lattice(tt) * 20.;\n  s += lattice(tt * 3.) * 5.1;\n  s *= sin(tick(iTime * .31) * .21+ 7.);\n  \n  t += lattice(tt * 95. + 1.) * 3.;\n  t += lattice(tt * 57.) * 1.1;;\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,-1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n\n \n\n  \n  // march\n  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 100.0;\n  float z;\n  for( z=0.; z<100.; ++z) {\n  \n    float d=map(p);\n    if(d<0.001) break;\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n    \n  }\n  \n  \n  \n  // volume\n  \n  float rand=rnd(uv);\n  \n  vec3 lightpos = vec3(3);\n  //vec3 lightfocus = vec3(3);\n  float lightangle = .1;\n \n  lightpos = vec3(0,0,4);\n  lightpos.xz *= rot(iTime);\n  lightpos.yz *= rot(iTime * .61);\n  lightpos.xy *= rot(iTime * .41);\n  \n  \n  //lightfocus.yz *= rot(t1 * .7);\n  //lightfocus.xz *= rot(t2 * .8);\n  //lightfocus.yx *= rot(t3 * .91);\n  \n\n\n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n    if ( dot( normalize(lv), normalize(lp) ) > -1.) {\n      atcol += 5./(0.01+(pow(ldistvol,1.5))) * shadvol;\n    }\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n \n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(lightpos - p);\n\n  float ldist = length(lightpos - p);\n  float fade = 1.0/(ldist*ldist);\n  \n  float shad = shadow(p + n * 0.2, l, ldist, 30, 0.01);\n  \n  vec3 col=vec3(0);\n\n  col += atcol * .07;\n  col = pow(col, vec3(0.4545));\n  col *= 1.2-length(uv);\n  \n  col += pow( 1.-z/100., 135.) * vec3(1);\n  \n  fragColor = vec4(col, 1);\n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 70, 70, 119], [121, 121, 140, 140, 211], [214, 214, 237, 237, 315], [316, 316, 336, 336, 515], [517, 517, 546, 546, 571], [572, 572, 600, 600, 626], [628, 628, 649, 649, 698], [700, 700, 725, 725, 1194], [1196, 1196, 1215, 1225, 1484], [1486, 1486, 1506, 1506, 1575], [1577, 1577, 1597, 1597, 1639], [1641, 1641, 1663, 1663, 1745], [1750, 1750, 1823, 1823, 2072], [2076, 2076, 2133, 2133, 4381]], "test": "valid"}
{"id": "7tyGWz", "name": "isolines from sparse points", "author": "elenzil", "description": "interpolating isolines from sparse sample points.\nleft: ground-truth  right: interpolated.\nthe blend falloff power here is 4.0.\ncan be modified at top of code.", "tags": ["isolines", "interpolation", "power", "falloff", "sparse"], "likes": 6, "viewed": 86, "published": "Public API", "date": "1637484279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// the weighting of each sample point is 1 / distance^BLEND_FALLOFF_POWER\nconst float BLEND_FALLOFF_POWER = 4.0;\n\n\n// sample point are contained in a square of this 'radius'.\nconst float sweepRadius = 10.0;\n\n// distance between sample points.\nconst float sweepStep   = sweepRadius / 5.0;\n\n// every third and seventh sample points are removed for some irregularity.\n\n\n\n\n#define RES iResolution\n\n\nmat2 rotationMatrix2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nconst float sinData[] = float[](\n    // angle\n    // frequency\n    // phase\n    // amplitude\n    2.5, 0.11, 1.5, 3.0,\n    3.1, 0.71, 1.5, 2.0,\n    6.1, 1.31, 1.5, 1.0,\n    2.2, 0.41, 1.5, 4.0\n);\nfloat groundTruth(in vec2 p) {\n\n    float accum = 0.0;\n    float range = 0.0;\n    for (int n = 0; n < sinData.length(); n += 4) {\n        vec2  v   = p * rotationMatrix2(sinData[n + 0]);\n        float val = sin(v.y * sinData[n + 1] + sinData[n + 2]) * sinData[n + 3];\n        accum += val;\n        range += sinData[n + 3];\n    }\n    \n    float f = accum * 0.5 / range + 0.5;\n    \n    return f;\n}\n\nvoid accumulateSample(in vec2 p, in vec2 samplePt, inout float accumVal, inout float accumRng) {\n    \n    float sampleVal = groundTruth(samplePt);\n    float sampleDst = length(p - samplePt);\n        \n    float weight = 1.0 / pow(sampleDst, BLEND_FALLOFF_POWER);\n    accumVal += sampleVal * weight;\n    accumRng += weight;\n}\n\nbool discardSamplePoint(int n) {\n    return n % 3 == 0 || n % 7 == 0;\n}\n\n\nfloat interpolated(in vec2 p, in vec2 screenCenter, in vec2 mousePt) {\n    float accumVal = 0.0;\n    float accumRng = 0.0;\n    \n    accumulateSample(p, screenCenter + mousePt       , accumVal, accumRng);\n    \n\n    int n = 0;\n    for (float dx = -sweepRadius; dx <= sweepRadius; dx += sweepStep) {\n    for (float dy = -sweepRadius; dy <= sweepRadius; dy += sweepStep) {\n        ++n;\n        if (discardSamplePoint(n)) {\n            continue;\n        }\n        accumulateSample(p, screenCenter + vec2(dx, dy), accumVal, accumRng);\n    }\n    }\n    \n    return accumVal / accumRng;\n}\n\n// doing fwidth 'yourself' with dFdx() and dFdy()\n// yields finer results on some systems, iirc.\nfloat fwidth_home(float val) {\n    return abs(dFdy(val)) + abs(dFdx(val));\n}\n\n// val in [0, 1]\nfloat isolines(float val) {\n    val = (val - 0.5) * 1.01 + 0.5;\n    return smoothstep(2.0, 0.0, abs(mod(val + 0.05, 0.1) - 0.05) / fwidth_home(val));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    // get normalized xy screen-coordinates in \n    float zoomFactor       = 1.2;\n    float smallDim         = min(RES.x, RES.y);\n    vec2  xy               = (XY - RES.xy * 0.5) /smallDim * 2.0 * zoomFactor;\n    bool  isLeftSide       = xy.x < 0.0;\n    \n    // for smooth lines\n    float edgeWidth        = 2.0;\n    float smoothingEpsilon = edgeWidth / smallDim * 2.0;\n\n    // world-space coord\n    vec2  worldOffset      = vec2(cos(iTime * 0.0051), sin(iTime * 0.0041)) * 100.0;\n    vec2  p                = xy * 10.0 + worldOffset;\n    vec2  resetSide        = vec2(RES.x / smallDim * zoomFactor * -10.0, 0.0);\n    \n    vec2  mouse            = (iMouse.xy - RES.xy * 0.5) / smallDim * 2.0 * zoomFactor;\n    vec2  samplePt         = mouse * 10.0 - resetSide * 0.5;\n        \n    float val;\n    if (isLeftSide) {\n        val = groundTruth(p);\n    }\n    else {\n        val  = interpolated(p + resetSide, worldOffset + resetSide * 0.5, samplePt);\n    }\n    \n    vec3 rgb  = val * vec3(0.5, 0.8, 1.0);\n    \n    float iso = isolines(val);\n    rgb       = mix(rgb, vec3(0.5, 0.5, 0.3), iso);\n    \n    // draw sample points\n    float ptRad = 0.2;\n    vec3  ptCol = vec3(1.0);\n    float dp;\n    if (isLeftSide) {   \n        dp = length(p - (worldOffset + resetSide * 0.5 + samplePt));\n        rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n    }\n    else {\n        dp = length(p + resetSide - (worldOffset + resetSide * 0.5 + samplePt));\n        rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n    }\n\n    int n = 0;\n    for (float dx = -sweepRadius; dx <= sweepRadius; dx += sweepStep) {\n    for (float dy = -sweepRadius; dy <= sweepRadius; dy += sweepStep) {\n        ++n;\n        if (discardSamplePoint(n)) {\n            continue;\n        }\n        if (isLeftSide) {\n            dp = length(p - (worldOffset + resetSide * 0.5 + vec2(dx, dy)));\n            rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n        }\n        else {\n            dp = length(p + resetSide - (worldOffset + resetSide * 0.5 + vec2(dx, dy)));\n            rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n        }\n    }\n    }\n    \n    // center divider\n    rgb       = mix(rgb, vec3(0.0, 0.0, 0.0), smoothstep(smoothingEpsilon * 2.0, 0.0, abs(xy.x)));\n    \n    \n    RGBA.rgb = rgb;\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 396, 431, 431, 515], [712, 712, 742, 742, 1107], [1109, 1109, 1205, 1205, 1432], [1434, 1434, 1466, 1466, 1505], [1508, 1508, 1578, 1578, 2087], [2089, 2186, 2216, 2216, 2262], [2264, 2281, 2308, 2308, 2432], [2434, 2434, 2477, 2525, 4914]], "test": "error"}
{"id": "7tyGz3", "name": "Fractal 92_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 5, "viewed": 93, "published": "Public", "date": "1638060147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define R(p,a,t)mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define Y p=p.x<p.y?p.zxy:p.zyx\n#define N p=p.x>p.y?p.zxy:p.zyx\n\n#define hash(p)fract(sin(p*12345.5))\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+23715.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t)\n{\n    t*=.5;\n    float n = 1234.567;\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++)    {\n        p += randVec(n+=365.)*sin((t*=1.3)+sin(t*0.6)*0.5);\n    }\n    return p*.8;\n}\n\nmat3 lookat(vec3 eye, vec3 ta)\n{\n    vec3 w=normalize(ta-eye), u=normalize(cross(w,vec3(0,1,0)));\n    return mat3(u,cross(u,w),w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p,ta,eye,\n    r=iResolution,\n    d=normalize(vec3((fragCoord-.5*r.xy)/r.y,1.)),\n    c=vec3(0);\n    float i=0.,g=0.,e,a,s,t=iTime*.5;  \n    for(;i++<120.;){\n        eye= randCurve(t-.3);\n        ta= randCurve(t+.3);\n        p=lookat(eye,ta)*g*d+eye;\n        a=dot(p,p);\n        p=abs(p)-.6;\n        N;\n        Y;\n        s=3.;\n        for(int i=0;i++<8;){\n            p=abs(p);\n            Y;\n            s*=e=1.8/min(dot(p,p),1.3);\n            p=abs(p)*e-vec3(1.5*a,3.,5.*a);\n        }\n        a=.3;\n        p-=clamp(p,-a,a);\n        g+=e=length(p.yz)/s;\n        if(e<.001)c+=mix(vec3(1),H(log(s)*.2+.2),.5)*.015*exp(-i*i*e);\n    }\n    c*=c*c;\n    fragColor=vec4(c,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 232, 232, 333], [335, 335, 360, 360, 535], [537, 537, 569, 569, 669], [671, 671, 728, 728, 1408]], "test": "valid"}
{"id": "fdGSR3", "name": "Geometry Light Generator", "author": "ivatronx", "description": "A acos cos tan piece", "tags": ["generative"], "likes": 2, "viewed": 23, "published": "Public", "date": "1638043031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*acos(cos(atan(iTime/1.1))))/iResolution.xy*acos(cos(atan(iTime/1.1)));\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(cos(tan(iTime*0.01+uv.xyx+vec3(0.1,0.2,0.4))));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 371]], "test": "valid"}
{"id": "fdyXDy", "name": "myBH", "author": "btx0424", "description": "ray-tracing of a black hole", "tags": ["raytracing"], "likes": 8, "viewed": 74, "published": "Public", "date": "1637224970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926;\nconst float vfov=pi/2.0;\nconst float dt = 0.04;\nconst float R2 = pow(16., 2.);\nconst vec3 start = vec3(12., 0., 0.);\nconst vec3 lookat =  vec3(2., 0., 0.);\n\nvec3 disk_color(vec3 p) {\n    float r = length(p);\n    \n    vec2 ra = vec2(atan(abs(p.z), p.x), r/3.);\n    vec3 col = (texture(iChannel0, ra).xyz + vec3(0.5))/(r-4.6)*23.;\n    return col;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 bg_color(vec3 p) {\n    p = normalize(p);\n    float phi = atan(p.y, p.x);\n    float theta = acos(p.z);\n    float x = phi/2.0/pi;\n    float y = theta/pi;\n    vec2 texture_p = vec2(x, y)*4.;\n    \n    return pow(texture(iChannel0, texture_p).yzx, vec3(3.6));\n}\n\nvec3 integrate(vec3 p, vec3 v) {\n    vec3 c = cross(p, v), col=vec3(0.);\n    float h2 = dot(c, c), p2 = 0., dis=0.;\n    \n    \n    for (int i=0; i<80; i++) {\n        p2 = dot(p, p);\n        if (0. < p2) {\n            vec3 a = -1.5*h2*p/pow(p2, 2.5);\n            float ra = length(a);\n            float step_size = dt/(0.13+pow(ra, 2.1));\n            v += a*step_size;\n            vec3 new_p = p + v*step_size;\n            dis += length(v*step_size);\n            \n            \n            if (p.y*new_p.y<0.) {\n                vec3 hit = mix(p, new_p, abs(p.y/(new_p.y-p.y)));\n                float r = length(hit);\n                if (4.8 < r && r< 6.4) {\n                    col += disk_color(hit) / pow(dis, 1.6);\n                }\n            }\n            p = new_p;\n            //if (sdTorus(p, vec2(5.6, 0.8)) < 0.) col += vec3(0.08);\n            col += vec3(0.85,0.8,0.95) * smoothstep(0., 0.26, length(p)-2.)*(0.18/p2);\n        } else {\n            break;\n        }\n    }\n    if (p2>R2) {\n        col += bg_color(p);\n        \n    }\n    return col;\n}\n\nmat2 rotate(float a) {\n    return mat2(\n        cos(a), -sin(a),\n        sin(a), cos(a)\n    );\n}\n\nvec3 ray_direction(vec3 ro, vec3 lookat, vec3 up, vec2 uv) {\n    vec3 r = normalize(lookat-ro);\n    up = normalize(up-dot(up, r)*r);\n    vec3 x = cross(r, up)*uv.x;\n    vec3 z = iResolution.y/tan(0.5*vfov)*r;\n    vec3 y = up*uv.y;\n    return normalize(x+y+z);\n}\n\nvec3 get_color(vec3 ro, vec3 lookat, vec3 up, vec2 uv) {\n    vec3 rd = ray_direction(ro, lookat, up, uv);\n    return integrate(ro, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime *0.2;\n    vec3 ro; ro.xz = rotate(t)*start.xz;ro.y+=2.;\n    vec3 ro1; ro1.xz = rotate(t+0.02)*start.xz; ro1.y=ro.y+0.8;\n    \n    \n    vec2 uv = fragCoord-iResolution.xy*0.55;\n\n    vec3 up = normalize(ro1-ro);\n   \n    vec3 col = get_color(ro, lookat, up, uv);\n     \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 210, 210, 374], [376, 376, 409, 409, 474], [476, 476, 499, 499, 737], [739, 739, 771, 771, 1795], [1797, 1797, 1819, 1819, 1893], [1895, 1895, 1955, 1955, 2156], [2158, 2158, 2214, 2214, 2295], [2297, 2297, 2354, 2354, 2673]], "test": "error"}
{"id": "fl33D4", "name": "Merry-Go-Round", "author": "dr2", "description": "Carousel (mouseable)", "tags": ["raymarch", "carousel", "complexityreduction"], "likes": 12, "viewed": 172, "published": "Public API", "date": "1636108322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Merry-Go-Round\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, gAng, nSec, aRot;\nint idObj;\nconst int idSup = 1, idTube = 2, idSeat = 3, idGrip = 4, idLitS = 5, idCmid = 6, idFlr = 7,\n   idSpk = 8, idTop = 9, idPole = 10, idLit = 11, idBase = 12, idRail = 13;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, h, s, sx;\n  dMin = dstFar;\n  p.xz = Rot2D (p.xz, 2. * pi * gAng);\n  q = p;\n  s = Hashff (11.1 * gAng);\n  q.x += 5. + 0.7 * s;\n  sx = sign (q.x);\n  q.x = abs (q.x) - 0.8 + 0.4 * (s - 0.5);\n  a = cos (2. * pi * gAng + 0.3 * pi * tCur) + 0.5 * cos (5. * pi * gAng - 0.7 * pi * tCur);\n  h = 0.5 + 0.2 * a;\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.14, 0.1);\n  DMINQ (idSup);\n  q.y -= 2. * h;\n  d = PrCylDf (vec3 (q - vec3 (0., - h, 0.)).xzy, 0.06, h);\n  DMINQ (idTube);\n  q.xz = Rot2D (q.xz, 0.1 * pi * a * sx);\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.05, 0.16), 0.1);\n  DMINQ (idSeat);\n  d = PrSphDf (vec3 (q.xy, abs (q.z) - 0.24), 0.05);\n  DMINQ (idLitS);\n  q.yz = Rot2D (q.yz - vec2 (0.2, -0.2), 0.07 * pi);\n  d = min (PrCylDf (q.xzy, 0.04, 0.3), PrCylDf ((q - vec3 (0., 0.3, 0.)).yzx, 0.03, 0.25));\n  DMINQ (idGrip);\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{  // (raymarching with axial grid reduces scene complexity when symmetry absent)\n  vec3 p;\n  vec2 cs;\n  float dHit, d, eps, rgOut;\n  rgOut = 10.;\n  eps = 0.001;\n  cs = sin (pi / nSec + vec2 (0., 0.5 * pi));\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    p.xz = Rot2D (p.xz, aRot);\n    gAng = (floor (nSec * atan (p.z, - p.x) / (2. * pi)) + 0.5) / nSec;\n    d = GObjDf (p);\n    p.xz = Rot2D (p.xz, 2. * pi * gAng);\n    d = min (d, 0.1 + max (- p.x - rgOut, abs (dot (vec2 (p.x, abs (p.z)), cs))));\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, s;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.05;\n  d = PrCylDf (q.xzy, 9.3, 0.05);\n  DMINQ (idBase);\n  d = PrTorusDf (vec3 (q.xz, abs (abs (q.y - 1.) - 0.3) - 0.3), 0.03, 9.);\n  q.xz = Rot2D (q.xz, 2. * pi * floor (32. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 32.);\n  q.xy -= vec2 (-9., 0.8);\n  d = min (d, PrCylDf (q.xzy, 0.03, 0.8));\n  DMINQ (idRail);\n  p.xz = Rot2D (p.xz, aRot);\n  q = p;\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 1., 0.5);\n  DMINQ (idCmid);\n  q.y -= 0.6;\n  d = PrSphDf (q, 0.12);\n  DMINQ (idLit);\n  a = (floor (0.5 * nSec * atan (p.z, - p.x) / (2. * pi)) + 0.5) / (0.5 * nSec);\n  q = p;\n  q.y -= 0.1;\n  q.xz = Rot2D (q.xz, 2. * pi * a);\n  d = PrCaps2Df (vec2 (q.y - 0.1, q.x + 5.), 0.06, 2.5);\n  DMINQ (idFlr);\n  d = PrCylDf ((q - vec3 (-1.25, 0.1, 0.)).yzx, 0.07, 1.25);\n  DMINQ (idSpk);\n  d = Maxv2 (abs (Rot2D (q.xy, -0.05 * pi) - vec2 (-3.6, 5.2)) - vec2 (3.2, 0.04));\n  d = min (d, min (Maxv2 (abs (vec2 (q.x + 7.3, q.y - 3.95)) - vec2 (0.02, 0.15)),\n     Maxv2 (abs (vec2 (q.x + 1.2, q.y - 5.1)) - vec2 (0.02, 0.15))));\n  DMINQ (idTop);\n  s = sign (q.z);\n  q.z = abs (q.z);\n  q -= vec3 (7.2 * vec2 (-1., tan (pi / (0.5 * nSec))), 2.1).xzy;\n  d = PrCylDf (q.xzy, 0.07, 2.);\n  q.z *= s;\n  DMINQ (idPole);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), 4. * e.x)).xzy);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.3, 0.4, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  vec3 c1, c2;\n  float a;\n  c1 = HsvToRgb (vec3 (gAng, 0.8, 1.));\n  c2 = HsvToRgb (vec3 (fract (gAng + 0.5), 0.8, 1.));\n  if (idObj == idPole || idObj == idBase || idObj == idCmid) a = atan (qHit.z, - qHit.x);\n  if (idObj == idBase) col4 = vec4 (0.4, 0.2, 0., 0.) * (1. - 0.3 * step (5., length (qHit.xz)) * \n     (1. - smoothstep (0., 0.1, sin (128. * a) + 0.5)));\n  else if (idObj == idTop) col4 = mix (vec4 (1., 0., 0., 0.1), vec4 (1., 1., 0., 0.1),\n     smoothstep (0., 0.02, fract (1.1 * qHit.z + 0.5) - 0.5));\n  else if (idObj == idFlr) col4 = (abs (qHit.x + 5.) < 2.45) ? vec4 (0.7, 0.4, 0.3, 0.1) *\n     (0.8 + 0.2 * smoothstep (0., 0.03, fract (2. * qHit.x) - 0.1)) * (1. -\n     0.4 * Fbm2 (64. * qHit.xz)) : vec4 (0.2, 0.7, 0.2, -1.);\n  else if (idObj == idSpk) col4 = vec4 (0.2, 0.3, 0.2, 0.1);\n  else if (idObj == idSup) col4 = vec4 (c1, -1.);\n  else if (idObj == idTube) col4 = vec4 (0.8, 0.8, 0.85, 0.2) * (0.6 +\n     0.4 * smoothstep (0., 0.02, fract (16. * qHit.y + 0.5) - 0.5));\n  else if (idObj == idSeat) col4 = mix (vec4 (c1, 0.1), vec4 (c2, 0.1),\n     step (0.5, fract (8. * qHit.z)));\n  else if (idObj == idGrip) col4 = vec4 (c1, 0.1);\n  else if (idObj == idCmid) col4 = vec4 (0.5, 0.5, 1., 0.1) *\n     (0.7 + 0.3 * smoothstep (0., 0.1, cos (0.5 * nSec * a) + 0.5));\n  else if (idObj == idPole) col4 = mix (vec4 (1., 0., 0., -1.), vec4 (1., 1., 1., 0.2),\n     smoothstep (0., 0.03, fract (8. * qHit.y + a / (2. * pi)) - 0.1));\n  else if (idObj == idRail) col4 = vec4 (0.8, 0.9, 0.9, 0.2);\n  else if (idObj == idLitS) col4 = vec4 (((qHit.z < 0.) ? c1 : c2), -1.);\n  else if (idObj == idLit) col4 = vec4 (1., 1., 0.7, -1.);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 qHitG, col, vn;\n  float dstObjG, dstObj;\n  nSec = 36.;\n  aRot = -0.05 * pi * tCur;\n  dstObjG = GObjRay (ro, rd);\n  qHitG = qHit;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstObjG) < dstFar) {\n    if (dstObj < dstObjG) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n    } else {\n      ro += dstObjG * rd;\n      ro.xz = Rot2D (ro.xz, aRot);\n      qHit = qHitG;\n      vn = GObjNf (ro);\n      vn.xz = Rot2D (vn.xz, - aRot);\n    }\n    col4 = ObjCol ();\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    vn = GrndNf (ro.xz);\n    col = (0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz)))) *\n       (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n    col *= 0.7 + 0.3 * smoothstep (0., 0.5, length (ro.xz) - 9.3);\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.06 * pi;\n  if (mPtr.z > 0.) {\n    az -= 1.5 * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.4, -30.);\n  zmFac = 4.3 / (1. - 0.8 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  uv.x *= canvas.y / canvas.x;\n  col = mix (vec3 (0.85), col, sqrt (sqrt (max (0., 0.95 - length (pow (abs (uv), vec2 (12.)))))));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33D4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[970, 970, 993, 993, 1850], [1852, 1852, 1886, 1966, 2538], [2540, 2540, 2562, 2562, 2818], [2820, 2820, 2842, 2842, 4108], [4110, 4110, 4143, 4143, 4390], [4392, 4392, 4413, 4413, 4668], [4670, 4670, 4692, 4692, 4833], [4835, 4835, 4869, 4869, 5457], [5459, 5459, 5475, 5475, 7149], [7151, 7151, 7186, 7186, 8376], [8378, 8378, 8434, 8434, 9630], [9632, 9632, 9678, 9678, 9725], [9727, 9727, 9760, 9760, 9787], [9789, 9789, 9831, 9831, 9882], [9884, 9884, 9928, 9928, 9988], [9990, 9990, 10036, 10036, 10093], [10095, 10095, 10117, 10117, 10144], [10146, 10146, 10182, 10182, 10388], [10390, 10390, 10420, 10420, 10533], [10535, 10535, 10559, 10559, 10676], [10710, 10710, 10734, 10734, 10771], [10773, 10773, 10797, 10797, 10850], [10852, 10852, 10876, 10876, 10988], [10990, 10990, 11015, 11015, 11161], [11163, 11163, 11188, 11188, 11374], [11376, 11376, 11398, 11398, 11552], [11554, 11554, 11575, 11575, 11730]], "test": "error"}
{"id": "fl33Rs", "name": "multiverse", "author": "4eckme", "description": "im sorry", "tags": ["2d", "rgb", "animation", "universes", "multiverse"], "likes": 2, "viewed": 56, "published": "Public", "date": "1636510303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 c, float a) {\n  return vec2(c.x*cos(a)-c.y*sin(a),c.x*sin(a)+c.y*cos(a));\n}\nvoid mainImage( out vec4 color, in vec2 c ) {\n    c-=iResolution.xy/2.0;\n    if(max(iResolution.x,iResolution.y)<1000.0)c*=2.0;\n    float r=sqrt(c.x*c.x+c.y*c.y)/256.0;\n    c.x=mod(c.x,256.0)-128.0;\n    c.y=mod(c.y,256.0)-128.0;\n    c=rotate(c,-iTime/2.0-abs(c.x/2.0)-abs(c.y/2.0));\n    // c/=2.5; //try it\n    color=vec4(int(abs(c.x)<60.0&&abs(c.y)<60.0));\n    if(c.x<-12.0&&c.x>-36.0&&c.y>12.0)color=vec4(0.0);\n    if(c.x<36.0&&c.x>12.0&&c.y<-12.0)color=vec4(0.0);\n    if(c.y>12.0&&c.y<36.0&&c.x>12.0)color=vec4(0.0);\n    if(c.y<-12.0&&c.y>-36.0&&c.x<-12.0)color=vec4(0.0);\n    if(color.x*color.y*color.z>=1.0) {\n        color=vec4(abs(sin(r-1.0)),abs(sin(r)),abs(sin(r+1.0)),0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 92], [93, 93, 138, 138, 782]], "test": "valid"}
{"id": "fl33WB", "name": "Pulsating customizable spiral", "author": "feldim2425", "description": "Spiral can be customized by modifying the constants in the shader.\nI didn't bother fitting the dimensions to any specific unit so most options a trial and error.", "tags": ["spiral"], "likes": 3, "viewed": 57, "published": "Public", "date": "1636596921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\n// Size options\nfloat spiralSize = 20.0; // Smaller is bigger; 0 would just be a rotating line\nfloat spacing = 1.5; // Min. 1.0\nfloat pulsationStrength = 0.5; // from 0.0 to 1.0\nint armCount = 1; // 0 for rings; negative to flip the direction\n\n// Speed options\nfloat pulsespeed = 0.5; // 0.0 to disable pulsation\nfloat rotationspeed = 2.0; // 0.0 to disable rotation; negative -> CW; positive -> CCW\n\n// Color options\nfloat gradient = 2.0; // 0.0 -> Fix to inner color\nvec3 innerColor = vec3(1.0,1.0,1.0); // from 0.0 to 1.0 Red-Green-Blue\nvec3 outerColor = vec3(0.0,0.0,0.25); // from 0.0 to 1.0 Red-Green-Blue\n\n/*\n * Further info:\n * CW = Clockwise rotation\n * CCW = Counter clockwise rotation\n *\n * When using rings (0 arms) CW will move inwards while CCW moves outwards\n *\n * Please not that I did this as a learning project. It seemed both simple enough to do but also complex enough to learn \n * writing shader effects.\n */\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 pos = ( fragCoord.xy - iResolution.xy / 2.0 ) / max(iResolution.x, iResolution.y);\n\t\n    float scaling = (sin((iTime * pulsespeed) + length(pos)) * pulsationStrength + 1.0) * spiralSize;\n\tfloat rotation = atan(pos.x, pos.y) * float(armCount) * 0.5 / PI * spacing + (iTime * rotationspeed);\n\tfloat intensity = max(0.0, 1.0 - mod(rotation - length(pos) * scaling , spacing));\n    intensity = min(intensity, (1.0 - intensity) * intensity * 0.04 * iResolution.y); //Thanks to Shane for this anti-aliasing hack\n\t\n\tvec3 col = mix(innerColor,outerColor, length(pos) * gradient);\n\tfragColor = vec4( col * intensity, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[957, 957, 1012, 1012, 1636]], "test": "valid"}
{"id": "fl33zs", "name": "Wood carvings", "author": "jarble", "description": "A series of richly decorated wooden artifacts.", "tags": ["fractal", "wood", "carving"], "likes": 3, "viewed": 124, "published": "Public API", "date": "1636519702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            uv = triangle_wave(uv.yx-offset,scale)+triangle_wave(uv,scale);\n            \n            for(int k = 0; k < 3; k++){\n                uv /= scale2;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]).yx;\n\n                scale /= 1.-(scale2+uv.x-uv.y)*col.x/5.;\n                scale2 += (col.x);\n\n            }\n            \n\n            col[c] = abs((uv.x)-(uv.y))/2.;\n\n        }\n\t}\n    \n    fragColor = vec4((col*4.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 1940]], "test": "valid"}
{"id": "fl33zX", "name": "Procedural fluid 2", "author": "arlomcwalter", "description": "A simple liquid style shader.", "tags": ["fluid", "liquid"], "likes": 5, "viewed": 210, "published": "Public API", "date": "1636400467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fluid(vec2 uv) {\n    for (float i = 1.0; i <= 20.; i++) {\n        uv.x -= iTime / 11. + sin(iTime + uv.y * -i) / i * 0.8 - sin(3.2);\n        uv.y -= iTime / 22. + uv.x * i * 0.5 / i * 0.9;\n    }\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fluid(fragCoord / iResolution.xy * 6.5);\n    \n    float r = abs(sin(uv.y / 1.1));\n    float g = abs(sin(uv.x / 2.2));\n    float b = abs(sin(uv.x / 3.3));\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 216], [218, 218, 273, 273, 479]], "test": "valid"}
{"id": "fl3GR7", "name": "qr light", "author": "huataishi", "description": "qr light study", "tags": ["2dqr"], "likes": 4, "viewed": 191, "published": "Public", "date": "1635845495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int modi(int a, int n){\n    return a - (n * int(a/n));\n}\n\nbool checkin(int x, int y, int w, int h){\n    return x>=0&&x<w && y>=0&&y<h; \n}\n\nint pow2(int x){\n    return int(pow(2.,float(x)));\n}\n\nconst int QR_LEN = 29;\nint QR[QR_LEN];\n\nvoid qrLoad(){\n    QR[28]=533147263;QR[27]=273053761;QR[26]=391663197;QR[25]=391794013;QR[24]=391099741;QR[23]=273901121;QR[22]=534074751;QR[21]=111104;QR[20]=52090595;QR[19]=229524769;QR[18]=3251061;QR[17]=49859844;QR[16]=282388420;QR[15]=425654187;QR[14]=115532266;QR[13]=364934657;QR[12]=110253038;QR[11]=500794045;QR[10]=309982567;QR[9]=28167609;QR[8]=502435577;QR[7]=52343552;QR[6]=123594111;QR[5]=152679745;QR[4]=335101021;QR[3]=380404317;QR[2]=266967645;QR[1]=383815489;QR[0]=128683391;\n}\nint qr(const int x,const int y){\n    int r = 1;\n    if (checkin(x,y, QR_LEN,QR_LEN)){\n        for (int i = 0 ; i < QR_LEN ; i++) if (y == i) r = modi( QR[i] / pow2(x) + 1, 2 );\n            return 1-r;\n    }\n}\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = 1.;\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2 = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = 1.;\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) / 2.4,iResolution.y * (sin(iTime + 3.1415) + 1.2) / 2.4);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) / 2.4, 340.0);\n\tvec4 light3Col = vec4(1., 0.75, 1.0, 1.0);\n    \n\tvec4 light4Col = vec4(0.5, 0.75, 1.0, 1.0);\n\t\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0);\n\tcol *= clamp(min(mod(p2.y, 10.0), mod(p2.x, 10.0)), 0.9, 1.0);\n\t\n\tcol += drawLight(p2, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(p2, light2Pos, light2Col, dist, 200.0, 8.0);\n\tcol += drawLight(p2, light3Pos, light3Col, dist, 300.0, 12.0);\n\tqrLoad();\n    ivec2 ir  = ivec2(iResolution.xy); \n    ivec2 ip  = ivec2(fragCoord.xy);\n    ivec2 it  = ip*31/ivec2(ir.y) ;\n    int width  = 31 * ir.x / ir.y;\n    int movex = (width -31)/2;\n    it.x -= movex;\n    float qrf = float(1-qr(it.x-1, it.y-1));\n    float t = iTime;\n    float t1 = clamp((t-0.)*.2,0.,1.);\n    vec2 ar   = vec2( iResolution.x/iResolution.y,1.);\n    vec2 uv   = fragCoord/iResolution.xy;\n    vec2 p1   = uv*ar;\n    col*= (1.-qrf);\n    col.xyz *=  1.7*smoothstep(0.,.8, t1*2.-length(p1-.5));\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3GR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 56], [58, 58, 99, 99, 137], [139, 139, 155, 155, 191], [233, 233, 247, 247, 728], [729, 729, 761, 761, 937], [939, 939, 979, 979, 1009], [1013, 1013, 1041, 1041, 1075], [1078, 1078, 1163, 1185, 1457], [1460, 1460, 1517, 1517, 2907]], "test": "error"}
{"id": "fl3GRl", "name": "Rounded Cylinder SDF", "author": "TheTurk", "description": "Distance function for a rounded cylinder (where the size of the cylinder is not affected by the corner radius). ", "tags": ["3d", "distancefield", "sdf", "distance", "cylinder", "rounded", "primitive"], "likes": 2, "viewed": 36, "published": "Public", "date": "1636500446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cylinder(vec3 position, float radius, float halfHeight, float cornerRadius) {\n   vec2 d = vec2(length(position.xz), abs(position.y)) - vec2(radius, halfHeight) + cornerRadius; \n   return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - cornerRadius;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat sdf(in vec3 position) { \n    float radius = 0.4;\n    float halfHeight = 0.2;\n    float cornerRadius = 0.01 + ((cos(iTime * 0.5) + 1.0) * 0.5) * 0.19;\n    float d = cylinder(position, radius, halfHeight, cornerRadius);\n    return d;\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.0;\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3GRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 256], [258, 258, 297, 297, 479], [481, 481, 535, 535, 876], [878, 878, 907, 907, 1117], [1119, 1119, 1147, 1147, 1492], [1494, 1494, 1544, 1544, 1926], [1928, 1928, 1983, 1983, 3473]], "test": "valid"}
{"id": "flc3DN", "name": "Ellipse from bounding box", "author": "singintime", "description": "Draw an ellipse with fill and stroke given its bounding box. Antialiased.", "tags": ["ellipse"], "likes": 0, "viewed": 28, "published": "Public", "date": "1636371699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author singintime\n *\n * Draw an ellipse given its bounding box (top left corner, width, and height),\n stroke width, stroke color, and fill color.\n */\nvec4 ellipse(vec2 uv, vec2 pos, float w, float h, float strokeWidth, vec4 strokeColor, vec4 fillColor) {\n    vec2 p = uv - pos;\n    vec2 pp = p * p;\n    vec2 d = vec2(w, h) / 2.0;\n    float s = strokeWidth / 2.0;\n    vec2 dFillIn = d - s - 0.5;\n    vec2 dFillOut = d - s + 0.5;\n    float magFillIn = dot(pp, 1.0 / dFillIn / dFillIn);\n    float magFillOut = dot(pp, 1.0 / dFillOut / dFillOut);\n    float blend;\n    \n\tif (magFillIn < 1.0) {\n\t\treturn fillColor;\n\t}\n    \n    if (magFillOut < 1.0) {\n        blend = (1.0 - magFillOut) / (magFillIn - magFillOut);\n        return strokeWidth <= 0.0\n            ? vec4(fillColor.rgb, blend)\n            : fillColor * blend + strokeColor * (1.0 - blend);\n    }\n\n    vec2 dStrokeIn = d + s - 0.5;\n    vec2 dStrokeOut = d + s + 0.5;\n    float magStrokeIn = dot(pp, 1.0 / dStrokeIn / dStrokeIn);\n    float magStrokeOut = dot(pp, 1.0 / dStrokeOut / dStrokeOut);\n    \n    if (magStrokeIn < 1.0) {\n        return strokeColor;\n    }\n\n    if (magStrokeOut < 1.0) {\n        blend = (1.0 - magStrokeOut) / (magStrokeIn - magStrokeOut);\n        return vec4(strokeColor.rgb, blend);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat width = (0.3 + 0.2 * cos(iTime)) * iResolution.y;\n\tfloat height = (0.3 + 0.2 * sin(iTime)) * iResolution.y;\n    float strokeWidth = 10.0 + 10.0 * cos(iTime / 5.0);\n    \n    // Background\n\tvec4 layer1 = vec4(0.65, 0.65, 0.65, 1.0);\n\t\n\t// Ellipse\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 layer2 = ellipse(uv, center, width, height, strokeWidth, black, white);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 262, 262, 1277], [1279, 1279, 1334, 1334, 1875]], "test": "error"}
{"id": "flc3DX", "name": "myFirstShamder", "author": "AlanHaBrony", "description": "Oh I just want to add sin to make some animation, so amazing! (Although I even haven't figure out how it works (a little shame)\n\nAnd I very very wonder the math behand this (it isn't high level but high \"performance\")", "tags": ["sin", "animate"], "likes": 1, "viewed": 113, "published": "Public API", "date": "1636802450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5f;\n    \n    //grt time(much easier than in vs2019)\n    float t=iTime;\n   \n    float d=length(uv);\n    float an=d+sin(t+.5f);\n    \n    vec2 ret=fract(5.*an*uv);\n\n    // Output to screen\n    fragColor = vec4(ret,1.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]], "test": "valid"}
{"id": "flc3RN", "name": "Obfuscated rotating triangle", "author": "curvedcubes", "description": "It's somewhere in there behind all the coordinate distortions and patterns, I promise!", "tags": ["triangle", "checkerboard", "chromatic", "aberration", "impulse"], "likes": 3, "viewed": 50, "published": "Public", "date": "1635767218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141596\n\nvec2 rot(vec2 p, float an){\n\tmat2x2 rota = mat2x2( cos(an), -sin(an), \n\t\t\t\t\t\t  sin(an), cos(an)  );\n\treturn rota*p;\n}\n\n// checks if pixel is inside tri with angles an and (distance of lines from origin)==a\nbool tri(vec2 p, vec3 an, float a){\n\tbool tri = true;\n\tfor(int i=0; i<3 && tri; i++){ \n\t\ttri = p.y > -a; // loop break = pixel.y not less then a from origin\n\t\tp = rot(p, radians(an[i])); // rotation for next side\n\t}\n\treturn tri;\n}\n\n// absolute sort of triangle wave as time\nfloat time(){\n\treturn abs(0.3*tan(sin((iTime-1.0)/3.))+0.5);\n}\n\n// coordinate weirdness\nvec2 weird(vec2 uv){\n\tuv *= 1.0+length(uv);\n\treturn mix(vec2(uv.x, uv.y*sin(10.*uv.y)), vec2(uv.x*cos(10.*uv.x), uv.y), time()); // idk it's fun\n}\n\n// checkerboard pattern\nfloat pattern(vec2 p, float a){\n\treturn abs(mod(floor(a*p.x), 2.0)-mod(floor(a*p.y), 2.0));\n}\n\n// iq's exponential impulse\nfloat impulse(float x, float k){\n\tx += 1.0/k;\n\tfloat h = k*x;\n\treturn h*exp(1.0-h);\n}\t\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 col = vec3(0);\n\tfloat t;\n\tfor(int i=0; i<3; i++){\n\t\tvec2 uv = (gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n\t\t\n\t\tfloat d = distance(time(), 0.5); // at time()==0.5, the animation tips\n\t\tfloat boing = max(0.5*impulse((time()-0.5)*20., 4.0+float(i)), -1.0); // aberation impulse param\n\t\tuv *= sqrt(d*0.3*float(i)+1.0) - boing + 0.01*boing*boing*(3.0-2.0*boing); // aberation & scale animation\n\t\t\n\t\tvec2 orig = uv;\n\t\tuv *= 2.;\n\t\tuv += (mod(uv, 0.06)-0.06); // tiling, broken glass sorta effect\n\t\tuv = weird(uv);\n\t\t\n\t\tbool tri = tri(rot(uv, 1.1*iTime), vec3(120), 0.5); // rotating triangle\n\t\tcol[i] = tri ? pattern(uv, 1.0) : 0.0; // tweak second pattern argument for different effects\n\t\tcol[i] = mix(col[i], col[i] * clamp(pattern(gl_FragCoord.xy, 0.333)*abs(1.0/length(uv)), 0.0, 1.0), 1.0/length(orig)); // mini pattern\n\t}\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 48, 48, 138], [140, 227, 262, 262, 457], [459, 501, 514, 514, 563], [565, 589, 609, 609, 735], [737, 761, 792, 792, 854], [856, 884, 916, 916, 969], [972, 972, 1026, 1026, 1891]], "test": "valid"}
{"id": "flc3Rs", "name": "Licorice Wheel Tower", "author": "Tater", "description": "The code became very messy but the result is good, just don't look at the code :)", "tags": ["3d", "raymarching", "spiral", "roll"], "likes": 44, "viewed": 426, "published": "Public API", "date": "1636529648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Spiral SDF testing 4\" by Tater. https://shadertoy.com/view/Nl3Gzj\n// 2021-11-10 02:34:13\n\n// Fork of \"Spiral SDF testing 3\" by Tater. https://shadertoy.com/view/Nlc3Rj\n// 2021-11-08 02:08:11\n\n// Fork of \"Spiral SDF testing 2\" by Tater. https://shadertoy.com/view/fs3Xzf\n// 2021-11-08 02:05:42\n\n// Fork of \"Spiral SDF testing\" by Tater. https://shadertoy.com/view/fs3SzX\n// 2021-10-07 08:34:52\n\n//Inspiration:\n//https://twitter.com/smjtyazdi/status/1457290470497869824\n//https://www.brucescandy.com/products/red-licorice-wheels\n\n\n#define MDIST 150.0\n#define STEPS 128.0\n\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 rdg;\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//iq extrude\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\n\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return rc.z+0.01;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\n\n\n\n//This is a large mess :)\nvec2 spiral(vec2 p, float t, float m, float scale, float size, float expand, float pz,float timeOffset){\n    \n    size-=expand-0.01;\n    float R1 = (sqrt(m*(m*pi+4.0*t*pi)))+m*sqrt(pi)/(2.0*m*sqrt(pi)) -1.0;\n    float RT1 = R1;\n    float R2 = (sqrt(m*(m*pi+4.0*max(-t+timeOffset,0.)*pi)))+m*sqrt(pi)/(2.0*m*sqrt(pi)) -1.0;\n    float RT2 = R2;\n    R1 = R1*m-m*0.5;\n    R2 = R2*m-m*0.5;\n    float centDist = 22.0*3.5*scale+sin(t*0.5+pi)*1.25;\n\n    float L = sqrt(centDist*centDist-(R2+R1)*(R2+R1));\n    \n    p.x+=L*0.5*sin(t);\n    p*=rot(-(RT2-RT1)*pi*1.0);\n    p*=rot(-atan((R2+R1)/L)-0.13);\n    p.x-=L*0.5;\n    p.y-=R2;\n\n    vec2 po3 = p;\n    float s = sign(p.x);\n    p.x = abs(p.x);\n    \n    float c = max(p.x+0.125+expand,abs(p.y)-(R2+R1)*2.0);\n    \n    p.x-=L*0.5;\n\n    p.y*=s;\n    float to2 = t;\n    t*=s;\n    \n    //if(s<0.0)t+=timeOffset;\n    \n    t = max(t,0.);\n    float to = t;\n\n    if(s>0.)t=RT1;\n    else t = RT2;\n    vec2 po = p;\n    p.y+=-t*m-m*0.5;\n\n    p*=rot(t*pi*2.+pi/2.);\n    \n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    p.y+=theta*scale*0.5;\n\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n    float py2 = p.y;\n    float hel = -(theta+pi)/(2.*pi)+id; \n    \n    float a = abs(p.y)-size;\n    \n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    if(a>b-size){\n        a=b-size;\n        py2=p.y;\n    }\n    b = abs(po.y)-size;\n    b = max(po.x*30.,b);\n    \n    if(b<a) {\n        id = ceil(t);\n        py2=-po.y;\n        hel*=id;\n    }\n    else hel*=max(id,0.4);\n    \n    float strip = (sin(hel*pi*20.)*0.5+0.5);\n    vec3 p2 = vec3(hel,py2+hel*0.1,pz)*7.0+to2*0.2;\n    p2.xy*=rot(0.4);\n    //Taken from https://www.shadertoy.com/view/tsBSzc\n    strip =  smoothstep(-.05,.05,  length(p2 - (floor(p2) + cos(floor(p2.zxy) * 10.) * .25 + .5)) - .25);\n    \n    if(b<a){\n        hel = (po3.x*(0.04/scale)-to2/(sqrt(pi)*(0.04/scale)))*1.1;\n        p2 = vec3(hel,po3.y,pz*0.8+hel*0.01)*8.0+to2*0.2;\n        p2.xy*=rot(0.4);\n        float strip2 = smoothstep(-.05,.05,  length(p2 - (floor(p2) + cos(floor(p2.zxy) * 10.) * .25 + .5)) - .3);\n        strip = mix(strip,strip2,1.0-smoothstep(-0.4,0.,po.x));\n       // strip = strip2;\n    }\n    a = min(a,b);\n    a = min(a,c); \n    return vec2(a,strip);\n}\nvec4 map(vec3 p){\n    float t = iTime;\n    vec3 rd2 = rdg;\n    \n    p.yz=p.zy;\n    rd2.yz=rd2.zy;\n    \n    p.zx*=rot(sin(t)*0.125);\n    rd2.zx*=rot(sin(t)*0.125);\n    p.zx*=rot(cos(t)*0.125);\n    rd2.zx*=rot(cos(t)*0.125);\n    p.xy*=rot(pi);\n    rd2.xy*=rot(pi);\n    p.xy*=rot(t);\n    rd2.xy*=rot(t);\n    \n    vec3 po = p;\n    vec2 a = vec2(1);\n    \n    float timeOffset = 30.0;\n    \n    float scale = 0.05;\n    float m = pi*scale;\n    float size = 0.07;\n    float expand = m*0.5;\n    float count = 14.0;\n    float thick = 0.075;\n    \n    float id = idlim(p.z,m+scale+thick*1.5,-count,count);\n    p.z = lim(p.z,m+scale+thick*1.5,-count,count);\n    t*=0.25;\n    t+=id*0.025;\n    //timeOffset+=id*1.0;\n    t = (tanh(sin(t)*1.2)*0.55+0.5)*timeOffset;\n    \n    p.xy*=rot(id*pi/30.0);\n    \n    vec2 b = spiral(p.xy, t, m, scale, size, expand, po.z,timeOffset);\n    a.x = ext(p.yzx,b.x,thick)-expand;\n    a.x*=0.9;\n    vec2 c= vec2(diplane(p,vec3(m+thick-scale),rd2)*0.9,5.0);\n    \n    a.y+=b.y;\n    float nsdf = a.x;\n    a=(a.x<c.x)?a:c;\n    return vec4(a,nsdf,id);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,7,-5)*1.1;\n    ro.yz*=rot(0.2);\n    if(iMouse.z>0.){\n    ro.yz*=rot(3.0*(iMouse.y/iResolution.y-0.2));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.55)+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    bool hit = false;\n    vec4 d= vec4(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.001){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    vec3 bg = mix(vec3(0.710,0.310,0.792),vec3(0.184,0.031,0.286)*0.75,length(uv));\n    if(hit&&d.y!=5.0)\n    {\n        vec3 ld = normalize(vec3(0,1,0));\n      \n        //sss from nusan\n        float sss=0.15;\n        for(float i=1.; i<10.; ++i){\n            float dist = i*0.05;\n            sss += smoothstep(0.,1.,map(p+ld*dist).z/dist)*0.055;\n        }\n        vec3 al = vec3(0.25,0.25,0.373)*0.8;\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        //blackle ao\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*(hsv(vec3(fract(d.w*0.5)*0.45+0.75,1.,1.35)));\n        col=pow(col,vec3(mix(1.2,1.0,d.y-1.0)));\n        col*=mix(0.8,1.0,d.y-1.0);\n        col*=mix(ao,1.,0.6);\n        col = pow(col,vec3(0.7));\n    }\n    else{\n    col = bg;\n    }\n    col = clamp(col,0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 703, 720, 720, 889], [890, 903, 939, 939, 1021], [1023, 1023, 1060, 1060, 1140], [1141, 1141, 1193, 1193, 1239], [1240, 1240, 1294, 1294, 1336], [1340, 1366, 1470, 1470, 3759], [3760, 3760, 3777, 3777, 4822], [4823, 4823, 4841, 4841, 4969], [4971, 4971, 5028, 5028, 6959]], "test": "valid"}
{"id": "flcGDr", "name": "CharActor", "author": "mizumasa", "description": "The personality of living things is beautiful. Is it possible to have a personality in the digital world?\nCharActor is a video work that produces animation by recognizing shader programs as genes and by changing the mathematical expression itself.", "tags": ["generative", "python"], "likes": 1, "viewed": 53, "published": "Public", "date": "1635952385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor = vec4(0.);\nvec2 uv = vec2(0.);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,-0.45) )*vec2(10.,10.);\nfloat a_0 = atan(acos( radians( asin( asin( sin( acos( tan( sin( sin( degrees( atan( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , acos( radians( asin( asin( sin( acos( tan( sin( sin( degrees( atan( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( sin( abs( ceil( a_0 ) ) + iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,-0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( sin( tan( ceil( tan( sin( degrees( floor( atan( abs( tan( atan( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( ceil( tan( sin( degrees( floor( atan( abs( tan( atan( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     tan( atan( abs( floor( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,-0.25) )*vec2(10.,10.);\n a_0 = abs( atan(floor( radians( asin( abs( asin( sin( tan( sin( sin( degrees( floor( abs( radians( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , floor( radians( asin( abs( asin( sin( tan( sin( sin( degrees( floor( abs( radians( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( log2( fract( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,-0.15) )*vec2(10.,10.);\n a_0 = atan(log( degrees( abs( radians( asin( asin( degrees( log2( tan( sin( atan( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) ) ) ) ) ) ).y , log( degrees( abs( radians( asin( asin( degrees( log2( tan( sin( atan( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( ceil( cos( sqrt( abs( ceil( a_0 ) ) ) / iTime) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,-0.05) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( radians( sqrt( asin( fract( sin( tan( sin( asin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( radians( sqrt( asin( fract( sin( tan( sin( asin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( radians( abs( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,0.05) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( radians( sin( asin( sin( tan( sin( atan( degrees( sin( abs( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( sin( asin( sin( tan( sin( atan( degrees( sin( abs( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     exp( abs( log( floor( abs( ceil( a_0 ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,0.15) )*vec2(10.,10.);\n a_0 = atan(sqrt( acos( degrees( radians( asin( radians( sin( floor( tan( sin( degrees( floor( sin( abs( log2( uv ) ) + iTime) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , sqrt( acos( degrees( radians( asin( radians( sin( floor( tan( sin( degrees( floor( sin( abs( log2( uv ) ) + iTime) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,0.25) )*vec2(10.,10.);\n a_0 = exp( atan(fract( degrees( radians( normalize( asin( sin( tan( sqrt( sin( degrees( floor( cos( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , fract( degrees( radians( normalize( asin( sin( tan( sqrt( sin( degrees( floor( cos( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( asin( asin( sin( tan( sin( degrees( degrees( floor( abs( uv.y * ceil( log2( uv ) ) - floor(uv.y * ceil( log2( uv ) )) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( abs( radians( asin( asin( sin( tan( sin( degrees( degrees( floor( abs( uv.y * ceil( log2( uv ) ) - floor(uv.y * ceil( log2( uv ) )) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sqrt( abs( abs( tan( cos( asin( asin( ceil( a_0 ) ) ) / iTime) * iTime) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.45,0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( fract( radians( asin( asin( exp2( sin( log2( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( fract( radians( asin( asin( exp2( sin( log2( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( log( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,-0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( floor( sin( radians( asin( asin( sin( tan( sqrt( exp( exp( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) * iTime) ) ).y , degrees( floor( sin( radians( asin( asin( sin( tan( sqrt( exp( exp( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) * iTime) ) ).x);\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,-0.35) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( sin( tan( radians( asin( tan( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( sin( tan( radians( asin( tan( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     floor( abs( cos( abs( radians( abs( cos( ceil( a_0 ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,-0.25) )*vec2(10.,10.);\n a_0 = atan(sqrt( log( degrees( radians( exp( asin( asin( sin( tan( sin( log( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , sqrt( log( degrees( radians( exp( asin( asin( sin( tan( sin( log( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     acos( asin( ceil( a_0 ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,-0.15) )*vec2(10.,10.);\n a_0 = sign( atan(degrees( abs( radians( asin( asin( sin( tan( asin( degrees( exp2( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( abs( radians( asin( asin( sin( tan( asin( degrees( exp2( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,-0.05) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( radians( sign( asin( asin( sin( sin( tan( sin( log2( floor( abs( log2( log2( uv ) ) ) ) ) ) ) + iTime) + iTime) ) ) ) ) ).y , degrees( radians( sign( asin( asin( sin( sin( tan( sin( log2( floor( abs( log2( log2( uv ) ) ) ) ) ) ) + iTime) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     cos( acos( asin( sin( a_0 * iTime) ) ) / iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,0.05) )*vec2(10.,10.);\n a_0 = atan(log( degrees( abs( radians( asin( asin( sin( tan( radians( abs( radians( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , log( degrees( abs( radians( asin( asin( sin( tan( radians( abs( radians( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     exp2( abs( abs( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,0.15) )*vec2(10.,10.);\n a_0 = atan(sign( radians( asin( asin( abs( uv.y * sin( abs( tan( sin( degrees( floor( fract( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) - floor(uv.y * sin( abs( tan( sin( degrees( floor( fract( abs( log2( uv ) ) ) ) ) ) ) ) + iTime)) ) ) ) ) ).y , sign( radians( asin( asin( abs( uv.y * sin( abs( tan( sin( degrees( floor( fract( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) - floor(uv.y * sin( abs( tan( sin( degrees( floor( fract( abs( log2( uv ) ) ) ) ) ) ) ) + iTime)) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( radians( abs( abs( sin( cos( a_0 ) + iTime) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,0.25) )*vec2(10.,10.);\n a_0 = exp2( atan(degrees( radians( asin( asin( sin( tan( sin( sign( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( sign( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( cos( sin( ceil( a_0 ) * iTime) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,0.35) )*vec2(10.,10.);\n a_0 = atan(atan( degrees( abs( radians( degrees( asin( abs( sin( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , atan( degrees( abs( radians( degrees( asin( abs( sin( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     cos( exp( sin( sin( ceil( a_0 ) + iTime) ) ) / iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.35,0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( abs( uv.y * asin( asin( sin( tan( sin( degrees( floor( asin( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) - floor(uv.y * asin( asin( sin( tan( sin( degrees( floor( asin( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) )) ) ) ).y , degrees( abs( abs( uv.y * asin( asin( sin( tan( sin( degrees( floor( asin( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) - floor(uv.y * asin( asin( sin( tan( sin( degrees( floor( asin( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) )) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     degrees( abs( exp( cos( log2( cos( ceil( a_0 ) / iTime) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,-0.45) )*vec2(10.,10.);\n a_0 = atan( atan(degrees( radians( radians( asin( asin( ceil( sin( uv.x * tan( sin( degrees( sign( abs( log2( uv ) ) ) ) ) ) - floor(uv.x * tan( sin( degrees( sign( abs( log2( uv ) ) ) ) ) )) + iTime) ) ) ) ) ) ).y , degrees( radians( radians( asin( asin( ceil( sin( uv.x * tan( sin( degrees( sign( abs( log2( uv ) ) ) ) ) ) - floor(uv.x * tan( sin( degrees( sign( abs( log2( uv ) ) ) ) ) )) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( exp( uv.x * fract( sin( uv.x * a_0 - floor(uv.x * a_0) + iTime) ) - floor(uv.x * fract( sin( uv.x * a_0 - floor(uv.x * a_0) + iTime) )) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,-0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( sin( radians( atan( asin( asin( sin( tan( sin( abs( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) ) + iTime) ).y , degrees( sin( radians( atan( asin( asin( sin( tan( sin( abs( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) ) + iTime) ).x);\nfragColor += clamp( abs( vec4(\n     uv.y * a_0 - floor(uv.y * a_0) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,-0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( cos( abs( sin( tan( tan( sin( exp( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( asin( asin( cos( abs( sin( tan( tan( sin( exp( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     acos( degrees( cos( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,-0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( asin( asin( acos( sin( tan( sin( degrees( cos( fract( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( abs( radians( asin( asin( acos( sin( tan( sin( degrees( cos( fract( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sin( uv.x * abs( sin( abs( floor( ceil( a_0 ) ) ) * iTime) ) - floor(uv.x * abs( sin( abs( floor( ceil( a_0 ) ) ) * iTime) )) * iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,-0.05) )*vec2(10.,10.);\n a_0 = abs( atan(atan( degrees( degrees( asin( asin( sin( tan( cos( sin( degrees( floor( tan( abs( log2( uv ) ) * iTime) ) ) ) / iTime) ) + iTime) ) ) ) ) ).y , atan( degrees( degrees( asin( asin( sin( tan( cos( sin( degrees( floor( tan( abs( log2( uv ) ) * iTime) ) ) ) / iTime) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,0.05) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( radians( asin( acos( asin( abs( sin( acos( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( asin( acos( asin( abs( sin( acos( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     sin( exp2( sin( ceil( a_0 ) + iTime) ) + iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( uv.x * sin( radians( asin( ceil( sin( tan( sin( sin( tan( degrees( floor( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) * iTime) - floor(uv.x * sin( radians( asin( ceil( sin( tan( sin( sin( tan( degrees( floor( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) * iTime)) ).y , degrees( uv.x * sin( radians( asin( ceil( sin( tan( sin( sin( tan( degrees( floor( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) * iTime) - floor(uv.x * sin( radians( asin( ceil( sin( tan( sin( sin( tan( degrees( floor( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) * iTime)) ).x);\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( abs( radians( asin( asin( sin( sign( tan( sin( degrees( floor( abs( abs( sin( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( abs( radians( asin( asin( sin( sign( tan( sin( degrees( floor( abs( abs( sin( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     radians( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( exp( asin( radians( sin( tan( radians( sin( asin( floor( log2( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( asin( exp( asin( radians( sin( tan( radians( sin( asin( floor( log2( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     log2( fract( sin( uv.x * ceil( a_0 ) - floor(uv.x * ceil( a_0 )) * iTime) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.25,0.45) )*vec2(10.,10.);\n a_0 = log( atan(degrees( radians( asin( asin( sin( sin( tan( uv.y * sin( degrees( floor( abs( sin( log2( uv ) + iTime) ) ) ) ) - floor(uv.y * sin( degrees( floor( abs( sin( log2( uv ) + iTime) ) ) ) )) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( sin( tan( uv.y * sin( degrees( floor( abs( sin( log2( uv ) + iTime) ) ) ) ) - floor(uv.y * sin( degrees( floor( abs( sin( log2( uv ) + iTime) ) ) ) )) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     radians( acos( abs( cos( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,-0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( asin( degrees( asin( sin( tan( sin( asin( degrees( floor( sign( abs( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( abs( asin( degrees( asin( sin( tan( sin( asin( degrees( floor( sign( abs( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( ceil( ceil( radians( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,-0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( normalize( asin( sin( asin( abs( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( normalize( asin( sin( asin( abs( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     log( exp( asin( log2( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,-0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( sin( tan( sin( floor( cos( cos( floor( abs( log2( uv ) ) ) ) / iTime) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( floor( cos( cos( floor( abs( log2( uv ) ) ) ) / iTime) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     tan( sin( uv.y * abs( ceil( a_0 ) ) - floor(uv.y * abs( ceil( a_0 ) )) * iTime) * iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,-0.15) )*vec2(10.,10.);\n a_0 = atan(abs( radians( asin( abs( asin( sin( sin( tan( sin( degrees( floor( atan( abs( log2( uv ) ) ) ) ) ) ) + iTime) * iTime) ) ) ) ) ).y , abs( radians( asin( abs( asin( sin( sin( tan( sin( degrees( floor( atan( abs( log2( uv ) ) ) ) ) ) ) + iTime) * iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     uv.x * sin( abs( log( ceil( a_0 ) ) ) + iTime) - floor(uv.x * sin( abs( log( ceil( a_0 ) ) ) + iTime)) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,-0.05) )*vec2(10.,10.);\n a_0 = asin( abs( sin( atan(degrees( radians( asin( asin( sin( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ).x) + iTime) ) );\nfragColor += clamp( abs( vec4(\n     abs( abs( ceil( floor( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,0.05) )*vec2(10.,10.);\n a_0 = atan(floor( degrees( radians( asin( asin( sin( tan( asin( fract( sqrt( uv.x * degrees( floor( abs( log2( uv ) ) ) ) - floor(uv.x * degrees( floor( abs( log2( uv ) ) ) )) ) ) ) ) + iTime) ) ) ) ) ).y , floor( degrees( radians( asin( asin( sin( tan( asin( fract( sqrt( uv.x * degrees( floor( abs( log2( uv ) ) ) ) - floor(uv.x * degrees( floor( abs( log2( uv ) ) ) )) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sin( abs( ceil( a_0 ) ) * iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( abs( atan( asin( asin( abs( sin( fract( exp2( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , degrees( radians( abs( atan( asin( asin( abs( sin( fract( exp2( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     degrees( log( abs( floor( abs( sin( asin( atan( a_0 ) ) + iTime) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( degrees( asin( acos( exp2( asin( sin( tan( sin( sin( degrees( atan( abs( log2( uv ) ) ) ) ) + iTime) ) + iTime) ) ) ) ) ) ) ).y , degrees( radians( degrees( asin( acos( exp2( asin( sin( tan( sin( sin( degrees( atan( abs( log2( uv ) ) ) ) ) + iTime) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     uv.x * ceil( a_0 ) - floor(uv.x * ceil( a_0 )) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( asin( radians( asin( asin( sin( tan( sin( sin( log( degrees( floor( abs( log( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( asin( radians( asin( asin( sin( tan( sin( sin( log( degrees( floor( abs( log( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     asin( acos( abs( floor( cos( ceil( abs( a_0 ) ) / iTime) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.15,0.45) )*vec2(10.,10.);\n a_0 = abs( atan(log( degrees( exp2( radians( asin( asin( sin( tan( sin( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , log( degrees( exp2( radians( asin( asin( sin( tan( sin( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,-0.45) )*vec2(10.,10.);\n a_0 = sqrt( degrees( atan(log2( radians( asin( asin( sin( tan( cos( sin( degrees( floor( tan( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , log2( radians( asin( asin( sin( tan( cos( sin( degrees( floor( tan( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x) ) );\nfragColor += clamp( abs( vec4(\n     abs( tan( sign( sign( acos( abs( ceil( a_0 ) ) ) ) ) * iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,-0.35) )*vec2(10.,10.);\n a_0 = atan(fract( degrees( radians( asin( asin( floor( degrees( abs( sin( tan( sin( degrees( floor( abs( cos( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ) ).y , fract( degrees( radians( asin( asin( floor( degrees( abs( sin( tan( sin( degrees( floor( abs( cos( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     exp( abs( radians( uv.y * abs( abs( floor( a_0 ) ) ) - floor(uv.y * abs( abs( floor( a_0 ) ) )) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,-0.25) )*vec2(10.,10.);\n a_0 = sqrt( atan(radians( radians( asin( asin( sin( tan( fract( uv.y * sin( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) - floor(uv.y * sin( abs( degrees( floor( abs( log2( uv ) ) ) ) ) )) ) ) + iTime) ) ) ) ).y , radians( radians( asin( asin( sin( tan( fract( uv.y * sin( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) - floor(uv.y * sin( abs( degrees( floor( abs( log2( uv ) ) ) ) ) )) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     radians( fract( abs( sin( radians( abs( abs( atan( a_0 ) ) ) ) + iTime) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,-0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( sin( tan( sin( degrees( asin( floor( sign( degrees( sign( abs( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( degrees( asin( floor( sign( degrees( sign( abs( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     exp( atan( sign( fract( sqrt( sign( abs( ceil( a_0 ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,-0.05) )*vec2(10.,10.);\n a_0 = atan(sqrt( degrees( radians( asin( asin( degrees( tan( sin( degrees( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) ) ) ) ) ) ).y , sqrt( degrees( radians( asin( asin( degrees( tan( sin( degrees( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,0.05) )*vec2(10.,10.);\n a_0 = atan(log( radians( degrees( radians( degrees( asin( asin( sin( tan( abs( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , log( radians( degrees( radians( degrees( asin( asin( sin( tan( abs( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( sign( abs( abs( uv.y * abs( tan( a_0 ) ) - floor(uv.y * abs( tan( a_0 ) )) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( fract( radians( log( asin( ceil( sin( tan( sin( log2( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( fract( radians( log( asin( ceil( sin( tan( sin( log2( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     atan( abs( log( asin( degrees( sin( abs( sin( a_0 + iTime) ) + iTime) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( tan( asin( sin( sign( abs( sin( degrees( floor( abs( abs( acos( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) * iTime) ) ) ).y , degrees( radians( asin( tan( asin( sin( sign( abs( sin( degrees( floor( abs( abs( acos( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) * iTime) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( log2( abs( abs( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( sin( tan( sin( sign( sign( sqrt( degrees( floor( atan( abs( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( sign( sign( sqrt( degrees( floor( atan( abs( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     radians( degrees( abs( asin( abs( acos( atan( abs( ceil( a_0 ) ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(-0.05,0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( asin( sin( abs( fract( sin( tan( uv.x * sin( degrees( floor( abs( log2( uv ) ) ) ) ) - floor(uv.x * sin( degrees( floor( abs( log2( uv ) ) ) ) )) ) + iTime) ) ) ) ) ) ) ).y , degrees( abs( radians( asin( sin( abs( fract( sin( tan( uv.x * sin( degrees( floor( abs( log2( uv ) ) ) ) ) - floor(uv.x * sin( degrees( floor( abs( log2( uv ) ) ) ) )) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( tan( ceil( a_0 ) * iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,-0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( exp( asin( asin( sin( tan( cos( tan( abs( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) / iTime) ) + iTime) ) ) ) ) ).y , degrees( radians( exp( asin( asin( sin( tan( cos( tan( abs( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) / iTime) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sin( abs( abs( abs( exp2( ceil( a_0 ) ) ) ) ) + iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,-0.35) )*vec2(10.,10.);\n a_0 = exp( atan(sign( radians( asin( asin( sin( tan( cos( asin( sin( degrees( floor( abs( atan( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , sign( radians( asin( asin( sin( tan( cos( asin( sin( degrees( floor( abs( atan( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     log2( log( sqrt( uv.x * sqrt( ceil( a_0 ) ) - floor(uv.x * sqrt( ceil( a_0 ) )) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,-0.25) )*vec2(10.,10.);\n a_0 = atan(sign( degrees( radians( log2( asin( asin( sin( tan( sin( degrees( sqrt( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , sign( degrees( radians( log2( asin( asin( sin( tan( sin( degrees( sqrt( floor( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,-0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( radians( asin( asin( sin( tan( degrees( abs( fract( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( abs( radians( radians( asin( asin( sin( tan( degrees( abs( fract( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     asin( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,-0.05) )*vec2(10.,10.);\n a_0 = atan(fract( degrees( radians( asin( log2( abs( asin( sin( tan( sin( degrees( floor( exp( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , fract( degrees( radians( asin( log2( abs( asin( sin( tan( sin( degrees( floor( exp( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sqrt( floor( abs( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,0.05) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( cos( asin( asin( uv.y * log2( sin( tan( sin( degrees( floor( sin( fract( log2( uv ) ) ) ) ) ) ) + iTime) ) - floor(uv.y * log2( sin( tan( sin( degrees( floor( sin( fract( log2( uv ) ) ) ) ) ) ) + iTime) )) ) ) ) ) ).y , degrees( radians( cos( asin( asin( uv.y * log2( sin( tan( sin( degrees( floor( sin( fract( log2( uv ) ) ) ) ) ) ) + iTime) ) - floor(uv.y * log2( sin( tan( sin( degrees( floor( sin( fract( log2( uv ) ) ) ) ) ) ) + iTime) )) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( sqrt( ceil( a_0 ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,0.15) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( abs( radians( asin( asin( sin( abs( tan( sin( exp2( degrees( floor( exp2( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( abs( radians( asin( asin( sin( abs( tan( sin( exp2( degrees( floor( exp2( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     cos( abs( radians( abs( atan( ceil( a_0 ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,0.25) )*vec2(10.,10.);\n a_0 = atan(acos( abs( degrees( log( radians( asin( exp( asin( sin( tan( sin( degrees( floor( abs( fract( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ) ).y , acos( abs( degrees( log( radians( asin( exp( asin( sin( tan( sin( degrees( floor( abs( fract( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     ceil( radians( abs( abs( sign( abs( sign( abs( ceil( a_0 ) ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,0.35) )*vec2(10.,10.);\n a_0 = atan(abs( abs( degrees( radians( asin( tan( asin( sin( tan( floor( sin( degrees( asin( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) * iTime) ) ) ) ) ).y , abs( abs( degrees( radians( asin( tan( asin( sin( tan( floor( sin( degrees( asin( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) * iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sign( radians( exp( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.05,0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( sign( sign( asin( asin( sin( tan( asin( degrees( floor( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( sign( sign( asin( asin( sin( tan( asin( degrees( floor( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( degrees( log( abs( sqrt( abs( ceil( a_0 ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,-0.45) )*vec2(10.,10.);\n a_0 = abs( cos( atan(degrees( radians( asin( ceil( sin( tan( sin( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) ).y , degrees( radians( asin( ceil( sin( tan( sin( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) * iTime) ) + iTime) ) ) ) ).x) ) );\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( abs( abs( sign( abs( ceil( a_0 ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,-0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( log2( radians( asin( abs( asin( sin( tan( sin( exp2( log( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( log2( radians( asin( abs( asin( sin( tan( sin( exp2( log( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( sin( exp( abs( ceil( a_0 ) ) ) + iTime) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,-0.25) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( radians( asin( radians( asin( exp( sin( tan( tan( sin( sin( floor( abs( log2( uv ) ) ) ) ) ) * iTime) + iTime) ) ) ) ) ) ).y , degrees( radians( asin( radians( asin( exp( sin( tan( tan( sin( sin( floor( abs( log2( uv ) ) ) ) ) ) * iTime) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,-0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( degrees( asin( log( sin( tan( log( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( asin( degrees( asin( log( sin( tan( log( abs( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( fract( log2( log2( radians( abs( sqrt( ceil( a_0 ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,-0.05) )*vec2(10.,10.);\n a_0 = atan(degrees( sqrt( radians( asin( asin( sin( sin( tan( sin( degrees( acos( exp2( abs( radians( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( sqrt( radians( asin( asin( sin( sin( tan( sin( degrees( acos( exp2( abs( radians( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,0.05) )*vec2(10.,10.);\n a_0 = atan(sin( degrees( radians( asin( asin( sin( asin( acos( tan( exp2( degrees( floor( uv.x * abs( log2( uv ) ) - floor(uv.x * abs( log2( uv ) )) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , sin( degrees( radians( asin( asin( sin( asin( acos( tan( exp2( degrees( floor( uv.x * abs( log2( uv ) ) - floor(uv.x * abs( log2( uv ) )) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( log( abs( abs( fract( ceil( a_0 ) ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( acos( asin( degrees( floor( sin( tan( abs( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( acos( asin( degrees( floor( sin( tan( abs( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( sin( log( acos( radians( degrees( ceil( a_0 ) ) ) ) ) * iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,0.25) )*vec2(10.,10.);\n a_0 = uv.x * atan(degrees( radians( asin( cos( asin( sin( tan( sin( abs( degrees( floor( cos( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( radians( asin( cos( asin( sin( tan( sin( abs( degrees( floor( cos( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) - floor(uv.x * atan(degrees( radians( asin( cos( asin( sin( tan( sin( abs( degrees( floor( cos( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( radians( asin( cos( asin( sin( tan( sin( abs( degrees( floor( cos( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x));\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( exp2( asin( asin( abs( sin( tan( cos( sin( degrees( floor( floor( abs( abs( log2( uv ) ) ) ) ) ) ) / iTime) ) + iTime) ) ) ) ) ).y , degrees( exp2( asin( asin( abs( sin( tan( cos( sin( degrees( floor( floor( abs( abs( log2( uv ) ) ) ) ) ) ) / iTime) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sin( asin( abs( cos( abs( abs( sign( a_0 ) ) ) / iTime) ) ) * iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.15,0.45) )*vec2(10.,10.);\n a_0 = floor( atan(abs( degrees( radians( abs( asin( asin( sin( tan( sin( degrees( sin( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , abs( degrees( radians( abs( asin( asin( sin( tan( sin( degrees( sin( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     floor( abs( sin( cos( ceil( a_0 ) / iTime) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,-0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( exp2( cos( sin( tan( uv.x * radians( sin( degrees( abs( floor( abs( log2( uv ) ) ) ) ) ) ) - floor(uv.x * radians( sin( degrees( abs( floor( abs( log2( uv ) ) ) ) ) ) )) ) + iTime) ) ) ) ) ).y , degrees( radians( asin( exp2( cos( sin( tan( uv.x * radians( sin( degrees( abs( floor( abs( log2( uv ) ) ) ) ) ) ) - floor(uv.x * radians( sin( degrees( abs( floor( abs( log2( uv ) ) ) ) ) ) )) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     log( uv.x * a_0 - floor(uv.x * a_0) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,-0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( asin( asin( sin( exp2( tan( uv.y * log( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) - floor(uv.y * log( sin( degrees( floor( abs( log2( uv ) ) ) ) ) )) ) ) + iTime) ) ) ) ) ).y , degrees( abs( radians( asin( asin( sin( exp2( tan( uv.y * log( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) - floor(uv.y * log( sin( degrees( floor( abs( log2( uv ) ) ) ) ) )) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,-0.25) )*vec2(10.,10.);\n a_0 = abs( atan(exp2( degrees( radians( asin( log2( abs( sin( tan( sin( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , exp2( degrees( radians( asin( log2( abs( sin( tan( sin( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( cos( uv.y * ceil( a_0 ) - floor(uv.y * ceil( a_0 )) / iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,-0.15) )*vec2(10.,10.);\n a_0 = tan( atan(degrees( radians( asin( asin( sin( tan( sin( degrees( degrees( exp2( floor( sin( log2( uv ) + iTime) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( degrees( degrees( exp2( floor( sin( log2( uv ) + iTime) ) ) ) ) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     exp2( abs( degrees( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,-0.05) )*vec2(10.,10.);\n a_0 = atan(abs( degrees( radians( asin( asin( sin( tan( uv.x * log2( degrees( fract( sign( floor( abs( log2( uv ) ) ) ) ) ) ) - floor(uv.x * log2( degrees( fract( sign( floor( abs( log2( uv ) ) ) ) ) ) )) ) + iTime) ) ) ) ) ).y , abs( degrees( radians( asin( asin( sin( tan( uv.x * log2( degrees( fract( sign( floor( abs( log2( uv ) ) ) ) ) ) ) - floor(uv.x * log2( degrees( fract( sign( floor( abs( log2( uv ) ) ) ) ) ) )) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( ceil( exp2( tan( abs( ceil( a_0 ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,0.05) )*vec2(10.,10.);\n a_0 = tan( atan(degrees( abs( radians( radians( asin( sin( tan( sin( degrees( floor( abs( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( abs( radians( radians( asin( sin( tan( sin( degrees( floor( abs( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,0.15) )*vec2(10.,10.);\n a_0 = atan(asin( cos( exp( radians( asin( asin( sin( tan( sin( degrees( sqrt( floor( tan( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , asin( cos( exp( radians( asin( asin( sin( tan( sin( degrees( sqrt( floor( tan( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     atan( uv.x * abs( asin( abs( cos( ceil( a_0 ) / iTime) ) ) ) - floor(uv.x * abs( asin( abs( cos( ceil( a_0 ) / iTime) ) ) )) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( cos( tan( asin( asin( sin( tan( tan( sin( degrees( floor( tan( log2( uv ) * iTime) ) ) ) ) ) + iTime) ) ) * iTime) ) ) ).y , degrees( radians( cos( tan( asin( asin( sin( tan( tan( sin( degrees( floor( tan( log2( uv ) * iTime) ) ) ) ) ) + iTime) ) ) * iTime) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sign( abs( cos( log( abs( floor( a_0 ) ) ) / iTime) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( sin( tan( sin( degrees( degrees( abs( tan( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( tan( sin( degrees( degrees( abs( tan( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     degrees( abs( ceil( a_0 ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.25,0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( sin( abs( tan( sin( degrees( floor( sin( abs( abs( degrees( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( abs( tan( sin( degrees( floor( sin( abs( abs( degrees( log2( uv ) ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     radians( abs( abs( abs( degrees( atan( sign( a_0 ) ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,-0.45) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( sign( abs( asin( sin( tan( sin( log( tan( sqrt( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( radians( sign( abs( asin( sin( tan( sin( log( tan( sqrt( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     fract( exp2( ceil( a_0 ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,-0.35) )*vec2(10.,10.);\n a_0 = radians( atan(degrees( radians( asin( asin( uv.y * tan( sin( degrees( floor( acos( abs( exp( log2( uv ) ) ) ) ) ) ) ) - floor(uv.y * tan( sin( degrees( floor( acos( abs( exp( log2( uv ) ) ) ) ) ) ) )) ) ) ) ).y , degrees( radians( asin( asin( uv.y * tan( sin( degrees( floor( acos( abs( exp( log2( uv ) ) ) ) ) ) ) ) - floor(uv.y * tan( sin( degrees( floor( acos( abs( exp( log2( uv ) ) ) ) ) ) ) )) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     cos( sqrt( sign( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,-0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( asin( asin( sin( abs( tan( sin( degrees( acos( floor( cos( sin( log2( uv ) + iTime) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( abs( radians( asin( asin( sin( abs( tan( sin( degrees( acos( floor( cos( sin( log2( uv ) + iTime) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     tan( asin( abs( atan( floor( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,-0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( degrees( radians( asin( cos( asin( sin( tan( sin( degrees( fract( sign( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) / iTime) ) ) ) ) ).y , degrees( abs( degrees( radians( asin( cos( asin( sin( tan( sin( degrees( fract( sign( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) / iTime) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( acos( ceil( a_0 ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,-0.05) )*vec2(10.,10.);\n a_0 = abs( atan(ceil( radians( asin( asin( sin( tan( sin( degrees( floor( degrees( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , ceil( radians( asin( asin( sin( tan( sin( degrees( floor( degrees( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     degrees( sin( abs( abs( abs( abs( a_0 ) ) ) ) * iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,0.05) )*vec2(10.,10.);\n a_0 = atan(log2( exp( degrees( radians( asin( asin( sin( tan( sin( degrees( degrees( floor( exp( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , log2( exp( degrees( radians( asin( asin( sin( tan( sin( degrees( degrees( floor( exp( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     abs( abs( uv.y * ceil( a_0 ) - floor(uv.y * ceil( a_0 )) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( exp2( asin( asin( exp( sin( tan( sin( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) + iTime) ) + iTime) ) ) ) ) ) ).y , degrees( radians( exp2( asin( asin( exp( sin( tan( sin( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) + iTime) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     acos( sin( sin( abs( cos( ceil( a_0 ) ) ) ) + iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,0.25) )*vec2(10.,10.);\n a_0 = log( atan(degrees( radians( asin( asin( sin( abs( exp( sin( degrees( floor( cos( atan( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).y , degrees( radians( asin( asin( sin( abs( exp( sin( degrees( floor( cos( atan( abs( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( abs( abs( atan( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( floor( sign( asin( asin( sin( abs( tan( normalize( degrees( floor( log( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( radians( floor( sign( asin( asin( sin( abs( tan( normalize( degrees( floor( log( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     floor( sqrt( abs( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.35,0.45) )*vec2(10.,10.);\n a_0 = log( atan(degrees( degrees( radians( asin( abs( asin( sin( tan( exp2( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , degrees( degrees( radians( asin( abs( asin( sin( tan( exp2( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     floor( log2( uv.x * abs( log2( ceil( a_0 ) ) ) - floor(uv.x * abs( log2( ceil( a_0 ) ) )) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,-0.45) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( exp2( radians( asin( abs( sign( asin( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , degrees( exp2( radians( asin( abs( sign( asin( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,-0.35) )*vec2(10.,10.);\n a_0 = floor( atan(degrees( radians( asin( floor( uv.y * asin( sin( tan( sin( degrees( floor( abs( abs( abs( uv ) ) ) ) ) ) ) + iTime) ) - floor(uv.y * asin( sin( tan( sin( degrees( floor( abs( abs( abs( uv ) ) ) ) ) ) ) + iTime) )) ) ) ) ).y , degrees( radians( asin( floor( uv.y * asin( sin( tan( sin( degrees( floor( abs( abs( abs( uv ) ) ) ) ) ) ) + iTime) ) - floor(uv.y * asin( sin( tan( sin( degrees( floor( abs( abs( abs( uv ) ) ) ) ) ) ) + iTime) )) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     ceil( a_0 ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,-0.25) )*vec2(10.,10.);\n a_0 = atan(degrees( abs( radians( asin( asin( sin( abs( sin( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).y , degrees( abs( radians( asin( asin( sin( abs( sin( tan( sin( degrees( floor( abs( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sin( acos( abs( exp2( degrees( ceil( a_0 ) ) ) ) ) * iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,-0.15) )*vec2(10.,10.);\n a_0 = atan(degrees( sin( radians( asin( asin( sin( tan( abs( cos( sin( degrees( floor( abs( floor( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) * iTime) ).y , degrees( sin( radians( asin( asin( sin( tan( abs( cos( sin( degrees( floor( abs( floor( log2( uv ) ) ) ) ) ) ) ) ) + iTime) ) ) ) * iTime) ).x);\nfragColor += clamp( abs( vec4(\n     abs( sign( fract( abs( abs( cos( a_0 ) ) ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,-0.05) )*vec2(10.,10.);\n a_0 = tan( atan(abs( log( radians( asin( asin( sin( abs( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , abs( log( radians( asin( asin( sin( abs( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     uv.y * sin( cos( tan( ceil( a_0 ) ) / iTime) * iTime) - floor(uv.y * sin( cos( tan( ceil( a_0 ) ) / iTime) * iTime)) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,0.05) )*vec2(10.,10.);\n a_0 = ceil( atan(floor( degrees( radians( abs( asin( asin( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ).y , floor( degrees( radians( abs( asin( asin( sin( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) + iTime) ) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( exp2( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,0.15) )*vec2(10.,10.);\n a_0 = abs( atan(degrees( radians( asin( sin( log( sin( log2( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ).y , degrees( radians( asin( sin( log( sin( log2( tan( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) ) ) ) ).x) );\nfragColor += clamp( abs( vec4(\n     abs( radians( tan( ceil( a_0 ) ) ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,0.25) )*vec2(10.,10.);\n a_0 = atan(fract( degrees( radians( degrees( asin( uv.y * sin( tan( sin( degrees( floor( abs( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) - floor(uv.y * sin( tan( sin( degrees( floor( abs( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime)) ) ) ) ) ).y , fract( degrees( radians( degrees( asin( uv.y * sin( tan( sin( degrees( floor( abs( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime) - floor(uv.y * sin( tan( sin( degrees( floor( abs( abs( abs( log2( uv ) ) ) ) ) ) ) ) + iTime)) ) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     cos( tan( abs( ceil( a_0 ) ) * iTime) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,0.35) )*vec2(10.,10.);\n a_0 = atan(degrees( radians( asin( asin( cos( tan( abs( log2( sin( degrees( degrees( floor( cos( abs( log2( uv ) ) / iTime) ) ) ) ) ) ) ) / iTime) ) ) ) ).y , degrees( radians( asin( asin( cos( tan( abs( log2( sin( degrees( degrees( floor( cos( abs( log2( uv ) ) / iTime) ) ) ) ) ) ) ) / iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     tan( ceil( a_0 ) ) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\nuv = ( (fragCoord - (iResolution.xy / 2.)) / min(iResolution.x,iResolution.y) + vec2(0.45,0.45) )*vec2(10.,10.);\n a_0 = atan(sin( radians( asin( asin( cos( abs( sin( tan( sqrt( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) / iTime) ) ) ) ).y , sin( radians( asin( asin( cos( abs( sin( tan( sqrt( sin( degrees( floor( abs( log2( uv ) ) ) ) ) ) ) + iTime) ) / iTime) ) ) ) ).x);\nfragColor += clamp( abs( vec4(\n     sin( asin( sin( ceil( sin( ceil( a_0 ) + iTime) ) + iTime) ) + iTime) ,\n     a_0 ,\n     17. ,\n     1. ) ),0.,1.) * step(-0.5,uv.x) * step(-0.5,uv.y) * step(-0.5,-uv.x) * step(-0.5,-uv.y);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 63534]], "test": "timedout"}
{"id": "fld3z7", "name": "Fractelligence LookingGlass", "author": "PsyPhi", "description": "Raymarched Fractal\n\nDepth", "tags": ["raymarching", "fractal"], "likes": 1, "viewed": 108, "published": "Public API", "date": "1635891633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Transforms\nfloat RotX = 1.5; //0 to 3\nfloat RotY = 0.77;\nfloat RotZ = 0.5;\nfloat TransX = 0.92;  //0 to 5\nfloat TransY = 1.8;\nfloat TransZ = 0.6;\nfloat Scale = 0.;\nfloat Range = 0.001;\nfloat RX = 0.;\nfloat RY = 0.;\nfloat RZ = 0.;\nfloat TX = 0.;\nfloat TY = 1.;\nfloat TZ = 0.;\nfloat TwistY = 0.07; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 1;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 1.;\n//Sphere\nint Sphere = 1;\nfloat SphereScale = 1.;\nfloat SphereTX = 0.5;\nfloat SphereTY = 0.2;\nfloat SphereTZ = 0.1;\n//Shapes\nint InfPre = 1;\nint InfPost = 0;\nint Merge = 1;\nfloat ShapeMix = 0.5;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 0.;\nfloat Proximity = 1.;\nfloat PHue = 0.;\nfloat Distance = 1.;\nfloat DHue = 5.;\nfloat light = 0.;\nfloat DepthHue = 0.0;\n//Time\nfloat TimeRotX = 0.3;\nfloat TimeRotY = 0.25;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.05;\n\n\n\n\n\n\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\n\tfloat c = cos(a),\n\n\t\ts = sin(a);\n\n\treturn mat2(c, -s, s, c);\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n\n{\n\nfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\nreturn mix( d2, d1, h ) - k*h*(1.0-h);\n\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\n\n\n\tfloat d = 1.; //Just to have the d var declaired\n\n//\tfloat perStep = 1/FRACT_STEPS;\n\n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n\nif(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.2);\n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);;\n\t\tp.z -= TransZ;\n\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); //Audio rct\n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n    p.xz *= rotate(p.y*TwistY); //Twist\n\nif(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n}\n\nif (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n\t  float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n    else d = min(sphereDist,d);\n  }\n\n\n\t\t if (Rectangle == 1){//Adds in the Rectangle\n\t\t\t vec4 rec = vec4(0.0, 0.0, 0.0, RecScale);\n\t\t\t float recDist = length(max(abs(p) - rec.w, 0.));\n\t\t\t if(Merge == 1) d = opSmoothUnion(recDist, d, ShapeMix);\n       else d = min(recDist,d);\n\t\t }\n\n\n\t\t// d = min(sphereDist,d);\n\n\n\t//}\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd)\n\n{\n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n\n\t\tfloat prox = 0.0;\n\n    vec3 ro = vec3(0, 0, -6+\n      (InfPre+InfPost));  //Audio rct\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    ro = _ro;\n    rd = _rd;\n\n\n    vec3 d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n    //color = vec3(dif);\t\t\t\t//lighting\n\n\t\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n\n  //vec3 tex =  textureLod(syn_UserImage, _uv, 0.0).rgb;\n\n\t\tcolor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n\n    color = hs(color, IHue);\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity\n    // *1.-tex.r\n    ;\t\t\t\t\t\t//G\n\n    color = hs(color, PHue);\n\n    color.b = (1.-d.x*0.04)*Distance;\n\n\n\n    color = hs(color, DHue);\n\n    color += dif*light;       //light\n  //  color += hs(color, 5*dif*light);       //light hue rotate\n\n\t\t  color = hs(color, d.y*DepthHue); //iterations to hue rot\n\n//\t\tcolor -= dif*0.5;\n\n\n\n    fragColor = vec4(color,1.0);\n}\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(15.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1034, 1034, 1108, 1108, 1181], [1183, 1183, 1208, 1208, 1300], [1302, 1302, 1324, 1324, 1390], [1392, 1392, 1474, 1474, 1568], [1572, 1620, 1643, 1643, 2939], [2941, 2941, 2974, 2974, 3336], [3338, 3338, 3362, 3362, 3543], [3545, 3545, 3569, 3569, 3886], [3890, 3890, 3973, 3973, 5029], [5342, 5342, 5398, 5398, 6168]], "test": "error"}
{"id": "fld3zM", "name": "Simple Distance Filtering.", "author": "knotapun", "description": "This shader takes the default `new` shader and filters it via a circle, and displays only that circle. This is my first shader.", "tags": ["first"], "likes": 1, "viewed": 30, "published": "Public", "date": "1635880939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nFiltering the input of a shader with a simple distance function.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  // Normalized pixel coordinates -0.5..0.5\n  vec2 uvCentered = fragCoord.xy - (iResolution.xy * vec2(0.5));\n  //The distance from the center of the screen, calculated for each pixel.\n  float uvDistance = sqrt(uvCentered.x * uvCentered.x + uvCentered.y * uvCentered.y);\n  \n  // Normalized mouse coordinates -0.5..0.5\n  vec2 mouseCentered = (iMouse.xy - (vec2(0.5) * iResolution.xy)) ;\n  //convert the coordinates of the mouse to a simple distance from the center of the shader area.\n  float mouseDistance = sqrt(mouseCentered.x * mouseCentered.x + mouseCentered.y * mouseCentered.y);\n  \n  \n  float radius = iMouse.y / 2.0;\n  \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+(fragCoord.xy / iResolution.xy).xyx+vec3(0,2,4));\n    // Output to screen, using a step function to filter based on distance from mouse click.\n    fragColor = vec4(step(uvDistance, mouseDistance) * col.xyz,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 128, 175, 1038]], "test": "valid"}
{"id": "fld3zX", "name": "Something  gaz 234", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 11, "viewed": 122, "published": "Public", "date": "1636465353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    float z=100.,cnt=30.;\n    for(float j=0.;j++<cnt;)\n    {\n        float i=0.,g=0.,e;\n        for(;++i<50.||g<z;){\n            p=g*d;\n            p.z-=6.;\n            p=R(p,vec3(.577),iTime*.5);\n            p=R(p,vec3(0,1,0),1.5*j*TAU/cnt);\n            p=R(p,vec3(1,0,0),.04*j);\n            p.x-=.5;\n            g+=e=length(vec2(length(p.xz)-1.-j*.03,p.y))-.05;\n            if(e<.001)\n            {\n                if(g<z)\n                {\n                    z=g;\n                    O.xyz=mix(vec3(1),H(j/cnt),.7)*3./i;\n                }\n                break;\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 160, 160, 837]], "test": "valid"}
{"id": "fldGDn", "name": "spqr: decal scaffold", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 1, "viewed": 101, "published": "Public API", "date": "1636005865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\nfloat ink(vec2 uv) {\n\n  return m2(uv);\n}\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 1;\n\n\n\nfloat building(vec3 p) {\n\n  p.xz = abs(p.xz)- 100.;\n  \n  p = rep(p, vec3(0.,50.,0.));\n \n  float floors = box(p, vec3(110,11.1,110));\n  float collumns = box(p, vec3(10,40,10));\n \n  float all = min(floors,collumns);\n  \n  if ( floors == all) {\n    matter = 1;\n  }\n  if ( collumns == all) {\n    matter = 2;\n  }\n  return all;\n \n \n}\n\n\n\nfloat map (vec3 p) {\n\n  // geo\n  \n  float w = 1000.;\n  p.xz = abs(p.xz - w);\n  float t = building(p - vec3(w,0,w));\n \n  return t;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  for (int z = 0; z < 2; z++) {\n    r = smoothstep(0.,1.,r);\n  }\n  \n  return i + r;\n}\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  float tt = iTime * 1.;\n  vec3 s = lattice(tt  * 2. + 17.) * 100.;\n  vec3 t = lattice(tt  * 1.71) * 100.;\n  \n  \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt * .55);\n  arm.yz *= rot(tt * .68);\n  arm.xy *= rot(tt * .71);\n\n  \n  s += flit(tt * 1.21) * 77.1;\n  s += arm * 200.;\n  t.xy *= .5;\n  \n  vec3 down = vec3(0.  , tick(tick(iTime/12.3)) * 717.91, 0.);\n  s+= down;\n  t+= down;\n  \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.001) {\n      if ( matter == 1) {\n        float i = ink(mod(p.xz,150.));\n        if (i > .2) {\n          d = .1;\n        } else {\n          hit = true;\n          break;\n        }\n      \n      }\n      \n      if (matter == 2) {\n        hit = true;\n        break;\n      }\n    }\n    if ( dd > 50000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n \n  vec3 col;\n  \n  if ( matter == 1) {\n    float i = ink(mod(p.xz,150.));\n    col = vec3(1);\n    if ( i < 0.2) {\n      col = vec3(0);\n    }\n    if (i < -0.1) {\n \n    \n      col =  vec3(.8,.4,.2);\n      //col = vec3(.7);\n    \n    }\n    \n\n  }\n  if (matter == 2) {\n    col = vec3(1);\n  }\n  \n \n\n  \n  vec3 light =normalize(vec3(4,12.,2.));\n  light.xz *= rot(iTime);\n\n  light = abs(light);\n  \n \n  vec3 n = norm(p);\n  \n  float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  //float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n\n;\n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,1,0)));\n    per = pow(per,0.9);\n   \n    col =   mix(  vec3(.0,.5,1.), vec3(.0,.5,1.) * .1, per);\n    \n  }\n\n  fragColor = vec4(col, 1);\n\n\n\n  /*\n  uv *= rot(iTime);\n  uv *= 250.;\n  uv *=  sin(iTime * 1.)/ 1. + .2;\n  float d = ink(uv);\n  vec3 col;\n  col = vec3(.7);\n  \n  if ( d < .2) {\n    col = vec3(0);\n  }\n  if (d < 0.) {\n    col = vec3(1.,.34,.32);\n  }\n\n  col += glow * 400.5;\n  fragColor = vec4( col, 1.);\n\n  */\n  \n}\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 301, 301, 370], [374, 374, 403, 403, 451], [454, 454, 501, 501, 547], [549, 549, 568, 568, 1127], [1166, 1166, 1185, 1185, 1580], [1582, 1582, 1602, 1602, 1622], [1626, 1626, 1653, 1653, 1721], [1723, 1723, 1751, 1751, 1775], [1776, 1776, 1805, 1805, 1892], [1893, 1893, 1935, 1935, 2042], [2044, 2044, 2072, 2072, 2098], [2100, 2100, 2128, 2128, 2161], [2164, 2164, 2211, 2211, 2257], [2261, 2261, 2302, 2302, 2470], [2473, 2473, 2494, 2494, 2785], [2787, 2787, 2806, 2806, 2914], [2916, 2916, 2955, 2955, 3032], [3034, 3034, 3070, 3070, 3148], [3150, 3150, 3170, 3170, 3264], [3287, 3287, 3311, 3311, 3366], [3370, 3370, 3391, 3391, 3440], [3442, 3442, 3467, 3467, 3936], [3964, 3964, 3988, 3988, 4290], [4294, 4294, 4314, 4324, 4425], [4426, 4426, 4445, 4445, 4564], [4566, 4566, 4607, 4607, 4653], [4655, 4655, 4691, 4691, 4736], [4738, 4738, 4758, 4758, 4801], [4803, 4803, 4822, 4822, 4901], [4903, 4903, 4925, 4925, 5055], [5057, 5057, 5077, 5077, 5261], [5263, 5263, 5320, 5320, 7931]], "test": "valid"}
{"id": "fldGDr", "name": "wasteland", "author": "rockhard", "description": "landtest. High contract image make people feel nevous or exsiting sometime,i give this image a soft light spreading from far distance to feel comfortable.  ", "tags": ["landwalk"], "likes": 22, "viewed": 254, "published": "Public API", "date": "1636265796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p){\n    p.z+=iTime*0.5;\n    //push away the height to make a road.\n    float wav=(sin(p.x*0.25+4.4))*0.5\n        + texture(iChannel0,p.xz*0.5).x*0.007;  \n    float h = dot(sin(p - cos(p.zyx)),vec3(0.03));\n    p*=0.65;\n    h += dot(sin(p- cos(p.yzx*2.5)),vec3(0.05));\n     //-0.35 ~ 0.52 can flatten the ground and top surface \n    return p.y + smoothstep(-0.35,0.52,h-wav);   \n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.002, -0.002); \n    return normalize(\n        e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvec3 col(vec3 rd, vec3 norm, float md, float t)\n{     \n    //a simply trick without the heavy mie calculation\n    //to control color\n    vec3 sun=(1.0-rd.y-rd.x)*vec3(0.4,0.3,0.2);\n    vec3 sky=mix(vec3(0.25,0.2,0.1),vec3(0.0,0.3,0.75),rd.y)+sun;\n    //cloud is also not nessesary this time..\n    \n    // light\n    vec3 ld =normalize(vec3(0.25, 0.5, 0.51)); \n    \n    float diff = dot(norm, ld);\n    \n    vec3 col= vec3(0.25)*(diff-0.5); \n    //fog\n    col = mix(col,sky, 1.0 - exp(-0.0006*t*t*t) );\n    //https://www.shadertoy.com/view/MlccDf\n    float sand = smoothstep(-0.2, 0.35, 0.0001 / md * t);\n    \n    return col+sand*vec3(0.15,0.1,0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy-0.5;\n    float vig=(1.0-uv.x*uv.x)*(1.0-uv.y*uv.y);\n    \n    uv.x*=iResolution.x/iResolution.y; \n  \n    vec3 ro = vec3(0.0, 0.36, 0.0); \n    vec3 rd = normalize(vec3(uv,0.65));\n        \n    float t = 0.1;    \n    float minDist = 50.0;\n    \n    for (int i = 0; i < 64; i++){\n        float d = map(ro + rd*t);\n        if(d<0.01){\n            minDist = 0.1;\n            break;  \n        }\n        if(t>25.0) break;//early exist.               \n        t += d;\n    }    \n    \n    vec3 n =rd.y>0.15? vec3(0.0): getNormal(ro + rd * t);\n    vec3 color = col(rd, n, minDist, t);\n \n    fragColor = vec4(sqrt(clamp(color,0.0,1.0))*vig*1.25, 1.0);\n \n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 393], [395, 395, 418, 418, 594], [596, 596, 645, 728, 1245], [1247, 1247, 1304, 1304, 1987]], "test": "error"}
{"id": "fldGR7", "name": "Nodevember Day 1/2 - 3 Sides", "author": "y2k_cyborg", "description": "Just messing around", "tags": ["raymarching", "nodevember"], "likes": 11, "viewed": 97, "published": "Public", "date": "1635885301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/sllGDN\n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Performance settings\n// Enabling AA is more expensive but looks quite a lot better\n#define USE_AA 0\n// Continue further raycast after refraction?\n#define MAX_RAYS_PER_PRIMARY 3.\n\n#define MAX_STEPS 128\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nconst int MAT_BASE=1;\nconst int MAT_BARS=2;\nconst int MAT_BALL=3;\nconst int MAT_LINE=4;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b) {\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c);\n}\n\nvec2 sdBall(vec3 p, float a) {\n    \n    p.y-=1.01;\n    p.xy *= Rot(a);\n    p.y+=1.01;\n    \n    float ball = length(p)-.15;\n    float ring = length(vec2(length(p.xy-vec2(0, .15))-.03, p.z))-.01;\n    ball = min(ball, ring);\n    \n    p.z = abs(p.z);\n    float line = sdLineSeg(p, vec3(0,.15,0), vec3(0, 1.01, .4))-.005;\n    \n    float d = min(ball, line);\n    \n    return vec2(d, d==ball ? MAT_BALL : MAT_LINE);\n}\n\nfloat udIsoTriangle( vec3 p, float r )\n{\n  const float cos30 = 0.86602540378;\n  float h = r;\n  vec3 a = vec3(-h, -h*cos30, 0.);\n  vec3 b = vec3(+h, -h*cos30, 0.);\n  vec3 c = vec3( 0,  h*cos30, 0.);\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdPrism( in vec3 p, in float r, in float h )\n{\n    float d = udIsoTriangle(vec3(p.xy, 0.), r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\n// for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\nfloat toPrism(in float d2d, in float v, in float size) {\n    vec2 d = vec2(d2d, abs(v) - 0.5 * size);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat nPrism(in int n, in vec3 p, in float r, in float depth) {\n    float d = nGon(n, p.xy, r);\n    return toPrism(d, p.z, depth);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 Min(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\nfloat noise(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat fbm( vec2 x, float H )\n{    \n    float G = exp2(-H);\n    float skip = 0.;\n    float f = pow(2., skip);\n    float a = pow(G, skip);\n    float t = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec2 GetDist(vec3 p) {\n    float d = MAX_DIST;\n    int mat = MAT_BALL;\n    \n    // p.xz *= Rot(.005 * sqrt(dot(p.xz, p.xz)));\n    \n    vec3 prism_origin = vec3(0.,.8,0.);\n    vec3 prism_query = p - prism_origin;\n    prism_query.yz *= Rot(3.14159 * .15);\n    prism_query.xy *= Rot(iTime);\n        \n    float c = 7.;\n    prism_query = mod(prism_query+0.5*c,c)-0.5*c;\n\n    // d = nPrism(3, prism_query, 0.3, 2.) - 0.02;\n    // d = sdBox(prism_query, vec3(0.4)) - 0.02;\n    d = sdPrism(prism_query, .5, 1.) - 0.02;\n    \n    return vec2(d, mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    vec2 dSMat = vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p)*side;\n   \n        dO += dSMat.x;\n        if(dO>MAX_DIST || abs(dSMat.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dSMat.y);\n    //return vec2(MAX_DIST, 0.);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 EnvCol(vec3 rd) {\n  vec3 ground_col = vec3(.2,.25,.3);\n  vec3 sky_col = vec3(.6, .9, .9);\n  float t = smoothstep(.4, .6, rd.y * .5 + .5);\n  vec3 sky = t * sky_col + (1.-t) * ground_col;\n  float theta = atan(rd.z, rd.x);\n  float phi = atan(rd.y, rd.x);\n  float rzx = dot(rd.xz, rd.xz);\n  float sky_top = 1. * sin(theta * 12.) + .2;\n  //float sky_top = - .5*fbm(.001 * vec2(theta, phi), .5);\n  float sky_bottom = .6 * sin(rzx * 3.14159); // + .05 * cos(theta * 357.8746) * sin(rzx * 3.14159 * 454.8465);\n  float t2 = smoothstep(-.2, 0., rd.y);\n  return sky + (t2 * sky_top + (1.-t2) * sky_bottom);\n}\n\nvec4 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last) {\n    vec3 col = EnvCol(rd);\n    vec2 dMat = RayMarch(ro, rd, 1.);\n    float d = dMat.x;\n    \n    ref *= 0.;\n    \n    float alpha = 0.;\n    const float IOR = 1.35; // index of refraction\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        // Colour of reflection, going to environment\n        vec3 refOutside = EnvCol(r);\n        \n        // Ray refracted internally\n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n\n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.).x; // inside the object\n\n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit);\n\n        vec3 rdOut = refract(rdIn, nExit, IOR);\n        if (dot(rdOut, rdOut) == 0.) {\n          rdOut = reflect(rdIn, nExit);\n        }\n\n        // Next iteration's ray\n        ro = pExit - nExit*SURF_DIST*3.;\n        rd = rdOut;\n        alpha = 1.;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n\n        // The rest of the mixing happens in the RenderAll loop\n        col = vec3(0);\n        ref = vec3(.8);\n        if (last) {\n          // We won't spawn a further ray, but get the colour of the refracted ray going to environment\n          const float dens = .1;\n          float optDist = exp(-dIn*dens);\n          vec3 reflTex = EnvCol(rdOut) * optDist;\n          col += reflTex*ref;\n        }\n        col = mix(col, refOutside, fresnel);\n    }\n    return vec4(col, alpha);\n}\n\nvec3 RenderAll(vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(iTime * .3);\n    ro.xz *= Rot(-m.x*6.2831);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.75,0), 2.);\n    vec3 col = vec3(0.);\n    vec3 ref, fil=vec3(1);\n   \n    for(float i=0.; i<MAX_RAYS_PER_PRIMARY; i++) {\n        vec4 pass = Render(ro, rd, ref, i==MAX_RAYS_PER_PRIMARY-1.);\n        col += pass.rgb*fil;\n        fil*=ref;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = RenderAll(fragCoord);\n    \n    // Anti-aliasing\n    #if USE_AA\n    col +=\n        RenderAll(fragCoord+vec2(.5,.0))+\n        RenderAll(fragCoord+vec2(.0,.5))+\n        RenderAll(fragCoord+vec2(.5,.5));\n    col /= 4.;\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[577, 577, 596, 596, 658], [660, 740, 765, 765, 784], [785, 785, 810, 810, 829], [830, 830, 866, 866, 894], [896, 896, 925, 925, 1006], [1008, 1008, 1037, 1037, 1108], [1110, 1110, 1151, 1151, 1279], [1281, 1281, 1311, 1311, 1691], [1693, 1693, 1733, 1733, 2387], [2389, 2389, 2441, 2441, 2584], [2586, 2586, 2631, 2671, 3058], [3060, 3155, 3211, 3211, 3316], [3318, 3318, 3381, 3381, 3450], [3452, 3452, 3488, 3488, 3571], [3573, 3573, 3599, 3599, 3629], [3631, 3631, 3653, 3653, 3760], [3762, 3762, 3792, 3792, 4036], [4038, 4038, 4060, 4060, 4580], [4582, 4582, 4627, 4627, 4928], [4930, 4930, 4954, 4954, 5152], [5154, 5154, 5204, 5204, 5395], [5397, 5397, 5419, 5419, 5999], [6001, 6001, 6071, 6071, 7652], [7654, 7654, 7686, 7686, 8215], [8217, 8217, 8274, 8274, 8611]], "test": "valid"}
{"id": "fldGWS", "name": "⚛️🧬🔬🌎 Scale Universe 🪐☀️⭐🌌", "author": "rmmcal", "description": "Scale of the Universe", "tags": ["scale", "universe"], "likes": 12, "viewed": 89, "published": "Public", "date": "1636713155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//   ...  ⚛️🧬🔬🌎 Scale Universe 🪐☀️⭐🌌 ...       ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/11\n// https://www.shadertoy.com/view/fldGWS\n/////////////////////////////////////////////////////////////\n\n\nconst float pi = 3.1415926;\nconst float pi2 = 2.*pi;\nconst float rad = pi/180.;\nvec2 fc; \nfloat mt ;\nmat2 rotate(float x){\n    float c = cos(x);\n    float s = sin(x);\n    return mat2(c,s,-s,c);\n}\nmat3 rotateX(float x){\n    mat3 m = mat3(1,0,0,0,1,0,0,0,1);\n    m[0].xy *= rotate(x);\n    m[1].xy *= rotate(x);\n    return m;\n}\nvec4 v(float v){\n    return vec4(v, 0.,0.,0.);\n}\nvec4 v(float v, float v2){\n    return vec4(v, v2, 0.,0.);\n}\n\nvec4 vmin(vec4 v1, vec4 v2){\n    return v1.x < v2.x ? v1 : v2;\n}\n\nvec4 vmin(vec4 v1, float v2){\n    return v1.x < v2 ? v1 : v(v2);\n}\n\nvec4 vmin(vec4 v1, float v2, float v3){\n    return v1.x < v2 ? v1 : v(v2,v3);\n}\n\n//////////////////////////////////\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//////////////////////////////////\n \n\nvec4 dist(vec3 p)\n{\n    vec4 d = v(100.);\n    p.xz *= rotate(iTime);\n    \n    p.xz *= rotate(-iTime);\n   \n    vec3 tp = p*0.5;\n  \n    float nx = ( sin(atan(tp.z,tp.x)) ) ;\n    float ny = ( sin(atan(tp.y,tp.x)) );\n   \n    float f;\n    f = 0.;\n    vec3 pk = p*2.0*vec3(1.,1.0,1.0)+vec3(1.);\n    float f2 = .18-abs(sin(pk.x)*cos(pk.y)+sin(pk.y)*cos(pk.z)+sin(pk.z)*cos(pk.x))/10.0;\n    pk = p*144.0*vec3(1.,1.0,1.0)+vec3(1.);\n    f2 += .01-abs(sin(pk.x)*cos(pk.y)+sin(pk.y)*cos(pk.z)+sin(pk.z)*cos(pk.x))/190.0;\n   \n    f = clamp(f+.05,0.,3.0);\n    f2 = clamp(f2 , 0., .2);\n  \n    vec3 pq = p*500.0;\n    float fv0 = .001-abs(sin(p.x)*cos(pq.y)+sin(pq.y)*cos(pq.z)+sin(pq.z)*cos(pq.x)+cos(iTime+pq.x))/800.0;\n    \n    float s = 500.0;\n    d = vmin(d, (length(p)-2.0 ) +  - 0.1   +fv0     , 1.0 );\n    d = vmin(d, (length(p)-2.0 ) +(f2-.13)*2.0, 2.0 );\n\n    pk = p*4.0*vec3(1.,1.0,1.0)+vec3(1.);\n    f2 = .01-abs(sin(pk.x)*cos(pk.y)+sin(pk.y)*cos(pk.z)+sin(pk.z)*cos(pk.x))/190.0;\n  \n    d = vmin(d, (length(p+cos(p*vec3(110.0,80.0,.0))*0.006-vec3(0.0,0.,-2.0))-.12 ), 3.0 );\n\n    d = vmin(d, (length(p-vec3(30.0,0.,-2.0))-3.0 ) +(f2-.13)*2.0, 2.0 );\n     \n    d = vmin(d, (length(p-vec3(-80.0,0.,-2.0))-22.0 ) +(f2-.13)*2.0, 6.0 );\n   \n    d = vmin(d, (length(p-vec3(-180.0,0.,-2.0))-18.0 ) +(f2-.13)*2.0, 7.0 );\n    d = vmin(d, (sdTorus((p-vec3(-180.0,00.,-2.0))*rotateX(0.5)*vec3(.25,1.0,0.25),vec2(8.,2.0))-1.0 ) , 8.0 );\n  \n     \n    d = vmin(d, (length(p-vec3(400.0,0.,-2.0))-150.0 ), 5.0 );\n\n    vec3 c = vec3(10.0*((1.0 - mt)*.7+.3));\n    \n    vec3 q = mod((p+c/2.0)+0.5*c,c)-0.5*c;\n    d = vmin(d, max((length(q)-.3), -(length(p-vec3(0.0,0.,.0))-1540.0 )) , 9.0 );\n \n    d = vmin(d, max((length(q-vec3(.2,0.2,0.0))-.2), -(length(p-vec3(0.0,0.,.0))-1540.0 )) , 9.0 );\n    d = vmin(d, max((length(q+vec3(.2,0.2,0.0))-.2), -(length(p-vec3(0.0,0.,.0))-1540.0 )) , 9.0 );\n \n    return d;\n}\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0., 0.01);\n    float x = dist(p-d.yxx).x;\n    float y = dist(p-d.xyx).x;\n    float z = dist(p-d.xxy).x;\n    return normalize(vec3(x,y,z)-dist(p).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime+39.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    fc = uv;\n    vec2 pc = (uv-.5)*vec2(1, iResolution.y/iResolution.x);\n    vec3 p = vec3(0,0.,-10);\n    vec3 d = normalize(vec3(pc,1.0));\n    \n    p = vec3(0,0.,-2.2)+vec3(0,0.,-2550)* pow(smoothstep(0.,40.0,fract(time/40.0)*40.0),2.0);\n  \n    d = mix(d, normalize(d-vec3(0.,0.,0.995)) , \n        smoothstep( 22.,35.0, fract(time/40.0)*40.0)  \n                *\n        (1.0 - smoothstep( 33.,35.0, fract(time/40.0)*40.0) )\n    );\n    \n    d = mix(d, normalize(d-vec3(0.,0.,0.95)) , \n        smoothstep( 38.,40.0, fract(time/40.0)*40.0)  \n                *\n        (1.0 - smoothstep( 40.,43.0, fract(time/40.0)*40.0) )\n    );\n     \n    mt =  smoothstep( 33.,37.0, fract(time/40.0)*40.0) ;\n    \n    vec3 c;\n    \n    \n    {\n    ///////////////////////////////////////////////////\n        // https://www.shadertoy.com/view/XlfGRj\n        vec2 uv=fragCoord.xy/iResolution.xy-.5;\n        uv.y*=iResolution.y/iResolution.x;\n\n        vec3 v=vec3(0.);\n        vec3 p=vec3(1.,.52,.5)+.1*d;\n        float pa,a;\n        for (int i=0; i<25; i++) { \n            p=abs(p)/dot(p,p)-0.5; \n            a+=abs(length(p)-pa);  \n            pa=length(p);\n        }\n        a*=a*a; \n        v+=vec3(0.0002*a*.01)*vec3(1.,0.9,1.5); \n        c = v;\n     ///////////////////////////////////////////////////\n    }\n    \n    \n    float t = 0.;\n    vec4 q;\n    for (int i = 0 ; i < 60; i++)\n    {\n        q = dist(p);\n        float h=q.x; \n        if (h < 0.01)\n         break;\n        t+=h;\n        p += d*h;\n    }\n    \n    if (t < 1150.0)\n        c *= 0.0 ;\n    \n    if (q.y == 1.0)\n    {\n        c += ( getNormal(p).z )*vec3(0.1,.5,1.);\n    } \n    if (q.y == 2.0)\n    {\n        c += ( getNormal(p).z )*vec3(0.,.8,0.5);\n    }\n    if (q.y == 3.0)\n    {\n        c += ( getNormal(p).z )*vec3(0.7,0.5,0.1);\n    }\n    if (q.y == 4.0)\n    {\n        c += ( getNormal(p).z )*vec3(0.9,0.8,0.1);\n    }  \n    if (q.y == 5.0)\n    {\n        vec3 pk = vec3(fc.xy*100.0,1.0);\n        pk = p/10.0;\n        float f2 = .4-abs(sin(pk.x)*cos(pk.y)+sin(pk.y)*cos(pk.z)+sin(pk.z)*cos(pk.x))/1.0;\n        c += (( getNormal(p).z*3.0 ))*vec3(0.9,0.8,0.1)*3.;\n        c = clamp(c,vec3(0.),vec3(1.));\n        c += abs(cos(f2+iTime)*0.25+.75)*vec3(1.,.5,.5)*1.;\n    }  \n    if (q.y == 6.0)\n    {\n        \n        c += ( getNormal(p).z )*vec3(0.9,0.5,0.1)*1.;\n    } \n    if (q.y == 7.0)\n    {\n        \n        c += ( getNormal(p).z )*vec3(0.4,0.5,1.1)*1.;\n    } \n    if (q.y == 8.0)\n    {\n        \n        c += ( getNormal(p).z )*vec3(0.5,0.9,0.9)*1.;\n    } \n    if (q.y == 9.0)\n    {\n        c += ( getNormal(p).z/(t/50.0) )*vec3(1.)*1.;\n    } \n    \n    c = mix(c, vec3(0.7, 0.5, 0.1), smoothstep( 35.,40.0, fract(time/40.0)*40.0)  );\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[502, 502, 523, 523, 596], [597, 597, 619, 619, 725], [726, 726, 742, 742, 774], [775, 775, 801, 801, 834], [836, 836, 864, 864, 900], [902, 902, 931, 931, 968], [970, 970, 1009, 1009, 1049], [1051, 1160, 1191, 1191, 1278], [1280, 1280, 1313, 1313, 1378], [1417, 1417, 1436, 1436, 3305], [3306, 3306, 3330, 3330, 3499], [3501, 3501, 3558, 3558, 6341]], "test": "error"}
{"id": "flGGRc", "name": "the flag of Romania - 005", "author": "catafest", "description": "the flag of Romania with wind effect ... \nhttps://en.wikipedia.org/wiki/Flag_of_Romania", "tags": ["flag", "romania", "catafest"], "likes": 0, "viewed": 62, "published": "Public API", "date": "1638311751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// this create a rectangle, from uv and size\nfloat rectangle (vec2 uv, float size) {\n\tvec2 s = abs(uv) - vec2(size);\n    float Patrat = length(max(s, .0));\n    Patrat = smoothstep(.001, .0, Patrat);\n    return Patrat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // all colors\n    vec3 col = vec3(0.0);    // background black \n    vec3 blue = vec3(0.0, 0.0, 1.0); // blue flag\n    vec3 yellow = vec3(1.0, 1.0, 0.0); // yellow flag\n    vec3 red = vec3(1.0, 0.0, 0.0); // red flag\n\n    // get uv area \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // set a new area for draw \n    vec2 new_uv = uv;\n\n\n    // create a flagpole \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    new_uv = uv;\n    new_uv.x += .335;\n    float flagpole = smoothstep(.0176, .0155, length(new_uv.x));\n    col += flagpole;\n\n    // translation of uv to the left area of flagpole\n    uv.y -= .0;\n    uv.x -= -.321;\n \n    //create animation with color \n    float windColor= .1;\n    \n    // wind effect\n    new_uv.x = uv.x;\n    new_uv.x += -1.0-sin(-iTime);\n    \n    float mod = smoothstep(0.9, 0.0, length(abs(new_uv.x+(new_uv.y*-.5))));\n    \n    // shadow wind\n    uv.y += mod * 0.1;\n    col -= mod * windColor;\n    \n    // up and down flag \n    uv.y +=0.18 * sin(-0.11 * (iTime))/mod*mod;\n    col -= mod*windColor;\n\n    // flag created with the new UV and Patrat \n    new_uv = uv;\n    new_uv.x *= .55;\n    float base = rectangle(new_uv, .3);\n\n    float flag_X = new_uv.x;\n    float flag_Y = new_uv.y* base;\n    \n\n    if (flag_X > 0.0 && flag_X < 0.6  && flag_Y > 0.0) \n    { \t\t       \n\t\tfloat size = 3.0;\n\t\tif (flag_X < 0.33 / size) \n\t\t{\n\t\t\t// Output to screen fill the screen with blue\n\t\t\t//fragColor = vec4(0,0,1,0);\n            col = blue;\n            \t\n\t\t} else if (flag_X < 0.6 / size) {     \n\t\t\t// fill the 2/3 of size with yellow color\n\t\t\tcol = yellow;\n        \t    \n\t\t} else if (flag_X < 0.9 / size) {\n   \n\t\t\t// fill the last 1/3 with the red color \n\t\t\tcol=red;\n\t\t}\n    }\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 84, 84, 219], [221, 221, 278, 296, 2031]], "test": "valid"}
{"id": "flK3Dm", "name": "Omnes Vita", "author": "ivatronx", "description": "Eternal Light of Live", "tags": ["omnesvita"], "likes": 2, "viewed": 37, "published": "Public", "date": "1637813813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy/iResolution.xy;\n  st.x *= (iResolution.x/0.45)/(iResolution.y/0.25);\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n  float d2 = 0.0;\n  float d3 = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Make the distance field\n  d2 = length( abs(st*iTime)-0.9 );\n  d3 = length( min(abs(st)-0.1*abs(tan(0.1*iTime)),0.1) );\n  d = length( max(abs(st)-0.0003,0.005) );\n  // Visualize the distance field\n  fragColor = vec4(vec3(acos(tan(d2/d3*0.5*d)),acos(cos(d/d3*0.5*d)),acos(sin(d2/d3*0.5*d))),0.8);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 637]], "test": "valid"}
{"id": "flK3R3", "name": "slitscan geometry", "author": "jneen", "description": "in which different points in 3d space are looking at different slices of time. also reflections for swag", "tags": ["slitscan"], "likes": 2, "viewed": 40, "published": "Public", "date": "1638082493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time=0.;\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nmat2 rot(float a){float s=sin(a),c=cos(a); return mat2(c,s,-s,c);}\n\nvec3 M=vec3(0);\nfloat G=0.;\nfloat w(vec3 p) {\n  vec3 planep = p;\n  planep.xz *= rot(time);\n  float plane = box(planep+vec3(0,10,0), vec3(8));\n  p.xz *= rot(time);\n  p.xy *= rot(.2*time);\n  float B= length(p.xz)-1.;//box(p, vec3(1,2,1));//length(p)-2.;\n  B = max(B, -(length(p.xz)-.8));\n  \n  float C=length(p.xy)-1.5;\n  float CC=length(p.yz)-1.5;\n  CC = max(CC, -C);\n  \n  float BB= max(B,-C);\n  M = p.y < 0. ? vec3(.9, .7, .3) : vec3(.2, .8, .5);\n\n\n  if (CC < BB) M = vec3(.4, .6, 1.);\n\n\n  BB = min(BB, CC);\n\n\n  \n  float O = mix(B,BB,.5+.5*sin(time));\n  \n  G += -min(O,0.);\n  \n  O = mix(length(p)-2.,O,sin(2.*time));\n  \n  if (plane < O) M = vec3(.9,.3,.1);\n  \n  return min(plane,O);\n}\n\nfloat ray(vec3 p, vec3 dir){\nfloat d=0.,c;\nfor(int i=0;i<100;i++){\n  c=w(p+dir*d);d+=c*.5;\n  if(c<.01||d>69.)break;\n}\n\nreturn d;\n  \n}\n\nvec3 normal(vec3 p) {\n mat3 k = mat3(p,p,p)-mat3(.01);\n return normalize(w(p)-vec3(w(k[0]),w(k[1]),w(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    time = 2.*iTime;\n    \n    // COMMENT TO TURN OFF SLITSCAN EFFECT\n    time += sin(2.*uv.y) + length(uv);\n    \n    //uv *= rot(iTime);\n    vec3 col=vec3(0);\n    vec3 cam=vec3(0,0,-8);\n    vec3 dir=normalize(vec3(uv,1));\n    \n    float dist=ray(cam,dir);\n    vec3 mat = M;\n    float glow=G;\n    \n    if (dist<69.) {\n      vec3 hit = cam+dir*dist;\n      vec3 norm = normal(hit);\n      \n      \n      float diff = length(.5+.5*sin(1.+norm))/sqrt(3.);\n      col = mat*diff;\n      \n      vec3 refldir = reflect(dir,norm);\n      float refl = ray(hit+.1*refldir, refldir);\n      \n      if (refl<69.){\n        vec3 reflM = M;\n        vec3 rnorm = normal(hit+refldir*refl);\n        float rdiff = length(.5+.5*sin(1.+rnorm))/sqrt(3.);\n        col = mix(col, .1+reflM * rdiff, .5);\n      }\n\n\n    }\n    \n    //col += glow;\n    \n    // Output to screen\n    fragColor = vec4(col,1);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 43, 43, 127], [129, 129, 147, 147, 195], [225, 225, 242, 242, 880], [882, 882, 910, 910, 1015], [1017, 1017, 1038, 1038, 1128], [1130, 1130, 1187, 1237, 2203]], "test": "valid"}
{"id": "flK3RK", "name": "Classic Mandelbrot Set Demo.", "author": "Ludicrous", "description": "The classic mandelbrot set.", "tags": ["mandelbrot", "maths", "classic"], "likes": 1, "viewed": 55, "published": "Public", "date": "1638007871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getScale()\n{\n    return clamp(exp2(2.-iTime), .0005, 2.);\n}\n\nvec3 Hue(float v)\n{\n    return vec3(sin(v), sin(v + 2.09439510239), sin(v - 2.09439510239)) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord + iMouse.xy * .2)/iResolution.xy * 4.0 - vec2(1.7,2.3)) * getScale() + vec2(-1.39,.0143);\n    vec2 ini = vec2(0,0);\n    float iter = 0.;\n    float iterLimit = clamp(iTime * 10.0, 1., 300.);\n    for (int i = 0; i < int(iterLimit); i++)\n    {\n        vec2 nPos = vec2(ini.x * ini.x - ini.y * ini.y, 2. * ini.y * ini.x) + uv;\n        ini = nPos;\n        float len = length(nPos);\n        if (len > 2.0)\n        {\n            iter += 1.0 / (len * len - 3.);\n            i = 2000;\n            continue;\n        }\n        iter++;\n    }\n    vec3 col = Hue(iter * .12);\n    if (iter >= floor(iterLimit))\n        col = vec3(0,0,0);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [67, 67, 86, 86, 173], [175, 175, 232, 232, 915]], "test": "valid"}
{"id": "flKGRG", "name": "Desmos I Guess.SV", "author": "turtlelover891", "description": "Kinda like the Desmos Graphing Calculator", "tags": ["desmos"], "likes": 2, "viewed": 119, "published": "Public API", "date": "1637960324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//So basically, Desmos Graphing Calculator\n\n//equation function with color\nvec3 func(float w, float y, float e, vec3 col){\n    float sol = smoothstep(-1./w, 1./w, 1./w-abs(e-y));\n    return col*sol;\n}\n\n//equation function white\nfloat func(float w, float y, float e){\n    return smoothstep(-1./w, 1./w, 1./w-abs(e-y));\n}\n\n//use pi as needed\nconst float pi = acos(-1.);\n\n//=====================================================\n//Create your own custom functions\n//If a function is in another function, make sure that the function\n//on the inside is initialized before the function on the outside\n\nfloat a(float x, float t){\n    return sin(x*3.-(t*5.));\n}\n\nfloat b(float x, float t){\n    return sin(x+t*5.)*2.-sin(t);\n}\n\nfloat ab(float x, float t){\n    return b(x, t)+(sin(x)/2.+.5)*(a(x, t)-b(x, t));\n}\n\n//=====================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec3 col = vec3(0.);\n    float w = 1.;\n    w = clamp(iMouse.x/5., 2., R.x);\n    float x = fragCoord.x-R.x/2.;\n    float y = fragCoord.y;\n    if(iMouse.xy == vec2(0.)){\n        w = R.x/15.;\n        y /= w;\n        y -= R.y/w/2.;\n    }else{\n    y /= w;\n    y -= clamp(iMouse.y/w, 0., R.y/w);}\n    x /= w;\n\n    float t = iTime;\n    //grid lines\n    col += func(w, y, floor(y))/7.; col += func(w, y, 0.)/4.;\n    col += func(w, x, floor(x))/7.; col += func(w, x, 0.)/4.;\n\n    //The Function 'func' is how you display stuff\n    //The first parameter is w, the width of the line.\n    //Multiply or divide it to grow or shrink the width\n    //The second parameter is the axis, usually use y \n    //The third parameter is the function itself\n    //You can color the function by adding a fourth parameter\n    //Use vec3 for r, g, and b values\n\n    //=========================================================================== \n\n    //col += func(w,  y,  a(x, t),  vec3(1, 0, 0));      //red sin wave\n    //col += func(w,  y,  b(x, t),  vec3(0, 0, 1));      //blue  sin wave\n    col += func(w/2., y, ab(x, t),vec3(0, 1, 0));      //green sin wave\n    //col += func(w, y, x+7.5);                    //white diagonal line\n    //col += func(w, y, -x*x+7.5);                 //white upside down parabola\n    //col += func(w, 2., sqrt(pow(x-3., 2.) + pow(y-2., 2.)));//white circle\n    //col += func(w, x, pi);//white vertical line\n\n    //===========================================================================\n\n    //makes background not entirely black\n    col += vec3(0.075);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 75, 122, 122, 200], [202, 228, 266, 266, 319], [595, 595, 621, 621, 652], [654, 654, 680, 680, 716], [718, 718, 745, 745, 800], [860, 860, 917, 917, 2549]], "test": "error"}
{"id": "flKGzh", "name": "Font experiment 008", "author": "iY0Yi", "description": "Other experiments list:\n[url]https://www.shadertoy.com/playlist/tctBWH[/url]", "tags": ["font", "util"], "likes": 1, "viewed": 49, "published": "Public", "date": "1637162408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// lpnorm by gaz\n// https://www.shadertoy.com/view/slG3Rz\nfloat lpnorm(vec2 p, float n){vec2 t=pow(abs(p),vec2(n));return pow(t.x+t.y,1./n);}\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\nfloat dp = 0.;\n// iq's segment function\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    //p.x += sin(p.y*50.)*.01;\n    vec2 pa = p-a, ba = b-a;\n    dp = abs(dot(normalize(ba),vec2(0,1)));\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return lpnorm( pa - ba*h , 2.)+.25*sabs(p.x, .5)+.35*sabs(p.y, .5);\n}\n\n\nfloat fontSize = 1.;\nfloat fontWeight = .2;\n\n// Modify skeleton\n#define SEGX .45\n#define SEGY .6\n#define SEGCX sin(p.y*20.)*0.0025\n#define SEGCY -0.0025*sin(p.x*10.)\n#define SEGYHP +.45\n#define SEGYHN -.35\n\n// Short hands\n\n#define START_SEG float d = 1e4\n#define END_SEG return d\n#define DRAW_SEG(v1, v2) d=min(sdSegment(p, v1, v2)-fontWeight-mix(abs(sin(p.x*13.)), abs(sin(p.y*13.)), dp)*.05,d)\n\n// Outer Box (Start from Top/Left. Clockwise. SEG0-11)\n#define SEG0  DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX, +SEGY))\n#define SEG1  DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX, +SEGY))\n#define SEG2  DRAW_SEG(vec2( +SEGX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG3  DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( +SEGX, SEGCY))\n#define SEG4  DRAW_SEG(vec2( +SEGX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG5  DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG6  DRAW_SEG(vec2( +SEGX, -SEGY), vec2( SEGCX, -SEGY))\n#define SEG7  DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX, -SEGY))\n#define SEG8  DRAW_SEG(vec2( -SEGX, -SEGY), vec2( -SEGX,SEGYHN))\n#define SEG9  DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( -SEGX, SEGCY))\n#define SEG10 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( -SEGX,SEGYHP))\n#define SEG11 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( -SEGX, +SEGY))\n// Top Rhombus (Start from Top/Left. Clockwise. SEG12-15)\n#define SEG12 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( SEGCX, +SEGY))\n#define SEG13 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG14 DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( SEGCX, SEGCY))\n#define SEG15 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( -SEGX,SEGYHP))\n// Bottom Rhombus (Start from Top/Left. Clockwise. SEG16-19)\n#define SEG16 DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( SEGCX, SEGCY))\n#define SEG17 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG18 DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( SEGCX, -SEGY))\n#define SEG19 DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX,SEGYHN))\n// Center Vertical line (Top>Bottom. SEG20,21)\n#define SEG20 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( SEGCX, SEGCY))\n#define SEG21 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( SEGCX, -SEGY))\n// Center Horizont line (Left>Right. SEG22,23)\n#define SEG22 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX, SEGCY))\n#define SEG23 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG24-27)\n#define SEG24 DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX,SEGYHP))\n#define SEG25 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, +SEGY))\n#define SEG26 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHP))\n#define SEG27 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG28-31)\n#define SEG28 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHN))\n#define SEG29 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, SEGCY))\n#define SEG30 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG31 DRAW_SEG(vec2( -SEGX, -SEGY), vec2( SEGCX,SEGYHN))\n\n\n#define SKIP_DRAW d=d\n#define SEG0x  SKIP_DRAW\n#define SEG1x  SKIP_DRAW\n#define SEG2x  SKIP_DRAW\n#define SEG3x  SKIP_DRAW\n#define SEG4x  SKIP_DRAW\n#define SEG5x  SKIP_DRAW\n#define SEG6x  SKIP_DRAW\n#define SEG7x  SKIP_DRAW\n#define SEG8x  SKIP_DRAW\n#define SEG9x  SKIP_DRAW\n#define SEG10x SKIP_DRAW\n#define SEG11x SKIP_DRAW\n#define SEG12x SKIP_DRAW\n#define SEG13x SKIP_DRAW\n#define SEG14x SKIP_DRAW\n#define SEG15x SKIP_DRAW\n#define SEG16x SKIP_DRAW\n#define SEG17x SKIP_DRAW\n#define SEG18x SKIP_DRAW\n#define SEG19x SKIP_DRAW\n#define SEG20x SKIP_DRAW\n#define SEG21x SKIP_DRAW\n#define SEG22x SKIP_DRAW\n#define SEG23x SKIP_DRAW\n#define SEG24x SKIP_DRAW\n#define SEG25x SKIP_DRAW\n#define SEG26x SKIP_DRAW\n#define SEG27x SKIP_DRAW\n#define SEG28x SKIP_DRAW\n#define SEG29x SKIP_DRAW\n#define SEG30x SKIP_DRAW\n#define SEG31x SKIP_DRAW\n\n#define SEG0o  SEG0\n#define SEG1o  SEG1\n#define SEG2o  SEG2\n#define SEG3o  SEG3\n#define SEG4o  SEG4\n#define SEG5o  SEG5\n#define SEG6o  SEG6\n#define SEG7o  SEG7\n#define SEG8o  SEG8\n#define SEG9o  SEG9\n#define SEG10o SEG10\n#define SEG11o SEG11\n#define SEG12o SEG12\n#define SEG13o SEG13\n#define SEG14o SEG14\n#define SEG15o SEG15\n#define SEG16o SEG16\n#define SEG17o SEG17\n#define SEG18o SEG18\n#define SEG19o SEG19\n#define SEG20o SEG20\n#define SEG21o SEG21\n#define SEG22o SEG22\n#define SEG23o SEG23\n#define SEG24o SEG24\n#define SEG25o SEG25\n#define SEG26o SEG26\n#define SEG27o SEG27\n#define SEG28o SEG28\n#define SEG29o SEG29\n#define SEG30o SEG30\n#define SEG31o SEG31\n\nfloat sdAllSeg(vec2 p) {\n    // Start designing with copy & paste below lines.\n    // -------------------------------- ✂ -----------------------------------\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12o, SEG13o, SEG14o, SEG15o;\n    /*BottomRhombus*/   SEG16o, SEG17o, SEG18o, SEG19o;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n    // -------------------------------- ✂ -----------------------------------\n}\n\nfloat sdNum0(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum1(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1x,  SEG2x,  SEG3x, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum2(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8o, SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum3(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23o;\n    END_SEG;\n}\nfloat sdNum4(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0x,  SEG1x,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum5(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x, SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum6(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1x,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum7(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum8(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum9(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\n\nfloat sdNumFont(vec2 p, float s, float fi) {\n    p /= s;\n    int i = int(mod(floor(fi), 10.)); // 0-9    \n    switch(i){\n        case 0:\n            return sdNum0(p);\n        case 1:\n            return sdNum1(p);\n        case 2:\n            return sdNum2(p);\n        case 3:\n            return sdNum3(p);\n        case 4:\n            return sdNum4(p);\n        case 5:\n            return sdNum5(p);\n        case 6:\n            return sdNum6(p);\n        case 7:\n            return sdNum7(p);\n        case 8:\n            return sdNum8(p);\n        case 9:\n            return sdNum9(p);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord/iResolution.xy;\n    vec2 grid = vec2(.2,.5);\n    vec2 ip = floor(p/grid);\n    p = mod(p, grid)/grid*2.-1.;\n    p.y*=iResolution.x/iResolution.y;\n    p.y*=.8; // ???\n    \n\tfontWeight = .4+(sin(iTime*2.))*.015;//-clamp(sin(iTime*1.5)*2.,0.,1.)*.19;\n    fontSize = .9;\n    float num = ip.x+(1.-ip.y)*5.;// + floor(exp(clamp(sin(iTime*5.),0.,1.))*10.) + floor(sin(iTime*.5)*10.);\n    float d = sdNumFont(p, fontSize, num);\n    d = 1.-smoothstep(.0,.015,d);\n    \n    vec3 col = mix(vec3(0.102,0.102,0.102), vec3(.8, .77, .7), d);\n \n    // Draw Skeleton\n    col = max(col, vec3(.8, .77, .7)*.3*smoothstep(0.02, 0., abs(sdAllSeg(p/fontSize)+fontWeight)-.002));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 88, 88, 141], [143, 143, 172, 172, 242], [258, 283, 334, 365, 568], [4922, 4922, 4946, 5080, 5526], [5528, 5528, 5550, 5550, 5916], [5917, 5917, 5939, 5939, 6305], [6306, 6306, 6328, 6328, 6693], [6694, 6694, 6716, 6716, 7082], [7083, 7083, 7105, 7105, 7471], [7472, 7472, 7494, 7494, 7859], [7860, 7860, 7882, 7882, 8248], [8249, 8249, 8271, 8271, 8637], [8638, 8638, 8660, 8660, 9026], [9027, 9027, 9049, 9049, 9415], [9417, 9417, 9461, 9461, 10005], [10007, 10007, 10064, 10064, 10773]], "test": "error"}
{"id": "flt3WB", "name": "Trapped Light", "author": "dr2", "description": "Light cone (mouseable)", "tags": ["illumination", "lightcone"], "likes": 17, "viewed": 150, "published": "Public API", "date": "1636646130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Trapped Light\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (= 0/1) optional antialising\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, rmSize, ltPos, ltPosF;\nvec2 coneCs;\nfloat tCur, dstFar, szFac, sLoop, dLoop, aLoop, hBase, lEnd, tubRot;\nfloat coneHt[2], coneRd[2];\nint idObj;\nconst int idRm = 1, idBar = 2, idLit = 3, idLitF = 4, idTube = 5, idEx = 6, idEnd = 7, idCon = 8;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetObjConf ()\n{\n  float t;\n  t = tCur / 30. + 0.5;\n  tubRot = mod (15. * t, 2. * pi);\n  t = mod (t, 1.);\n  sLoop = (1. / 1.4) / (0.01 + 0.99 * SmoothBump (0.25, 0.75, 0.15, t));\n  aLoop = 0.25 * pi / sLoop;\n  dLoop = 6. * sLoop;\n  lEnd = 1.;\n  hBase = - (6. * (0.5 * pi) + 4. * lEnd) * (1. - SmoothBump (0.1, 0.9, 0.08, t));\n  coneCs = sin (-0.17 * pi + 0.07 * pi * sin (1.5 * pi * tCur) + vec2 (0.5 * pi, 0.));\n  coneHt[0] = 0.8 * coneCs.x;\n  coneRd[0] = 0.3 - 0.8 * coneCs.y;\n  coneHt[1] = 50. * 0.8 * coneCs.x;\n  coneRd[1] = 0.95 * 0.3 - 0.8 * coneCs.y;\n  szFac = 0.5;\n  ltPos = vec3 (0., 2. * lEnd + 0.75 + coneHt[0], 0.);\n  ltPos.xy = Rot2D (Rot2D (ltPos.xy - vec2 (dLoop, 0.), - aLoop), - (aLoop - 0.5 * pi)) +\n     vec2 (0., dLoop);\n  ltPos.xy = ltPos.yx * vec2 (1., -1.);\n  ltPos.y += 2. * lEnd + hBase + 0.3;\n  ltPos.xz = Rot2D (ltPos.xz, - tubRot);\n  ltPos *= szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, rCyl, rc, s, dc, dy, db;\n  dMin = dstFar;\n  q = p;\n  q.y -= rmSize.y - 0.4;\n  db = PrBoxDf (q, rmSize);\n  d = abs (db) - 0.4;\n  q.xz = mix (q.zx, q.xz, step (abs (q.z), abs (q.x)));\n  d = max (max (d, - PrBox2Df (q.zy, vec2 (2.5, 5.))), min (2.5 - length (abs (q.xz) - 15.), q.y));\n  DMINQ (idRm);\n  d = min (length (vec2 (abs (q.x) - rmSize.x + 0.15, q.z)),\n     length (vec2 (abs (q.x) - rmSize.x + 0.15, abs (q.y) - 1.8))) - 0.2;\n  q = vec3 (abs (q.xz) - 15., q.y - rmSize.y + 0.15).xzy;\n  d = max (min (d, min (length (q.xy), length (q.zy)) - 0.15), db);\n  DMINQ (idBar);\n  q = p - ltPosF;\n  q.y -= 1.;\n  d = PrCapsDf (q.xzy, 1., 0.5);\n  DMINQ (idLitF);\n  dMin /= szFac;\n  p /= szFac;  // (from \"Metallic Tubeworms\")\n  rCyl = 0.6;\n  rc = 0.6;\n  q = p;\n  dy = - q.y;\n  q.y -= 0.3;\n  d = max (PrRoundCylDf (q.xzy, rCyl + 0.4, 0.1, 0.3), dy);\n  DMINQ (idEx);\n  q = p;\n  q.y -= 2. * lEnd + hBase + 0.3;\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) -\n     rc, rc), abs (q.y + lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.yx * vec2 (-1., 1.) - vec2 (0., dLoop), aLoop - 0.5 * pi);\n  s = mod (3. * dLoop * atan (q.y, - q.x) + 0.5, 1.);\n  qq = q;\n  dc = dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)));\n  q.xz = Rot2D (vec2 (length (q.xy) - dLoop, q.z), tubRot);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s)) -\n     rc), rc), dc), dy);\n  DMINQ (idTube);\n  q = qq;\n  q.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  q.xz = Rot2D (q.xz, - tubRot);\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) -\n     rc, rc), abs (q.y - lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.y -= 2. * lEnd + 0.1;\n  d = PrRoundCylDf (q.xzy, rCyl + 0.1, 0.05, 0.05);\n  DMINQ (idEx);\n  q.y -= 0.2;\n  d = PrCapsDf (q.xzy, 0.35, 0.25);\n  DMINQ (idEx);\n  q.y -= 0.4 + coneHt[0];\n  d = PrAnConCylDf (q.xzy, coneCs, coneRd[0], 0.05, coneHt[0]);\n  d = max (d, min (0.05 - min (abs (q.x), abs (q.z)), 0.5 * coneHt[0] -\n     abs (q.y - 0.1 * coneHt[0])));\n  DMINQ (idCon);\n  d = PrCapsDf (q.xzy, 0.4, 0.2);\n  DMINQ (idLit);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  q.y -= 2. * lEnd + hBase + 0.3;\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (Rot2D (q.yx * vec2 (-1., 1.) - vec2 (0., dLoop), aLoop - 0.5 * pi), aLoop) +\n     vec2 (dLoop, 0.);\n  q.y -= 2. * lEnd + 0.75 + coneHt[0];\n  d = max (PrConCylDf (q.xzy, coneCs, coneRd[1], coneHt[1]), coneHt[0] - q.y);\n  DMINQ (idCon);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  int idObjT;\n  sh = 1.;\n  d = 0.01;\n  idObjT = idObj;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dMax) break;\n  }\n  idObj = idObjT;\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 sp, ss;\n  if (2. * floor (0.5 * floor (p.y)) != floor (p.y)) p.x += 0.5;\n  sp = smoothstep (0.03, 0.07, abs (fract (p + 0.5) - 0.5));\n  p = fract (p) - 0.5;\n  ss = 0.3 * smoothstep (0.4, 0.5, abs (p.xy)) * sign (p.xy);\n  if (abs (p.x) < abs (p.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sp.x * sp.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn)\n{\n  vec3 rg;\n  if (abs (vn.x) > 0.99) {\n    rg = ShStagGrid (p.zy);\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg = ShStagGrid (p.zx);\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg = ShStagGrid (p.xy);\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.04 * Fbm1 (32. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4;\n  vec3 col, vn, roo, rdo, ltDir, ltAx;\n  float dstGrnd, dstObj, dstTrObj, nDotL, sh, ltDst, att;\n  SetObjConf ();\n  ltPosF = vec3 (0., 2. * rmSize.y - 1.8, 0.);\n  roo = ro;\n  rdo = rd;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (1., 1., 0.9, 0.2);\n    if (idObj == idTube || idObj == idEnd) {\n      col4 = col4 * (0.93 + 0.07 * smoothstep (-0.1, 0., cos (32. * atan (qHit.z, - qHit.x))));\n    } else if (idObj == idEx) {\n      col4 *= 0.95;\n    } else if (idObj == idCon) {\n      col4 = (PrConCylDf (qHit.xzy, coneCs, coneRd[0], coneHt[0]) < 0.) ?\n         vec4 (0.8 + 0.2 * sin (32. * pi * tCur), 0., 0., -1.) : col4 *\n         (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (64. * qHit.y)));\n    } else if (idObj == idBar) {\n      col4 = vec4 (0.9, 0.5, 0.2, 0.1);\n    } else if (idObj == idRm) {\n      col4 = (abs (vn.y) < 0.99) ? vec4 (1., 1., 0.9, 0.2) : ((vn.y > 0.) ?\n         vec4 (1., 0.8, 0.8, 0.2) : vec4 (0.8, 1., 0.8, 0.2) * (0.8 + 0.2 * smoothstep (0., 1.,\n         length (ro.xz) - 1.)));\n      rg4 = ShStagGrid3d (ro, vn);\n      vn = rg4.xyz;\n      vn = VaryNf (4. * ro, vn, 0.2);\n      col4.rgb *= 0.9 + 0.1 * rg4.w;\n    } else if (idObj == idLit) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    } else if (idObj == idLitF) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    }\n    if (col4.a >= 0.) {\n      ltDir = ltPosF - ro;\n      ltDst = length (ltDir);\n      ltDir = normalize (ltDir);\n      att = 1. / (1. + 0.002 * ltDst * ltDst);\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir, ltDst - 2.);\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = att * (col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n         step (0.95, sh) * col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n      if (idObj <= idBar) {\n        ltDir = ltPos - ro;\n        ltDst = length (ltDir);\n        ltDir = normalize (ltDir);\n        ltAx = vec3 (0., -1., 0.);\n        ltAx.xy = Rot2D (ltAx.xy, -2. * aLoop);\n        ltAx.xz = Rot2D (ltAx.xz, - tubRot);\n        att = smoothstep (-0.1, 0.2, dot (ltAx, ltDir) - coneCs.x) *\n           step (- dot (vn, ltDir), 0.) / (1. + 0.002 * ltDst * ltDst);\n        col = mix (col, att * (col4.rgb * max (dot (vn, ltDir), 0.) +\n           col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.)), 0.5);\n      }\n    } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col = 0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n    vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n    col *= 0.2 + 0.8 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  ro = roo;\n  rd = rdo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    ltDst = length (ro - ltPos);\n    att = 1. / (1. + 0.2 * ltDst * ltDst);\n    col = mix (col, vec3 (1., 1., 0.8), 0.3 * max (- dot (vn, rd), 0.) *\n       att * (1. - smoothstep (-0.3, -0.1, dstTrObj - dstObj)));\n  }\n  ltAx = vec3 (0., -1., 0.);\n  ltAx.xy = Rot2D (ltAx.xy, -2. * aLoop);\n  ltAx.xz = Rot2D (ltAx.xz, - tubRot);\n  col = mix (col, vec3 (1., 1., 0.9), 0.15 * smoothstep (-0.1, 0.2,\n     dot (ltAx, normalize (ltPos - roo)) - coneCs.x));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  el = 0.;\n  az = 0.27 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.44 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  rmSize = vec3 (20.4, 9.4, 20.4);\n  ro = vec3 (-17., 9., -17.);\n  sunDir = normalize (vec3 (1., 1., -1.));\n  zmFac = 2.1;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h)\n{\n  return max (abs (dot (vec2 (length (p.xy) - r, p.z), cs)) - w, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec4 (0., cHashVA2.xy, cHashVA2.x + cHashVA2.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3WB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1189, 1189, 1209, 1209, 2072], [2074, 2074, 2096, 2096, 4426], [4428, 4428, 4461, 4461, 4644], [4646, 4646, 4667, 4667, 4922], [4924, 4924, 4948, 4948, 5373], [5375, 5375, 5410, 5410, 5594], [5596, 5596, 5619, 5619, 5876], [5878, 5878, 5927, 5927, 6218], [6220, 6220, 6246, 6246, 6573], [6575, 6575, 6612, 6612, 7173], [7175, 7175, 7209, 7209, 7966], [7968, 7968, 8003, 8003, 11474], [11476, 11476, 11529, 11529, 12661], [12663, 12663, 12695, 12695, 12795], [12797, 12797, 12830, 12830, 12919], [12921, 12921, 12969, 12969, 13036], [13038, 13038, 13095, 13095, 13171], [13173, 13173, 13216, 13216, 13280], [13282, 13282, 13336, 13336, 13409], [13411, 13411, 13476, 13476, 13559], [13561, 13561, 13597, 13597, 13803], [13805, 13805, 13835, 13835, 13948], [13950, 13950, 14007, 14007, 14090], [14124, 14124, 14148, 14148, 14201], [14203, 14203, 14227, 14227, 14339], [14341, 14341, 14365, 14365, 14502], [14504, 14504, 14529, 14529, 14675], [14677, 14677, 14702, 14702, 14888], [14890, 14890, 14912, 14912, 15066], [15068, 15068, 15089, 15089, 15244], [15246, 15246, 15275, 15275, 15487], [15489, 15489, 15528, 15528, 15780]], "test": "error"}
{"id": "flt3Wj", "name": "Glacier", "author": "guil", "description": "Fork from https://t.co/CrlKX7VEmE?amp=1", "tags": ["ice"], "likes": 6, "viewed": 141, "published": "Public API", "date": "1636739389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s,e,f,o;\n\tvec3 n;n.y=1.;\n    e=p.y;\n\tfor(s=1.;s<8e2;s*=1.8)p.xz*=rot(s),n.xz*=rot(s),n+=cos(p*s)*.3,e+=(dot(sin(p.xz*s),vec2(.3)/s));\n\tn=-normalize(n);\n    f-=exp(-e*11.-6.)*dot(n.xz,vec2(1.8));\n    e-=n.y*n.y*.1;\n    e-=n.z*n.z*.1;\n    o-=exp(-e*11.-6.);\n    \n    return vec2(max(.2,1.+.4*f),1.+o);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .025;\n    vec3 col= vec3(0.);\n    for( int i=0; i<128; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.015;\n        col = .95*col+ .08*vec3(c*c*c, .9*c*c, 1.2*c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(-4);\n    ro.y +=1.;\n    ro.yz*=rot(-.9);    \n    vec3 rd = normalize( vec3(p,2.)-ro);    \n    ro.z +=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 68], [71, 113, 136, 136, 447], [450, 450, 487, 487, 787], [790, 790, 847, 847, 1293]], "test": "valid"}
{"id": "flt3z7", "name": "Fractelligence", "author": "PsyPhi", "description": "Raymarched Fractal", "tags": ["raymarching", "fractal"], "likes": 6, "viewed": 179, "published": "Public API", "date": "1636647970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Transforms\nfloat RotX = 1.5; //0 to 3\nfloat RotY = 1.5;\nfloat RotZ = 1.5;\nfloat TransX = 1.; //0 to 5\nfloat TransY = 1.5;\nfloat TransZ = 0.5;\nfloat Scale = 0.;\nfloat Range = 0.001;\nfloat RX = 0.;\nfloat RY = 0.;\nfloat RZ = 0.;\nfloat TX = 0.;\nfloat TY = 1.;\nfloat TZ = 0.;\nfloat TwistY = 0.; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 1;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 1.;\n//Sphere\nint Sphere = 0;\nfloat SphereScale = 1.;\nfloat SphereTX = 0.;\nfloat SphereTY = 0.;\nfloat SphereTZ = 0.;\n//Shapes\nint InfPre = 1;\nint InfPost = 0;\nint Merge = 0;\nfloat ShapeMix = 0.;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 0.;\nfloat Proximity = 0.;\nfloat PHue = 0.;\nfloat Distance = 0.;\nfloat DHue = 0.;\nfloat light = 0.;\nfloat DepthHue = 0.1;\nfloat ProxHue = 0.;\n//Time\nfloat TimeRotX = 1.;\nfloat TimeRotY = 0.25;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.05;\nint TimeEnable = 1;\nint TimeDisabled = 0;\n\n\n\n\n\n\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\n\tfloat c = cos(a),\n\n\t\ts = sin(a);\n\n\treturn mat2(c, -s, s, c);\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n\n{\n\nfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\nreturn mix( d2, d1, h ) - k*h*(1.0-h);\n\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\n\n\n\tfloat d = 1.; //Just to have the d var declaired\n\n//\tfloat perStep = 1/FRACT_STEPS;\n\n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n\nif(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.2);\n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);;\n\t\tp.z -= TransZ;\n\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); //Audio rct\n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n    p.xz *= rotate(p.y*TwistY); //Twist\n\nif(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n}\n\nif (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n\t  float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n    else d = min(sphereDist,d);\n  }\n\n\n\t\t if (Rectangle == 1){//Adds in the Rectangle\n\t\t\t vec4 rec = vec4(0.0, 0.0, 0.0, RecScale);\n\t\t\t float recDist = length(max(abs(p) - rec.w, 0.));\n\t\t\t if(Merge == 1) d = opSmoothUnion(recDist, d, ShapeMix);\n       else d = min(recDist,d);\n\t\t }\n\n\n\t\t// d = min(sphereDist,d);\n\n\n\t//}\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    if (TimeEnable == 0 && TimeDisabled == 0) {\n    TimeRotX = 0.;\n    TimeRotY = 0.;\n    TimeTransX = 0.;\n    TimeTransY = 0.;\n    int TimeDisabled = 1;\n    }\n    \n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n\n\t\tfloat prox = 0.0;\n\n    vec3 ro = vec3(0, 0, -6+\n      (InfPre+InfPost));  //Audio rct\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec3 d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n    //color = vec3(dif);\t\t\t\t//lighting\n\n\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n\n\tcolor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n\n    //color = hs(color, IHue);\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity\n    // *1.-tex.r\n    ;//G\n\n    color = hs(color, PHue);\n    color.b = (1.-d.x*0.04)*Distance;\n\n    color = hs(color, DHue);\n    \n    color += dif*light;       //light\n    //color = hs(color, 5.0*dif*light);       //light hue rotate\n    \n    color = hs(color, -n.b);\n    color = hs(color, n.r);\n   //color.r += GetNormal(p)\n\n\t\t  color = hs(color, d.y*DepthHue); //iterations to hue rot\n\n//\t\tcolor -= dif*0.5;\n\n\n\n    fragColor = vec4(color,1.0);\n    \n\n}\n\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1085, 1085, 1159, 1159, 1232], [1234, 1234, 1259, 1259, 1351], [1353, 1353, 1375, 1375, 1441], [1443, 1443, 1525, 1525, 1619], [1623, 1671, 1694, 1694, 2990], [2992, 2992, 3025, 3025, 3387], [3389, 3389, 3413, 3413, 3594], [3596, 3596, 3620, 3620, 3937], [3941, 3941, 3999, 3999, 5222]], "test": "valid"}
{"id": "flt3zl", "name": "Glowing Offset Triangles", "author": "Shane", "description": "Using an offset triangle grid to produce some randomly glowing markings on some irregular triangles.", "tags": ["grid", "triangle", "light", "glow", "skew"], "likes": 77, "viewed": 713, "published": "Public API", "date": "1637499088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tGlowing Offset Triangles\n\t------------------------\n\n    Using an offset triangle grid to produce some randomly glowing markings \n    on some irregular triangles.\n    \n    I coded this some time ago, and decided to tidy it up and post it after \n    seeing Yusef28's cool static triangle grid efforts. This particular one\n    was inspired by those phone backgrounds that you may have seen around. \n    \n    The code was written off the top of my head just to get the job done, so \n    I'd ignore most of it. The offset triangle routine is probably worth \n    looking at, if you're interested in this kind of thing.\n    \n    In case it isn't obvious, this is a simple 2D example with some fake 3D\n    elements thrown in. Since there's emitting light involved, it would have \n    been nice to path trace it, but I'm guessing not a lot of people here are \n    viewing Shadertoy on a supercomputer, so perhaps some other time. :) A \n    standard realtime 3D version should be possible though.\n    \n\n\n\tRelated examples:\n\n\n\t// My example is loosely enspired by this.\n\tSimplex Experiment #3b  - Yusef28\n\thttps://www.shadertoy.com/view/Nl33WM\n\n*/\n\n// Display the animated glowing cracks. One could argue that it defeats the\n// purpose of the example, but you may wish to see the pattern without the glow. :)\n#define GLOW\n\n// Light decorations on the triangle faces.\n//#define FACE_DECO\n\n// Light decorations on the outer triangle faces.\n#define OUTER_FACE_DECO\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n// Textured.\n//#define TEXTURE\n\n// Animate the triangles -- Technically, a metallic surface animating in such a\n// way isn't really realistic, so you may wish to keep the arrangement static.\n#define ANIMATE\n\n// Light color - Reddish Pink: 0, Greenish Blue: 1. \n#define COLOR 0\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    #ifdef ANIMATE\n    return sin(p*6.2831853 + iTime/2.);\n    #else\n    return p;\n    #endif\n     \n}\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(289, 41)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.;\n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    //return sin(p*6.2831853 + iTime/2.); \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.57 + n2D3G(p*2.)*.28 + n2D3G(p*4.)*.15; }\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n\n/*\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .0002/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .0002;      \n        \n}  \n\n*/\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\nconst float tf = 2./sqrt(3.);\n// Scale.\nconst vec2 scale = vec2(tf, 1)*vec2(1./3.);\n\n// Brick dimension: Length to height ratio with additional scaling.\nconst vec2 dim = vec2(scale);\n// A helper vector, but basically, it's the size of the repeat cell.\nconst vec2 s = dim*2.;\n    \n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(tf/2., 0);\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 id = vec2(0), cntr;\n    \n    // For block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n    // Height scale.\n    const float hs = .5;\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0];\n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);// - cntr*s;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices.\n        vert[0] += hash22B((idi + vert[0]/2.))*.2;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.2;\n        vert[2] += hash22B((idi + vert[2]/2.))*.2; \n        vert[3] += hash22B((idi + vert[3]/2.))*.2;\n        #endif\n        \n        \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi*s, sk);  \n \n        \n        // Partioning the rectangle into two triangles.\n        \n        // Triangle one.\n        tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n        tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n        tri1.triID = float(i); // Triangle ID. Not used here.\n        tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n        tri1.p = p; // 2D coordinates.\n         \n        // Triangle two.\n        tri2.v = vec2[3](vert[0], vert[2], vert[3]);\n        tri2.id = idi + inCentRad(tri2.v[0], tri2.v[1], tri2.v[2]).xy; // Position Id.\n        tri1.triID = float(i + 4); // Triangle ID. Not used here.\n        tri2.dist = sdTri(p, tri2.v[0], tri2.v[1], tri2.v[2]); // Field distance.\n        tri2.p = p; // 2D coordinates.\n         \n        // Doesn't work, unfortunately, so I need to write an ugly \"if\" statement.\n        //triS gTi = tri1.dist<tri2.dist? tri1 : tri2;\n        triS gTi; \n        // Obtain the closest triangle information.\n        if(tri1.dist<tri2.dist) gTi = tri1; \n        else gTi = tri2;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // then return the correct triangle information.\n        if(gTi.dist<d){\n            d = gTi.dist;\n            gT = gTi;\n            gT.id = idi;//(idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy)*s;\n        }\n        \n        //if(d>1e8) break; // Fake break to get compile times down.\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n    // Scene rotation.\n    uv.xy *= rot2(-3.14159/9.);\n    \n    \n    // Unit direction vector and camera origin. \n    // Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0);\n   \n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = uv*gSc - vec2(0, iTime/32.).yx;\n    \n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    \n    // Take an offset triangle function sample. \n    triS gT = blocks(p);\n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] v = gT.v;\n    vec2 rp = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene color to black.\n    vec3 col = vec3(0);  \n     \n    // Triangle color.\n    vec3 tCol = vec3(0);\n\n     \n    // Triangle cell center.\n    vec3 cntr = inCentRad(v[0], v[1], v[2]);\n\n     \n    // Light position, light direction and light distance.\n    vec3 lp = vec3(-.5, 1, -1);\n    vec3 ld = lp - vec3(uv, 0);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    // Light attenuation.\n    float atten = 2./(1. + lDist*lDist*.5);\n\n    // Triangle cell.\n    float triCell = sdTri(rp, v[0], v[1], v[2]);\n    //float triCell2 = sdTri(rp, v[0] - ld.xy*.01, v[1] - ld.xy*.01, v[2] - ld.xy*.01);\n\n    \n    // Circle center and opening.\n    float cir = length(rp - cntr.xy);\n    // The opening is created by using the edge triangles to chip away\n    // from the original cell space.\n    float opening = triCell;\n\n\n    // Glow color.\n    vec3 glCol = vec3(1, .35, .2);\n    #if COLOR == 1\n    glCol = mix(glCol.zyx, glCol.zxy, clamp(-uv.y*1.25 + .5, 0., 1.));\n    #endif\n    glCol = mix(glCol, glCol.xzy, dot(sin(p*2. - cos(p.yx*4.)*3.), vec2(.125)) + .25);\n    //tx = glCol;\n    glCol *= (fBm((rp -svID*s)*128.)*.25 + .75)*1.25; // Adding noise.\n\n\n\n    // Adding some glow to the triangle cell. The subdivided triangle will be drawn\n    // over the top, thus giving the impression of light eminating through cracks.\n    col += glCol*max(.2 - triCell/scale.x*6., 0.);\n\n    // Edge and opening distance fields.\n    float edge = 1e5, openMax = 0.;\n    \n    // Subdividing the triangle cell and producing three triangle wedges -- one\n    // for each side.\n    for(int j = min(0, iFrame); j<3; j++){\n\n\n        // Random numbers based on the triangle cell ID, and the individual\n        // subdivided triangle ID.\n        float rnd = hash21(svID + .08);\n        float rndJ = hash21(svID + float(j)/9. + .13);\n\n        // Open the triangle sides at random blinking intervals.\n        float open = smoothstep(.9, .966, sin(rnd*6.2831 + rndJ/6. + iTime/1.)*.5 + .5);\n        //if(hash21(svID +.34)<.5) open = 0.;\n        //if(gT.triID<.5) open = 0.;\n        // If not showing the glowing light through the cracks, overide \n        // the open variable.\n        #ifndef GLOW\n        open = 0.;\n        #endif\n\n        // Subdivided triangle vertices.\n        vec3 p0 = vec3(v[j], 0);\n        vec3 p1 = vec3(v[(j + 1)%3], 0);\n        vec3 p2 = vec3(cntr.xy, -.2);\n        // Moving the central vertex toward the opposing edge to\n        // simulate the triangle opening like a flower.\n        //p2.xy -= (vec3(v[(j + 2)%3], 0) - p2).xy*.065*open;//(rndJ*.5 + .5)*.07;\n        p2.xy -= normalize(vec3(v[(j + 2)%3], 0) - p2).xy*.065*scale.x*open;\n\n        float triJ = sdTri(rp, v[j], v[(j + 1)%3], p2.xy);\n\n        // Z value, for some faux texture depth.\n        float z = 1./(1. - p2.z);\n        \n        // Creating a second shifted triangle give the open flap some fake depth.\n        p2.xy += normalize(v[(j + 2)%3] - cntr.xy)*.008*open;\n        \n        // Produce the triangle for this edge.\n        float triEdge = sdTri(rp, v[j], v[(j + 1)%3], p2.xy);\n\n   \n        // Normal -- Based on slightly incorrect hit information, but\n        // it's near enough.\n        vec3 nJ = normalize(cross(p1 - p0, p2 - p0));\n \n\n        // Diffuse lighting.\n        float diff = max(dot(ld, nJ), 0.);\n        diff = pow(diff, 4.)*2.;\n        // Specular lighting.\n        float spec = pow(max(dot(reflect(ld, nJ), rd ), 0.), 8.); \n\n\n \n        // Triangle color.\n        #ifdef TEXTURE\n        // Texture color.\n        vec3 tx2 = texture(iChannel0, (rp - svID*s)*z).xyz; tx2 *= tx2;\n        //vec3 tx2 = texture(iChannel0, svID*s).xyz; tx2 *= tx2;\n\n        vec3 tCol = smoothstep(-.5, 1., tx2)*.1;\n        //tCol = sqrt(tx2)*.1;\n        #else\n        vec3 tCol = vec3(.035);\n        #endif\n        \n        // Concentric triangular face pattern.\n        //float pat = (abs(fract(triPat[j]*84. - .5/84.) - .5)*2. - .5)/84.;\n        //tCol = mix(tCol*1.3, tCol*.65, 1. - smoothstep(0., sf, pat));\n\n\n        // Applying the diffuse and specular to the triangle.\n        tCol = tCol*(diff + .25 + spec*4.);\n\n        // Easier way to add diffuse light, but not as good.\n        //float b = max(triCell2 - triCell, 0.)/.01;\n        //tCol *= (b + .25);\n\n        \n        // Lightening the edges.\n        //col = mix(col, col*vec3(12, 6, 2), (1. - smoothstep(0., sf*4., triPat[j] - .001))*.25);\n\n        if(open>1e-5){\n            col = mix(col, vec3(0), open*(1. - smoothstep(0., sf*4., triEdge - .00)));\n            col = mix(col, mix(tCol*vec3(1.5, 1.25, 1), vec3(0), open), (1. - smoothstep(0., sf*2., triEdge)));// + .005/3.\n            col = mix(col, mix(tCol, glCol, .5)*(open), (1. - smoothstep(0., sf, triEdge + .005)));// + .005/3.\n        }\n        //else col = mix(col, vec3(0), open*(1. - smoothstep(0., sf*4., triPat[j] - .00)));// + .005/3.\n\n        col = mix(col, tCol*vec3(1.5, 1.25, 1)*(1. - open), 1. - smoothstep(0., sf*2., triJ));// + .005/3.\n        col = mix(col, tCol, 1. - smoothstep(0., sf*2., triJ + .005));// .005*2./3.\n\n        #ifdef OUTER_FACE_DECO\n        // Outer face decoration.\n        col = mix(col, mix(tCol, glCol*1., open), 1. - smoothstep(0., sf*4., abs(triJ + .035) - .002));// .005*2./3.\n        col = mix(col, mix(tCol, tCol/3., open), 1. - smoothstep(0., sf, abs(abs(triJ + .035) - .006) - .00125));// .005*2./3.\n        #endif\n        \n        #ifdef FACE_DECO\n        // Face decoration.\n        col = mix(col, mix(tCol, (diff + .25 + spec*4.)*glCol, open), (1. - smoothstep(0., sf*3., triJ + .035))*.2);\n        col = mix(col, mix(tCol, vec3(0), open), 1. - smoothstep(0., sf*2., triJ + .035));         \n        col = mix(col, mix(tCol, (diff + .25 + spec*4.)*glCol*2., open), 1. - smoothstep(0., sf, triJ + .035 + .005));          \n        #endif\n\n        edge = min(edge, abs(triJ));\n\n        p0.xy -= (p2.xy - p0.xy)*1.;//*length(p2.xy - p0.xy)*2.;\n        p1.xy -= (p2.xy - p1.xy)*1.;//*length(p2.xy - p1.xy)*2.;\n        float eTri = sdTri(rp, p0.xy*8., p1.xy*8., p2.xy);\n\n        // Glow mask. \n        openMax = max(openMax, open);\n        opening = max(opening, -eTri);\n\n\n    }\n\n    // Applying the glow mask.\n    cir = mix(cir, opening, .65);\n    col = mix(col, col + col*glCol*(openMax*2.5 + .5), (1. - smoothstep(0., sf*24., cir)));// + .005/3.\n\n    // Darkening and shading the edges.\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, edge - .001))*.5);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf*32., abs(triCell)))*.35);\n    col *= clamp(.5 - triCell/scale.x*4., 0., 1.);\n\n\n    // Outer layer noise. This is applied to the border cords and points.\n    float ns = fBm((rp - cntr.xy)*128.)*.5 + .5;\n    col *= .5 + ns*.75;\n\n    // Light attenuation.\n    col *= atten;\n\n\n/*   \n    // Vertices.\n    vec3 cir3 = vec3(length(svP - svV[0]), length(svP - svV[1]), length(svP - svV[2]));\n    float verts = min(min(cir3.x, cir3.y), cir3.z);\n    verts -= .016;\n \n    vec3 vCol = lCol;//*.7;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5.*iRes/450., verts))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .005, verts)));  \n    col = mix(col, vCol, (1. - smoothstep(0., sf, verts + .0035))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, verts + .011))); // Pin staple hole. \n*/   \n  \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1835, 1868, 1890, 1890, 1948], [1951, 1979, 2000, 2000, 2063], [2066, 2088, 2110, 2459, 2649], [2651, 2673, 2695, 3044, 3251], [3254, 3295, 3320, 3362, 3808], [3810, 3834, 3852, 3852, 3911], [3915, 3957, 4016, 4016, 4596], [4600, 4635, 4677, 4703, 4982], [4984, 5047, 5075, 5075, 5105], [5108, 5173, 5203, 5203, 5242]], "test": "error"}
{"id": "fltGWS", "name": "KaliedT", "author": "tomjhinton", "description": "Non rectangular tiles", "tags": ["tiling"], "likes": 1, "viewed": 36, "published": "Public", "date": "1636628409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float TAU = PI * 2.;\n\n\n\nconst vec2 v60 = vec2( cos(PI/3.0), sin(PI/3.0));\nconst vec2 vm60 = vec2(cos(-PI/3.0), sin(-PI/3.0));\nconst mat2 rot60 = mat2(v60.x,-v60.y,v60.y,v60.x);\nconst mat2 rotm60 = mat2(vm60.x,-vm60.y,vm60.y,vm60.x);\n\nfloat stroke(float x, float s, float w){\n  float d = step(s, x+ w * .5) - step(s, x - w * .5);\n  return clamp(d, 0., 1.);\n}\n\n\nvoid coswarp(inout vec3 trip, float warpsScale ){\n\n  trip.xyz += warpsScale * .1 * cos(3. * trip.yzx + (iTime * .25));\n  trip.xyz += warpsScale * .05 * cos(11. * trip.yzx + (iTime * .25));\n  trip.xyz += warpsScale * .025 * cos(17. * trip.yzx + (iTime * .25));\n}\n\n\nfloat aastep(float threshold, float value) {\n\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n\n}\n\nfloat fill(float x, float size) {\n    return 1.-aastep(size, x);\n}\n\n\n\nvec2 getRadialUv(vec2 uv) {\n\tfloat angle = atan(uv.x, -uv.y);\n\tangle = abs(angle);\n\tvec2 radialUv = vec2(0.0);\n\tradialUv.x = angle / (PI * 2.0) + 0.5;\n\tradialUv.y = 1.0 - pow(1.0 - length(uv), 4.0);\n\treturn radialUv;\n}\n\n\nfloat triangleGrid(vec2 p, float stepSize,float vertexSize,float lineSize)\n{\n    // equilateral triangle grid\n    vec2 fullStep= vec2( stepSize , stepSize*v60.y);\n    vec2 halfStep=fullStep/2.0;\n    vec2 grid = floor(p/fullStep);\n    vec2 offset = vec2( (mod(grid.y,2.0)==1.0) ? halfStep.x : 0. , 0.);\n   \t// tiling\n    vec2 uv = mod(p+offset,fullStep)-halfStep;\n    float d2=dot(uv,uv);\n    return vertexSize/d2 + // vertices\n    \tmax( abs(lineSize/(uv*rotm60).y), // lines -60deg\n        \t max ( abs(lineSize/(uv*rot60).y), // lines 60deg\n        \t  \t   abs(lineSize/(uv.y)) )); // h lines\n}\n\nvec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {\n  mat2 rotation_matrix=mat2(  vec2(sin(rotation),-cos(rotation)),\n                              vec2(cos(rotation),sin(rotation))\n                              );\n  uv -= pivot;\n  uv= uv*rotation_matrix;\n  uv += pivot;\n  return uv;\n}\n\nconst vec2 s = vec2(1, 1.7320508);\n\n\nfloat hex(in vec2 p){\n\n\t\t p = abs(p);\n\n\t\t return max(dot(p, s*.5), p.x); // Hexagon.\n\n }\nvec4 getHex(vec2 p){\n\n\t\t vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n\n\t\t vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n\n\t\t return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n\n }\n\n\n float box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 vUv = uv;\n float alpha = 1.;\n    \n  vec2 uvT = getRadialUv(uv -.5);\n\tvec2 rote = rotateUV(uv, vec2(.5), PI * iTime * .05);\n  vec2 uvT2 = getRadialUv(rote -.5);\n\tvec2 roteC = rotateUV(vUv, vec2(.5), -PI * iTime * .05);\n  vec2 uvT3 = getRadialUv(roteC -.5);\n\n\n\n  vec4 hex_uv2 = getHex(uvT2 * 10.);\n\n  float hexf2 = stroke(hex(hex_uv2.xy), .5, .1);\n\n\n  vec4 hex_uv3 = getHex(uvT3 * 10.);\n\n  float hexf3 = stroke(hex(hex_uv3.xy), .5, .2);\n\n\tfloat r = fill(triangleGrid(rote, 0.1, 0.000005,0.001), .1);\n\tfloat g = triangleGrid(uv, 0.1, 0.00000005,0.005);\n\n\n  vec3 color = vec3(uvT.x, uvT.y, g)  ;\n\n  coswarp(color ,3.);\n\n  color = mix(color, 1.-color, hexf2);\n  color = mix(color, 1.-color, hexf3);\n  color = mix(color, 1.-color, box(vUv, vec2(r), .1));\n\n\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 332, 332, 415], [418, 418, 467, 467, 679], [682, 682, 726, 726, 864], [866, 866, 899, 899, 932], [936, 936, 963, 963, 1154], [1157, 1157, 1233, 1266, 1750], [1752, 1752, 1804, 1804, 2038], [2077, 2077, 2098, 2098, 2165], [2166, 2166, 2186, 2186, 2399], [2403, 2403, 2455, 2455, 2648], [2655, 2655, 2712, 2762, 3623]], "test": "error"}
{"id": "flV3Dm", "name": "Truchet Ridges FORK", "author": "soundmasteraj", "description": "Ridgified, Weird looking shader that uses waves, truchet tiles, and iterations to make this 3D-like effect.\n\nIt may not be the fastest code but hey, it still works.", "tags": ["wave", "truchet", "fork", "depth"], "likes": 13, "viewed": 104, "published": "Public", "date": "1637817406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Truchet Hills\" by gls9102. https://shadertoy.com/view/wslcz2\n// 2021-11-25 05:14:08\n\n// v1.0.1\n\n#define PI 3.1415\n#define ITERATIONS 25.\n\nfloat ran21(vec2 uv) {\n    return fract(cos(dot(cos(uv.x*uv.y)-32.2,tan(uv.x/uv.y)-23.5)*1322.24)*432122.62);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 uvb = uv;\n\n    vec3 col = vec3(0);\n    for(float i=1.;i<=ITERATIONS;i++) {\n        float cur = i/ITERATIONS;\n        uv = uvb;\n        uv *= (25.*ITERATIONS/(ITERATIONS+i))-(cur*1.)/(length(uvb/uv));\n        uv.y += iTime*0.6;\n    \n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n    \n        gv.x *= (ran21(id)>.5) ? -1. : 1.;\n        vec2 ruv = gv-sign(gv.x+gv.y+.001)*.5;\n        float tile = smoothstep(.01,-.01,abs(length(ruv)-.5)-.1);\n        float rot = atan(ruv.x,ruv.y)/PI;\n    \n        float mul = mod(id.x+id.y,2.)==1. ? -1. : ITERATIONS/i;\n        float h = smoothstep((ITERATIONS/cur+.1)/gv.x,cur,sin(abs(rot*cur*mul+iTime)*PI)*.25+.75);\n        \n        col.b -= (h*tile*cur)/(h/i);\n        col.b *= .85-((h/i)/(h*tile*cur));\n        col.gb *= .95-((col.r + col.g )/(h*i));\n        \n        col = max(col,h*tile*cur);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flV3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 172, 172, 261], [263, 263, 318, 318, 1275]], "test": "error"}
{"id": "flV3Rw", "name": "raycasting101", "author": "bigjey", "description": "learning raycasting\n\ninspired by https://www.youtube.com/watch?v=TTqLX0OHZzI", "tags": ["learning"], "likes": 2, "viewed": 30, "published": "Public", "date": "1637366080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat MAX_DISTANCE = 200.0;\nfloat gamma = 2.2; \n\n\nvec3 rotateX(vec3 a, float angle)\n{\n    vec3 b = a;\n    b.z = a.z * cos(angle) - a.y * sin(angle);\n    b.y = a.z * sin(angle) + a.y * cos(angle);\n    return b;\n}\n\nvec3 rotateY(vec3 a, float angle)\n{\n    vec3 b = a;\n    b.x = a.x * cos(angle) - a.z * sin(angle);\n    b.z = a.x * sin(angle) + a.z * cos(angle);\n    return b;\n}\n\nvec3 rotateZ(vec3 a, float angle)\n{\n    vec3 b = a;\n    b.x = a.x * cos(angle) - a.y * sin(angle);\n    b.y = a.x * sin(angle) + a.y * cos(angle);\n    return b;\n}\n\n\nvec3 castRay(inout vec3 ro, inout vec3 rd) {\n\n    vec2 minIt = vec2(MAX_DISTANCE);\n    vec3 n = vec3(0);\n    vec3 col;\n    \n    vec3 spherePos = vec3(-3.0, 0, -1.0);\n    vec2 it = sphIntersect(ro, rd, spherePos, 1.0);\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(1.0, 0, 0);\n        n = normalize(ro + rd * it.x - spherePos);\n        minIt = it;\n    }\n    \n    spherePos = vec3(4.0, 3.0, 3.0);\n    it = sphIntersect(ro, rd, spherePos, 3.0);\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(1.0, 0, 1.0);\n        n = normalize(ro + rd * it.x - spherePos);\n        minIt = it;\n    }\n    \n    vec3 boxSize = vec3(1);\n    vec3 boxN;\n    it = boxIntersection(ro, rd, boxSize, boxN);\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(0.1, 0.8, 0.2);\n        n = boxN;\n        minIt = it;\n    }\n    \n    vec4 planeN = vec4(0, -1, 0, -1);\n    it = vec2(plaIntersect(ro, rd, planeN));\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(1.0, 1.0, 1.0);\n        n = planeN.xyz;\n        minIt = it;\n    }\n    \n    if (minIt.x == MAX_DISTANCE) {\n        return vec3(-1.0);\n    }\n    \n    vec3 light = normalize(vec3(sin(iTime), 1, cos(iTime)/5.0));\n    // vec light = normalize(vec3(1, 1, 0));\n    \n    float ambient = 0.1;\n    float diffuse = max(0.0, dot(n, light)) * 0.4 + 0.4;\n    float specular = pow(max(0.0, dot(reflect(rd, n), light)), 64.0);\n        \n    ro += rd * (minIt.x - 0.001);\n    rd = n;\n    \n    return (ambient + diffuse) * col + specular;\n}\n\nvec3 traceRay(vec3 ro, vec3 rd) {\n    vec3 col = castRay(ro, rd);\n\n    if (col.x == -1.0) {\n        return vec3(0.1,0.5,0.8);\n    }\n    \n    vec3 light = normalize(vec3(sin(iTime), 1, cos(iTime)/5.0));\n    \n    ro -= rd * 0.01;\n        \n    vec3 hitColor = castRay(ro, light);    \n    if (hitColor.x != -1.0) {\n        col *= 0.5;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * iResolution.xy/iResolution.y;    \n    \n    vec3 ro = vec3(0, 2, -10);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    ro = rotateZ(ro, 0.25);    \n    ro = rotateY(ro, iTime * 0.4);\n    \n    rd = rotateX(rd, -0.15);\n    rd = rotateY(rd, iTime * 0.4);\n   \n    vec3 col = traceRay(ro, rd);\n            \n    col = pow(col, vec3(1.0/gamma));\n        \n    fragColor = vec4(col, 1.0);    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flV3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 67, 67, 285], [287, 287, 370, 370, 848], [850, 850, 907, 907, 956], [1008, 1008, 1043, 1043, 1169], [1171, 1171, 1206, 1206, 1332], [1334, 1334, 1369, 1369, 1495], [1498, 1498, 1542, 1542, 2987], [2989, 2989, 3022, 3022, 3344], [3346, 3346, 3403, 3403, 3884]], "test": "valid"}
{"id": "flV3zV", "name": "Sine hash, large arguments", "author": "mla", "description": "A typical sine-based hash function, on left doing a 2pi wrap before calling sin, on the right, leaving it up to the sin function. Both Nvidia and Intel show substantially worse hashing in the unwrapped case for inputs > 1000 or so.", "tags": ["hash"], "likes": 5, "viewed": 111, "published": "Public API", "date": "1638021361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(in vec2 uv, bool domod)\n{\n    float PI = 3.14159265;\n    float modval = 2.0*PI;\n    modval = 1.23456789;\n    float seed = dot(uv, vec2(12.9898, 78.233));\n    if (domod) seed = mod(seed,modval);\n    return fract(43758.5453*sin(seed));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(hash(pow(10.0,mod(iTime,20.0))*uv,uv.x < 0.5));    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flV3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 246], [248, 248, 305, 305, 422]], "test": "valid"}
{"id": "flVGDR", "name": "the book of shader 练习 Patterns 图", "author": "suolong", "description": "the book of shader 练习", "tags": ["thebookofshader"], "likes": 2, "viewed": 97, "published": "Public API", "date": "1637677646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv*=12.0;\n    float t = step(1.0,mod(floor(uv.y),2.0))>0.?1.0:-1.0;\n    float t1 = step(1.0,mod(floor(uv.x),2.0))>0.?1.0:-1.0;\n\n    float b = cos(iTime)>0.?1.0:-1.0;\n    float offx = b>0.?b*t*sin(iTime)*2.0:0.;\n    float offy = b>0.?0.:b*t1*sin(iTime)*2.0;\n    uv += vec2(offx,offy);\n    uv = fract(uv);\n    \n    \n    float a = 1.0-step(0.3,distance(uv,vec2(0.5)));\n    vec3 col = vec3(a);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 552]], "test": "valid"}
{"id": "flVGRh", "name": "Ball of lights", "author": "TotallyReal", "description": "An attempt to visualize the rays of light escaping from some carved spheres.", "tags": ["raysoflight"], "likes": 4, "viewed": 75, "published": "Public", "date": "1637869844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Increase for better quality of light.\nconst int DUST = 128;\n\n// The color of the rays of light. \nconst vec3 LIGHT_COLOR = vec3(1.6, 1.6, 1.);\n\n// ----------------------------- spheres -----------------------------\n\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\n\nstruct Sphere {\n\tfloat r;\t\n    vec3 color;\n};\n\nconst int N = 3;\n\nconst Sphere spheres[N] = Sphere[N](\n    Sphere(30.,    vec3(0.3, 0.0, 0.0)), \n    Sphere(20.,    vec3(0.0, 0.3, 0.1)) ,\n    Sphere(10.,    vec3(0.05, 0.1, 0.25))\n);\n\nconst float minValue = 0.5; // The lower this is, the fuller are the spheres (the components are larger).\nconst float details = 2.5;  // The higher this is, the more components each sphere will have. \n\n// Just a very simple noise function, used to create the components on each sphere.\nfloat snoise3d(vec3 v) {\n    float t = (v.x+2.)*v.y+v.z*v.z*1.4+((cos(v.x*0.42-v.z*1.3)+sin(v.y*0.5-5.*v.x))*cos(v.z+v.y*2.));\n    return t - floor(t);\n}\n\n\n\n\n// ----------------------------- ray hit -----------------------------\n\nconst float MAX_DIST = 1000000000.;\n\nstruct HitInfo {\n    vec3 hitPoint;\n    vec3 normal;\n    float dist;\n    \n    vec3 color;\n};\n\nconst HitInfo NO_HIT = HitInfo(vec3(0.), vec3(0.), MAX_DIST, BLACK);\n\n\nmat3 rotateZ(float angle){\n    return mat3(\n        cos(angle),  sin(angle), 0.,\n        -sin(angle), cos(angle), 0.,\n        0., 0., 1.);\n}\n\n/**\n * Given the origin and direction of the ray, check if it hits the given sphere.\n */\nHitInfo sphereHit(Sphere sphere, float angle, vec3 origin, vec3 direction){\n    float dist = MAX_DIST;\n    // |origin + t*direction|^2 = r^2\n    // |origin|^2 +2t<direction,origin> + t^2 |direction|^2 = r^2\n    vec3 v = origin;                     \n    float a = dot(direction, direction);         \n    float b = 2.*dot(direction,v);               \n    float c = dot(v,v)-sphere.r*sphere.r;                      \n    // solve a*t^2 + b*t + c = 0\n    float disc = b*b-4.*a*c;\n    if (disc<0.)\n        return NO_HIT; // no intersection with the sphere\n        \n    dist = (-b - sqrt(disc))/(2.*a);\n    vec3 hitPoint = (origin + dist*direction);\n    \n    // Use the noise function to decide whether this part of the sphere exists.\n    float x = snoise3d(details*rotateZ(angle)*hitPoint/100.);\n    if (x>minValue)    \n        return HitInfo(hitPoint, normalize(hitPoint), dist, sphere.color);\n        \n    // Didn't hit the \"front\" part of the sphere. Check the back part.\n    dist = (-b + sqrt(disc))/(2.*a);\n    hitPoint = (origin + dist*direction);\n    x = snoise3d(details*rotateZ(angle)*hitPoint/100.);\n    if (x>minValue)  \n        // note that the back part should have more light that the front part.\n        return HitInfo(hitPoint, normalize(hitPoint), dist, sphere.color*1.3); \n        \n    return NO_HIT; // no intersection with the sphere       \n}\n\n\n/**\n * Given the origin and direction of the ray, check if it hits one of the spheres.\n */\nHitInfo sceneHit(vec3 origin, vec3 direction){\n\n    HitInfo info = NO_HIT;\n    float dist = MAX_DIST;\n    for (int i=0; i<N; i++){\n        HitInfo sphereInfo = sphereHit(spheres[i], float(i+1)*iTime/3., origin, direction);\n        if (sphereInfo.dist<dist){\n            info = sphereInfo;\n            dist = sphereInfo.dist;\n        }\n    }\n    \n    return info;\n}\n\n\n\n// ----------------------------- ray color -----------------------------\n\n// Check if there is a line of sight from the given position to the origin.\nbool lineSightToOrigin(vec3 position){\n    HitInfo lightInfo = sceneHit(position, -normalize(position));\n    float len = length(position);\n    return (lightInfo.dist>len);\n}\n\nvec3 rayColor(vec3 origin, vec3 direction){\n\n    // Check if the ray hits one of the spheres.\n    HitInfo info = sceneHit(origin, direction);\n    vec3 color = info.color;\n    \n    // Add the light as if it hits \"dust\" in the way.\n    float dist = min(info.dist, 500.);\n    for (int i=0; i<DUST; i++){\n        vec3 location = origin+dist*(float(1+i)/float(1+DUST))*direction;\n        if (lineSightToOrigin(location))\n            color += LIGHT_COLOR/float(DUST);\n    }\n    return color;\n    \n}\n\n\n// ----------------------------- main -----------------------------\n\nvoid updateCamera(out vec3 origin, out vec3 forward, out vec3 right, out vec3 up){\n    //origin = 100. *vec3(cos(iTime),sin(iTime),0.);\n    origin = 100. *vec3(1.,0.,0.);\n    \n    forward = -origin/100.;\n    right = vec3(forward.y, -forward.x , 0.);\n    up = vec3(0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 origin, forward, right, up;\n    updateCamera(origin, forward, right, up);\n    \n    \n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    vec3 direction = normalize(forward + uv.x*right + uv.y*up);\n    \n    vec3 color = rayColor(origin, direction);\n\n    // Output to screen\n    fragColor = vec4(color ,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 795, 819, 819, 948], [1227, 1227, 1253, 1253, 1367], [1369, 1458, 1533, 1533, 2814], [2817, 2908, 2954, 2954, 3272], [3350, 3426, 3464, 3464, 3599], [4165, 4165, 4247, 4300, 4443], [4445, 4445, 4502, 4502, 4840]], "test": "valid"}
{"id": "flVGWD", "name": "Irwin-Hall noise 2D", "author": "scholarius", "description": "Approximate gaussian noise via the sum of N uniform random variables (central limit etc). Generates the Irwin-Hall distribution with zero mean, unit variance and can reach to +/- sqrt(3*N) sigma of deviation. Usually N = 4 is sufficient for good quality.", "tags": ["noise", "gaussian", "hash", "irwinhall"], "likes": 1, "viewed": 36, "published": "Public", "date": "1637724471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 irwin_hall_noise_2D( uvec2 coord, uint seed, int N )\n{\n    uvec2 rand = uvec2( 131071u * coord.x + 31u * coord.y, 127u * coord.x + 8191u * coord.y );\n    rand = rand * 524187u + seed * 7u;  \n    rand = rand * 2147483647u + seed * 3u;                 \n    vec2 result = vec2(0.);\n    for( int i = 0; i < N; ++i )\n        { rand = rand * rand | 1u; result.xy += vec2( rand ); }\n    float n = float(N);\n    float s = sqrt( 12. / n );\n    return s * ( result * 2.32830644e-10 - n / 2. );\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n{\n    const int N = 4;\n    const float buckets = 15.;\n    const float scale = inversesqrt( float( 12 * N ) );\n    vec2 noise = .5 + scale * irwin_hall_noise_2D( uvec2( fcoord ), uint( iFrame ), N );\n    fcolor.xyz = step( +noise, +floor( fcoord / iResolution.xy * buckets + 1. ) / buckets ) *\n                 step( -noise, -floor( fcoord / iResolution.xy * buckets + 0. ) / buckets ) * \n                 mat3x2( .9, .01, .1, .1, .01, .9 );\n    fcolor.xyz = pow( fcolor.xyz + .002, vec3( .4545 ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 60, 60, 491], [493, 493, 544, 544, 1043]], "test": "valid"}
{"id": "flVGzc", "name": "Steel mesh", "author": "yasuo", "description": "Steel mesh", "tags": ["material"], "likes": 14, "viewed": 129, "published": "Public API", "date": "1638104962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 32\n#define MAX_DIST 6.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define MATERIAL_STEAL 0\n#define MATERIAL_WALL 1\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// thx:iq https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\n// vertical version\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n// thx:iq https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// thx:iq https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat dFakeSpring(vec3 p){\n    for(int i = 0; i<4; i++){\n        p.z = abs(p.z);\n        p.z-=0.025;\n    }\n\n    float d = sdTorus(p,vec2(0.05,0.023));\n    return d;\n}\n\nfloat steelMesh(vec3 p){\n    float d = dFakeSpring(p);\n    \n    p.yz = abs(p.yz);\n    p.z-=0.2;\n    p.y-=0.32;\n    p.y+=0.22;\n    p.yz*=Rot(radians(-35.0));\n    float d2 = sdSimpleCylinder(p,0.02,0.5);\n    d = opSmoothUnion(d,d2,0.05);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    p.y+=iTime*0.1;\n    p += noise3d(p*300.0)*0.002;   \n    vec3 prevP = p;\n    \n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    p.xz*=Rot(radians(90.0));\n    \n    float d = dFakeSpring(p);\n    d = steelMesh(p);\n    p = prevP;\n    \n    p.x+=0.6;\n    p.y+= 0.5;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    \n    p.xz*=Rot(radians(90.0));\n    float d2 = steelMesh(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    float wallD = p.z+0.01;\n    return combine(vec2(d,MATERIAL_STEAL),vec2(wallD,MATERIAL_WALL));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 iconBg(vec2 p, vec3 col){\n    float d = sdEquilateralTriangle(p)-0.2;\n    col = mix(col,vec3(1.0,1.0,0.0),S(d,0.0));\n    d = abs(sdEquilateralTriangle(p)-0.2)-0.05;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 hazrdIcon(vec2 p, vec3 col){\n    p*=5.0;\n    vec2 prevP = p;\n    col = iconBg(p,col);\n    \n    p.y+=0.2;\n    p.x = abs(p.x);\n    p.x-=0.3;\n    p*=Rot(radians(30.0));\n    float d = length(p)-0.4;\n    d = max(-(length(p-vec2(0.1,0.0))-0.31),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.4;\n    d = length(p)-0.4;\n    d = max(-(length(p-vec2(0.0,0.1))-0.31),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.05;\n    d = abs(length(p)-0.35)-0.05;\n    col = mix(col,vec3(0.0),S(d,0.0));\n     \n    return col;\n}\n\nvec3 warningIcon(vec2 p, vec3 col){\n    p*=5.0;\n    vec2 prevP = p;\n    col = iconBg(p,col);\n    \n    float d = sdUnevenCapsule(p,0.1,0.2,0.7);\n    d = min(length(p-vec2(0.0,-0.35))-0.15,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawHazardIcons(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y+=0.5;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    col = warningIcon(p,col);\n    \n    p = prevP;\n    p.x+=0.6;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    col = hazrdIcon(p,col);\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 np = p;\n    np.y+=iTime*0.1;\n    float nn = noise3d(np*80.0)*0.12;\n    if(mat == MATERIAL_STEAL){\n        col = diffuseMaterial(n,rd,p,vec3(0.3)+nn+nn);\n    }\n    if(mat == MATERIAL_WALL){\n        col = diffuseMaterial(n,rd,p,(vec3(0.3,0.2,0.1)+nn+nn)+drawHazardIcons(np.xy,col)*0.2);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n      \n    float handShakeY = noise3d(vec3(iTime*1.0,iTime*1.1,iTime*1.2))*0.05;\n    float handShakeX = noise3d(vec3(iTime*1.1,iTime*1.2,iTime*1.1))*0.2;\n    \n    vec3 ro = vec3(handShakeX, handShakeY, 2.0);\n    ro.xz *= Rot(radians(sin(iTime*0.5)*5.0));\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = vec3(0.3);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.8545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 401, 401, 443], [445, 557, 582, 582, 927], [929, 1011, 1063, 1063, 1163], [1165, 1165, 1214, 1214, 1287], [1289, 1309, 1342, 1342, 1411], [1413, 1499, 1541, 1541, 1752], [1754, 1840, 1902, 1902, 2141], [2143, 2143, 2169, 2169, 2309], [2311, 2311, 2335, 2335, 2562], [2564, 2564, 2586, 2586, 3118], [3120, 3120, 3178, 3178, 3449], [3451, 3451, 3475, 3475, 3676], [3678, 3678, 3720, 3720, 3915], [3917, 3958, 4007, 4007, 4298], [4300, 4300, 4357, 4357, 4976], [4978, 4978, 5008, 5008, 5204], [5206, 5206, 5239, 5239, 5768], [5770, 5770, 5805, 5805, 6022], [6024, 6024, 6063, 6063, 6324], [6326, 6326, 6385, 6385, 6703], [6705, 6705, 6762, 6762, 7508]], "test": "valid"}
{"id": "fly3WV", "name": "ParticleWave I", "author": "ivatronx", "description": "Particle Wave", "tags": ["trigonometry"], "likes": 1, "viewed": 32, "published": "Public", "date": "1638307967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932;\n\nfloat atanM(float y, float x){\n    if(x >= 0.){\n        return atan(y/x)/pi/2.+.75;\n    }\n    return (pi+2.*atan(y/x))/4./pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    int amount = 2;\n    float width = 2.5;\n    float speed = 0.05;\n    float speed2 = -0.075;\n    float speed3 = 0.10;\n    vec3 color1 = vec3(1.0, 1.5, 2.0);\n    vec3 color2 = vec3(-0.1, 0.0, 0.1);\n    vec3 color12 = vec3(1.0, 2.5, 2.0);\n    vec3 color22 = vec3(-0.11, 0.11, 0.11);\n    vec3 color13 = vec3(2.0, 2.5, 2.0);\n    vec3 color23 = vec3(-0.01, 0.01, 0.01);\n    \n\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col;\n    vec3 col2;\n    vec3 col3;\n    float d = length(uv);\n    float d2 = length(uv)/50.;\n    float d3 = length(uv)/75.0;\n    d -= iTime*speed;\n    d2 -= iTime*speed2;\n    d3 -= iTime*speed3;\n\n    float mascara = smoothstep(R.y/2.+width*4., R.y/2.-width*4., tan(length(uv.x*30.) / length(uv.y/-30.)));\n    float mascara2 = smoothstep(R.y/2.+width*4., R.y/2.-width*4., (length(uv.x/8.) * length(uv.y/-8.)));\n    float mascara3 = smoothstep(R.y/2.+width*4., R.y/2.-width*4., (length(uv.x) + length(uv.y)));\n    \n    col = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d*width)*float(amount))+1.)/2.;\n    col2 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d2*width)*float(amount))+1.)/2.;\n    col3 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d3*width)*float(amount))+1.)/2.;\n    col = color1+col*(color2-color1);\n    col *= mascara2;\n    col2 = color23+col3*(color13-color23);\n    col2 *= mascara;\n    col3 = color22+col3*(color12-color22);\n    col3 *= mascara3;\n    fragColor = vec4(col-col2-col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fly3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 165], [167, 167, 224, 224, 1641]], "test": "valid"}
{"id": "flyGz1", "name": "Font experiment 007", "author": "iY0Yi", "description": "Other experiments list:\n[url]https://www.shadertoy.com/playlist/tctBWH[/url]", "tags": ["font", "util"], "likes": 6, "viewed": 57, "published": "Public", "date": "1637123168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// lpnorm by gaz\n// https://www.shadertoy.com/view/slG3Rz\nfloat lpnorm(vec2 p, float n){vec2 t=pow(abs(p),vec2(n));return pow(t.x+t.y,1./n);}\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\n// iq's segment function\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    //p.x += sin(p.y*50.)*.01;\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return lpnorm( pa - ba*h , (1.-abs(sin(iTime*.5)))*50.+2.)-.1*sabs(p.x, .5)-.1*sabs(p.y, .5);\n}\n\n\nfloat fontSize = 1.;\nfloat fontWeight = .2;\n\n// Modify skeleton\n#define SEGX .4\n#define SEGY .6\n#define SEGCX 0.\n#define SEGCY 0.025\n#define SEGYHP +.45\n#define SEGYHN -.35\n\n// Short hands\n#define START_SEG float d = 1e4\n#define END_SEG return d\n#define DRAW_SEG(v1, v2) d=min(sdSegment(p, v1, v2)-fontWeight,d)\n\n// Outer Box (Start from Top/Left. Clockwise. SEG0-11)\n#define SEG0  DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX, +SEGY))\n#define SEG1  DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX, +SEGY))\n#define SEG2  DRAW_SEG(vec2( +SEGX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG3  DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( +SEGX, SEGCY))\n#define SEG4  DRAW_SEG(vec2( +SEGX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG5  DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG6  DRAW_SEG(vec2( +SEGX, -SEGY), vec2( SEGCX, -SEGY))\n#define SEG7  DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX, -SEGY))\n#define SEG8  DRAW_SEG(vec2( -SEGX, -SEGY), vec2( -SEGX,SEGYHN))\n#define SEG9  DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( -SEGX, SEGCY))\n#define SEG10 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( -SEGX,SEGYHP))\n#define SEG11 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( -SEGX, +SEGY))\n// Top Rhombus (Start from Top/Left. Clockwise. SEG12-15)\n#define SEG12 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( SEGCX, +SEGY))\n#define SEG13 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG14 DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( SEGCX, SEGCY))\n#define SEG15 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( -SEGX,SEGYHP))\n// Bottom Rhombus (Start from Top/Left. Clockwise. SEG16-19)\n#define SEG16 DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( SEGCX, SEGCY))\n#define SEG17 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG18 DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( SEGCX, -SEGY))\n#define SEG19 DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX,SEGYHN))\n// Center Vertical line (Top>Bottom. SEG20,21)\n#define SEG20 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( SEGCX, SEGCY))\n#define SEG21 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( SEGCX, -SEGY))\n// Center Horizont line (Left>Right. SEG22,23)\n#define SEG22 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX, SEGCY))\n#define SEG23 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG24-27)\n#define SEG24 DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX,SEGYHP))\n#define SEG25 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, +SEGY))\n#define SEG26 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHP))\n#define SEG27 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG28-31)\n#define SEG28 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHN))\n#define SEG29 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, SEGCY))\n#define SEG30 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG31 DRAW_SEG(vec2( -SEGX, -SEGY), vec2( SEGCX,SEGYHN))\n\n\n#define SKIP_DRAW d=d\n#define SEG0x  SKIP_DRAW\n#define SEG1x  SKIP_DRAW\n#define SEG2x  SKIP_DRAW\n#define SEG3x  SKIP_DRAW\n#define SEG4x  SKIP_DRAW\n#define SEG5x  SKIP_DRAW\n#define SEG6x  SKIP_DRAW\n#define SEG7x  SKIP_DRAW\n#define SEG8x  SKIP_DRAW\n#define SEG9x  SKIP_DRAW\n#define SEG10x SKIP_DRAW\n#define SEG11x SKIP_DRAW\n#define SEG12x SKIP_DRAW\n#define SEG13x SKIP_DRAW\n#define SEG14x SKIP_DRAW\n#define SEG15x SKIP_DRAW\n#define SEG16x SKIP_DRAW\n#define SEG17x SKIP_DRAW\n#define SEG18x SKIP_DRAW\n#define SEG19x SKIP_DRAW\n#define SEG20x SKIP_DRAW\n#define SEG21x SKIP_DRAW\n#define SEG22x SKIP_DRAW\n#define SEG23x SKIP_DRAW\n#define SEG24x SKIP_DRAW\n#define SEG25x SKIP_DRAW\n#define SEG26x SKIP_DRAW\n#define SEG27x SKIP_DRAW\n#define SEG28x SKIP_DRAW\n#define SEG29x SKIP_DRAW\n#define SEG30x SKIP_DRAW\n#define SEG31x SKIP_DRAW\n\n#define SEG0o  SEG0\n#define SEG1o  SEG1\n#define SEG2o  SEG2\n#define SEG3o  SEG3\n#define SEG4o  SEG4\n#define SEG5o  SEG5\n#define SEG6o  SEG6\n#define SEG7o  SEG7\n#define SEG8o  SEG8\n#define SEG9o  SEG9\n#define SEG10o SEG10\n#define SEG11o SEG11\n#define SEG12o SEG12\n#define SEG13o SEG13\n#define SEG14o SEG14\n#define SEG15o SEG15\n#define SEG16o SEG16\n#define SEG17o SEG17\n#define SEG18o SEG18\n#define SEG19o SEG19\n#define SEG20o SEG20\n#define SEG21o SEG21\n#define SEG22o SEG22\n#define SEG23o SEG23\n#define SEG24o SEG24\n#define SEG25o SEG25\n#define SEG26o SEG26\n#define SEG27o SEG27\n#define SEG28o SEG28\n#define SEG29o SEG29\n#define SEG30o SEG30\n#define SEG31o SEG31\n\nfloat sdAllSeg(vec2 p) {\n    // Start designing with copy & paste below lines.\n    // -------------------------------- ✂ -----------------------------------\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12o, SEG13o, SEG14o, SEG15o;\n    /*BottomRhombus*/   SEG16o, SEG17o, SEG18o, SEG19o;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n    // -------------------------------- ✂ -----------------------------------\n}\n\nfloat sdNum0(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum1(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1x,  SEG2x,  SEG3x, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum2(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8o, SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum3(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23o;\n    END_SEG;\n}\nfloat sdNum4(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0x,  SEG1x,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum5(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x, SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum6(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1x,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum7(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum8(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum9(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\n\nfloat sdNumFont(vec2 p, float s, float fi) {\n    p /= s;\n    int i = int(mod(floor(fi), 10.)); // 0-9    \n    switch(i){\n        case 0:\n            return sdNum0(p);\n        case 1:\n            return sdNum1(p);\n        case 2:\n            return sdNum2(p);\n        case 3:\n            return sdNum3(p);\n        case 4:\n            return sdNum4(p);\n        case 5:\n            return sdNum5(p);\n        case 6:\n            return sdNum6(p);\n        case 7:\n            return sdNum7(p);\n        case 8:\n            return sdNum8(p);\n        case 9:\n            return sdNum9(p);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord/iResolution.xy;\n    vec2 grid = vec2(.2,.5);\n    vec2 ip = floor(p/grid);\n    p = mod(p, grid)/grid*2.-1.;\n    p.y*=iResolution.x/iResolution.y;\n    p.y*=.8; // ???\n    \n\tfontWeight = .17;//-clamp(sin(iTime*1.5)*2.,0.,1.)*.19;\n    fontSize = .7;\n    float num = ip.x+(1.-ip.y)*5.;// + floor(exp(clamp(sin(iTime*5.),0.,1.))*10.) + floor(sin(iTime*.5)*10.);\n    float d = sdNumFont(p, fontSize, num);\n    d = 1.-smoothstep(.0, 1./iResolution.x*19.,d);\n    \n    vec3 col = mix(vec3(0.102,0.102,0.102), vec3(.8, .77, .7), d);\n \n    // Draw Skeleton\n    col = max(col, vec3(.8, .77, .7)*.3*smoothstep(1./iResolution.x*19., 0., abs(sdAllSeg(p/fontSize)+fontWeight)-.002));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 88, 88, 141], [143, 143, 172, 172, 242], [244, 269, 320, 351, 536], [4806, 4806, 4830, 4964, 5410], [5412, 5412, 5434, 5434, 5800], [5801, 5801, 5823, 5823, 6189], [6190, 6190, 6212, 6212, 6577], [6578, 6578, 6600, 6600, 6966], [6967, 6967, 6989, 6989, 7355], [7356, 7356, 7378, 7378, 7743], [7744, 7744, 7766, 7766, 8132], [8133, 8133, 8155, 8155, 8521], [8522, 8522, 8544, 8544, 8910], [8911, 8911, 8933, 8933, 9299], [9301, 9301, 9345, 9345, 9889], [9891, 9891, 9948, 9948, 10670]], "test": "error"}
{"id": "flyGzD", "name": "Helicopter Squadron", "author": "dr2", "description": "Out on a mission...", "tags": ["flight"], "likes": 16, "viewed": 220, "published": "Public API", "date": "1637222977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Helicopter Squadron\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 qHit, sunDir, flDisp;\nvec2 gId;\nfloat tCur, dstFar, hgSize, grLim, hVel, heliSz;\nint idObj;\nconst int idHeli = 1, idRotorM = 2, idRotorT = 3, idSkd = 4, idGun = 5;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{  // (from \"Piz Gloria With Helicopter\")\n  vec3 q;\n  vec2 csRotor;\n  float dMin, d, r, s;\n  csRotor = sin (10.3 * pi * tCur + vec2 (0.5 * pi, 0.));\n  dMin = dstFar / heliSz;\n  p -= flDisp;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  p = flMat * p / heliSz;\n  q = p;\n  r = 1.;\n  if (q.z < -0.1) {\n    s = (q.z + 0.1) * (q.z + 0.1);\n    r *= 1. - 0.1 * s;\n    q.y -= 0.05 * s;\n  } else if (q.z > 0.1) {\n    s = (q.z - 0.1) * (q.z - 0.1);\n    r *= 1. - 0.03 * s;\n  }\n  q.x *= 0.8;\n  d = PrCapsDf (q, max (r, 0.), 2.);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (1.1, -4.2), -0.05 * pi);\n  r = 0.2 * (1. + 0.25 * q.z);\n  q.y *= 0.7;\n  d = min (d, PrCapsDf (q, r, 1.5));\n  q = p;\n  q.yz -= vec2 (1.7, -0.2);\n  d = min (d, PrCylDf (q.xzy, 0.4, 0.4));\n  q = p;\n  q.yz -= vec2 (0.4, -1.);\n  r = 1.1;\n  if (q.z < 0.) {\n    s = q.z * q.z;\n    r *= 1. - 0.2 * s;\n    q.y -= 0.1 * s;\n  }\n  q.y *= 0.8;\n  d = SmoothMin (d, PrCapsDf (q, max (r, 0.), 1.5), 0.03);\n  q = p;\n  q.yz -= vec2 (1.4, -6.15);\n  d = min (d, max (PrRoundCylDf (q.yzx, 0.5, 0.05, 0.02), 0.35 - length (q.yz)));\n  q = p;\n  DMINQ (idHeli);\n  q = p;\n  q.yz = Rot2Cs (q.yz - vec2 (1.4, -6.15), csRotor);\n  d = PrRoundBoxDf (q, vec3 (0.01, 0.32, 0.04), 0.02);\n  DMINQ (idRotorT);\n  q = p;\n  q.yz -= vec2 (2., -0.2);\n  d = PrCylDf (q.xzy, 0.12, 0.5);\n  q.y -= 0.4;\n  q.xz = Rot2Cs (q.xz, csRotor);\n  d = min (d, PrRoundBoxDf (q, vec3 (4.5, 0.02, 0.08), 0.03));\n  DMINQ (idRotorM);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.9, -1.4);\n  d = PrRoundBoxDf (q, vec3 (0.1, 0.01, 1.4), 0.04);\n  q.xy = Rot2D (q.xy, -0.1 * pi);\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.4, 0.7);\n  d = min (d, PrCylDf (q.xzy, 0.06, 0.4));\n  DMINQ (idSkd);\n  q = p;\n  q.yz -= vec2 (-0.8, 2.1);\n  d = PrCapsDf (q.xzy, 0.2, 0.2);\n  q.yz -= vec2 (-0.2, 0.3);\n  d = min (d, PrCylDf (q, 0.1, 0.3));\n  DMINQ (idGun);\n  return 0.7 * heliSz * dMin;\n}\n\nvoid ObjState ()\n{\n  vec3 vd, cb, sb;\n  vec2 h;\n  float tc, t, tt, flPit, flYaw, flRol;\n  tc = tCur + 0.7 * (gId.x + gId.y);\n  t = cos (2. * pi * mod (0.6 * tc, 1.));\n  tt = (mod (0.3 * tc, 6.) - 2.) / 4.;\n  h = Hashv2v2 (vec2 (17.1, 19.1) * gId + 1.1) - 0.5;\n  flDisp.xz = hgSize * (gId + 0.5 + 0.2 * h);\n  flDisp.y = 2. + ((tt > 0.) ? 0.2 * (1. - t) + (7. + dot (h, vec2 (0.5))) *\n     SmoothBump (0.2, 0.8, 0.2, tt) : 0.);\n  flPit = 0.03 * pi + 0.02 * pi * sin (0.4 * pi * (h.x + h.y) * tCur);\n  flYaw = 0.03 * pi * sin (0.3 * pi * h.y * tCur);\n  flRol = 0.02 * pi * sin (0.2 * pi * h.x * tCur);\n  cb = cos (vec3 (flPit, flYaw, flRol));\n  sb = sin (vec3 (flPit, flYaw, flRol));\n  flMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{ // (from \"Flying Bathtubs\")\n  vec3 p, rdi;\n  vec2 gIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  gIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p.xz / hgSize);\n    if (gId != gIdP) {\n      ObjState ();\n      gIdP = gId;\n    }\n    d = (Maxv2 (abs (gId)) <= grLim) ? ObjDf (p) : dstFar;\n    s = (hgSize * (gId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (Minv2 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = floor (p.xz / hgSize);\n    if (gId != gIdP) {\n      ObjState ();\n      gIdP = gId;\n    }\n    if (Maxv2 (abs (gId)) <= grLim) {\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.3 * hgSize;\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.01 * (ro.xz + tCur * vec2 (0.5, 2.) + ((100. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{  // (from \"Wind Farm\")\n  return Fbm2 (0.4 * p) - 0.45;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  float h;\n  h = GrndHt (p);\n  if (h > 0.) h = 0.3 * h + 0.3 * Fbm2 (2. * p);\n  return h;\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.001, 0.);\n  return normalize (vec3 (GrndHtN (p) - vec2 (GrndHtN (p + e.xy), GrndHtN (p + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, row;\n  vec2 s;\n  float dstObj, dstGrnd, sh;\n  bool wtRefl;\n  heliSz = 0.5;\n  wtRefl = false;\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstGrnd < min (dstObj, dstFar)) {\n    row = ro + dstGrnd * rd;\n    s = row.xz + (hVel / sqrt(2.)) * tCur;\n    if (GrndHt (s) < 0.) {\n      ro = row;\n      row.xz = s;\n      vn = VaryNf (2. * row, vec3 (0., 1., 0.), 0.05 * (1. - smoothstep (0.1, 0.4, dstGrnd / dstFar)));\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n      dstGrnd = dstFar;\n      wtRefl = true;\n    }\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idHeli) {\n        col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.75, 0.85, 0.9, 0.2), smoothstep (0., 0.02,\n           abs (qHit.y) - 0.04));\n        if (length (vec2 (qHit.x, qHit.y / 0.8)) > 1.24 && qHit.y > 0.55 && qHit.z > 0.4 &&\n           abs (abs (qHit.x) - 0.3) > 0.05) col4 = vec4 (0., 0.5, 0.5, -1.);\n        if (PrRoundBox2Df (qHit.zy - vec2 (-1., 0.8), vec2 (1.2, 0.6), 0.01) < 0.) col4 =\n           mix (col4, vec4 (1., 0., 0., 0.2), ShowIntPZ ((qHit.zy - vec2 (-1.2 + 0.4 * sign (qHit.x), 0.8)),\n           vec2 (sign (qHit.x), 0.5), 3., 1. + grLim - gId.x + (2. * grLim + 1.) * (grLim - gId.y)));\n      } else if (idObj == idRotorM) {\n        col4 = (length (qHit.xz) < 4.2) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n      } else if (idObj == idRotorT) {\n        col4 = (length (qHit.yz) > 0.06) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n      } else if (idObj == idSkd) {\n        col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n      } else if (idObj == idGun) {\n        col4 = vec4 (0.8, 0.8, 0.8, 0.2);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      gId = floor (ro.xz / hgSize);\n      s = ro.xz + (hVel / sqrt(2.)) * tCur;\n      col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.),\n         smoothstep (0.2, 0.8, Fbm2 (4. * s)));\n      col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.3, 0.6, dstGrnd / dstFar));\n      vn = GrndNf (s);\n    }\n    if (col4.a >= 0.) {\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         step (0.95, sh) * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n      col = mix (col, SkyCol (ro, rd), (wtRefl ? 0.2 + 0.8 * smoothstep (0.4, 0.6, dstObj / dstFar) :\n         smoothstep (0.8, 0.9, min (dstGrnd, dstObj) / dstFar)));\n    } else col = mix (col4.rgb, SkyCol (ro, reflect (rd, vn)), 0.8);\n  } else col = SkyCol (ro, rd);\n  col *= vec3 (1., 0.85, 0.85) * (wtRefl ? 0.85 : 1.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  hgSize = 8.;\n  grLim = 4.;\n  hVel = 2.;\n  az = pi;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az = pi + 2. * pi * (0.5 + abs (mod (0.01 * tCur, 2.) - 1.));\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 2., -4. - 1.4 * (grLim + 1.) * hgSize * (0.9 - 0.1 * cos (4. * az)));\n  ro.xz = Rot2D (ro.xz, - az) + 0.5 * hgSize;\n  zmFac = 2.5;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (1., 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGzD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1150, 1150, 1172, 1212, 3025], [3027, 3027, 3045, 3045, 3901], [3903, 3903, 3936, 3964, 4602], [4604, 4604, 4625, 4625, 4880], [4882, 4882, 4919, 4919, 5408], [5410, 5410, 5442, 5442, 5971], [5973, 5973, 5996, 6019, 6053], [6055, 6055, 6079, 6079, 6171], [6173, 6173, 6195, 6195, 6329], [6331, 6331, 6366, 6366, 9184], [9228, 9228, 9284, 9284, 10501], [10503, 10503, 10549, 10549, 10596], [10598, 10598, 10645, 10645, 10692], [10694, 10694, 10736, 10736, 10787], [10789, 10789, 10832, 10832, 10896], [10898, 10898, 10955, 10955, 11031], [11033, 11033, 11055, 11055, 11082], [11084, 11084, 11106, 11106, 11133], [11135, 11135, 11180, 11180, 11272], [11274, 11274, 11319, 11319, 11357], [11359, 11359, 11416, 11416, 11499], [11501, 11501, 11537, 11537, 11743], [11745, 11745, 11775, 11775, 11888], [11890, 11890, 11921, 11921, 11985], [11987, 11987, 12010, 12010, 12114], [12187, 12187, 12219, 12219, 12767], [12769, 12769, 12831, 12831, 13198], [13232, 13232, 13256, 13256, 13368], [13370, 13370, 13395, 13395, 13581], [13583, 13583, 13604, 13604, 13759], [13761, 13761, 13790, 13790, 14002], [14004, 14004, 14043, 14043, 14295]], "test": "error"}
{"id": "flyGzt", "name": "Wavy Blue Thingy Thing", "author": "Dayshadow_", "description": "Looks interesting I guess\n", "tags": ["wocky"], "likes": 0, "viewed": 37, "published": "Public", "date": "1638133193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvd = rotateUV(uv, 1.0) + (sin(uv.x*17.0 + iTime/1.0) / (8.0 + (uv.x * iTime)/80.0));\n\n    \n    float waveStrength = abs(cos(uvd.x * 20.0 + iTime)) + fract(sin((uvd.x + uv.x) * 10.0));\n    \n    float highlight = 1.0 - smoothstep(0.0, 0.5, waveStrength);\n    \n    vec3 highlightCol = vec3(uvd, uv.x);\n\n    vec3 col = vec3(0.011, 0.098, 0.866) * waveStrength + highlightCol * highlight;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 237], [240, 240, 297, 347, 844]], "test": "valid"}
{"id": "ft33DS", "name": "Metaball motion test - lpg2709", "author": "lpg2709", "description": "Metaball test", "tags": ["test", "metaball", "study"], "likes": 0, "viewed": 21, "published": "Public", "date": "1636588283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Ball1 = vec2(0.5);\nvec2 Ball2 = vec2(0.5);\nvec2 Ball3 = vec2(0.5);\nvec2 Ball4 = vec2(0.5);\nfloat radio = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Change position over time\n    Ball1 = 0.5 + 0.1*cos(iTime+uv.xy+vec2(2));\n    Ball2 = 0.5 + 0.2*cos(iTime+uv.xy+vec2(2));\n    Ball3 = 0.5 + 0.3*cos(iTime+uv.xy+vec2(2));\n    Ball4 = 0.5 + 0.4*cos(iTime+uv.xy+vec2(2));\n\n\n    // Calculate distances of the pixel to the ball position\n    float d1 = distance(uv, Ball1);\n    float d2 = distance(uv, Ball2);\n    float d3 = distance(uv, Ball3);\n    float d4 = distance(uv, Ball4);\n    \n    // Sum all distances\n    vec2 sum = vec2(radio/d1 + radio/d2 + radio/d3 + radio/d4);\n    \n    vec2 inf = vec2(0.3);\n    // Get mouse Position\n    // inf = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    vec3 col = vec3(sum.x*inf.x, sum.y*inf.y, inf.x*inf.y);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 224, 1045]], "test": "valid"}
{"id": "ft33Rf", "name": "Grid sampling topology errors", "author": "kastorp", "description": "Trying to visualize when sampling a function, and then interpolating it, produces wrong topology\n", "tags": ["interpolation"], "likes": 3, "viewed": 62, "published": "Public", "date": "1636409749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quick demonstration on how sampling function values on a grid introduces topology errors \n// The example is with bilinear interpolation, but the same would happen with marching squares ( or marching cubes in 3d)\n//  - red: a generic iso function\n//  - blue (left side): bilinear interpolation \n//  - green (right side): bilinear interpolation (keeping just topology with 2^4=16 cases)\n// The topology errors seem to occur when:\n//   - the function crosses a square side more than once\n//   - the square contains an island or an hole (ie: function not crossing any side)\n//   - the square contains a manifold ( 4 intersections, one at each side);in this case errore probability is 50%\n\n#define R iResolution.xy\nfloat S(vec2 uv){return (texture(iChannel0,uv/6.).x);}\nfloat T(vec2 uv){return floor(texture(iChannel0,uv/6.).x+.5);}\n#define SAMPLE(fn) vec4( fn(floor(uv*z)/z), fn(floor(uv*z+vec2(1,0))/z), fn(floor(uv*z+vec2(0,1))/z), fn(floor(uv*z+vec2(1,1))/z));\n#define INTERP(fn) mix(mix(fn.x,fn.y,fract(uv.x*z)),mix(fn.z,fn.w,fract(uv.x*z)),fract(uv.y*z)))\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/R.y;\n    float z = 25. + sin(iTime*.1)*15.;\n    vec3 col=vec3(T(uv),0,0)/20./abs(.5-texture(iChannel0,uv/6.).x);\n    col=mix(vec3(1),col,smoothstep(0.,.005*z, length(.5- fract(uv*z-.5))));\n\n    vec4 f=SAMPLE(T);\n    vec4 g=SAMPLE(S);\n   \n    if(uv.x>.5*R.x/R.y) col.g=(floor(.5+INTERP(f));\n    else col.b=(floor(.5 +INTERP(g));\n\n    O = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[713, 713, 730, 730, 767], [768, 768, 785, 785, 830]], "test": "error"}
{"id": "ft33W8", "name": "Rack and pinion", "author": "mlaang", "description": "A gear meshing with two linear gears. We use CSG to construct a gear, and then subtract infinitely many copies of that gear from a cylinder to get the rack: to do this we construct a small number of copies of the gear and then use gradient descent.", "tags": ["raymarching", "gear", "rackandpinion"], "likes": 1, "viewed": 155, "published": "Public API", "date": "1636039144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Parameters: x, vector from which the distance is calculated\n//\t      r, sphere radius\n//\t      c, sphere center vector\n//Return value: signed distance to sphere surface\nfloat distance_to_sphere(vec3 x, float r, vec3 c) {\n    return length(x-c)-r;\n}\n\nfloat softmin(float x, float y) {\n    float K=8.0;\n    return -log(exp(-K*x) + exp(-K*y))/K;\n}\n\nconst float pi = 3.14159265;\n\n//Parameters: x, vector to be rotated,\n//\t      axis, axis around which it is to be rotated\n//\t      angle, rotation angle\n//Return value: rotated vector\nvec3 rotate(vec3 x, vec3 axis, float angle) {\n   return x*cos(angle) + cross(axis, x)*sin(angle) + axis*(1.-cos(angle))*dot(axis, x);\n}\n\n//Parameters: x, spatial position\n//Return value: signed distance from x to a 3D object representing a stylized gear shape\nfloat distance_to_gear(vec3 x) {\n    //d1 is the distance to a central sphere\n\n    float d1 = distance_to_sphere(x, 0.5, vec3(0.0, 0.0, 0.0));\n    \n    //d2 will after the loop be the distance to the union of little spheres that act as cogs\n    \n    const float n=7.0;\n    \n    float d2 = 10000000.0;\n    for(float i=0.0; i < n; i = i + 1.0) {\n        float d = distance_to_sphere(x, 0.1, vec3(0.6*cos(2.0*pi/n*i), 0.6*sin(2.0*pi/n*i), 0.0));\n        if(d < d2)\n            d2 = d;\n            \n        d = distance_to_sphere(x, 0.05, vec3(0.7*cos(2.0*pi/n*i), 0.7*sin(2.0*pi/n*i), 0.0));\n        if(d < d2)\n            d2 = d;\n    }\n\n    return softmin(d1,d2);\n}\n\n//Parameters: x, spatial position\n//            y, sign representing the direction of the translatory motion\n//Return value: signed distance to the shape swept out by the shape to which distance_to_gear defines the distance to under rotation and translation.\nfloat distance_to_reciprocal_gear(vec3 x, float s) {\n    x.x = mod(x.x, 2.0*pi/7.0); //Use translation symmetry\n\n    float relevant_angle,\n          d = 1000000.0;\n     for(float i=0.0; i <= 2.0*pi/7.0; i += 0.1) {\n        float temp = distance_to_gear(rotate(x+s*vec3(i, 0.0, 0.0), vec3(0,0,1), i));\n        if(temp < d) {\n            d = temp;\n            relevant_angle = i;\n        }\n    }\n    \n    for(int i = 0; i != 2; ++i) {\n        const float epsilon = 0.001;\n        float grad = distance_to_gear(rotate(x + vec3(s*(relevant_angle + epsilon), 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle + epsilon));\n        grad = grad - distance_to_gear(rotate(x + vec3(s*relevant_angle, 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle));\n        grad = grad/epsilon;\n        \n        relevant_angle = relevant_angle - 0.8*grad;\n    }\n    \n    d = distance_to_gear(rotate(x+s*vec3(relevant_angle, 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle));  \n    \n    return d;\n}\n\n//Parameters: x, spatial position\n//Return value: Signed distance from x to a particular cylinder\nfloat cyl(vec3 x) {\n    return length(x.yz) - 0.25;\n}\n\n//Signed distance to the xy plane with normal pointing in the -z direction\nfloat distance_beyond_xy_plane(vec3 x) {\n    return -x.z;\n}\n\n//Parameters: x, spatial position\n//Return value: Signed distnace to a complete scene\n//\n// This scene has several characteristics:\n// One thing shown in it is the gear,the distance to which is d\n// We construct a rack which meshes with the gear in one rotation direction\n// the distance to which is d2\n// and we construct another rack which meshes with the gear in another rotation direction\n// the distance to which is d5\n// The intersections of these racks with two cylinders from which the front half has been\n// subtracted using the 'distance_beyond_xy_plane' function.\nfloat distance_to_scene(vec3 x) {\n    float d = distance_to_gear(rotate(x, vec3(0.0, 0.0, 1.0), iTime));\n    \n    float d2 = distance_to_reciprocal_gear(x-vec3(mod(iTime, 2.0*pi),0.0,0.0), 1.0);\n    float d3 = cyl(x-vec3(0.0, 0.5, 0.0));\n    float d4 = distance_beyond_xy_plane(x);\n    \n    float d5 = distance_to_reciprocal_gear(x+vec3(mod(iTime, 2.0*pi),0.0,0.0), -1.0);\n    float d6 = cyl(x-vec3(0.0, -0.5, 0.0));\n    \n    return min(min(max(max(d3, -d2), d4), d), max(max(d6, -d5), d4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1.0 to 1.0) \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Camera: ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 camera_direction = vec3(0.0, 0.0, 0.0) - ro;\n    vec3 rd = vec3(uv.xy, 0.0)-ro;\n    rd = normalize(rd);\n    \n    //Walk along the ray to get to the scene surface\n    \n    vec3 current_position;\n    current_position = ro;\n    for(int i = 0; i != 15; ++i)\n        current_position = current_position + rd*distance_to_scene(current_position);\n        \n    //Is there a hit?\n    \n    const float epsilon = 0.005;\n    \n    float col;\n    \n    if(distance_to_scene(current_position) < epsilon) {\n        float d = distance_to_scene(current_position);\n        float d_plusx = distance_to_scene(current_position + epsilon*vec3(1.0,0.0,0.0));\n        float d_plusy = distance_to_scene(current_position + epsilon*vec3(0.0,1.0,0.0));\n        float d_plusz = distance_to_scene(current_position + epsilon*vec3(0.0,0.0,1.0));\n        \n        vec3 grad = vec3(d_plusx - d, d_plusy - d, d_plusz - d);\n        grad = grad/epsilon;\n        \n        //Grad is now an outward pointing normal\n        //We could do raytracing, but we're instead just going to color the scene\n        //by the normal\n        \n        //Specifically, the color will be the cosine of the angle with a couple of fixed vectors\n        //as is traditional\n        \n        vec3 v = vec3(1.0, 1.0, 1.0);\n        \n        float agreement = dot(v, grad)/(length(grad) * length(v));\n        col = 0.00 + 0.5*max(agreement, 0.);\n        \n        //Now, to brighten things up we do a reflection\n        \n        vec3 normal = normalize(grad);\n        \n        vec3 rd_along_normal = dot(rd, normal)*normal;\n        vec3 rd_orthogonal_to_normal = rd - rd_along_normal;\n        \n        //Make flipped vector\n        ro = current_position;\n        rd = -rd_along_normal + rd_orthogonal_to_normal;\n        \n        //Now do the marching again\n        \n        current_position = ro;\n        for(int i = 0; i != 10; ++i)\n               current_position = current_position + rd*distance_to_scene(current_position);\n               \n        //and what's the normal there again?\n        \n        d = distance_to_scene(current_position);\n        d_plusx = distance_to_scene(current_position + epsilon*vec3(1.0,0.0,0.0));\n        d_plusy = distance_to_scene(current_position + epsilon*vec3(0.0,1.0,0.0));\n        d_plusz = distance_to_scene(current_position + epsilon*vec3(0.0,0.0,1.0));\n        \n        grad = vec3(d_plusx - d, d_plusy - d, d_plusz - d);\n        grad = grad/epsilon;\n        \n        //get the color there and add it multiplied by something like 0.9 (or, well, it seems I picked 1.0)\n        \n        agreement = dot(v, grad)/(length(grad) * length(v));\n        col = col + max(agreement, 0.0);\n        \n    } else col = 0.0;\n        \n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 171, 222, 222, 250], [252, 252, 285, 285, 346], [378, 532, 577, 577, 667], [669, 792, 824, 869, 1455], [1457, 1716, 1768, 1768, 2683], [2685, 2783, 2802, 2802, 2836], [2838, 2913, 2953, 2953, 2972], [2974, 3549, 3582, 3582, 4042], [4044, 4044, 4101, 4157, 7067]], "test": "valid"}
{"id": "ft3GDN", "name": "Wood_shader_sidps", "author": "kingcrimson1112", "description": "A procedural wood shader", "tags": ["procedural", "noise", "wood"], "likes": 1, "viewed": 47, "published": "Public", "date": "1636117187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n// PERLIN_NOISE_GENERATOR\n//----------------------------------------------------\n\nfloat fade(float t)\n{\n    return t * t * t * (t * ((t * 6.0f) - 15.0f) + 10.0f);\n}\n\nfloat grad(int hash, float x, float y, float z)\n{\n    int h = hash & 15;\n    // Convert lower 4 bits of hash into 12 gradient directions\n    float u = (h < 8) ? x : y,\n           v = ((h < 4) ? y : (h == 12 || h == 14 ? x : z));\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nint[512] p=int[512](151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,\n             151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180);\n\n// Returns noise value for position\nfloat noise(float x, float y, float z)\n{  \n    // Find the unit cube that contains the point\n    int X = int(floor(x)) & 255;\n    int Y = int(floor(y)) & 255;\n    int Z = int(floor(z)) & 255;\n\n    // Find relative x, y,z of point in cube\n    x -= floor(x);\n    y -= floor(y);\n    z -= floor(z);\n    \n    // Compute fade curves for each of x, y, z\n    float u = fade(x);\n    float v = fade(y);\n    float w = fade(z);\n\n    // Hash coordinates of the 8 cube corners\n    int A = p[X] + Y;\n    int AA = p[A] + Z;\n    int AB = p[A + 1] + Z;\n    int B = p[X + 1] + Y;\n    int BA = p[B] + Z;\n    int BB = p[B + 1] + Z;\n\n    // Add blended results from 8 corners of cube\n    float res = mix(\n        mix(\n            mix(grad(p[AA], x, y, z),\n                 grad(p[BA], x - 1.0f, y, z),\n                 u),\n            mix(grad(p[AB], x, y - 1.0f, z),\n                 grad(p[BB], x - 1.0f, y - 1.0f, z),\n                 u),\n            v),\n        mix(\n            mix(grad(p[AA + 1], x, y, z - 1.0f),\n                 grad(p[BA + 1], x - 1.0f, y, z - 1.0f),\n                 u),\n            mix(grad(p[AB + 1], x, y - 1.0f, z - 1.0f),\n                 grad(p[BB + 1], x - 1.0f, y - 1.0f, z - 1.0f),\n                 u),\n            v),\n        w);\n    return (res + 1.0f) / 2.0f;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// OCTAVE_NOISE_GENERATOR\n//----------------------------------------------------\n#define IMAGE_ROWS 50\n#define SCALE 17.5f\n#define SCALE_FROM_CENTER 1\n#define LEVEL_OF_DETAIL 0\n#define SMOOTH_INVERSE_LERP 0\n#define OCTAVES 4\n#define PERSISTANCE 0.5f\n#define LACUNARITY 2.0f\n#define NORMALIZE_OFFSET 0\n\n// Inverse Lerp Function\nfloat linear_step(float l, float u, float a)\n{\n    return clamp(((a - l) / (u - l)), 0.0f, 1.0f);\n}\n\n// Gets the perlin noise for point b/w 0.0 and 1.0\nfloat perlin(vec2 pos)\n{\n    return noise(pos.x, pos.y, 0.0f);\n}\n\nfloat get_octave_noise(vec2 pos)\n{\n    float rows = float(IMAGE_ROWS);\n    pos *= rows;\n    float columns = rows * (iResolution.x / iResolution.y);\n    float scale = float(SCALE);\n    if(scale <= 0.0f)\n    {\n        scale = 0.001f;\n    }\n    \n    int octaves = int(OCTAVES);\n    float lacunarity = max(LACUNARITY, 1.0f);\n    float persistence = min(PERSISTANCE, 1.0f);\n    \n    float halfX = 0.0f;\n    float halfY = 0.0f;\n#if SCALE_FROM_CENTER\n    halfX = columns / 2.0f;\n    halfY = rows / 2.0f;\n#endif\n\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n    float noiseVal = 0.0f;\n    \n    // Add LODs\n#if LEVEL_OF_DETAIL\n    pos /= float(LEVEL_OF_DETAIL);\n    pos = vec2(floor(pos.x), floor(pos.y));\n    pos *= float(LEVEL_OF_DETAIL);\n#endif\n\n    vec2 offset = 0.1f * vec2(iTime * -1.0f, iTime * -1.25f);\n    \n    for (int i = 0; i < octaves; i++)\n    {\n#if NORMALIZE_OFFSET\n        float sampleX = (((pos.x-halfX) / scale) * frequency) + offset.x;\n        float sampleY = (((pos.y-halfY) / scale) * frequency) + offset.y;\n#else\n        float sampleX = (((pos.x-halfX + offset.x*scale) / scale) * frequency);\n        float sampleY = (((pos.y-halfY + offset.y*scale) / scale) * frequency);\n#endif\n        float noise = (perlin(vec2(sampleX, sampleY)) * 2.0f) - 1.0f;\n        noiseVal += noise * amplitude;\n        // Decrease A and increase F\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }    \n\n    // Inverser lerp so that noiseval lies between 0 and 1 \n#if SMOOTH_INVERSE_LERP\n    noiseVal = smoothstep(-0.95f, 1.1f, noiseVal);\n#else\n    noiseVal = linear_step(-0.7f,0.85f,noiseVal);\n#endif\n    return noiseVal;\n}\n//----------------------------------------------------\n//----------------------------------------------------\nvec3 baseCol=vec3(0.25f,0.10f,0.0f);\nvec3 detailCol = vec3(1.0f,0.60f,0.0f);\nfloat xScale=3.0f;\nfloat yScale=3.0f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=uv*2.0f-1.0f;\n    uv.x*=(iResolution.x/iResolution.y);\n    uv*=xScale*yScale;\n    \n    float fac=4.0f;\n    float freq=1.5f;\n    float t=get_octave_noise(freq*uv/(xScale*yScale));\n    \n    float p = sqrt(pow(uv.x*xScale,2.0f)+pow(uv.y*yScale,2.0f));\n    p += t*fac;\n    float h = sin(p);\n    \n    h=h*h;\n    h=1.0f-h;\n    h+=0.2f;\n    h=pow(h,2.0f);\n    h=smoothstep(h,-1.0f,-0.2f);\n   \n    vec3 col=mix(baseCol,detailCol*h,h);  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3GDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 158, 158, 219], [221, 221, 270, 270, 513], [3176, 3212, 3252, 3304, 4490], [4960, 4985, 5031, 5031, 5084], [5086, 5137, 5161, 5161, 5201], [5203, 5203, 5237, 5237, 6851], [7078, 7078, 7135, 7135, 7671]], "test": "valid"}
{"id": "ft3GDX", "name": "Ray Marching Techniques", "author": "playbyan1453", "description": "This technique if not careful can be heavy. Regular technique breaks down at bigger displacement, the relaxing one it looks smooth with less artifact.\nLeft (Common), Right (New).", "tags": ["raymarching", "sdf", "relaxing"], "likes": 5, "viewed": 82, "published": "Public", "date": "1636799748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 1024\n#define MIN_T 1e-4\n#define MAX_T 8.0\n\nfloat map(vec3 p) {\n    return (length(p) - 1.0)+(sin(8.0*p.x)*sin(8.0*p.y)*sin(8.0*p.z))*0.5;\n}\n\nvec3 normal(vec3 p) {\n    const float e = MIN_T;\n    const vec2 h = vec2(1,-1);\n    return normalize(h.xyy*map(p + h.xyy*e)+\n                     h.yyx*map(p + h.yyx*e)+\n                     h.yxy*map(p + h.yxy*e)+\n                     h.xxx*map(p + h.xxx*e));\n}\n\n// Common technique, total distance summed by estimation.\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        float d = map(ro + rd * t);\n        t += d;\n        if(d < MIN_T || t > MAX_T) break;\n    }\n    return t;\n}\n\n/* // Original code, it was a better soft shadow from iq\n// It was modified to get better intersection\nfloat hraymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float pd = 1e19;\n    float steps = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        float d = map(ro + rd * t);\n        float y = d*d/(2.0*pd);\n        float h = sqrt(d*d-y*y);\n        pd = d;\n        t += min(d, h/max(0.0, t-y));\n        if(d < MIN_T || t > MAX_T) break;\n    }\n    return t;\n}*/\n\n// Relaxing Ray Marcher : https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nfloat hraymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float relax = 0.25;\n    float last_d = 0.0;\n    float last_dt = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        if(t > MAX_T) break;\n        float d = map(ro + rd * t);\n        if(relax != 1.0 && last_dt > abs(last_d) + abs(d)) {\n            t += (1.0 - relax) * last_dt;\n            relax = 1.0;\n            continue;\n        }\n        if(d < MIN_T) break;\n        t += relax * d;\n        last_dt = relax * d;\n        last_d = d;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(cos(iTime*0.25)*3.0, 2, sin(iTime*0.25)*3.0);\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    vec3 rd = normalize(uv.x * x + uv.y * y + 1.0 * z);\n    float t = uv.x < 0.0 ? raymarch(ro, rd) : hraymarch(ro, rd);\n    vec3 p = ro + rd * t;\n    vec3 nor = normal(p);\n    vec3 col = t < MAX_T ? vec3(nor.y*0.5+0.5) : vec3(rd.y*0.5+0.5);\n\n    fragColor = vec4(sqrt(col)*smoothstep(0.0005, 0.005, abs(uv.x)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3GDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 76, 76, 153], [155, 155, 176, 176, 417], [419, 477, 511, 511, 683], [1146, 1239, 1274, 1274, 1752], [1754, 1754, 1806, 1806, 2411]], "test": "valid"}
{"id": "ft3GWs", "name": "American Film Festival 2021", "author": "Sir_Dudard", "description": "Inspired by American Film Festival promo spot - New Horizon Cinema 2021\n\nOriginal spot: \nhttps://www.youtube.com/watch?v=TXY5ujpsGvU&ab_channel=NoweHoryzonty\n", "tags": ["stars"], "likes": 6, "viewed": 401, "published": "Public", "date": "1636904901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define clamp01(x) clamp(x,0.,1.)\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nconst vec3 WHITE_STAR_COLOR = vec3(1.);\nconst vec3 BLUE_STAR_COLOR = vec3(0.35294117647,0.42352941176,0.67058823529);\nconst vec3 RED_STAR_COLOR = vec3(0.72549019607,0.05098039215,0.30980392156);\nconst vec3 BACKGROUND_BLACK = vec3(0.01176470588);\nconst vec3 MOUNTAIN_COLOR = vec3(0.0862745098,0.1725490196,0.30588235294);\n\nconst float STAR_MAX_SIZE = 0.2;\nconst float STAR_MIN_SIZE = 0.05;\n\nfloat remap01(float a, float b, float t)\n{\n    return clamp01((t-a)/(b-a));\n}\n\nfloat Rand(float i)\n{\n    return fract(sin(i * 23325.) * 35543.);\n}\n\nvec4 Rand4(float i)\n{\n    return fract(sin(i * vec4(23325.,53464.,76543.,12312)) * vec4(35543.,63454.,23454.,87651));\n}\n\nvec2 within(vec2 uv, vec4 rect)\n{\n    return (uv - rect.xy)/(rect.zw-rect.xy);\n}\n\nfloat Star(vec2 uv, float radius, float iradius, float rotation)\n{\n    vec2 st = vec2 (atan(uv.x,uv.y), length(uv));\n    \n    float n = 5.;\n    \n    float a  = st.x + rotation;\n    float sa = M_PI/n;\n    \n    float p = fract(a/(2.0*sa));\n          p = abs(p-0.5)*2.0;\n    \n    float cr = cos(sa)*radius;\n\n    float pa  = p*sa;\n    float cpr = cr/cos(sa-pa);\n\n    float xp = cpr*sin(pa);\n    float yp = cpr*cos(pa);\n    float xi = sin(sa*0.5)*iradius*radius;\n    float yi = cos(sa*0.5)*iradius*radius;\n  \n    float yx = (xi*yp*radius)/(xp*radius-xp*yi+xi*yp);\n\n    float border = yx/cos(pa);\n   \n    return smoothstep(0.,0.1,1. -st.y/border);\n}\n\nvec3 ThreeStar(vec2 uv, float rotation){\n    \n    float radius  = 0.5;\n    float iradius = .5;  \n\n    float redStar   = Star(uv - vec2(.055,-.09), radius, iradius, rotation);\n    float blueStar  = Star(uv - vec2(.0,.0), radius, iradius, rotation);\n  \n    vec3 whiteStarColor = blueStar * redStar * WHITE_STAR_COLOR;\n    vec3 redStarColor   = redStar * RED_STAR_COLOR;\n    vec3 blueStarColor  = blueStar * BLUE_STAR_COLOR;\n      \n    return whiteStarColor + redStarColor + blueStarColor;\n}\n\nvec3 StarSky(vec2 uv){\n    \n    float t = iTime*0.025;\n    float sr = iResolution.x/iResolution.y;\n\n    vec3 color = vec3(0.);\n    \n    float sc = 15.;\n    float s = 1./ sc;\n    float at = 0.01;\n    \n    float stt = 0.1;\n    vec2 spading = vec2(0.95,0.9);\n    \n    for(float i = 0.; i < 1.; i +=s)\n    {    \n        float ci = t + i;\n        float fci = fract(ci);\n        float sit = floor(ci);\n    \n        float btout = pow(smoothstep(0.9,1.0,fci),20.);        \n        float ibtout = 1.-btout;\n        \n        float bt = ci * 500.;\n        float h1 = Rand(floor(bt));\n        float h2 = Rand(floor(bt+1.));\n        float bumps = mix(h1, h2, fract(bt))*.1;\n        bumps = pow(bumps,3.) * 10.;\n        float shake = smoothstep(0.9,1.0,fci) * bumps;\n        \n        float btin = pow(smoothstep(0.,0.1,fci),2.);\n        \n        vec4 rm = Rand4(i + sit);\n        \n        float rs = STAR_MIN_SIZE + rm.x * (STAR_MAX_SIZE-STAR_MIN_SIZE) * ibtout;\n        vec2 rp  = vec2((rm.y*2. - 1.)*sr + shake ,rm.z + shake) * spading;\n        \n        rp  = (vec2(sr * 0.9,-0.5) - rp) * btout + rp;\n        \n        vec4 rb  = vec4(rp.x, rp.y, rp.x + rs, rp.y + rs);\n        vec2 st  = within(uv, rb);\n        \n        vec3 ts = ThreeStar(st,M_PI);\n        ts *= ibtout;\n        ts *= btin;\n        color += ts;\n        \n    }\n    \n    return color;\n}\n\nvec3 Background(vec2 uv)\n{ \n    vec3 dc = BACKGROUND_BLACK;\n    vec3 bc = BLUE_STAR_COLOR;\n    vec3 rc = RED_STAR_COLOR;\n    vec3 wc = WHITE_STAR_COLOR;\n    \n    vec3 color = mix (bc, dc, smoothstep(-0.8,-0.1,uv.y));\n    color = mix (rc, color, smoothstep(-1.0,-0.55,uv.y));\n    color = mix (wc, color, smoothstep(-1.4,-0.7,uv.y));\n    return color;\n}\n\nvec3 MountainsOverlay(vec2 uv, vec3 color, float mountainLevel)\n{\n    float pos = uv.x + iTime * 0.05;\n    float bt = pos * 5.;\n    float h1 = Rand(floor(bt));\n    float h2 = Rand(floor(bt+1.));\n    float bumps = mix(h1, h2, fract(bt))*.1;\n    bumps = pow(bumps,3.) * 300.;\n    \n    mountainLevel += bumps;\n    \n    float mask = 1.-smoothstep(mountainLevel,mountainLevel*0.99, uv.y);\n    vec3 mc =  smoothstep(-1.2, mountainLevel+0.1, uv.y) * MOUNTAIN_COLOR;\n    color = mix(color,mc, mask);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        \n    vec3 color = StarSky(uv) + Background(uv);\n    color = MountainsOverlay(uv,color,-0.9);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3GWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 483, 525, 525, 560], [562, 562, 583, 583, 629], [631, 631, 652, 652, 750], [752, 752, 785, 785, 832], [834, 834, 900, 900, 1477], [1479, 1479, 1519, 1519, 1967], [1969, 1969, 1991, 1991, 3310], [3312, 3312, 3338, 3338, 3663], [3665, 3665, 3730, 3730, 4181], [4183, 4183, 4240, 4240, 4440]], "test": "valid"}
{"id": "ft3Gzs", "name": "Persian carpet 16", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 10, "viewed": 147, "published": "Public API", "date": "1636513420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.125;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.+random3[k];\n            //float bend = abs(fract((uv.x)*3.)-.5)/3.+1.;\n            //float bend = 1.+1./3.;\n            //float bend = scale2;\n            \n            //bend = abs(fract(((uv.x+uv.y)))-.5)+1.+1.;\n            \n            //uv *= bend+col.x;\n            uv = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n            //uv *= bend+col.x;\n            \n            for(int k = 0; k < 3; k++){\n                //uv.y /= scale2+col.x;\n                uv.y /= scale2;\n                \n                //uv *= bend-col.x;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]).yx;\n                uv.x /= -scale2;\n                scale /= 1.+(scale2+uv.x-uv.y)*col.x/5.;\n                scale2 -= (col.x-1.-uv.x+uv.y)/12.;\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1.+uv.x/2.;\n\n\n            }\n            //bend *= -1.;\n            //bend -= 1./3.;\n            \n\n            col[c] = abs((uv.x)-(uv.y));\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3Gzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2586]], "test": "valid"}
{"id": "ftc3W8", "name": "Spinning Cube", "author": "LargeBee", "description": "My second ever shader! Recreating an old project I made with DOS graphics when I was learning about matrices and orthographic projection.\nTips on how to improve it very much appreciated", "tags": ["cube", "beginner", "orthographic"], "likes": 3, "viewed": 140, "published": "Public API", "date": "1636040879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Borrowed from https://www.shadertoy.com/view/MlcGDB\n    uv Normalized coordinates from main func\n    p1 Position 1 to draw the line from\n    p2 Position 2 to draw the line to\n    t  Thickness of the line\n*/\nfloat line(vec2 uv, vec2 p1, vec2 p2, float t) \n{\n    vec2 g = p2 - p1;\n    vec2 h = uv - p1;\n    t /= iResolution.y;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(t, 0.5*t, d);\n}\n\nmat3 rotationZ(float angle)\n{\n    return mat3(\n        cos(angle),-sin(angle),0,\n        sin(angle),cos(angle),0,\n        0,0,0\n    );\n}\n\nmat3 rotationY(float angle)\n{\n    return mat3(\n        cos(angle),0,sin(angle),\n        0,1,0,\n        -sin(angle),0,cos(angle)\n    );\n}\n\nmat3 rotationX(float angle)\n{\n    return mat3(\n        1,0,0,\n        0,cos(angle),sin(angle),\n        0,-sin(angle),cos(angle)\n    );\n}\n\nmat3 scaler(float scale)\n{\n    return mat3(\n        scale,0,0,\n        0,scale,0,\n        0,0,scale\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    //Define set of points\n    vec3 points[] = vec3[](\n    vec3(-1.0,-1.0,-1.0),   //Corner 0\n    vec3(1.0,-1.0,-1.0),    //Corner 1\n\n    vec3(1.0,1.0,-1.0),     //Corner 2\n    vec3(-1.0,1.0,-1.0),    //Corner 3\n\n    vec3(-1.0,-1.0,1.0),    //Corner 4\n    vec3(1.0,-1.0,1.0),     //Corner 5\n    \n    vec3(1.0,1.0,1.0),      //Corner 6\n    vec3(-1.0,1.0,1.0)      //Corner 7\n    );\n\n    ivec2 edges[] = ivec2[](\n        ivec2(0, 1),\n        ivec2(0, 3),\n        ivec2(0, 4),\n        ivec2(1, 2),\n        ivec2(1, 5),\n        ivec2(2, 3),\n        ivec2(2, 6),\n        ivec2(3, 7),\n        ivec2(4, 5),\n        ivec2(4, 7),\n        ivec2(5, 6),\n        ivec2(6, 7)\n    );\n\n    float angle = iTime; //Modify?\n    float scale = 0.5;\n\n    //rotate and project points with matrix maths and use time as angle\n    vec3 outPoints;\n    vec2 projectedPoints[points.length()];\n    for (int i = 0; i < points.length(); ++i)\n    {\n        outPoints = points[i];\n        outPoints *= rotationY(angle)\n                * rotationX(angle)\n                * scaler(scale);\n        \n        projectedPoints[i] = vec2(outPoints.xy);\n    }\n    \n    float colOut = 0.0;\n    bool valid;\n    //Add lines to output value\n    for (int i = 0; i < edges.length(); ++i)\n    {\n        colOut += line(\n            uv, \n            projectedPoints[edges[i].x].xy, \n            projectedPoints[edges[i].y].xy, \n            4.0\n        );\n    }\n\n    const vec3 backColour  = vec3(0.3);\n    const vec3 lineColour = vec3(0.35,0.95,0.51);\n    \n    vec3 colour = mix(backColour, lineColour, colOut);\n    //Output colour per pixel\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 214, 263, 263, 435], [437, 437, 466, 466, 573], [575, 575, 604, 604, 711], [713, 713, 742, 742, 849], [851, 851, 877, 877, 959]], "test": "error"}
{"id": "ftc3Wj", "name": "Inflatey Bubble", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 9, "viewed": 125, "published": "Public API", "date": "1636686405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}    \n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float sc = 96. + 32. * thc(12., iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n\n    float a = atan(ipos.y, ipos.x);\n    float r = length(ipos)/sc;\n    r *= .5 * (1. + thc(4., 4. * r));\n    float str = 3. + 5. * cos(3. * a + iTime);\n    ipos = r * vec2(thc(str, a), ths(str, a));\n\n    float d = length(ipos);\n    float cr = 0.26 + 0.1 * thc(4., iTime) + 0.02 * ths(3., iTime);\n    float s = step(cr - 4./sc, d) - step(cr, d);\n    s *= step(length(fpos), 0.5);\n    fragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [76, 76, 105, 105, 146], [149, 149, 206, 206, 802]], "test": "valid"}
{"id": "ftc3Wn", "name": "LogPolar QuadTree", "author": "byt3_m3chanic", "description": "Very basic design - Going another step into the Quadtree explorations, and who doesn't enjoy love a good log-polar transform! ", "tags": ["warp", "log", "quadtree"], "likes": 37, "viewed": 368, "published": "Public API", "date": "1636008823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Draft Quadtree [learning number 3]\n    11/4/21 @byt3_m3chanic\n\n    throwing it into a log polar transform.\n    It's hard to make the design more complex and \n    still look good as it scales, but this was \n    just poking around to see what else you can do.\n    \n    @Shane has a good example that explains quadtrees\n    which is what I used to create this shader.\n    https://www.shadertoy.com/view/llcBD7\n \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\nvec3 hue(float t){ \n    const vec3 d = vec3(0.067,0.812,0.910);\n    return .55 + .45*cos(PI2*t*(vec3(.95,.97,.98)*d)); \n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 vuv= uv*rot(T*.05);\n\n    vuv=vec2(log(length(vuv)), atan(vuv.y, vuv.x))*3.5;\n    vuv.x+=T*.25;\n    \n    float px = fwidth(vuv.x);\n    float level=1.;\n\n    vec3 C = vec3(.0325);\n    float mask = smoothstep(.65,.0,length(uv)-.2);\n    C = mix(C, vec3(.125),mask);\n    \n    for(int k=0; k<5; k++){\n        vec2 id = floor(vuv*level);\n        float rnd = hash21(id);\n        \n        // threshold or if last loop\n        if(rnd>.45||k>3) {\n\n            vec2 p = vuv -(id+.5)/level;\n            rnd = hash21(rnd+id.yx);\n\n            float d = smoothstep(px,-px,length(p)-.455/level);\n            float s = length(p)-.425/level;\n \n            if(rnd<.675) {\n                if(rnd>.2) s=abs(s)-.05/level;\n                s = smoothstep(px,-px,s);\n                C=mix(C,hue((id.y*.05)+float(k+1)*.25),s);\n            } else {\n                C=mix(C,vec3(.2),d);\n                            \n                if(hash21(rnd+id)>.8) {\n                    p*=rot(rnd+T*.5);\n                    vec2 cs = vec2(.3,.075)/level;\n                    float cx=min(box(p,cs.yx),box(p,cs));\n                    C=mix(C,vec3(.8),smoothstep(px,-px,cx));\n                }\n            }\n\n            break;\n        }\n        level*=2.;\n    }\n    \n    C = pow(C, vec3(.4545));        \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Wn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[659, 659, 679, 679, 724], [725, 725, 746, 746, 801], [803, 803, 821, 821, 924], [926, 926, 960, 960, 1040], [1042, 1042, 1083, 1083, 2422]], "test": "valid"}
{"id": "ftc3z8", "name": "speaking with the void", "author": "bradseeker", "description": "if u chat w it long enough it'll chat right back", "tags": ["noisewarping"], "likes": 6, "viewed": 118, "published": "Public", "date": "1635933844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// various parts ripped from various IQ projects\n// and articles, such as: https://www.iquilezles.org/www/articles/warp/warp.htm\n\nfloat lerp(float a, float b, float t){return a+((b-a)*t);}\nvec2 lerp(vec2 a, vec2 b, float t){return a+((b-a)*t);}\nvec2 lerp(vec2 a, vec2 b, vec2 t){return a+((b-a)*t);}\nvec3 lerp(vec3 a, vec3 b, float t){return a+((b-a)*t);}\nvec3 lerp(vec3 a, vec3 b, vec3 t){return a+((b-a)*t);}\n\nfloat fmod(float a, float b){return a - (b * floor(a/b));}\n\nfloat hash( float p ) // replace this by something better\n{\n\tvec2 p2 = vec2( dot(vec2(p),vec2(127.1,311.7)), dot(vec2(p),vec2(269.5,183.3)) );\n    p2 = fract(sin(p2)*43758.5453123);\n\treturn (p2.x+p2.y)/2.;\n}\nfloat hash2 (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash2(i);\n    float b = hash2(i + vec2(1.0, 0.0));\n    float c = hash2(i + vec2(0.0, 1.0));\n    float d = hash2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nconst int numOctaves = 32;\nfloat fbm(in vec2 pos, in float H){\n    float total_noise = 0.;\n    float f, a;\n    for (int i=0; i<numOctaves; ++i) {\n        f=pow(2., float(i));\n        a=pow(f, -H);\n        total_noise+=a*noise(f*pos);\n    }\n    \n    return total_noise;\n}\nfloat fbm(in vec2 pos){return fbm(pos, 0.5);}\n\nconst vec2 center = vec2( 0.);\nvec3 pattern( in vec2 p, in vec2 fragCoord, vec3 col1, vec3 col2, vec2 morph )\n{\n    vec2 q = vec2( fbm(morph+ p + vec2(0.0,0.0) * cos(iTime/7.) ),\n                   fbm(morph+ p + vec2(0.27,0.37) + sin(iTime/8.)/8. ) );\n                   \n    vec2 r = vec2(cos(p.x*q.x*6.28), sin(p.y*q.y*3.14));\n    \n    vec2 p2 = vec2(p.x, p.y);\n    vec2 d = center-p2;\n    \n    float pw = max(1.-pow(length(d*(q/3.))*2.,4.), 0.);\n    \n    r = r - pw*normalize(d)*(1.+sin(iTime/8.768)*2.);\n    \n    float blackness = pow(length(d*q)*(3.+sin(iTime/8.768)),2.5+cos(iTime/8.)*2.);\n    blackness = min(max(blackness, 0.),1.5);\n    pw = fbm( morph+p + 4.0*r) * blackness;\n    \n    return lerp(lerp(col2, col2+hash2(p), max(1.-blackness, 0.)), col1, pw);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uv + vec2(0.35);\n    \n    // coloring\n    vec3 col = vec3(uv.x/2., 0.,uv.y);\n    vec3 col2 = vec3(1.0);\n    col.x *= (sin(iTime/3.)+1.)/4. + 0.5;\n    col.z *= (cos(iTime/4.)+1.)/6. + (2./3.);\n    col.y = (col.x*col.z + col.z*col.x)/2.;\n    col /= 1.;\n    col2 = pow(col, vec3(2.));\n    \n    // shaping\n    vec2 pos = fragCoord/iResolution.y;// + (fragCoord/8.*rand1(iTime));\n    pos = pos-vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    \n    col = pattern(pos, fragCoord, col, col2,vec2(sin(iTime/16.), cos(iTime/16.)) );\n    col.y *= (sin(iTime/4.)/2.+0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 168, 168, 188], [189, 189, 224, 224, 244], [245, 245, 279, 279, 299], [300, 300, 335, 335, 355], [356, 356, 390, 390, 410], [412, 412, 441, 441, 470], [472, 472, 531, 531, 679], [680, 680, 706, 706, 823], [825, 825, 882, 882, 997], [999, 999, 1025, 1025, 1538], [1567, 1567, 1602, 1602, 1810], [1811, 1811, 1834, 1834, 1856], [1889, 1889, 1969, 1969, 2627], [2631, 2631, 2688, 2688, 3328]], "test": "valid"}
{"id": "ftc3zN", "name": "Refraction Sphere Test", "author": "FoRenard", "description": "Refraction Sphere Test", "tags": ["refractionspheretest"], "likes": 3, "viewed": 60, "published": "Public", "date": "1635776011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define AA 2\n\n//------------------------------------------------------------------\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 qos=pos;\n    float d=1e9;\n    d=min(d,sdPlane(qos));\n    qos.xz=mod(qos.xz,1.0)-vec2(0.5);\n    d=mod(iTime,6.0)<3.0?min(d,sdSphere(qos-vec3(0.0,0.5,0.0),0.45)):d;\n    return d;\n}\n\nint mateId( in vec3 pos )\n{\n    int id;\n    float d=1e10,b;\n    vec3 qos=pos;\n    \n    b=sdPlane(qos);\n    if(d>b){\n        d=b;\n        vec2 uv=pos.xz;\n        id=mod(uv.x*uv.y,2.0)<1.0?1:2;\n    }\n    qos.xz=mod(qos.xz,1.0)-vec2(0.5);\n    b=sdSphere(qos-vec3(0.0,0.5,0.0),0.45);\n    if(d>b){\n        d=b;\n        id=0;\n    }\n    return id;\n}\n\nvec3[] mateCol=vec3[](\n    vec3(0.5,0.8,1.0)*0.8,\n    vec3(0.2,0.3,1.0)*0.8,\n    vec3(0.2,0.8,0.7)\n);\n\n//------------------------------------------------------------------\n\nmat2 rot2(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 25.0;\n    float ymin = -1.0;\n    float ymax = 3.0;\n\n    float tp1 = (ymin-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (ymax-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>ymax ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 skybox(vec3 rd)\n{\n    //return texture(iChannel0,rd).rgb;\n    return vec3(0.1);\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    /// default is skybox\n    vec3 col=skybox(rd);\n    //vec3 col=vec3(0.0);\n    float t = castRay(ro,rd);\n    \n    /// ray collide\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        int id=mateId(pos);\n\n        /// inout: ro,rd,t,pos,nor,id\n        /// refract process\n        int rdepth=2;\n        float eta=0.5;\n        while(rdepth-->0)\n        {\n            if(id==0)\n            {\n                /// reflect\n                ro=pos;\n                rd=refract(rd,nor,eta);\n                t=castRay(ro,rd);\n                if(t>-0.5)\n                {\n                    /// next reflect\n                    pos = ro + t*rd;\n                    nor = calcNormal( pos );\n                    id=mateId(pos);\n                }else\n                {\n                    /// ray far away\n                    return skybox(rd);\n                }\n            }else\n            {\n                /// not reflect\n                break;\n            }\n        }\n        \n        /// set material\n        vec3 mate=mateCol[id];\n        \n        /// calc lighting\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0);\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 4.0*dif*vec3(0.50,0.80,0.80);\n        col +=      12.0*spe*vec3(1.00,0.80,0.50);\n        \n        float occ = calcAO( pos, nor );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        \n        col *= exp( -0.0005*t*t*t );//fog\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /// camera\n    float arg=2.0*PI*(iTime/20.0);\n    vec3 ro = vec3( 3.0, 5.0, 3.0 );ro.xz*=rot2(arg);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    /// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta ,0.0);\n    \n    vec3 scol=vec3(0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        //vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n        /// ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        /// render\n        vec3 col = render( ro, rd);\n\n        /// gamma\n        col = pow( col, vec3(0.4545) );\n        \n        //sum\n        scol+=col;\n    }\n    scol/=float(AA*AA);\n    fragColor = vec4( scol, 1.0 );\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 105, 130, 130, 145], [147, 147, 182, 182, 206], [208, 208, 241, 241, 306], [308, 308, 353, 353, 444], [515, 515, 541, 541, 729], [731, 731, 758, 758, 1073], [1248, 1248, 1267, 1267, 1316], [1318, 1387, 1464, 1464, 1876], [1878, 1878, 1910, 1910, 2110], [2112, 2112, 2153, 2153, 2731], [2733, 2733, 2775, 2775, 3036], [3038, 3038, 3060, 3100, 3124], [3126, 3126, 3164, 3191, 4979], [4981, 4981, 5033, 5033, 5210], [5212, 5212, 5269, 5284, 6117]], "test": "error"}
{"id": "ftcGDl", "name": "Fall & Light", "author": "rmmcal", "description": "The Fall", "tags": ["fall"], "likes": 8, "viewed": 111, "published": "Public", "date": "1636912095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//             ...  Fall & Light ...                     ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/11\n// https://www.shadertoy.com/view/ftcGDl\n//\n// Fork: https://www.shadertoy.com/view/fltGDH\n/////////////////////////////////////////////////////////////\n\nconst float pi = 3.1415926;\nconst float pi2 = 2.*pi;\nconst float rad = pi/180.;\nfloat rnd ;\n\nmat2 rotate(float x){\n    float c = cos(x);\n    float s = sin(x);\n    return mat2(c,s,-s,c);\n}\n  \nvec4 v(float v){\n    return vec4(v, 0.,0.,0.);\n}\nvec4 v(float v, float v2){\n    return vec4(v, v2, 0.,0.);\n}\n\nvec4 vmin(vec4 v1, vec4 v2){\n    return v1.x < v2.x ? v1 : v2;\n}\n\nvec4 vmin(vec4 v1, float v2){\n    return v1.x < v2 ? v1 : v(v2);\n}\n\nvec4 vmin(vec4 v1, float v2, float v3){\n    return v1.x < v2 ? v1 : v(v2,v3);\n}\n\n/////////////\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n/////////////\n\n\nvec4 dist(vec3 p)\n{\n    vec4 d = v(1.0);\n    vec2 ps = ((p.xy+vec2(3., 2.)))/1.0;\n    float f = .1;\n    d = min(d, .075);\n\n    vec3 c1 = vec3(.1);\n    vec3 c2 = vec3(.2)*2.0;\n    vec3 q = mod(p+0.5*c1,c1)-0.5*c1; \n    q.z=p.z;\n    vec2 id = floor((p+0.5*c1)/c1).xy;\n\n    float  e2 = .001+abs(fract(dot((id+cos(id.x+id.y*10.0*1.0+cos(id.x*123.0)))*179.531, vec2(11.1327,1.1323))));\n\n    id = floor((p+0.5*c1)/c1).xy+vec2(-1,0);\n    \n    float at = +(-2.+2.0*fract(-e2*4.+(e2+.4)*iTime*0.04));\n    vec4 da = d;\n    d = vmin(d,  -c1.x/15.0+length(q-vec3(0.00, 0.0,1.+at ))*1.0, 1.0);\n\n    d =   vmin(d,  sdVerticalCapsule(  (q-vec3(0,0, e2*225.  - 25.0*abs(fract((at)))  )).xzy,  .5, .001 ), 2.0) ;\n  \n    float wave = cos(cos(p.x*11.01) + cos((p.y+.5)*11.01)+ cos((p.x*.5+.5)*11.01+max(0.,cos(at))) + iTime)*.03;\n    d = vmin(d, 1.- p.z + wave, 0.0);\n    \n    float swave = 1.90- p.z + wave;\n    d = vmin(d, length(q-vec3(0.0,0.0,swave))-c1.x*e2*e2*e2/4.0 , 0.0);\n   \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0., 0.01);\n    float x = dist(p-d.yxx).x;\n    float y = dist(p-d.xyx).x;\n    float z = dist(p-d.xxy).x;\n    return normalize(vec3(x,y,z)-dist(p).x);\n}\n\nvec3 hsv2rgb(float v){\n\treturn abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pc = (uv-.75)*vec2(1, iResolution.y/iResolution.x);\n\n    vec3 p = vec3(0.);\n    p += vec3(0.,-5.0,-5.);\n    float sr = 5.;\n\n    float a = iTime*.05 * (max(-1.0,cos(iTime*.25))* .005+.995 );\n\n    p = vec3(sr*cos(a)-.85,sr*sin(a), 0.2);\n    vec3 d = normalize(vec3(pc,1.0));\n    d.yz *= rotate(1.341592);\n    d.xy *= rotate(-a+4.63);\n\n    vec3 c=vec3(0.0);\n    float t = 0.;\n    float pd = 1e19;\n    vec4 hit;\n    vec4 hitn;\n    vec3 cadd;\n    vec3 cadd2;\n    float caddm = 1.; \n    for (int i = 0 ; i < 200; i++)\n    {\n        hit = dist(p);           // current \n        hitn = dist(p+ d*hit.x); // next \n        float h=hit.x; \n        float h2=hitn.x;\n        h = (h+h2)/2.0;\n\n        //float y = h*h/(2.0*pd);\n        //float k = sqrt(h*h-y*y);\n        //pd = h;\n        //h = min(h, h/max(0.0, t-y));\n\n        if (h < 0.01)\n         break;\n        t+=h;\n        p += d*h;\n        cadd += vec3(1,.5,.25)*h;\n        \n        caddm = min(caddm, h);\n        cadd2 += vec3(1,.5,.25)/caddm;;\n    }\n    vec3 pn = getNormal(p);\n    c += pn.z*.0;\n \n  \n   \n    if (hit.y==0.0) {\n    }\n    if (hit.y==2.0) {\n        c = cadd2*.5 ;\n    } if (hit.y==1.0) {\n        c = (pn.z*.5+.5)*(hsv2rgb(p.x+p.y+p.z)*.5+.75  ) ; \n    }\n    else\n        c += vec3(abs(pn.z)) *(cadd2)/(t*190.); \n    \n     \n    c = mix(c, c * (1.-(log(cadd))*1.0), max(0., sin(-iTime*.25)));\n    \n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[528, 528, 549, 549, 622], [626, 626, 642, 642, 674], [675, 675, 701, 701, 734], [736, 736, 764, 764, 800], [802, 802, 831, 831, 868], [870, 870, 909, 909, 949], [951, 1040, 1093, 1093, 1152], [1169, 1169, 1188, 1188, 2150], [2152, 2152, 2176, 2176, 2345], [2347, 2347, 2369, 2369, 2430], [2432, 2432, 2489, 2489, 3933]], "test": "valid"}
{"id": "ftcGRX", "name": "Waving Lights", "author": "lGuy", "description": "Lights which seem to be distorted by water waves.", "tags": ["noise"], "likes": 18, "viewed": 328, "published": "Public", "date": "1636395796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// -----------------------------------------------\n\nfloat fbm( in vec2 uv )\n{\n \tuv *= 2.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f = 0.;\n    f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return abs(f + 0.5);\n}\n\nvec4 light(vec2 p, vec2 center, float strength, vec4 color) {\n    return strength * color / length(p - center);\n}\n\nvec2 move(int n) {\n    float h = hash(vec2(float(n))).x;\n    \n    return vec2(cos(iTime / 10.0 - h) * 0.7, sin(iTime / 20.0 + h) * 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 distortion = vec2(fbm(p), fbm(1.0 - p)) * 0.4;\n    distortion.y -= fbm(0.3 * vec2(p.x, p.y - iTime * 0.7)) * 0.8;\n    \n    vec4 lights = vec4(0.0);\n    \n    lights += light(move(0) + p + distortion, vec2(0.0), abs(sin(0.1 * iTime + 13.45)) * 0.11, vec4(0.4, 0.2, 0.7, 1.0));\n    lights += light(move(1) + p + distortion, vec2(0.3), abs(sin(0.1 * iTime)) * 0.1, vec4(0.1, 0.2, 0.8, 1.0));\n    lights += light(move(2) + p + distortion, vec2(-0.4, 0.1), 0.09 * abs(cos(0.15 * iTime)), vec4(0.4, 0.6, 0.8, 1.0));\n    \n    lights += light(move(0) + p - distortion * 0.2, vec2(0.0), abs(sin(0.1 * iTime + 13.45)) * 0.11, vec4(0.4, 0.2, 0.7, 1.0));\n    lights += light(move(1) + p + distortion * 0.2, vec2(0.3), abs(sin(0.1 * iTime - 1.0)) * 0.1, vec4(0.1, 0.2, 0.8, 1.0));\n    lights += light(move(2) + p - distortion * 0.2, vec2(-0.4, 0.1), 0.07 * abs(cos(0.15 * iTime + 2.0)), vec4(0.4, 0.6, 0.8, 1.0));\n\n    // Output to screen\n    fragColor = lights;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 196], [198, 198, 224, 224, 622], [676, 676, 701, 701, 950], [952, 952, 1013, 1013, 1065], [1067, 1067, 1085, 1085, 1205], [1207, 1207, 1264, 1264, 2284]], "test": "valid"}
{"id": "ftcGWj", "name": "The Goo Machine", "author": "JupiterDude", "description": "Cosine of Cosine Of Cosine...", "tags": ["cosine"], "likes": 5, "viewed": 96, "published": "Public", "date": "1636680894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define PI2 6.283185307179586476925286766559\n#define PI4 12.566370614359172953850573533118\n\n\nfloat func(float a) {\n    return cos(a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec2 cv = vec2(uv.x - .5, uv.y - .5); // uv * .5;\n    float dist = 1.0 - distance(cv, vec2(0.0,0.0));\n    dist = dist * dist * dist;\n\n    #define COUNT 6\n    // int count = 6;\n    float phases[COUNT];\n    float speeds[COUNT];\n    float amps[COUNT];\n    float ph = -2.0;\n    float sp = .40;\n    float amp = .10;\n    float phSign = 1.0;\n    float spSign = -1.0;\n    for (int a=0; a<COUNT; a++ ){\n        phases[a] = ph;\n        speeds[a] = sp;\n        amps[a] = amp;\n        amp *= .995;\n        ph *= 1.02 * phSign;\n        sp *= 1.002 * spSign;\n        phSign *= -1.0;\n        spSign *= -1.0;\n    }\n    float z = 0.0;\n    float z0 = 0.0;\n    float z1 = 0.0;\n    float x0 = uv.x;\n    float y0 = uv.y;\n    for(int a=0; a<COUNT; a++ ) {\n        z0 = func(z1 + x0 + uv.x * PI * phases[a] - iTime * speeds[a] +\n                func(z0 + y0 + uv.y * PI * phases[a] + iTime * .1) + iTime * amps[a]\n                );\n        z1 = func(z0 + y0 + uv.x * PI * phases[a] - iTime * .1 +\n                func(z1 + x0 + uv.y * PI * phases[a] + iTime * speeds[a]) + iTime * amps[a]\n                );\n        x0 = z1;\n        y0 = z0;\n    }\n    z0 = z0 * .5 + .5;\n    z1 = z1 * .5 + .5;\n    z = z0 + z1;\n    //z *= dist;\n\n    cv *= 2.0;\n    cv = abs(cv);\n    float r = z * cv.x;\n    float g = z * cv.y;\n    float b = (dot(vec2(z0 + cos(iTime), z1 + sin(iTime)), cv.xy) * 1.0);\n\n    fragColor = vec4(r, g, b, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 159, 159, 180], [182, 182, 237, 237, 1683]], "test": "valid"}
{"id": "ftd3D2", "name": "fork-Persian carpet 18-jf-v2", "author": "jorge2017a2", "description": "fork-Persian carpet 18-jf-v2", "tags": ["forkpersiancarpet18jfv2"], "likes": 3, "viewed": 15, "published": "Public", "date": "1636751848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///fork\n//https://www.shadertoy.com/view/fl3GDB\n//Created by jarble in 2021-11-11\n///modificado por jorge2017a2\n\n\n//change these constants to get different patterns!\n#define c2 0.05\n\n#define cB1 0.0\n#define cB2 0.01\n#define cB3 0.05\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n#define cA1 vec4(3.0+cB1,2.5+cB1,1.5,0)\n#define cA2 vec4(3.0+cB2,2.5+cB2,1.5,0)\n#define cA3 vec4(3.0+cB3,2.5+cB3,1.5,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{   //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale)\n{    return abs(fract((a+c1.xy)*scale)-.5); }\n\nvec2 triangle_wavePC(vec2 a,float scale, vec4 Pc)\n{  return abs(fract((a+Pc.xy)*scale)-.5);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    float tfijo=8.67;\n    float ti=iTime;\n    uv += vec2(18.67/2.0+ti,18.67/3.0+ti*0.5)/t1/8.0;\n    float t2 =tfijo;\n    \n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n\n    float offset = .5;\n    float scale2 = 1.5;\n\n    vec2 va1;\n    vec2 va2;\n\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++)\n            {\n                uv /= -scale2;\n                vec2 tmp1=uv.yx-offset;\n                vec2 tmp2=uv;\n                vec2 tv2= triangle_wavePC(tmp2,scale, cA3);\n                uv.yx=tv2;\n                va1=vec2(random1[k]*random1[0],random2[k]);\n                va2=vec2(random1[k],random2[k]);   \n                uv +=mix( va1, va2, sin(ti));\n            }\n\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n            col[c] = abs((uv.x)-(uv.y));\n         }\n\t}\n\n    fragColor = vec4(vec3(col*2.),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 502, 524, 568, 701], [703, 703, 743, 743, 787], [789, 789, 840, 840, 881], [883, 883, 940, 940, 2047]], "test": "valid"}
{"id": "ftd3DX", "name": "terrain 2?", "author": "yonatan", "description": "very fake trees and a lot of artifacts", "tags": ["terrain", "short"], "likes": 12, "viewed": 276, "published": "Public API", "date": "1636845394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n#define r iResolution.xy\n#define t iTime\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n    for(float i,e,g,s;i++<50.;g+=e*.5){\n        vec3 c=vec3(4.4,5,5.6),n,p=vec3((FC.xy-.5*r)/r.y*g,g);\n        p.zy*=R(.4+sin(t/3.)*.2);\n        s=1.4;\n        p.z+=t;\n        for(e=++p.y;s<1e3;s*=1.7)\n            p.xz*=R(s),\n            n.xz*=R(s),\n            n+=cos(p*s),\n            e+=sin(p.x*s)/s/2.;\n        n.y=.2;\n        n/=length(n);\n        e-=n.y;\n        c.x+=n.y*3.;\n        o.rgb+=mix(exp(n.z-c),c/3e2,min(g/9.+e,1.4));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 131, 131, 590]], "test": "valid"}
{"id": "ftd3zH", "name": "Rainbow Storm", "author": "R3N", "description": "Color hue of fractal noise with chromatic aberration to separate the colors at the edges.", "tags": ["noise", "color", "rainbow", "acid"], "likes": 7, "viewed": 183, "published": "Public API", "date": "1635972705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\n// color hue based on IQ's palettes\nvec3 col(float t) {\n    return 0.5+0.5*cos(2.0*pi*(t+vec3(0, 0.33, 0.67)));\n}\n\n// random number between 0 and 1\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n// value noise\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\n// fractal noise\nfloat fbm(vec2 p) {\n    float a = 0.5;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r += a*noise(p);\n        a *= 0.5;\n        p *= 2.0;\n    }\n    return r;\n}\n\n// main effect\nvec4 eff(vec2 uv) {\n\tuv *= 10.0;\n\tuv *= rot(length(0.1*uv)*1.25);\n\tuv.y -= iTime*0.75;\n\treturn vec4(col(3.0*fbm(uv/4.0+iTime*0.1+fbm(2.5*uv-iTime*0.1+fbm(uv/10.0)))), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= iResolution.xy/iResolution.y/2.0;\n    vec4 col = eff(uv);\n    float aberration = 1.015 + 0.2*smoothstep(-1.0, 1.0, sin(0.25*iTime));\n    col.r = eff(uv/aberration).r;\n    col.b = eff(uv*aberration).b;\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 109, 128, 128, 186], [188, 221, 241, 241, 301], [303, 318, 339, 339, 577], [579, 596, 615, 615, 770], [772, 787, 806, 806, 961], [963, 963, 1020, 1020, 1293]], "test": "valid"}
{"id": "ftd3zX", "name": "- liquid -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["fractal", "noise", "fbm", "water", "smoke", "metal", "liquid"], "likes": 14, "viewed": 270, "published": "Public API", "date": "1636466131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.99, 78.233))) * 43758.545);\n}\n\nfloat noise(vec2 p) {\n    vec2 f = fract(p);\n    f = f * f * f * f * (3. - 2. * f) * (3. - 2. * f);\n    vec2 i = floor(p);\n    float r1 = rand(i);\n    float r2 = rand(i + vec2(1, 0));\n    float r3 = rand(i + vec2(0, 1));\n    float r4 = rand(i + vec2(1, 1));\n    return mix(r1, r2, f.x) + mix((r3 - r1) * f.y, (r4 - r2) * f.y, f.x);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.;\n    float a = 1.;\n    for(int i = 0; i < 4; ++i) {\n        p = 1.5 * p + 15.;\n        a *= 0.5;\n        v += a * noise(p);\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 2. * fragCoord.xy / iResolution.y;\n    \n    vec2 r1 = vec2(fbm(p + 0.02 * iTime), fbm(p + 0.005 * iTime));\n    vec2 r2 = vec2(fbm(p + 0.15 * iTime + 10. * r1), fbm(p + 0.12 * iTime + 12. * r1));\n\n    fragColor = vec4(1.6 * pow(fbm(p + r2), 2.) + 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 109, 109, 421], [423, 423, 442, 442, 605], [607, 607, 662, 662, 930]], "test": "valid"}
{"id": "ftdGDB", "name": "SDF Quadratic Bézier Shape", "author": "DrNoob", "description": "Signed distance function for a shape made out of quadratic Bézier curves. In the tradition of iq's series such as this one: https://www.shadertoy.com/view/MlKcDD.", "tags": ["sdf", "bezier", "spline", "quadratic", "shape", "controlpolygon"], "likes": 10, "viewed": 105, "published": "Public", "date": "1636707948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: SDF Quadratic Bézier Shape\n//\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Signed distance function for a shape made out of quadratic\n// Bézier curves in the tradition of iq's series such as this\n// one: https://www.shadertoy.com/view/MlKcDD.\n//\n// The only real contribution of this shader is that it postpones\n// the call to the costly Bézier SDF up until the point it has\n// identified the closest segment of the control polygon.\n// So instead of iterating over all Bézier curves, we iterate\n// over the line segments of the control polygon and identify the\n// closest segment. We then call the Bézier SDF for this segment\n// only. This approach is correct since quadratic Bézier curves\n// are always contained in the triangle formed by its three\n// control points.\n\n// Constants\nconst int CAPACITY = 32; // Control polygon capacity\nconst float INF   = 1.0 / 0.0;\nconst float SQRT3 = 1.732050807568877;\n\n// Cross-product of two 2D vectors\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\n// Clamp a value to [0, 1]\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\nvec3 saturate(in vec3 a) {\n    return clamp(a, 0.0, 1.0);\n}\n\n// Minimum of the absolute of two values\nfloat abs_min(float a, float b) {\n    return abs(a) < abs(b) ? a : b;\n}\n\n// SDF for a line segment\nfloat sdf_line(in vec2 p, in vec2 a, in vec2 b) {\n    float h = saturate(dot(p - a, b - a) /\n                       dot(b - a, b - a));\n    return length(p - a - h * (b - a));\n}\n\n// Like the SDF for a line but partitioning space into positive and negative\nfloat sdf_line_partition(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    vec2 k = pa - h * ba;\n    vec2 n = vec2(ba.y, -ba.x);\n    return (dot(k,n) >= 0.0) ? length(k) : -length(k);\n}\n\n// Signed distance to a quadratic Bézier curve\n// Mostly identical to https://www.shadertoy.com/view/MlKcDD\n// with some additions to combat degenerate cases.\nfloat sdf_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    const float EPSILON = 1e-3;\n    const float ONE_THIRD = 1.0 / 3.0;\n\n    // Handle cases where points coincide\n    bool abEqual = all(equal(A, B));\n    bool bcEqual = all(equal(B, C));\n    bool acEqual = all(equal(A, C));\n    \n    if (abEqual && bcEqual) {\n        return distance(pos, A);\n    } else if (abEqual || acEqual) {\n        return sdf_line_partition(pos, B, C);\n    } else if (bcEqual) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    // Handle colinear points\n    if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < EPSILON) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) * ONE_THIRD;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if (h >= 0.0) {\n        // One root\n        h = sqrt(h);\n        vec2 x = 0.5 * (vec2(h, -h) - q);\n        vec2 uv = sign(x) * pow(abs(x), vec2(ONE_THIRD));\n        float t = saturate(uv.x + uv.y - kx) + EPSILON;\n        vec2 q = d + (c + b*t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0*b*t, q);\n    } else {\n        // Three roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0)) * ONE_THIRD;\n        float m = cos(v);\n        float n = sin(v) * SQRT3;\n        vec3 t = saturate(vec3(m+m,-n-m,n-m)*z-kx) + EPSILON;\n        vec2 qx = d + (c+b*t.x)*t.x;\n        float dx = dot(qx, qx);\n        float sx = cross2(c+2.0*b*t.x, qx);\n        vec2 qy = d + (c+b*t.y)*t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c+2.0*b*t.y, qy);\n        res = (dx < dy) ? dx : dy;\n        sgn = (dx < dy) ? sx : sy;\n    }\n    \n    return sign(sgn) * sqrt(res);\n}\n\n// Signed distance to a segment of a control polygon\nfloat sdf_control_segment(in vec2 p, in vec2 A, in vec2 B, in vec2 C) {\n    return abs_min(sdf_line(p, A, B), sdf_line(p, B, C));\n}\n\n// Signed distance to a control polygon\n// Identifies and returns distance to the closest segment.\nfloat sdf_control_polygon(in vec2 p, in vec2 controlPoly[CAPACITY], in int controlPolySize, out vec2 closest[3]) {\n    // Cycle through segments and track the closest\n    float d = INF;\n    float ds = 0.0;\n\n    // First n-2 segments\n    vec2 c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    vec2 prev = c;\n    for (int i = 1; i < controlPolySize - 1; ++i) {\n        prev = c;\n        c = 0.5 * (controlPoly[i] + controlPoly[i+1]);\n        ds = sdf_control_segment(p, prev, controlPoly[i], c);\n        if (abs(ds) < abs(d)) {\n            closest[0] = prev;\n            closest[1] = controlPoly[i];\n            closest[2] = c;\n            d = ds;\n        }\n    }\n\n    // Last-but-one segment\n    prev = c;\n    c = 0.5 * (controlPoly[controlPolySize-1] + controlPoly[0]);\n    ds = sdf_control_segment(p, prev, controlPoly[controlPolySize-1], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[controlPolySize-1];\n        closest[2] = c;\n        d = ds;\n    }\n\n    // Last segment\n    prev = c;\n    c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    ds = sdf_control_segment(p, prev, controlPoly[0], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[0];\n        closest[2] = c;\n        d = ds;\n    }\n    \n    // Return distance\n    return d;\n}\n\n// Signed distance to a quadratic Bezier shape made from a given control polygon\nfloat sdf_bezier_shape(in vec2 p, in vec2 controlPoly[CAPACITY], in int controlPolySize) {\n    // Determine closest segment in control polygon\n    vec2 closest[3];\n    sdf_control_polygon(p, controlPoly, controlPolySize, closest);\n\n    // Refine by determining actual distance to curve of closest segment\n    return sdf_bezier(p, closest[0], closest[1], closest[2]);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Mouse coordinates\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Control polygon animation\n    float off = sin(iTime);\n    const float R = 0.7071;\n    \n    // Control polygon\n    const int SIZE = 8;\n    vec2 controlPoints[CAPACITY];\n    controlPoints[0] = vec2(-0.75, -0.75);\n    controlPoints[1] = vec2( 0.0 , -0.75) + vec2(0.0, -off) * R;\n    controlPoints[2] = vec2( 0.75, -0.75);\n    controlPoints[3] = vec2( 0.75,  0.0 ) + vec2(off, 0.0) * R;\n    controlPoints[4] = vec2( 0.75,  0.75);\n    controlPoints[5] = vec2( 0.0 ,  0.75) + vec2(0.0, off) * R;\n    controlPoints[6] = vec2(-0.75,  0.75);\n    controlPoints[7] = vec2(-0.75,  0.0 ) + vec2(-off, 0.0) * R;\n\n    // Distance to shape\n    float d = sdf_bezier_shape(p, controlPoints, SIZE);\n    \n    // Distance field\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,-1.0);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n    \n    // Shape\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)));\n    \n    // Control polygon\n    if (cos(iTime) > 0.0) {\n        vec2 closest[3];\n        d = sdf_control_polygon(p, controlPoints, SIZE, closest);\n        d = min(d, length(p-closest[1])-0.02);\n        col = mix(col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d));\n    }\n    \n    // Distance to mouse position as circle\n    if (iMouse.z > 0.001) {\n        d = sdf_bezier_shape(m, controlPoints, SIZE); \n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGDB.jpg", "access": "shaders20k", "license": "mit", "functions": [[1952, 1987, 2023, 2023, 2055], [2057, 2084, 2112, 2112, 2145], [2146, 2146, 2172, 2172, 2205], [2207, 2248, 2281, 2281, 2319], [2321, 2347, 2396, 2396, 2524], [2526, 2603, 2662, 2662, 2870], [2872, 3032, 3096, 3096, 5014], [5016, 5069, 5140, 5140, 5200], [5202, 5301, 5415, 5467, 6621], [6623, 6704, 6794, 6846, 7072], [7074, 7074, 7129, 7154, 8893]], "test": "error"}
{"id": "ftdGDr", "name": "jneen - 25min practice", "author": "jneen", "description": "practice n stuff", "tags": ["jneen"], "likes": 2, "viewed": 67, "published": "Public", "date": "1635998018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float G=0.;\nfloat box(vec3 p,vec3 a){vec3 q=abs(p)-a;return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));}\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\n#define time (iTime*2.)\n\nfloat scene(vec3 p) { \n      //p.xy *= rot(-.0001*sin(3.14+2.*time));\n      p.xz *= rot(time*.0001);\n      p.x+=1.;\n      p.y+=5.*(.5+.5*sin(time));\n\n\n  float bg = p.y+5.*(.5+.5*sin(time));\n    \n   p.x += 5.*sin(2.*time);\n    \n    \n  float per=15.;\n  p.xz = mod(p.xz,per)-.5*per;\n  p.xz *= rot(time);\n  p.xy *= rot(.2*time);\n  float sph = length(p)-2.;\n  float B = box(p, vec3(2));\n \n  float solid = mix(sph,B,2.*sin(iTime));\n  \n  solid = max(solid,-(length(p.yz)-2.5));\n  float glowy =max(-solid,solid -1.);\n  if (solid>.1) G += max(0.,-glowy);\n  glowy = abs(glowy)+.001;\n  \n\n  \n  return min(bg,glowy);//min(sph,glowy);\n}\n\nfloat ray(vec3 p, vec3 rd){\nG=0.;float d=0.; for (int i=0;i<400;i++){float c=scene(p+d*rd);d+=c;if(c<.001||d>1000.)return d;}return d;}\n\nvec3 grad(vec3 p){\nmat3 k=mat3(p,p,p)-mat3(.001);\nreturn scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2]));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam=vec3(0,0,20.*time);\n    vec3 dir=normalize(vec3(uv,1));\n    \n    float dist=ray(cam,dir);\n    float glow=G;\n    vec3 hit=cam+dir*dist;\n    vec3 norm=normalize(grad(hit));\n    vec3 refl = reflect(dir,norm);\n    float refldist = ray(hit+.01*refl,refl);float reflglow=0.;\n    if (dist<1000.) reflglow = G;\n    \n    \n    // Time varying pixel color\n    vec3 col = .2*mix(vec3(1,.4,.8)*glow,vec3(1,.1,.4)*reflglow,.1);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 37, 37, 109], [111, 111, 129, 129, 176], [203, 203, 224, 272, 825], [827, 827, 854, 854, 962], [964, 964, 982, 982, 1073], [1074, 1074, 1131, 1181, 1766]], "test": "valid"}
{"id": "ftdGRB", "name": "Rotating Gear Grid", "author": "Shane", "description": "Using cheap layering techniques to produce a faux extruded grid consisting of rotating gears.", "tags": ["2d", "grid", "gear", "cog", "layer", "faux"], "likes": 46, "viewed": 403, "published": "Public API", "date": "1636295818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Rotating Gear Grid\n    ------------------    \n    \n    Using cheap layering techniques to produce a faux extruded grid \n    consisting of rotating gears. No raymarching was harmed during the\n    making of this example, as they say. :)\n    \n    I love rotating cog patterns. The basic 2D grid versions are pretty\n    easy to code up, and there are heaps of examples on Shadertoy. Here, \n    I've provided the square and hexagon arrangements -- Both are pretty \n    common.\n\n    Just in case it isn't obvious, the point of this is to cheap out with \n    a few layers in order to give the impression that it's a 3D scene, \n    which it does, providing you don't look into it too much. While we're \n    at it, the code works fine, but I wouldn't pay too much attention to \n    that either. :) By the way, there are a various options below for \n    anyone interested in trying out different looks.\n    \n    A raymarched version is simple enough to produce, and I intend to put \n    one of those up later.    \n\n    Due to the layout, it'd be possible to combine this with a moving \n    Truchet pattern to make something interesting, but I'll leave that as \n    an exercise. :)\n    \n    \n    \n    Similar examples:\n    \n    // Fabrice has examples of almost everything on here. :)\n    gear field - hexagonal tiling 7 - FabriceNeyret2\n    https://www.shadertoy.com/view/lsKSRt\n    \n\n*/\n\n\n// Hexagon grid arrangement.\n#define HEXAGON\n\n// Color scheme: Evening: 0, Sepia: 1, Pink: 2, Dawn: 3, Green: 4.\n#define COLOR 0\n\n// Texture the scene.\n#define TEXTURE\n\n// Use a second style of cog.\n//#define COG2\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Hacky global angular position for the cog... I'll tidy this later.\nvec2 gA;\n\n\nfloat cogs(vec2 p, vec2 ip) {\n    \n    // Time: You could just have a simple linear time value, but I thought it'd\n    // be interesting the sinusoidally reverse direction. Hence the following.\n    float tm = iTime/8.;\n    float ftm = floor(tm); // Integer time.\n    float frtm = tm - ftm; // Fractional time.\n    float tDir = mod(ftm, 2.)*2. - 1.; // Reversing direction every second.\n    tm = tDir*(sin(frtm*3.14159)*.5 + .5)*6.2831*2.; // Reversed sinusoidal motion.\n    \n    // Cog radius. \n    float rad = .44;\n    float cir = length(p); // Circle.\n    // Cog distance field.\n    float d = cir - rad;\n    \n    // Reversing the direction on alternate cogs in the grid. How you do it is \n    // up to you... I hacked the hexagon one for sure. I'm pretty sure Fabrice \n    // would have done it in a more elegant way, so I'd refer to his example.\n    #ifdef HEXAGON\n    float dir = mod(ip.x + mod(ip.y*2., 3.), 2.)==0.? -1. : 1.;\n    #else\n    float dir = mod(ip.x + ip.y, 2.)==0.? -1. : 1.;\n    #endif\n  \n    // Adding the teeth via polar coordinates.\n    vec2 q = p; \n    float aNum = 12.; // Teeth number.\n    // Time based movement.\n    q *= rot2(tm*dir - 3.14159/aNum/2.);\n    gA = q; // Hacky global angular position.\n   \n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.2831*aNum);\n    \n    #if 0\n    // A cheap, but effective way to produce teeth using AntoineC's formula, here:\n    // Planetary gears - https://www.shadertoy.com/view/MsGczV\n    // It's a really elegant example, by the way, but I'm using a more expensive \n    // method below. Anyway, the option to use it is here, if you're curious.\n    float teeth = .125/(1.1 + exp(3.*cos(dir*tm - aNum*a)));\n    d = (d - teeth)/1.25;\n    #else\n    \n    a = (ia + .5)/aNum;\n    q *= rot2(-a*6.2831);\n    q.x -= rad;\n\n    // Outer teeth.\n    float teeth = mix(max(abs(q.x) - .12, abs(q.y) - .05), length(q.xy*vec2(.7, 1)) - .12, .35);\n    d = min(d, teeth); // Applying the teeth to the cog object.\n    #endif\n    \n    \n \n  \n    #ifdef COG2\n    // Use a solid center with a thin central ring taken\n    // out for the second cog style.\n    d = max(d, -(abs(cir - .34) - .005));\n    #else\n    // For the other style, chop out some holes to give it\n    // a more cartoonish look.\n    \n    // Six polar dispersed holes.\n    aNum = 6.;\n    vec2 q2 = p;\n    q2 *= rot2(tm*dir - 3.14159/aNum/4.);\n    a = atan(q2.y, q2.x);\n    ia = floor(a/6.2831*aNum);\n    a = (ia + .5)/aNum;\n    q2 *= rot2(-a*6.2831);\n    q2.x -= rad;\n    \n    // The small holes.\n    float innerCir = length(q2 - vec2(-.15, 0)) - .065;\n    //float innerCir = max(abs(cir - .285) - .045, -(abs(q2.y) - .07));\n    d = max(d, -innerCir); // Cutting them out.\n    #endif\n    \n    \n    // Cutting out the central hole.\n    d = max(d, -(cir - .14)); \n \n    \n    return d; // Return the cog distance.\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct pixel coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scene rotation.\n    float tm = mod(iTime/8., 2.);\n    \n    // Lens warping.\n    uv *= sqrt(max(1. - (.5 - dot(uv, uv))*.25, 0.));\n    \n    // Pixel rotation, which equates to a 2D camera rotation.\n    uv *= rot2(-sin(tm*3.14159)*2./8.);\n    \n    // Global zoom scale and smoothing factor.\n    float scl = 4.5;//4.5 + sin(tm*3.14159)*.5;\n    float sf = scl/iResolution.y;\n    \n    // The scaling is slightly different for hexagon grids and square ones.\n    #ifdef HEXAGON\n    vec2 sc = vec2(.8660254, 1);\n    #else\n    vec2 sc = vec2(1);\n    #endif\n    \n    // Scaling and translation.\n    vec2 p = uv*scl - vec2(-sc.x/2., 0) - vec2(sin(tm*3.14159)*sc.x*2., 0);\n    \n    \n    // Distance values for various samples:\n    // Distance, highlight, shadow and extrusion.\n    float d = 1e5, dHi = 1e5, dSh = 1e5, dEx = 1e5;\n    \n    // Saved cog ID.\n    vec2 id;\n    \n    // Light direction.\n    vec2 lgtDir = normalize(vec2(-2, -1));\n    \n    // Fake unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    // Saved cog position and angular position.\n    vec2 svP, svA;\n    \n    // Background pattern rivot values. This has been hacked in.\n    float bgPat = 1e5, bgPat2 = 1e5;\n    \n    // The cell shapes exceed the cell boundaries, which means covering all \n    // surrounding cells that the shape covers. In this case, there are 4.\n    // By the way, you could get away with two taps, if you really wanted to.\n    // However, the square grid 3D version would require all four.\n    for(int i = 0; i<=1; i++){\n        for(int j = 0; j<=1; j++){\n          \n            // Local cell coordinates and cell ID.\n            vec2 cntr = vec2(i, j) - .5;\n            vec2 q = p;\n            vec2 iq = floor(q/sc - cntr); \n            #ifdef HEXAGON\n            if(mod((iq.x), 2.)<.001) {\n               q.y += sc.y/2.;\n               iq = floor(q/sc - cntr); \n            }\n            #endif\n            q -= (iq + .5)*sc; \n            \n            // Extruded \"q\" position. This is a hacky estimate, but it's\n            // enough to fool the eyes, provided you don't look too hard. :)\n            vec2 qEx = q + rd.xy*.2/(1. + length(uv)*1.5);\n            \n            \n            // Producing distance fields for the rivots and highlights\n            // on the hexagon arrangement... I've hacked it in the middle\n            // of the loop out of sheer laziness, but you could produce\n            // this outside.\n            #ifdef HEXAGON\n            vec2 miq = mod(iq, vec2(2, 3));\n            if((miq.x + miq.y)==0. || (miq.x*miq.y)==1.){\n           \n                vec2 rdd = lgtDir*.01;\n                float hx = length(qEx);\n                float hx2 = length(qEx - rdd);\n                bgPat = min(bgPat, (hx - .1));\n                bgPat2 = min(bgPat2, (hx2 - .1));\n                 \n                // After rendering producing the rivot field,\n                // skip the cog field construction.\n                continue;\n            }\n            #endif\n\n           \n            // Some distance field samples.\n            //\n            // // Top layer.\n            float cg = cogs(q, iq); \n            // Store the closest distance.\n            if(cg<d) { d = cg; id = iq; svP = q; svA = gA; }\n            // Extruded.\n            dEx = min(dEx, cogs(qEx, iq));\n            // Shadow.\n            dSh = min(dSh, cogs(qEx - lgtDir*.135, iq));\n            // Highlight.\n            dHi = min(dHi, cogs(q - lgtDir*.01, iq));            \n             \n            \n         }\n    }\n    \n    \n    // Random number based on the cog ID.\n    float rnd =  hash21(id);\n    \n    // Lit background.\n    vec3 bg = mix(vec3(.6), vec3(.4), clamp(dot(rd.xy, lgtDir), 0., 1.));\n\n    // Changing the background color, depending on the palette.\n    #if COLOR == 0\n    bg *= vec3(.7, .85, 1);\n    #elif COLOR == 1\n    bg *= vec3(.77, .64, .5);\n    bg *= vec3(1.2, 1, .8);\n    #elif COLOR == 2\n    bg *= vec3(.45, .5, .55);\n    #elif COLOR == 3\n    bg *= vec3(1, .85, .7);\n    #endif\n\n\n    #ifdef TEXTURE\n    // Background texture.\n    // The textured plane is technically at the extruded \"p\" position.\n    vec2 pEx = p + rd.xy*.2/(1. + length(uv)*1.5);\n    vec3 tx = texture(iChannel0, (pEx + 2.)/4.).xyz; tx *= tx;\n    tx = smoothstep(-.05, .5, tx);\n    tx = min(tx*2., 1.5);\n\n    // Cog texture.\n    #ifdef COG2\n    // If using the second cog style, keep the center texture coordinates\n    // static and let the outer coordinates rotate.\n    svA = mix(svP, svA, smoothstep(0., sf, abs(length(svP) - .24) - .07));\n    #endif\n    //\n    vec3 tx2 = texture(iChannel0, svA/4. + rnd/4.).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.05, .5, tx2);\n    tx2 = min(tx2*2., 1.5);\n    \n    #else\n    // When not texturing, set the value to one.\n    vec3 tx = vec3(1);\n    vec3 tx2 = vec3(1);\n    #endif\n    \n    // If applicable, apply the texture to the background.\n    bg *= tx;\n\n    \n    // Initiate the scene color to the background.\n    vec3 col = bg;\n    \n    // Apply the circle rivots to the backgournd.\n    float b = max(bgPat2 - bgPat, 0.)/.01;\n    col = mix(col, bg*1.5, (1. - smoothstep(0., sf*24., bgPat))*.25);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., bgPat))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, bgPat));\n    col = mix(col, bg/2.*(1. + b) + b*.25*2., 1. - smoothstep(0., sf, bgPat + .025));\n    col = mix(col, bg/2.*(1. + b) + b*.25, 1. - smoothstep(0., sf, bgPat + .025 + .025));\n    //col += col*b*vec3(1, 2, 4)*.2;\n\n\n    // Use the randomly generated cog ID and IQ's cosine palette formula\n    // to produce a cog color.\n    vec3 oCol = .5 + .45*cos(6.2831*rnd/8. + vec3(0, 1, 2));\n\n\n    // Color alternating cogs different colors or shades.\n    #ifdef HEXAGON\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.){\n    #else\n    if(mod(id.x + id.y, 2.)<.001){\n    #endif\n\n        oCol = mix(oCol, oCol.zyx, .6);\n        #if COLOR == 3\n        oCol = oCol.zyx;\n        #endif\n    } \n    #if COLOR == 4\n    else {\n        oCol = mix(oCol, oCol.yxz, .75);\n        //oCol = mix(oCol, oCol.yxz, dot(sin(p/1.5 + cos(p/.75)*1.57), vec2(.25)) +.5);\n    }\n    #endif\n\n\n\n    #if COLOR == 1\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.)\n        oCol = vec3(.55, .5, .44)*dot(oCol, vec3(.299, .587, .114));\n    else oCol = vec3(.9, .8, .7)*mix(oCol, oCol.zyx, .25);\n    oCol *= vec3(1.15, 1, .85);\n    #elif COLOR == 2\n    oCol = (mix(oCol.xzy, vec3(1, .15, .3), .5)*1.5);\n    //if(mod(id.x + 1., 4.)<=1.) oCol = oCol.zyx;\n    //if(hash21(id + .21)<.5) oCol = oCol.zyx;\n    oCol = mix(oCol, oCol.zyx, dot(sin(p/1.5 + cos(p/.75)*1.57), vec2(.35)) +.5);\n    #ifdef HEXAGON\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.){\n    #else\n    if(mod(id.x + id.y, 2.)<.001){\n    #endif\n        oCol = vec3(.4)*dot(oCol, vec3(.299, .587, .114));\n        oCol *= vec3(.9, 1, 1.1);\n    }\n    #endif\n\n    // Apply the second texture value to the cog color.\n    oCol *= tx2;\n\n\n    // Rendering.\n\n\n    // Sample differnces for highlights.\n    float sh = max(dHi - d, 0.)/.01;\n    float sh2 = max(d - dHi, 0.)/.01;\n\n    // Rotated top face highlight.\n    //vec2 svQ = -rot2(atan(lgtDir.x, lgtDir.y))*svP;\n    //float sh3 = mix(0., 1., smoothstep(0., .25, svQ.x));\n\n\n    // Render the layers in order.\n    //\n    // Extruded AO, extruded edge and extruded layer itself.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*12., dEx - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dEx - .02))*.95); \n    col = mix(col, oCol/2. + sh*.25, (1. - smoothstep(0., sf, dEx + .005))); // oCol/2.\n\n    // Laying the shadow down over the background and extruded section.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dSh - .015))*.5);\n\n\n    // Top layer edge, edge highlight and colored center.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d))*.95);\n    col = mix(col, oCol + sh*.5, (1. - smoothstep(0., sf, d + .025))*.95);\n    //\n    #ifdef COG2\n    // For the second cog style, brighten the outside and darkent the center.\n    oCol = mix(oCol*1.3, oCol/1.4, (1. - smoothstep(0., sf, abs(length(svP) - .24) - .07)));\n    #endif\n    col = mix(col, oCol + sh*.25, 1. - smoothstep(0., sf, d + .025+.025));\n\n\n    // Debug grayscale value.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n\n    // Vignette. \n    col *= max(1.1 - length(uv)*.25, 0.);\n\n\n    // Rought gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1605, 1638, 1660, 1660, 1718], [1720, 1748, 1769, 1769, 1831], [1914, 1914, 1943, 2107, 4742]], "test": "error"}
{"id": "ftdGWr", "name": "Wavy micro tile", "author": "xZAKHAMx", "description": "just another micro tile to get familiar with glsl. ", "tags": ["microtiles"], "likes": 4, "viewed": 107, "published": "Public API", "date": "1635991469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p  = -1.0 + 2.0*uv; \n    \n    float pha = 1.0;\n    float div = 0.5;\n    float scale = 0.5;\n    float num = 10.0;\n    float xsine = sin(p.x + iTime*pha);\n    vec3 col = vec3 (0.0);    \n    \n    float wave = round(mod(abs(xsine - p.y), div)*num*(1.0/scale))*(1.0/num);\n    \n    col = vec3(wave);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 463]], "test": "valid"}
{"id": "ftdGzH", "name": "spqr: material", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 3, "viewed": 99, "published": "Public API", "date": "1636006306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\nfloat ink(vec2 uv) {\n\n  return m2(uv);\n}\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\nfloat map(vec3 p) {\n\n// geo\n\n  p.xz -= 50.;\n  vec3 q1 = rep(p, vec3(21,0,21));\n\n  float bb = box(q1, vec3(.03,.23,.03));\n \n\n \n  //vec3 q2 = rep(p + vec3(0,0,iTime * 15.), vec3(21,0,21));\n  //float sph = sph(q2, 4.1);\n \n  \n \n  p = abs(p)- 100.;\n   p = rep(p, vec3(0.,50.,0.));\n  float ground = box(p, vec3(100,4,100));\n  \n  //float plane = smin(ground,sph,10.2);\n  float plane = ground;\n  float final = min(bb, plane);\n \n  if ( bb == final) {\n    matter = 2;\n  }\n  if ( plane == final ) {\n    matter = 1;\n  }\n  \n  return final;\n \n}\n/*\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n*/\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  for (int z = 0; z < 2; z++) {\n    r = smoothstep(0.,1.,r);\n  }\n  \n  return i + r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  float tt = iTime;\n  vec3 s = lattice(tick(tt * 1.)) * 275.91;\n  vec3 t = lattice(tick(tt * 4.)) *  45.71;\n  vec3 arm = vec3(530,0,0);\n  arm.xz *= rot(iTime);\n  arm.yz *= rot(iTime * .71);\n  arm.xy *= rot(iTime * .41);\n  \n  t += arm;\n  t.xy *= .5;\n \n\n  \n  //s = vec3(0.,iTime * 44.21,0);\n  //vec3 arm = vec3(1,1,.11);\n  //t = s + arm;\n  \n  //s = vec3(10,200,10);\n  //t = vec3(0);\n  \n  \n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z < 300.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n      float i = ink(mod(p.xz,150.));\n      if (i > .2) {\n        d = .1;\n      } else {\n        hit = true;\n        break;\n      }\n    }\n    if ( dd > 5000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n \n  vec3 col;\n  \n  if ( matter == 1) {\n    float i = ink(mod(p.xz,150.));\n    col = vec3(1);\n    if ( i < .3) {\n      col = vec3(0);\n    }\n    if (i < -.0) {\n      col =  vec3(.8,.4,.2);\n      //col = pow(col, vec3(.75));\n    }\n    \n\n  }\n  if (matter == 2) {\n    col = vec3(.5);\n  }\n  \n \n\n  \n  vec3 light =normalize(vec3(4,12.,2.));\n  light.xz *= rot(iTime);\n\n  light = abs(light);\n  \n \n  vec3 n = norm(p);\n  \n  float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  //float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n\n;\n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0.,.2,1.)));\n    per = pow(per,2.);\n    col =   mix(  vec3(.5), vec3(.5) * .3,per);\n    \n  }\n\n  fragColor = vec4(col, 1);\n\n\n\n  /*\n  uv *= rot(iTime);\n  uv *= 250.;\n  uv *=  sin(iTime * 1.)/ 1. + .2;\n  float d = ink(uv);\n  vec3 col;\n  col = vec3(.7);\n  \n  if ( d < .2) {\n    col = vec3(0);\n  }\n  if (d < 0.) {\n    col = vec3(1.,.34,.32);\n  }\n\n  col += glow * 400.5;\n  fragColor = vec4( col, 1.);\n\n  */\n  \n}\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 301, 301, 370], [374, 374, 403, 403, 451], [454, 454, 501, 501, 547], [549, 549, 568, 568, 1127], [1166, 1166, 1185, 1185, 1580], [1582, 1582, 1602, 1602, 1622], [1626, 1626, 1653, 1653, 1721], [1723, 1723, 1751, 1751, 1775], [1776, 1776, 1805, 1805, 1892], [1893, 1893, 1935, 1935, 2042], [2044, 2044, 2072, 2072, 2098], [2100, 2100, 2128, 2128, 2161], [2164, 2164, 2211, 2211, 2257], [2261, 2261, 2302, 2302, 2470], [2473, 2473, 2494, 2494, 2785], [2787, 2787, 2806, 2806, 2914], [2916, 2916, 2955, 2955, 3032], [3034, 3034, 3070, 3070, 3148], [3150, 3150, 3170, 3170, 3264], [3287, 3287, 3311, 3311, 3366], [3370, 3370, 3391, 3391, 3440], [3442, 3442, 3467, 3467, 3936], [3961, 3961, 3980, 3988, 4491], [4492, 4846, 4865, 4865, 4984], [4986, 4986, 5027, 5027, 5073], [5075, 5075, 5111, 5111, 5156], [5158, 5158, 5178, 5178, 5221], [5223, 5223, 5242, 5242, 5321], [5323, 5323, 5345, 5345, 5475], [5476, 5476, 5533, 5533, 8025]], "test": "valid"}
{"id": "ftdGzN", "name": "Fractal tiling", "author": "jarble", "description": "A tessellated geometric pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 134, "published": "Public API", "date": "1635798782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(1.0+c2,.5+c2,-1.5,0)\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = iTime/8.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/12.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/6.;\n    float scale = c1.z;\n    for(int j = 0; j < 18;j++){\n        uv = (triangle_wave(uv.yx+scale,scale)+triangle_wave(uv,scale));\n        col[0] += fract(uv.x*.5-uv.y);\n        col = abs(col.yzx*col.x)/(col.x+col.y);\n    }\n    fragColor = vec4(vec3(col),1.0);  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 147, 147, 192], [194, 194, 251, 251, 717]], "test": "valid"}
{"id": "ftG3Dw", "name": "Chamfered Box SDF", "author": "TheTurk", "description": "Distance function for a chamfered box.", "tags": ["distancefield", "sdf", "rectangle", "distance", "box", "rect", "primitive", "octagon", "chamfer", "chamfered"], "likes": 7, "viewed": 45, "published": "Public", "date": "1637769264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 position, vec2 halfSize, float chamferRadius) {\n   position = abs(position) - halfSize;\n   vec2 d1 = vec2(max(position.x + chamferRadius, 0.0), position.y);\n   vec2 d2 = vec2(position.x, max(position.y + chamferRadius, 0.0));\n   float k = clamp((position.x - position.y + chamferRadius) * 0.5, 0.0, chamferRadius);\n   vec2 d3 = position + vec2(chamferRadius - k, k);\n   float s = sign(max(d3.x, d1.y));\n   return sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3))) * s;\n}\n\nfloat box(vec2 position, vec2 halfSize, vec2 chamferRadius) {\n   position = abs(position) - halfSize;\n   vec2 d1 = vec2(max(position.x + chamferRadius.x, 0.0), position.y);\n   vec2 d2 = vec2(position.x, max(position.y + chamferRadius.y, 0.0));\n   position.x += chamferRadius.x; \n   vec2 end = vec2(chamferRadius.x, -chamferRadius.y);\n   vec2 d3 = position - end * clamp(dot(position, end) / dot(end, end), 0.0, 1.0);\n   float s = sign(max(d3.x, d1.y));\n   return sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3))) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    vec2 halfSize = vec2(0.55);\n    float chamferRadius = ((cos(iTime + 1.0) + 1.0) * 0.5) * 0.55 / (sqrt(2.0) + 1.0) * sqrt(2.0);\n    float d = box(position, halfSize, chamferRadius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n    if (iMouse.z > 0.001) {\n        vec2 mousePosition = iMouse.xy / iResolution.xy;\n        mousePosition = (mousePosition * 2.0) - 1.0;\n        mousePosition.x *= iResolution.x / iResolution.y;\n        float d = box(mousePosition, halfSize, chamferRadius);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.0025, abs(length(position - mousePosition) - abs(d)) - 0.0025));\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 488], [490, 490, 551, 551, 1013], [1015, 1015, 1070, 1070, 2142]], "test": "valid"}
{"id": "ftG3RK", "name": "new function of vierershtrass", "author": "polinasidiropoulou", "description": "colors added", "tags": ["functions"], "likes": 2, "viewed": 27, "published": "Public", "date": "1637945714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535897932384626433832795\n\nfloat veiershrass (float x){\n    float sum=0.0;\n    float a=0.056;\n    float b=0.044;\n    for(int i=0; i<100; i++){\n        // Time varying pixel color\n        sum += pow(0.5,float(i))*cos(pow(a,float(i))*pi*x);\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.25*veiershrass(uv.x*iTime)+0.5, cos(fragCoord*iTime));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 74, 74, 281], [283, 283, 340, 390, 570]], "test": "valid"}
{"id": "ftG3Wz", "name": "Anti-aliased ellipse", "author": "rpmalon", "description": "Method for approximating a point's distance from an ellipse for the purposes of anti-aliasing", "tags": ["ellipse"], "likes": 2, "viewed": 103, "published": "Public API", "date": "1637442938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//=======================================================================================================================\n//\n// The MIT License\n// Copyright © 2021 Ryan Malon\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//=======================================================================================================================\n//\n// Rendering an ellipse implicitly with anti-aliasing using an approximation of signed distance\n//\n// note: This does not work well for highly eccentric (flat) ellipses.\n//       However, this does not require any textures, root-finding, or conditionals.\n//       What you see is what you get.\n//\n// Ellipse representation\n//\n//   names are based on conventional ellipse values A, B, and C where:\n//     A is the length of the semi-major axis\n//     B is the length of the semi-minor axis\n//     C is the distance from the center of the ellipse to either of the foci\n//     these follow a Pythagorean triple, A^2 = B^2 + C^2\n//\n//   EllipseCenter: vector from center of coordinate space to center of the ellipse\n//                  you can easily write your vertex shader such that this is always (0, 0)\n//\n//   EllipseCVec:   vector from center of ellipse to one of the foci\n//                  i.e. one focus is at (EllipseCenter + EllipseCVec), the other is at (EllipseCenter - EllipseCVec)\n//                  this determines the orientation of the ellipse, and partially defines its eccentricity\n//\n//   EllipseB:      length of the ellipse's semi-minor axis\n//\n//=======================================================================================================================\n\nfloat ApproxDistanceToEllipse(vec2 QueryPoint, vec2 EllipseCenter, vec2 EllipseCVec, float EllipseB)\n{\n    QueryPoint = QueryPoint - EllipseCenter;\n    \n    float EllipseC = length(EllipseCVec);\n    float EllipseA = sqrt(EllipseC*EllipseC + EllipseB*EllipseB);\n    \n    float QueryA = (length(QueryPoint + EllipseCVec) + length(QueryPoint - EllipseCVec)) / 2.f;\n    float QueryB = sqrt(QueryA*QueryA - EllipseC*EllipseC);\n    \n    float CosTheta = dot(QueryPoint, normalize(EllipseCVec)) / QueryA;\n    \n    // I'm not sure which of these is better for anti-aliasing purposes.\n    // Maybe there's actually a better interpolation than Lerp, and we should use neither or both.\n    // Cosine^2 is clearly better (just looking at it) as distance from ellipse increases, which is exactly the cases we don't care about for anti-aliasing.\n    // I'm too lazy right now to implement the exact distance function and collect error metrics of both methods.\n    // If anyone reading this feels like doing that for some reason, \n    // you can find David Eberly's exact distance method at https://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf section 2.9.\n    // tl;dr just because the first option for LerpValue LOOKS better, doesn't mean that it is, but it might be, I haven't checked\n    float LerpValue = CosTheta * CosTheta;\n    //float LerpValue = abs(CosTheta);\n    \n    float Distanceish = mix(QueryB - EllipseB, QueryA - EllipseA, LerpValue);\n\n    return Distanceish;\n\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord )\n{\n    // turn off to see actual anti-aliasing\n    // turn on to see contours of approximated distance\n    bool ShowContours = bool(0);\n    \n    // FragCoord -> range [-iResolution / 2, iResolution / 2]\n    vec2 P = FragCoord - (iResolution.xy * 0.5f);\n    \n    // setup ellipse params\n    float pi = radians(180.f);\n    float CAngle = mod(iTime / 1.5f, 2.f*pi);\n    float CMag = mix(100.f, 200.f, abs(mod(iTime / 2.3f, 2.f) - 1.f));\n    \n    vec2  EllipseCVec = CMag * vec2(cos(CAngle), sin(CAngle));\n    float EllipseB = 50.f;\n    vec2  EllipseCenter = vec2(100.f*cos(iTime), 50.f*sin(iTime * 1.4));\n    \n    // stationary ellipse where major axis is X axis\n    if (ShowContours)\n    {\n        EllipseCVec = vec2(200.f, 0.f);\n        EllipseB = 50.f;\n        EllipseCenter = vec2(0.f, 0.f);\n    }\n    \n    // get approximate distance in pixels\n    float Distanceish = ApproxDistanceToEllipse(P, EllipseCenter, EllipseCVec, EllipseB);\n    \n    // do antialiasing using our approximate distance\n    float Antialias = 1.5;\n    float AntialiasMin = -(Antialias/2.f), AntialiasMax = Antialias/2.f;\n    float Alpha = 1.f - smoothstep(AntialiasMin, AntialiasMax, Distanceish);\n\n    // in actual use case, just use whatever texture or color you want for the ellipse\n    // and use the value of 'Alpha' for the alpha channel of FragColor\n    vec3 ColorOutsideEllipse = vec3(0,0.5,0.5);\n    vec3 ColorInsideEllipse = vec3(0,0.2,0.2);\n    vec3 Color = mix(ColorOutsideEllipse, ColorInsideEllipse, Alpha);\n    FragColor = vec4(Color, 1.f);\n    \n    // visualize distance contours\n    // contour coloring concept from https://www.shadertoy.com/view/tlSGzG\n    if (ShowContours)\n    {\n        float D = Distanceish/6.f;\n        float Darkness = 0.3;\n        vec3 ContourColor = vec3(1.0) - sign(D)*ColorInsideEllipse;\n        ContourColor *= 1.0 - exp(-2.0*abs(D));\n        ContourColor *= (1.f - Darkness) + Darkness*cos(D);\n        FragColor = vec4(ContourColor, 1.f);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3Wz.jpg", "access": "shaders20k", "license": "mit", "functions": [[2639, 2639, 2741, 2741, 4130], [4132, 4132, 4188, 4288, 6152]], "test": "valid"}
{"id": "ftG3zz", "name": "Woven frames", "author": "jarble", "description": "A series of frames stitched together.", "tags": ["fractal", "carpet", "frame", "rug"], "likes": 2, "viewed": 113, "published": "Public API", "date": "1637034358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/5.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 9; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                \n                uv.yx = -triangle_wave(uv.yx-offset,scale)/bend-triangle_wave(uv,scale)*bend;\n                //uv += uv.yx*col.x/2.;\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                //bend *= -1.;\n                //uv += vec2(random1[k],random2[k]);   \n                bend *= -1.;\n                //uv /= -1.0;\n                //scale -= .001;\n                \n            }\n            \n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(4.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2567]], "test": "valid"}
{"id": "ftGGWD", "name": "Slithering Worm", "author": "dr2", "description": "Colorful worm slithering (driven by pseudo-peristalsis)", "tags": ["snake", "motion", "coordinates", "transcendental"], "likes": 15, "viewed": 178, "published": "Public API", "date": "1637671169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Slithering Worm\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, tCyc, nCyc, segRot;\nconst float nSeg = 8.;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct Arc {\n  vec2 cs, css;\n  float chDist, ang, rad;\n};\nArc arc;\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Robotic Head\") \n  vec3 t;\n  vec2 f;\n  t.yz = vec2 (0.7, 1.2);\n  f = vec2 (F(t.y), F(t.z));\n  for (int nIt = 0; nIt < 4; nIt ++) {\n    t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n    t.zy = t.yx;\n    f = vec2 (F(t.x), f.x);\n  }\n  return t.x;\n}\n\nvoid ArcConf ()\n{\n  vec2 u;\n  float arcLen, arcEx, chLen, len, sep;\n  len = 2.;\n  sep = 1.;\n  arcEx = 1.;\n  arcLen = arcEx * length (vec2 (len, sep));\n  u = vec2 (len * sin (0.5 * segRot), sep);\n  chLen = length (u);\n  arc.ang = SecSolve (chLen / arcLen);\n  arc.chDist = chLen / tan (arc.ang);\n  arc.rad = sqrt (arc.chDist * arc.chDist + chLen * chLen);\n  arc.cs = sin (- arc.ang + vec2 (0.5 * pi, 0.));\n  arc.css = sin (- arc.ang - 0.002 + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cs;\n  float dMin, d, tRad, tBmp, s, da, rr, nc;\n  dMin = dstFar;\n  tRad = 0.5;\n  tBmp = 0.05;\n  da = 63. / (2. * arc.ang);\n  nCyc = floor (tCur / tCyc);\n  cs = sin (arc.ang * (1. - 2. * (tCur / tCyc - nCyc)) + vec2 (0.5 * pi, 0.));\n  p.y -= tRad + tBmp;\n  nc = floor (nCyc / 2.);\n  s = sign (nCyc - 2. * nc - 0.5);\n  rr = arc.rad * arc.cs.y;\n  p.x += (4. * nc + s - 2. - mod (nSeg, 2.)) * rr;\n  p.yz = p.zy;\n  p.xy *= vec2 (-1., s);\n  for (float k = float (VAR_ZERO); k < nSeg; k ++) {\n    q = p;\n    q.y *= - sign (mod (k, 2.) - 0.5);\n    q.xy -= vec2 (rr * (2. * k - nSeg + 0.5), - arc.chDist);\n    d = dot (vec2 (abs (q.x), q.y), arc.css);\n    d = max (length (vec2 (length (q.xy) - arc.rad, q.z)) - tRad + tBmp * (1. -\n       smoothstep (0.1, 0.4, 0.5 - abs (0.5 -  mod (da * (atan (q.x, q.y) / (2. * pi)), 1.)))), d);\n    if (k == 0. || k == nSeg - 1.) d = max (d, - sign (k - 0.5) * dot (q.xy, cs * vec2 (1., -1.)));\n    DMINQ (1);\n    if (k == 0. || k == nSeg - 1.) {\n      q.xy = Rot2Cs (q.xy, cs);\n      q.y -= arc.rad;\n      d = PrCapsDf (q.yzx, tRad + tBmp, 0.1);\n      DMINQ (2);\n    }\n  }\n  return dMin;\n}\n\nfloat GrObjDf (vec2 pg)\n{\n  vec3 p, q;\n  vec2 dkMin, cs;\n  float d, tRad, s, rr, nc;\n  dkMin = vec2 (dstFar, 0.);\n  tRad = 0.5 - 0.15;\n  nCyc = floor (tCur / tCyc);\n  cs = sin (arc.ang * (1. - 2. * (tCur / tCyc - nCyc)) + vec2 (0.5 * pi, 0.));\n  p.xz = pg;\n  p.y = 0.;\n  nc = floor (nCyc / 2.);\n  s = sign (nCyc - 2. * nc - 0.5);\n  rr = arc.rad * arc.cs.y;\n  p.x += (4. * nc + s - 2. - mod (nSeg, 2.)) * rr;\n  p.yz = p.zy;\n  p.xy *= vec2 (-1., s);\n  for (float k = float (VAR_ZERO) - 2. * nSeg; k < nSeg; k ++) {\n    q = p;\n    q.y *= - sign (mod (k, 2.) - 0.5);\n    q.xy -= vec2 (rr * (2. * k - nSeg + 0.5), - arc.chDist);\n    d = dot (vec2 (abs (q.x), q.y), arc.css);\n    d = max (length (vec2 (length (q.xy) - arc.rad, q.z)) - tRad, d);\n    if (k == - 2. * nSeg || k == nSeg - 1.) d = max (d, - sign (k - 0.5) *\n       dot (q.xy, cs * vec2 (1., -1.)));\n    if (d < dkMin.x) dkMin = vec2 (d, k);\n    if (k == - 2. * nSeg || k == nSeg - 1.) {\n      q.xy = Rot2Cs (q.xy, cs);\n      q.y -= arc.rad;\n      d = PrCapsDf (q.yzx, tRad, 0.1);\n      if (d < dkMin.x) dkMin = vec2 (d, k);\n    }\n  }\n  dkMin.y = 1. + min (dkMin.y / nSeg, 0.) / 2.;\n  return dkMin.y * step (dkMin.x, 0.);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  return 0.3 * Fbm2 (2. * p);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHtN (p.xz) - vec2 (GrndHtN (p.xz + e.xy),\n     GrndHtN (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hCol4, bCol4, sCol4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, nDotL, sh, s, f;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    bCol4 = vec4 (0.8, 0.6, 0.2, 0.2);\n    hCol4 = vec4 (0., 0.5, 1., 0.2);\n    sCol4 = vec4 (1., 1., 1., 0.3);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      qHit.xy = Rot2Cs (qHit.xy, sin (arc.ang * (1. - 2. * (tCur / tCyc - nCyc)) +\n         vec2 (0.5 * pi, 0.)));\n      s = abs (length (qHit.xy) - arc.rad);\n      f = Minv2 (Rot2D (0.5 - abs (0.5 - mod (4. * atan (qHit.xz, vec2 (qHit.y, s)) /\n         vec2 (arc.ang, pi), 1.)), 0.25 * pi));\n      col4 = mix (bCol4, hCol4, smoothstep (0., 0.03, f + 0.05));\n      if (qHit.z > 0.) col4 = mix (sCol4, col4, smoothstep (0., 0.03, s - 0.03));\n    } else if (idObj == 2) {\n      if (qHit.x > 0.) {\n        col4 = bCol4 * (0.3 + 0.7 * smoothstep (0., 0.03, PrRoundBox2Df (qHit.yz,\n           vec2 (0., 0.13), 0.02)));\n      } else {\n        col4 = bCol4 * (0.3 + 0.7 * smoothstep (0., 0.03, PrRoundBox2Df (qHit.yz -\n           vec2 (0., -0.2), vec2 (0.3, 0.), 0.02)));\n        col4 = mix (vec4 (1., 0., 0., -1.), col4, step (0.1,\n           length (vec2 (abs (qHit.y) - 0.2, qHit.z - 0.1))));\n      }\n      col4 = mix (hCol4, col4, smoothstep (0., 0.03, abs (abs (qHit.x) - 0.25) - 0.15));\n      if (qHit.z > 0. && abs (qHit.x) < 0.5) col4 = mix (sCol4, col4,\n         smoothstep (0., 0.03, abs (qHit.y) - 0.03));\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = 0.6 * mix (vec4 (1., 0.8, 0.5, 0.), vec4 (0.9, 0.7, 0.5, 0.), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * ro.xz)));\n    f = 1. - smoothstep (0.4, 0.7, dstGrnd / dstFar);\n    vn = GrndNf (ro);\n    s = GrObjDf (ro.xz);\n    col4 *= 1. - 0.1 * s;\n    vn = VaryNf (8. * ro, vn, 2. * f + 8. * s);\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) { \n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (dstObj < dstFar && idObj == 1) nDotL *= nDotL;\n      sh = (rd.y < 0.) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.13 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  tCyc = 4.;\n  segRot = pi * (0.4 + 0.*0.1 * floor (mod (tCur / (5. * tCyc), 4.)));\n  ArcConf ();\n  ro = vuMat * vec3 (0., 0., -40.);\n  ro.x -= arc.rad * arc.cs.y * (2. * tCur / tCyc - (nSeg + 1.) / 2.);\n  zmFac = 6. + 2.5 * el;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGWD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[780, 780, 806, 833, 1061], [1063, 1063, 1080, 1080, 1527], [1529, 1529, 1551, 1551, 2687], [2689, 2689, 2714, 2714, 3868], [3870, 3870, 3903, 3903, 4151], [4153, 4153, 4174, 4174, 4429], [4431, 4431, 4468, 4468, 4697], [4699, 4699, 4733, 4733, 5490], [5492, 5492, 5516, 5516, 5548], [5550, 5550, 5572, 5572, 5719], [5721, 5721, 5756, 5756, 8167], [8211, 8211, 8267, 8267, 9533], [9535, 9535, 9582, 9582, 9629], [9631, 9631, 9674, 9674, 9738], [9740, 9740, 9762, 9762, 9789], [9791, 9791, 9827, 9827, 10033], [10035, 10035, 10065, 10065, 10178], [10180, 10180, 10211, 10211, 10275], [10309, 10309, 10333, 10333, 10386], [10388, 10388, 10412, 10412, 10524], [10526, 10526, 10551, 10551, 10697], [10699, 10699, 10724, 10724, 10910], [10912, 10912, 10934, 10934, 11088], [11090, 11090, 11111, 11111, 11266], [11268, 11268, 11297, 11297, 11509], [11511, 11511, 11550, 11550, 11807]], "test": "error"}
{"id": "ftGGWm", "name": "Classic plasma effect", "author": "CenTdemeern1", "description": "Shadertoy implementation of the effect described here: https://www.bidouille.org/prog/plasma", "tags": ["plasma", "background", "trippy"], "likes": 3, "viewed": 102, "published": "Public API", "date": "1637771235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Inputs for this fragment\n    vec2 u_k = vec2(20,20); //\"Zoom\". You may derive this from the resolution if you want\n    float u_time = iTime;\n    vec2 v_coords = fragCoord / iResolution.xy;\n    \n    //Fragment value calculation done by applying the patterns described on the linked webpage\n    float v = 0.0;\n    vec2 c = v_coords * u_k - u_k/2.0;\n    v += sin((c.x+u_time));\n    v += sin((c.y+u_time)/2.0);\n    v += sin((c.x+c.y+u_time)/2.0);\n    c += u_k/2.0 * vec2(sin(u_time/3.0), cos(u_time/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+u_time);\n    v = v/2.0;\n    \n    //Color\n    vec3 col = vec3(1, sin(PI*v), cos(PI*v)); //Color calculation. v is the \"value\" of the current fragment.\n    fragColor = vec4(col*.5 + .5, 1); //Applies the fragment color, also makes the color brighter.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 126, 157, 924]], "test": "valid"}
{"id": "ftGGzy", "name": "walk 2d-n3", "author": "jorge2017a2", "description": "walk 2d-n3", "tags": ["walk2dn3"], "likes": 9, "viewed": 125, "published": "Public API", "date": "1637851432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a2....walk 2d-n3\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//https://www.shadertoy.com/view/Xdy3Rd..... bmontell\n//https://www.shadertoy.com/view/wtdBzf-----oneshade \n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//oneshade\nvec2 RotatePOA(in vec2 p, in vec2 o, in float a) {\n    float c = cos(a), s = sin(a);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec2 cossin(float x)\n{\treturn vec2(cos(x),sin(x));  }\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.5,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 hacerPiernaIzq(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,8.0);vec2 b1=vec2(3.0,5.0);  //pierna\n    vec2 a2=vec2(3.0,5.0);vec2 b2=vec2(3.0,2.0); //rodilla\n    vec2 a3=vec2(3.0,2.0);vec2 b3=vec2(4.0,2.0); //pie\n\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=(1.0 + sin(t+PI));//t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    p3=RotatePOA(p2,a3,ang3);\n\n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    float d3= sdSegment(p3,a3,b3);\n\n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    colOut= DrawFig(vec3(0.0,0.0,1.0), colOut,d3 );\n    return colOut;\n}\n\n\nvec3 hacerPiernaDer(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,8.0);vec2 b1=vec2(3.0,5.0);  //pierna\n    vec2 a2=vec2(3.0,5.0);vec2 b2=vec2(3.0,2.0); //rodilla\n    vec2 a3=vec2(3.0,2.0);vec2 b3=vec2(4.0,2.0); //pie\n\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n  r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=(1.0 + sin(t+PI)); //t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    p3=RotatePOA(p2,a3,ang3);\n\n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    float d3= sdSegment(p3,a3,b3);\n\n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    colOut= DrawFig(vec3(0.0,0.0,1.0), colOut,d3 );\n    return colOut;\n}\n\n\nvec3 hacerBrazoIzq(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,9.0);  //Brazo\n    vec2 a2=vec2(3.0,9.0);vec2 b2=vec2(3.0,6.0); //Ante brazo\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    \n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    \n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    return colOut;\n}\n\nvec3 hacerBrazoDer(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,9.0);  //Brazo\n    vec2 a2=vec2(3.0,9.0);vec2 b2=vec2(3.0,6.0); //Ante brazo\n    \n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.2; r3=0.2;    \n   t1=t;\n   t2=t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    \n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    \n    colOut= DrawFig(vec3(0.0+colIn.r,1.0,0.0+colIn.b), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    return colOut;\n}\n\nvec3 HacerCuerpoyCabeza(vec2 p, float t, vec3 colOut,vec3 colIn)\n{\n  vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,8.0);  //Pansa\n  float d1= sdSegment(p,a1,b1);\n  float d2=sdCircle(p-vec2(3.0,13.0), 0.5 );  //cabeza\n  \n  colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1);\n  colOut= DrawFig(vec3(0.5,5.0,1.0), colOut,d2);\n  return colOut;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-1.0,0.0);\n    uv*=7.0;\n\n    vec3  col=vec3(0.5);\n\n   float t=iTime;\n   uv-=vec2(0.0,-7.0);\n\n    col= HacerCuerpoyCabeza(uv, t, col,vec3(0.0));\n   col= hacerPiernaIzq(uv,t, col,vec3(0.0));\n   col= hacerPiernaDer(uv,t+PI, col,vec3(0.0,0.5,0.5));\n   col= hacerBrazoIzq(uv, t, col,vec3(0.2,0.5,0.3));\n   col= hacerBrazoDer(uv, t-PI, col, vec3(1.0,0.5,0.4));\n   \n   vec2 a1=vec2(0.0,0.0);\n   vec2 b1=vec2(6.5,0.0);\n    float d1= sdSegment(uv-vec2(-2.0,2.0),a1,b1);\n    col= DrawFig(vec3(0.0,1.0,1.0), col,d1 );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 445, 479, 479, 574], [576, 587, 637, 637, 717], [719, 719, 741, 741, 772], [774, 805, 841, 841, 886], [891, 935, 982, 982, 1009], [1010, 1010, 1053, 1053, 1080], [1081, 1081, 1129, 1129, 1157], [1163, 1163, 1225, 1225, 1420], [1422, 1422, 1503, 1503, 1630], [1632, 1632, 1689, 1689, 1760], [1762, 1762, 1799, 1799, 1873], [1875, 1875, 1910, 1910, 1933], [1935, 1935, 1987, 1987, 2103], [2105, 2105, 2167, 2167, 2977], [2980, 2980, 3042, 3042, 3852], [3855, 3855, 3916, 3916, 4544], [4546, 4546, 4607, 4607, 5256], [5258, 5258, 5324, 5324, 5588], [5592, 5592, 5649, 5649, 6320]], "test": "valid"}
{"id": "ftK3RG", "name": "Video Cube", "author": "rmmcal", "description": "cube, video, raymarching", "tags": ["raymarching", "video", "cube"], "likes": 8, "viewed": 54, "published": "Public", "date": "1637987641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//              ...  Video Cube ...                      ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/11\n// https://www.shadertoy.com/view/ftK3RG\n/////////////////////////////////////////////////////////////\n\nconst float pi = 3.1415926;\nconst float pi2 = 2.*pi;\nconst float rad = pi/180.;\n\nmat2 rotate(float x){\n    float c = cos(x);\n    float s = sin(x);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b ) // https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct march{\n     float x;\n     vec3 p;\n     float id;\n};\n\nmarch mac(float x){\n    march m;\n    m.x = x;\n    return m;\n}\n\nmarch mac(float x, vec3 p){\n    march m;\n    m.x = x;\n    m.p = p;\n    return m;\n}\n\nmarch mac(float x, vec3 p, float id){\n    march m;\n    m.x = x;\n    m.p = p;\n    m.id = id;\n    return m;\n}\n\nmarch vmin(march d, march v){\n    if (d.x > v.x)\n        return v;\n    else \n        return d;\n   \n}\n\nbool renderFloor = true;\nmarch dist(vec3 p)\n{\n    march d = mac( 1.0 );\n    \n    d = vmin(d, mac(-p.z+7., p, 1.0));\n  \n    if (renderFloor){\n      vec3 p1 = p;\n      p1.yz *= rotate(-.15);\n      p1.yz *= rotate(cos((p1.x+p1.z+cos(p1.y+p.z))*2.+iTime)*.04);\n      d = vmin(d, mac(sdBox(p1-vec3(0.0,-2.,0.), vec3(4.0,0.1,4.)),p,1.0));\n    }\n    \n    p.z+=-2.;\n    p.y+=cos(iTime*1.5)-1.;\n    p.x+=cos(iTime);\n    p.xz *= rotate(iTime);\n    p.yz *= rotate(iTime*.3);    \n    d = vmin(d, mac(sdBox(p, vec3(1.0)),p));\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0., 0.01);\n    float x = dist(p-d.yxx).x;\n    float y = dist(p-d.xyx).x;\n    float z = dist(p-d.xxy).x;\n    return normalize(vec3(x,y,z)-dist(p).x);\n}\n\nstruct raymarch{\n    float t; // distance\n    vec3 p;  // position\n    vec3 d;  // direction\n    march h; // hit\n    vec3 c;  // inv glow\n    vec3 b;  // glow\n    float m; // min hit\n    vec3 pn; // normal\n    vec3 dr; // reflect\n    vec3 pd; // penultimate hit\n    float len;\n};\n\nraymarch raymarching(vec3 p1, vec3 d1, float len, float maxd, float mind){\n    raymarch r;\n    r.t = 0.;\n    r.p = p1 ;\n    r.d = d1;\n    r.h;\n    r.c *= 0.0;\n    r.m  = 1.0;\n    int lenb = int(len);\n    for (int i = 0 ; i < lenb; i++)\n    {\n        r.h  = dist(r.p );\n        float h = r.h.x;\n        h = min(h, mind);\n        h = max(h, maxd);\n        //if (h < 0.01)\n        //  break;\n        r.t+=h;\n        r.p += r.d*h;\n        r.m = min(r.m, h);\n        r.c += r.m;\n        //r.b += 1./(sqrt(r.m));\n    }\n    r.c /= (len);  \n    r.b =  vec3(clamp(1.0-r.c*5.5,0.,1.));\n    r.len = len;\n    r.pn = getNormal(r.p); \n    r.dr = reflect( r.d, getNormal(r.p) ); \n    r.pd = r.p - r.d;\n    return r;\n}\n\nvec3 getVideoColor(raymarch r)\n{\n    return clamp(texture(iChannel0, ( (r.h.p.xy+vec2(r.h.p.z, 0.0))*vec2(0.25,.5)+vec2(0.5,.5)) ).rgb*vec3(r.pn.z),0.0,1.0);\n}\n\nfloat getFloorColor(raymarch r){\n\n    return clamp( step(.9, (r.h.id) ) + step(.9, abs(r.h.p.y) ), 0., 1. );\n    \n}\n\nvoid background(vec2 uv, inout vec3 c){\n    if (iTime < 20.0)\n        c += texture(iChannel0, mod(uv*10.0,1.0)).rgb*.5;\n    else\n        c += texture(iChannel0, uv).rgb*.5;\n\n    vec2 uvid = (floor(uv*10.0));\n    float index = mod(10.-uvid.y, 10.0)+ uvid.x/10.;\n    vec2 uvr = (mod(uv*10.0,1.0));\n    c *= smoothstep(0.,.1, uvr.x) ;     \n    c *= smoothstep(0.,.1, uvr.y) ;  \n    c *= smoothstep(-0.,1.,pow(iTime*5.+11.,1.0)-length(uvr-.5)-index*10.0)+.1 ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pc = (uv-.5)*vec2(1, iResolution.y/iResolution.x);\n    vec3 p1 = vec3(0,0.,-8);\n    vec3 d1 = normalize(vec3(pc,1.0));\n    \n    raymarch rFirst   = raymarching( p1, d1, 70. , .0, 1.);\n   \n    raymarch rShadow  = raymarching( rFirst.pd, vec3(0,1,0), 10., 0.0, 1. );\n    \n    raymarch rReflect = raymarching( rFirst.pd, rFirst.dr, 10., 0.0, 1. );\n    \n    renderFloor = false;\n    raymarch rGlow  = raymarching( p1, d1, 70. , .0, .5);\n     \n    vec3 c = getVideoColor(rFirst);                                      // ambient\n   \n    c = mix(c, vec3(0.3,0.7,rFirst.pn.z), getFloorColor(rFirst));        // color floor\n    \n    c += getVideoColor(rReflect);                                        // reflect\n    \n    c = c * rShadow.c+.25;                                               // shadow\n\n    c += pow(clamp(+1.-rFirst.pn.z, 0., 1.0), 20.0);                     // specular\n    \n    if (rFirst.t>15.0) background(uv, c);                                // background\n    \n    c = mix(c, vec3(0.0), smoothstep(0.0, 1.0, -.3+length(uv-.5))+.2);   // fade\n    \n    c += vec3(rGlow.b);                                                  // glow \n    \n    c += vec3(clamp(.9+pow(cos(iTime),1.0)*1.0-rGlow.c*8.,0.,1.));       // glow extra\n \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 487, 487, 560], [562, 562, 668, 668, 755], [817, 817, 836, 836, 878], [880, 880, 907, 907, 962], [964, 964, 1001, 1001, 1071], [1073, 1073, 1102, 1102, 1173], [1200, 1200, 1220, 1220, 1708], [1710, 1710, 1734, 1734, 1903], [2186, 2186, 2260, 2260, 2888], [2890, 2890, 2922, 2922, 3049], [3051, 3051, 3083, 3083, 3166], [3168, 3168, 3207, 3207, 3625], [3627, 3627, 3684, 3684, 5001]], "test": "error"}
{"id": "ftK3Rt", "name": "Bucking Bronco", "author": "dr2", "description": "Don't fall off", "tags": ["kinematics"], "likes": 25, "viewed": 284, "published": "Public API", "date": "1638191101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Bucking Bronco\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos[3], ltCol[3], pUp, qHit;\nvec2 aRotCs[3];\nfloat tCur, dstFar, movFac, platRad[2];\nint idObj;\nconst int idTube = 1, idBall = 2, idBase = 3, idLeg = 4, idPlat = 5, idSeat = 6, idGrip = 7; \nconst float pi = 3.1415927;\n\nstruct TbCon {\n  vec3 pLo, pHi;\n  vec2 aLimCs, tRotCs[2], pRotCs[2];\n  float chLen, chDist, ang, rad;\n};\nTbCon tbCon[4];\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Robotic Head\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid SetConf ()\n{\n  vec3 vp;\n  float tubeLen, t, h, rm, a[3];\n  movFac = SmoothBump (0.15, 0.85, 0.07, mod (0.05 * tCur, 1.));\n  t = 1.5 * tCur;\n  platRad[0] = 3.3;\n  platRad[1] = 1.;\n  rm = 0.55 * (platRad[1] - platRad[0]);\n  h = 0.1 + movFac * 0.9 * (1.2 + 0.6 * sin (2.3 * t));\n  tubeLen = length (vec2 (platRad[1] - platRad[0], 2.));\n  pUp.xz = movFac * Rot2D (vec2 (rm, 0.), t + 0.5 * (Fbm1 (t) - 0.5));\n  pUp.y = h;\n  a[0] = movFac * 0.1 * pi * sin (2.7 * t);\n  a[1] = movFac * 0.1 * pi * sin (2.9 * t);\n  a[2] = movFac * pi * (Fbm1 (0.5 * t) - 0.5) + 0.25 * pi;\n  aRotCs[0] = sin (a[0] + vec2 (0.5 * pi, 0.));\n  aRotCs[1] = sin (a[1] + vec2 (0.5 * pi, 0.));\n  aRotCs[2] = sin (a[2] + vec2 (0.5 * pi, 0.));\n  for (int k = 0; k < 4; k ++) {\n    tbCon[k].pLo = vec3 (Rot2D (vec2 (platRad[0] + 0.11, 0.), float (k) * 0.5 * pi), - h).xzy;\n    tbCon[k].pHi = vec3 (Rot2D (vec2 (platRad[1] + 0.11, 0.), float (k) * 0.5 * pi) + pUp.xz,\n       pUp.y).xzy;\n    tbCon[k].pHi.xy = Rot2D (tbCon[k].pHi.xy, - a[0]);\n    tbCon[k].pHi.zy = Rot2D (tbCon[k].pHi.zy, - a[1]);\n    vp = tbCon[k].pHi - tbCon[k].pLo;\n    tbCon[k].pLo.y += h;\n    tbCon[k].pHi.y += pUp.y;\n    tbCon[k].chLen = 0.5 * length (vp);\n    tbCon[k].tRotCs[0] = sin (atan (vp.x, vp.z) + vec2 (0.5 * pi, 0.));\n    tbCon[k].tRotCs[1] = sin (- asin (length (vp.xz) / length (vp)) + vec2 (0.5 * pi, 0.));\n    tbCon[k].ang = SecSolve (tbCon[k].chLen / tubeLen);\n    tbCon[k].chDist = tbCon[k].chLen / tan (tbCon[k].ang);\n    tbCon[k].rad = length (vec2 (tbCon[k].chDist, tbCon[k].chLen));\n    tbCon[k].aLimCs = sin (- tbCon[k].ang + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p.y -= 0.36;\n  q = p;\n  q.y -= -0.05;\n  d = PrRoundCylDf (q.xzy, platRad[0] + 0.03, 0.02, 0.04);\n  DMINQ (idBase);\n  q.y -= -0.22;\n  q.xz = abs (q.xz) - 0.63 * platRad[0];\n  d = PrCylDf (q.xzy, 0.1 * platRad[0], 0.15);\n  DMINQ (idLeg);\n  for (int k = 0; k < 4; k ++) {\n    d = PrSphDf (p - tbCon[k].pLo, 0.1);\n    DMINQ (idBall);\n  }\n  q = p;\n  q.y -= pUp.y;\n  q.xy = Rot2Cs (q.xy, aRotCs[0]);\n  q.zy = Rot2Cs (q.zy, aRotCs[1]);\n  q -= pUp;\n  q.y -= -0.1;\n  d = PrRoundCylDf (q.xzy, platRad[1] + 0.07, 0.02, 0.04);\n  DMINQ (idPlat);\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 0.15, 0.25);\n  DMINQ (idSeat);\n  q.y -= 0.33;\n  q.xz = Rot2Cs (q.xz, aRotCs[2]);\n  d = PrRoundBoxDf (q, vec3 (0.4, 0.15, 0.08), 0.1);\n  DMINQ (idSeat);\n  q.xy -= vec2 (0.3, 0.25);\n  d = PrTorusBxDf (q.yzx, vec3 (0.25, 0.12, 0.08), 0.03);\n  DMINQ (idGrip);\n  for (int k = 0; k < 4; k ++) {\n    d = PrSphDf (p - tbCon[k].pHi, 0.1);\n    DMINQ (idBall);\n  }\n  for (int k = 0; k < 4; k ++) {\n    q = p - tbCon[k].pLo;\n    q.xz = Rot2Cs (q.xz, tbCon[k].tRotCs[0]);\n    q.yz = Rot2Cs (q.yz, tbCon[k].tRotCs[1]) - vec2 (tbCon[k].chLen, tbCon[k].chDist);\n    a = fract ((128. / tbCon[k].ang) * atan (q.y, - q.z) / (2. * pi));\n    d = max (dot (vec2 (abs (q.y), - q.z), tbCon[k].aLimCs), length (vec2 (length (q.yz) -\n       tbCon[k].rad, q.x)) - (0.08 - 0.012 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a))));\n    DMINQ (idTube);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltAx, c;\n  vec2 u;\n  float dstObj, nDotL, sh, att, ltDst, a, r;\n  bool isMet;\n  SetConf ();\n  dstObj = ObjRay (ro, rd);\n  col = vec3 (0.);\n  isMet = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idTube) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.3);\n      isMet = true;\n    } else if (idObj == idBall) {\n      col4 = vec4 (0.9, 0.7, 0.4, 0.3);\n      isMet = true;\n    } else if (idObj == idBase) {\n      r = length (qHit.xz);\n      col4 = vec4 (0.5, 0.6, 0.4, 0.1) * (0.85 + 0.15 * smoothstep (0., 0.05,\n         abs (r - 1.1 * platRad[1])));\n      u = Rot2D (qHit.xz, pi / 16.);\n      a = (r > 0.) ? atan (u.y, - u.x) / (2. * pi) : 0.;\n      u = Rot2D (u, 2. * pi * (floor (16. * a + 0.5) / 16.));\n      if (length (u + vec2 (platRad[0] - 0.3, 0.)) < 0.15) col4 = vec4 (((movFac > 0.2) ?\n         HsvToRgb (vec3 (mod (a + 0.5 * pi * tCur, 1.), 1., 1.)) :\n         vec3 (1., 1., 0.) * (0.8 + 0.2 * sin (16. * pi * tCur))), -1.);\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.5, 0.6, 0.4, 0.1);\n    } else if (idObj == idPlat) {\n      col4 = vec4 (0.6, 0.5, 0.7, 0.2);\n      r = length (qHit.xz);\n      u = Rot2D (qHit.xz, pi / 8.);\n      a = (r > 0.) ? atan (u.y, - u.x) / (2. * pi) : 0.;\n      u = Rot2D (u, 2. * pi * (floor (8. * a + 0.5) / 8.));\n      if (length (u + vec2 (platRad[1] - 0.15, 0.)) < 0.1)\n         col4 = vec4 (((movFac > 0.) ? vec3 (1., 0., 0.) : vec3 (0., 1., 0.)), -1.);\n    } else if (idObj == idSeat) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.2);\n    } else if (idObj == idGrip) {\n      col4 = vec4 (1., 0.5, 0.5, 0.2);\n      isMet = true;\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    u = ro.xz;\n    col4 = vec4 (0.6, 0.5, 0.5, 0.1) * (1. - 0.2 * Fbm2 (4. * u));\n    u = abs (fract (u + 0.5) - 0.5);\n    col4.rgb *= (1. - 0.15 * smoothstep (0.05, 0.08,\n       abs (max (abs (u.x + u.y), abs (u.x - u.y)) - 0.2) - 0.2)) *\n       (1. - 0.15 * smoothstep (0.05, 0.08, length (max (u - 0.42, 0.))));\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      for (int k = VAR_ZERO; k < 3; k ++) {\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (0., 2., 0.));\n        att = smoothstep (0., 0.02, dot (ltDir, ltAx) - 0.97);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (isMet) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.1 + 0.9 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += c * c;\n      }\n      col = sqrt (col);\n    } else col = col4.rgb * (0.5 + 0.5 * max (0., - dot (vn, rd)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el += 0.08 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5, -20.);\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / 3.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, -0.1 * pi * tCur + 2. * pi * float (k) / 3.);\n  }\n  ltCol[0] = vec3 (1., 0.2, 0.2);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  zmFac = 4.2;\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3Rt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1141, 1141, 1167, 1193, 1581], [1583, 1583, 1600, 1600, 3197], [3199, 3199, 3221, 3221, 4681], [4683, 4683, 4716, 4716, 4963], [4965, 4965, 4986, 4986, 5241], [5243, 5243, 5292, 5292, 5534], [5536, 5536, 5571, 5571, 8431], [8433, 8433, 8489, 8489, 9894], [9896, 9896, 9942, 9942, 9989], [9991, 9991, 10037, 10037, 10118], [10120, 10120, 10153, 10153, 10180], [10182, 10182, 10224, 10224, 10275], [10277, 10277, 10334, 10334, 10410], [10412, 10412, 10436, 10436, 10558], [10560, 10560, 10617, 10617, 10700], [10702, 10702, 10738, 10738, 10944], [10946, 10946, 10976, 10976, 11089], [11091, 11091, 11122, 11122, 11186], [11220, 11220, 11244, 11244, 11297], [11299, 11299, 11323, 11323, 11435], [11437, 11437, 11462, 11462, 11608], [11610, 11610, 11635, 11635, 11821], [11823, 11823, 11845, 11845, 11999], [12001, 12001, 12022, 12022, 12177]], "test": "error"}
{"id": "ftK3W1", "name": "spqr: portal", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 5, "viewed": 156, "published": "Public API", "date": "1637622020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\n\n\nfloat map(vec3 p) {\n\n // geo\n \n\n  \n  \n  float pi = 3.141592;\n  \n  vec3 q = p;\n  q = rep(q, vec3(0,0,57));\n\n\n  p = vec3(atan(p.x,p.y), length(p.xy) - 1., p.z);\n  \n   \n  p.y = abs(p.y) - 2.;\n  p.y = abs(p.y) -2.;\n\n\n\n \n  float tunnel = box(p, vec3(domain_width,1.,domain_width));\n \n \n  vec3 pulse = vec3(iTime * 10.,0,0);\n  float beam = cylcap(q.yxz + vec3(0,0,430. * sin(iTime * 1.3)), 1.,1.);\n  glow += 0.6/(0.1 + beam);\n \n \n  float hit = min(beam,tunnel);\n  \n  if (tunnel == hit) {\n      matter = 1;\n  \n  }\n  if (beam == hit) {\n      matter = 2;\n  }\n\n\n  return hit;\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\nvec3 probepos;\nvec3 probe (vec3 r, vec2 uv, float dd) {\n // volume\n  \n  float rand=rnd(uv);\n  \n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = probepos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    vec3 target = vec3(0);\n   \n    \n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n \n    \n    float u = dot( normalize(lp - probepos), normalize(probepos-target) ) ;\n    //if ( u > .99) {\n    //u = min(.5,u);\n    //if ( u > .99) {\n    atcol += 35./(0.01+(pow(ldistvol,1.5))) * shadvol * pow(u,10.);\n    //}\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n  return atcol;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  \n   float tt = iTime * .15;\n  \n   vec3 s = lattice(tt) * 9.;\n  \n   vec3 t = lattice(tt+5.) * 7.;\n  \n   s.z += tt * 10.;\n   t.z += tt * 10.;\n\n   \n   probepos = s + vec3(0,0,100) * sin(iTime*7.);;\n\n\n \n  vec3 cz=normalize(t-s);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=s;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n      \n       i = decal(p * 100., domain); // resolution\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p * 100., domain + .01 );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(1,1,0);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n //col += probe(r, uv, dd) * .9;\n col += glow * .6;\n col = mix(vec3(.5), col, 1. - z/260.);\n  \n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 314, 314, 383], [385, 385, 407, 407, 454], [456, 456, 485, 485, 533], [536, 536, 583, 583, 629], [631, 631, 650, 650, 1209], [1211, 1211, 1253, 1253, 1360], [1362, 1362, 1386, 1386, 1448], [1487, 1487, 1515, 1515, 1960], [1966, 1966, 1994, 1994, 2625], [2647, 2647, 2674, 2674, 3293], [3333, 3333, 3356, 3356, 3471], [3607, 3607, 3630, 3630, 3708], [3710, 3710, 3744, 3838, 4230], [4236, 4236, 4263, 4263, 4331], [4333, 4333, 4361, 4361, 4385], [4386, 4386, 4415, 4415, 4502], [4505, 4505, 4533, 4533, 4559], [4561, 4561, 4589, 4589, 4622], [4625, 4625, 4672, 4672, 4718], [4722, 4722, 4763, 4763, 4931], [4934, 4934, 4955, 4955, 5246], [5248, 5248, 5267, 5267, 5375], [5377, 5377, 5416, 5416, 5493], [5495, 5495, 5531, 5531, 5609], [5611, 5611, 5631, 5631, 5725], [5728, 5728, 5752, 5752, 5807], [5811, 5811, 5832, 5832, 5881], [5883, 5883, 5908, 5908, 6377], [6404, 6404, 6423, 6432, 6973], [6975, 6975, 7039, 7039, 7321], [7324, 7324, 7343, 7343, 7462], [7464, 7464, 7505, 7505, 7551], [7553, 7553, 7589, 7589, 7634], [7636, 7636, 7656, 7656, 7699], [7701, 7701, 7720, 7720, 7799], [7803, 7803, 7823, 7823, 8007], [8009, 8009, 8082, 8082, 8331], [8348, 8348, 8388, 8399, 9177], [9179, 9179, 9236, 9236, 11102]], "test": "valid"}
{"id": "ftK3zy", "name": "Weird mix", "author": "turboplay", "description": "A weird mix, imported from https://github.com/Oncorporation/obs-shaderfilter/", "tags": ["burn", "effect"], "likes": 1, "viewed": 73, "published": "Public API", "date": "1637914636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec4 mod289(vec4 x)\n{\n\treturn x - floor(x / 289.0) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n\treturn mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n\treturn vec4(1.79284291400159 - r * 0.85373472095314);\n}\nvec2 fade(vec2 t) {\n\treturn t * t* t* (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod289(Pi); // To avoid truncation effects in permutation\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\tvec4 i = permute(permute(ix) + iy);\n\tvec4 gx = fract(i / 41.0) * 2.0 - 1.0;\n\tvec4 gy = abs(gx) - 0.5;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\tvec2 g00 = vec2(gx.x, gy.x);\n\tvec2 g10 = vec2(gx.y, gy.y);\n\tvec2 g01 = vec2(gx.z, gy.z);\n\tvec2 g11 = vec2(gx.w, gy.w);\n\tvec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy;\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod(Pi, rep.xyxy); // To create noise with explicit period\n\tPi = mod289(Pi);        // To avoid truncation effects in permutation\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\tvec4 i = permute(permute(ix) + iy);\n\tvec4 gx = fract(i / 41.0) * 2.0 - 1.0;\n\tvec4 gy = abs(gx) - 0.5;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\tvec2 g00 = vec2(gx.x, gy.x);\n\tvec2 g10 = vec2(gx.y, gy.y);\n\tvec2 g01 = vec2(gx.z, gy.z);\n\tvec2 g11 = vec2(gx.w, gy.w);\n\tvec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy;\n}\n\n\n\n float Speed = 0.33;\n float Gradient_Adjust = 0.85;\n float Dissolve_Value = 1.43;\n bool Animated;\n bool Apply_to_Channel;\n bool Apply_Smoke = true;\n float Smoke_Horizonal_Speed = 0.3;\n float Smoke_Vertical_Speed = 0.17;\n int Iterations = 4;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n    \n    vec4 color = fragColor;//image.Sample(textureSampler, v_in.uv);\n\tvec4 smoke = vec4(1.0,1.0,1.0,1.0);\n\tvec4 result = smoke;\n\tfloat t = iTime * Speed;\n\tfloat cycle = 1. - max((sin(t) * 2.) - 1., 0.); //create a negative cycle time as a delay\n\tvec2 dir = vec2(Smoke_Horizonal_Speed, Smoke_Vertical_Speed);\n\t//float largestDistance = sqrt(pow(uv_size.x, 2) + pow(uv_size.y, 2));\n\n\tfloat perlin = 0.5;\n\tfloat smoke_perlin = 0.;\n\tfloat scale = 1.;\n\tfloat w = 0.5;\t\n\n\tfor (int i = 0; i < Iterations; i++) {\n\t\t//vec2 coord = v_in.uv * scale;// (v_in.uv + t * dir)* scale;\n\t\tvec2 coord = (uv + t * (dir * .1)) * scale;\n\t\tvec2 period = scale * dir;\n\t\tperlin += pnoise(coord, period) * w;\n\t\tif (Apply_Smoke)\n\t\t\tsmoke_perlin += cnoise((uv + t * dir) * scale) * w * .5;\n\n\t\tscale *= 2.0;\n\t\tw *= 0.5;\n\t}\n\n\t//float toPoint = abs(length(v_in.uv - (v_in.uv * .5)) / ((1.0001 - t) * largestDistance));\n\tif (!Animated)\n\t\tcycle = 1.;\n\tfloat d = clamp(((Dissolve_Value * cycle + perlin) ) - 1.0, -.01, 0.99);\n\tfloat overOne = clamp(d * Gradient_Adjust,0.,1.);\n\tvec4 burn = texture(iChannel1, vec2(overOne, 0.5));\n\n\tif (Apply_to_Channel) {\n\t\tresult =  color * burn;\n\t}\n\telse {\n\t\tresult = vec4(perlin, perlin, perlin, 1.0) * burn;\n\t}\t\n\n\tif (smoke_perlin > 0.) {\n\t\tsmoke *= smoke_perlin;\n\t\tif (result.a <= 0.04)\n\t\t\tresult = vec4(smoke.rgb, smoke_perlin);\n\t\tresult += smoke;\n\t}\n\n\tfragColor= result;\n    \n    \n}\n\n\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 63], [64, 64, 86, 86, 128], [129, 129, 157, 157, 214], [215, 215, 234, 234, 285], [288, 312, 334, 334, 1327], [1328, 1370, 1402, 1402, 2467], [2715, 2715, 2772, 2822, 4320]], "test": "error"}
{"id": "ftK3zz", "name": "Through the hole", "author": "peremoya2000", "description": "A camera flying through a raymarched space torus.", "tags": ["space", "psychedelic", "interestellar"], "likes": 11, "viewed": 141, "published": "Public", "date": "1637264715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fovzoom = .5f;\nfloat radius = .6f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Calculate render parameters\n    float shake = .4*(1.f-abs(sin(iTime*.1)))+.01;\n    vec3 camPos = vec3(0,sin(iTime*50.f)*shake*.1,-1.38f-shake*.75),\n    pivot = vec3(.7+cos(iTime*40.f+.2)*shake*.2,cos(iTime*12.f)*shake,0),\n    u = normalize(pivot-camPos),\n    r = vec3(0,1,0),\n    f = cross(u,r),\n    sCenter = camPos+f*fovzoom,\n    screenPoint = sCenter + uv.x * r + uv.y * u,\n    rayDir = normalize(screenPoint-camPos);\n    \n    //Raymarch for the interior of a torus\n    vec3 ray;\n    float rayL, rayStep;   \n    for (int i=0; i<50; ++i){\n        ray = camPos + rayDir * rayL;\n        rayStep = -(length(vec2(length(ray.xz)-1.1f, ray.y)) - radius);\n        if(rayStep<.001) break;\n        rayL += rayStep;\n    }\n    \n    //Calculate torus UVs\n    vec3 col = vec3(0);\n    vec2 tUV = vec2(0);\n    if(rayStep<.001){\n        tUV.x = sin(atan(ray.x,ray.z*10.f)+iTime)+1.f;\n        tUV.y = sin(atan(length(ray.xz)-1.f, ray.y)+iTime)+1.f; \n    } \n   \n   //Calculate rainbow stripes\n   vec3 mask = vec3(sin(tUV.y*30.f+iTime)*.5+.5) * \n   vec3(sin(tUV.y*9.f-iTime*0.8)*.5+.5) *\n   vec3(sin(tUV.y*17.f-iTime*0.4)*.5+.5);\n   col = 0.5 + 0.5*cos(iTime+tUV.xyx+vec3(0,2,4));    \n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,tUV).xyz+mask*col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 99, 150, 1478]], "test": "error"}
{"id": "ftKGRm", "name": "near misses", "author": "Mr_Steve", "description": "hat tip to inspirnathan", "tags": ["rotations"], "likes": 1, "viewed": 24, "published": "Public", "date": "1637462964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// rotation matrices\nmat3 rotateX(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1.,0.,0.),\n        vec3(0.,c,-s),\n        vec3(0.,s,c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// identity matrix\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n float sd;\n vec3 col;\n};\n\nSurface sdBox(vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform){\n    p = (p - offset) * transform - vec3(3.,0.,0.);\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.)) + min(max(q.x, max(q.y,q.z)), 0.);\n    return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col){\n    float d = p.y + 1.;\n    return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2){\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface sdScene(vec3 p){\n    vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    Surface co = sdFloor(p, floorColor);\n    co = minWithColor(co,sdBox(\n        p,\n        vec3(.5),\n        vec3(0.,.5,-4.),\n        vec3(1.,0.,0.),\n        rotateY(iTime)\n    ));\n    co = minWithColor(co,sdBox(\n        p,\n        vec3(.25),\n        vec3(0.,1.5,-4.),\n        vec3(.5,.8,.2),\n        rotateY(-iTime) * rotateX(iTime*0.5)\n    ));\n    co = minWithColor(co,sdBox(\n        p,\n        vec3(.25,.1,.2),\n        vec3(0.,.25,-4.),\n        vec3(.1,.5,.8),\n        rotateY(-iTime*0.3) * rotateZ(iTime*0.75)\n    ));\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end){\n    float depth = start;\n    Surface co;\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        vec3 p = ro + depth *rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > end) break;\n    }\n    \n    co.sd = depth;\n    \n    return co;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1.0, 1.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    \n    if (co.sd > MAX_DIST){\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + rd * co.sd;\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2.0, 2.0, 7.0);\n        vec3 lightDirection = normalize(lightPosition - p);\n        \n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.0);\n        \n        col = dif * co.col + backgroundColor * 0.2;\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 47, 47, 193], [195, 195, 222, 222, 369], [371, 371, 398, 398, 545], [547, 566, 583, 583, 677], [848, 848, 917, 917, 1091], [1093, 1093, 1127, 1127, 1181], [1183, 1183, 1232, 1232, 1291], [1293, 1293, 1317, 1317, 1929], [1931, 1931, 1990, 1990, 2271], [2273, 2273, 2297, 2297, 2512], [2514, 2514, 2568, 2568, 3284]], "test": "valid"}
{"id": "ftKGWR", "name": "color drop", "author": "Ornibulon", "description": "smooth sdf color mixing test", "tags": ["sdf", "color"], "likes": 1, "viewed": 54, "published": "Public", "date": "1637498184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\n\n\nfloat rand(float k, float seed){\n    return sin(k*seed*seed);\n}\n\n\nmat3 rotMatrix(vec3 rotation){\n    rotation *= PI/180.;\n    float rx = rotation.x;\n    float ry = rotation.y;\n    float rz = rotation.z;\n    \n    mat3 rotationX = mat3( 1      , 0      , 0      ,\n                           0      , cos(rx),-sin(rx),\n                           0      , sin(rx), cos(rx));\n                          \n    mat3 rotationY = mat3( cos(ry), 0      , sin(ry),\n                          0       , 1      , 0      ,\n                          -sin(ry), 0      , cos(ry));\n                          \n    mat3 rotationZ = mat3( cos(rz),-sin(rz), 0      ,\n                           sin(rz), cos(rz), 0      ,\n                           0      , 0      , 1      );\n                           \n    return rotationX * rotationY * rotationZ;\n}\n\n\nvec4 opSmoothUnion( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n\nvec4 sphere(vec3 p, vec3 center, vec3 color, float s){\n    vec4 valcolor = vec4(0, 0, 0, 0);\n    \n    float value = length(p - center)-s;\n    \n    valcolor.x = value;\n    valcolor.yzw = color;\n    \n    return valcolor;\n}\n\n\nvec4 plane(vec3 p, vec3 normal, vec3 color, float h)\n{\n    vec4 valcolor = vec4(0, 0, 0, 0);\n    \n    float value = dot(p,normal) + h;\n    \n    valcolor.x = value;\n    valcolor.yzw = color; \n    \n    return valcolor;\n}\n\n\nvec4 sdf(in vec3 p){\n\n    float random0 = rand(1000., float(int(iTime/2.)));\n    float random1 = rand(2000., float(int(iTime/2.)));\n    float h = 8. - 13.*pow((iTime/2. - float(int(iTime/2.))),2.);\n    \n    float random2 = rand(5000., float(int(iTime/2.+0.5)));\n    float random3 = rand(7000., float(int(iTime/2.+0.5)));\n    float h2 = 8. - 13.*pow((iTime/2.+0.5 - float(int(iTime/2.+0.5))),2.);\n\n    return opSmoothUnion(sphere(p, vec3(2.*random0,2.*random1+2.,h), vec3(1,0,1), 1.),\n           opSmoothUnion(sphere(p, vec3(2.*random2,2.*random3+2.,h2), vec3(0,1,1), 1.),\n                         plane(p, vec3(0,0,1), vec3(1,1,1), 1.), 2.5), 2.5);\n}\n/*\nvec4 sdf(in vec3 p){\n    return sphere(p, vec3(0,0,0), vec3(1,1,0), 1.);\n}*/\n\n\n\nbool sdfIntersect(out vec3 position, out vec3 normal, out vec3 color, in vec3 rayOri, in vec3 rayDir){\n    int maxStep = 1000;\n    int dichoSteps = 12;\n\n    vec3 rayPosA = rayOri;\n    vec3 rayPosB = rayOri;\n    vec4 sdfValueA = sdf(rayOri)+0.01;\n    vec4 sdfValueB = sdfValueA;\n    \n    // sphere-tracing\n    int count = 0;\n    while (sdfValueB.x > 0.){\n        rayPosA = rayPosB; \n        rayPosB += (sdfValueB.x + 0.001) * rayDir;\n        //rayPosB += 0.01 * rayDir;\n        \n        sdfValueA = sdfValueB;\n        sdfValueB = sdf(rayPosB);\n        \n        if (count > maxStep || sdfValueB.x > 10.){\n            return false;\n        }\n        \n        count += 1;\n    }\n    \n    // end with dichotomy\n    vec3 rayPosAB = (rayPosA + rayPosB)/2.;\n    vec4 sdfValueAB = sdf(rayPosAB);\n    for (int i; i<dichoSteps; i++){\n        if (sdfValueAB.x > 0.){\n            rayPosA = rayPosAB;\n            sdfValueA = sdfValueAB;\n        } else {\n            rayPosB = rayPosAB;\n            sdfValueB = sdfValueAB;\n        }\n        \n        rayPosAB = (rayPosA + rayPosB)/2.;\n        sdfValueAB = sdf(rayPosAB);\n    }\n\n    position = rayPosAB;\n    \n    float epsilon = 0.0001;\n    normal = vec3(sdf(position+vec3(epsilon, 0, 0)).x - sdf(position+vec3(-epsilon, 0, 0)).x,\n                  sdf(position+vec3(0, epsilon, 0)).x - sdf(position+vec3(0, -epsilon, 0)).x,\n                  sdf(position+vec3(0, 0, epsilon)).x - sdf(position+vec3(0, 0, -epsilon)).x);\n                  \n    normal = normalize(normal);\n\n    color = sdfValueB.yzw;\n    \n    return true;\n}\n\n\nfloat light(vec3 lightPos, vec3 objPos, vec3 normal){\n    vec3 lightDir = normalize(lightPos - objPos);\n    \n    vec3 position2 = vec3(0,0,0);\n    vec3 normal2 = vec3(0,0,0);\n    vec3 color2 = vec3(0,0,0);\n    \n    vec3 rayOri = objPos;\n    vec3 rayDir = lightDir;\n    \n    bool intersect = sdfIntersect(position2, normal2, color2, rayOri, rayDir);\n    \n    if (intersect && length(position2 - objPos)>0.0001){\n        return 0.;\n    }\n    \n    return max(0.,dot(lightDir, normal));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    \n    float aspectRatio = iResolution.y/iResolution.x;\n    \n    vec2 sensorSize = vec2(16., 9.);//aspectRatio*16.);\n    float focal = 10.;\n    \n    \n    vec3 position = vec3(0,0,0);\n    vec3 normal = vec3(0,0,0);\n    vec3 color = vec3(0,0,0);\n    \n    vec3 rayOri = vec3(0, -5, 0);\n    vec3 rayDir = normalize(vec3(sensorSize.x*uv.x, focal, sensorSize.y*uv.y));\n    \n    bool intersect = sdfIntersect(position, normal, color, rayOri, rayDir);\n    \n    vec3 col = vec3(uv.y/3.,uv.y/2.,uv.y);\n    if (intersect){\n        col = color * vec3(1,1,1) * (light(vec3(6,-1,8), position, normal));\n        //col = (normal + vec3(1,1,1))/2.;\n    }\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 57, 57, 88], [91, 91, 121, 121, 851], [854, 854, 903, 903, 1006], [1013, 1013, 1067, 1067, 1233], [1236, 1236, 1290, 1290, 1454], [1457, 1457, 1477, 1477, 2107], [2191, 2191, 2293, 2293, 3746], [3749, 3749, 3802, 3802, 4233], [4236, 4236, 4292, 4292, 5025]], "test": "valid"}
{"id": "ftKGzm", "name": "Drink The Water", "author": "Jabo", "description": "Drink the Water", "tags": ["2d", "sdf", "flag", "pride"], "likes": 5, "viewed": 63, "published": "Public API", "date": "1637413240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p )\n{ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0; p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n\tfloat r = pow(length(m) / 0.75, 3.5) * 0.75;\n\tfloat a = atan(m.x, m.y);\n    float v = sin(48.*(sqrt(r)-0.0625*a-.05*t));\n\treturn clamp(v,0.,1.);\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r =      abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.);    //green\n    float b = 2. - abs(hue * 6. - 4.);  //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //saturate\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGzm.jpg", "access": "shaders20k", "license": "mit", "functions": [[1044, 1119, 1161, 1161, 1187], [1189, 1264, 1295, 1295, 1503], [1505, 1576, 1634, 1634, 1734], [1736, 1786, 1817, 1817, 1965], [1967, 2067, 2092, 2092, 2419], [2420, 2420, 2444, 2444, 2599], [2601, 2601, 2642, 2642, 5406], [5408, 5408, 5465, 5465, 5850]], "test": "valid"}
{"id": "ftKGzw", "name": "epilepsy warning - abomination", "author": "SnoopethDuckDuck", "description": "total mess in every regard", "tags": ["e"], "likes": 0, "viewed": 103, "published": "Public API", "date": "1637366682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 func(vec2 m) {\n    vec2 r = m;\n    r.x = 0.5 + 0.5 * thc(1000., 1. * iTime + 100. * m.x);\n    r.y = 0.5 + 0.5 * ths(1000., 1. * iTime + 100. * m.y);\n    return r;\n}\n\nvec2 func2(vec2 m) {\n    vec2 r = m;\n    r.x = thc(1.5, -0.04 * iTime * m.x + m.x * (1. + 0.2 * thc(4., iTime + m.y)));\n    r.y = thc(1.5, -0.04 * iTime * m.y + m.y * (1. + 0.2 * thc(4., iTime + m.x)));\n    return r;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float a = atan(uv.y, uv.x);\n    float l = length(uv);\n    \n    float k = 0.15;// mix(0.5, 0.05, .5 + .5 * thc(6., 0.5 * iTime)) * max(abs(uv.y), abs(uv.x));\n\n    vec2 m1 = .5 + .5 * func2(4. * k * uv);\n    vec2 m2 = .5 + .5 * func2(8. * k *uv);\n    vec2 m3 = .5 + .5 * func2(16. * k * uv);\n    vec2 m4 = .5 + .5 * func2(32. * k * uv);\n    vec2 m5 = .5 + .5 * func2(64. * k * uv);\n    \n    vec2 m = m1;\n    m = mix(m, m2,  func(m2));\n    m = mix(m, m3,  func(m3));\n    m = mix(m, m4,  func(m4));\n    m = mix(m, m5,  func(m5));\n    \n    \n    \n    uv = fract(m);\n\n    //uv.x = ths(2., cos(12. * uv.x) + iTime);\n    //uv.y = ths(2., sin(12. * uv.y) + iTime);\n    \n    // doesnt actually do much\n    float sc = 1.;//1. + cos(4. * length(m));\n\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = length(fpos);\n    float p = 0.4 * cos(10. * a);\n    float s = smoothstep(-p, p, 0.5 - d);\n    s -= smoothstep(-p, p, 0.4 - d);\n    s = clamp(s,0.,1.);\n    \n    \n    s *= 12. * thc(1., 20. * max(abs(uv.x), abs(uv.y)) +  iTime);\n   \n    //vec3 col = vec3(s);\n    \n    vec3 e = vec3(.5);\n    vec3 al = pal(0.4 * iTime + s * length(m), e*1.2,e,e*2.0, vec3(0,0.33,0.66));\n    vec3 col = clamp(al,0.,1.);\n    col *= s;\n    //col *= step(s,1.);\n    col -= round(col);\n    col *= 10.;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 163, 163, 313], [315, 315, 335, 335, 533], [536, 536, 604, 604, 647], [650, 650, 707, 757, 2188]], "test": "valid"}
{"id": "ftt3R2", "name": "Spectrolizer_example", "author": "volosati", "description": "just a sample", "tags": ["spectrolizer"], "likes": 4, "viewed": 125, "published": "Public", "date": "1636365047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]], "test": "error"}
{"id": "ftt3R4", "name": "Trippy effect", "author": "mvaios", "description": "Trippy effect by mostly playing around with some numbers.", "tags": ["colors", "zoom", "effect", "trippy"], "likes": 1, "viewed": 119, "published": "Public API", "date": "1635805102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n  \n    uv *= 3.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec3 col = vec3(gv.xy, 1.);\n\n    float m = 0.;\n    float t = iTime/2.;\n\n    \n    float dist = length(uv * 4.);\n    for(int x = -2; x<=2;x++) {\n        for(int y = -2; y<=2;y++) {\n            vec2 offset = vec2(x, y); \n            float d = length(gv-offset*0.7)*1.75;\n            float tNorm = sin(dist-t) * .5 + 0.5;\n            float r = mix(0.35, 1.8, tNorm);\n\n            m += smoothstep(r*1.0001, r, d);\n        }\n    }\n    \n    col.x = mod(m/1., 1.1);\n    col.y = mod(m/1.1, 1.3);\n    col.z = mod(m/1.3, 1.4);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 724]], "test": "valid"}
{"id": "ftt3R7", "name": "Starleidoscope", "author": "DanielXMoore", "description": "Followed some TheArtOfCodeTutorials and ended up with this!", "tags": ["tutorial"], "likes": 6, "viewed": 179, "published": "Public API", "date": "1635883589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 10.\n\nmat2 Rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare) {\n    float col = 0.;\n    float d = length(uv);\n    float m = .02/d;\n    \n    float rays = max(0., 1. - abs(uv.x * uv.y * 1000.));\n    m += rays * flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0., 1. - abs(uv.x * uv.y * 1000.));\n    m += rays * .3 * flare;\n    \n    m *= smoothstep(1., .2, d);\n\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p+45.32);\n  \n  return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0.);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for(int y = -1; y <= 1; y++ ) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 offs = vec2(x, y);\n\n            float n = Hash21(id + offs);\n            float size = fract(n*345.32);\n            \n            vec2 p = vec2(n, fract(n*34.));\n            \n            float star = Star(gv - offs - p + .5, smoothstep(.8, 1., size) * .6);\n            \n            vec3 hueShift = fract(n*2345.2 + dot(uv /420.,texture(iChannel0, vec2(0.25, 0.)).rg))*vec3(.2, .3, .9)*123.2;\n\n            vec3 color = sin(hueShift) * .5 + .5;\n            color = color * vec3(1., .25, 1.+size);\n\n            star *= sin(iTime*3.+n*6.2831)*.4+1.;\n            col += star * size * color;\n        }\n    }\n    \n    return col;\n\n}\n\nvec2 N(float angle) {\n  return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    float t = iTime * .01;\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.) * 3.1415) * .5;\n\n    vec2 n = N((5./6.) * 3.1415);\n    float d = dot(uv - vec2(.5, 0.), n);\n    uv -= n * max(0., d) * 2.;\n\n    // col += smoothstep(.01, .0, abs(d));\n\n    n = N((2./3.) * 3.1415);\n    float scale = 1.;\n    uv.x += 1.5 / 1.25;\n    for(int i=0; i<5; i++) {\n        scale *= 1.25;\n        uv *= 1.25;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n    }\n\n \n    uv += M * 4.;\n\n    uv *= Rot(t);\n    vec3 col = vec3(0.);\n    \n    float layers = 10.;\n    \n    for(float i=0.; i < 1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(1., .9, depth);\n        col += StarLayer(uv * scale + i * 453.2) * fade;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 105], [107, 107, 141, 141, 452], [454, 454, 476, 476, 569], [571, 571, 596, 596, 1403], [1405, 1405, 1426, 1426, 1467], [1469, 1469, 1526, 1526, 2537]], "test": "error"}
{"id": "ftt3RS", "name": "Light0.15315648", "author": "chanchancl", "description": "light", "tags": ["2d"], "likes": 5, "viewed": 62, "published": "Public", "date": "1636274805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 sdfCircle(vec2 p, vec2 o, float r, float emssive) {\n    return vec2(length(p - o) - r, emssive);\n}\n\nvec2 unionOp(vec2 sd1, vec2 sd2) {\n    //       ------\n    //       / \\  \n    // -----0---*---\n    //\n    if (sd1.x < sd2.x) {\n        return sd1;\n    }\n    return sd2;\n}\n\nvec2 scene(vec2 p) {\n    vec2 circle1 = sdfCircle(p, vec2(0.0, 0.4), 0.2, 0.0);\n    vec2 circle2 = sdfCircle(p, vec2(-0.6 + 0.3*cos(7.0*iTime), -0.6 + 0.3*sin(7.0*iTime)), 0.1, 1.0 + 1.0);\n    vec2 circle3 = sdfCircle(p, vec2(0.6 + 0.3*cos(3.0*iTime),  -0.6 - 0.3*cos(3.0*iTime)), 0.2, 2.0);\n\n    return unionOp(unionOp(circle1, circle2), circle3);\n}\n\n\nfloat trace(vec2 p, vec2 d, float r) {\n  float t = 0.0;\n  for(int i = 0; i < 64 && t < 3.0; i++ ){\n    // float sd = sdfCircle(p + t * d, r);\n    vec2 result = scene(p + t *d);\n    float sd = result.x;\n    if (sd <= 0.00001) {\n        return result.y /*- cos(150.0*t)*/ /*- sin(30.0*d.x*d.y+ 10.0*iTime)*/;\n    }\n    t += sd;\n  }\n  return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 a = hash(uvec3(fragCoord, iFrame));\n    float rand = a.x+a.y+a.z;\n    float R = 0.15 /*+ abs(0.1 * cos(2.0 * iTime))*/;\n    \n    float sum = 0.;\n    float N = 128.0;\n    for(float i=0.0; i < N; i++) {\n      //float a = 2.0 * 3.1415926 * i / N;\n      float a = 2.0 * 3.1415926 * (i + rand) / N;\n      sum += trace(uv, vec2(cos(a), sin(a)), R);\n    }\n    vec3 col = vec3(sum / N);\n    \n    // col = mix(col, vec3(1.0, 0., 0.), 1.0 - smoothstep(0.0, 0.01, abs(length(uv)-R)) );\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 269, 269, 402], [404, 404, 460, 460, 507], [509, 509, 543, 610, 679], [681, 681, 701, 701, 1031], [1034, 1034, 1072, 1072, 1379], [1381, 1381, 1438, 1488, 2129]], "test": "valid"}
{"id": "ftt3WN", "name": "Eyee", "author": "prishainabox", "description": "eye\nLike the Shadertoy logo, but not really!", "tags": ["eye"], "likes": 7, "viewed": 67, "published": "Public API", "date": "1636154267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat noise(in vec2 uv) {\n    \n    vec2 fid = fract(uv); // fraction part of uv -> where in the grid\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec2 id = floor(uv); // integer part of uvw -> which grid\n    \n    // corners of grid\n    float bl = random(id + vec2(0, 0));\n    float br = random(id + vec2(1, 0));\n    float tl = random(id + vec2(0, 1));\n    float tr = random(id + vec2(1, 1));\n    \n    // interpolate between corner\n    float b = mix(bl, br, fid.x);\n    float t = mix(tl, tr, fid.x);\n    return mix(b, t, fid.y);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // normalized pixel coordinates\n    vec2 res = iResolution.xy;\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y) * 1.2;\n    // for two eyes\n    \n    // distance between pt and origin\n    float d = length(uv);\n    vec3 outerEyeClr = vec3(0.05, 0.3, 0.8);\n    \n    // black background\n    vec3 clr = vec3(0.0);\n    // noise\n    clr += noise(uv * 3.0) * 0.1 * vec3(1.5, 0.1, 0.5);\n    clr += noise(uv * 3.0 + 1.0) * 0.2 * vec3(0.0, 0.1, 1.3);\n    clr += vec3(0.6, 0.06, 0.4) * 0.15 * sin(noise(uv) * uv.x * 10.0);\n    clr *= 0.5;\n    // blue/purple glow\n    clr = mix(vec3(0.3, 0.1, 0.4) * 0.8, clr, smoothstep(d, 0.58, 0.73));\n    clr = mix(outerEyeClr*5., clr, smoothstep(d, 0.64, 0.66));\n    \n    // stars\n    float n = random(uv * 0.2); // random num based on coordinate\n    if (n < 0.008) {\n        clr += 0.6 * noise(vec2(uv * 50.0 + iTime));\n    }\n    \n    if (d < 0.8) {\n        // angle between center and pt\n        float a = atan(uv.y, uv.x);\n        // outer circle\n        vec3 e = mix(vec3(0.35, 0.65, 0.14), outerEyeClr, smoothstep(0.3, 0.65, d));\n        e += vec3(0.3, 0.35, 0.15)*1.2*(smoothstep(2.4, 3.14, a) + smoothstep(3.14, 4.94, 3.14-a));\n        // noise\n        e += noise(14.5 * vec2(cos(a), sin(a))) * 0.18;\n        // vignette\n        e = mix(e, vec3(0.02, 0.02, 0.2) * 0.1, smoothstep(0.45, 0.9, d));\n        // center\n        e = mix(e, vec3(0.1, 0.1, 0.15) * 0.7, smoothstep(0.28, 0.23, d));\n        // shine\n        float l = distance(uv, vec2(0.27));\n        vec3 shineClr = vec3(0.8, 1.2, 0.7);\n        e += shineClr * smoothstep(0.7, 0.0, l) * 0.4;\n        e += shineClr * smoothstep(0.15, 0.0, l*0.5) * 0.3;\n        // mix eye clr into background\n        clr = mix(clr, e, smoothstep(0.74, 0.69, d));\n    }\n\n    fragColor = vec4(clr, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 101], [103, 103, 128, 128, 637], [639, 639, 696, 733, 2484]], "test": "valid"}
{"id": "fttGz4", "name": "Persian carpet fractal 8", "author": "jarble", "description": "A Persian carpet fractal pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 135, "published": "Public API", "date": "1635786272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(1.0+c2,.5+c2,-1.5,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = 45.87+iTime/2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/4.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/8.;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((t+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.05;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -.7;\n            float factor1 = 8.;\n            \n            uv = triangle_wave(uv.yx+scale,scale)+triangle_wave(uv,scale);\n            //uv.y /= .9;\n            uv.x *= factor;\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            uv.x /= -factor;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/factor1))-(uv.y*(col.y/factor1+1.)));\n        }\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 214, 214, 259], [261, 261, 318, 318, 1476]], "test": "valid"}
{"id": "fttGzM", "name": "Pulsing spirals (113 chars)", "author": "hnh", "description": "Low-Fi Sci-Fi ;-)\nSimilar concept as in https://www.shadertoy.com/view/7syXzV", "tags": ["spiral", "glow", "short", "tweet", "golf"], "likes": 2, "viewed": 130, "published": "Public API", "date": "1635881692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage(out vec4 o, vec2 u){\n\n//*\n// -2 chars by XOR\n   o = 1. - abs(sin((iTime \n          - length(o= u.xyxy/iResolution.xyxy - .5)\n          + atan(o.xxyx, o))*2.));  // coefficient -> spiral arms\n\n/*/\n// -1 char by coyote\n    o= 2.*fract(iTime - length(u= u/iResolution.xy - .5)\n             + atan(u.xxyx/u.xyxx)/1.57);\n    o*= --o;\n\n\n/* /\n// -2 chars by XOR\n    o= fract(iTime - length(u= u/iResolution.xy - .5)\n             + atan(u.xxyx/u.xyxx)/1.57) - .5;\n    o*= o*4.;\n\n/* /\n// base version, 118 chars\n    o= 1. - sin(3.14*fract(iTime \n          - length(u= u/iResolution.xy - .5)\n          + atan(u.xxyx, u.xyxx)/1.57));\n//*/\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 60, 645]], "test": "valid"}
{"id": "ftV3Rw", "name": "GG's Strange Shadows", "author": "guyemura", "description": "simple", "tags": ["raymarch"], "likes": 1, "viewed": 39, "published": "Public", "date": "1637391632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I learned how to make shapes and light movement from\n//https://www.youtube.com/watch?v=Ff0jJyyiVyw&ab_channel=TheArtofCode\n//Overall, this was tough, but I think I finally realized that when we\n//do all the floats and stuff, it's like making a definition in python.\n//Later on, all we are doing is fitting things into the parameters\n//as I would for a normal function. The result itself does not\n//look as impressive as I hoped, sadly, but still cool.\n#define surf_hit .009\n#define max_dist 100.\n\n//first vector is position, second one is size\nfloat dBox(vec3 p, vec3 s) {\n    //the x, y, and z cannot get smaller than 0\n    return length(max(abs(p) - s, 0.));\n }\n\n//position of center and then radius of each circle\nfloat sdTorus (vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\nfloat GetDist(vec3 p) {\n    //one away from ground plane, 6 away from us, radius of one so that it touches the ground\n    vec4 sphere = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    //ground plane is going to be 0 so p.y\n    float planeDist = p.y;\n    \n    //float box distance\n    //position the box at -2, 2 above the ground, and 6 away from camera,\n    //size of square is .3 in every direction\n    float bd = dBox(p - vec3(-2, 2, 6), vec3(.3));\n    //float torus distance\n    float td = sdTorus(p - vec3(4, 2, 9), vec2(1., .5));\n    float dis = min(planeDist, sphereDist);\n    //actually adds the box to the shader\n    dis = min(dis, bd);\n    dis = min(dis, td);\n    return dis;\n}\n\n// marching shoots a ray based on the camera position and direction of ray\nfloat marching(vec3 camPos, vec3 rayDirec) {\n    //keeping track of distance from origin\n    float distOrig = 0.0;\n    \n    //marching loop\n    for (int i=0; i<100; i++) {\n        vec3 p = camPos + rayDirec * distOrig;\n        //distance to scene\n        float distScene = GetDist(p);\n        distOrig += distScene;\n        if(distOrig > max_dist || distScene < surf_hit) break;\n    }\n    //return the \n    return distOrig;\n}\n\n\nvec3 getNormal(vec3 p) {\n    float dist = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = dist - vec3(\n    //these are called \"swizzles\"; a trick to efficiently manipulate\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\n\n//p is some point that we want to return light value based on\nfloat returnLight(vec3 p) {\n    //light position right above sphere\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(2.* sin(iTime), 2. * cos(iTime)) * 2.;\n    vec3 normalizedLight = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float diffuseLight = clamp(dot(n, normalizedLight), 0., 1.);\n    float d = marching(p + n * surf_hit * 1.5, normalizedLight);\n    if(d<length(lightPos-p)) diffuseLight *= .1;\n    \n    return diffuseLight;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizing it so that the uv is 0 in the middle\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //camera at one above the ground\n    \n    vec3 camPos = vec3(0, 3, 0);\n    vec3 rayDirec = normalize(vec3(uv.x,uv.y-.3, 1));\n    \n    //distance from ray marching function\n    float dis = marching(camPos, rayDirec);\n    \n    vec3 p = camPos + rayDirec * dis;\n    \n    float diffuseLight = returnLight(p);\n    col = vec3(diffuseLight);\n    \n    //the minimum distance is going to be at least one because\n    //we are one unit above the ground\n    //dis /= 6. ;\n    \n    //col = vec3(dis);\n    //col = getNormal(p); //checks that the getNormal function is working\n    //converting what I see to RGB confirms that the function is correctly done\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftV3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 546, 574, 622, 665], [667, 719, 751, 751, 826], [827, 827, 850, 944, 1550], [1552, 1627, 1671, 1715, 2052], [2055, 2055, 2079, 2079, 2357], [2360, 2422, 2449, 2489, 2882], [2885, 2885, 2942, 2998, 3797]], "test": "valid"}
{"id": "ftVGDy", "name": "Greek Variants", "author": "dr2", "description": "Beware of viruses bearing Greek letters (especially the Omicron)", "tags": ["font", "cellmarch"], "likes": 14, "viewed": 248, "published": "Public API", "date": "1638269941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Greek Variants\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Beware of viruses bearing Greek letters (especially the Omicron).\n \n Using the Greek characters included in otaviogood's \"SDF Texture Font\"; not\n following WHO naming guidelines.\n\n  No. 14 in \"Font\" series\n    \"Font3d\"               (ltsyRr)\n    \"Lorem Ipsum\"          (XlXyR8)\n    \"Historical Text\"      (4tXcRH)\n    \"Font Clock\"           (MlscR8)\n    \"Alphaville\"           (XtfczN)\n    \"Pi in the Sky\"        (4lfyR7)\n    \"Train Builder\"        (4tlcz7)\n    \"Twisted Time\"         (XlsyWH)\n    \"Alphawall\"            (MlXyWf)\n    \"Alphapolis\"           (4scyDj)\n    \"Pi Night\"             (WsXyR4)\n    \"Corona Time\"          (wsfcRX)\n    \"Facebook Time\"        (sscXRj)\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat FontTexDf (vec2 p, float id);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\n\nvec3 cId, ltDir, obRot;\nvec2 obRotCs[3], fntSize, qnTex;\nfloat dstFar, tCur, gSize, vSpd, idTxt, qyHit;\nbool cOcc;\nconst float pi = 3.1415927;\n  \nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (cOcc) {\n    p -= gSize * (cId + 0.5);\n    p.yz = Rot2Cs (p.yz, obRotCs[0]);\n    p.xz = Rot2Cs (p.xz, obRotCs[1]);\n    p.xy = Rot2Cs (p.xy, obRotCs[2]);\n    p.xz /= fntSize.x;\n    d = 0.5 * SmoothMax (max (fntSize.x * FontTexDf (p.xz + 0.5, idTxt),\n      PrBox2Df (p.xz, vec2 (0.35))), abs (p.y) - fntSize.y, 0.001);\n    qyHit = p.y;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  float rNum;\n  int c;\n  vRan = Hashv3f (dot (cId, vec3 (31.1, 41.1, 51.1)) + 99.);\n  cOcc = (vRan.x * step (1.5, length (cId.xz)) > 0.2);\n  if (cOcc) {\n    obRot = (vRan - 0.5) * (tCur + 10.);\n    obRotCs[0] = sin (obRot.x + vec2 (0.5 * pi, 0.));\n    obRotCs[1] = sin (obRot.y + vec2 (0.5 * pi, 0.));\n    obRotCs[2] = sin (obRot.z + vec2 (0.5 * pi, 0.));\n    rNum = Hashfv3 (vec3 (31.1, 41.1, 51.1) * cId + 99.);\n    c = int (rNum * 20.3);\n    if (c < 16) c += 0x80;\n    else c = (c < 20) ? 0x6f : 0x1d;\n    idTxt = float (c);\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / gSize);\n  p.y += vSpd * (tCur + 10.) * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / gSize);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.001;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((gSize * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 1.5;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.35, 0.5, 1.), vec3 (0.1, 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.15 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, s;\n  gSize = 1.;\n  fntSize = vec2 (0.45, 0.02);\n  vSpd = 0.1;\n  bgCol = BgCol (rd);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    col = (idTxt == float (0x6f)) ? vec3 (0.9, 0.3, 0.3) : vec3 (0.8, 0.9, 0.5);\n    s = step (abs (qyHit), fntSize.y - 0.001);\n    col *= 1. - 0.6 * s;\n    vn = (s > 0.) ? normalize (vec3 (qnTex,\n       0.001 * sign (qyHit))).xzy : vec3 (0., sign (qyHit), 0.);\n    vn.xy = Rot2D (vn.xy, - obRot.z);\n    vn.xz = Rot2D (vn.xz, - obRot.y);\n    vn.yz = Rot2D (vn.yz, - obRot.x);\n    col *= 0.3 + 0.7 * max (dot (vn, ltDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 0.95, dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define txFnt iChannel0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.25 * pi;\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += pi * sin (0.003 * pi * tCur);\n    el += 0.2 * pi * sin (0.002 * pi * tCur);\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.4);\n  zmFac = 3.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -2.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n#if 0   // (show full font texture instead)\n  col = (max (abs (uv.x), abs (uv.y)) < 1.) ? texture (txFnt, 0.5 * (uv + 1.)).rgb : vec3 (0.);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat FontTexDf (vec2 p, float id)\n{\n  vec3 tx;\n  float d;\n  tx = texture (txFnt, fract ((vec2 (mod (id, 16.),\n     15. - floor (id / 16.)) + fract (p)) * (1. / 16.))).gba - 0.5;\n  qnTex = vec2 (tx.r, - tx.g);\n  d = tx.b + 1. / 256.;\n  return d;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1377, 1377, 1399, 1399, 1781], [1783, 1783, 1801, 1801, 2348], [2350, 2350, 2373, 2373, 2507], [2509, 2509, 2542, 2542, 3099], [3101, 3101, 3123, 3123, 3546], [3548, 3548, 3583, 3583, 4305], [4332, 4332, 4388, 4388, 5626], [5628, 5628, 5661, 5661, 5750], [5752, 5752, 5774, 5774, 5812], [5814, 5814, 5859, 5859, 5951], [5953, 5953, 5998, 5998, 6036], [6038, 6038, 6074, 6074, 6280], [6282, 6282, 6312, 6312, 6425], [6427, 6427, 6458, 6458, 6522], [6524, 6524, 6560, 6560, 6771], [6805, 6805, 6829, 6829, 6889], [6891, 6891, 6915, 6915, 6980], [6982, 6982, 7006, 7006, 7066]], "test": "error"}
{"id": "ftVGRh", "name": "easy sun", "author": "suolong", "description": "画日", "tags": ["sun"], "likes": 1, "viewed": 77, "published": "Public API", "date": "1637677453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle (vec2 st, float pct){\n    if(st.y<2.5)return 0.;\n  return  step(distance(st,vec2(2.5)+vec2(0,sin(iTime)*2.5)), pct);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.y*5.0-vec2(2.,0.0);\n    vec3 color = vec3(0.265,0.48,0.65);\n\n    float pct = 0.2;\n    float intensity =distance(st,vec2(2.5)+vec2(0,sin(iTime)*2.5));\n    color = color+vec3(1.000,0.800,0.306)*pow(4.132,-2.0*intensity);\n    color = mix(color,vec3(0.979,0.978,1.000),circle(st,pct));\n    color =mix(color,mix(vec3(0.1,0.2,0.3),vec3(0.2,0.4,0.8),st.y),1.0-step(2.5,st.y));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 131], [132, 132, 189, 239, 680]], "test": "valid"}
{"id": "ftVGzm", "name": "Girih fractal", "author": "jarble", "description": "This fractal is reminiscent of girih tiles.", "tags": ["fractal", "tree", "ring", "wood"], "likes": 1, "viewed": 110, "published": "Public API", "date": "1637381857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//number of iterations\n#define ITERS 6\n\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/3.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    //vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    //vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = 1.5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < ITERS; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                //uv *= 1.-col.x;\n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                //uv.y *= 1.-col.x;\n                //uv.yx = triangle_wave(uv.yx-offset/1.5,scale)*bend-triangle_wave(uv-offset,scale)/bend;\n\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                //uv.yx += uv/2.;  \n                bend *= -1.;\n                bend -= 1./3.-col.x;\n                offset += bend;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.5;\n            //scale2 += (col.z+col.x+col.y)/(2.);\n\n\n            col[c] = ((uv.x)-(uv.y)-col[c]);\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col/1.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 375, 397, 443, 576], [578, 578, 617, 617, 662], [664, 664, 721, 721, 2609]], "test": "valid"}
{"id": "fty3zh", "name": "Fusion Generator A", "author": "JupiterDude", "description": "Mouse click to see effect of the clipped noise interpolation.", "tags": ["noise", "experiment", "symmetry"], "likes": 3, "viewed": 40, "published": "Public", "date": "1637115175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define PI2 6.283185307179586476925286766559\n#define PI4 12.566370614359172953850573533118\n\n#define OCTAVES 6\n#define SPEEDX (0.05)\n#define SPEEDY (SPEEDX * .4)\n#define RSCALE 2.4\n#define GSCALE 2.8\n#define BSCALE 2.1\n\nvec2 random(vec2 uv){\n    uv = vec2( dot(uv, vec2(123.7, 31.9) ),\n               dot(uv, vec2(609.2, 183.71) ) );\n    return -1.0 + 2.0 * fract( sin(uv) * 343803.23346);\n}\n\nfloat noise(vec2 uv, float scale) {\n    uv *= scale;\n    uv = abs(uv);\n    vec2 index = floor(uv);\n    vec2 fraction = fract(uv);\n    vec2 blend = smoothstep(0.0, 1.0, fraction);\n    return mix(\n        mix(\n            dot( random(index + vec2( 0.0, 0.0 ) ), fraction - vec2( 0.0, 0.0 ) ),\n            dot( random(index + vec2( 1.0, 0.0 ) ), fraction - vec2( 1.0, 0.0 ) ),\n            blend.x),\n        mix(\n            dot( random(index + vec2( 0.0, 1.0 ) ), fraction - vec2( 0.0, 1.0 ) ),\n            dot( random(index + vec2( 1.0, 1.0 ) ), fraction - vec2( 1.0, 1.0 ) ),\n            blend.x),\n        blend.y) * 0.5 + 0.5;\n}\n\nfloat noiseX(vec2 tuv, vec2 uv, float scale) {\n    // vec2 tuv = abs(uv);\n    uv *= scale;\n    uv = abs(uv);\n    vec2 index = floor(uv);\n    vec2 fraction = fract(uv);\n    vec2 blend = smoothstep(0.0, 1.0, fraction);\n    \n    if (tuv.x > (iMouse.x / iResolution.x)-.5) {\n        return mix(\n            mix(\n                dot( random(index + vec2( 0.0, 0.0 ) ), fraction - vec2( 1.0, 0.0 ) ),\n                dot( random(index + vec2( 1.0, 0.0 ) ), fraction - vec2( 1.0, 0.0 ) ),\n                blend.x),\n            mix(\n                dot( random(index + vec2( 0.0, 1.0 ) ), fraction - vec2( 0.0, 1.0 ) ),\n                dot( random(index + vec2( 1.0, 1.0 ) ), fraction - vec2( 1.0, 1.0 ) ),\n                blend.x),\n            blend.y) * 0.5 + 0.5;\n     } else {\n        return mix(\n            mix(\n                dot( random(index + vec2( 0.0, 0.0 ) ), fraction - vec2( 0.0, 0.0 ) ),\n                dot( random(index + vec2( 1.0, 0.0 ) ), fraction - vec2( 1.0, 0.0 ) ),\n                blend.x),\n            mix(\n                dot( random(index + vec2( 0.0, 1.0 ) ), fraction - vec2( 0.0, 1.0 ) ),\n                dot( random(index + vec2( 1.0, 1.0 ) ), fraction - vec2( 1.0, 1.0 ) ),\n                blend.x),\n            blend.y) * 0.5 + 0.5;\n     }\n}\n\nfloat bnoise(vec2 c, float scale) {\n    float t = 0.0;\n    vec2 tc = c;\n    c = abs(c);\n    float octave = .7;\n    float r0 = (12.0 + iTime * SPEEDX) * -sign(c.x);\n    float r1 = (13.0 + iTime * SPEEDY) * -sign(c.y);\n    float ot = noise(c + 12.0, 2.0);\n    for( int a=0; a<OCTAVES; a++ ){\n        c.x += r0;\n        c.y += r1;\n        float n = noiseX(tc, c + ot, scale) * octave;\n        ot = n;\n        octave /= 2.0;\n        scale *= 2.0;\n        t += n; // t = max(t, n);\n    }\n    return t;\n}\n\nfloat color(float t) {\n    return pow(cos((1.0-t)*PI)*.5 + .5, 3.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 c = uv - .5;\n    uv.x *= aspect;\n    float r = bnoise(c, RSCALE);\n    float g = bnoise(c, GSCALE);\n    float b = bnoise(c, BSCALE);\n    r = color(r);\n    g = color(g);\n    b = color(b);\n    float rr = (r+g) / 2.0;\n    float gg = (g+b) / 2.0;\n    float bb = (b+r) / 2.0;\n    fragColor = vec4(rr, gg, bb, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fty3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 285, 285, 435], [437, 437, 472, 472, 1065], [1067, 1067, 1113, 1140, 2336], [2338, 2338, 2373, 2373, 2836], [2838, 2838, 2860, 2860, 2908], [2910, 2910, 2965, 2965, 3375]], "test": "valid"}
{"id": "ftyGDh", "name": "Hue vs. brightness", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 2, "viewed": 49, "published": "Public", "date": "1637733259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n// gives pure saturated color from input [0, 6) for phase\nvec3 hue(float x) {\n    x = mod(x, 6.);\n    return clamp(vec3(\n        abs(x - 3.) - 1.,\n        -abs(x - 2.) + 2.,\n        -abs(x - 4.) + 2.\n    ), 0., 1.);\n}\n\nvec3 colorize(float value, float hue_){\n    vec3 a = hue(hue_);\n    return mix(\n      mix(\n        vec3(0.), a , smoothstep(0., 0.5, value)\n      ), vec3(1.), smoothstep(0.5, 1., value)\n    );\n}\n\nfloat zigzag(float value){\n    return abs(mod(value * 2., 2.) - 1.);\n}\n\nfloat dither(float value, float steps, float thres){\n    float a = value * steps;\n    return (floor(a) + step(thres, a - floor(a))) / steps;\n}\n\nfloat roll(vec2 xy_, uint t) {\n    uvec2 xy = uvec2(xy_);\n    const uint a = 1664525u;\n    const uint m = 1013904223u;\n\n    uint seed = 1818420u * xy.x + 78265178u * xy.y + 237698117u * t;\n    \n    uint x0 = (seed * a) % m;\n    uint x = (x0 * a) % m;\n    \n    return float((x ^ x0) & 65535u) / 65536.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 3.);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  \n  float dist = log(uv.x * uv.x + uv.y * uv.y);\n  float angle = atan(uv.y, uv.x) / TAU;\n  float dark = mod(floor(time * 50.), 2.);\n  float thres = (\n  mod(gl_FragCoord.x + gl_FragCoord.y, 2.) +\n  roll(gl_FragCoord.xy, floatBitsToUint(time))\n  )/2.;\n  \n  float spiral1 = dither(zigzag(\n    angle + dist * 0.2 + (\n    sin(time * TAU) * 1. - time * 4.\n    ) * 3.\n  ), 2., thres);\n  \n  float spiral2 = dither(\n    -angle + dist * 0.2 + (\n    sin(-time * TAU) * 1. - time * 4.\n    ) * 3.\n  , 12., thres);\n  \n  vec3 col = colorize(spiral1, spiral2 * 6.);\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 84, 103, 103, 243], [245, 245, 284, 284, 439], [441, 441, 467, 467, 511], [513, 513, 565, 565, 655], [657, 657, 687, 687, 960], [962, 962, 1019, 1019, 1828]], "test": "valid"}
{"id": "ftyGDz", "name": "Random Pixels", "author": "LoganLang", "description": "Random Pixels", "tags": ["time", "random"], "likes": 3, "viewed": 49, "published": "Public", "date": "1637450865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 one = vec3(55., 86., 32.)/255.;\nconst vec3 two = vec3(109., 142., 52.)/255.;\nconst vec3 three = vec3(129., 183., 12.)/255.;\nconst vec3 four = vec3(205., 219., 87.)/255.;\n\nfloat random (vec2 _st) {\n    return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = st;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += iTime * .25;\n    uv *= 10.;\n    vec2 ipos = floor(uv);\n    \n    //put each square in a random group 1 <-> 4\n    float randVal = random(ipos);\n    float timeGroup;\n    if (randVal > .75) timeGroup = 0.;\n    else if (randVal > .5) timeGroup = 1.;\n    else if (randVal > .25) timeGroup = 2.;\n    else timeGroup = 3.;\n    \n    //randomize each group one at a time\n    float timeVal = floor((iTime*12.+(1.*timeGroup))*.25);\n    randVal = random(vec2(ipos.x + timeVal, ipos.y + timeVal));\n    \n    //assign color to square\n    vec3 randColor;\n    if (randVal > .75) randColor = one;\n    else if (randVal > .5) randColor = two;\n    else if (randVal > .25) randColor = three;\n    else randColor = four;\n    \n    //add darkness on edges\n    col = randColor * (1.-abs(st.x-.5)*1.5)*(1.-abs(st.y-.5)*1.5);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 207, 207, 280], [282, 282, 339, 339, 1303]], "test": "valid"}
{"id": "ftyGR1", "name": "Font experiment 006", "author": "iY0Yi", "description": "Other experiments list:\n[url]https://www.shadertoy.com/playlist/tctBWH[/url]", "tags": ["font", "util"], "likes": 4, "viewed": 32, "published": "Public", "date": "1637122220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fontSize = 1.;\nfloat fontWeight = .2;\n\n// lpnorm by gaz\n// https://www.shadertoy.com/view/slG3Rz\nfloat lpnorm(vec2 p, float n){vec2 t=pow(abs(p),vec2(n));return pow(t.x+t.y,1./n);}\n\n// iq's segment function\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 ba = b-a;\n    vec2 aba = abs(ba);\n    float r = atan(aba.y,aba.x)/3.14;\n    vec2 pa = p-a;\n    //pa*=mat2(cos(r*.05+vec4(0,11,33,0)));\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return lpnorm( pa - ba*h, 6. );\n}\n\n// Modify skeleton\n#define SEGX .5\n#define SEGY 30.\n#define SEGCX 0.\n#define SEGCY 0.05\n#define SEGYHP +.45\n#define SEGYHN -.38\n\n// Short hands\n#define START_SEG float d = 1e4\n#define END_SEG return d\n#define DRAW_SEG(v1, v2) d=min(sdSegment(p, v1, v2)-fontWeight,d)\n\n// Outer Box (Start from Top/Left. Clockwise. SEG0-11)\n#define SEG0  DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX, +SEGY))\n#define SEG1  DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX, +SEGY))\n#define SEG2  DRAW_SEG(vec2( +SEGX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG3  DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( +SEGX, SEGCY))\n#define SEG4  DRAW_SEG(vec2( +SEGX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG5  DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG6  DRAW_SEG(vec2( +SEGX, -SEGY), vec2( SEGCX, -SEGY))\n#define SEG7  DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX, -SEGY))\n#define SEG8  DRAW_SEG(vec2( -SEGX, -SEGY), vec2( -SEGX,SEGYHN))\n#define SEG9  DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( -SEGX, SEGCY))\n#define SEG10 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( -SEGX,SEGYHP))\n#define SEG11 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( -SEGX, +SEGY))\n// Top Rhombus (Start from Top/Left. Clockwise. SEG12-15)\n#define SEG12 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( SEGCX, +SEGY))\n#define SEG13 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG14 DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( SEGCX, SEGCY))\n#define SEG15 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( -SEGX,SEGYHP))\n// Bottom Rhombus (Start from Top/Left. Clockwise. SEG16-19)\n#define SEG16 DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( SEGCX, SEGCY))\n#define SEG17 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG18 DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( SEGCX, -SEGY))\n#define SEG19 DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX,SEGYHN))\n// Center Vertical line (Top>Bottom. SEG20,21)\n#define SEG20 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( SEGCX, SEGCY))\n#define SEG21 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( SEGCX, -SEGY))\n// Center Horizont line (Left>Right. SEG22,23)\n#define SEG22 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX, SEGCY))\n#define SEG23 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG24-27)\n#define SEG24 DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX,SEGYHP))\n#define SEG25 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, +SEGY))\n#define SEG26 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHP))\n#define SEG27 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG28-31)\n#define SEG28 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHN))\n#define SEG29 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, SEGCY))\n#define SEG30 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG31 DRAW_SEG(vec2( -SEGX, -SEGY), vec2( SEGCX,SEGYHN))\n\n\n#define SKIP_DRAW d=d\n#define SEG0x  SKIP_DRAW\n#define SEG1x  SKIP_DRAW\n#define SEG2x  SKIP_DRAW\n#define SEG3x  SKIP_DRAW\n#define SEG4x  SKIP_DRAW\n#define SEG5x  SKIP_DRAW\n#define SEG6x  SKIP_DRAW\n#define SEG7x  SKIP_DRAW\n#define SEG8x  SKIP_DRAW\n#define SEG9x  SKIP_DRAW\n#define SEG10x SKIP_DRAW\n#define SEG11x SKIP_DRAW\n#define SEG12x SKIP_DRAW\n#define SEG13x SKIP_DRAW\n#define SEG14x SKIP_DRAW\n#define SEG15x SKIP_DRAW\n#define SEG16x SKIP_DRAW\n#define SEG17x SKIP_DRAW\n#define SEG18x SKIP_DRAW\n#define SEG19x SKIP_DRAW\n#define SEG20x SKIP_DRAW\n#define SEG21x SKIP_DRAW\n#define SEG22x SKIP_DRAW\n#define SEG23x SKIP_DRAW\n#define SEG24x SKIP_DRAW\n#define SEG25x SKIP_DRAW\n#define SEG26x SKIP_DRAW\n#define SEG27x SKIP_DRAW\n#define SEG28x SKIP_DRAW\n#define SEG29x SKIP_DRAW\n#define SEG30x SKIP_DRAW\n#define SEG31x SKIP_DRAW\n\n#define SEG0o  SEG0\n#define SEG1o  SEG1\n#define SEG2o  SEG2\n#define SEG3o  SEG3\n#define SEG4o  SEG4\n#define SEG5o  SEG5\n#define SEG6o  SEG6\n#define SEG7o  SEG7\n#define SEG8o  SEG8\n#define SEG9o  SEG9\n#define SEG10o SEG10\n#define SEG11o SEG11\n#define SEG12o SEG12\n#define SEG13o SEG13\n#define SEG14o SEG14\n#define SEG15o SEG15\n#define SEG16o SEG16\n#define SEG17o SEG17\n#define SEG18o SEG18\n#define SEG19o SEG19\n#define SEG20o SEG20\n#define SEG21o SEG21\n#define SEG22o SEG22\n#define SEG23o SEG23\n#define SEG24o SEG24\n#define SEG25o SEG25\n#define SEG26o SEG26\n#define SEG27o SEG27\n#define SEG28o SEG28\n#define SEG29o SEG29\n#define SEG30o SEG30\n#define SEG31o SEG31\n\nfloat sdAllSeg(vec2 p) {\n    // Start designing with copy & paste below lines.\n    // -------------------------------- ✂ -----------------------------------\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12o, SEG13o, SEG14o, SEG15o;\n    /*BottomRhombus*/   SEG16o, SEG17o, SEG18o, SEG19o;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    /*X(Top)*/          SEG24o, SEG25o, SEG26o, SEG27o;\n    /*X(Bottom)*/       SEG28o, SEG29o, SEG30o, SEG31o;\n    END_SEG;\n    // -------------------------------- ✂ -----------------------------------\n}\n\nfloat sdNum0(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum1(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1x,  SEG2x,  SEG3x, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum2(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    /*X(Top)*/          SEG24x, SEG25x, SEG26x, SEG27x;\n    /*X(Bottom)*/       SEG28x, SEG29x, SEG30x, SEG31x;\n    END_SEG;\n}\nfloat sdNum3(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    /*X(Top)*/          SEG24x, SEG25x, SEG26x, SEG27x;\n    /*X(Bottom)*/       SEG28x, SEG29x, SEG30x, SEG31x;\n    END_SEG;\n}\nfloat sdNum4(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0x,  SEG1x,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum5(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x, SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum6(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum7(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum8(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum9(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\n\nfloat sdNumFont(vec2 p, float s, float fi) {\n    p /= s;\n    int i = int(mod(floor(fi), 10.)); // 0-9    \n    switch(i){\n        case 0:\n            return sdNum0(p);\n        case 1:\n            return sdNum1(p);\n        case 2:\n            return sdNum2(p);\n        case 3:\n            return sdNum3(p);\n        case 4:\n            return sdNum4(p);\n        case 5:\n            return sdNum5(p);\n        case 6:\n            return sdNum6(p);\n        case 7:\n            return sdNum7(p);\n        case 8:\n            return sdNum8(p);\n        case 9:\n            return sdNum9(p);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord/iResolution.xy;\n    vec2 grid = vec2(.2,.5);\n    vec2 ip = floor(p/grid);\n    p = mod(p, grid)/grid*2.-1.;\n    p.y*=iResolution.x/iResolution.y;\n    p.y*=30.; // ???\n    p.x -= mix(0., p.y*.01, clamp(sin(iTime),0.,1.));;\n    //p.x*=mix(1., 2.+(1.-clamp(p.y+2., .0, 1.)*2.), clamp(sin(iTime),0.,1.));\n    \n\tfontWeight = .45;//-clamp(sin(iTime*1.5)*2.,0.,1.)*.19;\n    fontSize = .7;\n    float num = ip.x+(1.-ip.y)*5.;// + floor(exp(clamp(sin(iTime*5.),0.,1.))*10.) + floor(sin(iTime*.5)*10.);\n    float d = sdNumFont(p, fontSize, num);\n    d = 1.-smoothstep(.0,.015,d);\n    \n    vec3 col = mix(vec3(0.102,0.102,0.102), vec3(.8, .77, .7), d);\n \n    // Draw Skeleton\n    col = max(col, vec3(.8, .77, .7)*.3*smoothstep(0.02, 0., abs(sdAllSeg(p/fontSize)+fontWeight)-.002));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 103, 133, 133, 186], [188, 213, 264, 264, 502], [4726, 4726, 4750, 4884, 5442], [5444, 5444, 5466, 5466, 5832], [5833, 5833, 5855, 5855, 6221], [6222, 6222, 6244, 6244, 6722], [6723, 6723, 6745, 6745, 7223], [7224, 7224, 7246, 7246, 7612], [7613, 7613, 7635, 7635, 8000], [8001, 8001, 8023, 8023, 8389], [8390, 8390, 8412, 8412, 8778], [8779, 8779, 8801, 8801, 9167], [9168, 9168, 9190, 9190, 9556], [9558, 9558, 9602, 9602, 10146], [10148, 10148, 10205, 10205, 11029]], "test": "error"}
{"id": "ftyGzD", "name": "Red X of Death", "author": "brisingre", "description": "Worrying aura", "tags": ["error", "2dshapes"], "likes": 1, "viewed": 89, "published": "Public API", "date": "1637222175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float box1 = sdOrientedBox(uv, vec2(-1, -1), vec2(2, 2), .1);\n    float box2 = sdOrientedBox(uv, vec2(2, -1), vec2(-1, 2), .1);\n    \n    float x = min(box1, box2);\n    \n    float baseX = smoothstep(.00, .001, x);\n    \n    vec4 xColor = vec4(1., 0, 0, 1.) * ((sin(2. * iTime) + 1.)/2.);\n    vec4 bgColor = vec4(.5, 0, 0, 1.) * ((sin(11. * iTime) + 1.)/2.);\n    \n    // Output to screen\n    fragColor = mix(bgColor, xColor, baseX);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 283], [285, 285, 342, 392, 869]], "test": "valid"}
{"id": "NdKSDV", "name": "Gaussian Weierstrass Piecewise", "author": "spalmer", "description": "Applying a gaussian filter to a piecewise linear function.  Based on oneshade's toy.", "tags": ["filter", "antialias", "1d", "graph", "plot", "linear", "gaussian", "golf", "segments", "piecewise", "weierstrass"], "likes": 8, "viewed": 60, "published": "Public", "date": "1636379225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Weierstrass transform (https://en.wikipedia.org/wiki/Weierstrass_transform)\n// of piecewise linear function\n// filter by summing S for each segment\n\n// original was 864 characters, is now 825.\n// but I guess I've made progress!\n\n// save a few ch\n#define R float\n#define V vec2\n\n// oneshade's error function approximation\nR erf(R x)\n{\n    return sign(x) * sqrt(1. - exp2(-1.787776 * x * x));\n}\n\n// an integration.\n// the Weierstrass transform?\n// Gaussian filtered segment\nR S(R x, V A, V B, R w) \n{\n    const R k = sqrt(1. / acos(-1.));\n    R h = B.x - A.x // one of two interleaved terms\n    , m = k * w * (B.y - A.y) / h // variance?\n    , v = mix(A.y, B.y, (x - A.x) / h) // where on segment vertically by linear interpolation?\n    , a = (x - A.x) / w\n    , b = (x - B.x) / w;\n    return (\n        (erf(a) - erf(b)) * v +\n        (exp(-a * a) - exp(-b * b)) * m\n        ) * .5;\n}\n// unsure have actually improved it, perhaps easier to read.\n// Someone who is actually well trained in calculus\n// shall have to take it from here.  My brain hurts!\n\nR F(R x, R w)\n{\n    // example from Wikipedia\n    return (S(x, V(-5, 1), V( 0, 1), w)\n          + S(x, V( 0, 1), V( 5,-1), w)) * 4.25;\n}\n    // example animated wave, may work better with w fixed\n//#define P(i) vec2(10. * (i) - 5., cos(iTime + 6. * (i)))\n//    float z = 0.; float nr = 1./6.; vec2 p1 = P(1.), p2; //vec2(5., 0.);\n//    for (float i = 1.; (i -= nr) >= 0.; p1 = p2)\n//        z += S(x, p1, p2 = P(i), w);\n//    return z;\n\n\nvoid mainImage(out vec4 o, V q) \n{\n    V r = iResolution.xy;\n    R u = 10. / r.y;\n    q = (q - .5 * r) * u;\n    R w = mix(2.5005, 5., -cos(.5 * iTime)) //mix(.001, 5., .5 - .5 * cos(.5 * iTime)) // Filter width\n    , y = F(q.x, w)\n    , d = dFdx(y);\n    o = vec4(sqrt(abs(q.y - y) / sqrt(u * u + d * d))); // antialias plot, gamma\n}\n\n\n// oneshade's erf is top-notch.\n// missing a 2/sqrt(pi) factor mentioned on Wikipedia\n// but is VERY close to true value at 1.0;\n// I failed to improve it.\n\n// Wolfram Alpha uses Gamma to compute erf, and says erf(1.0) = .84270079\n\n// btw the slope of erf at zero is 2/sqrt(pi) or about 1.1283792\n// but if you match the slope there, will be worse approx elsewhere.\n\n\n// Maxima says\n// (%i)\tintegrate(e^(-x*x), x);\n// (%o)\t(sqrt(%pi)*erf(sqrt(log(e))*x))/(2*sqrt(log(e)))\n// (%i)\tintegrate(e^(-x*x), x, 0, z);\n// (%o)\t(sqrt(%pi)*erf(sqrt(log(e))*z))/(2*sqrt(log(e)))\n// once you grok erf, please let me know!\n// https://en.wikipedia.org/wiki/Error_function\n\n// closely related to  normal cumulative distribution function\n\n\n// How was S derived from what Wikipedia says about Weierstrass?\n// Had a 2/sqrt(pi) factor.\n// Guess they divided entire equation \n// by 2/sqrt(pi) and got sqrt(pi)/2\n// where the /2 factored out completely\n\n\n// these two can easily be inlined TODO\n// FIXME precise sqrt(1/pi) is wordy\n//, v = sqrt(1./acos(-1.)) * w //1./sqrt(acos(-1.)) * w // w/sqrt(pi) = .56418958354*w\n//, slope = (B.y - A.y) / bx;\n //* slope * v\n\n//, dY = (F(q.x + .001, w) - y) / .001 // dydx derivative of F at q.x, approximately dx*u\n//, dw = fwidth(y)\n//, dy = dFdy(y) // *should* be approximately dY * u or dY / r.y or something\n//, dx = dFdx(y) // approximately dY * u\n\n// this antialiasing method is superb!  sure beats what I was using prior.\n// trying to grok why circularizing works for AA... sin to cos\n// I guess it makes some sense; like rotating the line flat!\n// but why can't I express it in terms of dFdx or dFdy?\n//, aa = // antialiasing\n    //1./u // only handles flat parts\n    //1. / u / sqrt(1. + dY * dY) // perfect!\n    //1. / u / sqrt(1. + dx * dx / u / u) // imperfect! damn close\n    //1. / sqrt(u * u + dx * dx) // optimized?  Cool!!\n    //1. / length(vec2(u,      dx)) // longer :(\n    //inversesqrt(1. + dY * dY) / u // bit longer\n    //pow(abs(dY), -2.) / u\n    //1. / abs(dy + 1.001)\n    //1. / u / abs(dy*dy + 1.001)\n    //10. / sqrt(dy*dy+.1)\n    //1. / sqrt(dx*dx+1e-3)\n    //2./(abs(dx) + .1)\n    //pow(abs(dy), -2.)\n    //.5 / (abs(dx) + 1.01/r.y) // close-ish, has issues with even resolutions\n    //1./(dw + 1./r.y)\n    //1./sqrt(1.+dx*dx)/u\n    //1./u*(1.-1.06*abs(dx)) // close?! meh\n    //1. / sqrt(dw*dw+.00010001)\n//, d = abs(q.y - y) * aa\n\n//o = vec4(.5 + .5 * (dx/u - dY)); // debugging\n\n// see also https://desmos.com/calculator/mfzpsbbyqn", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 324, 336, 336, 395], [397, 475, 501, 501, 885], [1053, 1053, 1068, 1098, 1189], [1491, 1491, 1525, 1525, 1823]], "test": "valid"}
{"id": "NdyGRG", "name": "Gyroid2", "author": "stuwatt193", "description": "gyroid moving in z direction with time", "tags": ["gyroid"], "likes": 1, "viewed": 36, "published": "Public", "date": "1638009658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float timePeriod = 20.0;\n    float wavePeriod = 25.0;\n    float width = 10.0;\n    vec2 screenCoord = fragCoord - iResolution.xy/2.0;\n    vec2 uv =  width * screenCoord / min(iResolution.x, iResolution.y);\n\n\n    float x = uv.x;\n    float y = uv.y;\n    float z = 0.0;\n    z = wavePeriod * mod(iTime,timePeriod)/timePeriod;\n    float d = sin(x)*cos(y) + sin(y)*cos(z) + sin(z)*cos(x);\n    // diamond\n    //d = sin(x)*sin(y)*sin(z)+sin(x)*cos(y)*cos(z)+cos(x)*sin(y)*cos(z)+cos(x)*cos(y)*sin(z);\n    //Schwartz\n    //d = cos(x)+cos(y)+cos(z);\n    \n\n\n    float h = (d + 2.0)/4.0;\n    float s = 0.5;\n    float l = 0.5;\n\n    if(0.49<h&&h<0.51){l=0.0;};\n\n    vec3 col = hsl2rgb(vec3(h,s,l));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 169], [171, 171, 228, 228, 975]], "test": "valid"}
{"id": "Nl33Dl", "name": "Persian mosaic 3", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "glass", "mosaic", "ceramic"], "likes": 1, "viewed": 122, "published": "Public API", "date": "1636904262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(4.+t2)-.5)/8.;\n    vec3 random2 = (hash31(5.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.;\n            \n\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.;\n                uv.yx = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                //bend = (((uv.x-uv.y)))/3.+1.+1./3.;\n                bend *= -1. + (uv.y+uv.x)/8.;\n                uv += vec2(random1[k]*bend,random2[k]/bend);            \n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/8.;\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2300]], "test": "valid"}
{"id": "Nl33W8", "name": "Truncated Cone SDF", "author": "TheTurk", "description": "Distance function for a truncated cone. ", "tags": ["3d", "distancefield", "sdf", "cone", "distance", "frustum", "primitive", "truncatedcone"], "likes": 2, "viewed": 46, "published": "Public", "date": "1636040810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cone(vec3 position, float radius1, float radius2, float halfHeight) {\n    vec2 q = vec2(length(position.xz) - (radius2 + radius1) * 0.5, position.y);\n    vec2 end = vec2((radius2 - radius1) * 0.5, halfHeight);\n    vec2 segment = q - end * clamp(dot(q, end) / dot(end, end), -1.0, 1.0);\n    float d = length(segment);\n    if (segment.x > 0.0) {\n        return d;\n    }\n    return max(-d, abs(q.y) - halfHeight);\n}\n\n/*\n// alternative version without branching\nfloat cone(vec3 position, float radius1, float radius2, float halfHeight) {\n   vec2 q = vec2(length(position.xz), position.y);\n   vec2 d1 = vec2(max(q.x - radius1, 0.0), -q.y - halfHeight);\n   vec2 d2 = vec2(max(q.x - radius2, 0.0), q.y - halfHeight);\n   q -= vec2(radius1, -halfHeight);\n   vec2 end = vec2(radius2 - radius1, halfHeight * 2.0);\n   vec2 d3 = q - end * clamp(dot(q, end) / dot(end, end), 0.0, 1.0);\n   return sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3))) * sign(max(max(d1.y, d2.y), d3.x));\n}\n*/\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat sdf(in vec3 position) { \n    float cornerRadius = 0.01;\n    float radius1 = 0.4;\n    float radius2 = 0.15;\n    float halfHeight = 0.2;\n    position = rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.785) * position;\n    float d = cone(position, radius1, radius2, halfHeight);\n    d -= cornerRadius;\n    return d;\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 384;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 10.0);\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 75, 75, 418], [984, 984, 1023, 1023, 1205], [1207, 1207, 1261, 1261, 1602], [1604, 1604, 1633, 1633, 1922], [1924, 1924, 1952, 1952, 2297], [2299, 2299, 2349, 2349, 2731], [2733, 2733, 2788, 2788, 4295]], "test": "valid"}
{"id": "Nl33Wr", "name": "Jonix water ripple", "author": "Hultsborn10", "description": "A simulation of water ripples inspired by CodingTrain.", "tags": ["waterripplejonix"], "likes": 4, "viewed": 57, "published": "Public", "date": "1636366219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**************************************************************/\n//Try a value between 5.0 and 100.0 \n//and fullscreen (if your GPU can handle it...)\nconst float WAVE_NR = 10.0;\n\n/*************************************************************/\n    \n\nvoid mainImage( out vec4  \nfragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Move origin so x and y goes from -0.5 to 0.5\n    uv -= 0.5;\n    // Scale x coordinate to rectangular window (x is about -0.8 to 0.8)\n    uv.x *= iResolution.x / iResolution.y;\n \n    float WAVE_WIDTH = 0.02/sqrt(WAVE_NR);\n    //nr_factor allows the waves to live for 10 seconds\n    float nr_factor = WAVE_NR/10.0;\n    //Background color\n    //solid color\n    vec3 col = vec3(0.1,0.4,0.7);\n    //soft moving bluish color\n    float red   = (sin(iTime*0.354)+1.0)*0.15;\n    float green = (sin(iTime*0.123)+1.0)*0.15+0.25;\n    float blue  = (sin(iTime*0.678)+1.0)*0.25+0.5;\n    col = vec3(red,green,blue);\n    //White color (for wave)\n    vec3 white = vec3(1.0);\n    //\"Integer\" part of iTime (adjusted with nr_factor if more than 10 waves)\n    float intTime = floor(iTime*nr_factor)/nr_factor;\n    //Create a loop that looks back in time\n    for (float i = 0.0; i < WAVE_NR; i++)\n    {\n        //Calculate time backwards\n        float iT = (intTime - i/nr_factor);\n        //See where the startPoint was some time ago\n        vec2 startPoint = 0.5*vec2(sin(iT*0.95), cos(iT*0.67));\n        //Get the distance from a previous startpoint to the current point (pixel)\n        float dist = distance(uv,startPoint);\n        //The edge of the wave has a radius that grows.\n        //The further back in time, the larger the radius\n        //The radius goes from 0.0 up to 1.0, because i goes from 0.0 to 10.0\n        float waveRadius = (fract(iTime*nr_factor)/nr_factor + i/nr_factor)/10.0;\n        //Compare the distance to the wave radius\n        float wave = abs(dist-waveRadius);\n        //If the distance and the radius are close then color this pixel\n        if (wave < WAVE_WIDTH){\n            //The center of the wave edge should be most intense\n            //float intensity = (WAVE_WIDTH-wave)*50.0;\n            float intensity = 0.5*smoothstep(WAVE_WIDTH,0.5*WAVE_WIDTH,wave);\n            //Create fading effect\n            //If the distance is small, the color should be intense\n            //If the distance is large, the color should be pale\n            intensity = (1.0-dist)*intensity;\n            //Use intensity to make white color\n            col += white*intensity;\n            \n        }\n        //Testing the path of startpoint\n        //if (dist < 0.1) col += vec3(0.5,0.0,0.5)/i;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 308, 358, 2767]], "test": "valid"}
{"id": "Nl3GDj", "name": "Mandelbrot-Set Danny", "author": "danieletaat", "description": "Renders the Mandelbrot set.", "tags": ["fractals"], "likes": 1, "viewed": 42, "published": "Public", "date": "1636752552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float NUM_ITERATIONS = 512.0;\nconst float zoomSpeed = 10.0;\nconst float width = 10.0;\n//const vec2 center = vec2(-0.742978, 0.1);\nconst vec2 center = vec2(-0.747005, 0.150006);\n//const vec2 center = vec2(0.0, 0.0);\n\nvec2 f(vec2 z, vec2 c) {    \n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.y * z.x) + c;\n}\n\nfloat iter(vec2 c) {\n\n    float nrm = dot(c, c);\n    // http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n    if( 256.0*nrm*nrm - 96.0*nrm + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n    // http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n    if( 16.0*(nrm+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    \n    vec2 z = vec2(0.0, 0.0);\n    float i;\n    for (i = 0.0; i < NUM_ITERATIONS; i += 1.0) {\n        z = f(z, c);\n        if (dot(z, z) > 4.0) break;\n    }\n    if (i >= NUM_ITERATIONS) \n        return 0.0;  \n        \n    // smooth out the coloring\n    float si = i - log2(log2(dot(z,z))) + 4.0;\n    float ai = smoothstep( -0.1, 0.0, 0.0);\n    i = mix(i, si, ai);\n\n    return i;\n}\n\nvec2 rotateCoord(vec2 c) {\n    float theta = 3.14 + 3.14 * cos(iTime / 10.0);\n    float x = (c.x - center.x) * cos(theta) - (c.y - center.y) * sin(theta) + center.x;\n    float y = (c.x - center.x) * sin(theta) + (c.y - center.y) * cos(theta) + center.y;\n    return vec2(x, y);\n    \n}\n\nvec2 transformCoord(vec2 fragCoord) {\n    float rescale = pow(zoomSpeed, -2.75 + 2.75*cos(iTime / 10.0));\n    vec2 size = vec2(width, iResolution.y / iResolution.x * width) * rescale;\n    vec2 uv = fragCoord/iResolution.xy;\n    return rotateCoord((uv - 0.5) * size + center);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 c = transformCoord(fragCoord);\n    float i = iter(c);    \n    // color calculation\n    vec3 col = 0.5 + 0.5*cos( 3.0 + 0.05*i + vec3(0.50, 0.05, 0.05));\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 246, 246, 313], [315, 315, 335, 335, 1008], [1010, 1010, 1036, 1036, 1293], [1295, 1295, 1332, 1332, 1572], [1574, 1574, 1629, 1629, 1825]], "test": "valid"}
{"id": "Nl3GRs", "name": "Fbm: Calamity", "author": "Yusef28", "description": "An fbm noise texture", "tags": ["2d", "noise", "fbm", "color", "calamity", "vibrant"], "likes": 13, "viewed": 152, "published": "Public API", "date": "1636603342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*4254.);  \n}\n\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\nfloat voronoi(vec2 uv){\n  \n    float d = 100.;\n    vec2 uvFL = floor(uv);\n    vec2 uvFR = fract(uv);\n  \n    for(float i = -1.; i <= 1.; i++){\n      for(float j = -1.; j <= 1.; j++){\n        \n        vec2 nachbar = vec2(i,j);\n        \n        d = min(d, length( uvFR - noise(uvFL + nachbar)  - nachbar));\n      }\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n  \n  uv.x+=iTime*0.4+1.;\n  vec3 col = vec3(0.0);\n  \n  float fa1 = smoothstep(0.2, 0.9,\n              abs( fract(fbm(uv + length(uv)*0.5,5., 2.)*2.)-0.5) );\n  \n  \n  //float fb1 = fbm(uv*2. + vec2(3. ,3. ) ,5., 5.);\n  \n  \n\n // float fa2 = fbm(uv*2.*rot(2.) - vec2(8. ) + fa1 ,2., 3.);\n  \n  //float fa2fr = smoothstep(0.2, 0.5,\n  //            abs( fract(fa2*10.)-0.5) );\n  \n  float fb2 = fbm(uv*3.+ fa1/4. ,4., 3.);\n  \n  //float fb2fr = smoothstep(0., 0.9,\n  //            abs( fract(fb2*2.)-0.5) );\n \n // float fa3 = fbm(uv+ fa2 ,5., 1.);\n   float fb3 = fbm(uv*1.*rot(1.8) + vec2(1. ,47. ) + fb2 , 3., 2.);\n  \n  //softer version\n   //float fb3 = fbm(uv*1.*rot(1.8) + vec2(1. ,47. ) + fb2*.3 , 3., 2.);\n  \n  \n \n  \n  \n  \n  \n  \n  \n  \n   // col = mix(col, vec3(0.1), fb1/4.);\n//   col = mix(col, vec3(.0),fract(fa3*2.)*0.4-0.2);\n   \n    col = mix(col, vec3(sin(vec2(uv.x,uv.y))*1.3+0.2,0.5), pow(fb3, 3.));\n    col = mix(col, vec3(0.8,sin(uv.y),0.), pow(fb2, 8.)*4.);\n    col = mix(col, vec3(0.,0.,0.),fa1*0.99);\n    \n    \n    col *= voronoi(uv*2.)*7.;\n    //\n    col = mix(col, vec3(.4,0.9,0.9),pow(fb2,4.));\n    //col = mix(col, vec3(0.3,0.4,0.),fb2fr*.8);\n    \n    col = pow(col*vec3(0.9,0.99,0.9), vec3(1.));\n    \n   // col *= vec3(0.7,0.8,0.8);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 135], [138, 138, 161, 177, 499], [547, 547, 565, 565, 630], [631, 631, 669, 669, 880], [882, 882, 905, 905, 1215], [1216, 1216, 1273, 1273, 2615]], "test": "valid"}
{"id": "Nl3GW2", "name": "Persian carpet 19", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 107, "published": "Public API", "date": "1636693223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(2.+t2)-.5)/8.;\n    vec3 random2 = (hash31(3.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(4.+t2))/4.*0.;\n    //vec3 random4 = (hash31(5.+t2))/4.*0.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                uv = -triangle_wave(uv-offset,scale2)+triangle_wave(uv.yx,scale2)-col.yx;\n                uv += vec2(random1[k],random2[k]);\n                //uv = -triangle_wave(uv-offset,scale2)*(1.-random4[k])+triangle_wave(uv.yx,scale2)*(1.-random3[k])-col.yx;\n\n            }\n            col[c] = abs((uv.x)-(uv.y))/scale2;\n        }\n\t}\n    \n    //col /= 1.5;\n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 1840]], "test": "valid"}
{"id": "Nl3GWf", "name": "Fractal 91_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 129, "published": "Public", "date": "1636807848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void rot(inout vec3 p,vec3 a,float r){\n\ta=normalize(a);\n\tp=mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a);\n}\n\n#define sabs(p,k)sqrt((p)*(p)+(k))\n\nvoid sfold(inout vec2 p, vec2 v, float k)\n{\n    float g=dot(p,v);\n    p-=(g-sabs(g,k))*v;\n}\n\nvoid sfold90(inout vec2 p, float k)\n{\n    vec2 v=normalize(vec2(1,-1));\n    sfold(p,v,k);\n}\n\nfloat lpNorm(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\n#define hash(n) fract(sin(n*5555.5))\n\nfloat pt(vec2 uv)\n{\n    vec3 p=(vec3(uv,0));\n    p.z-=iTime*.05;\n    p.z=sin(p.z);\n    //p=asin(cos(p*3.));\n    float s=2.,e,res;\n    for(int i=0;i<10;i++)\n        p=abs(p)-1.2,\n        s*=e=5./clamp(dot(p,p),.8,4.),\n        p=p*e-3.;\n    e=(p.z/s)*.4;\n    return e;\n}\n\n\nfloat map(in vec3 p)\n{\n\trot(p,vec3(cos(iTime*.1),sin(iTime*.1),.7).xzy,iTime*.2);\n    p=abs(p)-vec3(2.);\n    float k=1e-7;\n    sfold90(p.xz,k);\n\tsfold90(p.yz,k);\n\tsfold90(p.xy,k);\n    p.x=abs(p.x)-.3;\n \n\tfloat d= lpNorm(p.xy,5.)-.05;\n    float q=pt(p.yz);\n    return min(d,lpNorm(vec2(q,p.x-clamp(p.x,-.01,.01)),5.)-.005 +hash(q*.1)*.005)*.7;\n  \n\t\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=1e-5*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.3,.5,.8)+cos(p)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 col= vec3(0);\n\tconst float maxd=50.;\n    float g=march(ro,rd,0.,maxd);\n    if(g<maxd)\n    {\n        vec3 p=ro+rd*g;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.3);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.4);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n        col *= exp(-.1 * g * g);\n        //col = pow(col,vec3(1.5))*3.;\n    }\n    fragColor=vec4(col,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 104], [142, 142, 185, 185, 233], [235, 235, 272, 272, 326], [328, 328, 365, 365, 423], [463, 463, 482, 482, 731], [734, 734, 756, 756, 1083], [1085, 1085, 1110, 1110, 1253], [1255, 1255, 1309, 1309, 1474], [1476, 1476, 1498, 1498, 1540], [1542, 1542, 1599, 1599, 2455]], "test": "valid"}
{"id": "Nl3GWr", "name": "Jonix metaballs", "author": "Hultsborn10", "description": "Metaballs inspired by CodingTrain", "tags": ["metaballsjonix"], "likes": 3, "viewed": 60, "published": "Public", "date": "1635949233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N(float t)\n{\n    //Psuedo random number between 0 and 1\n    //Enlarge t so that small changes in t will end up at \n    //very different points on the sine curve\n    //Enlarge the sine value (-1 to 1) and then return \n    //only the fraction part.\n    return fract(sin(t*3456.0)*6547.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int BALLS = 5;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 colors[5];\n    float cS = 0.4;\n    colors[0] = vec3(1.0,cS,cS);\n    colors[1] = vec3(1.0,1.0,cS);\n    colors[2] = vec3(cS,1.0,cS);\n    colors[3] = vec3(cS,cS,1.0);\n    colors[4] = vec3(1.0,cS,1.0);\n    \n    float sum = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < BALLS; i++){\n        float t = float(i);\n        float ranA = N(t*50.0);\n        float ranB = N(t*50.0+500.0);\n        vec2 ball = 0.5*vec2(sin(iTime*ranA), cos(iTime*ranB));    \n        float dist = distance(uv,ball)*15.0;\n        sum = 1.0 / dist;\n        if (sum > 1.0) sum = 1.0;\n        \n        col += colors[i%5]*sum;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 252, 294], [296, 296, 353, 353, 1201]], "test": "valid"}
{"id": "Nl3Gz2", "name": "Persian carpet 12", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 110, "published": "Public API", "date": "1636347753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/20.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col; \n            //float factor = 1.16;\n            //uv.y *= factor;\n\n            uv = triangle_wave(uv.yx-offset,scale)+triangle_wave(uv,scale);\n            for(int k = 0; k < 3; k++){\n                uv.y /= scale2;\n                //uv.y /= scale2-uv.x/2.;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]);\n                uv.x /= -scale2;\n                //uv.x /= -scale2-uv.y/2.;\n            }\n            //uv.x *= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            //uv = -uv.yx;\n            //uv = uv.yx;\n            //scale2 *= 1.25 + col.x;\n            //scale2 += col.x/8.;\n            scale2 = 1./(1.+col.x);\n            //col = (col*random1[i]+col_prev.yzx*(1.-random1[i]));\n            col[c] = fract((uv.x)-(uv.y));\n            //col[c] = abs(-col[c]-uv.x+uv.y);\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3Gz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2513]], "test": "valid"}
{"id": "Nlc3zf", "name": "Rounded Box SDF", "author": "TheTurk", "description": "Distance function for a rounded box (where the size of the box is not affected by the corner radius). ", "tags": ["distancefield", "sdf", "rectangle", "distance", "box", "rect", "rounded", "primitive"], "likes": 1, "viewed": 45, "published": "Public", "date": "1636414187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 position, vec2 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n\n    vec2 halfSize = vec2(0.7, 0.4);\n    float cornerRadius = ((cos(iTime + 1.0) + 1.0) * 0.5) * 0.4;\n\tfloat d = box(position, halfSize, cornerRadius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n    if (iMouse.z > 0.001) {\n        vec2 mousePosition = iMouse.xy / iResolution.xy;\n        mousePosition = (mousePosition * 2.0) - 1.0;\n        mousePosition.x *= iResolution.x / iResolution.y;\n        float d = box(mousePosition, halfSize, cornerRadius);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.0025, abs(length(position - mousePosition) - abs(d)) - 0.0025));\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 211], [213, 213, 268, 268, 1301]], "test": "valid"}
{"id": "Nlc3zM", "name": "i exaggerated my antialias code", "author": "HaleyHalcyon", "description": "I added antialiasing code, and made the \"pixel size\" used for antialiasing 8x bigger than it should be.\nClick the \"forked from\" link for the normal version", "tags": ["a"], "likes": 2, "viewed": 50, "published": "Public", "date": "1635844142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n// i want to use hex codes like in image editing programs,\n// so here's an improved macro by FabriceNeyret2\n#define HEX(x) vec3( ( ivec3(x) >> ivec3(16,8,0) ) & 255 ) / 255.\n\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        HEX(0x11151c),\n        HEX(0x390099),\n        HEX(0x9e0059),\n        HEX(0xff0054),\n        HEX(0xff5400),\n        HEX(0xffbd00),\n        HEX(0x127475),\n        HEX(0x8fefff)\n    );\n    x *= float(colorCount);\n    int lo = 1048576 + int(floor(x));\n    \n    return mix(\n        c[lo % colorCount],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\nfloat square(vec2 uv, float angle) {\n    // rotation.\n    // thank you FabriceNeyret for teaching me to git gud at rotating a 2D vector in glsl\n    uv *= mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    );\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 3.0);\n  // make the center of the canvas (0.0, 0.0) and\n  // make the long edge of the canvas range from -1.0 to +1.0\n  // we'll use the scale variable later for antialiasing bc it's the size of one pixel\n  float scale = max(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n\n  // i blend each square's color in order to antialias this shader\n  // are you proud of me yet Fabrice\n  vec3 col = vec3(0., 0., 0.);\n  float opacity = 0.;\n  float colOffset = 0.1;\n  const float iters = 32.;\n  float size = 0.002;\n  float sizeMult = 1.2;\n  float angleOffset = 0.12 * (2.5 + sin(time * TAU));\n  // i know, loops in glsl code, ew right\n  for (float i = 0.; i < iters; i++) {\n      // subtract from size and multiply by scale to get\n      // a nice \"pixels from boundary\" value\n      float dist = (square(\n          uv, -time * TAU + angleOffset * i\n      ) - size) * scale;\n      // for demonstration purposes only\n      dist /= 8.;\n      if ( // fully inside square\n          dist < 0.\n      ) {\n          col += (1. - opacity) * color(time + colOffset * i);\n          opacity = 1.;\n      } else if ( // partially inside square\n          dist < 1.\n      ) {\n          float newOpacity = max(0., (1. - dist) * (1. - opacity));\n          col += newOpacity * color(time + colOffset * i);\n          opacity += newOpacity;\n      } else { // fully outside square\n          // do nothing\n      }\n      // i'm not sure if this saves time for gpu calculation\n      // but i'm doing it anyway because it pleases me:\n      if (opacity >= 1.) {break;}\n      \n      size *= sizeMult; // better than calling pow()\n  }\n  \n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[641, 641, 677, 784, 912], [914, 914, 971, 971, 2705]], "test": "error"}
{"id": "NlcGDN", "name": "Gamozo Labs", "author": "nkaretnikov", "description": "Just a gift for Brandon Flask^W Falk.", "tags": ["2d", "simple", "flask"], "likes": 20, "viewed": 780, "published": "Public", "date": "1636119407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Public domain (but see below).\n//\n// Reference image: copyright 2021 Gamozo Labs:\n// https://twitter.com/gamozolabs\n// (Unfortunately, I don't know the name of the original artist to credit them.)\n\n// Thanks to Martijn Steinrucken (BigWings) for tutorials:\n// https://www.youtube.com/c/TheArtofCodeIsCool\n// https://www.shadertoy.com/user/BigWings\n// https://twitter.com/The_ArtOfCode\n\n#define S(a,b,x) smoothstep(a,b,x)\n#define C(a,b,x) clamp(x,a,b)\n\n// Thanks to Inigo Quilez (iq) for SDFs (and everything else):\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// https://www.shadertoy.com/user/iq\n// License: MIT.\n//\n////////////////////////////////////////////////////////////////////////////////\n// start paste\n\n// p: position\n// r: radius\nfloat sdCircle(vec2 p,float r)\n{\n    return length(p)-r;\n}\n\n// p:   position\n// s.x: width\n// s.y: height\nfloat sdBox(vec2 p,vec2 s)\n{\n    vec2 d = abs(p)-s;\n    \n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\n// p:   position\n// s.x: width\n// s.y: height\n// r.x: roundness top-right  \n// r.y: roundness bottom-right\n// r.z: roundness top-left\n// r.w: roundness bottom-left\nfloat sdRoundBox(vec2 p,vec2 s,vec4 r) \n{\n    r.xy = (p.x>0.)?r.xy:r.zw;\n    r.x  = (p.y>0.)?r.x :r.y;\n    \n    vec2 q = abs(p)-s+r.x;\n    \n    return min(max(q.x,q.y),0.)+length(max(q,0.))-r.x;\n}\n\nfloat sdEllipse(vec2 p,vec2 ab)\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    \n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    \n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    \n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    \n    return length(r-p) * sign(p.y-r.y);\n}\n\n// sca: sin/cos of the orientation\n// scb: sin/cos of the aperture\nfloat sdArc(vec2 p,vec2 sca,vec2 scb,float ra,float rb)\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    \n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    \n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n// end paste\n////////////////////////////////////////////////////////////////////////////////\n\n// Thanks to Maarten for functions for working with SDFs:\n// https://www.shadertoy.com/view/4dfXDn\n//\n////////////////////////////////////////////////////////////////////////////////\n// start paste\n\nfloat sdSmoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(.5+.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.-h);\n}\n\nfloat sdMerge(float d1,float d2)\n{\n\treturn min(d1,d2);\n}\n\n\nfloat sdMergeExclude(float d1,float d2)\n{\n\treturn min(max(-d1,d2),max(-d2,d1));\n}\n\n\nfloat sdSubtract(float d1,float d2)\n{\n\treturn max(-d1,d2);\n}\n\n\nfloat sdIntersect(float d1,float d2)\n{\n\treturn max(d1,d2);\n}\n// end paste\n////////////////////////////////////////////////////////////////////////////////\n\n// Thanks to NinjaKoala for the cubic bezier SDF:\n// https://www.shadertoy.com/view/4sKyzW\n//\n////////////////////////////////////////////////////////////////////////////////\n// start paste\n\n/*\nExact distance to cubic bezier curve by computing roots of the derivative(s)\nto isolate roots of a fifth degree polynomial and Halley's Method to compute them.\nInspired by https://www.shadertoy.com/view/4sXyDr and https://www.shadertoy.com/view/ldXXWH\nSee also my approximate version:\nhttps://www.shadertoy.com/view/lsByRG\n*/\nconst float eps = .000005;\nconst int halley_iterations = 8;\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tvec2 min1_2 = min(roots.xz,roots.yw);\n\tvec2 max1_2 = max(roots.xz,roots.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\ttmp[0] = min(min1_2.x,min1_2.y);\n\ttmp[1] = min(maxmin,minmax);\n\ttmp[2] = max(minmax,maxmin);\n\ttmp[3] = max(max1_2.x,max1_2.y);\n\n\troots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\n//halley's method\n//basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n//see http://mathworld.wolfram.com/HalleysMethod.html\n//or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                s[0] = tmp[0];\n                s[1] = tmp[1];\n            }\n            else{//old_num == 2\n                s[2] = tmp[0];\n                s[3] = tmp[1];\n            }\n        }\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_roots){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos < uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1 = p0.xy - p1.xy;\n\tvec2 tang2 = p2.xy - p3.xy;\n\n\tvec2 nor1 = vec2(tang1.y,-tang1.x);\n\tvec2 nor2 = vec2(tang2.y,-tang2.x);\n\n\tif(p0.y < p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\t//switch points when near to end point to minimize numerical error\n\t//only needed when control point(s) very far away\n\t#if 0\n\tvec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);\n\tvec2 mid_points = (p0 + p3)/2.;\n\n\tvec2 tang = mid_curve-mid_points;\n\tvec2 nor = vec2(tang.y,-tang.x);\n\n\tif(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){\n\t\tvec2 tmp = p0;\n\t\tp0 = p3;\n\t\tp3 = tmp;\n\n\t\ttmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\t#endif\n\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n    \n    //compute polynomial describing distance to current pixel dependent on a parameter t\n\tfloat bc6 = dot(a3,a3);\n\tfloat bc5 = 2.*dot(a3,a2);\n\tfloat bc4 = dot(a2,a2) + 2.*dot(a1,a3);\n\tfloat bc3 = 2.*(dot(a1,a2) + dot(a0,a3));\n\tfloat bc2 = dot(a1,a1) + 2.*dot(a0,a2);\n\tfloat bc1 = 2.*dot(a0,a1);\n\tfloat bc0 = dot(a0,a0);\n\n\tbc5 /= bc6;\n\tbc4 /= bc6;\n\tbc3 /= bc6;\n\tbc2 /= bc6;\n\tbc1 /= bc6;\n\tbc0 /= bc6;\n    \n    //compute derivatives of this polynomial\n\n\tfloat b0 = bc1 / 6.;\n\tfloat b1 = 2. * bc2 / 6.;\n\tfloat b2 = 3. * bc3 / 6.;\n\tfloat b3 = 4. * bc4 / 6.;\n\tfloat b4 = 5. * bc5 / 6.;\n\n\tvec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tvec4 roots_drv = vec4(1e38);\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfloat ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);\n\tfloat lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);\n\n\tvec3 a = vec3(1e38);\n\tvec3 b = vec3(1e38);\n\n\tvec3 roots = vec3(1e38);\n\n\tint num_roots = 0;\n    \n\t//compute root isolating intervals by roots of derivative and outer root bounds\n    //only roots going form - to + considered, because only those result in a minimum\n\tif(num_roots_drv==4){\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){\n\t\t\ta[0]=lb;\n\t\t\tb[0]=roots_drv[0];\n\t\t\tnum_roots=1;\n\t\t}\n\n\t\tif(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){\n            if(num_roots == 0){\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=roots_drv[2];\n                num_roots=1;\n            }\n            else{\n            \ta[1]=roots_drv[1];\n\t\t\t\tb[1]=roots_drv[2];\n                num_roots=2;\n            }\n\t\t}\n\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){\n            if(num_roots == 0){\n                a[0]=roots_drv[3];\n                b[0]=ub;\n                num_roots=1;\n            }\n            else if(num_roots == 1){\n                a[1]=roots_drv[3];\n                b[1]=ub;\n                num_roots=2;\n            }\n            else{\n                a[2]=roots_drv[3];\n                b[2]=ub;\n                num_roots=3;\n            }\n\t\t}\n\t}\n\telse{\n\t\tif(num_roots_drv==2){\n\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=ub;\n\t\t\t}\n\t\t\telse if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum_roots=2;\n\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\n\t\t\t\ta[1]=roots_drv[1];\n\t\t\t\tb[1]=ub;\n\t\t\t}\n\n\t\t}\n\t\telse{//num_roots_drv==0\n\t\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\n\t\t\tvec2 roots_trd_drv=vec2(1e38);\n\t\t\tint num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t\tnum_roots=1;\n\n\t\t\ta[0]=lb;\n\t\t\tb[0]=ub;\n\t\t}\n        \n        //further subdivide intervals to guarantee convergence of halley's method\n\t\t//by using roots of further derivatives\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tsort_roots3(roots_snd_drv);\n\n\t\tint num_roots_trd_drv=0;\n\t\tvec2 roots_trd_drv=vec2(1e38);\n\n\t\tif(num_roots_snd_drv!=3){\n\t\t\tnum_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots){\n\t\t\t\tfor(int j=0;j<3;j+=2){\n\t\t\t\t\tif(j < num_roots_snd_drv){\n\t\t\t\t\t\tif(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(j < num_roots_trd_drv){\n\t\t\t\t\t\tif(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat d0 = 1e38;\n\n    //compute roots with halley's method\n    \n\tfor(int i=0;i<3;i++){\n\t\tif(i < num_roots){\n\t\t\troots[i] = .5 * (a[i] + b[i]);\n\n            for(int j=0;j<halley_iterations;j++){\n\t\t\t\troots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);\n            }\n\t\t\t\n\n            //compute squared distance to nearest point on curve\n\t\t\troots[i] = clamp(roots[i],0.,1.);\n\t\t\tvec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,dot(to_curve,to_curve));\n\t\t}\n\t}\n\n\treturn sqrt(d0);\n}\n// end paste\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sdCubicBezier(vec2 uv,vec2 p,vec2 a,vec2 b,vec2 c,vec2 d)\n{\n    float cd = cubic_bezier_dis( uv-p,a,b,c,d);\n    float cs = cubic_bezier_sign(uv-p,a,b,c,d);\n    \n    return cd * cs;\n}\n\n// p: position\n// r: radius\n// b: blur\nvec4 Circle(vec4 col,vec2 uv,vec2 p,float r,float b)\n{\n    float d = sdCircle(uv-p,r);\n    \n    col.a = S(r+b,r-b,d);\n\n    return col;\n}\n\n// d: distance\n// s: start\n// e: end\n// b: blur\nvec4 Band(vec4 col,float d,float s,float e,float b)\n{\n    float s1 = S(s-b,s+b,d);\n    float s2 = S(e+b,e-b,d);\n\n    col.a = s1*s2;  // intersection\n    \n    return col;\n}\n\n// p:   position\n// s.x: width\n// s.y: height\n// b:   blur\nvec4 Rect(vec4 col,vec2 uv,vec2 p,vec2 s,float b)\n{\n    float d1 = sdBox(uv-p,s-b);\n    float d2 = sdBox(uv-p,s+b);\n    \n    col.a = S(d2,d1,b);\n\n    return col;\n}\n\n// s.x: width\n// s.y: height\n// r.x: roundness top-right  \n// r.y: roundness bottom-right\n// r.z: roundness top-left\n// r.w: roundness bottom-left\n// b:   blur\nvec4 RoundRect(vec4 col,vec2 uv,vec2 p,vec2 s,vec4 r,float b)\n{\n    float d1 = sdRoundBox(uv-p,s-b,r);\n    float d2 = sdRoundBox(uv-p,s+b,r);\n    \n    col.a = S(d2,d1,b);\n    \n    return col;\n}\n\nfloat sdFlaskBody(\n    vec2 uv,\n    vec2 tp,vec2 ts,vec4 rd,\n    vec2 mp,vec2 ms,\n    vec2 bp,float r,\n    float s)\n{\n    float dt = sdRoundBox(uv-tp,ts,rd);\n    float dm = sdBox(uv-mp,ms);\n    float db = sdCircle(uv-bp,r);\n           \n    float d = sdSmoothMerge(sdSmoothMerge(dt,dm,s),db,s);\n    \n    return d;\n}\n\n// tp: top position\n// ts: top size (width, height)\n// rd: top roundness\n//\n// mp: middle position\n// ms: middle size (width, height)\n//\n// bp: bottom position\n// r:  bottom radius\n//\n// s: smoothness\n// b: blur\nvec4 FlaskBody(\n    vec4 col,vec4 bcol,vec2 uv,\n    vec2 tp,vec2 ts,vec4 rd,\n    vec2 mp,vec2 ms,\n    vec2 bp,float r,\n    float s,float b)\n{         \n    float d1 = sdFlaskBody(uv,tp,ts-b,rd-b,mp,ms-b,bp,r-b,s);\n    float d2 = sdFlaskBody(uv,tp,ts+b,rd+b,mp,ms+b,bp,r+b,s);\n    \n    col = mix(col,bcol,S(d2,d1,b));\n   \n    return col;\n}\n\n// p: circle position\n// r: circle radius\n// b: blur\nvec4 FlaskFace(\n    vec4 col,vec4 bcol,vec4 fcol,vec4 ocol,\n    vec2 uv,vec2 p,float r,float ow,float b)\n{\n    // Liquid.\n    float k = .001;  // smoothness\n    \n    float cd  = sdCircle(uv-p,r);\n\n    float h = .24;  // height\n\n    vec2 p0 = vec2(p.x-r,p.y+h);\n\tvec2 p1 = vec2(p.x,p.y+h+r/2.-.02);\n\tvec2 p2 = vec2(p.x,p.y+h-r/2.-.02);\n\tvec2 p3 = vec2(p.x+r,p.y+h);\n    \n    vec2 bv = vec2(-uv.x,uv.y);\n\n    float cf = sdCubicBezier(uv,p,p0,p1,p2,p3);\n    float cb = sdCubicBezier(bv,p,p0,p1,p2,p3);\n    \n    float df = sdSmoothMerge(-cd,-cf,k);\n    float db = sdSmoothMerge(-cd,-cb,k);\n    \n    float bg = p.y+S(.2,2.,-uv.y*7.2);  // back gradient\n    float fg = p.y+S(.2,2.,-uv.y*2.2);  // front gradient\n    \n    fg += S(-0.5,5.,-abs(uv.x*.2));\n    \n    // Eyes.\n    vec2 es  = vec2(.035,.056);         // ellipse size\n    vec2 elp = vec2(p.x-.135,p.y-.07);  // ellipse left position\n    vec2 erp = vec2(p.x+.135,p.y-.07);  // ellipse right position\n    float el = sdEllipse(uv-elp,es);    // left\n    float er = sdEllipse(uv-erp,es);    // right\n    \n    // Eye pupils (or reflections?).\n    vec2 ps  = vec2(es.x-.027,es.y-.045);\n    vec2 plp = vec2(elp.x+.005,elp.y+.02);\n    vec2 prp = vec2(erp.x+.005,erp.y+.02);\n    float pl = sdEllipse(uv-plp,ps);\n    float pr = sdEllipse(uv-prp,ps);\n    \n    // Cheeks.\n    vec2 cs  = vec2(es.x+.005,es.y-.035);\n    vec2 clp = vec2(elp.x,elp.y-.05);\n    vec2 crp = vec2(erp.x,erp.y-.05);\n    float cl = sdEllipse(uv-clp,cs);\n    float cr = sdEllipse(uv-crp,cs);\n        \n    // Mouth.\n    vec2  ap = vec2(p.x,p.y-.03);  // mouth position\n    float ta = -3.14/2.;\n    float tb = 1.;\n    float ra = .06;\n    float rb = .009;\n    \n    float d = sdArc(uv-ap,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)),ra,rb);\n    d = -d;\n \n    // Draw the face.\n\tcol = mix(col,ocol,   S(db+b,db-b,b));\n    col = mix(col,fcol-bg,S(db-ow+b,db-ow-b,b));    \n    \n\tcol = mix(col,ocol,   S(df+b,df-b,b));\n    col = mix(col,fcol-fg,S(df-ow+b,df-ow-b,b));\n\n    col = mix(bcol+ocol,col,S(cl+b,cl-b,b));\n    col = mix(bcol+ocol,col,S(cr+b,cr-b,b));\n\n    col = mix(ocol,col,S(el+b,el-b,b));\n    col = mix(ocol,col,S(er+b,er-b,b));\n    \n    col = mix(bcol+ocol,col,S(pl+b,pl-b,b));\n    col = mix(bcol+ocol,col,S(pr+b,pr-b,b));\n    \n    col = mix(ocol,col,S(d-b,d+b,b));\n\n    return col;\n}\n\nvec4 FlaskFace(vec4 col,vec2 uv,vec2 p,float t)\n{\n    uv -= p;\n\n    vec4 mcol = vec4(1.,1.,1.,1.);     // mask color\n    vec4 bcol = vec4(.95,.42,.59,1.);  // body color\n    vec4 ocol = vec4(.31,.18,.54,1.);  // outline color\n    vec4 fcol = vec4(.92,.19,.51,1.);  // face color\n    \n    float b = .001;  // blur\n    \n    // Top.\n    vec2 tp = vec2(.0,.343);   // position\n    vec2 ts = vec2(.16,.028);  // width, height\n    vec4 rd = vec4(.017);      // roundness\n\n    // Middle.\n    vec2 mp = vec2(0.,0.);    // position\n    vec2 ms = vec2(.13,.35);  // width, height\n\n    // Bottom.\n    vec2  bp = vec2(0.,-.15);  // position\n    float r  = .29;            // radius\n    \n    // Face.\n    vec2 fp = vec2(0.,-.15);  // position\n\n    // Draw the body.\n    vec2 rv  = vec2(uv.x+.041,uv.y-.02);\n    vec2 rv2 = vec2(rv.x+.09,rv.y);\n    vec2 lv  = vec2(uv.x-.04,uv.y);\n        \n    float ow = .015; // outline width\n    float s  = .01;  // smoothness\n    \n    #define FlaskBodyO(col,bcol,uv) \\\n       FlaskBody(col,bcol,uv,tp,ts+ow,rd+ow,mp,ms+ow,bp,r+ow,s,b)\n    #define FlaskBodyS(col,bcol,uv) \\\n       FlaskBody(col,bcol,uv,tp,ts,rd,mp,ms,bp,r,s,b)\n   #define FlaskBodyR(col,bcol,uv) \\\n       FlaskBody(col,bcol,uv,tp,ts,rd,mp,ms,bp,r-.05,s,b)\n       \n    bcol -= ocol;  // account for the outline\n    \n    vec4 fo  = FlaskBodyO(col,ocol,uv);  // flask outline\n    vec4 f   = FlaskBodyS(col,bcol,uv);  // flask color\n    \n    vec4 fm  = FlaskBodyS(col,mcol,uv);  // base mask\n    vec4 fml = FlaskBodyS(col,mcol,lv);  // base mask, shifted right\n    \n    vec4 fms = FlaskBodyR(col,mcol,rv);   // base mask, shifted left\n    vec4 fmr = FlaskBodyR(col,mcol,rv2);  // mask right, shifted left\n    \n    vec4 rr = C(0.,1.,fms-fmr);  // reflection right, shifted left\n    vec4 rl = C(0.,1.,fm -fml);  // reflection left\n    \n    rr *= .1*S(.6,1.,1.-abs(uv.y));  // smooth reflections\n    rl *= .1*S(.0,1.,1.-abs(uv.y));\n    \n    rr *= S(-.2,2.,uv.x*7.);  // hide the sharp corner on the left\n    \n    vec4 br = f + (fm*(S(-uv.y,-uv.y+.7,-.03)));  // base and top gradient\n    br = mix(br,fm,fm.a*(uv.y+.3)*.9);            // flask gradient  \n    col = mix(col,fo,fo.a);\n    \n    col += br;\n                \n    // Draw the face.\n    float fr = r*.88;  // face radius\n    float fg = fp.y+(1.-uv.y)*.2;  // front gradient\n    vec4 fa = FlaskFace(col,bcol,fcol,ocol,uv,fp,fr,ow,b);  // face    \n    col = fa-(fa*fg);\n    \n    col += rl*9.;  // reflections\n    col += rr*2.;  \n\n    // Draw bubbles.\n    vec4 ucol = fcol;\n    \n    float t1 = t/4.;\n    float t2 = t/5.;\n    float t3 = t/6.;\n    float t4 = t/7.;\n    float t5 = t/8.;\n    float t6 = t/9.;\n    float t7 = t/10.;\n    float t8 = t/11.;\n    float t9 = t/12.;\n    \n    vec2 bp1 = vec2(-.03+sin(t1)/20.,.038+mod(t1,.4)-.1);\n    vec2 bp2 = vec2(-.062+sin(t2)/20.,.10+mod(t2,.4)-.1);\n    vec2 bp3 = vec2(.035+sin(t3)/20.,.06+mod(t3,.4)-.1);\n    vec2 bp4 = vec2(.01+sin(t4)/20.,.165+mod(t4,.4)-.1);\n    vec2 bp5 = vec2(-.036+sin(t5)/20.,.24+mod(t5,.4)-.1);\n    vec2 bp6 = vec2(.048+sin(t6)/20.,.28+mod(t6,.4)-.1);\n    vec2 bp7 = vec2(-.06+sin(t7)/20.,.31+mod(t7,.4)-.1);\n    vec2 bp8 = vec2(-.02+sin(t8)/20.,.42+mod(t8,.2)-.1);\n    vec2 bp9 = vec2(.025+sin(t9)/20.,.445+mod(t9,.2)-.1);\n    \n    float bs1 = mod((t1/100.),.009);\n    float bs2 = mod((t2/50.),.0054);\n    float bs3 = mod((t3/120.),.005);\n    float bs4 = mod((t4/70.),.014);\n    float bs5 = mod((t5/140.),.009);\n    float bs6 = mod((t6/90.),.0083);\n    float bs7 = mod((t7/60.),.0045);\n    float bs8 = mod((t8/130.),.004);\n    float bs9 = mod((t9/80.),.0065);\n    \n    ucol += S(uv.y+.3, -uv.y,.5);  // bubble gradient\n    \n    vec4 b1 = Circle(ucol,    uv,bp1,bs1,b);\n    vec4 b2 = Circle(ucol,    uv,bp2,bs2,b);\n    vec4 b3 = Circle(ucol,    uv,bp3,bs3,b);\n    vec4 b4 = Circle(ucol,    uv,bp4,bs4,b);\n    vec4 b5 = Circle(ucol,    uv,bp5,bs5,b);\n    vec4 b6 = Circle(ucol,    uv,bp6,bs6,b);\n    vec4 b7 = Circle(ucol,    uv,bp7,bs7,b);\n    vec4 b8 = Circle(ucol*.85,uv,bp8,bs8,b);\n    vec4 b9 = Circle(ucol*.85,uv,bp9,bs9,b);\n    \n    col = mix(col,b1,b1.a);\n    col = mix(col,b2,b2.a);\n    col = mix(col,b3,b3.a);\n    col = mix(col,b4,b4.a);\n    col = mix(col,b5,b5.a);\n    col = mix(col,b6,b6.a);\n    col = mix(col,b7,b7.a);\n    col = mix(col,b8,b8.a);\n    col = mix(col,b9,b9.a);\n       \n    // Draw the rim over the bubbles.\n    // XXX: This ugly hack is needed since the flask is not transparent.\n    vec2 rp = vec2(tp.x,tp.y+ts.y/2.+ow+ow/2.);  // position\n    vec2 rs = vec2(ts.x-rd.x,ow/2.-b/2.-b);      // size\n    vec4 ri = Rect(ocol,uv,rp,rs,b);\n    \n    col = mix(col,ri,ri.a);\n    \n    return col;\n}\n\n// https://www.shadertoy.com/view/wdB3DW\n// https://en.wikipedia.org/wiki/Rotation_matrix\n// https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Matrix_constructors\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,s,-s,c);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Move (0,0) to the center of the screen.\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;  \n  \n    // Draw the image.\n    vec4 col = vec4(0.);\n     \n    float t = iTime;\n     \n    vec2 p = vec2(0.,0.);  // position        \n    vec4 ocol = col;       // old color\n    \n    // t = 10.3;    \n    \n    // XXX: Slow.\n    /*\n    uv *= 2.;  // scale coordinates\n\n    for (int i=-10; i<10; i+=1) {\n        float fi = float(i)*1.-mod(t*2.,2.);\n        \n        vec2 lv = uv*r2d(t*fi);\n        vec2 lp = vec2(p.x+fi,p.y)*r2d(t*fi);\n        \n        vec4 f = FlaskFace(col,lv,lp,t);        \n        \n        ocol += f;\n    }\n    */\n    \n    uv *= r2d(t);          // rotate\n    uv *= (1.+sin(t*2.));  // scale coordinates\n        \n    vec4 f = FlaskFace(col,uv,p,t);\n    ocol = f;\n    \n    col = ocol;\n   \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcGDN.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[751, 779, 811, 811, 837], [839, 885, 913, 913, 994], [996, 1160, 1201, 1201, 1356], [1358, 1358, 1391, 1391, 2433], [2435, 2502, 2559, 2559, 2747], [3042, 3042, 3092, 3092, 3174], [3176, 3176, 3210, 3210, 3232], [3235, 3235, 3276, 3276, 3316], [3319, 3319, 3356, 3356, 3379], [3382, 3382, 3420, 3420, 3442], [4119, 4222, 4300, 4300, 4893], [4895, 4954, 5032, 5032, 5628], [5630, 5630, 5702, 5702, 5883], [5885, 5885, 5920, 5920, 6091], [6093, 6093, 6128, 6128, 6445], [6447, 6447, 6523, 6523, 6601], [6603, 6829, 6912, 6912, 7169], [7171, 7171, 7217, 7217, 7493], [7495, 7616, 7665, 7703, 7916], [7918, 8003, 8046, 8046, 9061], [9063, 9184, 9229, 9229, 11215], [11217, 11489, 11558, 11558, 12720], [12722, 12722, 12790, 12910, 17687], [17783, 17783, 17848, 17848, 17971], [17973, 18012, 18066, 18066, 18148], [18150, 18198, 18251, 18251, 18369], [18371, 18430, 18481, 18481, 18593], [18595, 18755, 18818, 18818, 18948], [18950, 18950, 19067, 19067, 19264], [19266, 19478, 19619, 19619, 19815], [19817, 19870, 19976, 19991, 22170], [22172, 22172, 22221, 22221, 26793], [26795, 26961, 26980, 26980, 27055], [27057, 27057, 27111, 27158, 27984]], "test": "error"}
{"id": "Nld3Dj", "name": "CPS-Sphere", "author": "peremoya2000", "description": "A short phong lit sphere render shader based on a circle.", "tags": ["phong", "interactive", "lighting", "sphere", "short"], "likes": 0, "viewed": 32, "published": "Public", "date": "1636808257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Define vars\nvec3 sphereCol = vec3(0.8,.15,.15);\nvec3 viewDir = vec3(0,0,-1);\nvec3 ambientLight = vec3(.1f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5f;\n    uv.x*=iResolution.x/iResolution.y; \n    \n    //Calculate lightDir by mouse\n    vec2 mousePos = iMouse.xy / iResolution.xy +.5f;\n    vec3 lightDir = normalize(vec3(1.f-mousePos,-.6f));\n    \n    //Define and Phong Shade circle\n    float r = (sin(iTime)*.05f+.15f);\n    vec3 surface3DPoint = vec3 (uv, sqrt(r - uv.x*uv.x - uv.y*uv.y));\n    vec3 normal = normalize(surface3DPoint);\n    \n    float lambertian = max(dot(normal, -lightDir) , 0.f);\n    \n    vec3 reflectionRay = reflect(lightDir,normal);\n    float specular = pow(max(0.f,dot(-viewDir,reflectionRay)),10.f);\n    \n    vec3 col = (lambertian*sphereCol*.6f)+(specular*.4f)+ambientLight;\n    \n    // Output to screen\n    fragColor = vec4(col,1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 218, 970]], "test": "valid"}
{"id": "Nld3R2", "name": "Noisey pulsate", "author": "ysp125", "description": "Cool pulsating noise on circles", "tags": ["noise"], "likes": 5, "viewed": 108, "published": "Public", "date": "1636368164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define PI     3.14159265\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   vec2 uv = fragCoord.xy;\n   float f1 = noise( uv*0.03*0.5 );\n   float f2 = noise( uv*0.03*0.5 );\n   float f3 = noise( uv*0.03*0.5 );\n   f1 *= smoothstep( 0.0, 10.0, abs(uv.x) ) * 200.0;\n   f2 *= smoothstep( 0.0, 10.0, abs(uv.x) ) * 200.0;\n   f3 *= smoothstep( 0.0, 10.0, abs(uv.x) ) * 200.0;\n   \n   float cols[3] = float[3](0.0,0.0,0.0);\n   \n   float size = 0.05;\n   \n   vec2 center;\n   vec2 displacement;\n   \n   center = vec2(iResolution.x/2.0 + (cos(iTime * 0.1) * 400.0 + f1), iResolution.y/2.0 + (sin(iTime * 0.3) * 200.0 + f1));\n   displacement = uv - center;\n   cols[0] += 1.0/(length(displacement)*size);\n   \n   center = vec2(iResolution.x/2.0 + (sin(iTime * 0.1) * 400.0 + f2), iResolution.y/2.0 + (cos(iTime * 0.3) * 200.0 + f2));\n   displacement = uv - center;\n   cols[1] += 1.0/(length(displacement)*size);\n   \n   center = vec2(iResolution.x/2.0 + (sin(iTime * 0.1) * 400.0 + f3), iResolution.y/2.0 + (sin(iTime * 0.3) * 200.0 + f3));\n   displacement = uv - center;\n   cols[2] += 1.0/(length(displacement)*size);\n   \n   fragColor = vec4(cols[0],cols[1],cols[2],0.0);\n             \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 207], [209, 209, 235, 235, 529], [531, 531, 588, 588, 1685]], "test": "valid"}
{"id": "Nld3RH", "name": "Sine Wave Animation 2", "author": "SerialSniper", "description": "Sine.", "tags": ["animation", "sine"], "likes": 2, "viewed": 46, "published": "Public", "date": "1635776713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// decrease for higher framerate\n#define QUALITY 10.0\n\nconst float radius = 0.03;\nconst float gap = 2.5;\nconst float amplitude = .1;\n\nfloat speed = 1.0;\nfloat freq = 1.0;\nfloat invert = 1.0;\n\nfloat start = -.5 * 1.1;\nfloat end = .5 * 1.1;\n\n// separated method for performance\nvoid update(float x) {\n    if(cos(iTime * 2. - gap) >= 0.0)\n        start = sin(iTime * 2. - gap) / 2.0 * 1.1;\n    if(cos(iTime * 2.) >= 0.0)\n        end = sin(iTime * 2.) / 2.0 * 1.1;\n        \n    if(start == -.5 * 1.1 && end == .5 * 1.1) {\n        start = .5 * 1.1;\n        end = -.5 * 1.1;\n    }\n    \n    invert = sin(iTime * 2.0);\n    speed = sin(iTime) + 1.0;\n}\n\nfloat func(float x) {\n    if(x <= end && x >= start)\n        return -10.;\n    return sin((x + speed + iTime / 2.0) * 30.0) * amplitude * invert;\n}\n\nbool wave(float x, float y) {\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float left = (x - radius * ratio.x) * iResolution.x;\n    float right = (x + radius * ratio.x) * iResolution.x;\n    \n    update(x);\n    \n    // Remove too distant pixels from calculation\n    if(abs(y) > amplitude / 2. + radius * 2. + .1)\n        return false;\n    \n    float leftSin = func(left / iResolution.x);\n    float rightSin = func(right / iResolution.x);\n    \n    for(float i = left; i <= right; i += 10.0 / QUALITY) {\n        float x2 = i / iResolution.x;\n        if(distance(vec2(x, y) * ratio, vec2(x2, func(x2)) * ratio) <= radius)\n            return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - vec2(0.5);\n    vec3 background = vec3(0);\n    \n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    \n    background = mix(vec3(0), col, -cos(iTime) / 2.0 + 0.5);\n    col = mix(col, vec3(0), -cos(iTime) / 2.0 + 0.5);\n    \n    if(wave(uv.x, uv.y))\n        fragColor = vec4(col, 0.0);\n    else\n        fragColor = vec4(background, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 276, 298, 298, 642], [644, 644, 665, 665, 790], [792, 792, 821, 821, 1488], [1490, 1490, 1545, 1545, 1939]], "test": "valid"}
{"id": "Nld3WX", "name": "Fork Mandelmaze gchipunov 862", "author": "gchipunov", "description": "Revisiting the Mandelmaze version of the Mandelbox in daylight (mouse enabled)", "tags": ["raymarching", "fractal", "mandelbox"], "likes": 2, "viewed": 133, "published": "Public API", "date": "1637117804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Mandelmaze in Daylight\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return exp(mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nmat3 vuMat;\nvec3 vuPos;\nfloat tCur, dstFar, chRingO, chRingI, vuVel, bxSize, chSize, qnStep;\nint idObj;\n\nfloat MBoxDf (vec3 p)\n{\n  vec4 q, q0;\n  const float mScale = 2.62;\n  const int nIter = 12;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;\n  }\n  return length (q.xyz) / abs (q.w);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dm, tWid;\n  dMin = dstFar;\n  d = MBoxDf (p);\n  q = p;\n  q.y -= vuPos.y;\n  tWid = 0.7 * chSize;\n  dm = min (PrCylAnDf (q.xzy, chRingO, chSize, chSize),\n     PrCylAnDf (q.xzy, chRingI, tWid, chSize));\n  dm = min (min (dm, PrBox2Df (q.xy, vec2 (tWid, chSize))),\n     PrBox2Df (q.zy, vec2 (tWid, chSize)));\n  d = max (d, - dm);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const int nStep = 200;\n  float dHit, d, s;\n  dHit = 0.;\n  s = 0.;\n  for (int j = 0; j < nStep; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    ++ s;\n    if (d < 0.0003 || dHit > dstFar) break;\n  }\n  qnStep = s / float (nStep);\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return sqrt(normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw))-e;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[9], aDir, a, d, r, tO, tI, tR, rGap;\n  bool rotStep;\n  tO = 0.5 * pi * chRingO / vuVel;\n  tI = 0.5 * pi * chRingI / vuVel;\n  rGap = chRingO - chRingI;\n  tR = rGap / vuVel;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tO;  ti[2] = ti[1] + tR;\n  ti[3] = ti[2] + tI;  ti[4] = ti[3] + tR;\n  ti[5] = ti[4] + tO;  ti[6] = ti[5] + tR;\n  ti[7] = ti[6] + tI;  ti[8] = ti[7] + tR;\n  aDir = 2. * mod (floor (t / ti[8]), 2.) - 1.;\n  p.y = 0.7 * bxSize * sin (2. * pi * floor (t / (2. * ti[8])) / 11.);\n  t = mod (t, ti[8]);\n  r = chRingO;\n  tr = vec2 (0.);\n  if (t < ti[4]) {\n    if (t < ti[1]) {\n      rotStep = true;\n      a = (t - ti[0]) / (ti[1] - ti[0]);\n    } else if (t < ti[2]) {\n      tr.y = chRingO - rGap * (t - ti[1]) / (ti[2] - ti[1]);\n    } else if (t < ti[3]) {\n      rotStep = true;\n      a = 1. + (t - ti[2]) / (ti[3] - ti[2]);\n      r = chRingI;\n    } else {\n      tr.x = - (chRingI + rGap * (t - ti[3]) / (ti[4] - ti[3]));\n    }\n  } else {\n    if (t < ti[5]) {\n      rotStep = true;\n      a = 2. + (t - ti[4]) / (ti[5] - ti[4]);\n    } else if (t < ti[6]) {\n      tr.y = - chRingO + rGap * (t - ti[5]) / (ti[6] - ti[5]);\n    } else if (t < ti[7]) {\n      rotStep = true;\n      a = 3. + (t - ti[6]) / (ti[7] - ti[6]);\n      r = chRingI;\n    } else {\n      tr.x = chRingI + rGap * (t - ti[7]) / (ti[8] - ti[7]);\n    }\n  }\n  if (rotStep) {\n    a *= 0.5 * pi * aDir;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    if (aDir < 0.) tr.y *= -1.;\n    p.xz = tr;\n  }\n  return p;\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel;\n  float a, ca, sa, dt;\n  dt = 0.5;\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.y = fpB.y;\n  vel = (fpF - fpB) / (2. * dt);\n  a = atan (vel.z, vel.x) - 0.5 * pi;\n  ca = cos (a);  sa = sin (a);\n  vuMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 25; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.1, 3. * h);\n    if (h < 0.001) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir[4];\n  float dstHit, sh, dfSum, spSum;\n  int idObjT;\n  ltDir[0] = normalize (vec3 (1., 1., 0.));\n  ltDir[1] = normalize (vec3 (0., 1., 1.));\n  ltDir[2] = normalize (vec3 (1., 0., 1.));\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += dstHit * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    if (idObjT == 1) {\n      col = mix (vec3 (0.6, 0.9, 0.6), vec3 (0.9, 0.9, 1.),\n         clamp (1.2 * length (ro) / bxSize, 0., 1.));\n      col = col * clamp (1. - 1.2 * qnStep * qnStep, 0.2, 1.);\n    }\n    dfSum = 0.;\n    spSum = 0.;\n    for (int j = 0; j < 3; j ++) {\n      sh = 0.1 + ObjSShadow (ro, ltDir[j]);\n      dfSum += sh * (0.2 + max (dot (vn, ltDir[j]), 0.));\n      spSum += sh * pow (max (0., dot (ltDir[j], reflect (rd, vn))), 32.);\n    }\n    col = col * dfSum + 1.3 * spSum;\n    ltDir[3] = normalize (- ro);\n    sh = ObjSShadow (ro, ltDir[3]);\n    col = mix (col, vec3 (0.9, 0., 0.),\n       0.5 * (1. + cos (20. * tCur)) * sh * max (dot (vn, ltDir[3]), 0.) /\n       dot (ro, ro));\n  } else {\n    col = mix (vec3 (0., 0., 0.8), vec3 (1.),\n       0.3 + 0.2 * (1. - smoothstep (0.8, 0.9, abs (rd.y))) *\n       Fbm2 (8. * vec2 (2. * abs (atan (rd.z, rd.x)) / pi, rd.y)));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  mat3 vuMat2;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 30.;\n  bxSize = 4.;\n  chSize = 0.08 * bxSize;\n  chRingO = 0.8 * bxSize;\n  chRingI = 0.4 * bxSize;\n  vuVel = 0.2 * bxSize;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el - 1.3 * pi * mPtr.y, - 0.49 * pi, 0.49 * pi);\n    az = clamp (az - 1.8 * pi * mPtr.x, - pi, pi);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat2 = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  VuPM (tCur);\n  ro = vuPos;\n  rd = normalize (vec3 ((1./0.5) * sin (0.5 * uv.x), uv.y, 2.)) * vuMat2 * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3WX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[277, 277, 301, 301, 348], [350, 350, 375, 375, 579], [581, 581, 602, 602, 741], [743, 743, 776, 776, 860], [862, 862, 915, 915, 976], [1083, 1083, 1106, 1106, 1396], [1398, 1398, 1420, 1420, 1830], [1832, 1832, 1865, 1865, 2122], [2124, 2124, 2145, 2145, 2361], [2363, 2363, 2389, 2389, 3912], [3914, 3914, 3935, 3935, 4255], [4257, 4257, 4294, 4294, 4524], [4526, 4526, 4561, 4561, 5838], [5840, 5840, 5896, 5896, 6790]], "test": "error"}
{"id": "Nld3z7", "name": "Draft Quadtree [learning level 2", "author": "byt3_m3chanic", "description": "Dr. Heavenly, Toya... Quad.", "tags": ["2d", "tiles", "quadrtree"], "likes": 23, "viewed": 198, "published": "Public API", "date": "1635898074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Draft Quadtree [learning level 2]\n    11/2/21 @byt3_m3chanic\n\n    Ver2 of my last shader in just playing with quadtrees.\n    \n    @Shane has a good example for 2d tiles here:\n    https://www.shadertoy.com/view/llcBD7\n\n    Done in an attempt to learn the basics and how to use\n    and match up ID's with spaces. IDK might delete later?\n \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\nvec3 hue(float t){ \n    t*=5.;//tweak for other color variations\n    const vec3 d = vec3(0.067,0.812,0.915);\n    return .35 + .45*cos(PI2*t*(vec3(.97,.97,.98)*d)); \n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat px = .0231;\n\nvec3 doHatch(vec2 p, float res) {\n    p *= res/10.;\n    vec2 id = floor(p*.5)-.5;\n    float rnd = hash21(floor(p*.5));\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n    if (chk > 0.5) p.x *=-1.;\n    float hatch = clamp(sin((p.x - p.y)*PI*3.)*3. + 0.25, 0., 1.);\n    if(rnd>.66) hatch = rnd;\n    return vec3(clamp(hatch,.3,.7),id);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 ms = (2.*M.xy-R.xy)/max(R.x,R.y);\n                \n    px = fwidth(uv.x)*2.;\n            \n    vec2 vuv= uv*(2.+.25*sin(T*.135));\n    vuv.xy*=rot(.5*sin(T*.2));\n\n    vuv.y+=T*.35;\n    float px = fwidth(uv.x);\n    float level=1.;\n    vec3 dht = doHatch(vuv,155.);\n    float chk = mod(dht.z + dht.y,2.) * 2. - 1.;\n    \n    vec3 C = mix(hue((chk+vuv.x)*.05),vec3(.01),dht.x);\n \n    vec2 muv = M.z>1.?uv-ms:uv-vec2(.5*sin(T)/level,.25*cos(T)/level);\n    float tp = length(muv)-.1;\n    tp=smoothstep(px,.0,abs(tp)-.0075);\n\n    \n    for(int k=0; k<4; k++){\n        vec2 id = floor(vuv*level);\n        float rnd = hash21(id);\n        \n        // threshold or if last loop\n        if(rnd>.45||k>2) {\n\n            vec2 p = vuv -(id+.5)/level;\n            rnd = hash21(rnd+id.yx);\n            float dir = rnd>.5 ?-1.:1.;\n\n                                    \n            vec2 off1= clamp(vec2(muv*.17),vec2(-.1275),vec2(.1275));\n            off1/=level;\n            \n            // make ring parts - very basic\n            float angle = atan(p.x+off1.x, p.y+off1.y);\n            float f = length(p);\n            float width = .5/level;\n            float amt = 24.;\n            //vec for moving ring\n            vec2 q = vec2(\n                fract(dir*amt*angle/PI+T*1.75)/level,\n                f-width\n            );\n            //id for moving ring\n            vec2 tid = vec2(\n                floor(dir*amt*angle/PI+T*1.75),\n                floor(f-width)\n            );\n            \n            tid.x=mod(tid.x,2.);\n            float ds = length(p+off1-vec2(.125/level))-.065/level;\n            float dt = length(p+off1+vec2(.115/level))-.030/level;\n            float d = length(p)-.455/level;\n            float s = length(p)-.375/level;\n            float c = box(q+vec2(0,.4/level),vec2(1.,.25)/level);\n            float l = length(p+off1)-.195/level;\n            float h = abs(l)-.014/level;\n            \n            float fd = smoothstep(.005+px,-px,abs(d)-.025/level);\n            float md = smoothstep(.025+px,-px,length(p)-.275/level);\n            d = smoothstep(.0075+px,-px,d);\n            s = smoothstep(.05+px,-px,s);\n            c = smoothstep(.01+px,-px,c);\n            l = smoothstep(.01+px,-px,l);\n            h = smoothstep(.01+px,-px,h);\n            ds = smoothstep(.01+px,-px,ds);\n            dt = smoothstep(.01+px,-px,dt);\n            \n            C=mix(C,vec3(.35),d);\n            C=mix(C,vec3(.1),min(s,d));\n            c=min(c,s);\n            vec3 clr = hue(hash21(float(k)+tid.yx));\n            if(tid.x<1.) clr = hue(hash21(tid.yx));\n            C=mix(C,clr,min(c,d)+md );\n            C=mix(C,vec3(.015),min(l,d));\n            C=mix(C,vec3(.005),h);\n            C=mix(C,vec3(.9),ds+dt+fd);\n            break;\n        }\n        level*=2.;\n    }\n    \n    C = mix(C,M.z>0.?vec3(.8,.1,.01):vec3(.01,.4,.9),tp);\n    C = pow(C, vec3(.4545)); \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3z7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[587, 587, 607, 607, 652], [653, 653, 674, 674, 729], [730, 730, 774, 774, 829], [830, 830, 850, 850, 888], [890, 890, 908, 908, 1056], [1058, 1058, 1092, 1092, 1172], [1193, 1193, 1226, 1226, 1526], [1528, 1528, 1569, 1569, 4500]], "test": "valid"}
{"id": "NldGzs", "name": "percolation network", "author": "FabriceNeyret2", "description": "atoms bonding (polymerization ) / diffusion through cracks ( water in soil or in coffee ) can be model as percolation in networks. Here, connectivity between nodes is \"slightly smooth\" for a better feeling of the connectome.", "tags": ["short", "network", "connect", "percolation", "molecules", "bonds"], "likes": 17, "viewed": 191, "published": "Public API", "date": "1636558466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define C(p) (.5+.5*vec2( cos( (H(p).y-.5)*iTime + 6.3*H(p).x + vec2(0,33) ) ) )\n//#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 10.*( u+u - R ) / R.y,\n         I = floor(U), F = fract(U), D,A,B;        \n    O-=O;\n\n    for( int k=0; k<9; k++ ) {\n        D = vec2(k%3,k/3)-1., A = D + C(I+D);\n        O.r = max(O.r, .3 / length(F-A) );             // red blobs\n        for( int j=0; j<9; j+= j==k-1?2:1 ) {\n            D = vec2(j%3,j/3)-1., B = D + C(I+D);\n            float d = length(B-A); d = max(0., 1.5-d); // A-B connectivity\n            if (d>0.) O = max(O, smoothstep(30./R.y,0., line(F,A,B) - .02 * d*4. )  *d*2. );\n            //*hue(d) \n    } }\n    \n\n    if ( iMouse.z>0. && min(F.x,F.y)<20./R.y ) O.b++;  // click to see grid\n    //O = sqrt(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 259, 259, 369], [371, 371, 409, 409, 1080]], "test": "valid"}
{"id": "Nlf3z8", "name": "Kusama", "author": "kstyler", "description": "Shader inspired by Kusama's infinity rooms", "tags": ["3d", "infinity", "room", "kusama"], "likes": 1, "viewed": 131, "published": "Public API", "date": "1635823289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int matID = 0;\nint scene = 1;\n\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat sdfLP(vec3 p, float norm, float size){\n    float px = pow(abs(p.x),norm);\n    float py = pow(abs(p.y),norm);\n    float pz = pow(abs(p.z),norm);\n    return pow(px+py+pz,1./norm)-size;\n}\n\nfloat sdfBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p,int id){\n    float subject = 999.;\n    if(scene ==0){\n        vec3 q = p;\n        q.x+=sin(q.y+iTime)*.5;\n        vec3 center = floor(q*.2)+.5;\n        subject = sdfLP(q-center,(sin(iTime)*2.)+2.9,.4);\n    }else if(scene ==1){\n        vec3 q = p;\n        subject = sdfLP(q,(sin(iTime)*2.)+2.9,.9);\n    }else if(scene ==2){\n        vec3 q = p;\n        q.y-=.5;\n        q.x+=sin(q.y*10.+iTime*1.)*.2;\n        vec3 center = vec3(floor(q.xz)+.5,0.);\n        subject = sdfLP(q-center.xzy,1.,.3);\n    } \n    \n    float plane = p.y+1.5;\n    float cil = 1.5-p.y;\n    float box = -sdfBox(p+vec3(0.,0.,0.),vec3(4.,4.,4.));\n    float best = min(cil,min(box,min(subject,plane)));\n    if(id != 0){\n        if(best == subject){matID = 2;}\n        if(best == plane){matID=3;}\n      \n        if(best == box){matID=4;}\n        if(best ==cil)matID=5;\n    }\n    return best;\n}\nvec3 normal(vec3 p){\n    vec2 e= vec2(0,0.001);\n\treturn normalize(vec3(map(p+e.yxx,0)-map(p-e.yxx,0),\n                          map(p+e.xyx,0)-map(p-e.xyx,0),\n                          map(p+e.xxy,0)-map(p-e.xxy,0)));\n}\nvec3 march(vec3 ro, vec3 rd){\n    float total = 0.;\n    float dist = 0.;\n    for(int i = 0; i<500; i++){\n        dist = map(ro+rd*total,1)*.5;\n        total+=dist;\n        if(dist < 0.001 || total>500.){\n        \tbreak;\n        }\n    }\n    if(dist>0.01){\n    \tmatID = 1;\n    }\n   \n    return (ro+rd*total);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    scene = int(mod(iTime*.1,3.));\n    if(scene == 0){\n        ro = vec3(0,0.3,-3.5);\n        ro.zy*=rotate(.4);\n        rd.zy*=rotate(.4);\n        ro.xz*= rotate(iTime*.1);\n        rd.xz*= rotate(iTime*.1);\n    }else if(scene ==1){\n        ro = vec3(0,0.8,-2.5);\n        rd.zy*=rotate(-.3);\n        ro.xz*= rotate(iTime*.1);\n        rd.xz*= rotate(iTime*.1);\n    \n    }else if(scene ==2){\n        ro = vec3(0,.3,-0.3);\n        rd.zy*=rotate(.1);\n        rd.zy*=rotate(.1);\n        ro.xz*= rotate(iTime*.1);\n        rd.xz*= rotate(iTime*.1);\n    \n    }\n    \n    vec3 accum = vec3(1);\n    for(int i = 0; i <9; i++){\n        vec3 col =(march(ro,rd));\n        vec3 n = normal(col);\n        if(matID ==1){\n    \t\taccum *= vec3(1);\n   \t\t}\t\n        if(matID ==2){\n            accum *= vec3(.9);\n        \tro = col*2.;\n            rd=normalize(reflect(rd,n));\n        }\n        if(matID ==3){\n            accum *= vec3(0.8);\n        }\n        if(matID ==4){\n            accum *= vec3(0.99,.996,0.99);\n            float fresnel = pow(1.-dot(- rd,n),0.03);\n            accum*=fresnel;  \n            ro = col*.999;\n            rd=normalize(reflect(rd,n));\n        }\n        if(matID ==5){\n            accum *= vec3(.999);\n        }\n    }\n    fragColor = vec4(accum,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlf3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 52, 52, 98], [100, 100, 144, 144, 290], [292, 292, 323, 323, 410], [412, 412, 437, 437, 1286], [1287, 1287, 1307, 1307, 1506], [1507, 1507, 1536, 1536, 1820], [1821, 1821, 1877, 1877, 3261]], "test": "valid"}
{"id": "NlG3Dw", "name": "The Cell Void 3 (fake 3D)", "author": "FabriceNeyret2", "description": "cylindrical variant of [url]https://shadertoy.com/view/flyGDw[/url]\n2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 10, "viewed": 133, "published": "Public API", "date": "1637771208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cylindrical variant of https://shadertoy.com/view/flyGDw\n\n#define H(v) fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v) smoothstep(30./R.y,0.,v)\n\n#define CYL\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime, k=8.;\n #ifdef CYL\n    U = k*vec2( .995*atan(U.y,U.x), 8./length(U) );        // go to cylinder space\n    U.y += t;                                              // animation\n #endif\n \n    for ( int k=0; k < 9; k++ )                            // jittered point grid distribution\n        D = vec2(k%3,k/3), P = D - H(mod(floor(U)+D,25.)), // NB: cyclical hash\n        d = length(P-fract(U)), \n        d < m ? _P=P, m = d : m;\n    \n    P = _P + floor(U);\n #ifdef CYL\n    U = U0;\n    P = k*8./(P.y-t) * cos( P.x/.995/k + vec2(0,-1.57) ); // back to screen space\n    m = length(P-U);\n #endif   \n                                                          // draw disk - dark disk\n    O = vec4( clamp( S(m-.4) - S( length(P-U+ U*length(U)/1e3 ) -.4 )  ,0.,1.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 1068]], "test": "valid"}
{"id": "NlG3Rh", "name": "terrain 3", "author": "yonatan", "description": "added some clouds/fog", "tags": ["terrain", "clouds", "fog", "short"], "likes": 15, "viewed": 479, "published": "Public API", "date": "1637107750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n#define r iResolution.xy\n#define t iTime\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n    for(float i,e,f,g,s;i++<50.;g+=min(e*.7,f*f*.1)){\n        vec3 c=vec3(4.7,5,5.6),n,q,p=q=vec3((FC.xy-.5*r)/r.y*g,g);\n        p.zy*=R(.4+sin(t/3.)*.2);\n        s=1.4;\n        p.z+=t;\n        q=p;\n        f=abs(p.y*p.y-2.8)+.4;\n        e=++p.y;\n        mat2 m=R(1.);\n        for(;s<1e3;s*=1.7)\n            p.xz*=m,\n            n.xz*=m,\n            q.xz*=m,\n            q.yz*=m,\n            n+=cos(p*s),\n            f-=abs(cos(q.x*s)*cos(q.z*s)-.6)/s,\n            q.xz+=t/s*.2,\n            e+=sin(p.x*s)/s/2.;\n        n.y=.2;\n        n/=length(n);\n        e-=n.y;\n        c.x+=n.y*3.;\n        o.rgb+=mix(\n            mix(exp(n.z-c),c/3e2,min(g/9.+e,1.4)),\n            p-p+exp(-f*f)/50.,\n            exp(-f));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 131, 131, 864]], "test": "valid"}
{"id": "NlG3Rt", "name": "Diverging Patterns", "author": "andrinr", "description": "playing around with lines", "tags": ["sinus"], "likes": 0, "viewed": 94, "published": "Public API", "date": "1638131934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n\n    float c = clamp(sin(uv.x*uv.x*uv.y*uv.y*3000.0 + 3.0 *iTime), 0.0, 1.0);\n    float d = clamp(sin((uv.x*uv.y*uv.x)*1000.0 - 3.0 * iTime), 0.0, 1.0);\n    \n    float r = max(d, c);\n\n    // Output to screen\n    fragColor = vec4(vec3(r),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 405]], "test": "valid"}
{"id": "NlGGzK", "name": "Mandelbrot Domain Coloring", "author": "tungster24", "description": "i finally did it :D", "tags": ["fractal", "mandelbrot", "domain"], "likes": 4, "viewed": 138, "published": "Public API", "date": "1637951862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat theta(in float x, in float y) {\n    float pi = 3.14159265;\n    return mod(atan(y,x),2.0*pi);\n}\n\nfloat r(in float x, in float y) {\n    return sqrt(x*x+y*y);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n    // preperation functions\n    float r1 = max(min(abs((mod(h,360.0)-180.0)/60.0)-1.0,1.0),0.0);\n    float g1 = max(min(2.0-abs((mod(h,360.0)-120.0)/60.0),1.0),0.0);\n    float b1 = max(min(2.0-abs((mod(h,360.0)-240.0)/60.0),1.0),0.0);\n    \n    //hsv to rgb functions\n    float r = (r1+(1.0-r1*(100.0-s)/100.0)-s/100.0)*v/100.0;\n    float g = (g1+(1.0-g1*(100.0-s)/100.0)-s/100.0)*v/100.0;\n    float b = (b1+(1.0-b1*(100.0-s)/100.0)-s/100.0)*v/100.0;\n    \n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // grid with -2 to 2 from -y to y, adjusted for x so there's no distortion\n    float x = (fragCoord.x/iResolution.y)*2.0-1.0*iResolution.x/iResolution.y;\n    float y = (fragCoord.y/iResolution.y)*2.0-1.0;\n    \n    // complex number\n    vec2 z = vec2(0,0);\n    \n    //pi for convenience\n    float pi = 3.1415926;\n    \n    for (int i = 0;i < 40;i++) {\n        z = vec2(z.x*z.x-z.y*z.y+x,2.0*z.x*z.y+y);\n    }\n    \n    //check if r(z.x,z.y) [distance to origin] is overflowing, if so color it white.\n    float k1,k2,k3;\n    if (isnan(r(z.x,z.y))) {k1 = 100.0;k2 = 0.0;k3 = 0.0;}\n    \n    \n    else {k1 = r(z.x,z.y)*100.0;k2 = 100.0-r(z.x,z.y)*100.0;k3 = theta(z.x,z.y)*(180.0/pi)+iTime*360.0;}\n    \n    \n    fragColor = vec4(hsv(k3,k2,k1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 39, 39, 102], [104, 104, 137, 137, 165], [167, 167, 213, 242, 695], [697, 697, 754, 833, 1502]], "test": "error"}
{"id": "NlK3R3", "name": "slitscan noise", "author": "jneen", "description": "time dilation noise", "tags": ["noise", "slitscan"], "likes": 0, "viewed": 33, "published": "Public", "date": "1638082986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time=0.;\n\nfloat rand2(vec2 uv) {\n  return fract(13339.*sin(dot(uv,vec2(86.726113,98.28111))));\n}\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nmat2 rot(float a){float s=sin(a),c=cos(a); return mat2(c,s,-s,c);}\n\nvec3 M=vec3(0);\nfloat G=0.;\nfloat w(vec3 p) {\n  vec3 planep = p;\n  planep.xz *= rot(time);\n  float plane = box(planep+vec3(0,10,0), vec3(8));\n  p.xz *= rot(time);\n  p.xy *= rot(.2*time);\n  float B= length(p.xz)-1.;//box(p, vec3(1,2,1));//length(p)-2.;\n  B = max(B, -(length(p.xz)-.8));\n  \n  float C=length(p.xy)-1.5;\n  float CC=length(p.yz)-1.5;\n  CC = max(CC, -C);\n  \n  float BB= max(B,-C);\n  M = p.y < 0. ? vec3(.9, .7, .3) : vec3(.2, .8, .5);\n\n\n  if (CC < BB) M = vec3(.4, .6, 1.);\n\n\n  BB = min(BB, CC);\n\n\n  \n  float O = mix(B,BB,.5+.5*sin(time));\n  \n  G += -min(O,0.);\n  \n  O = mix(length(p)-2.,O,sin(2.*time));\n  //O -= (.5+.5*sin(10.*iTime))*rand2(p.xz);\n  \n  if (plane < O) M = vec3(.9,.3,.1);\n  \n  return min(plane,O);\n}\n\nfloat ray(vec3 p, vec3 dir){\nfloat d=0.,c;\nfor(int i=0;i<100;i++){\n  c=w(p+dir*d);d+=c*.5;\n  if(c<.01||d>69.)break;\n}\n\nreturn d;\n  \n}\n\nvec3 normal(vec3 p) {\n mat3 k = mat3(p,p,p)-mat3(.01);\n return normalize(w(p)-vec3(w(k[0]),w(k[1]),w(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    time = 2.*iTime;\n    \n    // COMMENT TO TURN OFF SLITSCAN EFFECT\n    time += 2.*sin(mix(.5,10.,.5+.5*sin(iTime))*uv.y);// + length(uv);\n    //time += .3*rand2(uv);\n    \n    //uv *= rot(iTime);\n    vec3 col=vec3(0);\n    vec3 cam=vec3(0,0,-8);\n    vec3 dir=normalize(vec3(uv,1));\n    \n    float dist=ray(cam,dir);\n    vec3 mat = M;\n    float glow=G;\n    \n    if (dist<69.) {\n      vec3 hit = cam+dir*dist;\n      vec3 norm = normal(hit);\n      \n      \n      float diff = length(.5+.5*sin(1.+norm))/sqrt(3.);\n      col = mat*diff;\n      \n      vec3 refldir = reflect(dir,norm);\n      float refl = ray(hit+.1*refldir, refldir);\n      \n      if (refl<69.){\n        vec3 reflM = M;\n        vec3 rnorm = normal(hit+refldir*refl);\n        float rdiff = length(.5+.5*sin(1.+rnorm))/sqrt(3.);\n        col = mix(col, .1+reflM * rdiff, .5);\n      }\n\n\n    }\n    \n    //col += glow;\n    \n    // Output to screen\n    //col=vec3(1)*rand2(uv);\n    fragColor = vec4(col,1);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlK3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 38, 38, 102], [104, 104, 131, 131, 215], [217, 217, 235, 235, 283], [313, 313, 330, 330, 1013], [1015, 1015, 1043, 1043, 1148], [1150, 1150, 1171, 1171, 1261], [1263, 1263, 1320, 1370, 2425]], "test": "valid"}
{"id": "NlK3RD", "name": "FEZ Shader - Rain / Clouds", "author": "sterlingsowards", "description": "Another Fez inspired shader, this one drawing inspiration from a section in the game that flickers randomly between daytime and night time.", "tags": ["stars", "rain", "night", "flicker", "scroll", "videogame", "flash", "day", "fez"], "likes": 3, "viewed": 68, "published": "Public", "date": "1637268193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 3.\n#define WIDTH .008\n#define ZOOM_FAR 10.\n#define ZOOM_CLOSE 5.\n#define NUM_RAIN_LAYERS 10.\n#define RAIN_SPEED 2.\n#define RAIN_WIDTH .007\n#define RAIN_LENGTH .3\n#define CLOUD_LAYERS 4.\n#define CLOUD_ZOOM_CLOSE 1.\n#define CLOUD_ZOOM_FAR 1.5\n\nfloat rand( float n )\n{\n    return fract(sin(n * 52.48965902) * 247.1294857);\n}\n\nfloat rainLayer( vec2 uv, float layer )\n{\n    vec2 gv;\n    gv.x = fract((uv.x + iTime * .04 * (NUM_LAYERS + 1.)) * 5.)-.5;\n    float x_id = floor((uv.x + iTime * .04 * (NUM_LAYERS + 1.)) * 5.);\n    \n    gv.y = fract((uv.y + iTime * RAIN_SPEED) * 2.);\n    float y_id = floor((uv.y + iTime * RAIN_SPEED) * 2.);\n    \n    // randomly offset the raindrop\n    // x can range + or - .9\n    // y can range 0 to 1-RAIN_LENGTH\n    float n = rand(58. * x_id + 2.465 * y_id + 9.465 * layer);\n    vec2 offset = vec2(1.8 * n - 1., (1.-RAIN_LENGTH) * fract(n * 79.));\n    gv -= offset;\n    \n    float a = min(smoothstep(RAIN_WIDTH + 1./iResolution.x, RAIN_WIDTH, abs(gv.x)), smoothstep(RAIN_LENGTH, 0., gv.y));\n    a *= smoothstep(-.001, 0., gv.y);\n    //a += abs(gv.x) < .01 || abs(gv.y) < .01 ? .2  : 0.;\n    return a;\n}\n\nfloat starLayer( vec2 uv, float zoom )\n{\n    // Create grid coordinates based on zoom\n    vec2 gz = fract(uv * zoom) - .5;\n    float id = floor(uv * zoom).x * 67. + floor(uv * zoom).y * 13.;\n    \n    return min(smoothstep(WIDTH + 1./iResolution.x, WIDTH, abs(gz.x)), smoothstep(WIDTH + 1./iResolution.y, WIDTH, abs(gz.y)));\n}\n\nfloat cloud( vec2 uv, float n)\n{\n    uv *= 1.7;\n    float a;\n    // Each cloud is a rounded box with a random height between 1 and 2\n    float height = rand(n)+1.;\n    n = fract(n * 97.);\n    vec2 offset = vec2(0., 0.1);\n    float d = length(max(abs((uv - offset)*vec2(.5, height)),.2) - .2);\n    a = smoothstep(0.55, 0.5, abs(d / .6) * 5.0);\n    \n    // Then there's a cloud that's going to be a rounded box that's shorter and skinnier\n    offset = vec2(rand(n)*.6-.3, -.14*(2.7-height));\n    n = fract(n * 73.);\n    height = rand(n) * 2. + 4.;\n    n = fract(n * 32.);\n    float width = rand(n)+.5;\n    n = fract(n * 21.);\n    d = length(max(abs((uv - offset)*vec2(width, height)),.2) - .2);\n    a = max(a, smoothstep(0.55, 0.5, abs(d / .6) * 5.0));\n    \n    // little bit of cloud connecting the two\n    offset.y += .1;\n    offset.x *= .9;\n    height = 2.;\n    width = 4.;\n    d = length(max(abs((uv - offset)*vec2(width, height)),.2) - .2);\n    a = max(a, smoothstep(0.55, 0.5, abs(d / .6) * 5.0));\n    \n    a *= 1.5*(uv.y + .7);\n    return clamp(pow(a, 8.), 0., 1.);\n}\n\nfloat cloudLayer( vec2 uv, float zoom, float layer )\n{\n    float a;\n    vec2 gv = fract(uv * zoom)-.5;\n    float id = floor(uv * zoom).x * 46.23 + floor(uv * 1.5).y * 9.567;\n    // calculate random offset based on grid coordinate\n    float n = rand(id + 24.354 * layer);\n    vec2 offset = vec2((n*2.-1.) * .2, (fract(n * 25.)*2.-1.) * .3);\n    a = cloud(gv-offset, n);\n    return smoothstep(.5, .50001, n) * a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) irrespective of aspect ratio\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 night_col = vec3(0.043, 0.003, 0.074);\n    \n    float timeOffset = iTime * .04;\n    \n    // Star Layers\n    for (float i = 0.; i < NUM_LAYERS; i++) {\n        // Calculate the zoom factor\n        float zoom = mix(ZOOM_FAR, ZOOM_CLOSE, i/(NUM_LAYERS - 1.));\n        \n        // Calculate a parallax offset\n        vec2 offset = vec2((i+1.) * timeOffset, 0.);\n        \n        // Draw the star layer\n        float sl = starLayer(uv + offset, zoom) * (i + 1.)/(NUM_LAYERS);\n        night_col = sl + night_col * (1. - sl);\n    }\n    \n    // Rain Layer\n    for (float i = 0.; i < NUM_RAIN_LAYERS; i++) {\n        vec3 rainColor = vec3(0.180, 0.192, 0.325);\n        float rl = rainLayer(uv, i);\n        night_col = rainColor * rl + night_col * (1. - rl);\n    }\n    \n    vec3 day_col = mix(vec3(0.486, 0.988, 0.988), vec3(0.121, 0.956, 1.), uv.y);\n    \n    // Cloud Layers\n    for (float i = 0.; i < CLOUD_LAYERS; i++) {\n        float zoom = mix(CLOUD_ZOOM_FAR, CLOUD_ZOOM_CLOSE, i/(CLOUD_LAYERS - 1.));\n        vec2 offset = vec2(iTime * .01 * (i+1.), 0.2 * (i / (CLOUD_LAYERS - 1.)));\n        float cl = cloudLayer(uv+offset, zoom, i) * (i + 1.) / (CLOUD_LAYERS);\n        day_col = cl * vec3(1.) + day_col * (1. - cl);\n    }\n\n    // Decide if we're looking at day or night\n    // 1 = night, 0 = day\n    float day_night = smoothstep(.2, .2001, rand(floor(iTime*2.)+76.83));\n    vec3 col = night_col * day_night + day_col * (1. - day_night);\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlK3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 284, 284, 340], [342, 342, 383, 383, 1149], [1151, 1151, 1191, 1236, 1476], [1478, 1478, 1510, 1510, 2550], [2552, 2552, 2606, 2606, 2964], [2966, 2966, 3023, 3102, 4670]], "test": "valid"}
{"id": "NlK3RW", "name": "FEZ Shader - Pixel Stars", "author": "sterlingsowards", "description": "This simple shader is inspired by the game Fez. Click on the left half of the screen to make the background black like the start screen, and the right half to make the background a deep purple (like in the scene where you get the Fez)", "tags": ["simple", "zoom", "pixel", "colorful", "stars", "rainbow", "starfield", "videogame", "fez", "indie"], "likes": 2, "viewed": 53, "published": "Public", "date": "1637256490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 15.\n#define WIDTH .005\n#define ZOOM_FAR 9.\n#define ZOOM_CLOSE .0\n\nfloat rand( float n )\n{\n    return fract(sin(n * 592.) * 2467.) * .5 + .5;\n}\n\nvec4 starLayer( vec2 uv, float zoom, float layer, float blur )\n{\n    blur = clamp(pow(blur, 3.), 0., 1.);\n    // Create grid coordinates based on zoom\n    vec2 gz = fract(uv * zoom) - .5;\n    float id = floor(uv * zoom).x * 67. + floor(uv * zoom).y * 13.;\n    \n    // Give each star a random color determined by the id\n    float n = rand(id + layer * 87.);\n    vec4 col = vec4(n, fract(n*54.), fract(n*347.), 1.);\n    \n    // Decide if the point is in the star or not\n    col.a = (abs(gz.x) < WIDTH && abs(gz.y) < WIDTH) ? blur : 0.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) irrespective of aspect ratio\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    // Set the background color - click on left side of screen its black, right its deep purple\n    vec3 col = vec3(0.14117647058, 0.0862745098, 0.20392156862) * smoothstep(.499999, .5, iMouse.x / iResolution.x);\n    \n    for (float i = 0.; i < NUM_LAYERS; i++) {\n        // Draw a star layer back to front\n        // i = 0, star is far away\n        // i = 1, star is close\n        float zoom = mix(ZOOM_FAR, ZOOM_CLOSE, fract((i+iTime)/(NUM_LAYERS - 1.)));\n        float blur = (zoom - ZOOM_FAR) / ((ZOOM_CLOSE+1.) - ZOOM_FAR);\n        vec4 sl = starLayer(uv, zoom, i, blur);\n        col = sl.rgb * 2. * sl.a + col * (1. - sl.a);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlK3RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 108, 108, 161], [163, 163, 227, 227, 714], [716, 716, 773, 852, 1616]], "test": "valid"}
{"id": "NlK3WR", "name": "Robotic Head", "author": "dr2", "description": "Trigonometric experiment (mouseable)", "tags": ["mechanics", "trigonometry"], "likes": 28, "viewed": 176, "published": "Public API", "date": "1637498895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Robotic Head\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Trigonometric experiment (mouseable)\n\n/*\n  No. 12 in \"Flexible Tube\" series\n    \"Flexibility\"               (MtlyWl)\n    \"Planet Reboot\"             (wldGD8)\n    \"Decalled Floppy Tube\"      (3l3GD7)\n    \"Elevating Platter\"         (Wl33RS)\n    \"Multisegment Floppy Tube\"  (tlcGRB)\n    \"Planet Reboot 2\"           (Wtc3Rf)\n    \"Snake Worship\"             (wtyGRD)\n    \"Decalled Floppy Tube 2\"    (WsGfWd)\n    \"Floppy Column\"             (wtccR4)\n    \"Metallic Tubeworms\"        (3ltfzM)\n    \"Trapped Light\"             (flt3WB)\n    \n  But now a different (transcendental) problem must be solved: \n  compute arc angle from arc and chord lengths, rather than radius\n  from arc length and angle.\n*/\n\n#define AA  0   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos[4], ltCol[4], qHit;\nfloat tCur, dstFar;\nint idObj;\nconst int idTube = 1, idCon = 2, idBall = 3, idHead = 4, idEar = 5, idNos = 6, idCrwn = 7,\n   idTooth = 8, idEye = 9, idBas = 10, idArm = 11; \nconst float pi = 3.1415927;\n\nstruct Arc {\n  vec2 cs;\n  float chDist, chRot, ang, rad, shift;\n};\nArc arc;\n\nstruct Arm {\n  float len, sep, rot;\n};\nArm arm;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pr, q;\n  float dMin, d, sLen, sx, a;\n  dMin = dstFar;\n  sLen = 0.25;\n  p.y -= arm.sep + 1.;\n  q = p;\n  pr = p;\n  pr.xz = Rot2D (pr.xz, arm.rot);\n  pr.y -= arm.sep;\n  q = pr;\n  q.z -= -0.5;\n  d = PrRoundBoxDf (q, vec3 (0.8, 1.2, 1.), 0.2);\n  d = SmoothMax (d, - min (PrSphDf (vec3 (abs (q.x) - 0.4, q.y - 0.4, q.z + 1.2), 0.25),\n     PrCapsDf (vec3 (q.x, q.y + 0.7, q.z + 1.2).yzx, 0.15, 0.4)), 0.02);\n  DMINQ (idHead);\n  q = pr;\n  q.z -= -0.2;\n  d = PrRoundBoxDf (q, vec3 (0., 1.3, 0.9), 0.3);\n  DMINQ (idCrwn);\n  q = pr;\n  d = PrTorusBxDf (q, vec3 (arm.len - 0.2, 0.1, 0.2), 0.1);\n  DMINQ (idCon);\n  q = pr;\n  q.x = abs (q.x);\n  q -= vec3 (0.4, 0.4, -1.65);\n  d = PrSphDf (q, 0.22);\n  DMINQ (idEye);\n  q = pr;\n  q -= vec3 (0., 0.2, -1.7);\n  d = PrConCapsDf (q.xzy, sin (0.1 * pi + vec2 (0.5 * pi, 0.)), 0.13, 0.25);\n  DMINQ (idNos);\n  q = pr;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.5, -0.8);\n  d = PrRoundCylDf (q.yzx, 0.3, 0.15, 0.);\n  DMINQ (idEar);\n  q = pr;\n  d = max (PrRoundBoxDf (vec3 (mod (q.x + 0.05, 0.1) - 0.05, abs (q.y + 0.7) - 0.12,\n     q.z + 1.65), vec3 (0.025, 0.04, 0.), 0.03), abs (q.x) - 0.45);\n  DMINQ (idTooth);\n  q = pr;\n  sx = sign (q.x);\n  q.x = abs (q.x) - arm.len;\n  q.xz = Rot2D (q.xz, 0.5 * (pi - arm.rot) * sx);\n  q.x += sLen * sx;\n  d = PrCylDf (q.yzx, 0.1, sLen);\n  DMINQ (idCon);\n  sx *= sign (q.x);\n  q.x = abs (q.x) - sLen;\n  if (sx > 0.) q = q.xzy;\n  d = PrSphDf (q, 0.17);\n  DMINQ (idBall);\n  q = p;\n  d = PrCylDf (q.xzy, 0.4, 0.6);\n  DMINQ (idBas);\n  q = p;\n  q.yz -= vec2 (- arm.sep - 0.2, -0.3);\n  d = PrRoundCylDf (q.xzy, 1., 0.2, 0.7);\n  DMINQ (idBas);\n  q = p;\n  q.yz -= vec2 (- arm.sep, - sLen);\n  d = PrRoundBoxDf (q, vec3 (arm.len + 0.2, 0.2, 0.), 0.2);\n  DMINQ (idArm);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);\n  q.xy -= vec2 (arm.len, - arm.sep);\n  q.xz = Rot2D (q.xz, -0.5 * (pi - arm.rot) * sx);\n  q.x -= sLen * sx;\n  d = PrCylDf (q.yzx, 0.1, sLen);\n  DMINQ (idCon);\n  sx *= sign (q.x);\n  q.x = abs (q.x) - sLen;\n  if (sx < 0.) q = q.xzy;\n  d = PrSphDf (q, 0.17);\n  DMINQ (idBall);\n  for (float k = 0.; k <= 1.; k ++) { // (constant-length flexible tubing)\n    q = p;\n    q.xz = Rot2D (q.xz, k * pi + 0.5 * arm.rot) - vec2 (arc.shift, 2. * sLen * sign (1. - 2. * k));\n    q.yz = Rot2D (q.yz, arc.chRot - (k + 0.5) * pi) + vec2 (arc.chDist, 0.);\n    a = mod ((128. / arc.ang) * atan (q.z, q.y) / (2. * pi), 1.);\n    d = max (dot (vec2 (abs (q.z), q.y), arc.cs), length (vec2 (length (q.yz) - arc.rad, q.x)) -\n       0.13 + 0.02 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a)));\n    DMINQ (idTube);\n  }\n  return dMin;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (solve for arc angle given length and chord, |err| < 1e-4 for b < 0.95) \n  vec3 t;\n  vec2 f;\n  t.yz = vec2 (0.7, 1.2);\n  f = vec2 (F(t.y), F(t.z));\n  for (int nIt = 0; nIt < 4; nIt ++) {\n    t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n    t.zy = t.yx;\n    f = vec2 (F(t.x), f.x);\n  }\n  return t.x;\n}\n\nvoid ArcConf ()\n{\n  vec2 u;\n  float arcLen, arcEx, chLen, aLim;\n  aLim = 0.5 * pi;\n  arm.len = 2.;\n  arm.sep = 1.2;\n  arcEx = 1.5;\n  arcLen = arcEx * length (vec2 (arm.len * sin (0.5 * aLim), arm.sep));\n  arm.rot = aLim * (0.3 + 0.7 * Fbm1 (0.7 * tCur)) * sin (0.2 * pi * tCur);\n  u = vec2 (arm.len * sin (0.5 * arm.rot), arm.sep);\n  chLen = length (u);\n  arc.chRot = atan (u.x, u.y);\n  arc.shift = sqrt (arm.len * arm.len - u.x * u.x);\n  arc.ang = SecSolve (chLen / arcLen);\n  arc.chDist = chLen / tan (arc.ang);\n  arc.rad = sqrt (arc.chDist * arc.chDist + chLen * chLen);\n  arc.cs = sin (- arc.ang + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  float s;\n  if (idObj == idTube) {\n    col4 = vec4 (0.9, 0.9, 1., 0.3);\n  } else if (idObj == idCon) {\n    col4 = vec4 (1., 0.7, 0.4, 0.3);\n  } else if (idObj == idBall) {\n    col4 = vec4 (1., 0.7, 0.4, 0.3) * (0.8 + 0.2 * smoothstep (0., 0.005,\n       abs (abs (qHit.z) - 0.05) - 0.005));\n  } else if (idObj == idHead) {\n    s = min (abs (PrRoundBox2Df (qHit.yz - vec2 (-0.7, -0.4), vec2 (0.25, 0.3), 0.1)),\n       abs (PrRoundBox2Df (qHit.yz - vec2 (0., 0.5), vec2 (0.4, 0.1), 0.07)));\n    if (qHit.y > 0.) s = min (s, abs (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.55, qHit.z),\n       vec2 (0.1, 0.9), 0.07)));\n    s = min (s, (qHit.z < 0.) ? abs (PrRoundBox2Df (qHit.xy - vec2 (0., 1.),\n       vec2 (0.6, 0.1), 0.1)) : abs (PrRoundBox2Df (vec2 (abs (qHit.x), qHit.y) -\n       vec2 (0.55, 0.), vec2 (0.1, 1.1), 0.07)));\n    col4 = vec4 (0.8, 1., 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.03, s));\n    if (PrRoundBoxDf (qHit, vec3 (0.8, 1.2, 1.) - 0.01, 0.2) < 0.) col4 = vec4 (0.6, 0., 0., -1.);\n  } else if (idObj == idEar) {\n    col4 = vec4 (0.5, 1., 0.8, 0.2);\n    if (qHit.x > 0.1) col4 *= 0.7 + 0.3 * smoothstep (0., 0.02, mod (16. *\n       length (qHit.yz), 1.) - 0.1);\n  } else if (idObj == idNos) {\n    col4 = vec4 (0.9, 1., 0.6, 0.2);\n    if (qHit.y < -0.3 && length (vec2 (abs (qHit.x) - 0.07, qHit.z + 0.1)) < 0.05) col4 *= 0.3;\n  } else if (idObj == idCrwn) {\n    s = 0.;\n    if (abs (qHit.z) < 0.9) s = qHit.z;\n    else if (abs (qHit.y) < 1.3) s = qHit.y;\n    col4 = vec4 (0.6, 0.6, 0.2, 0.2);\n    if (s != 0.) col4 *= 0.8 + 0.2 * smoothstep (0., 0.05, mod (8. * s, 1.) - 0.1);\n  } else if (idObj == idTooth) {\n    col4 = vec4 (1., 1., 1., 0.2);\n  } else if (idObj == idEye) {\n    col4 = vec4 (vec3 (0.3, 0.5, 1.) * (0.7 + 0.3 * Fbm1 (8. * tCur)), -1.);\n  } else if (idObj == idBas) {\n    col4 = vec4 (0.3, 0.7, 0.3, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.05,\n       mod (8. * qHit.y, 1.) - 0.1));\n  } else if (idObj == idArm) {\n    col4 = vec4 (0.5, 0.9, 0.3, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.03,\n       abs (PrRoundBox2Df (vec2 (abs (qHit.x), qHit.y) - vec2 (arm.len - 0.05, 0.),\n       vec2 (0.2, 0.12), 0.07))));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltAx, c;\n  float dstObj, nDotL, sh, att, ltDst;\n  ArcConf ();\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = vec4 (0.6, 0.6, 0.6, 0.1) * (1. - 0.2 * Fbm2 (4. * ro.xz));\n    col4.rgb *= 1. - 0.2 * smoothstep (0.05, 0.08,\n       length (max (abs (mod (ro.xz + 0.7, 1.4) - 0.7) - 0.6, 0.)));\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      for (int k = VAR_ZERO; k < 4; k ++) { // (see \"Controllable Hexapod 2\")\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (0., arm.sep + 1., 0.));\n        att = smoothstep (0., 0.02, dot (ltDir, ltAx) - 0.95);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (col4.a > 0.) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.15 + 0.85 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += c * c;\n      }\n      col = sqrt (col);\n    } else col = col4.rgb * (0.2 + 0.8 * max (0., - dot (vn, rd)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.13 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el += 0.1 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 2., -20.);\n  ro.y = max (ro.y, 0.1);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / 4.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, 0.1 * pi * tCur + 2. * pi * float (k) / 4.);\n  }\n  ltCol[0] = vec3 (1., 0.5, 0.5);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n  zmFac = 4.8;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  p.z += r * cs.y;\n  return min (d, min (length (p - vec3 (0., 0., h)) - (r - h * cs.y),\n     length (p - vec3 (0., 0., - h)) - (r  + h * cs.y)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlK3WR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1888, 1888, 1910, 1910, 4491], [4525, 4525, 4551, 4628, 4856], [4858, 4858, 4875, 4875, 5483], [5485, 5485, 5518, 5518, 5766], [5768, 5768, 5789, 5789, 6044], [6046, 6046, 6095, 6095, 6337], [6339, 6339, 6355, 6355, 8524], [8526, 8526, 8561, 8561, 9933], [9935, 9935, 9991, 9991, 11454], [11456, 11456, 11502, 11502, 11549], [11551, 11551, 11598, 11598, 11645], [11647, 11647, 11693, 11693, 11774], [11776, 11776, 11809, 11809, 11836], [11838, 11838, 11880, 11880, 11931], [11933, 11933, 11976, 11976, 12040], [12042, 12042, 12099, 12099, 12175], [12177, 12177, 12232, 12232, 12493], [12495, 12495, 12540, 12540, 12632], [12634, 12634, 12679, 12679, 12717], [12719, 12719, 12755, 12755, 12961], [12963, 12963, 12993, 12993, 13106], [13140, 13140, 13164, 13164, 13217], [13219, 13219, 13243, 13243, 13355], [13357, 13357, 13382, 13382, 13528], [13530, 13530, 13555, 13555, 13741], [13743, 13743, 13765, 13765, 13919], [13921, 13921, 13942, 13942, 14097]], "test": "error"}
{"id": "NlKGRG", "name": "More log polar junk", "author": "SnoopethDuckDuck", "description": "bad code, dont really like this one", "tags": ["e"], "likes": 5, "viewed": 106, "published": "Public API", "date": "1637888696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float pe = 100.;\n    //uv = floor(pe * uv)/pe + 0.;\n    uv.y += 0.02 * cos(10. * uv.x + iTime);\n\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    uv = vec2(2. * a, log(r));\n    uv = uv.y * vec2(thc(2., uv.x), ths(2., uv.x));\n    \n    \n    float sc = 1.;\n     vec2 ipos = vec2(floor(0. * iTime + sc * uv.x) + 0.5,\n                      floor( 0.25 * iTime + 2. * sc * uv.y) + 0.5);\n    \n    \n    \n    vec2 fpos = vec2(fract(0. * iTime + sc * uv.x) - 0.5,\n                     fract( 0.3 * iTime + 2. * sc * uv.y) - 0.5);\n    \n    //fpos.y += 0.2 * cos(8.* fpos.x + 10. * h21(ipos) + iTime);\n    float k = 0.6 + 0.4 * thc(0.1, cos(0. * h21(ipos) + 8. * r -5.* a- iTime) + 2. * a - 1.2 * iTime);\n   \n    float d = (2. + thc(4., k + r * 10. - iTime)) * length(fpos) * length(fpos);// + (0.5 + thc(2., 101. * h21(ipos) + iTime));\n    float s = 1.2 * (1.-mlength(fpos)) * smoothstep(-0.5,0.5, 0.45-d);// - step(0.46, mlength(fpos));\n    s = smoothstep(-k, k, \n        -d + 0.32 + 0.1 * thc(4., -iTime + log(r) + 2. * a));\n    vec3 col = vec3(s);\n    vec3 col2 =  pal(k +  - 0.8 * iTime + s * 0.002 * iTime, vec3(1.), vec3(1.), vec3(0.4), log(r) * vec3(0.,0.33,0.66));\n    float s2 = 0.5 + 0.5 * thc(1., 1.5 * thc(2., 8. * s - iTime));\n    col = mix(col, col2, vec3(s2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 2038]], "test": "valid"}
{"id": "Nlt3D2", "name": "fork-Persian carpet 18-jf-v1", "author": "jorge2017a2", "description": "fork-Persian carpet 18-jf", "tags": ["forkpersiancarpet18jf"], "likes": 3, "viewed": 21, "published": "Public", "date": "1636751841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///fork\n//https://www.shadertoy.com/view/fl3GDB\n//Created by jarble in 2021-11-11\n///modificado por jorge2017a2\n\n//change these constants to get different patterns!\n#define c2 0.05\n\n#define cB1 0.0\n#define cB2 0.01\n#define cB3 0.05\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n#define cA1 vec4(3.0+cB1,2.5+cB1,1.5,0)\n#define cA2 vec4(3.0+cB2,2.5+cB2,1.5,0)\n#define cA3 vec4(3.0+cB3,2.5+cB3,1.5,0)\n\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{//from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale)\n{ return abs(fract((a+c1.xy)*scale)-.5);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    float tfijo=8.67;\n    float ti=iTime;\n    \n    uv += vec2(18.67/2.0+ti,18.67/3.0+ti*0.5)/t1/8.0; //antes\n    float t2 =tfijo;\n    \n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    \n    vec2 va1;\n    vec2 va2;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++){\n                uv /= -scale2;\n                uv.yx = triangle_wave(uv.yx-offset,scale)+triangle_wave(uv,scale);\n                va1=vec2(random1[k]*random1[0],random2[k]);\n                va2=vec2(random1[k],random2[k]);\n                uv +=mix( va1, va2, sin(ti));\n            }\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n            col[c] = abs((uv.x)-(uv.y));\n        }\n\t}\n\n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 502, 524, 565, 698], [700, 700, 740, 740, 780], [783, 783, 840, 840, 1883]], "test": "valid"}
{"id": "Nlt3DB", "name": "black holes", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 8, "viewed": 164, "published": "Public API", "date": "1636652398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"depth of field focus study 4\" by morisil. https://shadertoy.com/view/stdGzf\n// 2021-11-11 17:35:53\n\n// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-09 22:06:23\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur, in float shapeSize) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(shapeSize + blur, shapeSize - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6 + st.x + st.y) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    st *= log(length(sin(st * 5.18)) * (sin(iTime) + 2.) * 3.);\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    float shapeSize = .2 + (sin(iTime * .7) + 1.) * .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur, shapeSize),\n            getColorComponent(center, modScale, blur, shapeSize),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur, shapeSize)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 576, 576, 662], [665, 665, 756, 756, 990], [992, 992, 1047, 1047, 2190]], "test": "valid"}
{"id": "Nlt3Rs", "name": "Fork Fork Proce gchipunov 018", "author": "gchipunov", "description": "Simple procedural grass no hash2", "tags": ["procedural", "2d", "grass", "animated", "wind"], "likes": 1, "viewed": 39, "published": "Public", "date": "1636554028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scaleFactor 45.0\n#define noiseFactor 0.8\n#define windFactor 1.8\n#define grassHeight 5.0\n#define grassWidth 0.3\n\n\n//vec2 hash2( vec2 p )\n//{\n    // procedural white noise by iq\n//\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453)*noiseFactor;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=vec3(0.0);\n    vec2 pG=fragCoord.xy / iResolution.xx * scaleFactor;\n    vec2 n=floor(pG);\n    vec2 f=fract(pG);\n\n    for (int j= 0;j>= -8;j--)\n        for (int i= -3;i<=3;i++)\n        {\n            vec2 g=vec2(float(i),float(j));\n            vec2 growFrom=n+g;//hash2(n+g)*0.8;\n\n            vec2 growTo=growFrom+windFactor*vec2(sin(0.7*iTime ))+ (n+g); //+ (n+g).x/10.0,0);\n\n            if (pG.y>growTo.y || pG.y<growFrom.y) continue;\n\n            float rely=(pG.y-growFrom.y)/(growTo.y-growFrom.y);\n\n            float gr=log2(2.0-abs(rely))*grassWidth;\n            float dx= -pow(rely,2.0)*(growTo.x-growFrom.x);\n            #define ival 0.08\n            col=mix(col,vec3(0.0,0.0,0.0)*rely,smoothstep(gr+2.0*ival,gr,abs(growFrom.x+dx-pG.x)));\n            col=mix(col,vec3(0.0,1.0,0.0)*rely,smoothstep(gr+ival,gr-ival,abs(growFrom.x+dx-pG.x)));\n        }\n\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 348, 348, 1248]], "test": "valid"}
{"id": "NltGWr", "name": "DaemonWall(Modified)", "author": "taellinglin", "description": "kinda stole this shader from another one and removed the rotation/tilt/wobble and RGB shifter...\n\nI am just starting with shaders and thought this would look cool as a level texture in my game without some of the effects. Whoever wrote this I will hire u", "tags": ["stolen"], "likes": 7, "viewed": 142, "published": "Public API", "date": "1635991388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tdraw letter shapes after subdividing uv space randomly\n\n*/\n\n#define PI 3.1415926535\n\nfloat random2d(vec2 n) { \n    return fract(sin(dot(n, vec2(129.9898, 4.1414))) * 2398.5453);\n}\n\nvec2 getCellIJ(vec2 uv, float gridDims){\n    return floor(uv * gridDims)/ gridDims;\n}\n\nvec2 rotate2D(vec2 position, float theta)\n{\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\n//from https://github.com/keijiro/ShaderSketches/blob/master/Text.glsl\nfloat letter(vec2 coord, float size)\n{\n    vec2 gp = floor(coord / size * 7.); // global\n    vec2 rp = floor(fract(coord / size) * 7.); // repeated\n    vec2 odd = fract(rp * 0.5) * 2.;\n    float rnd = random2d(gp);\n    float c = max(odd.x, odd.y) * step(0.5, rnd); // random lines\n    c += min(odd.x, odd.y); // fill corner and center points\n    c *= rp.x * (6. - rp.x); // cropping\n    c *= rp.y * (6. - rp.y);\n    return clamp(c, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    float t = iTime;\n    float scrollSpeed = 0.3;\n    float dims = 2.0;\n    int maxSubdivisions = 3;\n    \n    //uv = rotate2D(uv,PI/12.0);\n    uv.y -= iTime * scrollSpeed;\n    \n    float cellRand;\n    vec2 ij;\n    \n   \tfor(int i = 0; i <= maxSubdivisions; i++) { \n        ij = getCellIJ(uv, dims);\n        cellRand = random2d(ij);\n        dims *= 2.0;\n        //decide whether to subdivide cells again\n        float cellRand2 = random2d(ij + 454.4543);\n        if (cellRand2 > 0.3){\n        \tbreak; \n        }\n    }\n   \n    //draw letters    \n    float b = letter(uv, 1.0 / (dims));\n\t\n    //fade in\n    float scrollPos = iTime*scrollSpeed + 0.5;\n    float showPos = -ij.y + cellRand;\n    float fade = smoothstep(showPos ,showPos + 0.05, scrollPos );\n    b *= fade;\n    \n    //hide some\n    //if (cellRand < 0.1) b = 0.0;\n    \n    fragColor = vec4(vec3(b), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 184], [186, 186, 226, 226, 271], [273, 273, 316, 316, 413], [415, 486, 524, 524, 928], [930, 930, 987, 987, 1975]], "test": "valid"}
{"id": "NltGzM", "name": "Mandelbrot-simple", "author": "backhoff", "description": "Simple Mandelbrot visualization.", "tags": ["fractal", "mandelbrot", "trippy", "easy"], "likes": 1, "viewed": 44, "published": "Public", "date": "1635877862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize position\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    \n    // interesting points\n    //float x0 = 0.42884;\n    //float y0 = -0.231345;\n    float x0 = -0.761574;\n    float y0 = -0.0847596;\n    \n    uv /= 1.0 * exp(6.0 * (1.0 + sin((iTime + 23.5)/ 5.0)));\n    uv = vec2((uv.x + x0), (uv.y + y0) );\n    \n    // mandelbrot algo\n    int max_it = 300;\n    vec2 z = vec2(0.0, 0.0);\n    int cnt = 0;\n    for (int i = 0; i < max_it && dot (z,z) < 4.0; i++)\n    {\n        float x = z.x * z.x - z.y * z.y + uv.x;\n        z.y = 2.0 * z.x * z.y + uv.y;\n        z.x = x;\n        cnt += 1;\n    }\n    \n    // set the default funky colors and obscure them\n    // using madelbrot result depending on how quickly\n    // they exploded (if)\n    vec3 col;\n    col = 0.75 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     if (cnt < max_it - 1) \n    { \n        col  *= (float(cnt) / (float(max_it) - 1.0));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "NlV3Rc", "name": "Gooage", "author": "gimulnautti", "description": "Just someThings", "tags": ["simple", "psychedelic", "visualizer"], "likes": 0, "viewed": 43, "published": "Public", "date": "1638102954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define freq(f) texture(iChannel0, vec2(f, 0.25)).x * 0.8\n#define wave(f) texture(iChannel0, vec2(f, 0.75)).x\n\n// Fast enough to go fullscreen on almost anything!\n// WIP just make it better :D \n// @Gimulnautti\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv1b = uv - vec2( 0.5 + sin(iTime) * 0.05, 0.5 + cos(iTime) * 0.1 );    \n    vec2 uv1 = uv1b / dot( uv1b, uv1b * (freq( 100 )) );\n    float line1 = cos( uv1.x + freq(50) * 10.0 + iTime );\n\n    vec2 uv2b = uv - vec2( 0.5 - sin(iTime) * 0.05, 0.5 + cos(iTime) * 0.1 );    \n    vec2 uv2 = uv2b / dot( uv2b, uv2b * (freq( 1000 ) + 0.1 + sin(iTime/2.0)) );\n    float line2 = cos( uv2.y + freq(2000) * 1.0 - iTime * 20.0 );\n    \n    vec2 uv3b = uv - vec2( 0.5 /*0.3 + sin(freq(150))* 0.5*/, 0.5 - cos(iTime) * 0.1 );    \n    vec2 uv3 = uv3b / (dot( uv3b, uv3b * (freq( 4000 )) ) * 0.5);\n    float line3 = cos( uv3.y + uv3.x + freq(10000) * 2.0 - iTime * 10.0 );\n\n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.5*cos(iTime+freq(50)*4.0+uv.xyx+vec3(0,2,4));\n    vec3 col2 = vec3( line2/line1, 0.0, line1/line3 );\n\n    // Output to screen\n    fragColor = vec4(col1 + col2,1.0);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 268, 318, 1252]], "test": "error"}
{"id": "NlV3WW", "name": "More trippy log-polar grid stuff", "author": "SnoopethDuckDuck", "description": "messy code", "tags": ["e"], "likes": 5, "viewed": 129, "published": "Public API", "date": "1637709477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n#define pi 3.14159\n\nfloat func(vec2 uv, float time) {\n    vec2 p = 0.35 * vec2(thc(4., time), ths(4., time));\n    float d = length(uv-p);\n    float k = 1.1 * thc(4.,3. * uv.x + time);\n    float s = smoothstep(-k, k, 0.82 - d);\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float time = -4. * iTime;\n    float a = atan(uv.y, uv.x);\n    float r = log(length(uv));\n  \n    //vec2 ipos = floor(iTime * uv) + 0.5;\n    uv = 0.5 * thc(2. + 1.5 * cos(10. * mlength(uv) + time),\n                   10. * uv) - 0. * thc(1.,iTime);\n            \n    float s = func(uv, time + a + r * 24.+ length(uv) * 0100.);\n    float s2 = func(fract(9. * uv) - 0.5, 8. * r + time);\n\n    s = max(s-s2, 0.08);\n    //s = s2;//mix(s,s2, .5 + .5 * thc(4., iTime));\n\n    vec3 col = s2 * pal(ths(r,length(uv) * r - iTime) + s, vec3(1.), vec3(1.), vec3(1.), s * vec3(0.,0.33,0.66));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3WW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 171, 171, 212], [214, 214, 241, 241, 282], [284, 284, 352, 352, 395], [397, 397, 417, 417, 492], [494, 494, 518, 518, 558], [580, 580, 613, 613, 802], [804, 804, 861, 861, 1558]], "test": "valid"}
{"id": "NlV3Wz", "name": "Distribution of Random funcs", "author": "iY0Yi", "description": "Distribution of Random functions.\nInspired by this shader.\n[url]https://www.shadertoy.com/view/4ssXRX[/url]", "tags": ["random", "hash", "distribution"], "likes": 15, "viewed": 222, "published": "Public API", "date": "1637515240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rndUni(vec2 p){\n    return hash12(p);\n}\n\nfloat rndAdd(vec2 p){\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    return (a+b)*.5;\n}\n\nfloat rndMul1(vec2 p){\n    float a = hash12(p);\n    return (a*a*a);\n}\n\nfloat rndMul2(vec2 p){\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    return (a*b);\n}\n\nfloat rndSqrt(vec2 p){\n    float a = hash12(p);\n    return sqrt(a);\n}\n\nfloat rndPow(vec2 p){\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    //return pow(a, (1.+sin(iTime))*8.);\n    \n    return pow(rndMul2(p), .25);\n}\n\nfloat rndGauss(vec2 p) {\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    float value =\n    sqrt(-2.*log(a)) *\n    sin(2.*acos(-1.) * b);\n    value = (value + 3.) / 6.;\n    return value;\n}\n\n\n#define drawHistgram(RND_TYPE) {\\\n    float maxth = ceil(uv.x*float(RESOLUTION))/float(RESOLUTION);\\\n    float minth = maxth-(1./float(RESOLUTION));\\\n    float cnt = 0.;\\\n    float t = fract( iTime );\\\n    for(int i = 0; i<MAX_SAMPLE; i++) {\\\n        float rnd = RND_TYPE(vec2(i,domain.x)+t);\\\n        if(rnd>=minth && rnd<maxth)cnt++;\\\n    }\\\n    cnt /= float(MAX_SAMPLE);\\\n    res = (cnt>uv.y/SCALE_Y) ? 1.: 0.;\\\n}\\\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const int VARIATIONS = 7;\n    vec2 domain = vec2(iResolution.x/float(VARIATIONS), iResolution.y);\n    int id = int(floor(fragCoord.x/domain.x));\n    fragCoord.x = mod(fragCoord.x, domain.x);\n    vec2 uv = fragCoord/domain;\n    \n    float res = 0.;\n    const int MAX_SAMPLE = 3000;\n    const int RESOLUTION = 30;\n    const float SCALE_Y = 1.;\n    if(id==0) drawHistgram(rndUni);\n    if(id==1) drawHistgram(rndAdd);\n    if(id==2) drawHistgram(rndMul1);\n    if(id==3) drawHistgram(rndMul2);\n    if(id==4) drawHistgram(rndSqrt);\n    if(id==5) drawHistgram(rndPow);\n    if(id==6) drawHistgram(rndGauss);\n    //drawHistgram(rndGauss);\n    vec3 col = mix(vec3(0.102,0.102,0.102), vec3(.8, .77, .7), res);\n    col = max(col, vec3(.8, .77, .7)*.3* ((fragCoord.x>=domain.x-2.) ? vec3(1) : vec3(0)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 102, 102, 219], [221, 221, 242, 242, 266], [268, 268, 289, 289, 365], [367, 367, 389, 389, 436], [438, 438, 460, 460, 533], [535, 535, 557, 557, 604], [606, 606, 627, 627, 761], [763, 763, 787, 787, 959], [1381, 1381, 1438, 1438, 2265]], "test": "valid"}
{"id": "NlV3zm", "name": "Footwear Design 006", "author": "yasuo", "description": "・Tried to implement the tube outsole.\n・Modefied the previous design upper shape with holes", "tags": ["footwear"], "likes": 3, "viewed": 121, "published": "Public API", "date": "1637393580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    p = prevP;\n    float d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    float k = 0.06;\n    p = prevP;\n    p.y*=0.7;\n    p.xz*=Rot(radians(90.0));\n    p.yz*=Rot(radians(90.0));\n    d2 = sdLink(p-vec3(0.0,0.01,-0.04),0.08,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    d2 = sdLink(p-vec3(0.15,0.0,-0.04),0.12,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    d2 = sdLink(p-vec3(-0.15,0.005,-0.04),0.17,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    p.xz*=Rot(radians(-15.0));\n    d2 = sdLink(p-vec3(0.28,0.0,-0.1),0.065,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    \n    p = prevP;\n    p.y*=0.7;\n    p.xz*=Rot(radians(90.0));\n    p.yz*=Rot(radians(90.0));\n    p.xz*=Rot(radians(10.0));\n    d2 = sdLink(p-vec3(-0.28,-0.02,-0.08),0.14,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    d2 = sdLink(p-vec3(-0.38,-0.03,-0.08),0.08,0.02,0.012);\n    d = opSmoothUnion(d,d2,k);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    \n    vec3 prevP2 = p;\n    p.x+=cos(p.y*70.0)*0.005;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.y+=0.01;\n    p.z-=0.005;\n    p.yz*=Rot(radians(-12.0));\n    p.x = mod(p.x,0.2)-0.1;\n    p.y = mod(p.y,0.1)-0.05;\n    p.z = mod(p.z,0.2)-0.1;\n    p.x*=0.8;\n    p.y*=2.0;\n    p.z*=0.8;\n    \n    \n    d2 = length(p)-0.05;\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.115),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.09),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    d =  opSmoothUnion(d,d2,0.03);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n        vec2 prevUV = uv;\n        \n        uv.x+=cos(uv.y*70.0)*0.02+sin(uv.y*50.0)*0.05;\n        float d = -uv.x+0.01;\n        col = mix(col,mix(vec3(0.7,0.2,0.2),vec3(1.0,1.0,0.1),uv.y),S(prevUV,d,0.0));\n\n        return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,upperTex(p.yz*0.9,vec3(0.4,0.3,0.1)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.2);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1273, 1306, 1306, 1371], [1373, 1448, 1502, 1502, 1604], [1606, 1681, 1733, 1733, 1840], [1842, 1917, 1948, 1948, 2035], [2037, 2112, 2149, 2149, 2232], [2234, 2309, 2368, 2368, 2681], [2683, 2683, 2732, 2732, 2805], [2807, 2807, 2842, 2842, 3250], [3252, 3252, 3274, 3274, 4668], [4671, 4671, 4695, 4695, 5755], [5757, 5757, 5777, 5777, 6831], [6833, 6833, 6855, 6855, 7109], [7111, 7111, 7169, 7169, 7436], [7438, 7438, 7462, 7462, 7663], [7665, 7665, 7707, 7707, 7902], [7904, 7945, 7994, 7994, 8288], [8290, 8290, 8347, 8347, 8966], [8968, 8968, 8990, 8990, 9080], [9082, 9082, 9115, 9115, 9344], [9346, 9346, 9405, 9405, 9530], [9532, 9532, 9589, 9589, 10633]], "test": "valid"}
{"id": "NlVGRm", "name": "getting closer", "author": "HaleyHalcyon", "description": "they look like they're getting closer but they aren't. dizzying", "tags": ["a"], "likes": 4, "viewed": 33, "published": "Public", "date": "1638235588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n// i want to use hex codes like in image editing programs,\n// so here's an improved macro by FabriceNeyret2\n#define HEX(x) vec3( ( ivec3(x) >> ivec3(16,8,0) ) & 255 ) / 255.\n\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        HEX(0xb810b0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        vec3(1),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    x *= float(colorCount);\n    int lo = 1048576 + int(floor(x));\n    \n    return mix(\n        c[lo % colorCount],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 4.0);\n  // make the center of the canvas (0.0, 0.0) and\n  // make the long edge of the canvas range from -1.0 to +1.0\n  float scale = max(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n\n  vec2 sep = vec2(sin(time * TAU * 0.5), cos(time * TAU * 0.5)) * 0.1;\n  \n  const float zoomSpeed = 9.;\n  const float ringSpacing = 0.8;\n\n  float dist = log(length(uv));\n  float distA = log(length(uv - sep) * ringSpacing) - zoomSpeed * time;\n  float distB = log(length(uv + sep) * ringSpacing) - zoomSpeed * time;\n  \n  float alphaA = step(0.8, fract(distA));\n  float alphaB = step(0.8, fract(distB));\n\n  vec3 colA = alphaA * color(time * 0.5);\n  vec3 colB = alphaB * color(time * 0.5 + 0.5);\n  \n  vec3 col = mix(\n  colA + colB,\n  vec3(1.),\n  clamp(alphaA + alphaB - 1.,\n   0., 1.));\n   \n  float swirl = step(\n    0.7,\n    fract(\n      dist * 4.\n    + atan(uv.y, uv.x) * 8. / TAU\n    + time * 8.\n    )\n  );\n  col += smoothstep(-1.0, -0.6, dist) * swirl;\n  \n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[635, 635, 692, 692, 1772]], "test": "error"}
{"id": "NlVGWW", "name": "monito 2d y fondo ", "author": "jorge2017a2", "description": "monito 2d y fondo ", "tags": ["monito2dyfondo"], "likes": 6, "viewed": 97, "published": "Public API", "date": "1637703707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a2\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//https://www.shadertoy.com/view/7ly3D1  ... Lightspeed effect\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;   return length(max(d,0.0)) + min(max(d.x,d.y),0.0);}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat ellipse(vec2 p, vec2 focus0, vec2 focus1, float radius) \n{   return distance(p, focus0) + distance(p, focus1) - distance(focus0, focus1) * radius; }\n\nfloat HacerPeloDown1(vec2 p )\n{   float d1= sdCircle(p-vec2(0.0,0.0), 0.5 );\n    float d2= sdCircle(p-vec2(0.2,-0.35),0.5 );\n    float dif1= differenceSDF(d1, d2);\n    return dif1;\n}\nfloat HacerPeloUp1(vec2 p )\n{   float d1= sdCircle(p-vec2(0.0,0.0), 0.5 );\n    float d2= sdCircle(p-vec2(0.42,0.35),0.75 );\n    float dif1= differenceSDF(d1, d2);\n    return dif1;\n}\n\nfloat HacerRostro(vec2 p)\n{   vec2 focus0=vec2(0.0,0.2);\n    vec2 focus1=vec2(0.0,0.8);\n    float radius=2.0;\n    float d1= ellipse(p,focus0,focus1,radius);\n    return d1;\n}\n\nfloat HacerOjo(vec2 p)\n{   vec2 focus0=vec2(0.0,0.2);\n    vec2 focus1=vec2(0.0,0.3);\n    float radius=1.0;\n    float d1= ellipse(p,focus0,focus1,radius);\n    return d1;\n}\n\nfloat HacerBoca(vec2 p)\n{   vec2 focus0=vec2(0.01,0.2);\n    vec2 focus1=vec2(0.2,0.25);\n    float radius=1.0;\n    float d1= ellipse(p,focus0,focus1,radius);\n    return d1;\n}\n\n\nvec3 sd2d(vec2 uv, vec3 col)\n{   float d0=HacerRostro(uv-vec2(0.08,-0.7));\n    col= DrawFigBorde(vec3(0.7,0.6,0.1)-uv.y*0.25, col, d0 );\n    \n    float d1,d2,d3,d4,d5,d6;\n    d1= HacerPeloDown1(uv-vec2(0.05,0.0));\n    d2= HacerPeloUp1(uv-vec2(0.3,0.48));\n    d3= HacerPeloUp1(vec2(-uv.x, uv.y)-vec2(-0.2,0.25));\n    d4= HacerPeloUp1(uv*1.5-vec2(-0.2,0.45));\n    d5= HacerPeloDown1(vec2(-uv.x, uv.y)-vec2(-0.4,-0.1) );\n    d6= HacerPeloUp1(vec2(-uv.x, uv.y)*1.2-vec2(0.6,0.25));\n    \n    float dtdo=unionSDF(d1, d2);\n    dtdo=unionSDF(dtdo, d3);\n    dtdo=unionSDF(dtdo, d4);\n    dtdo=unionSDF(dtdo, d5);\n    dtdo=unionSDF(dtdo, d6);\n    col=DrawFigBorde(vec3(1.0,0.0,0.0)-uv.y, col,dtdo);\n    \n    float dojoI= HacerOjo(uv-vec2(0.0,-0.6));\n    float dojoD= HacerOjo(uv-vec2(0.3,-0.6));\n    col=DrawFigBorde(vec3(0.0,0.0,0.0), col,dojoI);\n    col=DrawFigBorde(vec3(0.0,0.0,0.0), col,dojoD);\n    \n     float dboca= HacerBoca(uv-vec2(0.0,-0.7));\n    col=DrawFigBorde(vec3(0.0,0.0,0.0), col,dboca);\n return col;\n}   \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv0 = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv0.x *= iResolution.x/iResolution.y;\n    uv0*=1.0;\n     // Normalized pixel coordinates (from -1 to 1)\n    vec2 suv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //Radial UVs    \n    vec2 uv = vec2(length(suv),atan(suv.y,suv.x));\n    //Stars\n    float offset = .1*sin(uv.y*10.f-iTime*.6)*cos(uv.y*48.f+iTime*.3)*cos(uv.y*3.7f+iTime);\n    vec3 rays = vec3(sin(uv.y*150.f+iTime)*.5+.5)* \n    vec3(sin(uv.y*80.f-iTime*0.6)*.5+.5)*\n    vec3(sin(uv.y*45.f+iTime*0.8)*.5+.5)*\n    vec3(1.f-cos(uv.y+22.f*iTime-pow(uv.x+offset,.3f)*60.f))*\n    vec3(uv.x*2.f);\n    vec2 uv2=rays.xy;\n    \n   vec3  col=vec3(0.0);\n    col=sd2d(uv2, col);\n    col=sd2d(uv0, col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 377, 424, 424, 451], [452, 452, 495, 495, 522], [523, 523, 571, 571, 599], [605, 605, 667, 667, 863], [865, 865, 946, 946, 1076], [1078, 1078, 1135, 1135, 1201], [1203, 1203, 1240, 1240, 1313], [1315, 1315, 1350, 1350, 1373], [1375, 1375, 1439, 1439, 1529], [1531, 1531, 1562, 1562, 1713], [1714, 1714, 1743, 1743, 1895], [1897, 1897, 1924, 1924, 2070], [2072, 2072, 2096, 2096, 2242], [2244, 2244, 2269, 2269, 2417], [2420, 2420, 2450, 2450, 3428], [3437, 3437, 3494, 3494, 4264]], "test": "valid"}
{"id": "NlVGzW", "name": "FEZ Shader - Pink Grid", "author": "sterlingsowards", "description": "Yet another fez inspired simple shader. Shortly after leaving your village, you come across a room with a bunch of locked doors. The background for this hub room looks similar to this", "tags": ["grid", "texture", "lines", "parallax", "pink", "background", "videogame", "fez", "scrolling", "layered"], "likes": 5, "viewed": 57, "published": "Public", "date": "1637259589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 3.\n#define ZOOM_CLOSE 2.\n#define ZOOM_FAR 6.\n#define WIDTH .005\n\nfloat gridLayer( vec2 uv, float zoom )\n{\n    float a;\n    \n    // Create the grid coords\n    vec2 gv = fract(uv * zoom)-.5;\n    \n    // draw the lines\n    a = max(smoothstep(WIDTH+ 1./iResolution.y, WIDTH, abs(gv.y)), smoothstep(WIDTH+1./iResolution.x, WIDTH, abs(gv.x)));\n    \n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    uv.y -= .2;\n\n    vec3 col = vec3(0.043, 0.003, 0.074);\n    \n    // Draw the layers back to front\n    for (float i = 1.; i <= NUM_LAYERS; i++) {\n        // Get the zoom\n        float zoom = mix(ZOOM_FAR, ZOOM_CLOSE, (i-1.)/(NUM_LAYERS-1.));\n        \n        // Get the grid layer alpha data\n        vec2 offset = vec2(iTime * i *.06 + i*.458, i*.74);\n        float gridAlpha = gridLayer(uv + offset, zoom) *  i/(NUM_LAYERS);\n        vec3 gridCol = vec3(0.615, 0, 0.262); \n        col = gridCol * gridAlpha + col * (1.-gridAlpha);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 124, 124, 377], [379, 379, 436, 486, 1150]], "test": "valid"}
{"id": "Nly3z1", "name": "Persian mosaic 4", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "mosaic", "ceramic"], "likes": 2, "viewed": 102, "published": "Public API", "date": "1637124719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.;\n            \n\n            for(int k = 0; k < 6; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.;\n                \n                uv.yx = triangle_wave(uv.yx+offset/1.5,scale)*bend+triangle_wave(uv-offset,scale)/bend;\n                //bend *= 1. - (((uv.x-uv.y)))/81.;\n                //uv -= offset/1.5;\n\n                //uv += vec2(random1[k]/bend,random2[k]*bend);\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1. +uv.x/2.;\n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nly3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2413]], "test": "valid"}
{"id": "NlyGRK", "name": "veiershrassfunction", "author": "polinasidiropoulou", "description": "first shader ", "tags": ["functionsveiershrass"], "likes": 2, "viewed": 22, "published": "Public", "date": "1637945509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535897932384626433832795\n\nfloat veiershrass (float x){\n    float sum=0.0;\n    float a=0.056;\n    float b=0.044;\n    for(int i=0; i<100; i++){\n        // Time varying pixel color\n        sum += pow(0.5,float(i))*cos(pow(a,float(i))*pi*x);\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.25*veiershrass(uv.x*iTime)+0.5);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 74, 74, 281], [283, 283, 340, 390, 548]], "test": "valid"}
{"id": "NlyGzm", "name": "Optical Illusion Discs", "author": "xavierseb", "description": "Saw it on Youtube, credits to @coachly.de and probably others(?)\nI thought I would try to code it to play with the ideas.\nthe illusion is that the size appears to change, there is a variation in which they can appear to move around, \nopen to suggestions..", "tags": ["optical", "illusion", "visual"], "likes": 5, "viewed": 110, "published": "Public API", "date": "1637341136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// optical illusion inspired from @coachly.de\n// the discs are not changing in size at all.\n// slight variation of this can give the illusion of movement\n\n#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = mod( fragCoord/iResolution.xy, vec2(.5,1.) );\n\t\t\n\tfloat angle = (atan(position.y-.5,position.x-.25)+PI)/2./PI;\n\tangle = mod(angle+iTime*2.4,1.);\n\t\n\tfloat r=.5,g=.5,b=.5,l=length(position-vec2(.25,.5));\n\t\n\tif(l>.13&&l<.2) {\n\t\tif ( angle<.25) {  // y to r\n\t\t\tg=angle*4.;\n\t\t\tr=1.;\n\t\t\tb=0.;\n\t\t}\t\t\t\n\t\telse if(angle<.5) {  // c to y\n\t\t\tg=1.;\n\t\t\tb=(angle-.25)*4.;\n\t\t\tr=1.-b;\n\t\t}\n\t\telse if(angle<.75) { // b to c\n\t\t\tb=1.;\n\t\t\tg=1.-(angle-.5)*4.;\n\t\t\tr=0.;\n\t\t}\n\t\telse {\t\t// r to b\n\t\t\tr=(angle-.75)*4.;\n\t\t\tb=1.-r;\n\t\t\tg=0.;\n\t\t}\n\t}\n\t\n    if(l>.1975&&l<.2) {\t// outer rim\n\t\tfloat s = .3 + abs(cos(PI*angle-.03*mod(iTime,1.)));\n\t\ts*=s; r*=s; g*=s; b*=s;\n\t}\n\telse if(l>.127&&l<.13) {\t// inner rim\n\t\tfloat s = .3 + abs(sin(PI*angle-.03*mod(iTime,1.)));\n\t\ts*=s; r*=s; g*=s; b*=s;\n\t}\n\n\t/*if(l>.1975&&l<.2) {\t// outer rim\n\t\tfloat s=1.3*abs(sin(PI*angle-sin(iTime)));\n\t\tr*=s; g*=s; b*=s;\n\t}\n\telse if(l>.127&&l<.13) {\t// inner rim\n\t\tfloat s=1.3*abs(sin(PI*angle+sin(iTime*1.23456)));\n\t\tr*=s; g*=s; b*=s;\n\t}*/\n\t\n\tfragColor = vec4(r,g,b,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 232, 232, 1267]], "test": "valid"}
{"id": "NsKSzt", "name": "lattice sdf", "author": "kylegrover", "description": "playing with cubes of cubes and booleans of more cubes", "tags": ["3d", "raymarching", "distancefield", "sdf"], "likes": 3, "viewed": 142, "published": "Public API", "date": "1636354840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 opRotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( vec3 p, float b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdDiamond( vec3 p, float b)\n{\n  vec3 rot = p;\n  rot.xy = rot.xy * opRotate(0.785);\n  rot.xz = rot.xz * opRotate(.616);\n  rot.yz = rot.yz * opRotate(-.616);\n  vec3 d = abs(rot) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float d = (p.x+p.y+p.z-s)*0.57735027;\n  return d;\n}\n\nfloat opRepLimBox( in vec3 p, in float c, in vec3 l, float bb )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdBox(q, bb);\n}\n\n//---------------------------------\n// geometry controls\nconst float bothscale = 1.;\nconst float boxscale = 0.125 * bothscale;\nconst float diascale = 0.38 * bothscale;\nconst float timeoffset = 1.5; // -2 to 2\nconst int pattern = 999; // pattern picker, 1-whatever, 999 to test\nconst float dancespeed = 1.5;\n// render controls\nconst float render_depth = 13.0; // range 9ish to 11, lower = goopy\nconst int render_steps = 64; // options: 4, 8, 16, 32. low = goopy\nconst float lines = 0.0; // 0 to ~3.5\nconst int colormode = 2;\n\nfloat cubeDance(in float time, in vec3 pos) {\n    float size = 0.0;\n    if (pattern == 1) {\n        size += sin(time + pos.y * 3.15 * -.75);\n        if (mod(pos.x + pos.z,2.0) < 0.5) size *= -1.;\n    } else if (pattern == 2)\n        size += sin(time + pos.x * pos.y * (3.0 + 2.0 * pos.z));\n    else if (pattern == 3) \n        size += pos.y*cos(time*0.5);    \n    else {\n        vec3 normpos = (pos+0.5) * 0.4 - 1.; // -1 to 1\n        vec3 centerpos = abs(normpos) * 2.0 - 1.0;\n        size = sin(centerpos.z + centerpos.x + centerpos.y + time);\n    }\n    return size; // -1 to 1\n}\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n\n    pos -= vec3(1.,1.,1.);\n    \n    for(int x=0;x<5;x++)\n    for(int y=0;y<5;y++)\n    for(int z=0;z<5;z++)\n    {\n        vec3 cubepos = vec3(float(x),float(y),float(z));\n        float temptime = iTime*dancespeed;\n        \n        float boxsize = cubeDance(temptime, cubepos);\n        boxsize = clamp(boxsize*1.4+0.2, -1., 1.0);\n        boxsize = sin(boxsize)*boxscale+boxscale;\n\n        float diasize = cubeDance(temptime+timeoffset, cubepos);\n        diasize = clamp(diasize*1.4+0.2, -1.1, 1.0);\n        diasize = sin(diasize)*diascale+diascale;\n        float d2 = sdBox(\n            pos-vec3(\n                -float(x) * 0.5,\n                float(y) * 0.5,\n                -float(z) * 0.5\n            ), \n            boxsize\n        ); \n        float d3 = sdOctahedron(\n            pos-vec3(\n                -float(x) * 0.5,\n                float(y) * 0.5,\n                -float(z) * 0.5\n            ), \n            diasize\n        );\n        // d3 = 0.; // show box only\n        // d2 = 0.; // show diamond only\n        d = min( d, max( d2, d3 ));\n    }\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 1.00 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(.0,5.8,10.);\n        vec3 rd = normalize(vec3(p-vec2(.0,2.05),-5.));\n        \n        ro.xz *= opRotate(iTime * .5 + p.y * 1.2);\n        rd.xz *= opRotate(iTime * .5 + p.y * 1.2);\n\n        float t = 8.5;\n        for( int i=0; i<render_steps; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.005 || t>render_depth ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<render_depth + lines)\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.8);\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 0.5, 12.0 );\n            float amb = 0.5 + 0.5*nor.y;\n        \n            if (colormode == 1){\n                float amb = 0.5 + 0.5*nor.y;\n                col = vec3(sha + amb) / 2.;\n                col -= 0.5;\n                col *= 2.0;\n                col = pow(col, vec3(0.5));\n                col /= 2.0;\n                col += 0.5;\n                col = vec3(step(amb,0.3));\n            } else if (colormode == 2){\n                float amb = 0.5 + 0.5*nor.y;\n                col = vec3(sha + amb) / 2.;\n                col -= 0.5;\n                col *= 2.0;\n                col = pow(col, vec3(0.25));\n                col /= 2.0;\n                col += 0.5;\n            } else {\n                col = vec3(0.4)*amb + \n                      vec3(.80)*dif*sha;\n            }\n            \n        }\n\n        col = sqrt( col );\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n\n// Uses MIT SDF functions from IQ:\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [145, 145, 186, 186, 212], [215, 215, 246, 246, 333], [336, 336, 371, 371, 586], [588, 588, 626, 626, 694], [696, 696, 761, 761, 829], [1356, 1356, 1401, 1401, 1936], [1938, 1938, 1962, 1962, 3059], [3061, 3125, 3157, 3157, 3391], [3393, 3455, 3542, 3542, 3800]], "test": "valid"}
{"id": "Nt33R7", "name": "glowglowglow", "author": "darkfox", "description": "glow", "tags": ["glow"], "likes": 0, "viewed": 34, "published": "Public", "date": "1635846529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 f,in vec2 g){\nvec2 uv=(g*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\nfloat d=.25*(1.+cos(iTime*4.+uv.x*3.*6.28318))*(1.+cos(iTime*3.+uv.y*3.*6.28318));\nfloat k=7.+3.*sin(iTime*8.);vec3 col=vec3(exp((d-.95)*k));f=vec4(col,1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 259]], "test": "valid"}
{"id": "Nt33z4", "name": "Voronoi Patterns Shader", "author": "arjunpandey", "description": "Playing around with Voronoi", "tags": ["voronoi"], "likes": 4, "viewed": 73, "published": "Public", "date": "1635755673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(100,300)), \n\t\t\t\t   dot(p,vec2(250,150)), \n\t\t\t\t   dot(p,vec2(400,500)) );\n\treturn fract(sin(q) * 40000.54);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0 + 63.0 * pow(1.0 - v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( y, x );\n\t\tvec3  o = hash3( i + g ) * vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0 - smoothstep(0.0,1.005, length(d)), k );\n\t\ta += vec2(o.z * w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xx;\n\n    vec2 p = 0.5 - 0.5 * sin( iTime * vec2(1.0,0.5) );\n    \n\tif( iMouse.w > 0.1 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0) * iMouse.xy/iResolution.xy;\n\t\n\tp = p*p*(2.5 - 1.5 * p);\n\tp = p*p*(2.5 - 1.5 * p);\n\tp = p*p*(2.5 - 1.5 * p);\n\t\n\tfloat f = voronoise( 45.0 * uv, p.x, p.y );\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 163, 211, 211, 616], [618, 618, 675, 675, 1026]], "test": "valid"}
{"id": "Nt33zf", "name": "Cellular Noise :3", "author": "zlynch", "description": "Color Changing Noise!", "tags": ["noise"], "likes": 1, "viewed": 41, "published": "Public", "date": "1636411229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(tan(vec2(dot(p,vec2(50,150)),dot(p,vec2(300,150)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float amp = 0.15;\n    \n\n\n    float cellCount = 4.0;    \n    \n    float ampOfMove = 9.;\n    float dist = 2.;\n    \n    float seperation = 1.4;\n    vec2 mouse = vec2(iMouse)/vec2(iResolution);\n\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(1. * mouse.x, 0, 1.0 * mouse.y);\n    uv *= cellCount;\n    \n    vec2 movement = fract(uv);\n    vec2 intMove = floor(uv);\n\n\n    for (int x = 0; x <3; x++) {\n        for (int y = 0; y<3; y++)\n        {\n            vec2 neighbour = vec2(float(y), float(x));\n            \n            vec2 pt = random2(neighbour + intMove);\n            pt =  amp*(cos(iTime + ampOfMove*pt));\n            dist = min(dist, length(neighbour + pt - movement));\n        }\n    };\n\n    color += seperation*dist;\n\n    fragColor = vec4(color,3.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [99, 99, 156, 156, 937]], "test": "valid"}
{"id": "Nt3GR4", "name": "Swaggy Circles", "author": "ysp125", "description": "Some swaggy circles.", "tags": ["glow"], "likes": 2, "viewed": 77, "published": "Public", "date": "1635749186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define PI     3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   vec2 uv = fragCoord.xy;\n   \n   float cols[3] = float[3](0.0,0.0,0.0);\n\n   \n   float rVariableSize = max(cos(iTime*0.4), 0.4);\n   float gVariableSize = max(cos(PI + iTime*0.4), 0.4);\n   float bVariableSize = max(cos(PI/2.0 + iTime*0.4), 0.4);\n\n   \n   float size = 1.0;\n   float spinDistance = 150.0*cos(iTime);\n   float spinDistance2 = 100.0*cos(iTime);\n   float spinDistance3 = 50.0*cos(iTime);\n   \n   for (int i = 0; i < 4; i++) {\n      float x = float(i);\n      vec2 center;\n      vec2 displacement;\n      if (i % 3 == 0) {\n          center = vec2(iResolution.x/2.0 + (float(i&1) * cos(iTime) * spinDistance), iResolution.y/2.0 + (float(i&1)-1.0 * sin(iTime) * spinDistance));\n          displacement = uv - center;\n          cols[0] += 1.0/(length(displacement)*0.1*size);\n      } else {\n          center = vec2(iResolution.x/2.0 + (float(i&1) * sin(iTime) * spinDistance), iResolution.y/2.0 + (float(i&1)-1.0 * -cos(iTime) * spinDistance));\n          displacement = uv - center;\n          cols[0] += 1.0/(length(displacement)*0.1*size);\n      }\n   }\n   \n   for (int i = 0; i < 4; i++) {\n      float x = float(i);\n      vec2 center;\n      vec2 displacement;\n      if (i % 3 == 0) {\n          center = vec2(iResolution.x/2.0 + (float(i&1) * -cos(iTime) * spinDistance2), iResolution.y/2.0 + (float(i&1)-1.0 * sin(iTime) * spinDistance2));\n          displacement = uv - center;\n          cols[1] += 1.0/(length(displacement)*0.1*size);\n      } else {\n          center = vec2(iResolution.x/2.0 + (float(i&1) * sin(iTime) * spinDistance2), iResolution.y/2.0 + (float(i&1)-1.0 * cos(iTime) * spinDistance2));\n          displacement = uv - center;\n          cols[1] += 1.0/(length(displacement)*0.1*size);\n      }\n   }\n   \n   for (int i = 0; i < 4; i++) {\n      float x = float(i);\n      vec2 center;\n      vec2 displacement;\n      if (i % 3 == 0) {\n          center = vec2(iResolution.x/2.0 + (float(i&1) * cos(iTime + PI/4.0) * spinDistance3), iResolution.y/2.0 + (float(i&1)-1.0 * -sin(iTime + PI/4.0) * spinDistance3));\n          displacement = uv - center;\n          cols[2] += 1.0/(length(displacement)*0.1*size);\n      } else {\n          center = vec2(iResolution.x/2.0 + (float(i&1) * -sin(iTime + PI/4.0) * spinDistance3), iResolution.y/2.0 + (float(i&1)-1.0 * cos(iTime + PI/4.0) * spinDistance3));\n          displacement = uv - center;\n          cols[2] += 1.0/(length(displacement)*0.1*size);\n      }\n   }\n   \n   for (int i = 1; i <= 4; i++) {\n      float x = float(i);\n      vec2 center;\n      vec2 displacement;\n      if (i % 2 == 0) {\n          center = vec2(iResolution.x/2.0 + cos(iTime * 1.0/x) * spinDistance, iResolution.y/2.0 + cos(iTime * 1.0/x) * spinDistance);\n          displacement = uv - center;\n      } else {\n          center = vec2(iResolution.x/2.0 + sin(iTime * 1.0/x) * spinDistance, iResolution.y/2.0 + sin(iTime * 1.0/x) * spinDistance);\n          displacement = uv - center;\n      }\n      \n      cols[0] += 1.0/(length(displacement)*0.1*size*rVariableSize);\n   }\n   \n   for (int i = 1; i <= 4; i++) {\n      float x = float(i);\n      vec2 center;\n      vec2 displacement;\n      if (i % 2 == 0) {\n          center = vec2(iResolution.x/2.0 + cos(iTime * 1.0/x) * spinDistance2, iResolution.y/2.0 + -cos(iTime * 1.0/x) * spinDistance);\n          displacement = uv - center;\n      } else {\n          center = vec2(iResolution.x/2.0 + sin(iTime * 1.0/x) * spinDistance2, iResolution.y/2.0 + -sin(iTime * 1.0/x) * spinDistance);\n          displacement = uv - center;\n      }\n      \n      cols[1] += 1.0/(length(displacement)*0.1*size*gVariableSize);\n   }\n   \n   for (int i = 1; i <= 4; i++) {\n      float x = float(i);\n      vec2 center;\n      vec2 displacement;\n      if (i % 2 == 0) {\n          center = vec2(iResolution.x/2.0 + -cos(iTime * 1.0/x) * spinDistance3, iResolution.y/2.0 + cos(iTime * 1.0/x) * spinDistance);\n          displacement = uv - center;\n      } else {\n          center = vec2(iResolution.x/2.0 + -sin(iTime * 1.0/x) * spinDistance3, iResolution.y/2.0 + sin(iTime * 1.0/x) * spinDistance);\n          displacement = uv - center;\n      }\n      \n      cols[2] += 1.0/(length(displacement)*0.1*size*bVariableSize);\n   }\n    \n   \n   fragColor = vec4(cols[0],cols[1],cols[2],0.0);\n             \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "Nt3GWN", "name": "Circular Equalizer - Blue & Red", "author": "Meji", "description": "Equalizer", "tags": ["music"], "likes": 0, "viewed": 139, "published": "Public API", "date": "1636111114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nfloat rewrap(float r, float rep) {\n    \n    if (r < PI) {\n        r = -r;\n    }\n    \n    r = mod(r*rep, PI);\n                  \n    return r/(PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    \n    const int size = 24;\n                \n    float ar = iResolution.x / iResolution.y;\n    \n    px.y /= ar;\n    \n    vec2 pos = px-vec2(0.5, 0.5/ar);\n    \n    float len = length(pos);\n    \n\tvec3 color = vec3(0,0,0);\n    \n    float rep = 1.;\n    \n    float delta = rewrap(atan(pos.x, pos.y), rep);\n        \n    float div = 500./float(size);\n    \n    float modifier = sin(iTime*0.15);\n    \n    float index = float(int(mod(iTime*0.+delta+modifier, 3.0) * 100. / div));\n    \n\tfloat f = texelFetch(iChannel0, ivec2(index/float(size)*256.,0.1), 0).x;\n    \n    float base = texelFetch(iChannel0, ivec2(1.*256.,0.1), 0).x;\n    \n    float cpi = smoothstep((0.1 + base*0.05), 0.15 + f * 0.01, len);\n       \n\tif (len < 0.13 + f * 0.13 && len > (0.1 + base*0.001) && mod(delta + modifier, 1./float(size)) < 0.038 && (delta) > 0.0)\n\t\tcolor = vec3(0.95-delta, delta*0.1, delta);\n    \n    color *= cpi;\n    \n    if (len < 0.1 + base * 0.06 && len > 0.09 + base * 0.03)\n      color = vec3(1,1,1);\n    \n    float eq = texelFetch(iChannel0, ivec2(px.x*128.,1), 0).x;\n        \n    if (abs(px.y*ar-0.54+eq*0.1) < 0.01 && \n        px.x > 0.5-(0.1+base * 0.05-1.08) &&\n        px.x < 0.5+(0.1+base * 0.05-0.02)) {\n        color = vec3(1);\n    }\n    \n\tfragColor = vec4(color, 0.1);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 171], [173, 173, 230, 230, 1545]], "test": "error"}
{"id": "Nt3GzX", "name": "Path of the shader - 2.", "author": "SOMATICBITS", "description": "2. shader on the path to learning shaders.", "tags": ["somaticbits"], "likes": 1, "viewed": 33, "published": "Public", "date": "1636474031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat circle(vec2 uv) {\n    return length(uv);\n}\n\nfloat ss(float s, float size) {\n    float w = fwidth(s);\n    return smoothstep(size+w,size-w,s);\n}\n\nfloat concentricCircles(vec2 uv, vec2 center, float thickness, float phase, vec2 id) {\n    return ss(cos((distance(uv, vec2(center))/(thickness*length(id))*5.)+phase),thickness);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n   \n    uv *= 5.;\n    uv += .5;\n    vec2 guv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    vec3 col = clamp(vec3(concentricCircles(guv, vec2(0.), 0.05, iTime, id),0.,0.),0.,1.);\n    col -= ((length(id)*.1))*2.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 68], [70, 70, 93, 93, 118], [120, 120, 151, 151, 218], [220, 220, 306, 306, 400], [403, 403, 460, 460, 804]], "test": "valid"}
{"id": "Ntc3R7", "name": "Raymarching with Dithering", "author": "AJFarmar", "description": "A simple raymarcher with multiple materials, each of which is dithered in a different way.", "tags": ["raymarching", "sdf", "shader", "dithering", "signeddistance", "onebit"], "likes": 11, "viewed": 117, "published": "Public", "date": "1635848702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* This defines what stage of the process we show.\n * Uncomment/recomment different ones to see different parts.\n */\n//#define SHOW_ID\n//#define SHOW_DEPTH\n//#define SHOW_NORMAL\n//#define SHOW_BRIGHTNESS\n#define SHOW_DITHER\n//#define PIXELLATE\n\n// Determines the size of the dither \"pixels\".\n#define SQUARE_SIZE (2)\n\n// Firstly, we define all the usual raymarching necessities.\nconst int   MAX_MARCH = 1024; // The number of steps after which we stop marching.\nconst int   MAX_LIGHT_MARCH = 256; // The number of steps after which we stop calculating shadows.\nconst float CLOSE     = 0.00005; // \"Close enough\" distance. Arbitrary here.\nconst float FAR       = 5.0; // \"Far enough\" distance. Arbitrary here.\nconst float PI = 3.1415926535897; // Just useful.\n\n// Sunlight. We'll change this eventually.\nconst vec3 SUNLIGHT = vec3(0.4, -1.0, 1.3)/1.6881943;\n\n/* We track the maximum number of objects in the scene.\n * We could do way more than 16, but it really doesn't matter.\n * This will just be used to keep track of the IDs of objects.\n */\n#define MAX_OBJECTS (4)\n\n// Now we define some signed distance functions, with ADDITIONAL PARAMETERS!\nstruct SDFData\n{\n    float dist;\n    int id;\n    vec3 normal;\n};\n/* These parameters will become important in future layers, since we will use\n * the same scene definition multiple times.\n */\n#define SPHERE(center, radius, id, v) (SDFData( distance(v,center) - radius, id, normalize(v-center) ))\n#define SOLIDPLANE(point, normal, id, v) (SDFData( dot(v-point, normal), id, normal ))\nSDFData UNION(SDFData sdf1, SDFData sdf2)\n{\n    if (sdf1.dist <= sdf2.dist)\n        return sdf1;\n    return sdf2;\n}\nSDFData INTERSECTION(SDFData sdf1, SDFData sdf2)\n{\n    if (sdf1.dist <= sdf2.dist)\n        return sdf2;\n    return sdf1;\n}\n\n// Objects' information in the scene.\nstruct ObjectInfo {\n    int ditherer;\n};\n\n// We record the object information for each object.\nconst ObjectInfo objectList[MAX_OBJECTS] = ObjectInfo[MAX_OBJECTS](\n    ObjectInfo(2),\n    ObjectInfo(0),\n    ObjectInfo(2),\n    ObjectInfo(0)\n);\n\n// The scene. Outputs the object ID as well as the distance and the normal.\nSDFData sceneSDF(vec3 v)\n{\n    // We will have a sphere and a cube lying on a flat plane, each a different object.\n    return UNION(UNION(UNION(\n    // First object: the plane.\n        SOLIDPLANE(vec3(0.0), vec3(0.0, 1.0, 0.0), 1, v)\n    ,\n    // Second object: the sphere.\n        SPHERE(vec3(1.2, 0.4, -0.1), 0.4, 2, v)\n    ),\n    // Third object: the smaller sphere.\n        SPHERE(vec3(0.1, 0.2, -0.75), 0.2, 3, v)\n    ),\n    // Fourth object: the cube with rounded corners.\n        // To build a cube, we intersect 6 solid planes. This will get a bit messy!\n        INTERSECTION(INTERSECTION(INTERSECTION(\n        // X sides\n            INTERSECTION(\n                SOLIDPLANE(vec3(0.5, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 4, v),\n                SOLIDPLANE(vec3(-0.5, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), 4, v)\n            )\n        ,\n        // Y sides\n            INTERSECTION(\n                SOLIDPLANE(vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 4, v),\n                SOLIDPLANE(vec3(0.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0), 4, v)\n            )\n        ),\n        // Z sides\n            INTERSECTION(\n                SOLIDPLANE(vec3(0.0, 0.0, 0.5), vec3(0.0, 0.0, 1.0), 4, v),\n                SOLIDPLANE(vec3(0.0, 0.0, -0.5), vec3(0.0, 0.0, -1.0), 4, v)\n            )\n        ),\n        // We intersect a cube with a sphere to round the corners.\n            SPHERE(vec3(0.0, 0.5, 0.0), 0.75, 4, v)\n        )\n    );\n}\n\n// Different dithering methods\nfloat calculateDither(vec2 coord, float brightness, int dithererID) {\n    float ditherTexture;\n    if (dithererID == 1) {\n        ditherTexture = texture(iChannel1, coord/256.0).x;\n    } else if (dithererID == 2) {\n        ditherTexture = texture(iChannel2, coord/1024.0).x;\n    } else if (dithererID == 3) {\n        ditherTexture = texture(iChannel2, coord/1024.0).z;\n    } else {\n        ditherTexture = texture(iChannel0, coord/8.0).x;\n    }\n\n    return step(ditherTexture+0.001, brightness);\n}\n\n// The result of raymarching\nstruct RayMarch {\n    float depth; // How far away from the camera are we?\n    int id;      // Which object have we hit?\n    vec3 normal; // What's the normal to this surface?\n    float light; // Does this object recieve direct light?\n};\n\n// The raymarching algorithm!\nRayMarch raymarch(mat4 camera, vec2 relCoord)\n{\n\n    // Calculate the position of the eye.\n    vec4 eye_homog = camera * vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 eye = eye_homog.xyz / eye_homog.w;\n    \n    // Calculate the direction that we'll be looking in.\n    vec4 offsetRay_homog = camera * vec4(relCoord, 1.0, 1.0);\n    vec3 ray = normalize((offsetRay_homog.xyz/offsetRay_homog.w) - eye);\n    \n    // We begin raymarching -- yippee!\n    int steps = 0;\n    vec3 v = eye;\n    float totalDist = 0.0;\n    bool shouldContinue = true;\n    SDFData depthInfo;\n    do {\n        depthInfo = sceneSDF(v);\n        v += depthInfo.dist * ray;\n        totalDist += depthInfo.dist;\n        steps += 1;\n        shouldContinue =\n            abs(depthInfo.dist) >= CLOSE\n         && depthInfo.dist <= FAR\n         && steps <= MAX_MARCH;\n    } while (shouldContinue);\n    \n    // What if we're just looking at the sky?\n    if (steps >= MAX_MARCH || depthInfo.dist >= FAR)\n        // For now, ignore the normal vector for the sky.\n         return RayMarch(0.0, 0, vec3(0.0), 0.0);\n         \n    // Now, we do reflection by raymarching AGAIN.\n    // TODO: make this dependent on the material of the object.\n    ray = -SUNLIGHT;\n    v += (1.001)*CLOSE*depthInfo.normal;\n    steps = 0;\n    shouldContinue = true;\n    float dist;\n    do {\n        dist = sceneSDF(v).dist;\n        v += dist * ray;\n        steps += 1;\n        shouldContinue =\n            dist >= CLOSE\n         && dist <= FAR\n         && steps <= MAX_LIGHT_MARCH;\n    } while (shouldContinue);\n    \n    \n    // If we're really looking at an object.\n    return RayMarch(totalDist, depthInfo.id, depthInfo.normal, step(CLOSE, dist));\n}\n\n// Calculates the brightness of a point.\nfloat calculateBrightness(RayMarch info, vec3 gaze)\n{\n    float diffusion = dot(-SUNLIGHT, info.normal);\n    const float diffuse = 0.7;\n    \n    float speculation = abs(dot(SUNLIGHT, reflect(normalize(gaze), info.normal)));\n    speculation = clamp(speculation, 0.0, 1.0);\n    speculation = pow(speculation, 6.0);\n    const float specular = 0.7;\n    \n    float brightness = diffusion*diffuse + speculation*specular;\n    brightness = clamp(brightness, 0.0, 1.0);\n    brightness *= info.light;\n    return brightness;\n}\n\n// View matrix calculation.\nmat4 viewMatrix(vec3 eye, vec3 gaze, vec3 up)\n{\n    // By Jamie Wong, based on the gluLookAt man page.\n    // Lightly edited.\n    vec3 f = normalize(gaze);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(f, 0.0),\n        vec4(eye, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord;\n    #if defined(PIXELLATE) || defined(SHOW_DITHER)\n        vec2 sqCoord = floor(fragCoord/float(SQUARE_SIZE));\n        coord = float(SQUARE_SIZE)*sqCoord;\n    #else\n        coord = fragCoord;\n    #endif\n\n    // We get the signed distance info.\n    vec2 relCoord = (coord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(2.1 + 0.5*cos(iTime/1.5), 0.8 + 0.4*cos(iTime/1.5), -1.8+0.8*cos(iTime/1.5));\n    mat4 view = viewMatrix(\n        eye,\n        vec3(0.3 + 0.1*sin(iTime/2.0), 0.5 + 0.1*cos(iTime/2.0), 0.0) - eye,\n        vec3(0.0, 1.0, 0.0));\n    RayMarch distinfo = raymarch(view, relCoord);\n    ObjectInfo objinfo = objectList[distinfo.id-1];\n    \n    // Brightness\n    float brightness = calculateBrightness(distinfo, eye);\n    \n    // The various different layers of information\n    #if defined(SHOW_ID)\n        float colorAngle = 2.0 * PI * float(distinfo.id) / float(MAX_OBJECTS);\n        vec2 colorVector = vec2(cos(colorAngle), sin(colorAngle));\n        vec2 rV, gV, bV;\n        rV = vec2(1.0, 0.0);\n        gV = vec2(cos(2.0*PI/3.0), sin(2.0*PI/3.0));\n        bV = vec2(cos(-2.0*PI/3.0), sin(-2.0*PI/3.0));\n        vec3 idColor =\n              dot(colorVector, rV)*vec3(1.0,0.0,0.0)\n            + dot(colorVector, gV)*vec3(0.0,1.0,0.0)\n            + dot(colorVector, bV)*vec3(1.0,0.0,1.0);\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(0.5) + 0.5*idColor, 1.0);\n    #elif defined(SHOW_DEPTH)\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(1.0 - distinfo.dist/FAR), 1.0);\n    #elif defined(SHOW_NORMAL)\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(0.5 + 0.5*distinfo.normal, 1.0);\n    #elif defined(SHOW_BRIGHTNESS)\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(brightness), 1.0);\n    #elif defined(SHOW_DITHER)\n        float dither = calculateDither(sqCoord, brightness, objinfo.ditherer);\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(dither), 1.0);\n    #endif\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1528, 1528, 1571, 1571, 1643], [1644, 1644, 1694, 1694, 1766], [2048, 2124, 2150, 2238, 3539], [3541, 3572, 3641, 3641, 4069], [4339, 4369, 4416, 4459, 6042], [6044, 6085, 6138, 6138, 6600], [6602, 6630, 6677, 6755, 6962], [6964, 6964, 7021, 7021, 9191]], "test": "error"}
{"id": "Ntc3Rs", "name": "basic stairs 2d", "author": "jorge2017a2", "description": "basic stairs 2d", "tags": ["basicstairs2d"], "likes": 1, "viewed": 99, "published": "Public API", "date": "1636511910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//jorge2017a2\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.015,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvec3 EscaleraV2(vec2 p, vec3 colOut, vec3 colIn)\n{\n    float d1;\n    float d=99999.0;\n    \n    int y;\n    p.y-=0.8;\n    p.x+=1.5;\n    \n    float AnchoTot=1.0;\n    float AltoTot=0.8;\n    float NumEs=8.0;\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n      d1=sdBox(p-vec2( posx,posy), vec2(AnchoEs,AltoEs) ) ;\n      d=min(d,d1);\n    \n     }   \n    \n    //colOut= DrawFig(colIn, colOut, d);\n    colOut=DrawFigBorde(colIn, colOut, d);\n     \n    return colOut;\n}\n\nvec3 EscaleraLargo(vec2 p, vec3 colOut, vec3 colIn)\n{\n    float d1;\n    float d=99999.0;\n    \n    int y;\n    p.y-=0.8;\n    p.x+=1.5;\n    \n    float AnchoTot=1.0;\n    float AltoTot=0.8;\n    float NumEs=4.0;\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    float AltoEsNew;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n         \n      AltoEsNew=AltoTot-( float(i)- 1.0)*AltoEs ;\n      d1=sdBox(p-vec2( posx,posy-AltoEsNew), vec2(AnchoEs,AltoEs/NumEs+AltoEsNew) );\n            d=min(d,d1);\n     }   \n    \n    colOut= DrawFig(colIn, colOut, d);\n     \n    return colOut;\n}\n\n\n\n\nvec3 EscaleraTorre(vec2 p, vec3 colOut, vec3 colIn, int PNumEs)\n{\n    float d1;\n    float d=99999.0;\n    \n    int y;\n    p.y-=0.8;\n    p.x+=1.5;\n    \n    float AnchoTot=1.0;\n    float AltoTot=0.8;\n    float NumEs=float(PNumEs);\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    float AltoEsNew;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n        \n      AltoEsNew=AltoTot-( float(i)- 1.0)*AltoEs ;\n       d1=sdBox(p-vec2( posx,posy/2.0-AltoEsNew), vec2(AnchoEs,AltoEs+AltoEsNew) );\n        d=min(d,d1);\n\n     }   \n    \n    //colOut=DrawFig(colIn, colOut, d);\n    colOut=DrawFigBorde(colIn, colOut, d);\n    \n    return colOut;\n}\n\n\nvec3 Suelo1(vec2 p, vec3 col)\n{\n    col=DrawFig(vec3(0.75,0.35,0.2), col, p.y-0.5 );\n return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv.y*=3.0;\n    \n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.45;\n    uv.x=uv.x+iTime;\n    \n    float px=mod(uv.x, 14.0);\n    uv.x=px;\n    \n    \n    col= Suelo1(uv,col);\n    if( uv.x<3.0)\n    {\n        col= EscaleraLargo(uv-vec2(2.0,-0.8),col, vec3(0.0));\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.2,1.2), col, vec3(0.5,0.2,0.0),4);\n        col= EscaleraV2(vec2(uv.y, uv.x)-vec2(1.0,1.5), col, vec3(1.0,0.2,0.0));\n    }\n    else\n    {\n      \n      col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(0.9,4.2), col, vec3(0.7,0.6,0.2),6);\n      col= EscaleraLargo(uv-vec2(5.,-0.9),col, vec3(0.7,0.5,0.6));\n    }\n    \n    \n    if( uv.x>5.0)\n    {\n        col= EscaleraLargo(vec2(-uv.x,uv.y)-vec2(-6.5,-0.8),col, vec3(0.0));\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.0,7.5), col, vec3(0.5,0.3,0.0),6);\n    }\n    \n     if( uv.x>7.5)\n    {\n        col= EscaleraLargo(vec2(-uv.x,uv.y)-vec2(-8.5,-0.8),col, vec3(0.0));\n        col= EscaleraLargo(vec2(-uv.x,uv.y)-vec2(-10.5,-0.8),col, vec3(0.0));\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.0,9.5), col, vec3(0.5,0.2,0.0),4);\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.5,11.5), col, vec3(0.5,0.2,0.5),7);\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 301, 301, 396], [398, 429, 465, 465, 510], [515, 559, 606, 606, 633], [634, 634, 677, 677, 704], [705, 705, 753, 753, 781], [787, 787, 849, 849, 981], [983, 983, 1064, 1064, 1194], [1196, 1196, 1253, 1253, 1319], [1321, 1321, 1358, 1358, 1438], [1441, 1441, 1491, 1491, 2053], [3477, 3477, 3508, 3508, 3576], [3578, 3578, 3635, 3635, 4969]], "test": "valid"}
{"id": "Ntc3zj", "name": "#WorldTessellationDay 2021", "author": "cmarangu", "description": "It is not world tessellation day today (2021 November 7th). I am releasing the code on shadertoy because I am bored.\n[url]https://twitter.com/C010011012/status/1405775912277188608[/url]\n[url]https://www.instagram.com/p/CQQHrwgjtaU/[/url]", "tags": ["tessellation"], "likes": 4, "viewed": 117, "published": "Public API", "date": "1636340209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Current Code For: #WorldTessellationDay 2021\n// Date: 2021 June 17th\n// Tags: tessellation\n// Description: https://twitter.com/C010011012/status/1405775912277188608\n// https://www.instagram.com/p/CQQHrwgjtaU/\n\n\n// ↓ i know more\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307\n// 816406286 208998628034 8253421170679821480865132823066470938446095505\n#define TAU 6.2831853071795864\n\n// frequency in THz\n#define freqr 430.\n#define freqg 545.\n#define freqb 660.\n\n// samples per frame - each output frame = spf sample-frames blended together equally\n//#define spf 1.\n//const float spf = 30.*1.;\nconst float spf = 1.*1.;\n\n#define iFramef floor(float(iFrame) /spf)\n#define iFramem   mod(float(iFrame), spf)\n\n#define arg mod(  iFramef  /30./1., 1.)\n\n// frameblending version\n//#define arg mod(  float(iFrame)/spf  /30./1., 1.)\n\n// for testing porpoises - will blend all the animations frames\n// e.g. if the animation is a rotating cube the output should look like a blurry cylinder\n// try set spf=3 or 4 and pausing the animation to see how all frames blended equally\n//#define arg ( iFramem/spf )\n\n//\n// sky map\n//\n\n//#define inter_sky vec4(vec3(0.), 1e9)\nconst vec4 inter_sky = vec4(vec3(0.), 1e9);\nfloat sky_map (in float freq, in vec3 d) {\n    #if 0\n    vec3 col = texture(iChannel2, d).rgb;\n    #elif 1\n        vec3 col = vec3(1.);\n        col = vec3(0.);\n    #elif 0\n    vec3 col = vec3(.7, 1., 1.);\n    #else\n    vec3 col = vec3(0., 0., 100./255.);\n    #endif\n    //\n    if (freq == freqr) {\n        return col.r;\n    }\n    else if (freq == freqg) {\n        return col.g;\n    }\n    else if (freq == freqb) {\n        return col.b;\n    }\n}\n\n\n\n\n//\n// intersect primitive shapes\n//\nvec4 inter_sphere (vec3 p, vec3 d, float r) {\n\tfloat bsign = length(p) > r ? -1. : 1.;\n\tvec3 bar = -p;\n\tfloat h = length(bar);\n\tfloat a = h*dot(normalize(bar), d);\n\tfloat o = sqrt(h*h-a*a);\n\tif (dot(d, bar) > 0. && o <= r) {\n\t\tfloat bevel = sqrt(r*r-o*o);\n\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\treturn vec4(\n\t\t\tnormalize(hitp)*-bsign,\n\t\t\ta+bsign*bevel\n\t\t);\n\t}\n\treturn inter_sky;\n}\n// plane - one liner lol\n// #define SDF_plane(p, n) ( dot(normalize(p), n)*length(p) )\nfloat SDF_plane (vec3 p, vec3 n) { return dot(normalize(p), n)*length(p); }\n#define inter_plane_short(p, d, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, n) (\\\n//dot(n, d) > 1e-6 ? dot(-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n//\n// SDF\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.48), 0.) )-.015)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n#define inf vec2(1e-4, 0.)\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // test\n    //return inter_sphere(p, d, 1.);\n    //\n    // camp is unmodified p\n    vec3 camp = p;\n    //\n    #if 0\n    // space skip to sphere (.5, .5, .5) r=1.8 (causes bug)\n    vec4 temp;\n    temp = inter_sphere(p-vec3(.5), d, 1.8);\n    if (temp.w >= inter_sky.w) {\n        return inter_sky;\n    }\n    else {\n        if (length(p-vec3(.5)) > 1.8) {\n            p += d*temp.w;\n        }\n    }\n    //return temp;\n    #endif\n    //\n    //\n    float SDFp;\n    //for (int i=0; i<111222; ++i) {\n    //for (int i=0; i<11222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        //if (abs(SDFp) < 1e-1) {\n        if (abs(SDFp) < 5e-4) {\n            return vec4(\n                normalize(\\\n                    vec3(\n                        SDF(p+inf.xyy),\n                        SDF(p+inf.yxy),\n                        SDF(p+inf.yyx)\n                    )-SDFp\n                )*sign(SDFp),\n                length(p-camp)\n            );\n        }\n        p += d*abs(SDFp)*.5;\n        //p += d*abs(SDFp)*.99;\n        //p += d*abs(SDFp);\n        //if (abs(SDFp) > 10.) {\n        // sqrt(3) ~ 1.732\n        if (abs(SDFp) > 1.8) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 16., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    pane1n = normalize(vec3(1., 10., 6.));\n    //pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p-pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p-pane1c, d, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p-pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        blockhere = qf.x*0.+qf.y*10.+qf.z*10. <= 0.;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\n\n\n\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    // mouse pos normalized -1 to 1 y aspect ratio x\n    //\n    vec2 maus = (iMouse.xy-iResolution.xy/2.)/(iResolution.y/2.);\n    //\n    //\n    // view rotation matrices\n    //\n    //#define phi clamp(maus.y*3., -1., 1.)*PI*.5\n    #define phi -atan(1./sqrt(2.) )\n    mat2 zenith = transpose(\n        mat2(\n            cos(phi), cos(PI*.5+phi),\n            sin(phi), sin(PI*.5+phi)\n        )\n    );\n    //#define theta maus.x*TAU\n    #define theta -PI*.75\n    mat2 azimuth = transpose(\n        mat2(\n            cos(theta), cos(PI*.5+theta),\n            sin(theta), sin(PI*.5+theta)\n        )\n    );\n    //\n    //\n    // multisampling loop\n    //\n    fragColor = vec4(0., 0., 0., 1.);\n    // spw - width of multisample grid\n    // spp - number of random jitter/monte carlo integration per sub-pixel thing\n    #define spw 1.\n    #define spp 1.\n    float freq, ox, oy; vec3 rand;\n    //\n    #define numsamples spw*spw*spp\n    for (float samplei=0.; samplei<3.*numsamples; ++samplei) {\n        float samplei2 = samplei;\n        if (mod(samplei, 3.) == 0.) {\n            freq = freqr;\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            freq = freqg;\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            freq = freqb;\n        }\n        samplei2 = floor(samplei2/3.);\n        ox = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        oy = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        samplei2 += (float(iFrame)+fragCoord.x)*numsamples;\n        rand = vec3(\n            fract(\n                sin(\n                    mod(\n                        samplei2*1.234567890123,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*10.110010101,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*222.222222222,\n                        TAU\n                    )\n                )\n            )\n        );\n        #if 1\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.);\n        #else\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.)*vec2(1., -1.);\n        #endif\n        //\n        //\n        float retina = 0.;\n        float absorb = 1.;\n        //\n        #if 0\n        // perspective\n        vec3 p = vec3(screen.x, screen.y, 0.);\n        vec3 d = normalize(p-vec3(0., 0., -1.));\n        //vec3 p = vec3(0.);\n        //vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n        #else\n        // orthogonal\n        vec3 p = vec3(screen.x, screen.y, 0.)*4.*(sqrt(2.)/2.);///cos(30.*PI/180.);\n        vec3 d = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        p += vec3(0., 0., -12.);\n        //\n        p.zy = zenith*p.zy;\n        d.zy = zenith*d.zy;\n        p.zx = azimuth*p.zx;\n        d.zx = azimuth*d.zx;\n        //\n        d = normalize(d);\n        //p += vec3(0., 2., 0.);\n        //p -= d*20.;\n        //\n        //\n        //\n        //#define numbounces 50.\n        #define numbounces 3.\n        for (float bounces=0.; bounces<numbounces; ++bounces) {\n        //for (float bounces=0.; bounces<1.; ++bounces) {\n            //\n            if (absorb <= .1) {\n                break;\n            }\n            //\n            float samplei3 = bounces;\n            samplei3 += (float(iFrame)+fragCoord.x)*numbounces;\n            //\n            vec3 rand2 = vec3(\n                fract(\n                    sin(\n                        mod(\n                            samplei3*1.234567890123,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*10.110010101,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*222.222222222,\n                            TAU\n                        )\n                    )\n                )\n            );\n            //\n            vec4 inter_closest = inter_sky;\n            vec4 inter_current;\n            float inter_id;\n            //\n            //#define sphc vec3(cos(arg*TAU), 2.+sin(arg*TAU), 0.)\n            #define tempc vec3(0., 6., 0.)\n            #define tempr 1.\n            //inter_current = inter_sphere(p-tempc, d, tempr);\n            inter_current = inter_sky;\n            //inter_current = inter_SDF(p, d);\n            //inter_current = inter_sky;\n            vec3 tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 1.;\n                 if (length(p-tempc)-tempr < 0.) {\n                //if (SDF(p) < 0.) {\n                    // p is inside sphere - p hits inner shell\n                    inter_id *= -1.;\n                }\n            }\n            #undef tempc\n            #undef tempn\n            //\n            #define tempc vec3(0., -1.1, 0.)\n            #define tempn normalize(vec3(0., 1., 0.))\n            //inter_current = inter_plane(p-tempc, d, tempn );\n            inter_current = inter_minecraft(p, d);\n            tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 2.;\n                //inter_id = blocktyp(floor(tempp))+1.;\n                //inter_id *= sign(SDF_plane(p-tempc, tempn ));\n                inter_id *= sign( SDF(fract(tempp)) );\n            }\n            #undef tempc\n            #undef tempn\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // too far - hits sky\n                break;\n            }\n            else {\n                p += d*inter_closest.w;\n                //\n                //\n                //\n                //\n                //if (abs(inter_id) == 1.) {}\n                //if (abs(inter_id) == 2.) {\n                if (abs(inter_id) == 1.) {\n                    // hits sphere\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    TEXp = vec3(1.);\n                    #if 0\n                    #define temp 1.\n                    TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 1\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #endif\n                    //\n                    // environment light\n                    //\n                    if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    }\n                    else if (abs(inter_id) == 4.) {\n                        d = reflect(d, inter_closest.xyz);\n                    }\n                    #if 0\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 1\n                    // specular refraction\n                    // air 1.0\n                    // water 1.333\n                    // glass 1.458\n                    // diamond 2.417\n                    float eta = 1.01;\n                    eta = 10.7;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n                else if (abs(inter_id) != 1.) {\n                    //\n                    // hits plane\n                    //\n                    //implement brdf\n                    //implement different inter_id based on blocktyp(floor(p))\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    //TEXp = vec3(1.);\n                    TEXp = mix(vec3(0., 1., 1.), vec3(0., 0., 1.), fract(p).y)*.5;\n                    if (abs(fract(p).y-.5) > .48) {\n                        TEXp = vec3(.0, .0, .0);\n                    }\n                    else if (abs(fract(p).x-.5) > .48) {\n                        TEXp = vec3(.0, .9, .9);\n                    }\n                    else {\n                        TEXp = vec3(.0, .7, .7);\n                    }\n                    if (abs(fract(p).y-.5) < .48) {\n                        TEXp = mix(TEXp, vec3(0., 0., .9), fract(p.y));\n                    }\n                    else {\n                        /*TEXp += .2*pow(.5+.5*sin( (p.x*4.+\n                            (.5+.5*sin(p.z*TAU))\n                        )*TAU ), 4.);*/\n                        #if 1\n                        #define temp 1.\n                        //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                        if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                            TEXp += .25;\n                        }\n                        #endif\n                    }\n                    //\n                    #if 0\n                    #define temp 1.\n                    //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                        TEXp *= .5;\n                    }\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 0\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #else\n                    \n                    if (freq == freqr) {\n                        retina += absorb*TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        retina += absorb*TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        retina += absorb*TEXp.b;\n                    }\n                    //absorb *= 0.;\n                    #endif\n                    //\n                    // environment light\n                    //\n                    absorb *= .4;\n                    //if (abs(inter_id) == 2.) {\n                        //absorb *= 0.;\n                    //}\n                    //else if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    //}\n                    /*#if 1\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 0\n                    // specular refraction\n                    float eta = 1.01;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    */\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n            }\n            //\n        }\n        //\n        retina += absorb*sky_map(freq, d);\n        if (mod(samplei, 3.) == 0.) {\n            fragColor.rgb += retina*vec3(1., 0., 0.);\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            fragColor.rgb += retina*vec3(0., 1., 0.);\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            fragColor.rgb += retina*vec3(0., 0., 1.);\n        }\n    }\n    fragColor.rgb /= 1.*spw*spw*spp;\n    //\n    // blend with past n frames\n    //\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1230, 1230, 1272, 1272, 1673], [1678, 1714, 1759, 1759, 2092], [2093, 2180, 2214, 2214, 2255], [2362, 2458, 2501, 2501, 2821], [3219, 3219, 3252, 3336, 4504], [4505, 4505, 4544, 4582, 7792]], "test": "error"}
{"id": "Ntd3DB", "name": "black holes - acid", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 13, "viewed": 207, "published": "Public API", "date": "1636653017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"black holes\" by morisil. https://shadertoy.com/view/Nlt3DB\n// 2021-11-11 17:50:05\n\n// Fork of \"depth of field focus study 4\" by morisil. https://shadertoy.com/view/stdGzf\n// 2021-11-11 17:35:53\n\n// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-09 22:06:23\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur, in float shapeSize) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(shapeSize + blur, shapeSize - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6 + st.x + st.y) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    st *= log(length(sin(st * 5.18)) * cos(iTime * .1) + 1.2) * 5.;\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    float shapeSize = .2 + (sin(iTime * .7) + 1.) * .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3)) * 2.;\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur, shapeSize),\n            getColorComponent(center, modScale, blur, shapeSize),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur, shapeSize)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[643, 643, 671, 671, 757], [760, 760, 851, 851, 1085], [1087, 1087, 1142, 1142, 2294]], "test": "valid"}
{"id": "Ntd3Ds", "name": "DECOY Waves", "author": "u7i", "description": "Proof-of-Work shader", "tags": ["pow"], "likes": 2, "viewed": 35, "published": "Public", "date": "1636975494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lerp(vec3 a, vec3 b, float alpha) {\n    return a*(1.0 - alpha) + b*alpha;\n}\n\nfloat normalizedDistance(vec2 p1, vec2 p2, float hwRatio) {\n    // Fix normalized coords\n    p1.y *= hwRatio;\n    p2.y *= hwRatio;\n    \n    return sqrt(pow(p1.x - p2.x, 2.0) + pow(p1.y - p2.y, 2.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 source = vec2(0.8, 0.8);\n    float wavesNum = 4.0;\n    \n    float animationSpeed = 0.05;\n    \n    vec3 startColor = vec3(0.0, 0.0, 0.0);\n    vec3 endColor = vec3(1.0, 0.528, 0.0);\n    \n    bool directionFromSource = true;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 resolution = iResolution.xy;\n    \n    float hwRatio = resolution.y / resolution.x;\n    \n    // Generate waves\n    float dist = normalizedDistance(source, uv, hwRatio);\n    float space = (1.0 - max(source.x, source.y)) / wavesNum;\n    float animCoof = iTime * animationSpeed;\n    float wave = mod(dist - animCoof, space) / space; \n    \n    // Invert wave if needed\n    if (directionFromSource) wave = 1.0 - wave;\n    \n    // Convert wave height to a color\n    vec3 col = lerp(endColor, startColor, wave);\n    \n    // Get strength ( from distance to the source )\n    float strength = 1.0 - dist;\n    col *= strength;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 80], [82, 82, 141, 170, 283], [286, 286, 343, 343, 1357]], "test": "valid"}
{"id": "Ntd3DX", "name": "Pyramid SDF", "author": "TheTurk", "description": "Distance function for a pyramid with a rectangular base, a special case of a truncated pyramid [url]https://www.shadertoy.com/view/NsKSDc[/url]. ", "tags": ["3d", "distancefield", "sdf", "distance", "pyramid", "primitive"], "likes": 2, "viewed": 42, "published": "Public", "date": "1636845547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pyramid(vec3 position, float halfWidth, float halfDepth, float halfHeight) {\n    position.xz = abs(position.xz);\n    \n    // bottom\n    float s1 = abs(position.y) - halfHeight;\n    vec3 base = vec3(max(position.x - halfWidth, 0.0), abs(position.y + halfHeight), max(position.z - halfDepth, 0.0));\n    float d1 = dot(base, base);\n   \n    vec3 q = position - vec3(halfWidth, -halfHeight, halfDepth);\n    vec3 end = vec3(-halfWidth, 2.0 * halfHeight, -halfDepth);\n    vec3 segment = q - end * clamp(dot(q, end) / dot(end, end), 0.0, 1.0);\n    float d = dot(segment, segment);\n   \n    // side\n    vec3 normal1 = vec3(end.y, -end.x, 0.0);\n    float s2 = dot(q.xy, normal1.xy);\n    float d2 = d;\n    if (dot(q.xy, -end.xy) < 0.0 && dot(q, cross(normal1, end)) < 0.0) { \n        d2 = s2 * s2 / dot(normal1.xy, normal1.xy);\n    }\n    // front/back\n    vec3 normal2 = vec3(0.0, -end.z, end.y);\n    float s3 = dot(q.yz, normal2.yz);\n    float d3 = d;\n    if (dot(q.yz, -end.yz) < 0.0 && dot(q, cross(normal2, -end)) < 0.0) { \n        d3 = s3 * s3 / dot(normal2.yz, normal2.yz);\n    }\n    return sqrt(min(min(d1, d2), d3)) * sign(max(max(s1, s2), s3));\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nfloat sdf(in vec3 position) { \n    float cornerRadius = 0.01;\n    float halfWidth = 0.35; \n    float halfDepth = 0.35;\n    float halfHeight = 0.25;\n    float d = pyramid(position, halfWidth, halfDepth, halfHeight);\n    d -= cornerRadius;\n    return d;\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 6.0);\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 82, 82, 1149], [1151, 1151, 1190, 1190, 1372], [1374, 1374, 1403, 1403, 1627], [1629, 1629, 1657, 1657, 2002], [2004, 2004, 2054, 2054, 2436], [2438, 2438, 2493, 2493, 3999]], "test": "valid"}
{"id": "Ntd3R2", "name": "Wind Farm", "author": "dr2", "description": "Endless free energy... (mouseable)", "tags": ["symmetry", "seascape", "windmill", "propeller"], "likes": 20, "viewed": 195, "published": "Public API", "date": "1636367157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Wind Farm\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_BOAT 2\n\nmat3 boatMat[N_BOAT];\nvec3 boatPos[N_BOAT], sunDir, qHit;\nvec2 gId, gShift, csMilAx, csBldAng, csBldPch;\nfloat dstFar, tCur, hgSize, boatAng[N_BOAT], boatSz, milSz;\nint idObj, idObjGrp;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (7. * cos (0.06 * t) + 0.1 * t, 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (-0.06 * 7. * sin (0.06 * t) + 0.1, 0., 1.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, s;\n  h = Fbm2 (0.5 * p) - 0.45;\n  s = 1. - abs (p.x - TrackPath (p.y).x) / 2.5;\n  if (s > 0.) h = max (h - s * s, -0.5);\n  return h;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  float h;\n  h = GrndHt (p);\n  if (h > 0.) h = 0.3 * h + 0.3 * Fbm2 (2. * p);\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.001, 0.);\n  return normalize (vec3 (GrndHtN (p.xz) - vec2 (GrndHtN (p.xz + e.xy),\n     GrndHtN (p.xz + e.yx)), e.x)).xzy;\n}\n\nvoid SetMilParms ()\n{\n  vec2 g, w, cs0;\n  g = HexToPix (gId * hgSize);\n  if (GrndHt (g) < 0. || Hashfv2 (37. * gId + 1.1) < 0.15) milSz = 0.;\n  else {\n    milSz = 0.18 * hgSize * 0.5 * sqrt3 * (1. - 0.1 * Hashfv2 (17. * gId + 1.1));\n    w = Hashv2v2 (73. * gId + 1.1);\n    cs0 = vec2 (0.5 * pi, 0.);\n    gShift = hgSize * max (0., 0.1 * sqrt3 - milSz) * w.x * sin (2. * pi * w.y + cs0);\n    csBldAng = sin (0.2 * (0.2 + w.x) * pi * (tCur + 10.) + cs0);\n    csMilAx = sin (0.2 * pi * sin (0.1 * pi * tCur) + 0.2 * pi * w.y + 0.01 * pi * tCur + cs0);\n    csBldPch = sin ((0.15 + 0.2 * w.x) * pi + cs0);\n  }\n}\n\nfloat BladeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 b;\n  float d, bLen, bxMax;\n  bLen = 4.;\n  bxMax = 2.;\n  q = p;\n  q.x += 0.3;\n  d = PrRoundCylDf (q.yzx, 0.25, 0.05, 0.25);\n  DMINQ (2);\n  q.zy = Rot2Cs (q.zy, csBldPch);\n  q.xz += vec2 (bLen + 0.2, -0.03);\n  b = vec2 (q.x, sign (q.y));\n  if (q.z > 0.) q.zx = Rot2D (q.zx - vec2 (0., bxMax), mix (-0.02, 0.011,\n     step (q.x, bxMax)) * pi) + vec2 (0., bxMax);\n  q.yx = Rot2D (q.yx, 0.003 * pi * b.y);\n  d = PrRoundBoxDf (vec3 (b.x, q.y + 0.05 * b.y, q.z), vec3 (bLen, 0.02, 0.2), 0.12);\n  DMINQ (3);\n  return dMin;\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, tLen, bScl, s;\n  dMin = dstFar;\n  if (milSz > 0.) {\n    p.xz -= HexToPix (gId * hgSize) + gShift;\n    dMin /= milSz;\n    p /= milSz;\n    tLen = 3.5;\n    q = p;\n    q.xz = Rot2Cs (q.xz, csMilAx);\n    q.yz -= vec2 (2. * tLen + 0.1, 0.1);\n    d = PrRoundBoxDf (q, vec3 (0.18, 0.2, 0.375), 0.1); \n    DMINQ (1);\n    q.z += 0.55;\n    q.xy = Rot2Cs (q.xy, csBldAng);\n    d = PrCapsDf (q, 0.2, 0.45);\n    DMINQ (2);\n    q.z += 0.27;\n    q.xy = Rot2D (q.xy, 2. * pi * ((floor (3. * atan (q.y, - q.x) / (2. * pi)) + 0.5) / 3.));\n    bScl = 0.65;\n    dMin = bScl * BladeDf (q / bScl, dMin / bScl);\n    q = p;\n    q.y -= tLen;\n    s = abs (q.y / tLen - 1.);\n    d = PrCylDf (q.xzy, 0.15 * (0.8 + 0.125 * s * s * s), tLen);\n    DMINQ (4);\n    dMin *= milSz;\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.01;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetMilParms ();\n    }\n    d = GObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetMilParms ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.8 + 0.2 * sh;\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  dMin /= boatSz;\n  p /= boatSz;\n  p.y -= 0.7;\n  d = PrCylDf (p, 1.2, 3.5);\n  if (d < 0.1 / boatSz) {\n    q = p;\n    d = max (max (PrRoundCylDf (q, -0.8, 2., 1.5), - max (PrRoundCylDf (q - vec3 (0., 0.1, 0.),\n       -0.85, 2., 1.5), abs (q.y) - 0.1)), abs (q.y + 0.1) - 0.1);\n    q.y -= -0.2;\n    d = max (SmoothMin (d, max (PrRoundCylDf (q, -1., 2., 1.3 ), q.y), 0.1), q.z - 2.);\n    DMINQ (idObjGrp + 1);\n    q = p;\n    q.yz -= vec2 (-0.5, -0.2);\n    d = max (PrRoundCylDf (q, -0.1, 1.1, 1.2), max (0.4 - q.y, q.z - 1.2));\n    DMINQ (idObjGrp + 2);\n    q = p;\n    q.yz -= vec2 (0.8, 0.5);\n    d = PrCylDf (q.xzy, 0.04, 0.3);\n    DMINQ (idObjGrp + 3);\n  } else dMin = min (dMin, d);\n  return boatSz * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_BOAT; k ++) {\n    idObjGrp = (k + 1) * 256;\n    dMin = BoatDf (boatMat[k] * (p - boatPos[k]), dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.01 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nfloat WakeFac (vec3 row)\n{\n  vec2 tw[N_BOAT], twa;\n  float twLen[N_BOAT], wkFac, ba;\n  for (int k = 0; k < N_BOAT; k ++) {\n    tw[k] = row.xz - (boatPos[k].xz - Rot2D (vec2 (0., 2.), boatAng[k]));\n    twLen[k] = length (tw[k]);\n  }\n  if (twLen[0] < twLen[1]) {\n    twa = tw[0];\n    ba = boatAng[0];\n  } else {\n    twa = tw[1];\n    ba = boatAng[1];\n  }\n  twa = Rot2D (twa, - ba);\n  wkFac = 0.;\n  if (length (twa * vec2 (2., 0.5)) < 1.) wkFac =\n     clamp (1. - 4. * abs (twa.x), 0., 1.) * clamp (0.5 + twa.y, 0., 1.);\n  return wkFac;\n}\n\nvec4 BoatCol ()\n{\n  vec4 col4, c4;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  c4 = (ig == 1) ? vec4 (0.9, 0.9, 0.3, 0.2) : vec4 (0.3, 0.9, 0.3, 0.2);\n  if (id == 1) col4 = (abs (qHit.y - 0.1) < 0.01) ? vec4 (0.7, 0.4, 0.2, 0.1) * (1. -\n     0.2 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.))) :\n     ((qHit.y > -0.3) ? c4 : vec4 (0.7, 0.7, 0.8, 0.1));\n  else if (id == 2) col4 = (abs (abs (qHit.x) - 0.4) < 0.36 && qHit.y > 0.45 && \n     length (vec2 (abs (qHit.x) - 0.1, qHit.y - 0.2)) < 0.7 || abs (abs (qHit.z + 0.2) -\n     0.6) < 0.5 && abs (qHit.y - 0.65) < 0.2) ? vec4 (0.6, 0.5, 0.2, -1.) : c4;\n  else if (id == 3) col4 = vec4 (1., 0., 0., 0.2);\n  return col4;\n}\n\nvec4 MillCol ()\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (1., 0.9, 0.7, 0.1) * (0.5 +\n     0.5 * smoothstep (0., 0.02, abs (qHit.y) - 0.02)) * (0.5 +\n     0.5 * smoothstep (0., 0.02, length (vec2 (qHit.x, qHit.z + 0.1))- 0.18));\n  else if (idObj == 2) col4 = vec4 (0.9, 1., 0.8, 0.2);\n  else if (idObj == 3) col4 = mix (vec4 (0.85, 0.85, 0.9, 0.2), vec4 (1., 0.2, 0.2, 0.1), \n     smoothstep (0., 0.02, step (qHit.x, -3.5)));\n  else if (idObj == 4) col4 = vec4 (0.9, 0.8, 0.7, 0.05) * (0.9 +\n     0.1 * smoothstep (0., 0.02, abs (mod (2. * qHit.y + 0.5, 1.) - 0.5) - 0.02));\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, row;\n  vec2 vf;\n  float dstObj, dstObjG, dstObjM, dstGrnd, wkFac, sh;\n  int idObjG;\n  bool wtRefl;\n  boatSz = 0.15;\n  dstObjG = GObjRay (ro, rd);\n  idObjG = idObj;\n  dstObjM = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  wtRefl = false;\n  wkFac = 0.;\n  dstObj = min (dstObjM, dstObjG);\n  if (dstGrnd < min (dstObj, dstFar)) {\n    row = ro + dstGrnd * rd;\n    if (GrndHt (row.xz) < 0.) {\n      ro = row;\n      wkFac = WakeFac (row);\n      row.xz += 0.2 * tCur;\n      vf = (wkFac > 0.) ? vec2 (16., 2. * wkFac) : vec2 (2., 0.05 * (1. - smoothstep (0.1, 0.4,\n          dstGrnd / dstFar)));\n      vn = VaryNf (vf.x * row, vec3 (0., 1., 0.), vf.y);\n      row = ro;\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObjG = GObjRay (ro, rd);\n      idObjG = idObj;\n      dstObjM = ObjRay (ro, rd);\n      dstGrnd = dstFar;\n      dstObj = min (dstObjM, dstObjG);\n      wtRefl = true;\n    }\n  }\n  sh = 1.;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      if (dstObjM < dstObjG) {\n        ro += dstObjM * rd;\n        vn = ObjNf (ro);\n        col4 = BoatCol ();\n     } else {\n        ro += dstObjG * rd;\n        idObj = idObjG;\n        vn = GObjNf (ro);\n        col4 = MillCol ();\n        if (idObj == 4) vn = VaryNf (64. * ro, vn, 0.3);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      gId = PixToHex (ro.xz / hgSize);\n      SetMilParms ();\n      col4 = vec4 (vec3 (0., 0.4, 0.) * (1. - 0.2 * Fbm2 (8. * ro.xz)), 0.05);\n      if (milSz > 0.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.03,\n         milSz * length (ro.xz - HexToPix (gId * hgSize)) - 0.05);\n      sh = GObjSShadow (ro, normalize (vec3 (1., 5., 1.)));\n    }\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.2 * max (dot (normalize (vec3 (- sunDir.xz, 0.)).xzy, vn), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      col = mix (col, SkyCol (ro, rd), (wtRefl ? 0.2 + 0.8 * smoothstep (0.4, 0.6,\n         dstObj / dstFar) : smoothstep (0.8, 0.9, min (dstGrnd, dstObj) / dstFar)));\n    } else col = mix (col4.rgb, 0.5 * SkyCol (ro, reflect (rd, vn)), 0.8);\n  } else col = SkyCol (ro, rd);\n  col *= wtRefl ? 0.85 : 1.;\n  if (wkFac > 0.) col = mix (col, vec3 (0.8, 0.83, 0.8), wkFac * clamp (0.1 +\n     Fbm2 (16. * row.xz), 0., 1.));\n  col *= vec3 (1.05, 0.95, 0.95);\n  return clamp (col, 0., 1.);\n}\n\nvoid BoatPM (float t, out vec3 bPos, out mat3 bMat, out float btAng)\n{\n  vec3 v;\n  vec2 cs;\n  float bAz;\n  bPos = TrackPath (t);\n  bPos.y = 0.;\n  bMat[2] = vec3 (Rot2D (vec2 (1., 0.), 0.4 * (Fbm1 (0.2 * t) - 0.5)), 0.);\n  bMat[0] = normalize (vec3 (0., 0.1, 1.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  v = TrackVel (t);\n  bAz = atan (v.z, - v.x);\n  btAng = 0.5 * pi - bAz;\n  cs = sin (bAz + vec2 (0.5 * pi, 0.));\n  bMat *= mat3 (cs.x, 0., cs.y, 0., 1., 0., - cs.y, 0., cs.x);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, uvf, mMid, ut, mSize, msw;\n  float el, az, asp, winHt, zmFac, sr, spd;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  winHt = 0.9;\n  uvf = vec2 (asp, winHt) - abs (uv);\n  mSize = (1./5.) * vec2 (asp, 1.) * winHt;\n  mMid = vec2 (asp, winHt - mSize.y) * vec2 (1. - mSize.y, -1.);\n  ut = abs (uv - mMid) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    msw = 2. * mPtr.xy - mMid / vec2 (asp, 1.);\n    if (Maxv2 (abs (msw)) < mSize.y) {\n      regId = 1;\n      msw /= 2. * mSize.y;\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (Maxv2 (ut) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1;\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 3.;\n  spd = 0.3;\n  ro = TrackPath (spd * tCur);\n  if (vuId == 0) {\n    ro.x += 0.1 * sin (0.05 * 2. * pi * tCur);\n    ro.y = 1. + 0.3 * Fbm1 (0.1 * tCur);\n    vd = TrackVel (spd * tCur);\n    el = -0.03 * pi;\n    az = atan (vd.x, vd.z);\n    if (mPtr.z > 0.) {   \n      el += 0.4 * pi * msw.y;\n      az += 2. * pi * msw.x;\n    }\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n    zmFac = 3.;\n  } else {\n    ro.y = 30.;\n    el = -0.3 * pi + 0.1 * pi * msw.y;\n    az = 0.2 * pi * msw.x;\n    zmFac = 5.;\n  }\n  for (int k = 0; k < N_BOAT; k ++) {\n    BoatPM (spd * tCur + ((vuId == 0) ? (((abs (az) > 0.5 * pi) ? -1. : 1.) *\n       (7. * float (k) + 5.)) : 7. * float (k) + 15.), boatPos[k], boatMat[k], boatAng[k]);\n    boatPos[k].y = -0.02 + 0.04 * Fbm1 (0.5 * tCur + float (k));\n  }\n  vuMat = StdVuMat (el, az);\n  dstFar = 120.;\n  sunDir = normalize (vec3 (1., 3., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  if (uvf.y > 0.) {\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n         pi)) / zmFac;\n      rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n    if (Maxv2 (ut) < 0. && Minv2 (abs (ut)) * canvas.y < 2. ||\n       Minv2 (uvf) * canvas.y < 2.) col = vec3 (0.6, 0.3, 0.2);\n  } else col = vec3 (0.85);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3R2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1193, 1193, 1219, 1219, 1275], [1277, 1277, 1302, 1302, 1363], [1365, 1365, 1388, 1388, 1534], [1536, 1536, 1560, 1560, 1652], [1654, 1654, 1676, 1676, 1824], [1826, 1826, 1847, 1847, 2432], [2434, 2434, 2470, 2470, 3004], [3006, 3006, 3029, 3029, 3823], [3825, 3825, 3859, 3859, 4945], [4947, 4947, 4969, 4969, 5225], [5227, 5227, 5265, 5265, 5671], [5673, 5673, 5708, 5708, 6439], [6441, 6441, 6463, 6463, 6640], [6642, 6642, 6675, 6675, 6858], [6860, 6860, 6881, 6881, 7136], [7138, 7138, 7170, 7170, 7699], [7701, 7701, 7727, 7727, 8235], [8237, 8237, 8254, 8254, 8932], [8934, 8934, 8951, 8951, 9529], [9531, 9531, 9566, 9566, 12032], [12034, 12034, 12104, 12104, 12513], [12515, 12515, 12571, 12571, 15180], [15182, 15182, 15228, 15228, 15275], [15277, 15277, 15319, 15319, 15370], [15372, 15372, 15429, 15429, 15505], [15507, 15507, 15550, 15550, 15614], [15616, 15616, 15640, 15640, 15870], [15872, 15872, 15896, 15896, 15956], [15958, 15958, 15980, 15980, 16007], [16009, 16009, 16031, 16031, 16058], [16060, 16060, 16082, 16082, 16120], [16122, 16122, 16167, 16167, 16259], [16261, 16261, 16318, 16318, 16401], [16403, 16403, 16439, 16439, 16645], [16647, 16647, 16677, 16677, 16790], [16792, 16792, 16823, 16823, 16887], [16921, 16921, 16945, 16945, 17005], [17007, 17007, 17031, 17031, 17084], [17086, 17086, 17110, 17110, 17222], [17224, 17224, 17249, 17249, 17395], [17397, 17397, 17422, 17422, 17608], [17610, 17610, 17632, 17632, 17786], [17788, 17788, 17809, 17809, 17964], [17966, 17966, 17995, 17995, 18207], [18209, 18209, 18248, 18248, 18505]], "test": "error"}
{"id": "Ntd3R4", "name": "Cool RayMarchig", "author": "tkasch", "description": "Made by this awesome tutorial https://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["3d"], "likes": 1, "viewed": 26, "published": "Public", "date": "1635785014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.0;\n    for(int i = 0; i< MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST)\n            break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0.0, 5.0, 6.0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))* 2.0;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l);\n    if(d < length(lightPos-p))\n        dif *= (-1.0);   //0.1 for black shadow\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;   \n   \n    vec3 ro = vec3(0.0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);    \n    vec3 difV = vec3(dif);\n    if(dif < 0.0)\n    {\n        difV = vec3(0, -dif, 0);   //color shadow\n    }\n    \n    vec3 col = vec3(difV);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 92, 92, 268], [270, 270, 304, 304, 537], [539, 539, 563, 563, 768], [770, 770, 794, 794, 1151], [1153, 1153, 1210, 1210, 1642]], "test": "valid"}
{"id": "Ntd3Wn", "name": "Rotating Ripple", "author": "xZAKHAMx", "description": "this is my first micro tile as studying glsl.", "tags": ["microtiles"], "likes": 4, "viewed": 107, "published": "Public API", "date": "1635982943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p  = vec2 (-1.0 + 2.0*uv);\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anV = 0.50;\n    float div = 0.40;\n    float rad = 0.20;\n    \n    p = vec2 (p.x*cos(iTime) - p.y*sin(iTime),\n              p.x*sin(iTime) + p.y*cos(iTime));\n    p = abs(p);\n    vec2 tolen = (p + (vec2 (-iResolution.x/iResolution.y, -1.0 )));\n    float len = length(tolen);\n\n    float anm = len + iTime*anV; \n    vec2 mo = mod(vec2(anm), div);\n    vec3 col = vec3(0.0);\n    if (mo.x < rad)\n    {\n        col = vec3(1.0);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 656]], "test": "valid"}
{"id": "Ntd3Ws", "name": "Blue sky with sunset/rise", "author": "RJVB09", "description": "A 2d blue sky with rayleigh scattering in mind.", "tags": ["sky", "rayleigh"], "likes": 3, "viewed": 64, "published": "Public", "date": "1636965987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //All constants have been eyeballed, so nothing is really physically accurate.\n    \n\n    vec2 uv = fragCoord/iResolution.xy;\n    float zoom = 0.5;\n    float time = sin(iTime*0.1); //sin(uv.x*3.14); for time on the x axis.\n    float terminator = 7.0;\n    vec3 timeMult = vec3(1.0-pow(2.0,-(terminator*5.0)*time),1.0-pow(2.0,-(terminator*2.0)*time),1.0-pow(2.0,-terminator*time));\n    //    ^^ How each color should fade depending on time.\n\n    //The \"height\" of each gradient on each channel.\n    float r = pow(max(1.0-uv.y*zoom,0.0),6.0)*0.95 * timeMult.x;\n    float g = pow(max(1.0-uv.y*zoom,0.0),3.0) * timeMult.y;\n    float b = pow(max(1.0-uv.y*zoom,0.0),1.5) * timeMult.z;\n    \n    // Output to screen\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 140, 802]], "test": "valid"}
{"id": "Ntd3zS", "name": "入门之路-12", "author": "jialouluo", "description": "模拟细胞运动", "tags": [], "likes": 1, "viewed": 114, "published": "Public API", "date": "1636288179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float count = 40.0;\nvec2 Size = vec2(30.0, 40.0);\nvec3 colorBg = vec3(0.0);\nvec3 colorIn = vec3(1.0, 0.9, 0.16);\nvec3 colorOut = vec3(0.12, 0.59, 0.21);\nvec3 getPowerColor(vec2 power) {\n    float pMax = pow(1.12,3.2);\n    float pMin = 1.0 / pMax;\n    vec3 color = mix(colorBg, colorOut, smoothstep(pMin, pMax, power.y));\n    color = mix(color, colorIn, smoothstep(pMin, pMax, power.x));\n    return color;\n}\nvec2 getPower(vec2 st, vec2 pos, vec2 size) {\n    vec2 radius = (size * size) / dot(st - pos, st - pos);\n    radius = pow(radius, vec2(1.5));\n    return radius;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord;\n    vec2 pows = vec2(0.0);\n    vec2 pos;\n    vec3 col;\n    for(float i = 1.0; i < count; i++) {\n        pos = 0.5 *iResolution.xy *\n            vec2(sin(iTime*0.05 * fract(0.246 * i) + i * 3.6) *\n                          cos(iTime*0.05 * fract(0.374 * i) - i * fract(0.6827 * i))\n                          + 1.,\n                          cos(iTime*0.05 * fract(0.246 * i) + i * 3.6) *\n                          sin(iTime*0.05 * fract(.374 * i) - i * fract(0.6827 * i))\n                          + 1.);\n        pows += getPower(uv, pos, Size * (.5 + fract(0.2834 * i) * .5));\n    }\n    col = getPowerColor(pows);\n    // Output to screen\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 185, 185, 406], [407, 407, 452, 452, 569], [570, 570, 625, 625, 1326]], "test": "valid"}
{"id": "NtdGD2", "name": "Ripples by Osa", "author": "Osakazaur", "description": "I tried to make something different, but this is beautiful I want to save it.\nYou can change PARAMETERS in 12-15 str\nAlso you can change colors in 17-21 str", "tags": ["time", "color", "flow"], "likes": 0, "viewed": 135, "published": "Public", "date": "1636750618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14;\n\nfloat step2(float x){return x * x;}\n\nfloat radius(vec2 pos){return sqrt(step2(pos.x) + step2(pos.y));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // PARAMETERS //\n    float size = .27*iResolution.y;\n    float speed = 2.;\n    float ripples = 25.;\n    float ripplesScale = .1;\n\n    vec3 baseCol = vec3(0.);\n    vec3 outBottom = vec3(255., 105., 180.) / 255.;\n    vec3 outTop = vec3(255., 255., 0.) / 255.;\n    vec3 inBottom = vec3(127., 255., 212.) / 255.;\n    vec3 inTop = vec3(0., 255., 255.) / 255.;\n    \n    vec3 outMix = mix(outBottom, outTop, smoothstep(0., 1.5, uv.y));\n    vec3 inMix = mix(inBottom, inTop, smoothstep(0.1, .9, uv.y));\n\n    float rad = size * (1. + ripplesScale*sin(fract(fragCoord.y/ripples + iTime*speed)*2.*pi));\n    \n    //pink flame\n    \n    vec2 center = vec2(iResolution.x*.5, iResolution.y*.35);\n    vec2 pos = fragCoord - center;\n    float mul = 1. - (uv.y)*.5;\n    bool outMask = radius(vec2(pos.x, pos.y*mul)) < rad;\n    bool inMask = radius(vec2(pos.x, pos.y*mul)) < rad*.7;\n    \n\n    fragColor = outMask ? inMask ? vec4(inMix, 1.) : vec4(outMix, 1.) : vec4(baseCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 39, 39, 53], [55, 55, 78, 78, 120], [122, 122, 179, 179, 1195]], "test": "valid"}
{"id": "NtdGDs", "name": "Spinning Toruses", "author": "ysp125", "description": "some spinning toruses", "tags": ["raymarching"], "likes": 3, "viewed": 63, "published": "Public", "date": "1636969305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// BASIC RAY-MARCHING CLASS DEMO!\n//\n// Numerous methods borrowed from iq articles:\n//   https://iquilezles.org/www/index.htm\n// \n// 3D signed distance functions:\n//   https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// \n// Shadows:\n//   https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// \n// Ray-marching SDFs:\n//   https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n// \n// Normals for SDFs:\n//   https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nvec4  opUnion(vec4 d1, vec4 d2) {\n return (d1.x < d2.x ? d1 : d2);   \n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nvec4  opIntersection( vec4  d1, vec4  d2 ) {\n return (d1.x > d2.x ? d1 : d2);   \n    \n}\n\n// subtracts d1 from d2\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec4  opSubtraction( vec4  d1, vec4  d2 ) { \n  return opIntersection(vec4(-d1.x,d1.yzw), d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// 3D gradient noise methods. \n// https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm( in vec3 pos )\n{\n    vec3  q = 8.0*pos;\n    float f = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); //q = m*q*2.02;\n    //f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.0625*noise( q ); \n    return f;\n}\n\n\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, 0.,\n\t\t+.0, +.0, 1.);\n}\n\n// iq distance functions, \n// See https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere(vec3 p, float radius )\n{\n  return length(p)-radius;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// not exact\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// See https://www.shadertoy.com/view/Wdjfz3\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 bendPoint( in vec3 p , float amt)\n{\n    float k = amt; //  some amount, e.g., 10.\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n// Function to y-axis revolve a 2D SDF into a 3D SDF.\nvec2 revolvePoint( in vec3 p, float radius )\n{\n    return vec2( length(p.xz) - radius, p.y );\n}\n\n// Simple ellipsoidal SDF pumpkin at origin.\nfloat sdPumpkin(vec3 p) \n{\n\tfloat sdf = 100.;\n    for(int i=0; i<10; i++) {// somewhat expensive\n    \tvec3  rp = rotate_y(p, 6.28*float(i)/10.+0.27);\n        vec3  q  = rotate_z(rp-vec3(0.6,0.,0.),-0.1);\n\t    float d  = sdEllipsoid(q, vec3(0.8, 1., 0.6));\n        sdf = opSmoothUnion(d, sdf, 0.03);\n        //sdf = opUnion(d, sdf);\n    }\n    \n    return sdf;\n}\n\n\n/// SCENE PARAMETERS (feel free to add your own):\nconst vec3 pumpkinCenter     = vec3(0., -0.15, -8.0);\nconst vec3 Cd_pumpkinOutside = vec3(231./255., 111./255., 3./255.); \nconst vec3 Cd_pumpkinInside  = vec3(1.,0.7,0.);\nconst vec3 Cd_stem           = vec3(0.35,0.25,0.15);\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// SDF implementation for our scene. \n// Returns 4 values: (sdf, Cd)\n//   .x: SDF distance, \n//   .y: Cd.r\n//   .z: Cd.g\n//   .w: Cd.b\n// NOTE: You could return other things for yzw, e.g., y:objectID int to set more colors in \"render.\"\nvec4 mapV4(in vec3 p)\n{\n    // SDF vector (sdf, r,g,b) to be returned:\n    vec4 sdf = vec4(100000., -1., 0., 0.);\n    \n    float mx = iMouse.x/iResolution.x;\n\n\n    // TODO: REPLACE THE FOLLOWING WITH YOUR SCENE CODE:\n    \n    // Translate coordinate to pumpkin center:\n    vec3 c = pumpkinCenter;\n    p -= c; \n            \n    \n    // fuselage\n    vec3 q = p;\n    q = rotate_y(q, iTime);\n    q = rotate_z(q, cos(iTime));\n    q = rotate_x(q, sin(iTime));\n    float innerTorusSD = sdTorus(q, vec2(0.9,0.05));\n    vec4 innerTorus = vec4(innerTorusSD, vec3(0.4,0.9,0.9));\n    sdf = opUnion( sdf, innerTorus );\n    \n    vec3 n = p;\n    n = rotate_y(q, sin(iTime));\n    n = rotate_z(q, iTime);\n    n = rotate_x(q, cos(iTime));\n    float mediumTorusSD = sdTorus(n, vec2(1.05,0.05));\n    vec4 mediumTorus = vec4(mediumTorusSD, vec3(0.9,0.4,0.9));\n    sdf = opUnion( sdf, mediumTorus );\n    \n    vec3 x = p;\n    x = rotate_y(q, cos(iTime));\n    x = rotate_z(q, sin(iTime));\n    x = rotate_x(q, iTime);\n    float outerTorusSd = sdTorus(x, vec2(1.2,0.05));\n    vec4 outerTorus = vec4(outerTorusSd, vec3(0.9,0.9,0.4));\n    sdf = opUnion( sdf, outerTorus );\n    \n    \n    float sphereSD = sdSphere(p, 0.8);\n    vec4 sphere = vec4(sphereSD, vec3(0.9,0.4,0.6));\n    sdf = opUnion( sdf, sphere );\n        \n    return sdf;\n}\n\n\n// Scalar SDF implementation for our scene\nfloat map(in vec3 p)\n{\n    return mapV4(p).x;// just sdf value\n}\n\n//vec3 calcNormal( in vec3 p ) // for function map(p)\n//{\n//    const float eps = 0.0001; // or some other value\n//    const vec2  h   = vec2(eps,0);\n//    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n//                          map(p+h.yxy) - map(p-h.yxy),\n//                           map(p+h.yyx) - map(p-h.yyx) ) );\n//}\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// Vector raymarch: \n// .x   : t* value of surface, or -1 if didn't hit anything.\n// .yzw : pass-thru from mapV4.yzw\n// \nvec4 raymarchV4(in vec3 ro, in vec3 rd) \n{\n    //int steps = int(round(200.0*iMouse.y/iResolution.y));\n    float t = 0.0;\n    for(int i=0; i<513; i++) {\n        vec3  rt = ro + rd*t;\n        vec4  f  = mapV4(rt);\n\t\tfloat d  = f.x;\n        \n        if(d<0.001) {// We hit it or went too far\n            f.x = t; // replace .x's sdf with t*\n            //f.yzw = vec3(1.,0.,0.);\n            return f;\n        }\n        else {// keep marching\n         \tt += 0.95*d; // conservative/smaller step for inexact/warped SDFs\n        }\n        \n        if(t > 100.) {\n            f.x = -1.;// -ve t* --> didn't hit anything\n            return f;\n        }\n    }\n    \n\treturn vec4(-1., vec3(0.)); // didn't hit anything\n}\n\n/// Returns t* value of surface, or -1. if didn't hit anything.\nfloat raymarch(in vec3 ro, in vec3 rd) \n{\n    return raymarchV4(ro,rd).x;  \n}\n\n// Raymarch SDF: \n// Returns: t* value of surface, or -1.0 if didn't hit anything.\nfloat raymarchVanilla(in vec3 ro, in vec3 rd) \n{\n    float t = 0.0;\n    for(int i=0; i<200; i++) {\n        vec3  rt = ro + rd*t;\n        float d  = map(rt); // SDF of scene\n        \n        if(d<0.001) {// We hit it (or went too far)\n            return t;\n        }\n        else {// keep marching\n         \tt += d; // Assumes exact SDFs\n        }\n        \n        if(t > 100.) {\n            return -1.0;\n        }\n    }\n    \n\treturn -1.0; // didn't hit anything\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.;\n        t += 0.95*h;//can do slightly less for not-quite-SDFs\n    }\n    return 1.0;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += 0.95*h;//slightly less for not-quite-SDFs\n    }\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) \n{\n    vec3  col = vec3(0.,0.,0.);    // init color to background\n    vec4  ray = raymarchV4(ro, rd);// compute distance along ray to surface\n    float t   = ray.x;\n    vec3  Cd  = ray.yzw;// can passthru other shading values, e.g., objectID, but we did color.\n    \n    vec2  mouse = iMouse.xy/iResolution.xy;        \n\n    \n    if(t>0.0) {//hit surface --> shade it:   \n\n\t    vec3  p  = ro + rd*t; // point on surface\n        vec3  N  = calcNormal(p); // sdf normal\n        \n        // DETERMINE MATERIAL COLOR: (todo: all orange for now)\n        //vec3  Cd = vec3(231./255., 111./255., 3./255.); // diffuse color\n        \n        // DIRECTIONAL LIGHT:\n        vec3  posL   = ro+ 30.*vec3(mouse.x-0.5, mouse.y-0.5,0.);// light at eye (safe!)\n        vec3  L      = normalize(posL - p);\n        vec3  CL     = vec3(1.);// directional light color\n        float LdotN  = clamp(dot(L,N), 0., 1.);\n        //float shadL  = shadow(p, L, 0.01, 10.);\n        float sshadL = softshadow(p, L, 0.01, length(posL-p), 2.);\n\t    col = Cd * CL * LdotN * sshadL;// * sshadL; // * occ;\n        \n        // CANDLE LIGHT (#2):\n        //vec3  dp     = 2.*vec3(0., mouse.y-0.5, mouse.x-0.5);\n        vec3  posL2  = pumpkinCenter + .15*vec3(sin(20.*iTime),cos(7.*iTime),cos(14.*iTime));\n        vec3  L2     = normalize(posL2 - p);\n        vec3  CL2    = vec3(1.,1.,.2);// candle light color\n        float L2dotN = clamp(dot(L2,N), 0., 1.);\n        float shadL2  = shadow(p, L2, 0.02, length(posL2-p));\n        //float sshadL2 = softshadow(p, L2, 0.01, length(posL2-p), 8.);\n\t    col += Cd * CL2 * L2dotN * shadL2; // * occ;       \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pXY = (fragCoord - 0.5*iResolution.xy)/iResolution.y; // normalized coordinates (unit height)\n    vec3 pix = vec3(pXY,    0.);    // position of virtual pixel (Z=0 depth)\n    vec3 ro  = vec3(0., 0., 3.);    // ray origin (EYE POSITION).. controls field-of-view\n    vec3 rd  = normalize(pix - ro); // ray direction\n    \n    vec3 col = render(ro, rd); // ray-march and evaluate color\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 558, 558, 580], [581, 581, 614, 614, 652], [654, 654, 698, 698, 719], [720, 720, 764, 764, 807], [809, 833, 876, 876, 898], [899, 899, 942, 942, 994], [996, 996, 1048, 1048, 1147], [1149, 1149, 1207, 1207, 1307], [1309, 1309, 1368, 1368, 1467], [1469, 1469, 1520, 1520, 1553], [1555, 1627, 1684, 1684, 1853], [1854, 1854, 1880, 1880, 2705], [2831, 2831, 2857, 2857, 3062], [3067, 3067, 3103, 3103, 3220], [3221, 3221, 3257, 3257, 3375], [3376, 3376, 3412, 3412, 3527], [3529, 3631, 3656, 3656, 3675], [3676, 3676, 3701, 3701, 3720], [3721, 3721, 3757, 3757, 3785], [3787, 3787, 3826, 3826, 3855], [3857, 3857, 3895, 3895, 3960], [3961, 3961, 3992, 3992, 4079], [4080, 4080, 4144, 4144, 4261], [4262, 4262, 4314, 4314, 4435], [4436, 4436, 4495, 4495, 4808], [4809, 4809, 4845, 4845, 4928], [4929, 4929, 4971, 4997, 5022], [5023, 5023, 5071, 5071, 5353], [5355, 5368, 5405, 5405, 5488], [5490, 5535, 5587, 5587, 5871], [5872, 5872, 5942, 5942, 6076], [6077, 6077, 6122, 6122, 6213], [6215, 6215, 6255, 6255, 6431], [6432, 6486, 6532, 6532, 6581], [6583, 6628, 6654, 6654, 6988], [7266, 7266, 7322, 7322, 7824], [7826, 8062, 8085, 8132, 9369], [9372, 9415, 9437, 9437, 9479], [9481, 9876, 9908, 9908, 10429], [10431, 10552, 10594, 10654, 11262], [11264, 11328, 11369, 11369, 11405], [11407, 11490, 11538, 11538, 11953], [11955, 11955, 12019, 12019, 12223], [12224, 12224, 12301, 12301, 12675], [12677, 12677, 12715, 12715, 14352], [14354, 14354, 14411, 14411, 14860]], "test": "valid"}
{"id": "NtdGRX", "name": "Domino 2", "author": "nihohit", "description": "Based on \"domino piece \" by bmax.", "tags": ["proceduralgeneration", "domino"], "likes": 3, "viewed": 98, "published": "Public API", "date": "1636451495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLUR_RADIUS 0.015\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat sdRoundedLine(vec2 p, vec2 a, vec2 b, float r) {\n    return sdLine(p, a, b) - r;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y),0.0);\n}\n\nfloat sdRoundedBox(vec2 p, vec2 b, float r) {\n    return sdBox(p, b) - r;\n}\n\nvec4 shapeColor(vec3 fillColor, float dist, float gradience) {\n    float smoothDist = smoothstep(0.00, BLUR_RADIUS, dist);\n    float opacity = 1.0 - smoothDist;\n    return vec4(fillColor * opacity + abs(dist * gradience), opacity);\n}\n\nvec4 combine(vec4 color1, vec4 color2) {\n    return min(color1, color2);\n}\n\nmat2 scale(vec2 scale) {\n    return mat2(scale.x, 0.0, 0.0, scale.y);\n}\n\nvec3 white = vec3(0.8, 0.8, 0.8);\nvec3 black = vec3(0.0, 0.0, 0.0);\nvec3 green = vec3(0.0, 0.4, 0.0);\nvec3 red = vec3(0.5, 0.0, 0.0);\nfloat dotRadius = 0.06;\nint numberOfValues = 7;\n\nvec4 draw1Dot(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.0, -0.0), dotRadius), 5.0);\n    return mix(background, dot, dot.a);\n}\n\nvec4 draw2Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\n\nvec4 draw3Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.0, 0.0), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 draw4Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 draw5Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.0, 0.0), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 draw6Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.0), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.0), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 drawBlackCircle(vec2 center, float radius, float thickness) {\n    vec4 circle = vec4(1.0-step(sdCircle(center, vec2(0.0, -0.0), radius),  radius));\n    circle += vec4(step(sdCircle(center, vec2(0.0, -0.0), radius - thickness), radius - thickness));\n    circle.a = 1.0-step(sdCircle(center, vec2(0.0, -0.0), radius), radius);\n    return circle;\n}\n\nvec4 drawSagie(vec2 center) {\n    vec4 hair = drawBlackCircle(center - vec2(0.07, 0.19), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.07, 0.19), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.055, 0.195), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.055, 0.195), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.04, 0.2), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.04, 0.2), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.015, 0.205), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.015, 0.205), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.085, 0.175), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.085, 0.175), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.1, 0.165), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.1, 0.165), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.115, 0.15), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.115, 0.15), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.13, 0.141), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.13, 0.141), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.00, 0.21), 0.01, 0.008);\n    \n    vec4 beard = drawBlackCircle(center - vec2(-0.0, -0.19), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.07, -0.19), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.055, -0.195), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.055, -0.195), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.04, -0.2), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.04, -0.2), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.015, -0.205), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.015, -0.205), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.085, -0.175), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.085, -0.175),0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.1, -0.165), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.1, -0.165), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.115,- 0.15), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.115, -0.15), 0.01, 0.02);\n    hair *= drawBlackCircle(center - vec2(0.13, -0.141), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.13, -0.141), 0.01, 0.02);\n    \n    vec4 face = drawBlackCircle(center, 0.1, 0.01);\n    vec4 leftEye = drawBlackCircle(center - vec2(0.07, 0.06), 0.01, 0.003);\n    leftEye *= drawBlackCircle(center - vec2(0.07, 0.06), 0.005, 0.1);\n    face = mix(face, leftEye, 1.0-leftEye.a);\n    vec4 rightEye = drawBlackCircle(center- vec2(-0.07, 0.06), 0.01, 0.003);\n    rightEye *= drawBlackCircle(center - vec2(-0.07, 0.06), 0.005, 0.1);\n    face = mix(face, rightEye, 1.0-rightEye.a);\n    return mix(hair,face, 1.0-face.a) * beard;\n}\n\nvec4 drawDots(vec3 color, int number, vec2 center, vec4 background) {\n    vec4 aggregate = vec4(0);   \n    aggregate += draw1Dot(color, center, background) * float(number == 1);\n    aggregate += draw2Dots(color, center, background) * float(number == 2);\n    aggregate += draw3Dots(color, center, background) * float(number == 3);\n    aggregate += draw4Dots(color, center, background) * float(number == 4);\n    aggregate += draw5Dots(color, center, background) * float(number == 5);\n    aggregate += draw6Dots(color, center, background) * float(number == 6);\n    aggregate += drawSagie(center) * float(number == 0);\n    return aggregate;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = 2.0 * fragCoord/iResolution.xy - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    pos.x *= aspectRatio;\n    pos = scale(vec2(0.5 + 0.5 * cos(iTime))) * pos;\n    \n    vec2 pieceSize = vec2(0.22, 0.54);\n    float pieceRadius = 0.08;\n    vec4 piece = shapeColor(white, sdRoundedBox(pos, pieceSize, pieceRadius), 0.65);\n\n    int counter = int((iTime + 3.15) / 6.25) % numberOfValues;\n    vec4 blendedRedDots = drawDots(red, counter, pos + vec2(0.0, 0.32), piece);\n\n    vec4 blendedGreenDots = drawDots(green, (counter + 1) % numberOfValues , pos - vec2(0.0, 0.32), piece);\n\n    vec2 divStart = vec2(-0.24, 0.0);\n    vec2 divEnd = vec2(0.24, 0.0);\n    float divRadius = 0.02;\n    vec4 divider = shapeColor(black, sdRoundedLine(pos, divStart, divEnd, divRadius), 15.0);\n    vec4 blendedDivider = mix(piece, divider, divider.a);\n\n    fragColor = combine(combine(blendedRedDots, blendedGreenDots), blendedDivider);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 68, 68, 100], [102, 102, 140, 140, 257], [259, 259, 313, 313, 347], [349, 349, 378, 378, 462], [464, 464, 509, 509, 539], [541, 541, 603, 603, 774], [776, 776, 816, 816, 850], [852, 852, 876, 876, 923], [1108, 1108, 1165, 1165, 1292], [1294, 1294, 1352, 1352, 1668], [1671, 1671, 1729, 1729, 2193], [2195, 2195, 2253, 2253, 2871], [2873, 2873, 2931, 2931, 3697], [3699, 3699, 3757, 3757, 4674], [4676, 4676, 4742, 4742, 5026], [5028, 5028, 5057, 5057, 7903], [7905, 7905, 7974, 7974, 8543], [8545, 8545, 8600, 8600, 9539]], "test": "valid"}
{"id": "NtdGWl", "name": "Persian carpet 23", "author": "jarble", "description": "A series of randomly generated carpet designs.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 116, "published": "Public API", "date": "1636942227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2));\n    vec3 random2 = (hash31(4.+t2));\n    vec3 random3 = random1*3.;\n    vec3 random4 = random2*3.;\n    vec3 random5 = random2*3.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    //float bend = scale2;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 3; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //float bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //float bend = 1.+1./3.;\n                //float bend = scale2/1.5;\n                \n                \n                \n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                //bend += 1./(1.+uv.x+uv.y);\n                bend *= -1.+(uv.x+uv.y)/(6.+random5[k]*4.);\n\n                //bend = 1./bend;\n                uv += vec2(random1[k],random2[k])/(6.);                \n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(3.+random3[i]);\n            scale2 -= (col.x-1.)/(3.+random4[i]);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2441]], "test": "valid"}
{"id": "NtdGWs", "name": "I am calling the police", "author": "Arthank", "description": "This is literally my first shader, don't judge, PLEASSEEEEEEEE", "tags": ["useless"], "likes": 3, "viewed": 30, "published": "Public", "date": "1636964295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(3.0f*iTime+uv.xyx+vec3(1,0,2));\n    col[1] = 0.0f;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 318]], "test": "valid"}
{"id": "NtG3RK", "name": "Noise Blobs", "author": "SnoopethDuckDuck", "description": "sc = 3. makes it a noisy trail (need more points in for loop), the for loop is a bit expensive", "tags": ["e"], "likes": 5, "viewed": 148, "published": "Public API", "date": "1637953057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// smoothstep from a point p\nfloat sp(vec2 uv, float t) {\n    vec2 p = 0.35 * vec2(thc(0.5, t * 0.713), ths(0.5, t));\n    float d = length(uv - p);\n    float k = 0.5 * d + 0.035 * length(uv);\n    return smoothstep(-k, k, k - d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // warp uv slightly\n    uv /= 0.85 * cosh(1.1 * length(uv));\n\n    float t = 2.5 * iTime;\n    \n    // length of trail (0.05 -> blobs, 3. -> noisy trail)\n    float sc = 0.1; //mix(0.05, 3., .5 + .5 * cos(2. * iTime));\n    \n    // flick between blobs seperated/together\n    float e = .5 + .5 * thc(4., -0.8 * iTime);\n    \n    // make 12 blobs (sc * h21 \"stretches\" using noise)\n    float s = sp(uv, t + sc * h21(uv));\n    for (float i = 1.; i < 12.; i++) {\n        s = max(s, sp(uv, e * i + t + sc * h21(uv + i)));\n    }\n    \n    vec3 col = s * pal(s, vec3(1.), vec3(1.), vec3(1.), s * vec3(0.,0.33,0.66)); \n    col += 2. * vec3(s) * vec3(0.2,0.6,0.9);\n    //col = vec3(s);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 232, 232, 275], [277, 277, 297, 297, 372], [374, 403, 431, 431, 604], [606, 606, 663, 663, 1436]], "test": "valid"}
{"id": "NtG3Wh", "name": "nucleic acid", "author": "4eckme", "description": "6 spirals", "tags": ["2d", "colors", "spiral", "organic", "dna"], "likes": 4, "viewed": 49, "published": "Public", "date": "1637548483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 c, in vec2 o )\n{\n    o.y-=iResolution.y/2.0;o.x=float(int(o.x));\n    vec4 ox=vec4((mod(o.x+float(iFrame),11.0)-3.0),(mod(o.x+float(iFrame),13.0)-5.0),(mod(o.x+float(iFrame),17.0)-7.0),1)/2.0;\n    o.x+=float(iFrame);\n    vec2 old=o;\n    o.x=(mod(floor(o.x),2.0));\n    o.y=(old.y)+floor((sin(float(int(floor(old.x))/4)-iTime)*85.0));\n    c=vec4(0.0);\n    vec4 color=1.0-vec4(sin(float(int(floor(old.x))/4)-iTime));\n    float r = (o.x*o.x+o.y*o.y);\n    vec2 oo=old;\n    old.x-=1.0;\n    oo.x=(mod(floor(oo.x+float(iFrame)),2.0));\n    oo.y=(old.y)+floor((sin(float(int(floor(old.x+1.0))/4)-iTime+3.1416)*85.0));\n    float r2 = oo.x*oo.x+oo.y*oo.y;\n    vec4 color2=1.0-vec4(sin(float(int(floor(old.x+1.0))/4)-iTime+3.1416));\n    if((sqrt(r))<=2.0) c=color*color2+ox;\n    else if((sqrt(r2))<=2.0) c=color2*color+ox;\n    //if(c.x>0.0){c+=0.75;c/=2.0;}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 870]], "test": "valid"}
{"id": "NtGGWD", "name": "Four-leaf clover quilt", "author": "jarble", "description": "A four-leaf clover pattern.", "tags": ["fractal", "clover", "carpet", "rug"], "likes": 3, "viewed": 89, "published": "Public API", "date": "1637671087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change this constant to get different patterns!\n#define c2 0.\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 9.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float bend = 1.0; \n            for(int k = 0; k < 9; k++){       \n                uv /= scale2;\n                uv = triangle_wave(uv.yx+offset,scale)/bend+triangle_wave(uv+offset/scale2,scale)*bend;\n                //bend = 1.+uv.x/2.;\n            }\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n            col[c] = abs(col[c] - ((uv.x)-(uv.y)));\n        }\n\t}\n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 142, 142, 187], [189, 189, 246, 246, 1005]], "test": "valid"}
{"id": "NtGGWm", "name": "The Cell Void 4 (fake 3D)", "author": "FabriceNeyret2", "description": "multilayer variant of [url]https://shadertoy.com/view/NlG3Dw[/url]\ncylindrical variant of [url]https://shadertoy.com/view/flyGDw[/url]\n2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 14, "viewed": 209, "published": "Public API", "date": "1637772299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// multilayer variant of https://shadertoy.com/view/NlG3Dw\n// cylindrical variant of https://shadertoy.com/view/flyGDw\n\n#define H(v)      fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v)      smoothstep(30./R.y,0.,v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime, k=8., z=8., n, _n;\n\n  for( n = 2.; n >= 1.; n-=.5 ) {                           // several layers\n    U = U0;\n    U = k*vec2( .995*atan(U.y,U.x), z/length(U) );          // go to cylinder space\n    U.y += n*t;                                             // animation\n\n    for ( int k=0; k < 9; k++ )                             // jittered point grid distribution\n        D = vec2(k%3,k/3), P = floor(U)+D - H(mod(floor(U)+D,25.)+n/13.),  // NB: cyclical hash\n        d = length(P-U), \n        d < m ? _P=P, _n = n, m = d : m;\n }   \n    P = _P;\n\n    U = U0;\n    P = k*z/(P.y-_n*t) * cos( P.x/.995/k + vec2(0,-1.57) ); // back to screen space\n    m = length(P-U);\n \n                                                            // draw disk - dark disk\n    O = vec4( clamp( S(m-.4) - S( length(P-U+ U*length(U)/1e3 ) -.4 )  ,0.,1.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 254, 254, 1201]], "test": "valid"}
{"id": "NtGGzG", "name": "The Cell Void 5 (fake 3D)", "author": "FabriceNeyret2", "description": "perspective variant of [url]https://shadertoy.com/view/NtGGWm [/url]\nmultilayer +cylindrical + 2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]\n\nclick for slight fog.", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 14, "viewed": 234, "published": "Public API", "date": "1637846317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// perspective variant of https://shadertoy.com/view/NtGGWm\n// multilayer variant of https://shadertoy.com/view/NlG3Dw\n// cylindrical variant of https://shadertoy.com/view/flyGDw\n// 2D variant of lambmeow's https://www.shadertoy.com/view/7lVGWW\n\n#define H(v)      fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v)      smoothstep(30./R.y,0.,v)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P, C,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime, k=8., z=8., r = .4, n=1., _n;\n    O-=O; \n    for( z=32.; z >= 4.; z/=2. ) {                              // several layers\n//  for( n = 2.; n >= 1.; n-=.5 ) {                             // several layers\n        U = U0;\n        U = k*vec2( .995*atan(U.y,U.x), z/length(U) );          // go to cylinder space\n        U.y += n*t;                                             // animation\n        m = 9.;\n        for ( int k=0; k < 9; k++ )                             // jittered point grid distribution\n            D = vec2(k%3,k/3), P = floor(U)+D - H(mod(floor(U)+D,25.)+n/13.),  // NB: cyclical hash\n            d = length(P-U), \n            d < m ? _P=P, _n = n, m = d : m;\n\n        P = _P;\n\n        U = U0;\n        P = k*z/(P.y-_n*t) * cos( P.x/.995/k + vec2(0,-1.57) ); // back to screen space\n        m = length(P-U);\n\n        r = .4*length(U)/10.;                                   // draw disk\n        C = vec2( S(m-r) );                                           // mask\n        C.x = clamp( C.x - .9*S( length(P-U+ U*r/50. ) -r ), 0.,1.); // color = disc - dark disc\n        O =  ( iMouse.z <= 0. ? C.xxxy \n                              : C.xxxy*exp(-vec4(0,1,1,1)/10.*log2(z/4.)) ) // if click, fog\n            + (1.-C.y)*O;                                       // blend\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 445, 445, 1852]], "test": "valid"}
{"id": "NtGGzV", "name": "Fork Creation b xandrkat 265", "author": "xandrkat", "description": "My first demoscene release. Achieved second place @ DemoJS 2011. It has been said to be the first 1k WebGL intro ever released.", "tags": ["intro", "silexars", "1k", "demojs"], "likes": 2, "viewed": 46, "published": "Public", "date": "1637963284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z-z));\n\t\tc[i]=.01/length(mod(uv,1.)-.5);\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 224, 224, 462]], "test": "valid"}
{"id": "NtK3RV", "name": "Eclipse - Ending the golden age", "author": "LilBensson", "description": "A stylized eclipse inspired by Berserk fanart. Originally made as a background for a school project.", "tags": ["eclipse", "berserk"], "likes": 16, "viewed": 178, "published": "Public", "date": "1638198102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2x2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2x2(c, s, -s, c);\n}\n\nuint wang_hash(uint seed)\n{\n\tseed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    \n    return seed;\n}\n\n// Semi-random float [0, 1) from 1D position\nfloat randomFloat(float state)\n{\n\treturn float(wang_hash(uint(state))) / 4294967296.0;\n}\n\n// Semi-random floats from 2D position\nvec2 randomFloat(vec2 state)\n{\n\treturn vec2(\n        randomFloat(state.x + state.y * 1024.0), \n        randomFloat(state.x * 512.0 + state.y * 2048.0)\n    );\n}\n\nfloat perlinNoiseOctave(vec2 p)\n{\n\tfloat offsetStep = 1.0;\n    float gridSize = 10.0;\n    \n    vec2 id = floor(p * gridSize);\n    \n    // Random corners\n    float upperLeft  = randomFloat(id + vec2(0.0, 0.0)).x;\n    float upperRight = randomFloat(id + vec2(offsetStep, 0.0)).x;\n    float lowerLeft  = randomFloat(id + vec2(0.0, offsetStep)).x;\n    float lowerRight = randomFloat(id + vec2(offsetStep, offsetStep)).x;\n    \n    // Bicubic interpolation\n    vec2 st = smoothstep(0.0, 1.0, fract(p * gridSize));\n    float upperMix = mix(upperLeft, upperRight, st.x);\n    float lowerMix = mix(lowerLeft, lowerRight, st.x);\n    float finalMix = mix(upperMix, lowerMix, st.y);\n    \n\treturn finalMix;\n}\n\nfloat perlinNoise(vec2 p)\n{\n    float currentNoise = 0.0;\n    \n    // Add octaves\n    for(float i = 0.0; i < 5.0; i += 1.0)\n        currentNoise += perlinNoiseOctave(p*pow(2.0, i))/pow(2.0, i+1.0);\n    \n    // Returns value from 0 to 0.96875    \n    return currentNoise;\n}\n\nvec3 getCol(vec3 viewDir)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = viewDir.xy;\n    float lenUV = length(uv);\n    \n    // Red falloff\n    col = mix(vec3(0.8, 0.05, 0.05), col, lenUV);\n    \n    // Red shine\n    float redShineRadius = lenUV + perlinNoise(vec2((atan(uv.y, uv.x) + 4.0) * 1.0, iTime * 0.01)) * 0.8 + 0.1;\n    col = mix(vec3(0.8, 0.05, 0.05), col, clamp(redShineRadius, 0.0, 1.0));\n    \n    // Yellow shine\n    float yellowHaloRadius = \n        perlinNoise(vec2(cos(atan(uv.y, uv.x)), sin(atan(uv.y, uv.x))) + vec2(4.0, 2.0 + iTime * 0.05)) * \n        0.02 + 0.42;\n    vec3 shineCol = mix(vec3(0.95, 0.95, 0.3), vec3(0.7, 0.0, 0.0), clamp(lenUV * 7.0 - 2.7, 0.0, 1.0));\n    col += shineCol * smoothstep(yellowHaloRadius, yellowHaloRadius-0.03, lenUV);\n    \n    // Overinterpolate to keep colors around origin\n    col = mix(vec3(0.50, 0.98, 0.98), col, lenUV * 2.0);\n    \n    // Red sun halo\n    col = mix(col, vec3(0.8, 0.05, 0.05), smoothstep(0.41, 0.39, lenUV));\n    \n    // Moon shadow\n    float moonRadius = 0.38 + perlinNoise(vec2(sin(atan(uv.y, uv.x)) + 3.0, 0.0)) * 0.02;\n    col = mix(col, vec3(0.1, 0.02, 0.02), smoothstep(moonRadius, moonRadius - 0.04, lenUV));\n\n    // Fog\n    uv *= rotate(0.3);\n    col = mix(col, vec3(0.6, 0.2, 0.2), perlinNoise(uv + vec2(iTime * 0.05, 0.0) + vec2(4.0)) * pow(1.0 - uv.y*uv.y, 4.0) * 0.8 * min(lenUV*1.5, 1.0));\n    col = mix(col, vec3(0.6, 0.2, 0.2), perlinNoise(uv + vec2(iTime * 0.01, 0.0) + vec2(2.0)) * pow(1.0 - uv.y*uv.y, 4.0) * 0.8 * min(lenUV*1.5, 1.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 viewDir = normalize(vec3(uv, 0.3));\n    vec3 col = getCol(viewDir);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtK3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 107], [109, 109, 136, 136, 330], [332, 377, 409, 409, 465], [467, 506, 536, 536, 665], [667, 667, 700, 700, 1361], [1363, 1363, 1390, 1390, 1635], [1637, 1637, 1664, 1664, 3187], [3189, 3189, 3246, 3246, 3429]], "test": "valid"}
{"id": "NtK3Ww", "name": "Fork spiraling  hypnothala 777", "author": "hypnothalamus", "description": ".", "tags": ["spiral", "conformal", "polar"], "likes": 7, "viewed": 214, "published": "Public API", "date": "1637810787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ORIGINAL\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U = (U+U-R)/R.y; \n    \n    // Number of divisions of the circle\n    #ifdef ORIGINAL\n        float Q = 6.;\n    #else\n        float Q = 10. + 5.*sin(iTime);\n    #endif\n\n    U = vec2((1.+atan(U.y,U.x)/3.1416)*Q/2.,log(length(U))); // conformal polar\n    // multiply U for smaller tiles\n\n    U.y += U.x/Q; // comment for concentric circles instead of spiral\n    \n    // N is the counter - increasing towards the center\n    float N = floor(1.-U.y) * Q + floor(U.x);\n    \n    O.x = floor(N)/32.; // for display purposes only\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtK3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 58, 58, 608]], "test": "valid"}
{"id": "NtKGRy", "name": "starhex", "author": "callistabee", "description": "tessellation experiment", "tags": ["geometry"], "likes": 3, "viewed": 51, "published": "Public", "date": "1637969118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R vec3(1,0,0)\n#define G vec3(0,1,0)\n#define B vec3(0,0,1)\n#define W vec3(1,1,1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // number of hex cells on the screen\n    float resolution = 100.0f;\n    \n    // cartesian coordinates\n    vec2 xy = fragCoord / iResolution.xy - 0.5;    \n    \n    // axial coordinates [https://www.redblobgames.com/grids/hexagons/]\n    vec3 qrs = vec3(\n        resolution * (xy.x + xy.y),\n        resolution * (xy.x - xy.y),\n        -resolution * xy.x * 2.0f\n    );\n    \n    // star tessellation\n    vec3 grid = cos(qrs);\n    float magnitude = dot(grid, grid) / 3.0f;\n    \n    // random wave generator\n    vec3 col;\n    \n    // number of centers\n    int n = 20;\n    \n    // for each center...\n    for (int i = 0; i < n; ++i) {\n    \n        // sample random Q and R coordinates from noise buffer\n        float randQ = resolution * (texture(iChannel0, vec2(i,0)/float(n)).r - 0.5);\n        float randR = resolution * (texture(iChannel0, vec2(0,i)/float(n)).r - 0.5);\n        \n        // sample random frequency modifier\n        float randF = texture(iChannel0, vec2(i,i)/float(n)).r - 0.5;\n        \n        // Q + R + S = 0\n        vec3 center = vec3(randQ, randR, -randQ - randR);\n        \n        // cycle colors\n        vec3 C;\n        switch(i % 3) {\n            case 0:\n                C = R; break;\n            case 1:\n                C = G; break;\n            case 2:\n                C = B; break;\n        }\n        \n        \n        // compute wavefront at current point\n        col += C * sin(randF * length(qrs - center) + iTime);\n        \n    }\n    \n    // multiply waves with hex grid for nice effect\n    fragColor = vec4(col * magnitude, 1.0);\n\n           \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 146, 188, 1720]], "test": "error"}
{"id": "NtKGWw", "name": "Wavey mc wavavey face", "author": "feresr", "description": "Having fun", "tags": ["waves", "colorful", "wallpaper"], "likes": 2, "viewed": 47, "published": "Public", "date": "1637807872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed = .2;\n\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = rotateUV(fragCoord, 0.5, iResolution.xy/2.0)/iResolution.xy;\n\n    // Output to screen\n    if (uv.y + sin(iTime) * 0.05 > .85 + 0.1 * (cos((uv.x + iTime * speed) * 3.15 * 5.0))) {\n        vec3 col = 0.5 + 0.5*cos(1.01 * iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col,1.0);\n    } else if (uv.y + cos(iTime) * 0.05 > .6 + 0.1 * (cos((uv.x + iTime * speed * 0.998) * 3.15 * 5.0))) {\n        vec3 col = 0.5 + 0.5*cos(1.02 * iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col * .8,1.0);\n    } else if (uv.y + sin(iTime) * 0.05 > .40 + 0.1 * (cos((uv.x + iTime * speed * 0.996) * 3.15 * 5.0))) {\n        vec3 col = 0.5 + 0.5*cos(1.03 * iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col * .4,1.0);\n    } else if (uv.y + sin(iTime) * 0.05 > .15 + 0.1 * (cos((uv.x + iTime * speed * 0.994) * 3.15 * 5.0))) {\n        vec3 col = 0.5 + 0.5*cos(1.03 * iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col * .2,1.0);\n    }\n    else {\n        vec3 col = 0.5 + 0.5*cos(1.04 * iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col * .0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKGWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 69, 69, 252], [255, 255, 312, 362, 1433]], "test": "valid"}
{"id": "NttGRB", "name": "superstarfield", "author": "origo_", "description": "stars", "tags": ["stars"], "likes": 10, "viewed": 103, "published": "Public", "date": "1636296704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 RotZ(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(137.337, 13333.37));\n    p += dot(p, p+45.138);\n    return fract(p.x*p.y);\n}\n\nfloat ray(vec2 uv) {\n    return max(0.0, 1.0-abs(uv.x*uv.y*5000.0));\n}\n\nvec3 star(vec2 uv, vec2 id) {\n    float n = Hash21(id)/3.0;\n    uv -= vec2(n, fract(n*33.3))-.5 ;\n    float d = length(uv);\n    float size = (1.0+sin((n*iTime)/5.0));\n    float m = .001/d * size;\n\n    for(int i=0; i < 3; i++) {\n        uv *= RotZ(0.33*iTime+float(i)+id.x*id.y);\n        float f = (1.0+sin(iTime+id.x*id.y+float(i)/4.0))/2.0;\n        f = smoothstep(0.59, 0.05, f);\n        m += ray(uv)*f*0.3;\n    }\n  //  m = 1.0-smoothstep(0.5, 0.1, m);\n    \n    vec3 color = sin(vec3(.2, .3, .9)*fract(n*1337.37)*333.7)*.5+.5;\n    float glow = 0.33+sin(id.x*id.y*313.37+6.0*iTime/4.0)/2.0;\n    glow = smoothstep(0.9, 0.1, glow)*0.1;\n    color = color*vec3(0.7,.4,1.+size) +\n        (glow*vec3(1.0));\n    return color*m;\n//    return vec3(m)*fract(n*1772.0);//+vec3(id*0.1, 0.0);\n}\n\n\nvec3 starLayer(vec2 uv) {\n    vec3 col = vec3(0);\n\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    for(int y=-1; y <= 1; y++) {\n        for(int x=-1; x <= 1; x++) {\n            vec2 offs = vec2(float(x), float(y));\n            col += star(gv-offs, id+offs);\n        }\n    }\n    return col;\n}\n\n#define NUM_LAYERS 5.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=34.0;\n    \n    uv.x += sin(iTime/4.0)-cos(iTime/3.0)*2.0;\n    uv.y += cos(iTime/4.0)-sin(iTime/3.0)*2.0;\n\n    uv *= RotZ(-iTime*0.1);\n\n    vec3 col = vec3(0);\n    float t = cos(iTime*0.1);\n    \n    for(float i=0.0; i < 1.0; i+=1./NUM_LAYERS) {\n        uv *= RotZ(i*8.0);\n        float depth = fract(i+t);\n        float scale = mix(0.5, 0.01, depth);\n        float fade = pow(depth, 2.1)+0.1;\n        col += starLayer(uv*scale+i*1.37)*fade;\n        //uv *= i;\n    }\n\n//    col.rg += id*0.1;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 110, 110, 208], [210, 210, 230, 230, 280], [282, 282, 311, 311, 1063], [1066, 1066, 1091, 1091, 1367], [1393, 1393, 1450, 1450, 2042]], "test": "valid"}
{"id": "NttGz4", "name": "2D SDF Slice", "author": "lGuy", "description": "Trippy looking shader in which we can only see a 2D slice of a 3D world in which there are SDF shapes.", "tags": ["sdf"], "likes": 1, "viewed": 54, "published": "Public", "date": "1635786881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 ortho( \n    float b, float t, float l, float r, \n    float n, float f){ \n    mat4 m = mat4(1.0);\n    \n    m[0][0] = 2.0 / (r - l); \n    m[0][1] = 0.0; \n    m[0][2] = 0.0; \n    m[0][3] = 0.0; \n \n    m[1][0] = 0.0; \n    m[1][1] = 2.0 / (t - b); \n    m[1][2] = 0.0; \n    m[1][3] = 0.0; \n \n    m[2][0] = 0.0; \n    m[2][1] = 0.0; \n    m[2][2] = -2.0 / (f - n); \n    m[2][3] = 0.0; \n \n    m[3][0] = -(r + l) / (r - l); \n    m[3][1] = -(t + b) / (t - b); \n    m[3][2] = -(f + n) / (f - n); \n    m[3][3] = 1.0;\n    \n    return m;\n} \n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = vec3(normalize(center - eye));\n    vec3 s = vec3(normalize(cross(f, up)));\n    vec3 u = vec3(cross(s, f));\n\n    mat4 m = mat4(1.0);\n    m[0][0] = s.x;\n    m[1][0] = s.y;\n    m[2][0] = s.z;\n    m[0][1] = u.x;\n    m[1][1] = u.y;\n    m[2][1] = u.z;\n    m[0][2] =-f.x;\n    m[1][2] =-f.y;\n    m[2][2] =-f.z;\n    m[3][0] =-dot(s, eye);\n    m[3][1] =-dot(u, eye);\n    m[3][2] = dot(f, eye);\n    \n    return m;\n}\n\n\nfloat sphere( vec3 p, vec3 center, float rad ) {\n    return length(p - center) - rad;\n}\n\nfloat roundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat torus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat boxFrame( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eyePos = vec3(sin(iTime), cos(iTime), sin(iTime)) * 0.5;\n    vec3 viewDir = vec3(cos(iTime), 0.0, sin(iTime));\n    vec3 upVector = vec3(0.0, sin(iTime), cos(iTime));\n\n    mat4 view = lookAt(eyePos, eyePos + viewDir, upVector);\n    float dim = 1.0;\n    mat4 projection = ortho(-dim, dim, -dim, dim, -dim, dim);\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec4 world = projection * view * vec4(p, 0.0, 1.0);\n    \n    float d = 1.e10;\n    \n    float s1 = sphere(world.xyz, vec3(0.0), 0.1);\n    float s2 = sphere(world.xyz, vec3(0.0, 0.0, -0.5 + sin(iTime) * 0.3), 0.1);\n    float u = smoothUnion(s1, s2, 0.1);\n    d = min(u, d);\n    \n    float rb1 = roundBox(world.xyz - vec3(0.5), vec3(0.6, 0.2, 0.7), 0.1);\n    u = smoothUnion(rb1, d, 0.1);\n    d = min(u, d);\n    \n    float t1 = torus(world.xyz - vec3(0.0), vec2(0.1, 0.1));\n    u = smoothUnion(t1, d, 0.1);\n    d = min(u, d);\n    \n    if (d < 0.3) {\n        fragColor = vec4(d * (1.0 / 0.3));\n    }\n    else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 528], [531, 531, 576, 576, 994], [997, 997, 1045, 1045, 1084], [1086, 1086, 1129, 1129, 1220], [1222, 1222, 1253, 1253, 1322], [1324, 1324, 1367, 1367, 1649], [1651, 1651, 1701, 1701, 1777], [1779, 1779, 1836, 1836, 2882]], "test": "valid"}
{"id": "NtV3RR", "name": "Rounded Tube SDF", "author": "TheTurk", "description": "Distance function for a rounded tube (where the size of the tube is not affected by the corner radius). ", "tags": ["3d", "distancefield", "sdf", "ring", "distance", "tube", "cylinder", "rounded", "primitive", "pipe", "hollow"], "likes": 4, "viewed": 53, "published": "Public", "date": "1637073828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tube(vec3 position, float innerRadius, float outerRadius, float halfHeight, float cornerRadius) {\n   vec2 d = vec2(length(position.xz) - (outerRadius + innerRadius) * 0.5, position.y);\n   d = abs(d) - vec2((outerRadius - innerRadius) * 0.5, halfHeight) + cornerRadius;\n   return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - cornerRadius;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat sdf(in vec3 position) { \n    float innerRadius = 0.25; \n    float outerRadius = 0.4;\n    float halfHeight = 0.1;\n    float cornerRadius = 0.05;\n    position = rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 2.094) * position;\n    float d = tube(position, innerRadius, outerRadius, halfHeight, cornerRadius);\n    return d;\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128 * 3;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 5.0);\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 103, 103, 348], [350, 350, 389, 389, 571], [573, 573, 627, 627, 968], [970, 970, 999, 999, 1296], [1298, 1298, 1326, 1326, 1671], [1673, 1673, 1723, 1723, 2109], [2111, 2111, 2166, 2166, 3672]], "test": "valid"}
{"id": "NtVGRD", "name": "Simple Metal Plates", "author": "InvalidString", "description": "A grid of overlapping metal plates", "tags": ["simple", "cheap", "metal"], "likes": 10, "viewed": 89, "published": "Public", "date": "1637312007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 plate(vec2 id, vec2 uv){\n    vec3 col = vec3(-1);\n    \n    \n    vec2 r = hash22(id);\n    float r2 = hash12(id);\n    \n    vec2 p = uv;\n    \n    p += r2;\n    \n    uv = abs(uv);\n    \n    vec2 dim = vec2(.6,.6) + r * .4;\n\n    if(uv.x < dim.x && uv.y < dim.y){\n        col = mix(vec3(.3, .3, .3), vec3(.7, .7, .7), r2) * 1. + 0.1 * texture(iChannel0, p).x;\n        \n        \n        if(length(uv - dim + vec2(.1)) < .05){\n            col = vec3(.4);\n        }\n        \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    uv *= 10.;\n\n    uv += iTime;\n\n\n    vec2 off = floor(uv);\n    \n    float depth = 0.;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            vec2 id = off + vec2(x,y);\n            float plateDepth = hash12(id + vec2(.5,.5));\n            vec3 c = plate(id, uv - id);\n            if(c != vec3(-1) && plateDepth > depth){\n                depth = plateDepth;\n                col = c;\n            }\n            \n        }\n    \n    }\n    \n    \n    \n\n\n    \n    \n    \n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGRD.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[0, 167, 188, 188, 322], [323, 323, 345, 345, 462], [465, 465, 494, 494, 962], [965, 965, 1022, 1022, 1638]], "test": "error"}
{"id": "NtVGWm", "name": "Light Voyage", "author": "ivatronx", "description": "Trigonometry Light Color Effect", "tags": ["lights", "trigonometry"], "likes": 2, "viewed": 27, "published": "Public", "date": "1637812534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy/iResolution.xy;\n  st.x *= (iResolution.x/0.45)/(iResolution.y/0.25);\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n  float d1 = 0.0;\n  float d2 = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Make the distance field\n  d = length( abs(st)-.003*atan(iTime) );\n  d1 = length( max(abs(st)-.09/sin(iTime*0.1),0.001) );\n  d2 = length( min(abs(st)-.09*tan(iTime*0.1),1.1) );\n  // Visualize the distance field\n  fragColor = vec4(vec3(abs(tan(d2/d1*2.0*d)),acos(sin(d2/d1*10.0*d)),tan(d2/d1*13.0*d)),1.0);\n\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 647]], "test": "valid"}
{"id": "NtVGz3", "name": "spqr: tube 4", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 0, "viewed": 38, "published": "Public API", "date": "1638098625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\nfloat trig (float t) {\n\n  \n  \n  \n   float wave = 0.;\n   for (float i = 0.; i < 5.; i++) {\n       wave += sin(i * .19 + rnd(i) * t);\n       wave += cos(-i * .99 + rnd(i + 1.13) * t);\n       \n   }\n \n \n  \n  return wave;\n  \n}\nvec3 wave (float t) {\n    float x = trig(t);\n    float y = trig(t + 171.321);\n    float z = trig(t + 471.341);\n    \n    return vec3(x,y,z);\n    \n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\nvec3 s;\nint matter = 0;\n\nvec3 probe;\nfloat map(vec3 p) {\n\n// geo\n \n\n  // tunell\n  float minimum = 6.74;\n  float seper = .74;\n  \n  float hole1 = -cyl(p.xy,minimum + 0. * seper);\n  float wall1 = cyl(p.xy, minimum + .2 * seper);\n  float tunnel1 = max(hole1,wall1);\n  \n  \n  float hole2 = -cyl(p.xy,minimum + 8. * seper);\n  float wall2 = cyl(p.xy, minimum + 8.2 * seper);\n  float tunnel2 = max(hole2,wall2);\n  \n  float hole3 = -cyl(p.xy,minimum + 16. * seper);\n  float wall3 = cyl(p.xy, minimum + 16.2 * seper);\n  float tunnel3 = max(hole3,wall3);\n  \n  \n  float tunnel = min(min(tunnel1, tunnel2),tunnel3);\n  \n  matter = 1;\n  return tunnel;\n  \n  /*\n  float ball = sph(p - probe, 1.);\n\n \n  float final = min(ball,tunnel);\n  \n  if ( tunnel == final) {\n      matter = 1;\n  }\n  if ( ball == final) {\n      matter =2;\n  }\n  return final;\n  */\n\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\n\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nfloat intersect(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n\n       float granularity = 20. ;\\\n       \n       float z = decal(p  * granularity, domain );\n       if (  z < 4.5) {\n          d = .1;\n       } else {\n         shad=0.0;\n         break;\n       }\n    }\n   \n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\nvec3 vollight ( vec3 lightpos, vec3 s, vec3 r, vec2 uv, float limit) {\n\n  float rand=rnd(uv);\n  \n  \n  const int volsteps=120; //50\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>limit) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = intersect(lp, lv, ldistvol, 10, 0.01);\n    atcol += 5./(0.01+(pow(ldistvol,2.))) * shadvol;\n   \n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n  return atcol;\n}\n\n\n\n\n\nvec3 nav_source (float tt ) {\n//  vec3 source = lattice(tt + 53.1) * 39.3 ;\n  vec3 source = bezier(tt + 53.1) * 39.3 ;\n\n  \n  return source;\n}\nvec3 nav_target (float tt ) {\n  //vec3 target = lattice(tt+1.) * 19.;\n  vec3 target = bezier(tt+1.) * 19.;\n\n  \n  return target;\n}\n\n\n \nfloat factor (float t) {\n    return (atan(40. * sin(t))/atan(40.)) * .5 + .5;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n    \n   // one \n   \n   \n   float tt = 133.191 + iTime *.3 ;\n\n   tt = tt + sin(tt)  + tt * .1;\n   vec3 source = nav_source(tt) ;\n   vec3 target = nav_target(tt) ;\n \n   source.z += 22. * tt;\n   target.z += 22. * tt;\n \n   \n   \n  // probe =  vec3(0,0, sin(iTime * .91 + 1.5) * 74. + source.z);\n   \n\n \n  vec3 cz=normalize(target-source);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  //r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=source;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  float granularity = 20. ;\n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n       \n      i = decal(p  * granularity, domain );\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p  * granularity, domain );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(.8,.4,.2);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n\n \n \n //vec3 atcol = vollight(probe, source , r, uv, dd);\n //col += atcol * .5;\n \n \n \n \n //vec3 atcol = vollight(probe, s, r, uv, dd);\n //col += atcol * .1;\n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n*/\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 314, 314, 383], [385, 385, 407, 407, 454], [456, 456, 485, 485, 533], [536, 536, 583, 583, 629], [631, 631, 650, 650, 1209], [1211, 1211, 1253, 1253, 1360], [1362, 1362, 1386, 1386, 1448], [1487, 1487, 1515, 1515, 1960], [1966, 1966, 1994, 1994, 2625], [2647, 2647, 2674, 2674, 3293], [3333, 3333, 3356, 3356, 3471], [3607, 3607, 3630, 3630, 3708], [3710, 3710, 3744, 3838, 4230], [4236, 4236, 4263, 4263, 4331], [4333, 4333, 4361, 4361, 4385], [4386, 4386, 4415, 4415, 4502], [4505, 4505, 4533, 4533, 4559], [4561, 4561, 4589, 4589, 4622], [4625, 4625, 4672, 4672, 4718], [4722, 4722, 4763, 4763, 4931], [4934, 4934, 4955, 4955, 5246], [5248, 5248, 5267, 5267, 5375], [5376, 5376, 5396, 5396, 5439], [5440, 5440, 5462, 5462, 5661], [5662, 5662, 5683, 5683, 5808], [5810, 5810, 5849, 5849, 5926], [5928, 5928, 5964, 5964, 6042], [6044, 6044, 6064, 6064, 6158], [6161, 6161, 6185, 6185, 6240], [6244, 6244, 6265, 6265, 6314], [6316, 6316, 6341, 6341, 6810], [6812, 6812, 6832, 6832, 7016], [7018, 7018, 7041, 7041, 7167], [7205, 7205, 7224, 7247, 8005], [8007, 8007, 8071, 8071, 8353], [8356, 8356, 8375, 8375, 8494], [8496, 8496, 8537, 8537, 8583], [8585, 8585, 8621, 8621, 8666], [8670, 8670, 8689, 8689, 8768], [8774, 8774, 8847, 8847, 9096], [9100, 9100, 9176, 9176, 9596], [9599, 9599, 9669, 9669, 10250], [10256, 10256, 10285, 10331, 10397], [10398, 10398, 10427, 10467, 10527], [10532, 10532, 10556, 10556, 10616], [10619, 10619, 10676, 10676, 12719]], "test": "valid"}
{"id": "NtVGzm", "name": "Frozen pond surface", "author": "jarble", "description": "An icy fractal pattern.", "tags": ["fractal", "ice", "frost"], "likes": 4, "viewed": 124, "published": "Public API", "date": "1637382829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 6\nconst float scale = 2.7;\nconst float scale1 =-1.175;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale+uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.x /= scale1*(1.-1./5.);\n            //uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 833]], "test": "valid"}
{"id": "Nty3Rc", "name": "Domain Repetition Tests", "author": "Drakyen", "description": "I've been messing with bounded domain repetition lately, and decided to see how far I could take it.\nThis entire scene is made from a single cuboid evaluation (ignoring the bound evaluations)", "tags": ["3d", "raymarching", "domainrepetition"], "likes": 6, "viewed": 81, "published": "Public", "date": "1638043582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a)) \n\nfloat bx(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.) + length(max(q,0.));\n}\n\nfloat mp(vec3 p)\n{\n\n    float xID1 = p.x; //Calculate ID for rotation direction\n    float xR1 = xID1 > 0. ? 1. : -1.;\n    \n    p.x = abs(p.x) - 8.5; //Domain repeat\n    \n    float b4 = bx(p, vec3(8.3,14,14)); //Bound 4 (32-cuboid sets)\n    b4 = abs(b4) + 0.1;\n    \n    p.yz *= rot(iTime * xR1); //Rotate\n\n    //--------\n\n    float zID0 = p.z; //Calculate ID for rotation direction\n    float zR0 = zID0 > 0. ? 1. : -1.;\n    \n    p.z = abs(p.z) - 6.5; //Domain repeat\n    \n    float b3 = bx(p, vec3(9,9,6.3));  //Bound 3 (16-cuboid sets)\n    b3 = abs(b3) + 0.1;\n    \n    p.xy *= rot(iTime * zR0); //Rotate\n\n    //--------\n\n    float yID1 = p.y; //Calculate ID for rotation direction\n    float yR1 = yID1 > 0. ? 1. : -1.;\n    \n    p.y = abs(p.y) - 3.5; //Domain repeat\n    \n    float b2 = bx(p, vec3(7,3.3,7)); //Bound 2 (8-cuboid sets)\n    b2 = abs(b2) + 0.1;\n    \n    p.xz *= rot(iTime * yR1); //Rotate\n    \n    //--------\n    \n    float xID0 = p.x; //Calculate ID for rotation direction\n    float xR0 = xID0 > 0. ? 1. : -1.;\n    \n    p.x = abs(p.x) - 3.5; //Domain repeat\n    \n    float b1 = bx(p, vec3(3.3,5,5)); //Bound 1 (4-cuboid sets)\n    b1 = abs(b1) + 0.1;\n    \n    p.yz *= rot(iTime * xR0); //Rotate\n\n    //--------\n    \n    float yID0 = p.y; //Calculate ID for rotation direction.\n    float yR0 = yID0 > 0. ? 1. : -1.;\n    \n    p.y = abs(p.y) - 1.5; //Domain repeat.\n    \n    float b0 = bx(p, vec3(3,1.3,3)); //Bound 0 (2-cuboid pairs)\n    b0 = abs(b0) + 0.1;\n    \n    p.xz *= rot(iTime * yR0); //Rotate\n    \n    //--------\n    \n    float c0 = bx(p, vec3(2,1,1)); //Actual cuboid that's being rendered\n    c0 = min(b0, c0); //bound it..\n    c0 = min(b1, c0); //bound it...\n    c0 = min(b2, c0); //bound it again..\n    c0 = min(b3, c0); //and again...\n    c0 = min(b4, c0); //and again....\n\n    return c0; //return cube distance\n}\n\nfloat tr(vec3 ro, vec3 rd) //ultra basic raymarcher\n{\n    float d = 0.;\n    for(int i = 0; i < 512; i++)\n    {\n        float s = mp(ro + rd * d);\n        d += s;\n        if(s < 0.01 || d > 64.) break;\n    }\n    return d;\n}\n\nvec3 nm(vec3 p) //standard 3-tap normal calculation, inlined\n{\n    vec2 e = vec2(0.001,0); return normalize(mp(p) - vec3(mp(p - e.xyy),mp(p - e.yxy),mp(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n   \n    vec3 ro = vec3(0,0,-25);\n    ro.xz *= rot(iTime/2.);\n    \n    //some camera look direction code i grabbed real quick so I can easily move the camera around\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    \n    float h = tr(ro,rd); //distance\n    vec3 p = ro + rd * h; //position\n    \n    if(h < 64.) //lighting\n    {\n        vec3 n = nm(p);\n        vec3 l = vec3(0.5, 0.6, 0.7);\n        \n        float diff = length(n*l); //ultra basic tri-planer-axis-lighting-stuff idk but it works well\n\n        fragColor = vec4(diff);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 81, 81, 170], [172, 172, 190, 190, 2010], [2012, 2012, 2065, 2065, 2234], [2236, 2236, 2298, 2298, 2403], [2405, 2405, 2462, 2462, 3191]], "test": "valid"}
{"id": "Nty3Rw", "name": "il4fs", "author": "shigi242", "description": "il4fs", "tags": ["tag"], "likes": 1, "viewed": 22, "published": "Public", "date": "1637326373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y = uv.y * uv.y;\n    uv.x = uv.y * uv.y;\n        \n    uv.y += sin(iTime);\n    uv.y = mod(uv.y, 0.1);\n    \n    uv.y = step(0.04, uv.y);\n    \n    if(uv.y < 0.01){\n        fragColor = vec4(uv.x);\n        return;\n    }\n    \n    vec3 col = vec3(uv.y);\n    \n    \n    fragColor = uv.y *  vec4(uv + sin(iTime), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 425]], "test": "valid"}
{"id": "Nty3Ry", "name": "Plotting by dmc3105", "author": "dmc3105", "description": "my first shader", "tags": ["math"], "likes": 1, "viewed": 94, "published": "Public API", "date": "1637939210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixelsPerSegment = pow(1.2, iTime+ 15.0);\n    float axisThickness = 2.0;\n    float gridThickness = 3.0;\n    float graficThickness = 5.0;\n    \n    vec2 inp = (fragCoord - iResolution.xy * 0.5)/ pixelsPerSegment ;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float x = inp.x;\n    float y = sin(x);\n    \n    \n    vec3 col = vec3(1.0);\n    graficThickness *= 0.5;\n    // draw grid\n    float startX = fragCoord.x - center.x + gridThickness * 0.5;\n    if (startX - (float(int((startX) / pixelsPerSegment))\n        * pixelsPerSegment)<= gridThickness &&\n        fragCoord.x > center.x)\n        col = vec3(0.9);\n    startX = fragCoord.x - center.x - gridThickness * 0.5;\n    if (abs(startX - (float(int((startX) / pixelsPerSegment)))\n        * pixelsPerSegment) <= gridThickness &&\n        fragCoord.x < center.x)\n        col = vec3(0.9);\n    float startY = fragCoord.y - center.y + gridThickness * 0.5;\n    if (startY - (float(int((startY) / pixelsPerSegment))\n        * pixelsPerSegment)<= gridThickness &&\n        fragCoord.y > center.y)\n        col = vec3(0.9);\n    startY = fragCoord.y - center.y - gridThickness * 0.5;\n    if (abs(startY - (float(int((startY) / pixelsPerSegment)))\n        * pixelsPerSegment) <= gridThickness &&\n        fragCoord.y < center.y)\n        col = vec3(0.9);\n        \n        \n\n    //draw axis\n    if (abs(iResolution.x * 0.5 - fragCoord.x) <= axisThickness ||\n        abs(iResolution.y * 0.5 - fragCoord.y) <= axisThickness )\n    {\n        col = vec3(0.0);\n    }\n    \n    \n    \n    // draw function\n    if (pow((pow(inp.y - y, 2.0) + pow(inp.x - x, 2.0)), 0.5) < graficThickness / pixelsPerSegment)\n    {\n        col = vec3(0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "Nty3W1", "name": "Ext. Lissajous (accurate)", "author": "vec5", "description": "Accurate parametric curve", "tags": ["curve", "lissajous", "parametric"], "likes": 6, "viewed": 99, "published": "Public", "date": "1637575918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI         3.14159265358979\n#define SAMPLES    2048\n#define ITERATIONS 4\n\nfloat Sign(vec2 p, vec3 abc, float t)\n{\n  float a  = abc.y * t;\n  float b  = abc.z + t;\n  float e  = exp(-abc.x * t);\n  \n  vec2  A  = vec2(e     , -abc.x * e     );\n  vec2  B  = vec2(cos(a), -abc.y * sin(a));\n  vec2  C  = vec2(sin(b),          cos(b));\n  \n  vec2  q0 = vec2(A.x * B.x            , A.x * C.x            );\n  vec2  q1 = vec2(A.y * B.x + A.x * B.y, A.y * C.x + A.x * C.y);\n  vec2  pq = p - q0;\n  \n  return sign(dot(pq, q1));\n}\n\nvec3 Func(vec2 p, vec3 abc, float t)\n{\n  float a  = abc.x, aa = a * a;\n  float b  = abc.y, bb = b * b;\n  float c  = abc.z, cc = c * c;\n  float d  = exp(-a * t);\n  vec2  e  = vec2(sin(b * t), cos(b * t));\n  vec2  f  = vec2(sin(t + c), cos(t + c));\n  \n  vec3  A  = vec3(d  , -a * d  ,  aa * d  );\n  vec3  B  = vec3(e.y, -b * e.x, -bb * e.y);\n  vec3  C  = vec3(f.x,      f.y, -     f.x);\n  \n  vec2  q0 = vec2(A.x * B.x                             , A.x * C.x                             );\n  vec2  q1 = vec2(A.y * B.x +      A.x * B.y            , A.y * C.x +      A.x * C.y            );\n  vec2  q2 = vec2(A.z * B.x + 2. * A.y * B.y + A.x * B.z, A.z * C.x + 2. * A.y * C.y + A.x * C.z);\n  vec2  pq = p - q0;\n  \n  return vec3(dot(pq, q1), dot(pq, q2) - dot(q1, q1), length(pq));\n}\n\nfloat Lissajous(vec2 p, vec3 abc)\n{\n  float dt, t, s0, s1, dist;\n  vec3  func;\n  int   i, j;\n  \n  dt   = 64. * PI / float(SAMPLES - 1);\n  s0   = Sign(p, abc, 0.);\n  dist = Func(p, abc, 0.).z;\n  \n  for(i = 1; i < SAMPLES; ++i)\n  {\n    s1 = Sign(p, abc, float(i) * dt);\n    \n    if(s0 == s1)\n      continue;\n    \n    s0   = s1;\n    func = Func(p, abc, t = (float(i) - .5) * dt);\n   \n    for(j = 0; j < ITERATIONS; ++j)\n      func = Func(p, abc, t -= func.x / func.y);\n    \n    if(func.z < dist)\n      dist = func.z;\n  }\n  \n  return dist;\n}\n\nvoid mainImage(out vec4 C, in vec2 P)\n{\n    vec2 r = iResolution.xy * .5;\n    vec2 p = (P - r)/r.y;\n\n    float intensity = 2e-3 / Lissajous(1.1 * p, vec3(1./81., 2./3., iTime));\n    float gamma     = pow(intensity, 1.0/2.2);\n    \n    C = vec4(vec3(0., gamma, 0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 121, 121, 521], [523, 523, 561, 561, 1300], [1841, 1841, 1880, 1880, 2111]], "test": "valid"}
{"id": "NtyGRV", "name": "kc-intro", "author": "wzdd", "description": "blurred moving shapes with noise", "tags": ["gradient", "shapes"], "likes": 3, "viewed": 34, "published": "Public", "date": "1637958216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float blurredSphere(in vec2 uv, in float size)\n{\n    return pow(max(size - length(uv), 0.), 1.2);\n}\n\nvec2 journey(in vec2 uv, in vec2 start, in vec2 delta)\n{\n    return uv + fract(start + (delta * iTime)) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord-0.5);\n    \n    vec3 noise = texelFetch( iChannel0, p % ivec2(iChannelResolution[0].xy), 0 ).xyz;\n    \n    vec3 tex = vec3(0.2, 0.1, 0.4) + (noise / 9.);\n\n    // Non-aspected corrected:\n    vec2 uv = fragCoord/iResolution.xy; // 0..1\n\n    // Aspect-corrected\n    // vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    \n    uv -= 0.5; // -0.5 .. 0.5\n\n    tex += vec3(0.3, 0.6, 0.8) * blurredSphere(journey(uv, vec2(0.3, 0.3), vec2(0.015, -0.2)), 0.4);\n\n    tex += vec3(1., 0.5, 0.9) * blurredSphere(journey(uv, vec2(0., 0.1), vec2(-0.01, 0.015)), 0.3);\n\n    tex += vec3(0.8, 1., 0.8) * blurredSphere(journey(uv, vec2(-0.3, -0.3), vec2(-0.02, -0.02)), 0.35);\n\n    tex += vec3(1., 0.4, 0.0) * blurredSphere(journey(uv, vec2(0.2, 0.5), vec2(0.03, 0.009)), 0.25);\n\n    fragColor = vec4(tex, 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 99], [101, 101, 157, 157, 213], [215, 215, 272, 272, 1104]], "test": "error"}
{"id": "NtyGRW", "name": "Persian carpet 26", "author": "jarble", "description": "More experiments with fractal carpet designs.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 114, "published": "Public API", "date": "1637202015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            vec2 t2 = vec2(0.);\n            vec2 t3 = vec2(0.);\n            for(int k = 0; k < 3; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                //uv *= bend-col.x;\n                //uv += t2.yx/scale;\n                t2 = triangle_wave(uv.yx-offset,scale);\n                t3 = triangle_wave(uv,scale);\n                uv.yx = t2/bend+t3*bend;\n                //uv.yx = triangle_wave(uv.yx-offset/1.5,scale)*bend-triangle_wave(uv-offset,scale)/bend;\n\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                uv += vec2(random1[k],random2[k]);  \n                bend *= -1.;\n                bend -= 1./3.-col.x;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2687]], "test": "valid"}
{"id": "sdjXRy", "name": "Distance to Cubic Bezier", "author": "oneshade", "description": "Numerically calculating the euclidean distance to a cubic bezier curve.", "tags": ["2d", "bezier", "distance", "cubic", "numerical"], "likes": 22, "viewed": 141, "published": "Public", "date": "1636757868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 posBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv + b * 3.0 * t * tInv * tInv + c * 3.0 * tInv * t * t + d * t * t * t;\n}\n\n// https://www.shadertoy.com/view/st33Wj\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nint solveQuintic(in float a, in float b, in float c,\n    in float d, in float e, in float f, out float[5] realRoots) {\n    float p = (5.0 * a * c - 2.0 * b * b) / (5.0 * a * a);\n    float q = (25.0 * a * a * d - 15.0 * a * b * c + 4.0 * b * b * b) / (25.0 * a * a * a);\n    float r = (125.0 * a * a * a * e - 50.0 * a * a * b * d + 15.0 * a * b * b * c - 3.0 * b * b * b * b) / (125.0 * a * a * a * a);\n    float s = (3125.0 * a * a * a * a * f - 625.0 * a * a * a * b * e + 125.0 * a * a * b * b * d - 25.0 * a * b * b * b * c + 4.0 * b * b * b * b * b) / (3125.0 * a * a * a * a * a);\n\n    float bound = 1.0 + max(1.0, max(abs(p), max(abs(q), max(abs(r), abs(s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5;\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0);\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound;\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound;\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound;\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound;\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(p, 0.0), z) + vec2(q, 0.0), z) + vec2(r, 0.0), z) + vec2(s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    int numRealRoots = 0;\n    float offs = b / (5.0 * a);\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            realRoots[numRealRoots] = z.x - offs;\n            numRealRoots++;\n        }\n    }\n\n    return numRealRoots;\n}\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec4 sdCubicBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float qa = 3.0 * dot(a, a);\n    float qb = 5.0 * dot(a, b);\n    float qc = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float qd = 3.0 * (dot(b, c) + dot(d, a));\n    float qe = dot(c, c) + 2.0 * dot(d, b);\n    float qf = dot(d, c);\n\n    float distSq = dot2(p - v1);\n    float tNear = 0.0;\n    vec2 pNear = v1;\n\n    float distSq2 = dot2(p - v4);\n    if (distSq2 < distSq) {\n        distSq = distSq2;\n        tNear = 1.0;\n        pNear = v4;\n    }\n\n    float[5] roots;\n    int numRoots = solveQuintic(qa, qb, qc, qd, qe, qf, roots);\n    for (int n=0; n < numRoots; n++) {\n        float t = roots[n];\n        if (0.0 < t && t < 1.0) {\n            vec2 pos = posBezier(v1, v2, v3, v4, t);\n            float distSq2 = dot2(p - pos);\n            if (distSq2 < distSq) {\n                distSq = distSq2;\n                pNear = pos;\n                tNear = t;\n            }\n        }\n    }\n\n    return vec4(pNear, tNear, sqrt(distSq));\n}\n\n/*\n// Plain and simple version (nearest point and parameter are not recorded)\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdCubicBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float qa = 3.0 * dot(a, a);\n    float qb = 5.0 * dot(a, b);\n    float qc = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float qd = 3.0 * (dot(b, c) + dot(d, a));\n    float qe = dot(c, c) + 2.0 * dot(d, b);\n    float qf = dot(d, c);\n\n    float[5] roots;\n    int numRoots = solveQuintic(qa, qb, qc, qd, qe, qf, roots);\n    float distSq = min(dot2(p - v1), dot2(p - v4));\n    for (int n=0; n < numRoots; n++) {\n        float t = roots[n];\n        if (0.0 < t && t < 1.0) {\n            distSq = min(distSq, dot2(p - posBezier(v1, v2, v3, v4, t)));\n        }\n    }\n\n    return sqrt(distSq);\n}\n*/\n\n// For visualizing the distance mnimizing quintic\nfloat sdMinimizerPoly(in vec2 pos, in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float t5 = 3.0 * dot(a, a);\n    float t4 = 5.0 * dot(a, b);\n    float t3 = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float t2 = 3.0 * (dot(b, c) + dot(d, a));\n    float t1 = dot(c, c) + 2.0 * dot(d, b);\n    float t0 = dot(d, c);\n\n    float y = ((((t5 * pos.x + t4) * pos.x + t3) * pos.x + t2) * pos.x + t1) * pos.x + t0;\n    float dx = (((5.0 * t5 * pos.x + 4.0 * t4) * pos.x + 3.0 * t3) * pos.x + 2.0 * t2) * pos.x + t1;\n\n    return abs(pos.y - y) / sqrt(1.0 + dx * dx);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 3.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n    float time = iTime;//610.94;\n\n    float t1 = time * 0.5, t2 = time, t3 = time * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    /*\n    vec2 a = vec2(-1.0, -0.75);\n    vec2 b = vec2(s1, s2);\n    vec2 c = vec2(c3, c1);\n    vec2 d = vec2(1.0, -0.75);\n    */\n\n    vec2 a = vec2(c2 * 0.5, s3);\n    vec2 b = vec2(-2.0, 1.0);\n    vec2 c = vec2(2.0, 1.0);\n    vec2 d = vec2(s2 * 0.5, c3);\n\n    float sdf = sdCubicBezier(uv, a, b, c, d).w - 0.1;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(sdf) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(sdf));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * sdf);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(sdf)));\n\n    // Hull\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, a, b) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, b, c) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, c, d) - 0.01));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - a) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - b) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - c) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - d) - 0.03));\n\n    // Draw shortest segment between the mouse and curve\n    vec3 nearest = sdCubicBezier(mouse, a, b, c, d).xyz;\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, mouse, nearest.xy) - 0.01));\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.05));\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv - nearest.xy) - 0.05));\n\n    // Draw the distance minimizing quintic for the mouse position\n    //color = mix(color, vec3(0.0, 0.5, 1.0), smoothstep(unit, 0.0, sdMinimizerPoly(uv, mouse, a, b, c, d) - 0.001));\n    //color = color = mix(color, vec3(0.0), smoothstep(unit, 0.0, length(uv - vec2(nearest.z, 0.0)) - 0.03));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 204], [206, 247, 280, 280, 313], [314, 314, 347, 347, 394], [2447, 2447, 2470, 2470, 2490], [4779, 4829, 4924, 4954, 5641], [5643, 5643, 5690, 5690, 5798], [5800, 5800, 5855, 5855, 8226]], "test": "valid"}
{"id": "sdl3WM", "name": "Ray Bender", "author": "kick", "description": "Bending camera rays by treating them as particles whose velocity is affected by their pseudo-mass, their normal trajectory in the 3d camera plane. The spheres are the gravity \"nodes\".  Three iterations is enough for the simulation to get smooth results.", "tags": ["analytic", "gravity", "raybending"], "likes": 8, "viewed": 216, "published": "Public API", "date": "1636898814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define ut (iTime * 1.)\n#define n(x) normalize(x)\n#define l(x) length(x)\n#define f(x) fract(x)\n#define v3 vec3(0)\n#define sb 0.5\n#define rv(x) (vec2(cos(x),sin(x)))\n\n#define USE_TEXTURE\n\nfloat t;\nvec2 m, tc1, tc2, tc3;\n\nfloat pD(vec3 ro,vec3 rd,vec4 p) {\n\treturn -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec4 pI(vec3 ro,vec3 rd,vec4 p) {\n\tfloat d=pD(ro,rd,p);\n\treturn vec4(ro+rd*d,d);\n}\n\nfloat sD(vec3 ro,vec3 rd,vec4 sph) {\n\tvec3 oc=ro-sph.xyz;\n\tfloat b=dot(oc,rd), c=dot(oc,oc)-sph.w*sph.w, h=b*b-c;\n\tif(h<0.0) return -1.0;\n\treturn -b-sqrt(h);\n}\n\nvec4 sI(vec3 ro,vec3 rd,vec4 sph) {\n\tvec4 i=vec4(-1.);\n\tfloat d=sD(ro,rd,sph);\n\tif(d > 0.) { i.xyz=ro+rd*d; i.w=d; }\n\treturn i;\n}\n\nvec4 pl, pl2, s, s2;\n\nvoid cv(inout vec3 pos,inout vec3 vel) {\n\tvec3 h=s.xyz-pos,h2=s2.xyz-pos;\n\tvel+=n(h)/dot(h,h)+n(h2)/dot(h2,h2); pos+=vel;\n}\n\nvec4 i2p(vec3 ro,inout vec3 v) {\n\tvec3 pos=ro;\n\tcv(pos,v); cv(pos,v); cv(pos,v);\n\tcv(pos,v); cv(pos,v); cv(pos,v);\n\treturn pI(ro,n(v),pl);\n}\n\nvec3 pal(float t) {\n\t// return vec3(1.);\n\tt=(t-ut*0.08);\n\treturn abs(vec3(0.5,0,0.5)+0.5*cos(15.*(1.*t+vec3(0,0.33,0.67))));\n}\n\n// vec3 pal(float t) {\n// \treturn (0.5+0.5*cos(3.*(1.*t+vec3(0,0.33,0.67))));\n// }\n\nfloat tex(vec2 uv) {\n#ifdef USE_TEXTURE\n    return dot(texture(iChannel0,uv*0.25).rgb,vec3(0.333));\n#else    \n\treturn mix(1.-l(f(uv)*2.-1.),0.25,min(l(fwidth(uv)),1.));\n#endif\n}\n\nvec3 pC(vec4 pi, vec4 p) {\n\tvec3 c=vec3(0);\n\tif(pi.w<0.) return c;\n\tc += tex(pi.xy+vec2(t,tc1.y)*vec2(sign(pi.z)));\n\tpi.w=dot(n(vec3(0,0,1)),n(vec3(pi.xy,1)));\n\tc *= pal(f(-pi.w));\n\tfloat sl=1./min(pow(sD(pi.xyz,n(s.xyz-pi.xyz),s),2.),10.);\n\tfloat sl2=1./min(pow(sD(pi.xyz,n(s2.xyz-pi.xyz),s2),2.),10.);\n\tc *= (sl+sl2)*1.;\n\tif(p==pl) c+=pow(dot(n(vec3(pi.xy,1)),pl.xyz),16.);\n\t// c *= pow(pi.w,0.5);\n\treturn pow(c,vec3(0.666));\n}\n\nvoid pR(inout vec2 p,float a) {\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec3 sC(vec4 sp,vec4 si,vec3 ro) {\n\tvec3 sc=v3, c, c2;\n\tvec3 n=n(si.xyz-sp.xyz),ci=n(si.xyz-ro);\n\tvec3 lp=0.-(pl.xyz*pl.w),l=n(lp-si.xyz);\n\tsc += max(0.,dot(l,n)) * 0.5;\n\n\tvec3 r=reflect(ci,n);\n\tvec4 pi=pI(si.xyz,r,pl), pi2=pI(si.xyz,r,pl2);\n\tc = mix(sc,pC(pi,pl),sb);\n\tc2 = mix(sc,pC(pi2,pl2),sb);\n\tfloat md = pi.w;\n\tif( pi2.w > pi.w ) { c = c2; md = pi2.w; }\n\n\tvec4 so=s;\n\tif(sp.x == s.x) so = s2;\n\tsp=so; ro=si.xyz; si=sI(si.xyz,n(r),so);\n\n\tif( si.w > 0. && si.w < md ) {\n\t\tvec3 osc=v3, osc2 = v3;\n\t\tn=n(si.xyz-sp.xyz),ci=n(si.xyz-ro);\n\t\tlp=-(pl.xyz*pl.w),l=n(lp-si.xyz);\n\t\tosc += max(0.,dot(l,n)) * 0.5;\n\t\tr=reflect(ci,n);\n\t\tpi=pI(si.xyz,r,pl),pi2=pI(si.xyz,r,pl2);\n\t\tosc = mix(osc,pC(pi,pl),sb);\n\t\tosc2 = mix(osc,pC(pi2,pl2),sb);\n\t\tif( pi2.w > pi.w ) { osc = osc2; }\n\t\tc = mix(sc,osc,sb);\n\t}\n\treturn c;\n}\n\nvec3 gPC(vec2 uv) {\n\tvec3 ro=vec3(0,7.2,0), rd=n(vec3(uv*2.,-1.0));\n\tvec3 c=v3;\n\tpR(rd.yz,PI*(m.y-0.5));\n\tpR(rd.xy,2.*PI*(m.x-0.5));\n\n\tvec4 pi=i2p(ro,rd), pi2=pI(ro,n(rd),pl2);\n\tvec4 sip=sI(ro,n(rd),s2), si=sI(ro,n(rd),s);\n\tfloat md=1e10;\n\tif(sip.w>0. && sip.w<md) {md=sip.w; c=sC(s2,sip,ro);}\n\tif(si.w>0. && si.w<md) {md=si.w; c=sC(s,si,ro);}\n\tif(pi2.w>0. && pi2.w<md) {md=pi2.w; c+=pC(pi2,pl2);}\n\tif(pi.w>0. && pi.w<md) {md=pi.w; c+=pC(pi,pl);}\n\tc *= exp( -0.05*md );\n\n\treturn c;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  m=iMouse.xy / iResolution.xy * vec2(1,-1);\n  t=ut*0.2;\n  tc1=rv(t*PI*0.5);\n  tc2=rv(t*PI);\n  tc3=rv(ut*PI*0.125);\n  pl=vec4(n(vec3(0, 0, 3)),3.9);\n  pl2=vec4(n(vec3(0,0,-1)),1.9);\n  s=vec4(5.5*tc3.x,5.5*-tc3.y,0.+4.*tc2.x,1.9);\n  s2=vec4(-s.x,-s.y,0.-4.*tc2.x,1.9);\n\n\n  vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec3 col = gPC(uv.xy);\n\t//-----------------------------------------------------\n  // postprocess\n  //-----------------------------------------------------\n\n  // gama\n  col = pow( col, vec3(0.44,0.5,0.55) );\n\n  // contrast\n  col = mix( col, smoothstep( 0.0, 1.0, col ), 0.5 );\n\n  // saturate\n  col = mix( col, vec3(dot(col,vec3(0.333))), -0.2 );\n\n  // vigneting\n  col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n  // dithering\n  col += (1.0/255.0)*hash3(q.x+13.3214*q.y);\n\n\tfragColor=vec4(col,1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 276, 276, 322], [324, 324, 357, 357, 406], [408, 408, 444, 444, 567], [569, 569, 604, 604, 698], [722, 722, 762, 762, 845], [847, 847, 879, 879, 987], [989, 989, 1008, 1029, 1115], [1201, 1201, 1221, 1221, 1378], [1380, 1380, 1406, 1406, 1809], [1811, 1811, 1842, 1842, 1879], [1881, 1881, 1915, 1915, 2690], [2692, 2692, 2711, 2711, 3175], [3177, 3177, 3200, 3200, 3256], [3258, 3258, 3315, 3315, 4199]], "test": "error"}
{"id": "sdySDd", "name": "Image transition-noise", "author": "therepo90", "description": "Hold and move mouse to move pillar\n\nnoise fn from https://www.shadertoy.com/view/XdXBRH", "tags": ["noise", "imagetransition"], "likes": 6, "viewed": 56, "published": "Public", "date": "1635981649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 mod2(vec2 p, float d) {\n    float a = mod(p.x,d);\n    float b = mod(p.y,d);\n    return vec2(a,b);\n}\n\n\n\nvec3 laserTex(vec2 uv, vec2 mouse) {\n\n    //uv*=0.1;\n    vec3 col=vec3(0);\n    float thk=0.03;\n    vec3 barCol=vec3(0,1.0,1.0);\n    float edgeCloseFactor = smoothstep(mouse.x-thk,mouse.x,uv.x);\n    float barFactor = edgeCloseFactor* smoothstep(mouse.x+thk,mouse.x, uv.x);\n    col=vec3(barFactor);\n    return col;\n    \n}\n\n\nvec3 laserComposition(vec2 uv, vec2 mouse) {\n\n    vec3 laserMask = laserTex(uv,mouse);\n    vec3 laserCol = vec3(1.0, 0.5, 0.);\n    return laserMask.x * laserCol *2.;\n    //return laserMask;\n    \n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvoid Unity_GradientNoise_float(vec2 UV, float Scale, out float Out)\n    {\n       Out = noised(UV * Scale).x *0.5 + 0.5;\n    }\n       \nvoid Unity_Multiply_float2_float2(vec2 A, vec2 B, out vec2 Out)\n{\n    Out = A * B;\n}\n\nvoid Unity_TilingAndOffset_float(vec2 UV, vec2 Tiling, vec2 Offset, out vec2 Out)\n{\n    Out = UV * Tiling + Offset;\n}\n\nvoid Unity_Lerp_float4(vec4 A, vec4 B, vec4 T, out vec4 Out)\n{\n    Out = mix(A, B, T);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(mouse.x < 0.01) {\n    // init\n        mouse.x = 0.5;\n    }\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y / iResolution.x;\n    uv.x/=asp;\n    mouse.x/=asp;\n\n            vec2 timeF = vec2(0.1, 0);\n            vec2 timeOffset = iTime * timeF;\n            vec2 uvTiled;\n            Unity_TilingAndOffset_float(uv, vec2 (1, 1), timeOffset, uvTiled);\n            \n    float gradientNoise;\n    Unity_GradientNoise_float(uvTiled, 11., gradientNoise);\n    \n\n    \n    float distortionAmount=0.1;\n    vec4 lerpedValue;\n    Unity_Lerp_float4(vec4(uv,0.,0.), vec4(gradientNoise),vec4(distortionAmount), lerpedValue);\n    \n    vec3 laserCol = laserComposition(lerpedValue.xy,mouse);\n    \n    //vec3 col = lerpedCol;\n    \n        //float edgeCloseFactor = smoothstep(mouse.x-thk-offset1-0.03,mouse.x-offset1,uv.x);\n    //float barFactor = edgeCloseFactor* smoothstep(mouse.x+thk-offset1,mouse.x-offset1, uv.x);\n    \n    vec3 col1=texture(iChannel0, uv).xyz;\n    vec3 col2=texture(iChannel1, uv).xyz;\n    vec3 col;\n     col=mix(col1,col2,step(mouse.x, lerpedValue.x));\n     //col*=laserCol;\n     col+=laserCol;\n     //col=mix(col,laserCol,0.5);\n    //col = laserTex(uv, mouse);\n    //col = vec3(uvTiled,0.);\n    //col = vec3(gradientNoise);\n    //col = vec3(lerpedValue);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdySDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 105], [109, 109, 145, 161, 428], [431, 431, 475, 475, 627], [629, 629, 690, 690, 828], [831, 891, 917, 917, 1783], [1785, 1785, 1858, 1858, 1910], [1919, 1919, 1984, 1984, 2003], [2005, 2005, 2088, 2088, 2122], [2124, 2124, 2186, 2186, 2212], [2213, 2213, 2270, 2270, 3660]], "test": "error"}
{"id": "sl33D4", "name": "Pixel Spiral Test", "author": "SnoopethDuckDuck", "description": "e", "tags": ["ee"], "likes": 0, "viewed": 118, "published": "Public API", "date": "1636122677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float c = 5. + 1. * thc(2., 0.8 * iTime);\n    float l = mix(4. * length(uv) * length(uv), 1. / (1. + length(uv)), .5 + .5 * thc(3., iTime));\n    uv = vec2(ths(3., c * uv.x * l), ths(3., c * uv.y * l));\n    \n    float sc = 64.;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    \n    float a = atan(ipos.y, ipos.x);\n    float r = log(cos(10. * length(ipos)/sc + 4. * iTime) + thc(3.,30. * length(ipos)/sc + 2. * a + iTime));//log(length(ipos));\n   \n    vec2 v = r * vec2(cos(a), sin(a));\n    \n    float d = length(v);\n    d = clamp(d, 0., 1.);\n    float s = step(d,0.74 -.25 * thc(4., iTime));\n    \n    vec3 col = vec3(s);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl33D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [145, 145, 202, 252, 1031]], "test": "valid"}
{"id": "sl33Wn", "name": "jneen - happy pulsing glowmoon", "author": "jneen", "description": "glow smoothly moving between two objects. click around to make it shake", "tags": ["fog", "jneen"], "likes": 9, "viewed": 112, "published": "Public", "date": "1635958153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rad(x) (radians(360.*(x)))\n#define time (iTime*.1)\n#define mouse (iMouse/iResolution.y)\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat glow;\n\n#define tri(x) (abs(fract((x)*.5)-.5)*2.)\n#define nsin(x) (.5+.5*sin(x))\nfloat scene(vec3 p) {\n  float bgsize = 2.5;\n  vec3 bgp = p.xyz;\n  bgp.xz *= rot(time);\n  float bg = box(bgp+vec3(0,bgsize+1.2,0),vec3(bgsize))-.3;//p.y + 2.;\n  vec3 orig_p = p.xyz;\n  p.xz *= rot(rad(.2*sin(time)));\n  p.xy *= rot(rad(.3*time*sqrt(2.)));\n  p.yz *= rot(rad(2./6.));\n  \n  p = orig_p;\n  p.y -= 1.;\n  p.xy += .2*mouse.y*nsin(tan(time*10.)*.01)*rot(time*300.)*vec2(1,0);// sin(time*6.);\n  p.yz *= rot(rad(.25)+.5*cos(10.*time));\n  p.xy *= rot(rad(.25)+.1*sin(20.*time));\n  float yzrot = 3.14+sin(tan(time*12.))/200.;\n  p.yz *= rot(yzrot);\n\n  float squeeze = 4.8;\n  float sph = sphere(p,2.);\n  vec2 samp = vec2(atan(p.x,p.z)/3.141592654, p.y*.2);\n  float solid = mix(sph,box(p,vec3(1.5)-.2),.8+.5*sin(time*150.));\n  \n  solid = max(solid,.2-box(p-vec3(0,.6,.4),.5*vec3(5.,.05,.2)));\n  solid = max(solid,.2-box(p-vec3(0,-.6,.4),.5*vec3(5.,.05,.2)));\n  solid = max(solid,.2-box(p*(-abs(p.y)-2.)-vec3(0,0,1.2),vec3(5.,.6,.2*nsin(tan(time)))));\n\n  solid += (.1+.2*nsin(time))*mix(texture(iChannel0, samp).r, texture(iChannel0, samp+1.).r, .5);\n\n  float glowr = .5;\n  float glowbase = mix(solid,bg,.5+.5*sin(time*20.));\n  float glowbox = max(glowbase - glowr, -glowbase+glowr-.4);\n  // a buffer between the solid and the fog to prevent\n  // super-bright areas on the solid as the raymarcher\n  // slows down. try setting this to 0 and see what happens\n  // should be at least DENSITY\n  // raising this is the best way to deal with edge glow around\n  // the solid\n  float BUFFER_ZONE = 0.05;\n  \n  \n  // lower = more dense fog. should be at least 1/stepcount\n  // (100 here)\n  float FOGSTEP = .03;\n\n  // ==== and here's the 2-line fog effect ====\n  // * if we're inside the glowbox, increase the glow by how far\n  // we have penetrated into the box.\n  // * however, if we're passing close to the solid object, we have to\n  // not increase the glow because it will overcount as we step closer\n  // and closer to the solid. so we zero it out below the buffer zone\n  glow += max(0., -glowbox)*smoothstep(0.,BUFFER_ZONE*2.,solid);\n  \n  // step towards the glowbox by the distance we are inside the cube,\n  // plus a little buffer to get us inside the box. if we're *in* the\n  // box, we want to keep moving, and abs(glowbox) will make sure we're\n  // approximately inside the box still. note that we will *never* detect\n  // a surface at any point of the glowbox, because the minimum distance is\n  // always positive.\n  glowbox = abs(glowbox) + FOGSTEP;\n  return min(bg,min(solid,glowbox));\n}\n\n\nfloat ray(vec3 start, vec3 dir) {\n  float dist=0.;\n  glow=0.;\n  \n  for (int i=0;i<200;i++) {\n    float c = scene(start+dir*dist);\n    dist += c;\n    if (c < .001) return dist;\n    if (dist > 10000.) return 100001.;\n  }\n  \n  return 1001.;//min(dist,1000.);\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p) - mat3(.01);\n  return scene(p)-vec3(scene(K[0]),scene(K[1]),scene(K[2]));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float focus=2.;\n    vec3 cam = vec3(0,0,-5.*focus);\n    vec3 dir = normalize(vec3(uv,focus));\n    \n    float dist = ray(cam, dir);\n    float G = glow; \n    vec3 hit = cam+dir*dist;\n    vec3 norm = normalize(grad(hit));\n    \n    vec3 refl = reflect(dir,norm);\n    float refldist = ray(hit+refl*.1, refl);\n    float reflglow = glow;\n    \n    vec3 col;\n    if (dist < 1000.) {\n      // thanks blackle for the awesome fake image lighting :3\n      float diff = length(sin(norm)*.5+.5)/sqrt(3.);\n      col = diff*diff*vec3(.5,.9,1);\n    } else {\n      float moonspeed = 40.;\n      vec2 p = uv*8.+.5*texture(iChannel0,uv).r;\n      col = vec3(1,.5,.1)*(1.-length(p+vec2(4.*sin(moonspeed*sin(time)),-1.+cos(moonspeed*sin(time)))));\n      col = max(col,-mouse.y);\n      col = abs(col);\n    }\n    \n    \n    // lower numbers are a denser, more uniform fog\n    // high numbers are very glowy and a little glitchy\n    float UNIFORMITY = 0.8;\n    col += pow(G, UNIFORMITY) *mouse.x * vec3(.9, .3,.1);;\n    col += reflglow * vec3(.9,.2,.1)*.8;\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl33Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 124, 124, 205], [207, 207, 238, 238, 262], [264, 264, 283, 283, 333], [420, 420, 441, 441, 2908], [2911, 2911, 2944, 2944, 3168], [3170, 3170, 3189, 3189, 3288], [3291, 3291, 3348, 3398, 4593]], "test": "error"}
{"id": "sl3GRM", "name": "Simple Exposure Shader", "author": "SMAkbar", "description": "Taken from https://github.com/worleydl/hdr-shaders/blob/master/dolphin/hdr.glsl", "tags": ["exposureshader"], "likes": 0, "viewed": 50, "published": "Public", "date": "1635854945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Uncharted2ToneMapping(vec3 color)\n{\n    float gamma = 2.2;\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(Uncharted2ToneMapping(col), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 475], [477, 477, 534, 584, 800]], "test": "valid"}
{"id": "sl3GWn", "name": "波四", "author": "yjx", "description": "square wave", "tags": ["wave"], "likes": 1, "viewed": 112, "published": "Public API", "date": "1635955765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int Wav=1;\n\nfloat wave(float A,float k,float omega,float phi,vec2 U){\nreturn A*sin(k*U.x-omega*iTime+phi);}\n\nvoid mainImage( out vec4 O,vec2 u )\n{\n    vec2 R=iResolution.xy,\n         U = 100.*( u - .5*R ) / R.x;\n\n    float w=0.;\n    for(float j=1.;j<30.;j++){\n    if(Wav==0){\n        w+=wave(3.0/(2.*j-1.),0.3*(2.*j-1.),0.8*(2.*j-1.),0.,U);}\n    if(Wav==1){\n        w+=wave(3.0/j/j*sin(j/2.*3.14),0.3*j,0.8*j,0.,U);}}\n    O+=step(abs(0.2*U.y-w),0.05);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 69, 69, 107], [109, 109, 146, 146, 453]], "test": "valid"}
{"id": "slc3Dr", "name": "jneen - angry pulsing glowmoon", "author": "jneen", "description": "it angey. click it for angeyer, esp top right. bottom right for fire effect\n", "tags": ["jneen"], "likes": 7, "viewed": 106, "published": "Public", "date": "1635974646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rad(x) (radians(360.*(x)))\n#define time (iTime*.1)\n#define mouse (iMouse/iResolution.y)\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat glow;\n\n#define tri(x) (abs(fract((x)*.5)-.5)*2.)\n#define nsin(x) (.5+.5*sin(x))\nfloat scene(vec3 p) {\n  float bgsize = 2.5;\n  vec3 bgp = p.xyz;\n  bgp.xz *= rot(time);\n  float bg = box(bgp+vec3(0,bgsize+1.2,0),vec3(bgsize))-.3;//p.y + 2.;\n  vec3 orig_p = p.xyz;\n  p.xz *= rot(rad(.2*sin(time)));\n  p.xy *= rot(rad(.3*time*sqrt(2.)));\n  p.yz *= rot(rad(2./6.));\n  \n  p = orig_p;\n  p.y -= 1.;\n  p.xy += .2*mouse.y*nsin(tan(time*10.)*.01)*rot(time*300.)*vec2(1,0);// sin(time*6.);\n  p.yz *= rot(rad(.25)+.5*cos(10.*time));\n  p.xy *= rot(rad(.25)+.1*sin(20.*time));\n  float yzrot = 3.14+sin(tan(time*12.))*.1;\n  p.yz *= rot(yzrot);\n\n  float squeeze = 4.8;\n  float sph = sphere(p,2.);\n  vec2 samp = vec2(atan(p.x,p.z)/3.141592654, p.y*.2);\n  float solid = mix(sph,box(p,vec3(1.5)-.2),.8+.5*sin(time*150.));\n  \n  solid = max(solid,.2-box(p-vec3(0,.6,.4),.5*vec3(5.,.05,.2)));\n  solid = max(solid,.2-box(p-vec3(0,-.6,.4),.5*vec3(5.,.05,.2)));\n  solid = max(solid,.2-box(p*(sin(time*13.)*abs(p.y)-2.)-vec3(0,0,1.2),vec3(5.,.6,.2*nsin(tan(time)))));\n\n  vec2 pole = abs(p.xz)- vec2(1,0)*rot(15.*time);\n  solid = min(solid, max(p.z,length(pole)-p.y*.001));\n  solid += (.1+.2*nsin(time))*mix(texture(iChannel0, samp).r, texture(iChannel0, samp+1.).r, .5);\n\n  float glowr = .5;\n  float glowbase = mix(solid,bg,.1+.5*sin(time*20.));\n  float glowbox = max(glowbase - glowr, -glowbase+glowr-.4);\n  // a buffer between the solid and the fog to prevent\n  // super-bright areas on the solid as the raymarcher\n  // slows down. try setting this to 0 and see what happens\n  // should be at least DENSITY\n  // raising this is the best way to deal with edge glow around\n  // the solid\n  float BUFFER_ZONE = 0.05;\n  \n  \n  // lower = more dense fog. should be at least 1/stepcount\n  // (100 here)\n  float FOGSTEP = .03;\n\n  // ==== and here's the 2-line fog effect ====\n  // * if we're inside the glowbox, increase the glow by how far\n  // we have penetrated into the box.\n  // * however, if we're passing close to the solid object, we have to\n  // not increase the glow because it will overcount as we step closer\n  // and closer to the solid. so we zero it out below the buffer zone\n  glow += max(0., -glowbox)*smoothstep(0.,BUFFER_ZONE*2.,solid);\n  \n  // step towards the glowbox by the distance we are inside the cube,\n  // plus a little buffer to get us inside the box. if we're *in* the\n  // box, we want to keep moving, and abs(glowbox) will make sure we're\n  // approximately inside the box still. note that we will *never* detect\n  // a surface at any point of the glowbox, because the minimum distance is\n  // always positive.\n  glowbox = abs(glowbox) + FOGSTEP;\n  return min(bg,min(solid,glowbox));\n}\n\n\nfloat ray(vec3 start, vec3 dir) {\n  float dist=0.;\n  glow=0.;\n  \n  for (int i=0;i<200;i++) {\n    float c = scene(start+dir*dist);\n    dist += c;\n    if (c < .001) return dist;\n    if (dist > 10000.) return 100001.;\n  }\n  \n  return 1001.;//min(dist,1000.);\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p) - mat3(.01);\n  return scene(p)-vec3(scene(K[0]),scene(K[1]),scene(K[2]));\n}\n\nfloat N(float x) {\n  return fract(tan(x*1234.-2345.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float band = floor(uv.x*20.+time*200.);\n    uv.y = fract(uv.y+.5 + 0.01*mouse.y*N(band+7.)*time*N(band))-.5;\n    \n    float focus=2.;\n    vec3 cam = vec3(0,0,-5.*focus);\n    vec3 dir = normalize(vec3(uv,focus));\n    \n    float dist = ray(cam, dir);\n    float G = glow; \n    vec3 hit = cam+dir*dist;\n    vec3 norm = normalize(grad(hit));\n    \n    vec3 refl = reflect(dir,norm);\n    float refldist = ray(hit+refl*.1, refl);\n    float reflglow = glow;\n    \n    vec3 col;\n    if (dist < 1000.) {\n      // thanks blackle for the awesome fake image lighting :3\n      float diff = length(sin(norm)*.5+.5)/sqrt(3.);\n      col = max(0., pow(diff, 2.))*vec3(.1,0,0);\n    } else {\n      float moonspeed = 40.;\n      vec2 p = uv*8.+.5*texture(iChannel0,uv).r;\n      col = vec3(1,.5,.1)*(1.-length(p+vec2(4.*sin(moonspeed*sin(time)),-1.+cos(moonspeed*sin(time)))));\n      col = max(col,-mouse.y);\n      //col = tan(col);\n    }\n    \n    \n    // lower numbers are a denser, more uniform fog\n    // high numbers are very glowy and a little glitchy\n    float UNIFORMITY = 0.8;\n    col += pow(G, UNIFORMITY) *mouse.x * vec3(.9, .3,.1);;\n    col += reflglow * vec3(.9,.2,.1)*.8;\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 124, 124, 205], [207, 207, 238, 238, 262], [264, 264, 283, 283, 333], [420, 420, 441, 441, 3023], [3026, 3026, 3059, 3059, 3283], [3285, 3285, 3304, 3304, 3403], [3405, 3405, 3423, 3423, 3461], [3463, 3463, 3520, 3570, 4897]], "test": "error"}
{"id": "slc3Wj", "name": "Newton's Fractal 2", "author": "kowalski_analytics", "description": "You want to solve z⁵ + z² - z + 1 = 0, you know calc, you don't know factoring. Good news!\n\nYou just guess some x and improve!\na) find the linear approximation at x\nb) move to the x-intercept\nc) repeat!\n\nHowever, when the linear approximation is almo", "tags": ["fractal"], "likes": 3, "viewed": 54, "published": "Public", "date": "1636716658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 200\n\nvec2 zoomC = vec2(-0.648705, 0.115672);\nfloat zoomrate = 2.;\n\n#define N 5\nvec2 roots[N] = vec2[N](vec2(-1,0), vec2(0,1), vec2(0,-1), vec2(0.7, 0.7), vec2(0.7,-0.7));\nvec3 colors[N] = vec3[N](vec3(1., .7, .7), vec3(1., .3, .3), vec3(1., 1., 0.), vec3(.3, .3, 1.), vec3(.7, 1., .7) );\n                        // pink, red, yellow, blue, green\n\nint closest(vec2 z){\n    int k = 0;\n    for (int i = 0; i < N; i++) {\n        if (length(z - roots[k]) > length(z - roots[i])) k = i;\n    }\n    return k;\n}\n\nvec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 div(vec2 a, vec2 b) {\n    float d = b.x * b.x + b.y * b.y;\n    if (d == 0.0) {\n        d = 0.001;\n    }\n    return vec2 (a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / d;\n}\n\nvec2 f(vec2 x) {\n    vec2 total = vec2(1.0, 0.0);\n    for (int i = 0; i < N; i++) {\n        total = mul(total, x - roots[i]);\n    }\n    return total;\n}\n\nvec2 f_deriv(vec2 x) {\n    vec2 total = vec2(0.0, 0.0);\n    for (int i = 0; i < N; i++) {\n        vec2 subtotal = vec2(1.0, 0.0);\n        for (int j = 0; j < N; j++) {\n            if (i != j) subtotal = mul(subtotal, x - roots[j]);\n        }\n        total += subtotal;\n    }\n    return total;\n}\n\nvec2 scale( vec2 x ) {\n    float zoom = exp(-zoomrate * iTime);\n    \n    x -= iResolution.xy/2.;\n    x /= iResolution.y;\n    x *= 2.;\n    \n    x *= zoom;\n    x += zoomC * (1. - zoom);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 z = scale(fragCoord);\n    vec4 m = vec4(scale(iMouse.xy), iMouse.zw);\n    \n    if ( m.z > 0.0 ) {\n        roots[0] = m.xy;\n    }\n    \n    for (int i = 0; i < ITERATIONS; i++) {\n        z -= div(f(z), f_deriv(z));\n    }\n    \n    fragColor = vec4(colors[closest(z)], 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 386, 386, 521], [523, 523, 549, 549, 614], [616, 616, 642, 642, 794], [796, 796, 812, 812, 947], [949, 949, 971, 971, 1243], [1245, 1245, 1267, 1267, 1444], [1446, 1446, 1503, 1503, 1788]], "test": "valid"}
{"id": "slc3Ws", "name": "Caesar's Bubbles", "author": "lesserfish", "description": "JOJOOOO! THIS IS MY LAST HAMON.\nPLEASE TAKE IT!!!!1", "tags": ["raytracing"], "likes": 1, "viewed": 36, "published": "Public", "date": "1636927279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define ASPECT_RATIO iResolution.y / iResolution.x\n#define FOV PI / 4.0\n#define UP vec3(0.0, 1.0, 0.0)\n#define MAX_IT 5\n#define INFINITE 9999999999999999.0\n\n//x is in front of you, y is up, z is right.\n\nstruct Hit\n{\n    bool hit;\n    vec3 pos;\n    float t;\n    vec3 normal;\n    vec3 ray;\n    vec3 rgb;\n    int mode;\n};\nstruct Camera\n{\n    vec3 Position;\n    vec3 Direction;\n};\n\nHit PlaneHit(vec3 origin, vec3 ray, float height, int mode)\n{\n    if(ray.y == 0.0){\n        if(height == origin.y)\n            return Hit(true, origin, 0.0, UP, ray, vec3(0.0, 1.0, 0.0), mode);\n        return Hit(false, vec3(0.0), 0.0, vec3(0.0), vec3(0.0), vec3(0.0), mode);\n    }\n    \n    float t = (height - origin.y) / ray.y;\n    if(t < 0.0)\n        return Hit(false, vec3(0.0), 0.0, vec3(0.0), vec3(0.0), vec3(0.0), mode);\n        \n    float dev = texture(iChannel1, mod(t*ray.xz, 1.0)).x * 0.2;\n    vec3 ndev = vec3(texture(iChannel1, mod(t*ray.xz, 1.0)).y, 1.0, texture(iChannel1, mod(t*ray.xz, 1.0)).z);\n    return Hit(true, origin + (t)*ray + dev*UP, t, UP + 0.9*ndev, ray, vec3(1.0), mode);\n}\nHit SphereHit(vec3 origin, vec3 ray, vec3 sphpos, float radius, int mode, vec3 color)\n{\n    float a = dot(ray, ray);\n    float b = dot(ray, origin - sphpos);\n    float c = dot(origin - sphpos, origin - sphpos) - radius * radius;\n    float d = b*b - a*c;\n    if(d < 0.0)\n    {\n        return Hit(false, vec3(0.0), 0.0, vec3(0.0), vec3(0.0), vec3(0.0), mode);\n    }\n    \n    float fr = (-b - sqrt(d))/a;\n    float sr = (-b + sqrt(d))/a;\n\n    if(fr < 0.0)\n        return Hit(false, vec3(0.0), 0.0, vec3(0.0), vec3(0.0), vec3(0.0), mode);\n    \n    vec3 n = vec3(origin + fr*ray - sphpos);\n    n /= length(n);\n    \n\n    float dev = texture(iChannel0, vec2(mod(fr * 0.8*sin(iTime*0.05), 1.0))).x;\n    dev *= 1.1 * float(1 - mode);\n    \n    return Hit(true, origin + (fr + dev) * ray, fr, n, ray, color, mode);\n   \n}\nHit GetHit(vec3 origin, vec3 ray)\n{\n    Hit h1 = SphereHit(origin, ray, vec3(8.0 + sin(iTime), cos(iTime), cos(iTime)), 0.9, 0, vec3(1.0, 1.0, 1.0));\n    Hit h2 = PlaneHit(origin, ray, -2.0, 0);  \n    Hit h3 = SphereHit(origin, ray, vec3(8.0, -1.48, 0.5), 0.5, 0, vec3(1.0, 0.0, 0.0));\n    Hit h4 = SphereHit(origin, ray, vec3(6.1, -1.70, -1.5), 0.4, 0, vec3(0.0, 0.7, 0.3));\n    Hit h5 = SphereHit(origin, ray, vec3(7.8, -1.78, 1.5), 0.2, 0, vec3(1.0, 0.0, 1.0));\n    Hit h6 = SphereHit(origin, ray, vec3(5.5, -0.48, 2.8), 1.5, 0, vec3(1.0, 0.0, 1.0));\n    Hit h7 = SphereHit(origin, ray, vec3(12.9, -1.48, -2.5), 0.5, 0, vec3(0.0, 0.1, 0.5));\n    Hit h8 = SphereHit(origin, ray, vec3(9.8, -1.5, -1.3), 0.2, 0, vec3(0.0, 0.0, 0.0));\n    Hit h9 = SphereHit(origin, ray, vec3(3.8, -1.78, 2.9), 0.2, 0, vec3(1.0, 0.0, 1.0));\n    Hit h10 =SphereHit(origin, ray, vec3(6.8, -1.78,-1.5), 0.2, 0, vec3(1.0, 0.0, 1.0));\n\n    \n    \n    Hit HitList[] = Hit[](h1, h2, h3, h4, h5, h6, h7, h8, h9, h10);\n    \n    Hit h = Hit(false, vec3(0.0), INFINITE, vec3(0.0), vec3(0.0), vec3(0.0), 0);\n    for(int i = 0; i < HitList.length(); i++)\n    {\n        if(HitList[i].hit && HitList[i].t < h.t)\n            h = HitList[i];\n    }\n    return h;\n    \n}\nvec4 GetColor(Hit h)\n{\n    vec3 lightdir = vec3(0.0, -0.7, 0.5 + 0.5*cos(iTime));\n    float inten = 1.0;\n    float base = 0.5;\n    float t = 0.7;\n    lightdir /= length(lightdir);\n    if(h.hit)\n    {\n         vec4 c = (t * base + (1.0 - t)*dot(-lightdir, h.normal) * inten) * vec4(h.rgb,0.0);\n         vec3 dir = - lightdir;\n         vec3 pos = h.pos + dir * 0.005;\n         Hit new_hit = GetHit(pos, dir);\n           if(new_hit.hit)\n               return vec4(0.0);\n        return c;\n    }\n    else{\n        float skyi = 1.0;\n        return (1.0 - skyi)*vec4(1.0) + skyi*vec4(0.1, 0.7, 1.0, 0.0);\n    }\n}\nvec3 GetRayFromUV(vec3 direction, vec2 uv)\n{\n    direction /= length(direction);\n    vec3 r = direction - uv.x * tan(FOV) * cross(direction, UP) + ASPECT_RATIO * uv.y * UP;\n    r /= length(r);\n    return r;   \n}\n\nvec4 pixel(Camera cam, vec2 uv)\n{\n    vec3 r = GetRayFromUV(cam.Direction, uv);\n    Hit h;\n    vec4 color = vec4(0.0);\n    \n    vec3 origin = cam.Position;\n    vec3 dir = r;\n    \n    float intensity = 0.5;\n    \n    for(int i = 0; i < MAX_IT; i++)\n    {\n        Hit h = GetHit(origin, dir);\n        if(!h.hit || h.mode == 1)\n        {\n            color = color + intensity * GetColor(h);\n            break;\n        }\n        if(h.mode == 0){\n            dir = reflect(dir, h.normal);\n            dir /= length(dir);\n            origin = h.pos + dir*0.1;\n        }\n        if(h.mode == 2)\n        {\n            dir = reflect(dir, h.normal);\n            dir /= length(dir);\n            origin = h.pos + dir*0.1;\n            \n            Hit new_hit = GetHit(origin, dir);\n            color = color + intensity*intensity*intensity * GetColor(new_hit);\n            \n            dir = h.ray;\n            origin = h.pos + h.ray * 1.1;\n        }\n        color = color + intensity * GetColor(h);\n        intensity = intensity * 0.5;\n    }\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    Camera cam = Camera(vec3(3.0, -1.0, 0.0), vec3(1.0, 0.0, 0.0));\n    vec3 r = GetRayFromUV(cam.Direction, uv);\n        \n\n    fragColor = pixel(cam, uv);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 396, 457, 457, 1098], [1099, 1099, 1186, 1186, 1908], [3142, 3142, 3164, 3164, 3747], [3748, 3748, 3792, 3792, 3959], [3961, 3961, 3994, 3994, 5010], [5011, 5011, 5068, 5068, 5281]], "test": "error"}
{"id": "slc3WX", "name": "Fork Waves Remi gchipunov 002", "author": "gchipunov", "description": "get audacity for audio program. \n\n\n\nfrom waves, sound, wave, music, colors, beginner, audio, visualizer, easy, sounds\nCreated by ADOB in 2015-04-10\n", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "soundscreatedbyadobin20150410"], "likes": 2, "viewed": 78, "published": "Public", "date": "1636814093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// oringal createor https://www.shadertoy.com/user/ADOB\n// remixer coder: https://www.shadertoy.com/user/gchipunov\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i*7.0 - iTime * 5.6));\n        float Y = uv.y + getWeight(squared(i) * 50.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(2.6 * abs(mod(uvTrue.x + i / 0.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (100.0 * Y));\n       // float k = i;\n        if(i== 0.0f)\n       {\n\t\tcolor += vec3(glowWidth * (2.0 + tan(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                 //     glowWidth * (2.0 - cos(iTime * 0.19)));\n                       glowWidth * (2.0 - tan(iTime * 0.19)));\n       }\n           else   if(i== 1.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.01)),\n                      glowWidth * (2.0 - cos(iTime * 0.01)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n         else   if(i== 2.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + cos(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        else\n        {\n \t\tcolor += vec3(glowWidth/2.0 * (2.0 + tan(iTime * 0.13)),\n                      glowWidth/2.0 * (2.0 - sin(iTime * 0.23)),\n                      glowWidth/2.0 * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        \n\t}\t\n\tcolor = color + cos(color)/44.0;\n    color = color - tan(iTime * 0.13)/555.0;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "llS3Dy", "previewfilepath": "https://soundcloud.com/zubnid/zeldabetamax", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/zubnid/zeldabetamax", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 143, 143, 167], [169, 169, 200, 200, 259], [261, 261, 287, 287, 385], [387, 387, 444, 444, 2309]], "test": "error"}
{"id": "slc3z7", "name": "[Inercia 2021] Le Royal Cheater ", "author": "totetmatt", "description": "Same but different, wasn't really inspired.\n", "tags": ["shaderroyale"], "likes": 8, "viewed": 170, "published": "Public API", "date": "1635873616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/******\nThanks the Shader Showdown Scene folks for all the fun ! \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n\n\n\n# \n    This is the first scripted shader showdown / royale entry.\n    It was 'coded' live before the event, the bonzomatic network message has been recoreded via a script, \n    and then was replayed step by step thanks to another script and the bonzomatic network\n    during the Intercia 2021 Shader Royale\n#\n\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box2(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n     return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n  }\n \nvec2 sdf(vec3 p){\n  p.y -=.2;\n    p.xy *=rot(-.785*.5);\n  float bump = fract(iTime);\n  vec2 h;\n  vec3 hp = p;\n  hp.y -=1.;\n  hp.x +=1.;\n  h.x =  max(abs(hp.z)-.1-bump,box2(hp.xy,vec2(.5)));\n  h.y = 1.;\n  \n  vec2 t;\n  vec3 tp = p;\n  tp.x +=1.;\n  tp.y +=1.;\n  t.x =  max(abs(tp.z)-.1-bump,box2(tp.xy,vec2(.5,1.)));\n  t.y = 1.;\n  \n  h = t.x < h.x ? t:h;\n  \n  tp = p;\n  tp.y+=.3;\n  tp.x +=.1;\n  t.x = max(abs(tp.z)-.1-bump,length(tp.xy)-1.75);\n  t.x = max(-tp.x+.1,t.x);\n  \n  float tt  = max(abs(tp.z)-.2-bump,length(tp.xy)-1.);\n  tt = max(-tp.x,tt);\n  t.x= max(-tt,t.x);\n  t.y = 2.;\n  \n    h = t.x < h.x ? t:h;\n  return h;\n  }\n#define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nfloat diam2(vec2 p,float s){\n    p = abs(p);\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\nvec3 txt(vec2 uv){\n  uv*=4.;\n  uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.1415;\n  uv.x -=iTime;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n     vec3 col = vec3(.8,.2,.2);\n  if(mod(id.x,2.)==0.){\n       uv*=4.;\n       uv.y +=iTime;\n       uv = fract(uv)-.5;\n    col = vec3(.2,.8,.2);\n    }\n  float d = diam2(uv,.2);\n  d=  mix(d,abs(d)-.01,asin(sin(uv.x+uv.y))); // NOT SQUIDGAME \n  d=  smoothstep(1.7*fwidth(d),0.,d);\n \n  return .5*col*d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = txt(uv);\n  \n  vec3 ro = vec3(sin(iTime),0.,-5.);\n  vec3 rt = vec3(0.);\n  vec3 rp = ro;\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  float time = mod(iTime,10.);\nfor(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n     \n     \n     if(time < 5. && length(rp-vec3(.25,.1,.0)) >.6 ) acc += (d.y ==1. ? vec3(.2,.9,.2):vec3(.9,.2,.2))*exp(-abs(d.x))/(50.-min(40.,fract(iTime)*50.));\n     if(time < 5. &&  fract(iTime+ length(rp)*.5)<0.5){  d.x = max(.001,abs(d.x));}\n    \n    if(d.x <.0001){\n        vec3 n = norm(rp,.001);\n        vec3 nn = norm(rp,.01);\n        float diff = max(0.,dot(normalize(light-rp),n));\n        float spc = max(0.,dot(normalize(light-ro),reflect(-normalize(light),n)));\n      spc  = pow(spc,32.);\n        if(d.y == 1.){\n             col = vec3(.2,.9,.2)*diff;\n        }  else {\n             col = vec3(.9,.2,.2)*diff;\n          \n          }\n         col = time < 5. ?col : mix(col, col*step(.2,length(nn-n)),floor(asin(sin(rp.y+iTime)*.5)*10.)*.5+.5);\n         col +=spc*vec3(1.);\n      break;\n      }\n      rp +=rd*d.x;\n  \n  }  \n  col +=acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3z7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1414, 1414, 1432, 1432, 1479], [1480, 1480, 1506, 1506, 1591], [1594, 1594, 1611, 1611, 2217], [2246, 2246, 2273, 2273, 2348], [2349, 2349, 2377, 2377, 2435], [2436, 2436, 2454, 2454, 2878], [2879, 2879, 2936, 2986, 4350]], "test": "valid"}
{"id": "slc3zX", "name": "Fbm: Terraforma", "author": "Yusef28", "description": "A short fbm experiment. They say noise is a hard thing to master.\n", "tags": ["2d", "noise", "fbm", "texture", "color", "terraforma"], "likes": 16, "viewed": 154, "published": "Public API", "date": "1636509073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    //uv.x += iTime*0.24;\n    //cool start times\n    //16.*0.24\n    //190*0.24;\n    uv.x += 16.*0.24 + iTime*0.24;\n    vec3 col = vec3(0.0);\n \n  \n  float fa1 = smoothstep(0.2, 0.6,\n              abs( fract(fbm(uv ,5., 2.)*6.)-0.5) );\n  float fb1 = fbm(uv*2. + vec2(3. ,3. ) ,5., 5.);\n  \n  \n\n  float fa2 = fbm(uv*2.*rot(2.) - vec2(8. ) + fa1 ,2., 8.);\n  \n  float fa2fr = smoothstep(0.2, 0.5,\n              abs( fract(fa2*10.)-0.5) );\n  \n  float fb2 = fbm(uv*2. + vec2(3.,4. ) + fb1 ,5., 6.);\n  \n  float fb2fr = smoothstep(0., 0.9,\n              abs( fract(fb2*2.)-0.5) );\n \n  float fa3 = fbm(uv*1.*rot(1.5) + vec2(6. ) + fa2 ,5., 1.);\n   float fb3 = fbm(uv*1.*rot(1.8) + vec2(1. ,47. ) + fb2, 3., 2.);\n  \n  \n  \n  \n  col= mix(col, vec3(0.5,0.,0.),fa1);\n  \n  col= mix(col, vec3(0.9,0.,0.),fb1);\n  col= mix(col, vec3(0.5,0.99,0.),fa2);\n  \n  col= mix(col, vec3(1.),fb2);\n  col= mix(col, vec3(0.,0.,0.),fb2fr*.8);\n  \n  \n   col= mix(col, vec3(.0),fract(fa3*1.)*0.4-0.2);\n   \n   col= mix(col, vec3(sin(uv)*1.-(sin(iTime*3.)*0.1+0.1) ,0.5), pow(fb3, 3.));\n   \n   col *= vec3(0.95,0.8,0.6);\n   col = pow(col, vec3(1.2));\n   fragColor = vec4(col,1.);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 43, 43, 105], [107, 107, 130, 146, 468], [516, 516, 534, 534, 599], [600, 600, 638, 638, 849], [852, 852, 909, 909, 2114]], "test": "valid"}
{"id": "slcGDM", "name": "入门之路-10", "author": "jialouluo", "description": "雪花模拟", "tags": [], "likes": 5, "viewed": 153, "published": "Public API", "date": "1636188041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define count 400 //数量\n#define BlizardSpeed 0.4 //风速\nfloat rand(float x){\n    return fract(\n                sin(\n                    dot(vec2(x + 47.49, 38.2467 / (x + 2.3)),vec2(12.9898, 78.233))\n                    )\n                );\n}\nfloat drawCircle(vec2 uv,vec2 center,float radius){\n    return 1.0 - smoothstep(0.0,radius,length(uv -center));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n       fragColor = texture(iChannel0,uv);\n    for(int i=0;i<count;i++){\n        float j = float(i);\n        float speed = 0.4 + rand(j) * (0.7 + 0.5 * cos(j / (float(count) * 0.25)));//这里得到下落速度和雪花大小\n        vec2 center =vec2(\n             rand(j) + uv.y * BlizardSpeed + 0.6 * cos(iTime + sin(j)),//x代表雪花的出生x轴坐标\n             mod(rand(j) - speed *iTime,0.95)//y代表随时间下落的坐标\n            );\n             fragColor += vec4(drawCircle(uv,center,0.01*speed ));//这里传入speed 是作为大小使用\n    }\n\n   \n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 81, 81, 247], [248, 248, 299, 299, 361]], "test": "error"}
{"id": "slcGR4", "name": "test024175", "author": "JonathanMerfy", "description": "test024175#11test,test02,testest222", "tags": ["test", "test02", "testest222"], "likes": 7, "viewed": 174, "published": "Public API", "date": "1635774636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s,h,a;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z+=iTime*0.1;\n        p=sin(p);\n        p=R(p,vec3(.577),iTime*.5);\n        p=abs(p)-.2;//-.2 is nice, \n        p=p.x<p.y?p.yzx:p.zyx;\n        p=p.x<p.y?p.zxy:p.zyx;\n        s=2.;\n        for(int i=0;i++<8;){\n          s*=e=2./clamp(dot(p,p),.3,1.2);\n          p=abs(p)*e-vec3(.8,8,.8);\n        }\n        a=1.;\n        p-=clamp(p,-a,a);\n        g+=e=length(p)/s;\n        O.rgb+=(H(s*.01)+.5)*.01*exp(-.2*i*i*e);\n    }\n    O=pow(O,vec4(4));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 748]], "test": "valid"}
{"id": "slcGRS", "name": "Persian carpet 9", "author": "jarble", "description": "A Persian carpet pattern generator.", "tags": ["fractal", "snowflake", "carpet", "rug"], "likes": 4, "viewed": 112, "published": "Public API", "date": "1636243690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(-2.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = +floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float factor = 1.25;\n            float l1 = col.x;\n            \n            uv = triangle_wave(uv.yx+l1+offset,scale)+triangle_wave(uv,scale);\n            uv.x *= -factor;\n            \n            for(int k = 0; k < 3; k++){\n                uv = triangle_wave((uv+uv.yx*vec2(random1[k],random2[k])-l1+offset)/(random4[k]+1.),scale+random3[k]);\n                uv.x /= -factor;\n                //uv += vec2(random1[k],random2[k])*l1;\n        \n            }\n            \n\n            scale *= 1./(1.+l1);\n\n            //scale2 *= 2. - l1;\n\n            col = col.yxz;\n            col[c] = fract((uv.x)-(uv.y));\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 388, 410, 456, 589], [591, 591, 630, 630, 675], [677, 677, 734, 734, 1944]], "test": "valid"}
{"id": "slcGWN", "name": "Hipnosapo", "author": "peremoya2000", "description": "Simple inwards interactive bifocal circular scrolling", "tags": ["interactive", "uv", "psychedelic"], "likes": 1, "viewed": 34, "published": "Public", "date": "1636279125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5f;\n    uv.x*=iResolution.x/iResolution.y;\n     \n    vec2 uv0 = uv;\n    \n    //Normalized mouse position\n    vec2 mousePos = iMouse.xy / iResolution.xy -.5f;\n    mousePos.x*=iResolution.x/iResolution.y;\n    if(iMouse.z<.1f) mousePos = vec2(0);\n    \n    //Set UV center to MousePos and mul by centered UVs\n    uv-=mousePos;\n    uv*=uv0; \n       \n    \n    // Time varying pixel color    \n    float r= abs(sin(length(uv)*20.f+iTime));\n    float g= abs(cos(length(uv)*21.f+iTime*1.15f));\n    float b= (1.f-r)*abs(cos(iTime*.6f));\n    \n    \n    // Output to screen\n    fragColor = vec4(r,g,b,1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 742]], "test": "valid"}
{"id": "slcGWs", "name": "108-8", "author": "do", "description": "108-8", "tags": ["ico", "dode"], "likes": 5, "viewed": 69, "published": "Public", "date": "1636924614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//108\n//2021\n//do\n\n#define main() mainImage(out vec4 fragColor,in vec2 fragCoord)\n#define R iResolution\n#define t iTime\n\n#define AA 2\n#define EPS 0.0001\n\nconst int seed = 1290;\n\nconst float pi = radians(180.);\nconst float phi =  (1.+sqrt(5.))/2.;\n\nfloat h11(float p) {\n    uvec2 n = uint(int(p)) * uvec2(1391674541U,seed);\n    uint h = (n.x ^ n.y) * 1391674541U;\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat h21(vec2 p) {\n    uvec2 n = uvec2(ivec2(p))*uvec2(1391674541U,seed);\n    uint h = (n.x^n.y) * 1391674541U;\n    return float(h) * (1./float(0xffffffffU));\n}\n\nvec2 h22(vec2 p) {\n    uvec2 n = uvec2(ivec2(p)) * uvec2(1391674541U,seed);\n    n = (n.x ^ n.y) * uvec2(1391674541U,seed);\n    return vec2(n) * (1./float(0xffffffffU));\n}\n\nvec3 h33(vec3 p) {\n   uvec3 h = uvec3(ivec3(  p)) * \n   uvec3(1391674541U,seed,2860486313U);\n   h = (h.x ^ h.y ^ h.z) * uvec3(1391674541U,seed,2860486313U);\n   return vec3(h) * (1.0/float(0xffffffffU));\n\n}\n\nfloat spiral(vec2 p,float s) {\n    float d = length(p);\n    float a = atan(p.x,p.y);\n    float l = log(d)/.618 +a;\n    return sin(l*s);\n}\n\nfloat sin3(vec3 p,float h) {\n    \n    return sin(p.x*h) * sin(p.y*h) * sin(p.z*h);\n}\n\nvec3 fmCol(float t,vec3 a,vec3 b,vec3 c,vec3 d) {\n    return a + b * cos((radians(180.)*2.0) * (c * t + d));\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat extr(vec3 p,float d,float h) {\n    vec2 w = vec2(d,abs(p.z) - h);\n    return min(max(w.x,w.y),0.) + length(max(w,0.)); \n} \n\nvec2 rmod(vec2 p,float r) {\n    float n = radians(360.)/r;\n    float a = atan(p.x,p.y)+n*.5;\n    a = floor(a/n)*n;\n    return p * mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat cell(vec3 x,float n) {\n \n    x *= n;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n \n    float min_dist = 1.0;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            for(int k = -1; k <= 1; k++) { \n\n                vec3 b = vec3(float(k),float(j),float(i));\n                vec3 r = h33( p + b );\n                \n                vec3 diff = (b + r - f);\n\n                float d = length(diff);\n                min_dist = min(min_dist,d);\n    \n            }\n        }\n    }\n \n    return min_dist;  \n\n}\n\nfloat n2(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f =  f*f*(3.-2.*f);\n    float n = p.x + p.y * 57.;\n    \n    return( \n        mix(\n        mix(h11(n+0.),h11(n+1.),f.x),\n        mix(h11(n+57.),h11(n+58.),f.x),\n        f.y)\n        );\n       \n}\n\nfloat n3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(h11(n + 0.0),h11(n + 1.0),f.x),\n           mix(h11(n + 157.0),h11(n + 158.0),f.x),f.y),\n           mix(mix(h11(n + 113.0),h11(n + 114.0),f.x),\n           mix(h11(n + 270.0),h11(n + 271.0),f.x),f.y),f.z);\n}\n\nfloat f2(vec2 x) {\n\n    float t = 0.0;\n\n    float g = exp2(-.626); \n\n    float a = 0.5;\n    float f = 1.0;\n\n    for(int i = 0; i < 5; i++) {\n    t += a * n2(f * x); \n    f *= 2.0; \n    a *=  g;  \n    \n    }    \n\n    return t;\n}\n\nfloat f3 (vec3 p) {\n    float f = 1.;\n    mat3 m = mat3(vec2(.8,.6),h11(150.),\n                  vec2(-.6,.8),h11(125.),\n                  vec2(-.8,.6),h11(100.));\n\n    f += .5    * n3(p); p = m*p*2.01;\n    f += .25   * n3(p); p = m*p*2.04;\n    f += .125  * n3(p); p = m*p*2.1;\n    f += .0625 * n3(p);\n    return f / .94;\n}\n\nfloat dd(vec3 p) {\n    vec3 q = vec3(f3(p+vec3(0.,1.,2.)),\n                  f3(p+vec3(4.,2.,3.)),\n                  f3(p+vec3(2.,5.,6.)));\n    vec3 r = vec3(f3(p + 4. * q + vec3(4.5,2.4,5.5)),\n                  f3(p + 4. * q + vec3(2.25,5.,2.)),\n                  f3(p + 4. * q + vec3(3.5,1.5,6.)));\n    return f3(p + 4. * r);\n}\n\nmat2 rot(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n \nvec3 raydir(vec2 uv,vec3 ro,vec3 ta,float fov) {\n\n     vec3 f = normalize(ta - ro);\n     vec3 r = normalize(cross(vec3(0.0,1.0,0.0),f));\n     vec3 u = normalize(cross(f,r));\n\n     vec3 d = normalize(uv.x * r\n     + uv.y * u + f * fov);  \n\n     return d;\n}\n\nfloat petal(vec2 p,float r1,float r2,float h) {\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.-b*b);\n    float k = dot(p,vec2(-b,a));\n    if(k < 0.) return length(p)-r1;\n    if(k > a*h) return length(p-vec2(0.,h))-r2;\n    return dot(p,vec2(a,b))-r1;\n}\n\nfloat arc(vec2 p,vec2 sca,vec2 scb,float ra,float rb) {\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(dot(p,p)+ra*ra-2.*ra*k)-rb;\n}\n\nfloat box(vec3 p,vec3 b) {\n\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dode(vec3 p,vec3 a,vec3 b) {\n   vec4 v = vec4(0.,1.,-1.,0.5 + sqrt(1.25));\n   v /= length(v.zw);\n\n   float d;\n   d = abs(dot(p,v.xyw))-a.x;\n   d = max(d,abs(dot(p,v.ywx))-a.y);\n   d = max(d,abs(dot(p,v.wxy))-a.z);\n   d = max(d,abs(dot(p,v.xzw))-b.x);\n   d = max(d,abs(dot(p,v.zwx))-b.y);\n   d = max(d,abs(dot(p,v.wxz))-b.z);\n   return d;\n}\n \nfloat ico(vec3 p,float r) {\n    float d;\n    d = abs(dot(p,vec3(.577)));\n    d = max(d,abs(dot(p,vec3(-.577,.577,.577))));\n    d = max(d,abs(dot(p,vec3(.577,-.577,.577))));\n    d = max(d,abs(dot(p,vec3(.577,.577,-.577))));\n    d = max(d,abs(dot(p,vec3(0.,.357,.934))));\n    d = max(d,abs(dot(p,vec3(0.,-.357,.934))));\n    d = max(d,abs(dot(p,vec3(.934,0.,.357))));\n    d = max(d,abs(dot(p,vec3(-.934,0.,.357))));\n    d = max(d,abs(dot(p,vec3(.357,.934,0.))));\n    d = max(d,abs(dot(p,vec3(-.357,.934,0.))));\n    return d-r;\n}\n\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\nvec3 q,y,l,k,n;\n\nvec3 e = vec3(1./phi,1.,.67);\n\nk = p;\nk.xz *= rot(t*.61);\n\nfloat d = dode(k,vec3(e.z),vec3(e.z));\nd = max(d,-dode(k,e.yxx,vec3(e.x)));\nd = max(d,-dode(k,e.xyx,vec3(e.x)));\nd = max(d,-dode(k,e.xxy,vec3(e.x)));\nd = max(d,-dode(k,vec3(e.x),e.yxx));\nd = max(d,-dode(k,vec3(e.x),e.xyx));\nd = max(d,-dode(k,vec3(e.x),e.xxy));\n\nres = opu(res,vec2(d,5.));\n\nl = p;\nl.yz *= rot(t*.05);\nres = opu(res,vec2(ico(l,1./phi-.1),20.));\n\nfloat an1 = pi * (.5+.5*cos(.5));\nfloat an2 = pi * (.5+.5*cos(1.));\nfloat rb  = .1 * (.5+.5*cos(5.));\n\nres = opu(res,vec2(\n    extr(p.xzy,arc(p.xz,vec2(sin(an1),cos(an1)),\n                 vec2(sin(an2),cos(an2)),1.25,rb),\n                 .1),2.));\n\nan1 = pi * (-.5+.5*cos(.502));\nres = opu(res,vec2(\n    extr(p.xzy,arc(p.xz,vec2(sin(an1),cos(an1)),\n    vec2(sin(an2),cos(an2)),1.5,rb),\n    .16),1.));\n\ny = p.xzy;\ny.xy = rmod(y.xy,8.);\ny.y -= 6.;\n\nvec2 c = abs(vec2(length(p.xz),p.y)) - vec2(4.,2.);\nfloat cy = min(max(c.x,c.y),0.) + length(max(c,0.));\n\nres = opu(res,vec2(\n    max(-cy,box(y,vec3(1.,1e10,1.))),8.));\n\nn = p.xzy;\nn.xy = rmod(n.xy,108.);\nn.y -= 3.3;\n\nres = opu(res,vec2(\n   length(n-vec3(0.,0.,.12))-.08,108.));\n\nq = p.xzy;\nq.xy = rmod(q.xy,24.);\nq.y -= 2.;\n\nres = opu(res,vec2(length(q)-.2,5.));\n\nres = opu(res,vec2(    \n    max(-extr(q,petal(q.xy,.24,.12,.5),.1),\n    max(-extr(p.xzy-vec3(0.,0.,.05),abs(length(p.xz)-2.5)-.5,.05),\n    extr(p.xzy,abs(length(p.xz)-3.)-2.,.05) \n    ))\n    ,64.));\n\nreturn res;\n\n}\n\nvec2 trace(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = 4.;\n    float e = 12.; \n\n    for(int i = 0; i < 75; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(dist.x < EPS || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 25; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,325. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < .001 || ro.y+rd.y*t > 1.) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * EPS;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 render(vec3 ro,vec3 rd) {\n\n    vec2 d = trace(ro,rd); \n\n    vec3 p = ro + rd * d.x;\n\n    vec3 n = calcNormal(p);\n    vec3 r = reflect(rd,n);    \n\n    vec3 linear = vec3(0.);\n\n    float amb = sqrt(clamp(.5+.5*n.y,0.,1.));\n    float fre = pow(clamp(1.+dot(n,rd),0.,1.),2.);\n    float re = smoothstep(-2.,2.,r.y);\n\n    vec3 col = vec3(.5);\n    vec3 bg_col = vec3(1.);\n    col = bg_col * max(1.,rd.y);\n\n    vec3 l = normalize(vec3(-25.,10.,5.));\n    vec3 h = normalize(l - rd);  \n\n    float dif = clamp(dot(n,l),0.0,1.0);\n    float spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n    * dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\n    if(d.y >= 0.) {\n\n        if(dif>.001){\n            dif *= shadow(p,l);\n        }\n        \n        if(re>.001) {\n           re  *= shadow(p,r);\n        }\n        \n        linear += dif * vec3(.5);\n        linear += amb * vec3(0.001);\n        linear += fre * vec3(.005,.002,.001);\n        linear += spe * vec3(0.001,0.001,.005)*re;\n\n        if(d.y == 64.) {\n\n            col = vec3(.5);        \n            float r = length(p);\n            float a = atan(p.z,p.x);\n            a += .05* f2(p.xz*24.);\n \n            col *= .9*mix(bg_col*-2.,\n                vec3(f2(vec2(24.*a,4.*r))),\n                f3(p)*length(p));\n\n        }\n\n        if(d.y == 108.) {\n        col = vec3(1.,.5,0.);\n        col += 2.;\n        }\n\n        if(d.y == 2.) {\n        col = vec3(3.);\n        }        \n\n        if(d.y == 1.) {\n        col = vec3(0.1);\n        }\n        \n        if(d.y == 8.) {\n            col = vec3(2.)+(re*1.5);\n \n        }\n\n        if(d.y == 20.) {\n\n            p *= 3.25;\n\n            col += fmCol(dd(p),vec3(f3(p),h11(45.),h11(124.)),\n                   vec3(h11(235.),f3(p),h11(46.)),\n                   vec3(h11(245.),h11(75.),f3(p)),\n                   vec3(1.,spiral(p.xz,.5),.5));\n\n\n            col += mix(col,cell(p+f3(p*sin3(p,h11(100.)*45.\n            )),12.)*col,rd.y*rd.x*col.z)*.01;     \n    \n         \n        }    \n\n        if(d.y == 5.) {\n            col = vec3(.1,.5,.25);\n        }\n        \n          col = col * linear;\n          col = mix(col,bg_col,1.-exp(-.0001*d.x*d.x*d.x));         \n\n   }\nreturn col;\n}\n\nvoid main() { \n\nvec3 color = vec3(0.);\n\nvec3 ta = vec3(0.1);\nvec3 ro = vec3(-2.,4.,-3.);\nro.xz *= rot(t*.005);\n\nfor(int k = 0; k < AA; ++k) {\n    for(int l = 0; l < AA; ++l) { \n\nvec2 o = vec2(float(l),float(k))/ float(AA) -.5;\nvec2 uv = (2.* (fragCoord.xy+o) - R.xy)/R.y;\n\nvec3 rd = raydir(uv,ro,ta,2.);\nvec3 col = render(ro,rd);       \n\ncol = pow(col,vec3(.4545));\ncolor += col;\n   \n    }\n}\n\ncolor /= float(AA*AA);\nfragColor = vec4(color,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 268, 268, 411], [413, 413, 432, 432, 574], [576, 576, 594, 594, 746], [748, 748, 766, 766, 953], [955, 955, 985, 985, 1092], [1094, 1094, 1122, 1122, 1178], [1180, 1180, 1229, 1229, 1290], [1292, 1292, 1319, 1319, 1357], [1360, 1360, 1396, 1396, 1487], [1490, 1490, 1517, 1517, 1657], [1659, 1659, 1687, 1687, 2203], [2205, 2205, 2223, 2223, 2467], [2469, 2469, 2487, 2487, 2843], [2845, 2845, 2863, 2863, 3072], [3074, 3074, 3093, 3093, 3397], [3399, 3399, 3417, 3417, 3728], [3730, 3730, 3749, 3749, 3828], [3831, 3831, 3879, 3879, 4086], [4088, 4088, 4135, 4135, 4359], [4361, 4361, 4416, 4416, 4585], [4587, 4587, 4613, 4613, 4705], [4707, 4707, 4741, 4741, 5052], [5055, 5055, 5082, 5082, 5580], [5582, 5582, 5602, 5602, 7096], [7098, 7098, 7127, 7127, 7457], [7459, 7459, 7491, 7491, 7912], [7914, 7914, 7939, 7939, 8246], [8248, 8248, 8278, 8278, 10415], [10417, 10417, 10430, 10430, 10864]], "test": "error"}
{"id": "sld3RB", "name": "Polygonal Tunnel", "author": "Yusef28", "description": "My first tunnel attempt using a lot fo lighting code from shane [bump mapping, tri-planar, soft_shadow, ambient occlusion]", "tags": ["tunnel", "hexagon", "polygon", "pentagon"], "likes": 12, "viewed": 170, "published": "Public API", "date": "1636323151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n    The code here is kind of messy\n    but in the end the geometry is \n    based on modPolar. Then I add\n    glow, texture, bumpmapping, etc.\n    \n    There are definitly a ton of cool\n    things you can do with this type\n    of tunnel. Changing the number\n    of angles is an easy one.\n    \n    Jeyko has some really good ones:\n    \n    https://www.shadertoy.com/view/Wl3XD2\n    https://www.shadertoy.com/view/wdXczn\n    https://www.shadertoy.com/view/ttdXzj\n\n*/\n\n//you can change number of angles here but only 5 plus works without\n//issues but if you are willing to reduce the radius\n//most of the artifacts can be hidden.\n#define number_of_angles 8.\n#define defined_radius .9\n\n\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n#define TX texture\n#define C clamp\n\n#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define pi 3.14159265\n#define air 1.\n#define glass 1.4\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n    \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.);\n}\nfloat sdBox2D(vec3 p, vec3 d){\n    p = abs(p)-d;\n    //return length(max(p,0.)) + \n    return max(p.x,p.z);\n}\nvec2 modPolar(vec2 p, float n){\n\n    float a0 = float(n) / radians(360.); \n    float a = round( atan(p.y, p.x) * a0 ) / a0;\n    \n    p -= vec2(cos(a), sin(a));\n    \n    p *= rot(-a);\n    \n    return p;\n}\n\nvec3 path(vec3 p){\n     p.x += sin(p.z/4.);\n     p.y += sin(p.z/4.+3.);\n     return p;\n}\n\nfloat globalID = -1.;\nfloat glow;\n\nfloat map(vec3 p){\n    \n    p = path(p);\n    p.xy*=rot(p.z/20.);\n    float radius = defined_radius;//0.8\n    float num = number_of_angles; //5 to 8\n    float z = sin(floor(p.z/4.))/4.;\n    float d = length(p.xy) - 2.;\n    //p.xy -= vec2(z);\n    \n    //magic!\n    vec3 st = vec3(modPolar(p.xy, num), mod(p.z, 4.)-2. );\n    \n    float wall = sdBox( st-vec3(radius,0.,0.), vec3(0.1,2.,2.) );\n    d = min(-d,wall);\n    //d = min(d, length(st-vec3(radius,0.,0.))-0.3);\n    \n    //d = min(d, sdBox( st-vec3(radius,0.,0.), vec3(0.6,.3, pow(length(p.xy)-1., 2.7) ) ));\n    \n    //door layer one thick\n    float layer1 = sdBox( st-vec3(radius,0.,0.), vec3(0.5,2.,.1) );\n    //door layer two thinner\n    float layer2 = sdBox( st-vec3(radius,0.,0.), vec3(0.8,2.,.08) );\n    //door layer three really thin edge thing\n    float layer3 = sdBox( st-vec3(radius,0.,0.), vec3(0.84,.7,.01) );\n    \n    d = min(d,min(layer1,min(layer2,layer3)));\n    \n    vec3 st3 = vec3(modPolar(p.xy, num), mod(p.z, .2)-.1);\n    float lines = sdBox( st3-vec3(radius*1.0,0.,0.), vec3(0.13,1.,.02) );\n    //float lines = sdBox( st3-vec3(radius,0.,0.), vec3(0.15,1.,.03) );\n    d = min(d,lines);\n\n    vec3 st2 = vec3(modPolar(p.xy, num), mod(p.z, 2.)-1.);\n    //panel thing\n    float panel = sdBox( st2-vec3(radius,0.,0.), vec3(0.13,.6,.9));\n    d = min(d,panel);\n    //panel-indent thing\n    //first version has artifacts\n    //float indent = sdBox( st2-vec3(radius*0.74,0.,0.), vec3(0.15,.58,.8) );\n    float indent = sdBox( st2-vec3(radius*0.74,0.,0.), vec3(0.15,.5,.75) );\n    d = smax(d, -indent,0.003);\n    float outdent = sdBox( st2-vec3(radius,0.,0.), vec3(0.15,.5,.78) );\n    d = min(d, outdent);\n    \n    //ramp thing\n    float ramp = sdBox( st-vec3(radius,0.,0.), vec3(0.6,.3, pow(length(st.x/6.), .7) ));\n    //ramp = max(ramp, -sdBox( st-vec3(radius,0.,-.3), vec3(0.5,.05, 0.2 ) ));\n    d = smin(d,ramp,0.01);\n    \n    vec3 st4 = vec3(p.x,p.y,mod(p.z,2.)-1.);\n    float bridge = sdBox( st4-vec3(0.,-1.1,0.), vec3(0.6,.04, .8 ));\n    //d = min(d,bridge);\n    \n    if(wall <= d)globalID = 4.;\n    else if(outdent <= d)globalID = 6.;\n    else if(layer1 <= d)globalID = 1.;\n    else if(layer2 <= d)globalID = 2.;\n    \n    else if(layer3 <= d){\n        globalID = 3.;\n        //glow += abs(max(0.0001,(0.00005/(0.03*pow(layer3, 1.)))));\n        //glow += abs(max(0.0001,(0.0001/(0.0075*pow(layer3,.7 - 0.2*sin(iTime))))));//* (.5-augen*1.5);\n        \n        //attempting to cut off artifacts with a smoothstep\n        glow += smoothstep(0.2,1.,0.015/pow(layer3,.9))*4.;\n    }\n    \n    else if(lines <= d){globalID = 5.; \n       glow += abs(max(0.0001,(0.00009/(0.03*pow(lines, 1.)))));\n    \n    }\n    else if(panel <= d)globalID = 4.; \n    else if(ramp <= d)globalID = 7.; \n    //else if(bridge <= d)globalID = 8.; \n    return d;\n    //+sin(atan(p.x,p.y)*80.)/80. + sin(p.z*8.)/8.;   \n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < 0.007 || t > MAX_DIST) break;\n        t += d*0.65;\n    }\n    \n    return t;\n}\n\n\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zoom){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zoom;\n    return normalize(rd);\n\n}\n\n//from shane\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n//from shane, and he got it from an nvidia tutorial you can google\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;\n    return vec3(texture(tex, p.yz)*norm.x + \n                texture(tex, p.xz)*norm.y +\n                texture(tex, p.xy)*norm.z) ;\n    \n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n\n    \n    \n    \n    const vec3 eps3 = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps3, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps3.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps3.yzx, n)) - ref)/eps3.xxx;\n    \n    grad -= n*dot(grad, n);\n\n    return normalize(n + grad*bumpfactor);\n}\n\nfloat calcAo(vec3 p, vec3 n)\n{\n \nconst float ao_samples = 5.;\n    float r = 0.0, w = 1.0, d;\n    for(float i = 0.01 ; i<ao_samples ; i+=1.1)\n    {\n    d = i/ao_samples;//1/5, 2/5, 3/5, 4/5, 1\n    r += w*(d - map(p + n*d));\n\n       \n    w*=0.5;\n    }\n\n    return 1.0 - clamp(r,0.0, 1.0);\n}\n\nfloat sss(vec3 p, vec3 ldir, float distToTravel){\n  \n  //Here is my basic understanding:\n  //step out form the hit point a bit in the direction of the sun\n  //find dist from map\n  //whne map dist is equal to step dist w have a/b = 1.\n  //when map dist is smaller we have a/b < 1.\n\n\n  return smoothstep(0.,1.,map(p + ldir*distToTravel)/distToTravel);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0., 0., -3.+iTime*5.);\n    ro = vec3(-path(ro).xy,ro.z);\n    //ro.yz *= rot(-m.y*pi+1.);\n    //ro.xz *= rot(-m.x*pi*2.);\n    \n    //I was getting some artifacts when I had y at 0.4 or -0.4\n    //for these lights. Glow related artifacts, which was weird.\n    //So I am just letting the x and y be guided by ro.\n    vec3 farLight = ro +vec3(0.,0.,1.4);\n    vec3 closeLight = ro +vec3(0.,-0.,-1.4);\n    vec3 rd = camRay(uv, ro, ro +vec3(0.,0.,1.), 0.8);\n    \n    float t = min(MAX_DIST,trace(ro, rd));\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);//TX(iChannel0, rd).rgb;\n    vec3 rcol = vec3(0.);\n    if(t < MAX_DIST){\n    \n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        //col = n*0.5+0.5;//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        //col = abs(fract(vec3(atan(p.y,p.x)*pi,p.z,p.z))-0.5);\n        //col= n*0.5+0.5;\n        vec3 seedColor= vec3(1.,2.,4.)/2.;\n        seedColor.xy *= rot(0.8);\n        vec3 alb = 0.5+0.5*cos(seedColor + globalID*6. + 8.);\n        //vec3 alb = 0.5+0.5*cos(seedColor + globalID*6. + 1.);\n        //vec3 alb = 0.5+0.5*cos(vec3(1.,2.,4.)/2. + globalID*5.+1.);\n        if(globalID < 2.) {\n            alb *= triPlanar(iChannel0,p/2.,n).xxx;\n            n = bumpMap(iChannel0, p, n, 0.01);\n        }\n        else if(globalID == 6.){ alb = pow(\n            triPlanar(iChannel0,p/2.,n).zxx,vec3(8.))*7.;\n            n = bumpMap(iChannel0, p/2., n, 0.002);\n            }\n        \n        else if(\n            globalID < 8.){ alb *= triPlanar(iChannel0,p/2.,n).xxx;\n            n = bumpMap(iChannel0, p/2., n, 0.004);\n        }\n   \n\n        //light 1\n        float ldist = length(farLight-p);\n        vec3 ldir = (farLight-p)/ldist;\n        float diff = max(dot(ldir,n),0.);\n        float spec = pow(max(dot(reflect(-ldir,n),-rd),0.),200.)*3.;\n        col = alb*0.9*diff + spec*vec3(0.5,0.8,0.9);\n        \n        \n        float sha = softShadow(p,farLight,20.);\n        float ao = calcAo(p,n);\n        col *= ao;\n        col *= sha;\n        \n        \n\n        //light 2\n        ldist = length(closeLight-p);\n        ldir = (closeLight-p)/ldist;\n        diff = max(dot(ldir,n),0.);\n        spec = pow(max(dot(reflect(-ldir,n),-rd),0.),100.)*4.;\n        col += alb*0.3*diff*vec3(1.,0.7,0.7);\n        col/=2.;\n        rd = reflect(rd,n);\n        ro = p + n*0.01;\n        col += clamp(glow,0.,1.);//*pow(t/MAX_DIST,.7);\n        /*\n        \n        if(globalID == 6.){\n            glow = 0.;\n            globalID = -1.;\n            t = min(MAX_DIST,rtrace(ro, rd));\n            if(t < MAX_DIST){\n\n            vec3 p = ro + rd*t;\n            vec3 n = normal(p);\n            //col = n*0.5+0.5;//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n            //rcol = abs(fract(vec3(atan(p.y,p.x)*pi,p.z,p.z))-0.5);\n           // rcol= n*0.5+0.5;\n            vec3 alb = 0.5+0.5*cos(vec3(1.,2.,4.)/4. + globalID*5.+1.);\n\n            float ldist = length(farLight-p);\n            vec3 ldir = (farLight-p)/ldist;\n            float diff = max(dot(ldir,n),0.);\n            float spec = pow(max(dot(reflect(-ldir,n),-rd),0.),8.);\n            rcol = alb*diff + spec/1.4 + clamp(glow,0.,1.);\n\n            }\n        }*/\n    }\n    \n    col = mix(col,vec3(0.), pow(t/MAX_DIST,1.5))*1.;\n    // Output to screen\n    col = pow(col, vec3(0.67));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[875, 875, 916, 916, 1009], [1011, 1011, 1051, 1051, 1158], [1160, 1160, 1178, 1178, 1241], [1247, 1247, 1275, 1275, 1363], [1364, 1364, 1394, 1394, 1473], [1474, 1474, 1505, 1505, 1677], [1679, 1679, 1697, 1697, 1767], [1804, 1804, 1822, 1822, 4662], [4664, 4664, 4694, 4694, 4890], [4893, 4893, 4913, 4913, 5114], [5115, 5115, 5169, 5169, 5414], [5416, 5429, 5473, 5590, 6887], [6888, 6888, 6911, 6911, 6966], [6968, 7035, 7082, 7082, 7348], [7350, 7350, 7419, 7419, 7933], [7935, 7935, 7965, 7965, 8223], [8225, 8225, 8274, 8504, 8579], [8581, 8581, 8638, 8688, 12124]], "test": "error"}
{"id": "sldGDn", "name": "OK HSL Test", "author": "wnu", "description": "implemented from https://bottosson.github.io/posts/colorpicker/ Thank you Björn Ottosson, this way of picking color is awesome!\n", "tags": ["color", "hsl", "okhsl"], "likes": 3, "viewed": 43, "published": "Public", "date": "1636020201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592653589793\n#define FLT_MAX 3.402823466e+38\n\n// code from https://www.shadertoy.com/view/XljGzV\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n//Code from https://www.shadertoy.com/view/WtccD7\n\n// i think I have to include this\n\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\nfloat f_inv(float x)\n{\n    if (x >= 0.04045)\n        return pow((x + 0.055)/(1. + 0.055),2.4);\n    else \n        return x / 12.92;\n}\n\nvec3 f_inv3(vec3 x)\n{\n    vec3 o = vec3(0.);\n    o.x = f_inv(x.x);\n    o.y = f_inv(x.y);\n    o.z = f_inv(x.z);\n    return o;\n}\n\n//Code from https://bottosson.github.io/posts/colorpicker/ \n\n//Copyright (c) 2021 Björn Ottosson\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of\n//this software and associated documentation files (the \"Software\"), to deal in\n//the Software without restriction, including without limitation the rights to\n//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n///of the Software, and to permit persons to whom the Software is furnished to do\n//so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206;\n\tfloat k_2 = 0.03;\n\tfloat k_3 = (1.+ k_1) / (1. + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nstruct Cs { float C_0; float C_mid; float C_max; };\nstruct LC { float L; float C; };\nstruct RGB { float r; float g; float b; };\nstruct Lab { float L; float a; float b; };\nstruct ST { float S; float T; };\n\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328 * a - 0.80936493 * b > 1.)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277; k1 = +1.76576728; k2 = +0.59662641; k3 = +0.75515197; k4 = +0.56771245;\n\t\twl = +4.0767416621; wm = -3.3077115913; ws = +0.2309699292;\n\t}\n\telse if (1.81444104 * a - 1.19445276 * b > 1.)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515; k1 = -0.45954404; k2 = +0.08285427; k3 = +0.12541070; k4 = +0.14503204;\n\t\twl = -1.2684380046; wm = +2.6097574011; ws = -0.3413193965;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652; k1 = -0.00915799; k2 = -1.15130210; k3 = -0.50559606; k4 = +0.00692167;\n\t\twl = -0.0041960863; wm = -0.7034186147; ws = +1.7076147010;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774 * a + 0.2158037573 * b;\n\tfloat k_m = -0.1055613458 * a - 0.0638541728 * b;\n\tfloat k_s = -0.0894841775 * a - 1.2914855480 * b;\n\n\t{\n\t\tfloat l_ = 1. + S * k_l;\n\t\tfloat m_ = 1. + S * k_m;\n\t\tfloat s_ = 1. + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3. * k_l * l_ * l_;\n\t\tfloat m_dS = 3. * k_m * m_ * m_;\n\t\tfloat s_dS = 3. * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6. * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6. * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6. * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5 * f * f2);\n\t}\n\n\treturn S;\n}\n\nRGB oklab_to_linear_srgb(Lab c)\n{\n\tfloat l_ = c.L + 0.3963377774 * c.a + 0.2158037573 * c.b;\n\tfloat m_ = c.L - 0.1055613458 * c.a - 0.0638541728 * c.b;\n\tfloat s_ = c.L - 0.0894841775 * c.a - 1.2914855480 * c.b;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n    \n    RGB o;\n    o.r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;\n    o.g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;\n    o.b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;\n\n\treturn o;\n}\n\n\n//cbrt from https://www.shadertoy.com/view/wts3RX\n\n\nfloat cbrt( float x )\n{\n\tfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\n\tfor( int i = 0; i < 2; ++i )\n    \ty = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < 0; ++i )\n    {\n    \tfloat y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\nLC find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n    Lab lab;\n    lab.L =  1.;\n    lab.a = S_cusp * a;\n    lab.b = S_cusp * b;\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tRGB rgb_at_max = oklab_to_linear_srgb(lab);\n\tfloat L_cusp = cbrt(1. / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n    LC lc;\n    lc.L = L_cusp;\n    lc.C = C_cusp;\n\n\treturn lc;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, LC cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.C * L0 / (C1 * cusp.L + cusp.C * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.C * (L0 - 1.) / (C1 * (cusp.L - 1.) + cusp.C * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774 * a + 0.2158037573 * b;\n\t\t\tfloat k_m = -0.1055613458 * a - 0.0638541728 * b;\n\t\t\tfloat k_s = -0.0894841775 * a - 1.2914855480 * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1. - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3. * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3. * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3. * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6. * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6. * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6. * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1.;\n\t\t\t\tfloat r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt;\n\t\t\t\tfloat r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1.;\n\t\t\t\tfloat g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt;\n\t\t\t\tfloat g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5 * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s - 1.;\n\t\t\t\tfloat b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.7076147010 * sdt;\n\t\t\t\tfloat b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.7076147010 * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0. ? t_r : FLT_MAX;\n\t\t\t\tt_g = u_g >= 0. ? t_g : FLT_MAX;\n\t\t\t\tt_b = u_b >= 0. ? t_b : FLT_MAX;\n                \n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tLC cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nST to_ST(LC cusp)\n{\n\tfloat L = cusp.L;\n\tfloat C = cusp.C;\n    \n    ST st;\n    st.S = C / L;\n    st.T = C / (1. - L);\n\treturn st;\n}\n\nST get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993 + 1. / (\n\t\t+7.44778970 + 4.15901240 * b_\n\t\t+ a_ * (-2.19557347 + 1.75198401 * b_\n\t\t\t+ a_ * (-2.13704948 - 10.02301043 * b_\n\t\t\t\t+ a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642 + 1. / (\n\t\t+1.61320320 - 0.68124379 * b_\n\t\t+ a_ * (+0.40370612 + 0.90148123 * b_\n\t\t\t+ a_ * (-0.27087943 + 0.61223990 * b_\n\t\t\t\t+ a_ * (+0.00299215 - 0.45399568 * b_ - 0.14661872 * a_\n\t\t\t\t\t)))\n\t\t);\n        \n    ST st;\n    st.S = S;\n    st.T = T;\n\n\treturn st;\n}\n\n\n\nCs get_Cs(float L, float a_, float b_)\n{\n\tLC cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1., L, cusp);\n\tST ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.S), (1. - L) * ST_max.T);\n\n\tfloat C_mid;\n\t{\n\t\tST ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.S;\n\t\tfloat C_b = (1. - L) * ST_mid.T;\n\t\tC_mid = 0.9 * k * sqrt(sqrt(1. / (1. / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.\n\t\tfloat C_a = L * 0.4;\n\t\tfloat C_b = (1. - L) * 0.8;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1. / (1. / (C_a * C_a) + 1. / (C_b * C_b)));\n\t}\n    \n    Cs cs;\n    cs.C_0 = C_0;\n    cs.C_mid = C_mid;\n    cs.C_max = C_max;\n\n\treturn cs;\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308 >= a ? 12.92 * a : 1.055 * pow(a, .4166666666666667) - .055;\n}\n\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n    \n\n\tif (l == 1.0)\n\t{\n\t\treturn vec3(1., 1., 1.);\n\t}\n\n\telse if (l == 0.)\n\t{\n\t\treturn vec3( 0., 0., 0. );\n\t}\n\n\tfloat a_ = cos(2. * pi * h);\n\tfloat b_ = sin(2. * pi * h);\n\tfloat L = toe_inv(l);\n\n\tCs cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.C_0;\n\tfloat C_mid = cs.C_mid;\n\tfloat C_max = cs.C_max;\n\n    // Interpolate the three values for C so that:\n    // At s=0: dC/ds = C_0, C=0\n    // At s=0.8: C=C_mid\n    // At s=1.0: C=C_max\n\n\tfloat mid = 0.8;\n\tfloat mid_inv = 1.25;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1. - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1. - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1. - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1. - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1. - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1. - k_2 * t);\n\t}\n    \n    Lab lab;\n    lab.L = L;\n    lab.a = C*a_;\n    lab.b = C*b_;\n\n\tRGB rgb = oklab_to_linear_srgb(lab);\n    \n    \n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = hsl2rgb(vec3(uv.x,0.5,uv.x));\n    \n    float off = 0.5;\n    float theta = 2.*3.141592653589793*uv.y;\n    float chroma = 0.2*.33;\n    float L = uv.x;\n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 Lab = vec3(L,a,b);\n    \n    //col = linear_srgb_from_oklab(Lab);\n    ////col = pow(col,vec3(1./2.2));\n    \n    col = okhsl_to_srgb(vec3(uv.y+iTime/10.,0.6,uv.x));\n    \n    //col = pow(col,vec3(1./2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 141, 141, 284], [1385, 1385, 1422, 1422, 1536], [1538, 1538, 1575, 1575, 1650], [1652, 1652, 1674, 1674, 1784], [1786, 1786, 1807, 1807, 1912], [3069, 3069, 3093, 3093, 3218], [3425, 3425, 3473, 3625, 5384], [5386, 5386, 5419, 5419, 5902], [5957, 5957, 5980, 5980, 6289], [6291, 6291, 6323, 6383, 6818], [6820, 6820, 6908, 6969, 9258], [9260, 9260, 9339, 9379, 9467], [9469, 9469, 9488, 9488, 9599], [9601, 9601, 9636, 9636, 10137], [10141, 10141, 10181, 10181, 11201], [11203, 11203, 11242, 11242, 11322], [11325, 11325, 11355, 11355, 12460], [12462, 12462, 12519, 12569, 13114]], "test": "valid"}
{"id": "sldGRS", "name": "yee1212", "author": "dspindler", "description": "cool shader\n", "tags": ["yeex"], "likes": 6, "viewed": 83, "published": "Public", "date": "1636304217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n    mat4 m = rotationMatrix(axis, angle);\n    return (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sdSphere( vec3 p)\n{\n    return length(p)-.5;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SineCrazy(vec3 p) {\nreturn 1. - (sin(p.x) - sin(p.y) + sin(p.z))/3.;\n   // return 1.-(p.x*p.x - p.y +cos(p.z))/3.;\n}\nfloat CosCrazy(vec3 p) {\nreturn 1.-(cos(p.x) + 2.*cos(p.y) + cos(p.z))/3. ;\n}\n\nfloat sdOctahedron( vec3 p)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-0.8;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+0.5),0.0,0.5); \n  return length(vec3(q.x,q.y-0.5+k,q.z-k)); \n}\n\n       \n\nfloat scene(vec3 p){\n    vec3 p1 = rotate(p,vec3(0.1,1.,0.1),iTime/10.);\n    // return sdBox(p1, vec3(0.5,0.5,0.5));\n    float scale = 8.+ 5.*sin(iTime/12.);\n    \n    return max(sdOctahedron(p1), (0.85 - SineCrazy(p1*scale))/scale);\n}\n\nvec3 getNormal(vec3 p){\n\t\n\tvec2 o = vec2(0.001,0.);\n\t// 0.001,0,0\n\treturn normalize(\n\t\tvec3(\n\t\t\tscene(p + o.xyy) - scene(p - o.xyy),\n\t\t\tscene(p + o.yxy) - scene(p - o.yxy),\n\t\t\tscene(p + o.yyx) - scene(p - o.yyx)\n\t\t)\n\t);\n}\n\nvec3 GetColorAmount(vec3 p) {\n    float amount = clamp((1.5-length(p))/2. , 0., 1.);\n    vec3 col = 0.5 + 0.5 * cos(6.28319 * (vec3(0.2,0.0,0.0) + amount * vec3(1.0,1.0,0.5)));\n    return col*amount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 newUV = fragCoord/iResolution.xy;\n    \n    vec2 p = newUV - vec2(0.5);\n    \n    \n    vec3 camPos = vec3(-0.5,0.,2.+0.5*sin(iTime/4.));\n    \n    \n    vec3 ray = normalize(vec3(p, -1.));\n    \n    vec3 rayPos = camPos;\n    float curDist = 0.;\n    float rayLen = 0.;\n    \n    vec3 light = vec3(-1.,1.,1.);\n    \n    vec3 color = vec3(0.);\n   \n    for(int i=0;i<64;++i){\n        curDist = scene(rayPos);\n        rayLen += 0.6*curDist;\n    \n        rayPos = camPos + ray*rayLen;\n        if(abs(curDist)<0.001){\n        \n            vec3 n = getNormal(rayPos);\n            \n            float diff = dot(n,light);\n            // color = GetColor(length(2.*rayPos));\n            break;\n        }\n        color += 0.04*GetColorAmount(rayPos);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 673], [674, 674, 719, 719, 798], [800, 800, 825, 825, 852], [854, 854, 884, 884, 973], [975, 975, 1000, 1000, 1097], [1098, 1098, 1122, 1122, 1175], [1177, 1177, 1206, 1206, 1494], [1505, 1505, 1525, 1525, 1739], [1741, 1741, 1764, 1764, 1962], [1964, 1964, 1993, 1993, 2165], [2168, 2168, 2224, 2274, 3084]], "test": "valid"}
{"id": "sldGWj", "name": "RainbowPlasma", "author": "YDOG", "description": "Rainbow plasma shader", "tags": ["noise", "plasma", "rainbow"], "likes": 1, "viewed": 26, "published": "Public", "date": "1636755885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// references:\n// https://www.shadertoy.com/view/Md23DV\n// https://www.shadertoy.com/view/Msf3WH\n// https://en.wikipedia.org/wiki/Plasma_effect \n\n// TODO: \n// scrolling noise function\n// interpolate gradient based on noise\n// rainbow gradient\n// use HSV instead of RGB\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(length(r) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\n\t//if(p.x < 1./10.) { // Part I\n\t//\t// vertical waves\n\t//\tret = vec3(v1);\n\t//} else if(p.x < 2./10.) { // Part II\n\t//\t// horizontal waves\n\t//\tret = vec3(v2);\n\t//} else if(p.x < 3./10.) { // Part III\n\t//\t// diagonal waves\n\t//\tret = vec3(v3);\n\t//} else if(p.x < 4./10.) { // Part IV\n\t//\t// circular waves\n\t//\tret = vec3(v4);\n\t//} else if(p.x < 5./10.) { // Part V\n\t//\t// the sum of all waves\n\t//\tret = vec3(v);\n\t//} else if(p.x < 6./10.) { // Part VI\n\t//\t// Add periodicity to the gradients\n\t//\tret = vec3(sin(2.*v));\n\t//} else if(p.x < 10./10.) { // Part VII\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t//}\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 353, 353, 1399]], "test": "valid"}
{"id": "sldGzN", "name": "Wave184", "author": "FoRenard", "description": "Wave184", "tags": ["cineshader"], "likes": 5, "viewed": 95, "published": "Public", "date": "1635834007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 4\n#define BB 3\n\nfloat hash(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nvec2 hash2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat gnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( hash2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( hash2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat sdCircle(vec2 p,vec2 st,float r)\n{\n    return length(p-st)-r;\n}\n\nconst mat4x3[] pcol=mat4x3[](\n    mat4x3(0.5, 0.5, 0.5,\n           0.5, 0.5, 0.5,\n           2.0, 1.0, 0.0,\n           0.50, 0.20, 0.25\n    ),\n    mat4x3(0.8, 0.5, 0.4,\n           0.2, 0.4, 0.2,\n           2.0, 1.0, 1.0,\n           0.50, 0.20, 0.25\n    ),\n    mat4x3(0.5, 0.5, 0.5,\n           0.5, 0.5, 0.5,\n           1.0, 1.0, 1.0,\n           0.30, 0.20, 0.20\n    )\n);\n\nvec3 palette(float t,int id)\n{\n    vec3 a=pcol[id][0];\n    vec3 b=pcol[id][1];\n    vec3 c=pcol[id][2];\n    vec3 d=pcol[id][3];\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 gray(vec3 c){\n    return vec3(dot(c,vec3(0.298912,0.586611,0.114478)));\n}\nvec3 sepia(vec3 c){\n    return gray(c)*vec3(1.07,0.74,0.43);\n}\nint map(vec2 uv,float t)\n{\n    int id=0;\n    float i=t*1.2;\n\n    bool c=sdCircle(uv,vec2(0.0,0.5),0.3)<0.0;\n    bool s=uv.y-(0.5+sin(uv.x*10.0+i*2.0)*0.1)<0.0;\n    bool w1=uv.y-gnoise(vec2(uv.x-i*0.1,1.0))*0.5+0.1<0.0;\n    bool w8=uv.y-gnoise(vec2(uv.x+i*0.3,8.0))*0.5+0.3<0.0;\n    bool w4=uv.y-gnoise(vec2(uv.x-i*0.3,4.0))*0.5+0.5<0.0;\n    \n    id=c?s?1:2:id;\n    id=w1?3:id;\n    id=w8?4:id;\n    id=w4?5:id;\n    \n    return id;\n}\nvec3 render(in vec2 uv,float t)\n{\n    \n    vec3 col;\n    switch(map(uv,t))\n    {\n        case 0:\n            col=palette(uv.y*0.1+0.96,0);\n            break;\n        case 1:\n            col=palette(-uv.y*0.5+0.0,1);\n            break;\n        case 2:\n            col=palette(uv.y*0.5+0.5,2);\n            break;\n        case 3:\n            col=palette(uv.y*0.8+0.4,1);\n            break;\n        case 4:\n            col=palette(-uv.y*0.7+0.5,2);\n            break;\n        case 5:\n            col=palette(uv.y*0.6+0.2,1);\n            break;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cols=vec3(0.0);\n    \n    for( int b=0; b<BB; b++ )\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 col=render(uv,iTime-1.5*float(b)/float(BB));\n        cols+=col;\n    }\n    \n    cols/=float(AA*AA*BB);\n    \n    /// postprocess\n    cols=mix(cols,sepia(cols),0.1);\n    cols*=1.0+0.1*sin(hash(fragCoord));\n    \n    \n    \n    fragColor = vec4(cols,1.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Wave184\",\n\t\"description\": \"Wave184\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 116], [117, 117, 137, 137, 276], [277, 277, 300, 300, 696], [697, 697, 737, 737, 766], [1140, 1140, 1170, 1170, 1314], [1315, 1315, 1333, 1333, 1393], [1394, 1394, 1413, 1413, 1456], [1457, 1457, 1483, 1483, 1887], [1888, 1888, 1921, 1921, 2451], [2453, 2453, 2510, 2510, 3033]], "test": "error"}
{"id": "slG3Dh", "name": "Beving (2021)", "author": "DrNoob", "description": "After the video for Joep Beving's \"Sinfonia (After Bach, BWV 248)\": https://youtu.be/mJa6QbJfvHk", "tags": ["noise", "rain", "reproduction"], "likes": 8, "viewed": 110, "published": "Public", "date": "1637589288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: Beving (2021)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the video for Joep Beving's \"Sinfonia (After Bach,\n// BWV 248)\": https://youtu.be/mJa6QbJfvHk\n//\n// Try the shader in fullscreen mode. Would make a nice screen\n// saver.\n\nconst float PI = 3.14159;\n\nconst vec3 COLOR_BG = vec3( 17,  26,  46) / 255.0;\nconst vec3 COLOR_FG = vec3(121, 133, 156) / 255.0;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 corners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// https://github.com/patriciogonzalezvivo/lygia\nvec3 brightness_contrast(in vec3 color, in float brightness, in float contrast ) {\n    return (color - 0.5) * contrast + 0.5 + brightness;\n}\n\nfloat stripes(in vec2 p, in float nstripes) {\n    // Stripe config\n    vec2 sc = vec2(nstripes, 1.0) * p;\n    vec2 id = floor(sc);\n    vec2 cc = fract(sc);\n    \n    // Random variables\n    float r1 = hash(id.x);\n    float r2 = hash(id.x * 13.37);\n    float r3 = hash(id.x * 47.11);\n    float r4 = hash(id.x * 73.23);\n    \n    // Horizontal variation\n    float freq = nstripes * PI;\n    float f = smoothstep(1.0, 0.0, sin(freq * p.x));\n    \n    // Vertical variation\n    float t = sin(0.25 * iTime + 10.0 * r1);   // Randomized time offset\n    float dt = cos(0.25 * iTime + 10.0 * r1);  // Derivative of time offset\n    float len = 0.9 * r2;                      // Randomized length\n    float slt = -0.01 + 0.02 * r3;             // Randomized slant\n    float ext = 0.2 * t * r4;                  // Randomized extent\n    f *= step(len + slt * cc.x - ext, cc.y);\n    \n    // Fade out when receeding\n    f *= smoothstep(-0.1, 0.5, dt);\n    \n    // Apply noise\n    f *= 0.5 + 0.5 * vnoise(10.0 * (cc + 0.2 * t));\n\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Background\n    vec3 col = mix(COLOR_BG, brightness_contrast(COLOR_FG, -0.3, 1.25), 1.0 - length(uv - vec2(0.5, 1.0)));\n    \n    // Stripe layers\n    col = mix(col, COLOR_FG, stripes(uv, 200.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.1, 1.0), stripes(uv + vec2(0.123, 0.0), 250.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.2, 1.0), stripes(uv + vec2(0.456, 0.0), 150.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.3, 1.0), stripes(uv + vec2(0.789, 0.0), 300.0));\n    \n    // Add layer of animated white noise\n    col += 0.1 * vec3(hash(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Vignetting\n    float vig = length(uv - vec2(0.5)) * 0.85;\n    vig = vig * vig + 1.0;\n    col *= 1.0 / (vig * vig);\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slG3Dh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[448, 489, 513, 513, 596], [598, 639, 662, 662, 780], [782, 782, 805, 805, 908], [910, 951, 976, 976, 1421], [1423, 1472, 1554, 1554, 1612], [1614, 1614, 1659, 1680, 2641], [2643, 2643, 2698, 2733, 3591]], "test": "valid"}
{"id": "slG3Wm", "name": "domain distortion.SV", "author": "turtlelover891", "description": "trying out cool ways to distort the domain", "tags": ["distortion"], "likes": 1, "viewed": 14, "published": "Public", "date": "1637877990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, vec2 pos, vec2 size, float blur){\n    float x1 = smoothstep(pos.x-blur, pos.x+blur, uv.x);\n    float x2 = smoothstep(pos.x+size.x+blur, pos.x+size.x-blur, uv.x);\n    float y1 = smoothstep(pos.y-blur, pos.y+blur, uv.y);\n    float y2 = smoothstep(pos.y+size.y+blur, pos.y+size.y-blur, uv.y);\n    return x1*x2*y1*y2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord.xy/R.y*R.x;\n    vec3 col = vec3(0.);\n    float t = iTime;\n\n    float x = uv.x;\n    float y = uv.y;\n    col.x += rect(uv, vec2(150.+sin(y*.5)*5.+sin(t)*100., 100.+sin(x*.5)*5.)+cos(t)*100.+R/2., vec2(100., 100.), (y+x)/10.)*10.;\n    col.y += rect(uv, vec2(float(1+int(y)%20)+cos(t*float(int(t)%9))*100.+200., float(1+int(x)%19)+sin(t*float(int(t)%11))*100.+100.)+R/2., vec2(100., 100.), 50.)*20.;\n    float pixelSize = (sin(t/1.5)+1.05)*100.;\n    col.z += rect(uv, vec2(float(int(x)%int(pixelSize))+cos(t*1.5)*100.+100., float(int(y)%int(pixelSize))+sin(t/1.5)*100.+100.)+R/2., vec2(100., 100.), pixelSize)*20.;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slG3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 335], [337, 337, 394, 394, 1092]], "test": "valid"}
{"id": "slG3zK", "name": "Segments: Sacred Bearings", "author": "Yusef28", "description": "A segment exercise", "tags": ["circles", "lines", "practice", "segments"], "likes": 15, "viewed": 186, "published": "Public API", "date": "1638160551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define eps 9./iResolution.y\n\n\n#define maxPoints 16.\n#define screenSize 2.9\nfloat rnd(vec2 id){\n    return sin(fract(dot(id,vec2(14.27,74.97)))*54329.34);\n}\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.01, 0., abs(length(uv)-r+0.01));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 id = floor(uv*screenSize);\n    uv = fract(uv*screenSize)*2.-1.;\n    \n    vec2 ringPos = vec2(0.,0.);\n    float radius = 0.5;\n    float ring1 = ring(uv-ringPos, radius);\n    vec3 col = vec3(0.);\n    col += ring1;\n    \n    float mx = 1.+floor(abs(mod(iTime*2.+rnd(id*89.)*831.,\n                        maxPoints)-maxPoints/2.))+1.;\n    vec2 now,last=vec2(0.,radius)*rot(iTime);\n    vec2 first = last;\n    col += ring(uv-last, 0.1);\n    col += point(uv-last, 0.04);\n    \n    for(float i = 1.; i < mx; i++){\n    \n        \n        now = vec2(0.,radius)*rot(iTime+i*pi*2./mx);\n        col += ring(uv-now, 0.1);\n        col += point(uv-now, 0.04);\n        col += line(uv,now,last,0.005);\n        \n        \n        \n        last = now;\n    }\n    col += line(uv,now,first,0.005);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slG3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 177], [178, 178, 196, 196, 259], [261, 261, 291, 291, 340], [342, 342, 371, 371, 434], [436, 436, 480, 480, 670], [672, 672, 729, 779, 1675]], "test": "valid"}
{"id": "slGGRR", "name": "Blackhole Raymarch Demo", "author": "Ludicrous", "description": "A simple raymarch demonstration I put together as a little mini-project. Enjoy!", "tags": ["raymarching", "physics", "graphics"], "likes": 2, "viewed": 41, "published": "Public", "date": "1637040689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 PixeltoWorldSpace(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y * 1.5;\n    float xRot = 3.1415 + iMouse.x / iResolution.x * -6.28;\n    return normalize(vec3(uv.x * cos(xRot) - sin(xRot), uv.y, cos(xRot) + uv.x * sin(xRot)));\n}\n\nvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return vec3(v) / 4294967296.0;\n}\n\nvec3 ProceduralStars(vec3 rayDir)\n{\n    vec3 r = (rayDir + vec3(1,1,1)) * 330.;\n    float probability = pcg3d(uvec3(r)).y - abs(rayDir.y) * 0.001;\n    if (probability < 0.999)\n        return vec3(0,0,0);\n    if (probability < 0.9996)\n        return vec3(1,.7,.59);\n    return vec3(1,.96,.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = PixeltoWorldSpace(fragCoord);\n    vec3 rayPos = vec3(sin(iTime * 0.758334) * .2, cos(iTime * 0.5548334) * .1,1.) * (exp(iMouse.y / iResolution.y * 3. - 1.) * -4.0 + 3.5); // Position of camera\n    \n    vec3 col = vec3(0,0,0);\n    float transparency = 1.0; // Fog, amount of light that could pass through to reach current pixel\n    bool crossedHorizon = false; float elapsedDist = 0.0;\n    for (int i = 0; i < 60; i++)\n    {\n        float distFromBH = length(rayPos);\n        float GravStr = 1.0 / (distFromBH * distFromBH * distFromBH);\n        \n        if (GravStr > 50.0) // Definitely within horizon\n        {\n           crossedHorizon = true;\n           i = 70;\n           continue;\n        }\n        if (elapsedDist > 150.0) // Outisde range\n        {\n           i = 70;\n           continue;\n        }\n        \n        rayPos += rayDir * distFromBH * 0.2; // Step ray forwards\n        rayDir = normalize(rayDir - normalize(rayPos) * GravStr * distFromBH * 0.2); // Apply gravity numerical integration\n        elapsedDist += distFromBH * 0.2; // track total distance\n        \n        float opacityFog = 1. - exp(-.25 * distFromBH / (rayPos.y * rayPos.y + 32.)); //Equatorial Fog for nice effect\n        col += vec3(.3, .4, .6) * transparency * opacityFog;\n        transparency *= 1. - opacityFog;\n    }\n\n    if (!crossedHorizon)\n        col += ProceduralStars(rayDir) * transparency; // Add stars\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 266], [268, 268, 289, 289, 506], [508, 508, 543, 543, 801], [803, 803, 860, 860, 2317]], "test": "valid"}
{"id": "slK3Rd", "name": "G' surface", "author": "DPiker", "description": "G' surface from\nTriply Periodic Bicontinuous Cubic Microdomain Morphologies by\nSymmetries\nhttps://www.msri.org/publications/sgp/jim/papers/morphbysymmetry/text/levelset.pdf\n\nhttps://twitter.com/KangarooPhysics/status/1462951297825525762\n", "tags": ["bicontinuous"], "likes": 3, "viewed": 97, "published": "Public API", "date": "1638229087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float timePeriod = 100.0;\n    float wavePeriod = 20.0;\n    float width = 1.5;\n    vec2 screenCoord = fragCoord - iResolution.xy/2.0;\n    vec2 uv =  width * screenCoord / min(iResolution.x, iResolution.y);\n    float x = uv.x;\n    float y = uv.y;\n    float z = 0.0;\n    z = wavePeriod * mod(iTime,timePeriod)/timePeriod;\n   \n    //G' from https://www.msri.org/publications/sgp/jim/papers/morphbysymmetry/text/levelset.pdf\n    float pi = 3.14159265359;\n    float d = \n    sin(4.0 *pi * x)* cos(2.0 * pi * y)* sin(2.0 * pi * z) +\n    sin(4.0 *pi * y)* cos(2.0 * pi * z)* sin(2.0 * pi * x) +\n    sin(4.0 *pi * z)* cos(2.0 * pi * x)* sin(2.0 * pi * y) + 0.32;\n    \n\n    float h = (1.3*d)/5.0;\n    float s = 0.8;\n    float l = 0.9 - 0.15*d;\n\n    if(0.42<d&&d<0.58){l=0.0;};\n\n    vec3 col = hsl2rgb(vec3(h,s,l));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 169], [171, 171, 228, 228, 1096]], "test": "valid"}
{"id": "slK3Wz", "name": "Vesica eye thing", "author": "SnoopethDuckDuck", "description": "kinda hacky and oversaturated but short code", "tags": ["e"], "likes": 5, "viewed": 117, "published": "Public API", "date": "1637531367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float r = length(uv);\n    //float a = atan(uv.y, uv.x);\n    //uv = vec2(0.2 * cos(a + 0.2 * iTime),r);\n   \n    float k = 10. + 8. * thc(3., r + iTime);\n    float sc = 6. * ceil(k * fract(abs(uv.y) + r - 0.2 * iTime));\n    float d = length(floor(sc * uv) + 0.5)/sc;\n    float s = smoothstep(-1., 0.5, 0.1 + 0.5 * h21(uv));\n    \n    // 33333. is super hacky\n    vec3 col = 1.1 * s * pal(d * 33333. + r - iTime * 0.1, \n               vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 140, 140, 183], [185, 185, 205, 205, 280], [282, 282, 339, 339, 919]], "test": "valid"}
{"id": "slK3zK", "name": "simple sphere+light ray marching", "author": "EDB_02", "description": "sksk", "tags": ["raymarching"], "likes": 3, "viewed": 43, "published": "Public", "date": "1638197687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define max_steps 256\n#define epsi 1e-5\n#define max_dist 100.0\n\nvec3 camPos = vec3(0, 0, 0);\n\nstruct Sphere{\n    vec3 pos;    //centre of the sphere\n    float radius;\n};\n\nstruct Ray{\n    vec3 pos;   //position of the ray\n    vec3 rot;   //direction\n};\n\nstruct Light{\n    vec3 pos;  //position\n};\n\nLight initLight(in vec3 pos){\n    Light l;\n    l.pos = pos;\n    return l;\n}\n\nSphere initSphere(in vec3 pos, in float r){\n    Sphere s;\n    s.pos = pos;\n    s.radius = r;\n    return s;\n}\n\nfloat sphereSDF(in vec3 point, in Sphere s){\n    return distance(point, s.pos)-s.radius;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nRay initRay(in vec3 pos,in vec2 fragCoord){\n    Ray r;\n    r.pos = pos;\n    r.rot = rayDirection(45.0, iResolution.xy, fragCoord);\n    return r;\n}\n\n// number of spheres\n\n#define sphereC 2\nSphere s[sphereC];\nLight l;\n\nbool check1 = false;\n\nvoid initScene(){\n    if(check1) return;   //initialize the scene only 1 time\n    check1 = true;\n    \n    s[0] = initSphere(vec3(0, 0, 10), 1.0f);\n    s[1] = initSphere(vec3(3, .5, 10), .5f);\n    l = initLight(vec3(10, 0, 20));\n}\n\nfloat sceneSDF(in vec3 p){\n    float ret = max_dist;\n    \n    for(int i=0;i<sphereC;++i){\n        ret = min(ret, sphereSDF(p, s[i]));\n    }\n    \n    //displacement ff\n    // ret += sin(5.0 * p.x ) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25 * sin(iTime);\n    \n    return ret;\n}\n\nvec3 estimateNormal(in vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + epsi, p.y, p.z)) - sceneSDF(vec3(p.x - epsi, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + epsi, p.z)) - sceneSDF(vec3(p.x, p.y - epsi, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + epsi)) - sceneSDF(vec3(p.x, p.y, p.z - epsi))\n    ));\n}\n\nvec3 getColor(in vec3 p){\n    \n    vec3 normal = estimateNormal(p);\n    \n    vec3 direction_to_light = normalize(p - l.pos);\n\n    float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n    return vec3(1.0, 1.0, 1.0) * diffuse_intensity;\n}\n\nvoid rotateLight(){\n    float x = 50.0 * sin(iTime);\n    float y = 50.0 * cos(iTime);\n    \n    l.pos = vec3(x, 30, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initScene();\n    \n    rotateLight();\n    \n    Ray ray = initRay(vec3(0), fragCoord);\n    \n    float dist;\n    \n    for(int i=0;i<max_steps;++i){\n        dist = sceneSDF(ray.pos);\n        \n        if(dist <= epsi){\n            fragColor = vec4(getColor(ray.pos), 1.0f);\n            break;\n        }\n        \n        if(dist >= max_dist){\n            fragColor = vec4(0.0f);\n            break;\n        }\n        \n        ray.pos += ray.rot * dist;\n    }    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 326, 326, 372], [374, 374, 417, 417, 482], [484, 484, 528, 528, 574], [576, 576, 633, 633, 756], [758, 758, 801, 801, 904], [997, 997, 1014, 1014, 1226], [1228, 1228, 1254, 1254, 1502], [1504, 1504, 1536, 1536, 1828], [1830, 1830, 1855, 1855, 2083], [2085, 2085, 2104, 2104, 2205], [2207, 2207, 2264, 2264, 2726]], "test": "valid"}
{"id": "slKGWw", "name": "Fractal knots", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 19, "viewed": 196, "published": "Public API", "date": "1637819323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = .0;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){    \n            //uv /= -scale-col.x;\n            uv /= -scale;\n            uv -= (t2.yx)/(scale);\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            t2 = triangle_wave(uv.yx-offset-.5,scale);\n            \n            t3 = triangle_wave(uv-offset,scale);\n            \n            uv.yx = (t2+t3)/scale;\n        }\n        //offset += .5/scale;\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKGWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1134]], "test": "valid"}
{"id": "slt3Dj", "name": "Fork bending sp hypnothala 005", "author": "hypnothalamus", "description": "bending space proof of concept\n", "tags": ["warp", "transform", "bend"], "likes": 5, "viewed": 106, "published": "Public API", "date": "1636771056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 bend( vec2 uv, float angle )\n{\n    const float BLOCK_HEIGHT = 1.;\n    const float BLOCK_WIDTH = .25;\n\n    float bendSign = angle < 0. ? -1. : 1.;\n    float bendRadius = BLOCK_HEIGHT / abs( angle );\n    \n    vec2 p = uv * vec2( bendSign, 1. ) + vec2( bendRadius, 0. );\n    \n    return vec2( ( length( p ) - bendRadius ) / BLOCK_WIDTH * bendSign + .5, atan( p.y, p.x ) / abs( angle ) + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    //uv.y += .5;\n      \n    float bendAngle = sin( iTime * 3. + .0001 ) * 6.28;        \n    \n    vec2 textureUV = bend( uv, bendAngle );\n    float textureUVIsValid = textureUV.x >= 0. && textureUV.x < 1. && textureUV.y >= 0. && textureUV.y < 1. ? 1. : 0.;\n                      \n    vec3 col = vec3( sin(textureUV*3.14*10.), .5 ) * textureUVIsValid;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 395], [397, 397, 454, 454, 922]], "test": "valid"}
{"id": "slt3RN", "name": "Raymarching - Transformations", "author": "HashSlasher", "description": "This is an example domain transformations on signed distance functions. This project was made by Colsen Stiles.", "tags": ["raymarching"], "likes": 1, "viewed": 36, "published": "Public", "date": "1635821936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 10000.\n#define SURF_DIST 0.01\n#define PI 3.14159\n\nint iterations = 100;\nfloat bailout = 6.;\n\n\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0) * 2. - 1.;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2. * PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.)) c = abs(c);\n\treturn c;\n}\n\nfloat pModPolarMirror(inout vec2 p, float repetitions) {\n\tfloat angle = 2. * PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n    a *= mod(c, 2.0) * 2. - 1.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.)) c = abs(c);\n\treturn c;\n}\n\n\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat modp(float pComponent, float n)\n{\n    return mod(pComponent + n, n * 2.) - n;\n}\n\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 v, in float a)\n{\n    vec4 q = quat(v, a);\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\nvec3 rotateq(in vec3 p, in vec4 q)\n{\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    p -= vec3(cos(iTime * 2.) * 6., sin(iTime * 2.) * 6. + 0.5, 4);\n\n    float dist = length(p - c) - r;\n    \n    return dist;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    \n    p -= vec3(3, 2, 10);\n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), iTime/8.);\n    p = rotate(p, normalize(vec3(1, 0, 0)), iTime/8.);\n    \n    float amt = sin(iTime) * 9.;\n    \n    pModMirror1(p.z, 25. + amt);\n    pModMirror1(p.y, 25. + amt);\n    pModMirror1(p.x, 25. + amt);\n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), iTime * 2.);\n    p = rotate(p, normalize(vec3(0, 0, 1)), 2. + iTime/2.);\n    \n    pModPolar(p.xz, 2. + 1.);\n    pMirror(p.z, 0.);\n    \n    p = rotate(p, normalize(vec3(0, 0, 1)), iTime * 1.);\n    \n    pModPolarMirror(p.yx, 8.);\n    \n    p.y -= 3.;\n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), 2. + iTime/3.);\n    p = rotate(p, normalize(vec3(0, 0, 1)), 2. + iTime/2.);\n    p = rotate(p, normalize(vec3(1, 0, 0)), 2. + iTime/1.);\n    \n    vec3 q = abs(p) - b;\n    return length( max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    p.z -= 5.;\n    p.z = mod(p.z + 1., 2.) - 1.;\n    p.x += 2.;\n    p.x = mod(p.x + 1., 2.) - 1.;\n    p.y -= 2.;\n    \n    p = rotate(p, normalize(vec3(1,1,1)), iTime * 0.5);\n    \n    \n    vec3 aToB = b - a;\n    vec3 aToP = p - a;\n    \n    float t = dot(aToB, aToP) / dot(aToB, aToB);\n    \n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t * aToB;\n    \n    float dist = length(p - c) - r;\n    \n    return dist;\n}\n\nfloat sdTorus(vec3 p, vec3 center, vec2 r)\n{\n    //p.x += 2.;\n    //p.y -= 2.;\n    //p.z -= 3.;\n    \n    p = p - center;\n    \n    \n    \n    //p *= 0.1;\n    \n    \n    p = rotate(p, normalize(vec3(0.2, 0, 1)), 2. + iTime/8.);\n    \n    p = rotate(p, normalize(vec3(0.3, 0.9, 1)), 2. + iTime/10.);\n    \n    //p = rotate(p, normalize(vec3(1, 0, 0.1)), iTime * 5.);\n    \n    //pModMirror1(p.x, 20. - iTime/1.);\n    \n    pModPolar(p.xz, 6. + sin(iTime) * 3.);\n    pMirror(p.z, 0.);\n    \n    p.x -= 9.;\n    \n    //pModPolarMirror(p.zx, floor(iTime/2.)*50.);\n    \n    \n    \n    pModMirror1(p.y, (sin(iTime) + 1.) * 8.);\n    //pModMirror1(p.z, iTime/10. + 15.);\n    //pModMirror1(p.x, iTime/10. + 5.);\n    //p.z -= 6.;\n    \n    //pModMirror1(p.y, iTime/10.) + 3.;\n    \n    //pMirror(p.x, 0.);\n    //pMirror(p.y, 0.);\n    \n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), 2. + iTime/2.7);\n    p = rotate(p, normalize(vec3(1, 0.9, 1)), 2. + iTime/1.);\n    \n    float x = length(p.xz)-r.x;\n    float dist = length(vec2(x, p.y)) - r.y;\n    return dist;\n}\n\nfloat GetDist(vec3 p)\n{       \n    //sphere\n    float sphereDist = sdSphere(p, vec3(0,3,4), 2.);\n    \n    //y=0 flat plane\n    float planeDist = p.y;\n    \n    //capsule\n    //float cd = sdCapsule(p, vec3(-0.1, 0, 0), vec3(0.1, 0, 0), 0.25);\n    \n    \n    //Box\n    float bd = sdBox(p, vec3(1.5));\n    \n    \n    //Torus - this includes the repeating\n    //float td = sdTorus(p, vec3(0,3,4), vec2(3., 0.5));\n    \n    \n    //float d = min(min(min((planeDist), planeDist), sphereDist), td);\n    \n    float smov = 3.;\n    \n    float d = min(min(sphereDist, planeDist), bd); //+ SURF_DIST;\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out bool hit, out int stepNum) {\n    //initialize distance to zero\n    float dist = 0.;\n    //Initialize hit bool\n    hit = false;\n    \n    stepNum = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        stepNum += 1;\n        vec3 p = ro + rd * dist;\n        float dS = GetDist(p);\n        dist += dS;\n        if(abs(dS) < SURF_DIST)\n        {\n            hit = true;\n            break;\n        }\n        else if(dist > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    return dist;\n}\n\nfloat RayMarch2(vec3 ro, vec3 rd, out bool hit) {\n    //initialize distance to zero\n    float dist = 0.;\n    //Initialize hit bool\n    hit = false;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dist;\n        float dS = GetDist(p);\n        dist += dS;\n        if(abs(dS) < SURF_DIST)\n        {\n            hit = true;\n            break;\n        }\n        else if(dist > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    return dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n     float d = GetDist(p);\n     vec2 e = vec2(0.01, 0);\n     vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n     return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(3, 10, -8);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 4.;\n    \n    vec3 lightDir = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, lightDir), 0., 1.);\n    \n    bool hit = false;\n    float distToLight = RayMarch2(p + n * SURF_DIST * 2., lightDir, hit);\n    if(distToLight < length(lightPos-p))\n    {\n        dif = 0.;\n    }\n    \n    return mix(dif, 0.6, 0.2);\n    //return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //Initialize camera / rays\n    vec3 ro = vec3(0, 6, -2);\n    //Determines field of view\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.4));\n    rd = rotate(rd, vec3(1,0,0), -(iMouse.y / iResolution.y - 0.5) * 6.);\n    rd = rotate(rd, vec3(0,1,0), (iMouse.x / iResolution.x - 0.5) * 3.);\n    \n    //Hit or not?\n    bool hit = false;\n    \n    int numSteps = 0;\n    \n    //Shoot rays\n    float d = RayMarch(ro, rd, hit, numSteps);\n    \n    //Initialize point, light brightness, and normal direction\n    vec3 p;\n    float dif;\n    vec3 normal;\n    \n    //If raycast hits\n    if(hit)\n    {\n        p = ro + rd * d;\n        \n        dif = GetLight(p);\n        \n        normal = GetNormal(p);\n    }\n    else\n    {\n        dif = 0.;\n        normal = vec3(0);\n    }\n    \n    col = vec3(dif);\n    //col = vec3(20./d)/6.;\n    //col = normal;\n    //col = (vec3(10./d) + normal) / 4.;\n    //col = vec3(1) * float(numSteps) / 50.;\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 175, 175, 296], [298, 298, 344, 344, 493], [495, 495, 545, 545, 939], [941, 941, 997, 997, 1423], [1426, 1426, 1469, 1469, 1520], [1522, 1522, 1561, 1561, 1648], [1650, 1650, 1689, 1689, 1735], [1737, 1737, 1771, 1771, 1822], [1824, 1824, 1850, 1850, 1882], [1884, 1884, 1905, 1905, 1930], [1932, 1932, 1968, 1968, 2226], [2228, 2228, 2275, 2275, 2355], [2357, 2357, 2393, 2393, 2448], [2451, 2451, 2492, 2492, 2621], [2623, 2623, 2652, 2652, 3520], [3522, 3522, 3572, 3572, 3984], [3986, 3986, 4030, 4081, 5026], [5028, 5028, 5051, 5071, 5637], [5639, 5639, 5704, 5738, 6177], [6179, 6179, 6228, 6262, 6657], [6659, 6659, 6683, 6683, 6883], [6885, 6885, 6909, 6909, 7359], [7361, 7361, 7418, 7468, 8574]], "test": "error"}
{"id": "slt3zH", "name": "Circle Thingy", "author": "allisj", "description": "I had no plan for what to do for this assignment and this is what happened ¯\\_(ツ)_/¯", "tags": ["sphere"], "likes": 0, "viewed": 42, "published": "Public", "date": "1635800983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getLatitude( vec2 pos, float radius ) {\n    return acos(length(pos)/radius);\n}\n\n\nfloat getLongitude( vec2 pos, float radius ) {\n    if (pos.x > 0.0) { return 0.5*atan(pos.y/pos.x)+2.36; }\n    else { return 0.5*atan(pos.y/pos.x)+0.8; };\n}\n\n// not used\nfloat getLongitude( vec2 pos, vec2 mouse, float radius ) {\n    if (pos.x > 0.0) { return 0.5*(atan(pos.y/pos.x)- atan(mouse.x/mouse.y))+2.36; }\n    else { return 0.5*(atan(pos.y/pos.x)-atan(mouse.x/mouse.y))+0.8; };\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - iMouse.xy)/iResolution.y;\n    \n    // did not end up using this\n    float mouseX= iMouse.x/iResolution.x;\n    float mouseY= iMouse.y/iResolution.y;\n    vec2 mouse = vec2(iMouse.x, iMouse.y);\n    mouse =  2.0*vec2(mouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec3 bgCol = texture(iChannel0, p).xyz; \n    //bgCol = vec3(0.0);\n\tvec3 colBlue = vec3(0.216, 0.471, 0.698);\n\tvec3 colRed = vec3(1.00, 0.329, 0.298);\n\tvec3 colYellow = vec3(0.867, 0.910, 0.247);\n\n\tvec3 pixel = bgCol;\n    \n\tfloat radius = iTime/50.0;\n    if (iTime > 35.0) {\n        radius = 0.7;\n    }\n    radius = 0.5 + 0.05*cos(iTime/1.5);\n\n    // draw sphereish thing\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n        pixel = colBlue * 0.8 * getLatitude(r, radius);\n        pixel += vec3(1.0,1.0,1.0)* 0.33 * getLongitude(r, radius);\n    }\n    \n    // draw glow behind\n    if( r.x*r.x + r.y*r.y >= radius*radius && r.x*r.x + r.y*r.y < radius*radius+0.5) {\n        pixel +=  colRed * smoothstep(0.0, 0.5, 0.5 - (r.x*r.x + r.y*r.y - radius*radius));\n        //pixel +=  colRed * (0.5 - (r.x*r.x + r.y*r.y - radius*radius)); \n\t}\n\t\n\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 84], [87, 87, 133, 133, 243], [245, 257, 315, 315, 474], [476, 476, 533, 533, 1746]], "test": "error"}
{"id": "slt3zM", "name": "jneen - volumetric fog w/ solid", "author": "jneen", "description": "fog! with a solid passing through it this time!", "tags": ["fog"], "likes": 10, "viewed": 77, "published": "Public", "date": "1635907310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rad(x) (radians(360.*(x)))\n#define time (iTime*.1)\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat glow;\n\n#define tri(x) (abs(fract((x)*.5)-.5)*2.)\n\nfloat scene(vec3 p) {\n\n  p.xz *= rot(rad(time));\n  p.xy *= rot(rad(time*sqrt(2.)));\n  p.yz *= rot(rad(2./6.));\n  \n  // define the glow as a regular sdf float\n  float B = box(p, vec3(1))-.3;\n  float S = sphere(p, 2.*(tri(time*2.)));\n  float glowbox = max(B,-S);\n\n\n  p -= sin(time*6.);\n  p.xz *= rot(time*10.);\n  p.yz *= rot(time*20.);\n  p.xy *= rot(time*30.);\n  float squeeze = 4.8;\n  float solid = mix(sphere(p,.1+2.*tri(time*2.)),box(p,vec3(.5)-.2),.5+.5*sin(time*17.));\n  \n  // a buffer between the solid and the fog to prevent\n  // super-bright areas on the solid as the raymarcher\n  // slows down. try setting this to 0 and see what happens\n  // should be at least DENSITY\n  // raising this is the best way to deal with edge glow around\n  // the solid\n  float BUFFER_ZONE = 0.05;\n  \n  \n  // lower = more dense fog. should be at least 1/stepcount\n  // (100 here)\n  float FOGSTEP = 1./300.;\n\n  // ==== and here's the 2-line fog effect ====\n  // * if we're inside the glowbox, increase the glow by how far\n  // we have penetrated into the box.\n  // * however, if we're passing close to the solid object, we have to\n  // not increase the glow because it will overcount as we step closer\n  // and closer to the solid. so we zero it out below the buffer zone\n  glow += max(0., -glowbox)*smoothstep(0.,BUFFER_ZONE*2.,solid);\n  \n  // step towards the glowbox by the distance we are inside the cube,\n  // plus a little buffer to get us inside the box. if we're *in* the\n  // box, we want to keep moving, and abs(glowbox) will make sure we're\n  // approximately inside the box still. note that we will *never* detect\n  // a surface at any point of the glowbox, because the minimum distance is\n  // always positive.\n  glowbox = abs(glowbox) + FOGSTEP;\n\n  return min(solid,glowbox);\n}\n\n\nfloat volumetricRay(vec3 start, vec3 dir) {\n  float dist=0.;\n  glow=0.;\n  \n  for (int i=0;i<300;i++) {\n    float c = scene(start+dir*dist);\n    dist += c;\n  }\n  \n  return min(dist,10000.);\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p) - mat3(.01);\n  return scene(p)-vec3(scene(K[0]),scene(K[1]),scene(K[2]));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float focus=2.;\n    vec3 cam = vec3(0,0,-5.*focus);\n    vec3 dir = normalize(vec3(uv,focus));\n    \n    float dist = volumetricRay(cam, dir);\n    float G = glow; \n    \n    vec3 norm = normalize(grad(cam+dir*dist));\n    \n    // thanks blackle for the awesome fake image lighting :3\n    float diff = 0.;\n\n    if (dist < 1000.) diff = length(sin(norm)*.5+.5)/sqrt(3.);\n\n    \n    vec3 col = diff*diff*vec3(.9,.1,.1);\n    \n    // lower numbers are a denser, more uniform fog\n    // high numbers are very glowy and a little glitchy\n    float UNIFORMITY = 0.8;\n    col += pow(G, UNIFORMITY) *.2 * vec3(.5, .9, 1);;\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 87, 87, 168], [170, 170, 201, 201, 225], [227, 227, 246, 246, 296], [353, 353, 374, 374, 2129], [2132, 2132, 2175, 2175, 2322], [2324, 2324, 2343, 2343, 2442], [2445, 2445, 2502, 2552, 3327]], "test": "valid"}
{"id": "sltGzS", "name": "Log Polar Multiscale Truchet", "author": "byt3_m3chanic", "description": "So now I've reworked how the tiles are split mathematically over hash value, then using a log polar warp @mla https://www.shadertoy.com/view/fttGzB Mouse down to see the gridlines @Shane. ", "tags": ["truchet", "tile", "multiscale", "quadtree"], "likes": 31, "viewed": 217, "published": "Public API", "date": "1636316484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Log Polar Multiscale Truchet [learning]\n    11/7/21 @byt3_m3chanic\n\n    https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n    \n    My original multiscale >> https://www.shadertoy.com/view/stt3Dr \n\n    So now I've reworked how the tiles are split mathematically and by\n    loop over random hash value. Also with the help of @mla the hash22\n    makes the tiles seamless in the log polar transform.\n    \n    Mouse down to see the grid lines.\n    \n    The original truchet work which was based off of\n    @Shane >> Quadtree Truchet ::  https://www.shadertoy.com/view/4t3BW4\n\n    Then mla showed me how to make the ends match and put it into a log polar\n    @mla   >> Multiscale Truchet + Log Polar :: https://www.shadertoy.com/view/fttGzB\n\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\nconst float N = 4.;\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { \n    p.y = mod(p.y,2.*N);//@mla : shifting the y value from the range [-PI,+PI] to [0,2N]\n    float n = sin(dot(p, vec2(57, 27)));\n    return fract(vec2(262144, 32768)*n);\n}\n\nfloat bkptrn(vec2 p, float res) {\n    p *= res/10.;\n    float hatch = clamp(sin((p.x - p.y)*PI*3.)*1. + 1.25, 0., 1.);\n    hatch = min(hatch,clamp(sin((p.x + p.y)*PI*3.)*1. + 1.25, 0., 1.));\n    return clamp(hatch,.4,.5);\n}\n\n//@mla\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 suv = uv;\n    suv*=rot(.3);\n    vec2 vuv = uv-vec2(.3535,0);\n    if(uv.x>-.3) {\n        vuv = clog(vuv);\n        vuv /= 3.14159;\n        vuv *= N;\n        vuv.x -= 0.3*T;\n    }else{\n        vuv *= N;\n        vuv.x += 0.3*T;\n    }\n    \n    \n    float px = fwidth(vuv.x);\n\n    // Distance field values.\n    vec4 d=vec4(1e5), d2=vec4(1e5), d3=vec4(1e5), d4=vec4(1e5), grid = vec4(1e5);\n    float level=1.;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // Ssee his shader for full comments and explanations.\n    // https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n    \n        vec2 id = floor(vuv*level);\n\n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n\n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 home = id+neighbors;\n                vec2 rnd = hash22(home);\n\n                // So we're using a checkered function based on\n                // the floor size much in the same way @Shane\n                // was using the hash22 to split areas - this is\n                // more calculated than hash random.\n                vec2 hmd2 = (floor(home/2.));\n                vec2 hmd4 = (floor(home/4.));\n                vec2 hmd8 = (floor(home/8.));\n                \n                float chk  = mod(home.y+home.x,2.)*2.-1.;\n                float chk2 = mod(hmd2.y+hmd2.x,2.)*2.-1.;\n                float chk4 = mod(hmd4.y+hmd4.x,2.)*2.-1.;\n                float chk8 = mod(hmd8.y+hmd8.x,2.)*2.-1.;\n\n                if(k>0 && chk2<.5) continue;\n                // threshold\n                if(k==0||k==1&&chk2>.5||k==2&&chk4>.5&&chk2>.5||k==3&&chk4>.5&&chk8>.5) {\n\n                    vec2 p = vuv -(id+.5+neighbors)/level;\n                   \n                    // square to mask off tiles.\n                    float square = max(abs(p.x), abs(p.y)) - .5/level;\n\n                    // The grid lines.\n                    grid.x = min(grid.x, abs(square)-.0025/2.);\n\n                    // TILE COLOR ONE.\n                    // Standard Truchet rotation and flipping.\n                    if(rnd.x<.5) p.xy = p.yx;\n                    if(fract(rnd.x*57.5 + .35)<.5) p.x = -p.x;\n\n                    // Four circles on the midway points of the grid boundary\n                    vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - vec2(.5, .5)*.7071/level;\n                    float c3 = length(p2) - .5/3./level;\n  \n                    // Truchet arc one.\n                    float c = abs(length(p - vec2(-.5, .5)/level) - .5/level) - .5/3./level;\n \n                    // Truchet arc two.\n                    float c2;\n                    if(fract(rnd.x*157.763 + .49)>.15){\n                        c2 = abs(length(p - vec2(.5, -.5)/level) - .5/level) - .5/3./level;\n                    }\n                    else{  \n                        c2 = length(p -  vec2(.5, 0)/level) - .5/3./level;\n                        c2 = min(c2, length(p -  vec2(0, -.5)/level) - .5/3./level);\n                    }\n                    \n                    // Line variant @Shane\n                    if(fract(rnd.x*113.467 + .51)<.15) c = abs(p.x) - .5/3./level;\n                    if(fract(rnd.x*123.853 + .49)<.15) c2 = abs(p.y) - .5/3./level;\n\n                    float truchet = min(c, c2);\n\n                    c = min(c3, max(square, truchet));\n                    // Tile color one.\n                    d[k] = min(d[k], c);\n\n                    // TILE COLOR TWO.\n                    p = abs(p) - .5/level;\n                    float l = length(p);\n                    \n                    // Four circles at the grid vertices and the square.\n                    c = min(l - 1./3./level, square);\n                    if(chk>.5) d3[k] = min(d3[k], l - 1./3./level); \n                    c = max(c, -truchet);\n                    c = max(c, -c3);\n                    \n                    // Tile color two.\n                    d2[k] = min(d2[k], c); \n\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    // layerd mixdown as each iteration is stored in xyzw\n    d.x = max(d2.x, -d.x);\n    d.x = min(max(d.x, -d2.y),  d.y);\n    d.x = max(min(d.x,  d2.z), -d.z);\n    d.x = min(max(d.x, -d2.w),  d.w);\n\n    //d3.x = max(d2.x, -d.x);\n    d3.x = min(d3.x, d3.y);\n    d3.x = max(d3.x, -d3.z);\n    d3.x = min(d3.x, d3.w);\n    \n    float dm = smoothstep(px, -px,d.x);\n    float dn = smoothstep(-px, px,d.x);\n    float ptrn = max(dm,bkptrn(vuv,128.));\n    vec3 C = mix(vec3(.075),vec3(.2),clamp((suv.y+.25)*.5,0.,1.))*ptrn;\n    \n    // color gradient \n    vec3 clrA = mix(vec3(0.918,0.769,0.565),vec3(0.886,0.408,0.012),clamp(abs(suv.y*2.),0.,1.));\n\n    vec3 clrB = vec3(0.106,0.102,0.075);\n\n    C = mix(C, C*clrB, smoothstep(.05+px, -px, d.x));    \n    C = mix(C, clamp(C+texture(iChannel1,vuv*2.).rrr*.05,vec3(0),vec3(1)),dn);\n    C = mix(C, C*clrB, smoothstep(px, -px, abs(abs(abs(d3.x)-.03)-.015)-.0015 ));\n    C = mix(C, texture(iChannel0,vuv).rgb*vec3(0.733,0.447,0.047),clamp(dm,0.,1.));\n  \n    C = mix(C, clrA, smoothstep(px, -px, abs(d.x)-.0015));\n    \n    if(iMouse.z>0.){\n        C = mix(C, clrB, 1. - smoothstep(-px, px, grid.x - .001));\n        C = mix(C, vec3(.9), 1. - smoothstep(-px, px, grid.x));\n    }\n    \n    if(uv.x<-.3&&uv.x>-.305) C = vec3(.05);\n \n    // Gamma and output\n    C = pow(C, vec3(.4545));        \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltGzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1008, 1008, 1028, 1028, 1073], [1074, 1074, 1095, 1095, 1150], [1172, 1192, 1213, 1213, 1387], [1389, 1389, 1422, 1422, 1612], [1614, 1621, 1640, 1640, 1702], [1704, 1704, 1745, 1745, 7200]], "test": "error"}
{"id": "slVGWR", "name": "chromatic aberration study 101", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 4, "viewed": 145, "published": "Public API", "date": "1637516675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-21 17:43:16\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .1;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .3;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, (sin(st.x * 3.) + 1.) * .5);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .8;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 493, 493, 579], [582, 582, 653, 653, 911], [913, 913, 968, 968, 1943]], "test": "valid"}
{"id": "slVGzm", "name": "p-norm voronoi", "author": "triclops200", "description": "A voronoi shader that uses p-norm distance for smooth transition between manhattan and euclidean", "tags": ["voronoi", "pnorm"], "likes": 5, "viewed": 37, "published": "Public", "date": "1637418799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 points[6];\nfloat abs_sum(vec2 xs){\n\treturn abs(xs[0]) + abs(xs[1]);\n}\nfloat p_norm(vec2 delta, float p) {\n    return pow(pow(abs(delta[0]), p) +\n               pow(abs(delta[1]), p),\n               1.0/p);\n}\n\nvec3 color_from_point(vec2 point){\n\treturn vec3(point[0]+cos(iTime*0.02)*0.1+0.1,sin(iTime*0.01)*0.1+0.1,point[1]+0.3);\n}\n\nvec3 minimumDistColor(vec2 point){\n\tvec2 del = points[0] - point;\n    float p = (sin(iTime/1.0)*0.5 + 0.5)+1.0;\n\tfloat min_dist_sq = p_norm(del, p);\n\tvec3 min_color = color_from_point(points[0]);\n\tif(min_dist_sq<0.005) return color_from_point(vec2(0.5,0.2))-vec3(0.2,0.2,0.2);\n\tfor(int i=0;i<6;i++){\n\t\tdel = points[i]-point;\n\t\tfloat d = p_norm(del, p);\n\t\tif(d < 0.005) return color_from_point(vec2(0.5,0.2))-vec3(0.2,0.2,0.2);\n\t\tif(d < min_dist_sq){\n\t\t\tmin_color = color_from_point(points[i]);\n\t\t\tmin_dist_sq = d;\n\t\t}\n\t}\n\treturn min_color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpoints[0] = vec2(0.4+sin(iTime)*0.1,0.3+cos(iTime*3.1)*0.05);\n\tpoints[1] = vec2(0.9+sin(iTime*1.1)*0.1,0.1+cos(iTime*3.3+.2)*0.05);\n\tpoints[2] = vec2(0.2+sin(iTime*0.2)*0.1,0.5+cos(iTime*2.1+.2)*0.05);\n\tpoints[3] = vec2(0.8+sin(iTime*0.4)*0.1,0.4+cos(iTime*2.7+.7)*0.05);\n\tpoints[4] = vec2(0.2+sin(iTime*2.4)*0.13,0.15+cos(iTime*1.5+.7)*0.09);\n\tpoints[5] = vec2(0.5+sin(iTime*0.6)*0.13,0.15+cos(iTime*0.7+.7)*0.09);\n\tfloat u = fragCoord.x / iResolution.x;\n\tfloat v = fragCoord.y / iResolution.x;\n\tvec2 uv = vec2(u,v);\n\n\tfragColor = vec4(minimumDistColor(uv),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 39, 39, 74], [75, 75, 110, 110, 212], [214, 214, 248, 248, 335], [337, 337, 371, 371, 878], [881, 881, 938, 938, 1506]], "test": "valid"}
{"id": "sly3Dz", "name": "the book of shader 练习", "author": "suolong", "description": "the book of shader 练习", "tags": ["thebookofshader"], "likes": 4, "viewed": 98, "published": "Public API", "date": "1637677522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* the book of shader 的提问练习\n* 图形不是本人设计\n*/\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nfloat ng(vec2 st,float N,float size,float radian){\n   float a =  atan(st.x,st.y)+radian;\n   float r = TWO_PI/float(N);\n   float d = cos(floor(.5+a/r)*r-a)*length(st);\n   return 1.0-step(size,d);\n}\nfloat circle(vec2 st,vec2 c,float r,float d,float start,float end){\n  vec2 dir = st-c;\n  float a = atan(dir.y,dir.x);\n  a = step(start,a)*step(a,end);\n  return (step(r-d,distance(st,c))-step(r,distance(st,c)))*a;\n}\nfloat segment(vec2 st,float pct,float w,float s,float e){\n  return (step(-w*0.5,st.y-pct)-step(w*0.5,st.y-pct))*step(s,st.x)*step(st.x,e);\n}\nvec3 circle2(vec2 st,vec2 c,float r){\n  vec3 col = vec3(0.995,0.325,0.085);\n  float c1 = circle(st,c,r*0.1,r*0.1*0.1,-PI,PI);\n  float c2 = circle(st,c,r*0.1,r*0.1,-PI,PI)*step(0.0,sin(iTime*50.0));\n  float rs= abs(sin(iTime));\n  r =r*rs;\n  float c3 = circle(st,c,r,r,-PI,PI);\n  vec3 lc= col*(smoothstep(r*0.6,r,distance(st,c))-smoothstep(r,r,distance(st,c)));\n  return lc+col*(c1+c2); \n}\nvec3 circle3(vec2 st,vec2 c,float r){\n  vec3 col = vec3(0.240,0.63,0.87);\n  mat2 rotate =mat2(cos(iTime),-sin(iTime),\n                    sin(iTime),cos(iTime));\n  st=rotate*st;\n  float a = PI*0.5;\n  float b = atan(st.y,st.x);\n  float d = (1.0-step(r,distance(st,c)))*step(0.,b)*step(b,a);\n  return col*d*smoothstep(0.0,1.0,b*0.5)+col*step(0.,st.x)*step(st.x,0.2)*step(0.,st.y)*step(st.y,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 100.0;   \n    vec2 st = fragCoord/iResolution.y*size-vec2(iResolution.x/iResolution.y,1.0)*size*0.5;\n    vec3 col = vec3(0.0);\n    vec3 col1 = vec3(.6,0.6,0.6);\n    vec3 col2 = vec3(0.583,0.938,0.995);\n    vec3 col3 = vec3(1.,1.,1.);\n    vec3 col4 = vec3(0.773,0.957,0.995);\n    vec3 col5 = vec3(0.583,0.938,0.995);\n\n    float r = 30.0;\n    float w = 0.3;\n    float w1 = w*0.8;\n    float w2 = w*1.2;\n    float x = r*cos(PI/4.0);\n    float l1 = segment(st,st.x,w1,-x,x);\n    col += col1*l1;\n    float l2 = segment(st,-st.x,w1,-x,x);\n    col += col1*l2;\n\n    vec2 c = vec2(0.0);\n    float c1 = circle(st,c,r*0.1,w1,-PI,PI);\n    float c2 = circle(st,c,r*0.5,w1,-PI,PI);\n    float c3 = circle(st,c,r*0.7,w1,-PI,PI);\n    float c4 = circle(st,c,r,w1,-PI,PI);\n    col+= col2*(c1+c2+c3);\n    col+= col3*c4;\n\n    float a = PI*0.1*2.0*(0.5+abs(sin(iTime))*0.5);\n    float c5 = circle(st,c,r*1.2,w,a,PI-a);\n    float c6 = circle(st,c,r*1.2,w,-PI+a,-a);\n    col+= col4*c5+c6;\n     \n    float d = 0.05;\n    float c7 = circle(st,c,r*1.5,w2,d,PI-d);\n    float c8 = circle(st,c,r*1.5,w2,-PI+d,-d);\n    \n    \n    float tx = r*1.5 + sin(iTime)*2.0;\n    float t1 = ng(st+vec2(tx,0.0),3.0,r*1.4*tan(d*0.5),PI*0.5);\n    float t2 = ng(st-vec2(tx,0.0),3.0,r*1.4*tan(d*0.5),-PI*0.5);\n    col+= col5*(c7+c8+t1+t2);\n    float off=iTime*0.1;\n    vec2 cenoff=c+vec2(sin(off)*sin(-off)*cos(off),cos(off)*sin(off*2.0))*r; \n    vec3 cir = circle2(st,cenoff,r*0.4);\n    vec3 cir3 = circle3(st,c,r);\n\n \n    \n\n    \n    fragColor= vec4(col+cir+cir3,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sly3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 175, 175, 321], [322, 322, 389, 389, 536], [537, 537, 594, 594, 677], [678, 678, 715, 715, 1065], [1066, 1066, 1103, 1103, 1459], [1460, 1460, 1517, 1517, 3056]], "test": "valid"}
{"id": "sly3Rt", "name": "[zznewclear13] Gradient Z", "author": "zznewclear13", "description": "A gradient Z.\n\nColor palette is stolen from iq's [url=https://www.shadertoy.com/view/ll2GD3]Palettes[/url].", "tags": ["gradient"], "likes": 11, "viewed": 107, "published": "Public", "date": "1638172300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I stole the color palette from iq's Palettes (https://www.shadertoy.com/view/ll2GD3).\n\n#define INV_PI 0.31830988618\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat GetAngle(vec2 center, vec2 start, vec2 end)\n{\n    vec2 v0 = start - center;\n    vec2 v1 = end - center;\n    \n    float cosVal = dot(v0, v1);\n    float sinVal = v0.x * v1.y - v0.y * v1.x;\n    \n    return INV_PI * atan(sinVal, cosVal) * 0.5 + 0.5;\n}\n\nfloat GetAngleFlip(vec2 center, vec2 start, vec2 end)\n{\n    vec2 v0 = -(start - center);\n    vec2 v1 = end - center;\n    \n    float cosVal = dot(v0, v1);\n    float sinVal = v0.x * v1.y - v0.y * v1.x;\n    \n    return 0.5 - INV_PI * atan(sinVal, cosVal) * 0.5;\n}\n\n// b > a\nfloat EasyStep(float a, float b, float x)\n{\n    float value = clamp(x - a, 0.0, b - a);\n    return value / (b - a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = iResolution.y * 0.5;\n    vec2 p2 = vec2(iResolution.x * 0.5 - size * 0.5, size * 0.5);\n    vec2 p1 = p2 + size;\n    vec2 p0 = vec2(p2.x, p1.y);\n    vec2 p3 = vec2(p1.x, p2.y);\n    \n    float gradientOne = GetAngleFlip(p0, p1, fragCoord);\n    float gradientTwo = 1.0 - GetAngleFlip(p3, p2, fragCoord);\n    \n    //Not as good as two gradients above.\n    //float gradientOne = GetAngle(fragCoord, p0, p1);\n    //float gradientTwo = GetAngle(fragCoord, p2, p3);\n    \n    float lerpOne = GetAngleFlip(p2, p1, fragCoord);\n    float angleOne = GetAngleFlip(p2, p1, p3);\n    lerpOne = EasyStep(angleOne, 0.5, lerpOne);\n    \n    float lerpTwo = GetAngleFlip(p1, p2, fragCoord);\n    float angleTwo = GetAngleFlip(p1, p2, p0);\n    lerpTwo = 1.0 - EasyStep(angleTwo, 0.5, lerpTwo);\n    \n    float lerpValue = mix(lerpOne, lerpTwo, step(0.5, fragCoord.y / iResolution.y));  \n    float gradientValue = 1.0 - mix(gradientTwo, gradientOne, lerpValue);\n    gradientValue = gradientValue * 0.5 - 0.05 * iTime;\n    \n    vec3 col = pal(gradientValue, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sly3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 187, 187, 230], [232, 232, 283, 283, 485], [487, 487, 542, 542, 747], [749, 758, 801, 801, 875], [877, 877, 934, 934, 2132]], "test": "valid"}
{"id": "slyGR3", "name": "Center Spiral.SV", "author": "turtlelover891", "description": "a fun little challenge that I decided to take on", "tags": ["spiral"], "likes": 4, "viewed": 62, "published": "Public", "date": "1638137790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\n\nfloat atan2(float y, float x){\n    if(x >= 0.){\n        return atan(y/x)/pi/2.+.75;\n    }\n    return (pi+2.*atan(y/x))/4./pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //======================\n    //parameters\n    int amount = 1;\n    float width = 5.;\n    float speed = 1.;\n    vec3 color1 = vec3(1.0, 1.5, 1.0);\n    vec3 color2 = vec3(-0.1, 0.0, 0.1);\n    //======================\n\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col;\n    float circle = sqrt(uv.x*uv.x+uv.y*uv.y);\n    float d = (circle/100.);\n    d -= iTime*speed;\n\n    float mask = smoothstep(R.y/2.+width*4., R.y/2.-width*4., circle);\n    \n    col = vec3(sin((2.*pi*atan2(uv.y, uv.x)+d*width)*float(amount))+1.)/2.;\n    col = color1+col*(color2-color1);\n    col *= mask;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 59, 59, 156], [158, 158, 215, 261, 845]], "test": "error"}
{"id": "slyGRh", "name": "Fork Gradient F ronik 927", "author": "ronik", "description": "toying around", "tags": ["distortion", "flow"], "likes": 6, "viewed": 165, "published": "Public API", "date": "1637129146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix( mix( dot( -1.0+2.0*hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn 0.5 + 0.5*n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    vec2 tuv = uv;\n    tuv -= .5;\n\n    // rotate with Noise\n    float degree = noise(vec2(iTime*.1, tuv.x*tuv.y));\n\n    tuv.y *= 1./ratio;\n    tuv *= Rot(radians((degree-.5)*720.+75.));\n\ttuv.y *= ratio;\n\n    \n    // Wave warp with sin\n    float frequency = 2.;\n    float amplitude = 30.;\n    float speed = iTime * 4.;\n    tuv.x += sin(tuv.y*frequency+speed)/amplitude;\n   \ttuv.y += sin(tuv.x*frequency*1.5+speed)/(amplitude*.5);\n    \n    \n    // draw the image\n    vec3 colorWhite = vec3(1.0, 1.0, 1.0);\n    vec3 colorRed = vec3(.914, .345, .62);\n    vec3 colorPurple = vec3(.792, .573, .871);\n    vec3 colorGreen = vec3(.612, .91, .364);\n    vec3 colorBlue = vec3(.42, .773, .937);\n    vec3 colorYellow = vec3(1.0, .973, .325);\n    \n    vec3 layer1 = mix(colorRed, colorYellow, S(-.6, .2, (tuv*Rot(radians(-5.))).x));\n    layer1 = mix(layer1, colorWhite, S(-.6, .2, (tuv*Rot(radians(-5.))).x));\n    layer1 = mix(layer1, colorPurple, S(-.2, .6, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 layer2 = mix(colorRed, colorYellow, S(-.8, .2, (tuv*Rot(radians(-5.))).x));\n    layer2 = mix(layer2, colorGreen, S(-.1, .9, (tuv*Rot(radians(-5.))).x));\n    layer2 = mix(layer2, colorBlue, S(-.5, .5, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 finalComp = mix(layer1, layer2, S(.7, -.5, tuv.y));\n    \n    vec3 col = finalComp;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 55, 55, 131], [134, 258, 279, 279, 386], [388, 388, 414, 414, 881], [884, 884, 941, 941, 2383]], "test": "valid"}
{"id": "slyGRW", "name": "Quicky \"Glass\" ", "author": "Plento", "description": "Literally just nudging the ray a bit then marching through the stuff, which is probably the quickest way to do this but its slow since your raymarch loop isn't over the first few hits.", "tags": ["3d", "raymarch", "glass"], "likes": 15, "viewed": 259, "published": "Public API", "date": "1637228443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat rbox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Dave Hoshkin \nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n#define b vec3(2., 2., 2.)\n\nvec3 getCell(vec3 p){\n    return floor(p / b);\n}\n\nvec3 getCellCoord(vec3 p){\n    return mod(p, b) - b*.5;\n}\n\nfloat map(vec3 p){\n    vec3 id = getCell(p);\n    p = getCellCoord(p);\n    \n    float rnd = 2.*hash13(id*663.) - 1.;\n    \n    p.xz *= rot(rnd*iTime*.3 + rnd);\n    p.xy *= rot(rnd*iTime*.3 + rnd);\n    p.yz *= rot(p.x*(5.+rnd*10.));\n\n    return rbox(p, vec3(0.7, .16, .16), .1);\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 n, float t){\n    vec3 p = ro + rd*t;\n    vec3 lp = ro + vec3(.0, .0, 2.7);\n    \n    if(iMouse.z>0.) lp.z += m.y*14.;\n    \n    vec3 ld = normalize(lp-p);\n    float dd = length(p - lp);\n    float dif = max(dot(n, ld), .1);\n    float fal = 1. / dd;\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 23.);\n\n    vec3 id = getCell(p);\n    vec3 objCol = hash33(id*555.);\n    \n    \n    objCol *= (dif + .2);\n    objCol += spec * 0.6;\n    objCol *= fal;\n    \n    return objCol;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 0.8));\n    vec3 ro = vec3(0., 7.0, 4.);\n    rd.xy*=rot(-iTime*.1 + .5);\n    ro.zy += iTime;\n    ro.x += cos(iTime)*.25;\n    \n    int nHits = 0;\n    float d = 0.0, t = 0.0, ns = 0.;\n    vec3 p, n, col = vec3(0);\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(nHits >= 4 || t >= 12.) break;\n        \n        if(abs(d) < .001){\n            p = ro + rd*t;\n            n = normal(p);\n            \n            if(d > 0. && nHits == 0) rd = refract(rd, n, 1.03);\n            \n            col += color(ro, rd, n, t);\n            \n            nHits++;\n            t += .1;\n        }\n        t += abs(d) * .6;\n        \n        if(nHits == 0) ns++;\n    }\n    \n    col /= float(nHits)*.6;\n    col *= smoothstep(.5, .3, ns * .01);\n    \n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 184, 184, 275], [277, 294, 316, 316, 419], [421, 421, 442, 442, 567], [598, 598, 619, 619, 646], [648, 648, 674, 674, 705], [707, 707, 725, 725, 984], [986, 986, 1013, 1013, 1214], [1216, 1216, 1262, 1262, 1728], [1731, 1731, 1771, 1771, 2655]], "test": "valid"}
{"id": "slyGWy", "name": "Circle Study_Trospy", "author": "Trospy", "description": "Circel Study", "tags": ["circle"], "likes": 0, "viewed": 26, "published": "Public", "date": "1638255577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 makeSphere(vec2 uv,vec2 c,float r)\n{\n    float distance = sqrt(pow((uv.x-c.x),2.0)+pow((uv.y-c.y),2.0));\n    vec4 color;\n    if( distance <= r)\n    {\n       return color = vec4(1,1,1,1);\n    }\n    \n    return color = vec4(0,0,0,0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y; \n   \n    \n\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 center = vec2(0.0, 0.0);\n    // Output to screen\n    fragColor = makeSphere(uv, center, 0.1*sin(iTime)+0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 243], [245, 245, 302, 352, 679]], "test": "valid"}
{"id": "slyGzV", "name": "blending no overlap", "author": "wnu", "description": "If you have notes on how to make this better please comment, the blending is good when centers of circles are closer than 0.5, but not otherwise", "tags": ["blending"], "likes": 1, "viewed": 30, "published": "Public", "date": "1638000269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat smax(float a, float b, float r){\n    return ((a+b) + sqrt((a-b)*(a-b) + r))/2.;\n}\n\nfloat blend(float s1, float s2){\n    return smoothstep(0.,1.,1.-(s1 - s2 + 1.)/2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R;\n    uv -= 0.5;\n    uv.x *= R.x/R.y;\n\n    vec2 p1 = vec2(0.,0.);\n    vec2 p2 = vec2(sin(iTime/2.)/2.,0.);\n    vec2 p3 = vec2(0.,sin(iTime/2.)/2.);\n    \n    vec2 uv1 = uv-p1;\n    vec2 uv2 = uv-p2;\n    vec2 uv3 = uv-p3;\n    \n    float l1 = length(uv1);\n    float l2 = length(uv2);\n    float l3 = length(uv3);\n    \n    float s1 = smoothstep(0.5,0.,l1);\n    float s2 = smoothstep(0.5,0.,l2);\n    float s3 = smoothstep(0.5,0.,l3);\n   \n    \n    float sm1 = SmoothMax(s1,s2,0.5);\n    float sm2 = SmoothMax(sm1,s3,0.5);\n    \n    //float sa = 1.-(s1 - s2 + 1.)/2.;\n    //float sa2 = 1.-(sm1 - s3 + 1.)/2.;\n    \n    float sa = blend(s1,s2);\n    float sa2 = blend(sm1,s3);\n    \n\n    vec3 c1 = vec3(1.,0.,0.);\n    vec3 c2 = vec3(0.,1.,0.);\n    vec3 c3 = vec3(0.,0.,1.);\n   \n    \n    vec3 c = mix(c1,c2,sa);\n    c = mix(c,c3,sa2);\n    \n    \n    vec3 col = vec3(c*sm2);\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    //Can certainly be improved but its not so bad\n    //Want to make slope when touching result from how far into each other they touch\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 148], [150, 150, 195, 195, 233], [235, 235, 273, 273, 322], [324, 324, 356, 356, 409], [411, 411, 468, 518, 1673]], "test": "valid"}
{"id": "ssGXzK", "name": "Page Flip", "author": "xx3000", "description": "Always wanted to try that page flip effect.\nClick + Move mouse for manual controls. \nI might save the picked corner to a readback buffer in the future so you could flip from multiple places.", "tags": ["book", "pageflip"], "likes": 24, "viewed": 151, "published": "Public", "date": "1636127748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n#define BOOK_BOUNDS vec4(0.15, 0.05, 0.85, 0.95)\n\n#define LIGHT_DIR vec3(5,3,1)\n#define SPECULAR_SHININESS 16.0\n#define SPECULAR_COLOR vec3(1.0,1.0,1.0)\n#define SPECULAR_POWER 10.0\n\nvec3 fakeSpine(vec3 col, float t, float darken)\n{\n    return mix(col * darken,col , min(1.0,pow(abs(t - 0.5) * 30.0, 0.5)));\n}\n\nvec3 fakeNormal(float t, float center)\n{\n    t -= center;\n    float interp =(1.0 - abs((t - 0.5) * 2.0)) * PI + PI * (3.0/4.0) ;\n        \n    vec3 normal = vec3(abs(sin(interp)) ,0,abs(cos(interp)));\n\n    return mix(normal, vec3(0,0,1), min(1.0,pow(abs(t - 0.5) * 5.0, 0.5)));\n}\n\nvec3 specular(vec3 viewDir, vec3 normal )\n{\n    vec3 lightDir = normalize(LIGHT_DIR);\n    float dist = length(lightDir);\n    vec3 halfV = normalize(lightDir + normalize(viewDir));\n\n    float NdotH = dot(normal, halfV);\n    float intensity = pow(max(NdotH, 0.0), SPECULAR_SHININESS);\n\n    return intensity * SPECULAR_COLOR * SPECULAR_POWER / dist; \n}\n\nbool pageFlip(vec2 uv, vec2 mouse, vec2 topRight, inout vec2 sampleUV, inout vec3 normal, out float toHalfEdge)\n{\n    vec2 toEdge = topRight - mouse;\n    vec2 toEdgeN = normalize(toEdge);\n    \n    vec2 toPixel = uv - mouse;\n    \n    vec2 diagonal = normalize(vec2(1.0));\n    float cosT = dot(toEdgeN, diagonal);\n    float cosT2 = 2.0 * cosT * cosT - 1.0;\n    vec2 toEdgePerp = vec2(toEdgeN.y, -toEdgeN.x);\n    \n    float dir = sign(dot(toEdgePerp,diagonal));\n    float sinT2 = dir * sqrt(1.0 - cosT2 * cosT2);\n    \n    vec2 nextPageUp = vec2(-sinT2, cosT2);\n    vec2 nextPageRight = vec2(nextPageUp.y, -nextPageUp.x);\n    \n    if(dot(toPixel, nextPageUp) >= 0.0 && dot(toPixel, nextPageRight) >= 0.0)\n    {\n        vec2 halfPoint = mouse + toEdge * 0.5;\n        vec2 toPixHP = uv - halfPoint;\n        \n        float proj = dot(toEdgePerp, (uv - halfPoint));\n        vec2 projPoint = halfPoint + toEdgePerp * proj;\n            \n        float distDiff = distance(projPoint, uv) / distance(mouse, halfPoint);\n        toHalfEdge = distDiff;\n        \n        if(dot(toPixHP, toEdge) < 0.0)\n        {\n            sampleUV = (sampleUV - mouse);\n            sampleUV = vec2(sampleUV.y, -sampleUV.x);\n            mat2 rot = mat2(cosT2, -sinT2, sinT2, cosT2); \n            sampleUV = rot * sampleUV;\n            sampleUV.y *= -1.0;\n            sampleUV.y = 1.0 - sampleUV.y;\n            \n\n            distDiff *= 0.5;\n            normal = fakeNormal(distDiff, -0.43);\n        }\n        else\n        {\n            \n            normal = fakeNormal(uv.x / topRight.x, 0.07);\n        }\n\n        return false;\n    }\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 bgCol = texture(iChannel0, uv).xyz;\n\n    vec3 outCol = bgCol;\n    \n    vec2 bookUV = uv - BOOK_BOUNDS.xy;\n    vec2 bookSize = vec2(BOOK_BOUNDS.zw - BOOK_BOUNDS.xy);\n    bookUV /= bookSize;\n\n    vec2 topRight = vec2(bookSize.y / bookSize.x, 1); \n    vec2 sUV = bookUV;\n    sUV.x *= topRight.x;\n\n    vec2 nMouse = iMouse.xy / iResolution.xy;\n    nMouse -= BOOK_BOUNDS.xy;\n    nMouse /= bookSize.xy;\n    nMouse = clamp(nMouse, vec2(0.0),vec2(1.0));\n\n    \n    if(iMouse.z <= 0.0 && iTime > 0.0)\n    {\n        nMouse = vec2((sin(iTime + 0.3) + 1.0) * 0.5,(cos(iTime * 0.5) + 1.0) * 0.5);\n\n    }\n        nMouse.x *= topRight.x;\n\n\n    float radius = topRight.x * 0.5;\n    vec2 spineTop = vec2(radius, 1.0);\n    vec2 spineMouse = nMouse - spineTop;\n    float len = length(spineMouse);\n    nMouse = spineTop + normalize(spineMouse) * min(len, radius);\n\n    vec2 sampleUV = sUV;\n\n    vec3 normal = vec3(0,0,1);\n    float halfEdgeDist = 1.0;\n    bool firstPage = pageFlip(sUV, nMouse, topRight, sampleUV, normal, halfEdgeDist);\n\n    sampleUV.x /= topRight.x;\n\n    vec3 page1 = texture(iChannel2, sampleUV).xyz;\n    vec3 page2 = texture(iChannel1, sampleUV).xyz;\n    page1 = fakeSpine(page1,bookUV.x, 0.2);\n    page2 = fakeSpine(page2,sampleUV.x, 0.2);\n    page2 = fakeSpine(page2,  (1.0 -halfEdgeDist) * 0.5, 0.4);\n\n    vec3 pageCol = firstPage ? page1 : page2;\n\n    vec3 normal2 =  fakeNormal(bookUV.x > 0.5 ? bookUV.x : 1.0 - bookUV.x, 0.07);\n\n    normal = firstPage ? normal2 : normal;\n\n    normalize(normal);\n    pageCol += min(vec3(1,1,1), specular(vec3(0,0,1), normal)) * 0.3;\n\n    if(sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0)\n    {\n        outCol = pageCol;\n    }\n\n    fragColor = vec4(outCol,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 254, 254, 331], [333, 333, 373, 373, 611], [613, 613, 656, 656, 962], [964, 964, 1077, 1077, 2588], [2590, 2590, 2647, 2647, 4435]], "test": "error"}
{"id": "st33Rf", "name": "Persian carpet 13", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 135, "published": "Public API", "date": "1636436467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.16;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float bend = 1.;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n            //float bend = 1.+1./3.;\n            //float bend = scale2;\n            \n            //uv *= bend+col.x;\n            uv = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n            \n            for(int k = 0; k < 3; k++){\n                uv.y /= scale2;\n                //uv.y /= scale2-uv.x/2.;\n                //uv *= bend+col.x;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]).yx;\n                uv.x /= -scale2;\n                //uv *= bend+col.x;\n                //uv.x /= -scale2+uv.y/2.;\n                scale /= 1.+(scale2+uv.x+uv.y)*col.x/5.;\n                \n\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1.+uv.x/2.;\n\n            }\n            scale2 += col.x/8.;\n            \n            col[c] = fract((uv.x)-(uv.y));\n            //col[c] = abs(-col[c]-uv.x+uv.y);\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2499]], "test": "valid"}
{"id": "st33W7", "name": "meta-circles", "author": "Artemis152", "description": "meta circles. one of the balls can be controlled by dragging", "tags": ["metaballs", "circle"], "likes": 2, "viewed": 54, "published": "Public", "date": "1636190785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define THICCNEss 0.03\n\nvec2 scr2uv(vec2 scr)\n{\n    return ((scr - iResolution.xy/2.)/iResolution.y) * 5.;\n}\n\nfloat circle(vec2 uv, float r, vec2 pos)\n{\n    return (length(uv - pos) - r) * 1. / length(uv - pos);\n}\n\nfloat sceneDist(vec2 uv)\n{\n    return circle(uv, 1., scr2uv(iMouse.xy)) +\n        circle(uv, 0.8, vec2(1)) +\n        circle(uv, 2.5, vec2(-1.5)) +\n        circle(uv, 0.7, vec2(sin(iTime/1.5) * 2., 1.)) +\n        circle(uv, 1., vec2(1., sin(iTime/2.) * 2.));\n}\n\n\nvec3 color(vec2 uv)\n{\n    float d = sceneDist(uv);\n    return vec3( 1. - (abs(d) - THICCNEss ) /min(1.,fwidth(d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scr2uv(fragCoord);\n    \n\n    vec3 col = color(uv);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 47, 47, 108], [110, 110, 152, 152, 213], [215, 215, 241, 241, 474], [477, 477, 498, 498, 594], [596, 596, 653, 653, 753]], "test": "valid"}
{"id": "st33Wj", "name": "Quintic Solving Study II - DK", "author": "oneshade", "description": "Solving for the roots of a quintic equation using Durand-Kerner method to find all roots simultaneously.", "tags": ["study", "quintic", "solving", "weierstrass", "durandkerner"], "likes": 17, "viewed": 82, "published": "Public", "date": "1636757648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CONSTRUCT_FROM_ROOTS\n\nvoid quinticFromRoots(in float x1, in float x2, in float x3, in float x4, in float x5,\n    out float a, out float b, out float c, out float d, out float e, out float f) {\n    a = 1.0;\n    b = -x1 - x2 - x3 - x4 - x5;\n    c = x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4) + (x1 + x2 + x3 + x4) * x5;\n    d = -(x1 + x2) * x3 * x4 - x1 * x2 * (x3 + x4) - (x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4)) * x5;\n    e = x1 * x2 * x3 * x4 + ((x1 + x2) * x3 * x4 + x1 * x2 * (x3 + x4)) * x5;\n    f = -x1 * x2 * x3 * x4 * x5;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nint solveQuintic(in float a, in float b, in float c,\n    in float d, in float e, in float f, out float[5] realRoots) {\n    // TODO: refactor\n    // Reduction to x^5 + px^3 + qx^2 + rx + s\n    float p = (5.0 * a * c - 2.0 * b * b) / (5.0 * a * a);\n    float q = (25.0 * a * a * d - 15.0 * a * b * c + 4.0 * b * b * b) / (25.0 * a * a * a);\n    float r = (125.0 * a * a * a * e - 50.0 * a * a * b * d + 15.0 * a * b * b * c - 3.0 * b * b * b * b) / (125.0 * a * a * a * a);\n    float s = (3125.0 * a * a * a * a * f - 625.0 * a * a * a * b * e + 125.0 * a * a * b * b * d - 25.0 * a * b * b * b * c + 4.0 * b * b * b * b * b) / (3125.0 * a * a * a * a * a);\n\n    float bound = 1.0 + max(1.0, max(abs(p), max(abs(q), max(abs(r), abs(s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5; // Keep safely within bounds\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0); // QuinticRootOfUnity^0\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound; // QuinticRootOfUnity^1\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound; // QuinticRootOfUnity^2\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound; // QuinticRootOfUnity^3\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound; // QuinticRootOfUnity^4\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(p, 0.0), z) + vec2(q, 0.0), z) + vec2(r, 0.0), z) + vec2(s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    // Undo substitution y = x + b/5a\n    // and weed out complex roots\n    int numRealRoots = 0;\n    float offs = b / (5.0 * a);\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            realRoots[numRealRoots] = z.x - offs;\n            numRealRoots++;\n        }\n    }\n\n    return numRealRoots;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n    float time = iTime;\n\n    // Coefficients\n    float a, b, c, d, e, f;\n\n    #ifdef CONSTRUCT_FROM_ROOTS\n    time *= 0.25;\n    float sec = floor(time);\n    float lerp = smoothstep(0.0, 1.0, fract(time));\n\n    // Generate random animated roots\n    float x1 = mix(Hash11(sec), Hash11(sec + 1.0), lerp) * 6.0 - 3.0;\n    float x2 = mix(Hash11(sec + 17.13), Hash11(sec + 18.13), lerp) * 6.0 - 3.0;\n    float x3 = mix(Hash11(sec + 34.26), Hash11(sec + 35.26), lerp) * 6.0 - 3.0;\n    float x4 = mix(Hash11(sec + 51.39), Hash11(sec + 52.39), lerp) * 6.0 - 3.0;\n    float x5 = mix(Hash11(sec + 68.52), Hash11(sec + 69.52), lerp) * 6.0 - 3.0;\n\n    quinticFromRoots(x1, x2, x3, x4, x5,\n                     a, b, c, d, e, f);\n\n    #else\n    a = sin(time * 0.25) * 1.25;\n    b = sin(time) * 2.0;\n    c = sin(time) * 2.0;\n    d = cos(time * 0.75);\n    e = sin(time * 0.5);\n    f = cos(time);\n    #endif\n\n    // Draw the x axis and quintic equation\n    float fx = ((((a * uv.x + b) * uv.x + c) * uv.x + d) * uv.x + e) * uv.x + f;\n    float dx = (((5.0 * a * uv.x + 4.0 * b) * uv.x + 3.0 * c) * uv.x + 2.0 * d) * uv.x + e; // Derivative for distance estimation\n    color.b += smoothstep(unit, 0.0, abs(uv.y));\n    color.rg += smoothstep(unit, 0.0, abs(uv.y - fx) / sqrt(1.0 + dx * dx));\n\n    // Solve and draw expected versus found roots\n    float[5] roots;\n    int numRoots = solveQuintic(a, b, c, d, e, f, roots);\n    for (int n=0; n < numRoots; n++) {\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - vec2(roots[n], 0.0)) - 0.05));\n\n        #ifdef CONSTRUCT_FROM_ROOTS\n        color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(length(uv - vec2(roots[n], 0.0)) - 0.1)));\n        #endif\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 200, 200, 540], [542, 631, 657, 657, 743], [745, 745, 778, 778, 811], [812, 812, 845, 845, 892]], "test": "valid"}
{"id": "st33WX", "name": "eye raap 1.0", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 1, "viewed": 18, "published": "Public", "date": "1636813396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(50000000.0*iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(50000000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(50000000.0*iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(50000000.0*iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(50000000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(50000000.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 919]], "test": "valid"}
{"id": "st3GDM", "name": "TestWFC", "author": "qubailiang00", "description": "TestWFC hang in the air!!   (Actually, I didn't finish it)", "tags": ["wfc"], "likes": 13, "viewed": 343, "published": "Public", "date": "1636612370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _sizeX 20.0\n#define _sizeY 3.0\n#define _sizeZ 20.0\n\nstruct MData\n{\n\tfloat d;\n    vec3 albedo;\n    float metalness;\n    float roughness;\n};\n\nfloat opUn(float d1, float d2) {  return min(d1, d2); }\n\nfloat opSub(float d1, float d2) { return max(d1, -d2); }\n\nfloat opInter(float d1, float d2) { return max(d1, d2); }\n\nmat2 rot(float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sBx(vec3 p0, vec3 b) {\n\n    vec3 d = abs(p0) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sCCyl(vec3 p, float r, float h) {\n\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad) {\n\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\t\n    if(tN > tF || tF < 0.0) return vec2(-1.0); \n    \n    //oN = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2(tN, tF);\n}\n\nMData setMatPr(float d, vec3 albedo, float metalness, float roughness) {\n\n    MData mData;\n    mData.d = d;\n    mData.albedo = albedo;\n    mData.metalness = metalness;\n    mData.roughness = roughness;\n    return mData;\n}\n\nfloat obtainIConfiguration(vec3 p){\n\n    p.y += 0.5;\n    float f = sBx(p, vec3(0.3, 0.05, 0.5));\n    f = opUn(f, sBx(p - vec3(0.25, 0.18, 0.0), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(-0.25, 0.18, 0.0), vec3(0.025, 0.15, 0.025)));\n\n    for(float i = 1.0; i < 2.5; i += 1.0){\n\n        f = opUn(f, sBx(p - vec3(0.25, 0.18, -0.2 * i), vec3(0.025, 0.15, 0.025)));\n        f = opUn(f, sBx(p - vec3(-0.25, 0.18, -0.2 * i), vec3(0.025, 0.15, 0.025)));\n        f = opUn(f, sBx(p - vec3(-0.25, 0.18, 0.2 * i), vec3(0.025, 0.15, 0.025)));\n        f = opUn(f, sBx(p - vec3(0.25, 0.18, 0.2 * i), vec3(0.025, 0.15, 0.025)));\n    }\n    return f;\n}\n\nfloat gate(vec3 p){\n\n    vec3 p0 = p;\n    float f = sBx(p - vec3(0.0, 0.25, 0.0), vec3(0.3, 0.25, 0.3));\n    p0.yz = rot(3.1416 / 2.0) * p.yz;\n    f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    p0.xy = rot(3.1416 / 2.0) * p.xz;\n    f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    return f;\n}\n\nfloat obtainIGateConfiguration(vec3 p){\n\n    p.y += 0.5;\n    vec3 p0 = p;\n    float f = sBx(p, vec3(0.3, 0.05, 0.5));\n    f = opUn(f, gate(p));\n\n    // f = opUn(f, sBx(p - vec3(0.0, 0.25, 0.0), vec3(0.3, 0.25, 0.3)));\n    // p0.yz = rot(3.1416 / 2.0) * p.yz;\n    // f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    // p0.xy = rot(3.1416 / 2.0) * p.xz;\n    // f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    return f;\n}\n\nfloat obtainLConfiguration(vec3 p){\n\n    p.xz = rot(3.1416 * 1.5) * p.xz;\n    p.y += 0.5;\n    vec3 p0 = p;\n    p0.z += 0.1;\n    float f = sBx(p0, vec3(0.3, 0.05, 0.4));\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    f = opUn(f, sBx(p0 - vec3(0.0, 0.0, -0.1), vec3(0.3, 0.05, 0.4)));\n    f = opUn(f, sBx(p - vec3(0.25, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(0.05, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(-0.15, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(-0.35, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(0.25, 0.18, 0.05), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(0.25, 0.18, -0.15), vec3(0.025, 0.15, 0.025)));\n    f = opUn(f, sBx(p - vec3(0.25, 0.18, -0.35), vec3(0.025, 0.15, 0.025)));\n    return f;\n}\n\nfloat obtainLGateConfiguration(vec3 p){\n\n    p.xz = rot(3.1416 * 1.5) * p.xz;\n    p.y += 0.5;\n    vec3 p0 = p;\n    p0.z += 0.1;\n    float f = sBx(p0, vec3(0.3, 0.05, 0.4));\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    f = opUn(f, sBx(p0 - vec3(0.0, 0.0, -0.1), vec3(0.3, 0.05, 0.4)));\n    f = opUn(f, gate(p));\n    return f;\n}\n\nfloat obtainTConfiguration(vec3 p){\n\n    vec3 p0 = p;\n    p0.y += 0.5;\n\n    p0.z += 0.1;\n    float f = sBx(p0, vec3(0.3, 0.05, 0.4));\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    f = opUn(f, sBx(p0, vec3(0.3, 0.05, 0.5)));\n    return f;\n}\n\nfloat obtainStairsConfiguration(vec3 p){\n\n    p.z = -p.z;\n    p.y -= 0.5;\n    float f = sBx(p - vec3(0.0, 0.0, -0.45), vec3(0.3, 0.05, 0.05));\n    for(float i = 1.0; i < 9.5; i += 1.0)\n    f = opUn(f, sBx(p - vec3(0.0, 0.1 * i, -0.45 + i * 0.1), vec3(0.3, 0.05, 0.05)));\n    return f;\n}\n\nfloat obtainStairsConfiguration2(vec3 p){\n\n    p.z = -p.z;\n    p.y -= 0.5;\n    float f = sBx(p - vec3(0.0, 0.0, -0.45), vec3(0.3, 0.05, 0.05));\n    for(float i = 1.0; i < 9.5; i += 1.0)\n    f = opUn(f, sBx(p - vec3(0.15, 0.1 * i, -0.45 + i * 0.1), vec3(0.15, 0.05, 0.05)));\n    f = opUn(f, sBx(p - vec3(-0.15, -0.95, 0.0), vec3(0.15, 0.05, 0.5)));\n    return f;\n}\n\n// float Do(vec3 ro, vec3 rd, vec3 p, float d, int x, int y, int z, float t){\n\n//     vec2 v = boxIntersection(ro - vec3(x, y, z), rd, vec3(0.52, 0.52, 0.52));\n//     //if(v.y > t) return opUn(d, obtainTConfiguration(p - vec3(x, y, z)));\n//     return 10000.0;\n// }\n\nint imod(int x, int y) {\n\n    int i = x / y;\n    return x - i * y;\n}\n\nfloat sw(float i, float f, vec3 tp, vec3 et){\n\n    if(i > 5.5) f = opUn(f, obtainTConfiguration(tp - et)); //obtainTConfiguration(tp.xyz);//opUn(mData0.d, obtainTConfiguration(tp.xyz)); \n    else if(i > 4.5) f = opUn(f, obtainStairsConfiguration2(tp - et));\n    else if(i > 3.5) f = opUn(f, obtainStairsConfiguration(tp - et));\n    else if(i > 2.5) f = opUn(f, obtainLGateConfiguration(tp - et)); \n    else if(i > 1.5) f = opUn(f, obtainLConfiguration(tp - et)); \n    else if(i > 0.5) f = opUn(f, obtainIGateConfiguration(tp - et)); \n    else f = opUn(f, obtainIConfiguration(tp - et)); \n    return f;\n}\n\nfloat drw(vec3 ro, vec3 rd, float t, float time, vec3 p0) {\n\n    ivec4 m1[324] = ivec4[](ivec4(3, 0, 18, 19), ivec4(3, 1, 18, 23), ivec4(3, 2, 18, 31), ivec4(4, 1, 18, 25), ivec4(4, 0, 18, 9), ivec4(4, 1, 19, 27), ivec4(4, 0, 17, 0), ivec4(4, 1, 17, 0), ivec4(2, 1, 18, 1), ivec4(2, 2, 18, 1), ivec4(4, 1, 16, 15), ivec4(4, 0, 16, 15), ivec4(5, 1, 16, 10), ivec4(5, 0, 16, 14), ivec4(5, 1, 17, 8), ivec4(5, 0, 17, 8), ivec4(6, 0, 17, 5), ivec4(6, 1, 17, 17), ivec4(6, 2, 17, 29), ivec4(1, 1, 18, 1), ivec4(1, 2, 18, 1), ivec4(5, 1, 19, 25), ivec4(5, 1, 18, 11), ivec4(6, 1, 18, 3), ivec4(0, 1, 18, 27), ivec4(0, 2, 18, 11), ivec4(7, 1, 18, 7), ivec4(7, 2, 17, 7), ivec4(0, 1, 17, 11), ivec4(1, 1, 17, 13), ivec4(8, 1, 18, 3), ivec4(7, 0, 17, 17), ivec4(0, 1, 19, 2), ivec4(0, 2, 19, 2), ivec4(1, 1, 16, 6), ivec4(1, 1, 15, 10), ivec4(0, 1, 15, 24), ivec4(9, 1, 18, 31), ivec4(9, 0, 18, 19), ivec4(8, 2, 17, 9), ivec4(0, 1, 14, 14), ivec4(8, 2, 16, 2), ivec4(8, 2, 15, 14), ivec4(10, 0, 18, 26), ivec4(10, 0, 19, 24), ivec4(9, 0, 19, 11), ivec4(7, 2, 15, 7), ivec4(11, 0, 19, 1), ivec4(11, 0, 18, 17), ivec4(11, 1, 18, 29), ivec4(12, 0, 19, 7), ivec4(12, 1, 18, 1), ivec4(6, 2, 15, 24), ivec4(5, 2, 15, 24), ivec4(6, 2, 14, 0), ivec4(5, 2, 14, 10), ivec4(6, 2, 13, 14), ivec4(5, 2, 13, 8), ivec4(5, 2, 12, 15), ivec4(6, 2, 12, 24), ivec4(7, 2, 12, 25), ivec4(7, 2, 13, 30), ivec4(7, 1, 13, 18), ivec4(4, 2, 14, 15), ivec4(4, 2, 15, 27), ivec4(4, 2, 16, 27), ivec4(5, 2, 16, 26), ivec4(5, 2, 17, 0), ivec4(5, 2, 18, 27), ivec4(6, 2, 18, 7), ivec4(7, 2, 18, 3), ivec4(8, 2, 18, 7), ivec4(9, 2, 18, 3), ivec4(4, 2, 17, 4), ivec4(5, 2, 19, 25), ivec4(4, 2, 19, 11), ivec4(6, 2, 16, 7), ivec4(7, 2, 16, 31), ivec4(7, 1, 16, 23), ivec4(7, 0, 16, 19), ivec4(8, 1, 16, 14), ivec4(8, 1, 17, 13), ivec4(8, 0, 16, 26), ivec4(13, 0, 19, 25), ivec4(7, 1, 14, 25), ivec4(6, 1, 14, 12), ivec4(6, 1, 13, 6), ivec4(6, 1, 12, 4), ivec4(13, 1, 18, 13), ivec4(13, 0, 18, 25), ivec4(13, 0, 17, 6), ivec4(13, 1, 17, 14), ivec4(12, 1, 17, 12), ivec4(10, 2, 18, 26), ivec4(11, 2, 18, 9), ivec4(7, 2, 11, 28), ivec4(7, 1, 11, 20), ivec4(7, 0, 11, 16), ivec4(6, 2, 11, 2), ivec4(6, 1, 11, 10), ivec4(7, 1, 10, 28), ivec4(9, 0, 16, 9), ivec4(12, 1, 16, 2), ivec4(9, 0, 15, 15), ivec4(5, 1, 11, 12), ivec4(13, 0, 16, 0), ivec4(12, 1, 15, 20), ivec4(12, 0, 15, 16), ivec4(12, 2, 15, 28), ivec4(12, 2, 16, 6), ivec4(12, 2, 17, 24), ivec4(13, 2, 17, 14), ivec4(13, 2, 18, 25), ivec4(11, 2, 17, 11), ivec4(13, 0, 15, 18), ivec4(13, 1, 15, 30), ivec4(12, 0, 14, 4), ivec4(12, 1, 14, 4), ivec4(13, 1, 14, 4), ivec4(6, 2, 10, 15), ivec4(7, 2, 10, 24), ivec4(10, 2, 19, 2), ivec4(12, 1, 13, 14), ivec4(12, 0, 13, 26), ivec4(13, 1, 13, 4), ivec4(13, 0, 13, 24), ivec4(13, 0, 12, 4), ivec4(13, 1, 12, 0), ivec4(14, 0, 13, 14), ivec4(7, 2, 9, 6), ivec4(5, 1, 10, 14), ivec4(13, 2, 19, 12), ivec4(8, 2, 10, 1), ivec4(9, 2, 10, 25), ivec4(14, 0, 14, 13), ivec4(9, 2, 11, 27), ivec4(9, 2, 12, 6), ivec4(10, 2, 11, 24), ivec4(10, 2, 10, 6), ivec4(7, 2, 8, 27), ivec4(11, 0, 13, 1), ivec4(11, 1, 13, 5), ivec4(9, 2, 9, 0), ivec4(10, 2, 9, 0), ivec4(7, 2, 7, 15), ivec4(10, 1, 13, 11), ivec4(10, 0, 13, 27), ivec4(9, 2, 8, 14), ivec4(8, 2, 8, 5), ivec4(8, 2, 7, 1), ivec4(9, 2, 7, 1), ivec4(10, 2, 8, 2), ivec4(10, 2, 7, 26), ivec4(13, 1, 11, 2), ivec4(13, 0, 11, 14), ivec4(10, 0, 12, 15), ivec4(11, 0, 12, 24), ivec4(12, 0, 12, 17), ivec4(12, 0, 11, 3), ivec4(11, 0, 11, 27), ivec4(10, 0, 14, 2), ivec4(10, 1, 14, 2), ivec4(10, 0, 15, 24), ivec4(10, 1, 15, 8), ivec4(11, 0, 15, 25), ivec4(11, 0, 14, 18), ivec4(11, 1, 15, 13), ivec4(4, 1, 10, 8), ivec4(13, 1, 10, 26), ivec4(12, 1, 10, 15), ivec4(11, 0, 16, 6), ivec4(11, 0, 17, 13), ivec4(10, 0, 17, 5), ivec4(9, 0, 17, 1), ivec4(11, 2, 7, 1), ivec4(14, 1, 10, 13), ivec4(4, 1, 9, 6), ivec4(14, 1, 9, 25), ivec4(13, 1, 9, 5), ivec4(12, 1, 9, 5), ivec4(12, 2, 7, 25), ivec4(4, 1, 8, 15), ivec4(12, 2, 8, 0), ivec4(12, 2, 9, 9), ivec4(11, 2, 9, 8), ivec4(11, 2, 8, 28), ivec4(11, 1, 8, 16), ivec4(11, 1, 7, 25), ivec4(10, 1, 7, 26), ivec4(10, 1, 8, 2), ivec4(9, 1, 7, 29), ivec4(9, 0, 7, 17), ivec4(10, 1, 9, 8), ivec4(12, 2, 6, 28), ivec4(12, 1, 6, 20), ivec4(12, 0, 6, 16), ivec4(11, 1, 6, 28), ivec4(11, 0, 6, 16), ivec4(12, 1, 5, 28), ivec4(9, 2, 13, 6), ivec4(11, 0, 10, 0), ivec4(14, 1, 8, 15), ivec4(9, 2, 14, 0), ivec4(9, 2, 15, 27), ivec4(10, 2, 15, 24), ivec4(10, 2, 14, 2), ivec4(10, 2, 13, 27), ivec4(10, 2, 12, 28), ivec4(11, 2, 15, 9), ivec4(11, 2, 13, 9), ivec4(11, 2, 14, 11), ivec4(12, 2, 14, 24), ivec4(13, 2, 14, 24), ivec4(13, 2, 13, 0), ivec4(13, 2, 12, 0), ivec4(12, 2, 13, 6), ivec4(13, 2, 11, 6), ivec4(13, 2, 10, 10), ivec4(12, 2, 10, 11), ivec4(11, 2, 12, 11), ivec4(12, 2, 12, 25), ivec4(12, 2, 11, 0), ivec4(11, 2, 11, 9), ivec4(11, 2, 10, 28), ivec4(11, 1, 10, 16), ivec4(9, 2, 16, 8), ivec4(10, 2, 16, 5), ivec4(11, 2, 16, 31), ivec4(15, 1, 8, 17), ivec4(15, 2, 8, 29), ivec4(11, 0, 9, 25), ivec4(11, 0, 8, 0), ivec4(10, 0, 9, 8), ivec4(10, 0, 8, 14), ivec4(9, 0, 8, 7), ivec4(14, 2, 14, 10), ivec4(8, 0, 8, 26), ivec4(8, 0, 7, 3), ivec4(14, 2, 19, 24), ivec4(14, 2, 18, 27), ivec4(14, 2, 17, 4), ivec4(16, 2, 8, 3), ivec4(17, 2, 8, 31), ivec4(17, 1, 8, 19), ivec4(8, 0, 9, 9), ivec4(7, 0, 8, 27), ivec4(7, 0, 9, 27), ivec4(7, 0, 7, 27), ivec4(14, 2, 16, 14), ivec4(13, 2, 16, 29), ivec4(14, 2, 15, 30), ivec4(14, 1, 15, 22), ivec4(14, 0, 15, 18), ivec4(14, 1, 16, 30), ivec4(18, 1, 8, 1), ivec4(15, 2, 18, 24), ivec4(15, 2, 19, 1), ivec4(15, 2, 17, 11), ivec4(16, 2, 18, 9), ivec4(16, 2, 17, 10), ivec4(16, 2, 19, 5), ivec4(7, 0, 6, 0), ivec4(7, 0, 5, 18), ivec4(7, 1, 5, 30), ivec4(7, 1, 4, 22), ivec4(7, 2, 4, 30), ivec4(17, 2, 19, 5), ivec4(5, 1, 8, 3), ivec4(18, 2, 19, 24), ivec4(7, 2, 3, 4), ivec4(7, 1, 3, 0), ivec4(18, 2, 18, 6), ivec4(11, 0, 5, 15), ivec4(19, 2, 19, 13), ivec4(19, 2, 18, 11), ivec4(7, 1, 2, 6), ivec4(7, 2, 2, 14), ivec4(6, 2, 2, 11), ivec4(6, 2, 3, 2), ivec4(6, 2, 4, 2), ivec4(19, 1, 8, 14), ivec4(19, 1, 9, 4), ivec4(6, 2, 5, 13), ivec4(7, 1, 1, 18), ivec4(7, 2, 1, 30), ivec4(6, 1, 8, 14), ivec4(6, 1, 9, 6), ivec4(18, 2, 17, 14), ivec4(17, 2, 17, 11), ivec4(17, 2, 18, 30), ivec4(17, 1, 18, 22), ivec4(17, 0, 18, 18), ivec4(17, 1, 19, 13), ivec4(17, 1, 17, 11), ivec4(16, 1, 19, 29), ivec4(18, 1, 17, 10), ivec4(18, 1, 18, 6), ivec4(17, 0, 19, 9), ivec4(18, 1, 19, 4), ivec4(5, 2, 5, 27), ivec4(5, 2, 4, 10), ivec4(5, 2, 6, 25), ivec4(4, 2, 6, 15), ivec4(7, 2, 0, 0), ivec4(4, 2, 4, 24), ivec4(3, 2, 4, 3), ivec4(19, 1, 10, 4), ivec4(5, 2, 7, 0), ivec4(5, 2, 8, 27), ivec4(6, 2, 8, 10), ivec4(4, 2, 7, 2), ivec4(4, 2, 3, 14), ivec4(3, 2, 3, 5), ivec4(5, 2, 9, 12), ivec4(2, 2, 4, 1), ivec4(2, 2, 3, 1), ivec4(19, 1, 11, 12), ivec4(1, 2, 4, 8), ivec4(1, 2, 3, 27), ivec4(1, 2, 2, 0), ivec4(1, 2, 1, 25), ivec4(1, 2, 0, 14), ivec4(0, 2, 0, 29), ivec4(0, 2, 1, 7));\n    float f = 1000.0;\n    for(int i = 0; i < 324; i++) {\n\n        if(time < float(i) / 324.0 * 10.0 + 0.5) break;\n        ivec4 m = m1[i];\n\n        int index = m.w / 4;\n        int pose = imod(m.w, 4);\n        float pose0 = float(pose);\n\n        mat3 my = mat3(cos(3.1416 / 2.0 * pose0), 0.0, -sin(3.1416 / 2.0 * pose0),\n                  0.0, 1.0, 0.0, \n                  sin(3.1416 / 2.0 * pose0), 0.0, cos(3.1416 / 2.0 * pose0));\n        vec3 tp = p0 * my;\n\n        float x = float(m.x);\n        float y = float(m.y);\n        float z = float(m.z);\n\n        vec3 et = vec3(x, y, z) * my;\n\n        //int xt = int(x / _sizeX * 2.0);\n        //int zt = int(z / _sizeZ * 2.0);\n        //vec2 v0 = boxIntersection(ro - vec3(float(xt) * 10.0 + 4.5, y, float(zt) * 10.0 + 4.5), rd, vec3(_sizeX / 4.0, 0.52, _sizeZ / 4.0));\n        //if(v0.y < t) continue;\n\n        vec2 v = boxIntersection(ro - vec3(x, y, z), rd, vec3(0.52, 0.52, 0.52));\n        if(v.y > t)\n        if(float(index) > 6.5) continue;\n        else f = sw(float(index), f, tp, et);\n    }\n    return f;\n}   \n\nMData mp(in vec3 ro, in vec3 rd, in float t, float time) {\n    \n    vec3 p = ro + t * rd;   \n   \n    vec3 p0 = p;//my * vec4(p, 1.0);\n    MData mData0 = setMatPr(10000.0, vec3(1.0), 1.0, 1.0);\n    mData0.d = drw(ro, rd, t, time, p0);\n\n    \n\treturn mData0;\n}\n\nMData itrs(in vec3 ro, in vec3 rd, in float time) {\n\n    \n    MData h = setMatPr(-1.0, vec3(0.2), 1.0, 1.0);\n    vec2 tmix = boxIntersection(ro - vec3(9.5, 1.0, 9.5), rd, vec3(10.0, 1.52, 10.0));\n\tif(tmix.y > 0.0) {\n\n        float t = max(tmix.x, 0.001);\n    \t\n        for(int i = 0; i < 128 && t < tmix.y; i++) {\n            \n            h = mp(ro, rd, t, time);\n            if(h.d < 0.001) { h.d = t; return h; }\n            t += h.d;\n        }\n        //h = setMatPr(1.0, vec3(0.5, 0.2, 1.0), 1.0, 1.0);\n    }\n    h = setMatPr(-1.0, vec3(0.5), 1.0, 1.0);\n    return h;\n}\n\nfloat cao(in vec3 ro, in vec3 rd, in float t, in vec3 nor, in float time) {\n    \n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 4; i++) {\n\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = mp(ro + h * nor, rd, t, time).d;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 cN(in vec3 ro, in vec3 rd, in float t, in float time) {\n    \n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.00025;\n    return normalize(e.xyy * mp(ro + e.xyy * eps, rd, t, time).d + \n\t\t\t\t\t e.yyx * mp(ro + e.yyx * eps, rd, t, time).d + \n\t\t\t\t\t e.yxy * mp(ro + e.yxy * eps, rd, t, time).d + \n\t\t\t\t\t e.xxx * mp(ro + e.xxx * eps, rd, t, time).d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 20.0);\n    vec3 lkt = normalize(vec3(p0, -2.0));\n\n    float x = mo.x * 6.2831853;\n    float y = -(mo.y * 2.0 - 1.0) * 1.5707963268;\n    mat4 my = mat4(cos(x), 0.0, sin(x), 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  -sin(x), 0.0, cos(x), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    mat4 mx = mat4(1.0, 0.0, 0.0, 0.0,\n                  0.0, cos(y), -sin(y), 0.0,\n                  0.0, sin(y), cos(y), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    ro = (my * mx * vec4(ro, 1.0)).xyz;\n\n    ro -= vec3(-10.0, 0.0, -10.0);\n    lkt = (my * mx * vec4(lkt, 0.0)).xyz;\n\n    float time = iTime;\n\n    MData m_data = itrs(ro, lkt, time);\n\n    if(m_data.d < 0.0) { fragColor = vec4(0.2); return; }\n\n    vec3 nor = cN(ro, lkt, m_data.d, time);\n    \n    \n    float ao = cao(ro, lkt, m_data.d, nor, time);\n    vec3 lig = normalize(vec3(0.8, 10.2, 1.6));\n    //vec3 dif = m_data.albedo /*vec3(1.0)*/ * (dot(nor, lig) + 1.0) / 2.0;\n    \n    vec3 spec = m_data.albedo * pow(dot(nor, normalize(-lkt + lig)), 10.0);\n\n\n\n    fragColor = vec4(spec * ao /* (ro + lkt * m_data.d + 1.0) / 2.0*/, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 180, 180, 203], [205, 205, 238, 238, 261], [263, 263, 298, 298, 320], [322, 322, 341, 341, 422], [424, 424, 452, 452, 549], [551, 551, 590, 590, 707], [709, 709, 768, 768, 1117], [1119, 1119, 1191, 1191, 1339], [1341, 1341, 1376, 1376, 1991], [1993, 1993, 2012, 2012, 2313], [2315, 2315, 2354, 2354, 2760], [2762, 2762, 2797, 2797, 3591], [3593, 3593, 3632, 3632, 3916], [3918, 3918, 3953, 3953, 4153], [4155, 4155, 4195, 4195, 4441], [4443, 4443, 4484, 4484, 4806], [5075, 5075, 5099, 5099, 5143], [5145, 5145, 5190, 5190, 5748], [13648, 13648, 13706, 13706, 13905], [13907, 13907, 13958, 13958, 14480], [14482, 14482, 14557, 14557, 14838], [14840, 14840, 14900, 14900, 15203], [15205, 15205, 15262, 15262, 16510]], "test": "valid"}
{"id": "st3GzS", "name": "Raymarching with color!", "author": "RayWorld", "description": "My first shader. I'm learning the ropes of C++ and webgl, as I'm used to javascript.", "tags": ["raymarching", "stuff"], "likes": 2, "viewed": 24, "published": "Public", "date": "1636331523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define HIT_DIST 0.01 \n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\nvec3 bezierPos(vec3 anchor1, vec3 handle1, vec3 handle2, vec3 anchor2, float t) {\n    vec3 point = anchor1 * (-pow(t,3.)+3.*pow(t,2.)-3.*t+1.);\n    point += handle1 * (3.*pow(t,3.)-6.*pow(t,2.)+3.* t);\n    point += handle2 * (-3.*pow(t,3.)+3.*pow(t,2.));\n    point += anchor2 * (pow(t,3.));\n    return point;\n}\n\nvec3 getCameraPos() {\n    float pathProgress = float(iFrame)/float(120);\n    int bezierID = int(mod(pathProgress,3.0));\n    float bezierProgress = mod(pathProgress,1.0);\n    vec3 position = vec3(0.,1.,0.);\n    switch (bezierID) {\n        case 0:\n        position = bezierPos(vec3(0.,1.,0.),vec3(-0.5,1.,-1.),vec3(-1.,1.,-5.2),vec3(1.,1.,-5.),bezierProgress);\n        break;\n        case 1: \n        position = bezierPos(vec3(1.,1.,-5.),vec3(3.,1,-5.),vec3(6.,1.,-2.5),vec3(6.,1.,0.),bezierProgress);\n        break;\n        case 2:\n        position = bezierPos(vec3(6.,1.,0.),vec3(6.,1.,1.),vec3(0.5,1.,1.),vec3(0.,1.,0.),bezierProgress);\n        break;\n    }\n    return position;\n}\n\nfloat sphereSDF(vec3 pos,float radius) {\n    return length(pos) - radius;\n}\n\nfloat cubeSDF(vec3 pos, vec3 scale) {\n    vec3 offset = abs(pos) - scale;\n    float unsignedDist = length(max(offset,0.));\n    float signedDist = max(max(min(offset, 0.).x,min(offset, 0.).y),min(offset, 0.).z);\n    return signedDist + unsignedDist;\n}\n\nfloat torusSDF(vec3 pos, vec2 radii) {\n    return length( vec2(length(pos.xz)-radii.x,pos.y) )-radii.y;\n}\n\nvec3 rotateYZ(vec3 vector, float angle) {\n    vector.zy *= rot2(angle);\n    return vector;\n}\n\nvec3 rotateXZ(vec3 vector, float angle) {\n    vector.zx *= rot2(angle);\n    return vector;\n}\n\nvec3 rotateXY(vec3 vector, float angle) {\n    vector.yx *= rot2(angle);\n    return vector;\n}\n\nfloat boolOperation(float subjectDist, float actorDist, int operation) {\n    float returnValue = subjectDist;\n    switch (operation) {\n        case 0:\n        //Union\n        returnValue = min(subjectDist,actorDist);\n        break;\n        case 1:\n        //Difference\n        returnValue = max(subjectDist, -actorDist);\n        break;\n        case 2:\n        //Intersect\n        returnValue = max(subjectDist,actorDist);\n        break;\n    }\n    return returnValue;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothBoolOperation(float subjectDist, float actorDist, int operation,float k) {\n    float returnValue = subjectDist;\n    switch (operation) {\n        case 0:\n        //Union\n        returnValue = smin(subjectDist, actorDist, k);\n        break;\n        case 1:\n        //Difference\n        returnValue = smin(-subjectDist, actorDist, k);\n        break;\n        case 2:\n        //Intersect\n        returnValue = smin(-subjectDist, -actorDist, k);\n        break;\n    }\n    return returnValue;\n}\n\nvec4 getDist(vec3 center) {\n    vec4 minDist = vec4(0.5,0.5,1.,101.);\n    vec4 plane = vec4(0.25, 1.0, 0.3, center.y);\n    vec4[] objects = vec4[](\n        vec4(0.25,0.5,1.0,mix(cubeSDF(center - vec3(0.0,2.0,7.0),vec3(0.5,1.5,0.5)),sphereSDF(center-vec3(0.0,2.0,7.0),1.0),0.5+0.5*sin(iTime))),\n        vec4((1.+cos(iTime))/2.,(1.+cos(iTime+radians(120.)))/2.,1.0,torusSDF(center - vec3(3,0.5,7),vec2(1,0.5)))\n    );\n    if (minDist.w > plane.w) minDist = plane;\n    int objectCount = objects.length();\n    for (int i = 0; i < objectCount; i++) {\n        if (minDist.w > objects[i].w) minDist = objects[i];\n    }\n    return minDist;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p).w;\n        dO += dS;\n        if(dO>MAX_DIST || dS<HIT_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).w,\n        getDist(p-e.yxy).w,\n        getDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 1);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = rayMarch(p+n*HIT_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvec3 colorFromScene(vec3 rayOrigin, vec3 rayDirection, vec3 lightDir) {\n    vec3 returnValue = vec3(0.5,0.5,1);\n    //march to scene\n    float sceneDist = rayMarch(rayOrigin, rayDirection);\n    vec3 landingPosition = rayOrigin + rayDirection * (sceneDist - 0.1);\n    vec4 colorContender = getDist(rayOrigin + rayDirection * sceneDist);\n    if (colorContender.w < HIT_DIST) {\n        // if hit march towards light\n        float dif = getLight(landingPosition);\n        returnValue = colorContender.xyz * dif;\n        \n    }    \n    return returnValue;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPosition = getCameraPos();\n    vec2 rotations = vec2(0.,0.);\n    float theta = rotations.x;\n    float phi = rotations.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 rayDir = normalize(vec3(uv.xy,1));\n    rayDir.zy *= rot2(phi);\n    rayDir.zx *= rot2(theta);\n    vec3 col = colorFromScene(cameraPosition, rayDir, vec3(1,0,0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 226, 226, 455], [457, 457, 478, 478, 1138], [1140, 1140, 1180, 1180, 1215], [1217, 1217, 1254, 1254, 1467], [1469, 1469, 1507, 1507, 1574], [1576, 1576, 1617, 1617, 1668], [1670, 1670, 1711, 1711, 1762], [1764, 1764, 1805, 1805, 1856], [1858, 1858, 1930, 1930, 2326], [2328, 2328, 2369, 2369, 2460], [2462, 2462, 2548, 2548, 2960], [3597, 3597, 3631, 3631, 3834], [3836, 3836, 3860, 3860, 4058], [4060, 4060, 4084, 4084, 4336], [4338, 4338, 4409, 4409, 4890], [4891, 4891, 4948, 4948, 5351]], "test": "error"}
{"id": "stc3WH", "name": "heart.....", "author": "lllcz", "description": "....", "tags": [], "likes": 3, "viewed": 94, "published": "Public API", "date": "1636067999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define PI_HALF (.5*PI)\n#define PIx2 (2.*PI)\n \n// 2D rotation matrix\nmat2 rotmat(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n \n/// @brief 返回带有抗锯齿的 2D 圆的距离场\n/// @param uv 纹理坐标\n/// @param origin 圆心坐标\n/// @param radius 圆的半径\n/// @param alias 抗锯齿的区间\nfloat smooth_circle(in vec2 uv, in vec2 origin, float radius, float alias)\n{\n    return /*1.0 - */smoothstep(radius - alias, radius + alias,\n                                length(uv - origin));\n}\n \n/// @brief 返回默认带抗锯齿的 2D 圆的距离场\n/// @param uv 纹理坐标\n/// @param origin 圆心坐标\n/// @param radius 圆的半径\nfloat circle(in vec2 uv, in vec2 origin, float radius)\n{\n    return smooth_circle(uv, origin, radius, 0.005);\n}\n \n/// 可以分别控制四个角的大小 [z, x\n///                         w, y]\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x  = (p.y > 0.0) ? r.x  : r.y;\n \n    vec2 q = abs(p) - b + r.x;\n    float d = max(q.x, q.y);\n    return min(d, 0.0) + length(max(q, 0.0)) - r.x;\n}\n \n/// @brief 绘制心形\nfloat inHeart (vec2 p, vec2 center)\n{\n    //移动中心\n    p = p - center;\n    //旋转\n    vec2 q = rotmat(45. / 180.*PI) * p;\n    \n    float ret = sdRoundBox(q, vec2(.15), vec4(0.03));\n \n    ret = smoothstep(0.01, .012, ret);\n    ret = min(ret, circle(p, vec2(.1, .1), .161));\n    ret = min(ret, circle(p, vec2(-.1, .1), .161));\n \n    return ret;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n \n     //先绘制心形\n    float dist = inHeart(uv, vec2(.5));\n \n     //再填充波浪\n    float color[2];\n    for (int i = 0; i < 2; i++)\n    {\n  \n        /// @note 正弦波形\n        float p = (5.*uv.x + float(i)  +  1.*iTime);\n        float offset =  .025 * sin(p) + .62;\n \n        float eps = 1e-3;\n        float color_0 = step(uv.y, offset);\n        color[i] = color_0 * step(dist, .1);\n    }\n \n    vec3 temp = mix(vec3(57., 56., 78.) / 255., vec3(245., 245., 245.) / 255., dist);\n    temp = mix(temp, vec3(233., 51., 74.)/255., color[0]);\n    \n    fragColor = vec4(mix(temp,  vec3(.4, 0., 0.),clamp(color[0] - color[1], 0., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 90, 112, 112, 164], [167, 347, 423, 423, 543], [546, 693, 749, 749, 804], [807, 888, 941, 941, 1132], [1135, 1159, 1196, 1215, 1511], [1514, 1514, 1569, 1569, 2265]], "test": "valid"}
{"id": "stc3WX", "name": "plastic disco", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 21, "published": "Public", "date": "1636813555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(5.0*iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(5.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(5.0*iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(5.0*iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(0.02*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(0.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 878]], "test": "valid"}
{"id": "std3R4", "name": "light pulses", "author": "megan023", "description": "moving pulses of light", "tags": ["fireflies"], "likes": 1, "viewed": 28, "published": "Public", "date": "1635805371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 color1 =vec3(255.0, 220.0, 156.0)/255.0; // orange lighting\nvec3 bk_color1 =vec3(46, 42, 39)/255.0; //dark brown\n\n\n// the following helper function is adapted from https://www.shadertoy.com/view/Md23DV\n// returns the 1.0 inside the disk area and 0.0 outside the disk area\n// and has a outer glow\nfloat disk(vec2 r, vec2 center, float radius, float glow) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-glow, radius, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //relocate center\n    vec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n    //relocate mouse to center\n    vec2 mouse = 2.0*vec2(iMouse.xy - 0.5*iResolution.xy)/iResolution.y; \n    \n    vec3 col = bk_color1; //base dark brown\n    \n    //calculate lights\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    float x = (iTime/2.0)+uv.x;\n    float flicker1 = ((0.3)*sin(5.0*x)+(0.5)*sin(2.0*x)+0.2*sin(0.2*x)+1.0)/2.0;\n    float flicker2 = (0.3*sin(0.2*x)+0.2*sin(7.0*x)+0.3*sin(-7.0*x)+1.0)/4.0;\n    float flicker3 = (0.2*cos(4.0*x)+(0.5)*cos(0.3*x)+0.2*cos(9.0*x)+1.0)/2.0;\n    float flicker4 = (0.03*cos(5.0*x)+(0.75)*cos(2.0*x)+0.09*cos(0.2*x)+1.0)/3.0;\n    \n    col += disk(r, mouse, flicker1, flicker1)*color1;\n    col += disk(r, vec2(-mouse.x, -mouse.y), flicker2, flicker2)*color1;\n    col += disk(r, vec2(2.0*mouse.x, -1.5*mouse.y), flicker3, flicker3)*color1;\n    col += disk(r, vec2(-1.7*mouse.x, 0.5*mouse.y), flicker4, flicker4)*color1;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 301, 360, 360, 550], [552, 552, 609, 631, 1678]], "test": "valid"}
{"id": "std3Wn", "name": "Weaving Bridges", "author": "Plento", "description": "An endless weaving highway, with no exits. Mouse controls zoom.", "tags": ["2d", "mouse", "road", "car", "weave"], "likes": 33, "viewed": 336, "published": "Public API", "date": "1636018100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson (Plento)\n\n// An endless weaving highway, with no exits. Mouse controls zoom.\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define ss(a, b, x) smoothstep(a, b, x)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define w_scale 5.\n#define car_size vec2(0.07, 0.1)\n\n// Dave Hoshkin\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// Standard perlin\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// box sdf\nfloat box( in vec2 p, in vec2 b, float r){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// is a cell be flipped or not\nbool flipped(vec2 id){\n    float rnd = hash12(id*200.);\n    if(rnd > .5) return true;\n    \n    return false;\n}\n\n\nvec3 car(vec3 col, vec2 uv, vec2 uid){\n    uv.y *= .6; // stretch in direction of travel so they have more room to move in their cell\n    \n    float spd = iTime*.1;\n    \n    // Repeated uvs for cars (We only draw one)\n    vec2 cm = vec2(0., spd );\n    vec2 cv = fract((uv-cm)*w_scale*2.)-0.5;\n    vec2 id = floor((uv-cm)*w_scale*2.);\n    float idc = floor((uv.x-cm.x)*w_scale);\n    \n    // Switch direction \"randomly\"\n    if(cos(idc*2.) > 0.){\n        cm = vec2(0., -spd );\n        cv = fract((uv-cm)*w_scale*2.)-0.5;\n        id = floor((uv-cm)*w_scale*2.);\n    }\n    \n    if(int(id.y) % 7 == 0) return col; // Leave some cells empty\n    \n    // Make cars move down road in somewhat non uniform way\n    float t = id.y*114. + id.x*116.;\n    vec2 p = vec2(.0, .3*cos(iTime*1. + t));\n    \n    // Adjust car position based on side of road\n    if(int(id.x) % 2 == 0) p.x -= .2; \n    else p.x += .2;\n    \n    cv += p;\n    float cars = ss(.01, .0, box(cv, car_size, .03)); // Car mask\n    \n    // Car color\n    float ct = (id.x*3. + id.y*5.);\n    vec3 carCol = .5+.26*cos(vec3(4., 2., 1.)*ct + vec3(3., 4., 7.));\n    carCol *= max(ss(-.1, .21, abs(cv.y + .07)), .45);\n    carCol += .16*ss(0.055, 0.01, abs(cv.y));\n    \n    // Randomly add some variation\n    if(cos(ct) > 0.){\n        carCol *= max(abs(cos(ct)), .6);\n        carCol = mix(carCol, .6*vec3(.75, .85, .99), .7*ss(.3, .2, abs(cv.y*2. - .38)));\n    }\n   \n    // Shadow under car\n    float shdw = max(ss(-.08, .08, box(cv-vec2(0., .01), car_size+vec2(.015, .01), .03)), .3);\n    \n    return mix(col * shdw, carCol, cars) + vec3(0., 0., 0.);\n}\n\n\nvec3 road(vec2 uv, float y){\n    float rd = ss(.02, .00, abs(uv.x)); // road mask\n    rd *= ss(.25, .35, abs(fract(y*14.)-.5)); // road line\n    float bdg = ss(.35, .37, abs(uv.x)); // bridge mask\n    float shdw = ss(.49, .18, abs(uv.x)); // bridge shadow\n    \n    float nse = perlin(uv*45.); // perlin noise\n    float rc = clamp(nse*.4, .22, .24); // road color\n    float bc = clamp(nse, .46, .5); // bridge color\n    return mix(shdw * mix(vec3(rc), vec3(1), rd), vec3(bc), bdg);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 cv = uv;\n    uv *= 0.99 + (.5+.5*sin(iTime*.5))*0.77;\n    \n    if(iMouse.z > 0.)\n        uv *= max(0.3, (m.y+.4)*2.5);\n    \n    uv*=rot(-0.3);\n    uv += iTime*.1;\n   \n    // Road uvs\n    vec2 ruv = fract(uv*w_scale)-.5;\n    vec2 id = floor(uv*w_scale);\n    \n    vec3 col = vec3(1);\n    \n    // rotate uv 90 degree based on cell\n    float rnd = hash12(id*200.);\n    if(flipped(id)){\n        ruv = vec2(ruv.y, -ruv.x);\n        uv = vec2(uv.y, -uv.x);\n    }\n    \n    // cell containing current pixel flipped status\n    bool me = flipped(id);\n    \n    // main color\n    col = road(ruv, uv.y);\n    col = car(col, uv, id);\n    \n    // neighbooring cells flipped?\n    bool lft = flipped(id + vec2(-1., 0.));\n    bool rgt = flipped(id + vec2(1., 0.));\n    bool up = flipped(id + vec2(0., 1.));\n    bool dwn = flipped(id + vec2(0., -1.));\n    \n    // Add a shadow based on surrounding cells\n    if(me && !lft) col *= ss(.78, .12, (ruv.y));\n    if(me && !rgt) col *= ss(.78, .12, (-ruv.y));\n    if(!me && up) col *= ss(.78, .12, (ruv.y));\n    if(!me && dwn) col *= ss(.78, .12, (-ruv.y));\n    \n    col = pow(col*1.2, vec3(1.1));\n    \n    // intro thingy\n    float r = min(iTime, 3.);\n    if(iTime < 3.) col *= ss(r, r-.01, length(cv));\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 323, 344, 344, 461], [462, 462, 480, 480, 597], [598, 617, 638, 638, 944], [946, 957, 999, 999, 1083], [1085, 1116, 1138, 1138, 1226], [1229, 1229, 1267, 1267, 2824], [2827, 2827, 2855, 2855, 3309], [3312, 3312, 3352, 3352, 4653]], "test": "valid"}
{"id": "std3zl", "name": "Lava Blob", "author": "Moustave", "description": "o", "tags": ["yayyy"], "likes": 2, "viewed": 25, "published": "Public", "date": "1636567459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    precision highp float;\n\n    float time = iTime;\n    vec2 mouse = iMouse.xy;\n    vec2 resolution = iResolution.xy;\n\t\n\tconst int n =       25;\n\tfloat size =       0.12;\n\tfloat width =      0.8;\n\tfloat height =      1.;\n\tfloat speed =     0.15;\n    float blur =      0.2;\n    float clmp =      0.5;\n\n    float seedx =     3.01;\n\n\twidth/=2.;\n\theight/=2.;\n\tvec2 uv = ( fragCoord.xy / resolution.xy );\n\tfloat ratio = resolution.x/resolution.y;\n\tvec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n\tfloat dis = 1.0;\n\tvec2 pos;\n\tuv.x *= ratio;\n    \n\tfor (int i=0;i<n;i++){\n        \n            pos.x=sin(float(i)*seedx)*width+0.5;\n            pos.y=(float(i)/float(n))*abs(pow(cos(float(i)*12.8+time*speed*(1.+float(i)/111.)),3.))*height*2.;\n            pos.x*=ratio;\n            dis *= smoothstep(size-blur,size+blur,length(uv-pos));\t\t\n        \n    }\n    dis = step(clmp,dis);\n    if (mod(float(int(time/10.)),2.)==0.){\n        fragColor = vec4( col, 1.0 )*(1.-dis);\n    }\n    else {\n        fragColor = vec4( col, 1.0 )*dis;\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "stdGDj", "name": "Persian carpet 21", "author": "jarble", "description": "These carpets have many braided knot patterns.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 111, "published": "Public API", "date": "1636765931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        \n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //float bend = abs(fract((uv.x)*4.)-.5)/4.+1.;\n                //float bend = 1.125;\n                \n                uv = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                //uv.yx = triangle_wave(uv.yx+offset,scale)*bend-triangle_wave(uv+offset/1.5,scale)/bend;\n\n                uv += vec2(random1[k],random2[k]);\n                //bend = 1.+uv.x/2.;\n                //bend *= -1.;\n                //bend -= 1./3.;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = abs(col[c] - abs((uv.x)-(uv.y)));\n            \n\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2348]], "test": "valid"}
{"id": "stdGDN", "name": "Wowie!", "author": "ruojake", "description": "Playing with inverse kinematics.", "tags": ["2d", "ik", "fabrik"], "likes": 15, "viewed": 141, "published": "Public API", "date": "1636162598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Wowie! by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define saturate(x) clamp((x), 0., 1.)\n\nstruct seg\n{\n    vec2 p0, p1;\n    float len, r, c;\n};\n\nfloat sm(float a, float b, float q)\n{\n    float d = saturate((b - a) / q + .5);\n    float m = -.125 * q * d * (1. - d);\n    return mix(a, b, d) - m;\n}\n\nfloat line(vec2 p, float r, vec2 a, vec2 b)\n{\n    vec2 a2b = b - a,\n         a2p = p - a;\n    return length(a2p\n                - saturate(dot(a2p, a2b) / dot(a2b, a2b))\n                * a2b) - r;\n}\n\nvoid solveIK(vec2 root, vec2 target, inout seg segs[6])\n{\n    #define P0 segs[i].p0\n    #define P1 segs[i].p1\n    \n    for(int i = 5; i > -1; --i)\n    {\n        P1 = target;\n        P0 = P1 + normalize(P0 - P1) * segs[i].len;\n        target = P0;\n    }\n    \n    vec2 dir = normalize(segs[0].p1 - segs[0].p0);\n    \n    for(int i = 0; i < 6; ++i)\n    {\n        P0 = root;\n        \n        vec2 newDir = normalize(P1 - P0);\n        float t = dot(dir, newDir) * -.5 + .5;\n        t *= segs[i].c;\n        \n        newDir = normalize(mix(newDir, dir, t));\n        \n        P1 = P0 + newDir * segs[i].len;\n        \n        dir = newDir;\n        root = P1;\n    }\n    #undef P0\n    #undef P1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    seg segs[6] = seg[]\n    (\n        seg(vec2(-.1),  vec2(.01), .1, .025,  1. ),\n        seg(vec2(.02), vec2(-.01), .1, .02,   1. ),\n        seg(vec2(-.02), vec2(.03), .1, .015,  .75),\n        seg(vec2(.04), vec2(.03), .1, .0125, .5 ),\n        seg(vec2(.04), vec2(-.05), .1, .01,   .25),\n        seg(vec2(-.06), vec2(.05), .1, .0075, 0. )\n    );\n\n    vec2 target = vec2(sin(iTime), sin(iTime * 1.333)) * .4;\n    vec2 root = vec2(-.5);\n    \n    float d = 1000.;\n\n    solveIK(root, target, segs);\n    solveIK(root, target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    vec2 flip = vec2(-1, 1);\n\n    solveIK(root, target * flip, segs);\n    solveIK(root, target * flip, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(uv * flip, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    solveIK(root * flip, -target, segs);\n    solveIK(root * flip, -target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(-uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    solveIK(root, -target, segs);\n    solveIK(root, -target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(-uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    vec3 col = vec3(.8,.55,.05);\n    \n    \n    float blush = smoothstep(.2, 0., length(vec2(.4, 0) - abs(uv + vec2(0,.1))));\n    col = mix(col, vec3(1,.2,.2), blush * .3);\n    \n    \n    float eyeball = length(abs(uv) - vec2(.2, 0)) - .1;\n    \n    vec2 posPup = vec2(-.2, 0) + normalize(target - vec2(-.2,0)) * .07;\n    float pupL = length(uv - posPup) - .01;\n    \n    posPup = vec2(.2, 0) + normalize(target - vec2(.2,0)) * .07;\n    float pupR = length(uv - posPup) - .01;\n    \n    float outline = abs(eyeball) - .002;\n    outline = smoothstep(fwidth(outline), 0., outline);\n    eyeball = smoothstep(fwidth(eyeball), 0., eyeball);\n    pupL = smoothstep(fwidth(pupL), 0., pupL);\n    pupR = smoothstep(fwidth(pupR), 0., pupR);\n    \n    col = mix(col, vec3(.9), eyeball);\n    col *= 1. - outline;\n    col *= 1. - max(pupL, pupR);\n    \n    \n    float mouth = line(abs(uv + vec2(0.,.25)), .07, vec2(0), vec2(.2, 0) * (length(target) * 2.));\n    mouth = smoothstep(0.,fwidth(mouth), mouth);\n    col *= mouth;\n    \n    \n    float ball = length(uv - target) - .04;\n    outline = abs(ball) - .002;\n    outline = min(outline, abs(min(ball, d)) - .001);\n    \n    d = smoothstep(fwidth(d), 0., d);\n    ball = smoothstep(fwidth(ball), 0., ball);\n    outline = smoothstep(0., fwidth(outline), outline);\n    col = mix(col, vec3(.6,.45,0.), d);\n    col = mix(col, vec3(1,.4,.8), ball) * outline;\n    \n    col *= smoothstep(1., .3, length(fragCoord / iResolution.xy - .5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGDN.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[202, 202, 239, 239, 352], [354, 354, 399, 399, 553]], "test": "valid"}
{"id": "stdGRf", "name": "depth of field focus study 3", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 7, "viewed": 144, "published": "Public API", "date": "1636493894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .3;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 381, 381, 467], [470, 470, 541, 541, 777], [779, 779, 834, 834, 1810]], "test": "valid"}
{"id": "stdGWn", "name": "Moving RGB Squares", "author": "ersteller", "description": "Moving RGB squares. \n\nSome squares colored based on pixel position value and time. \n\nThis is for learning.\n\n", "tags": ["pixel", "rgb", "background", "moving", "art", "squares"], "likes": 2, "viewed": 110, "published": "Public API", "date": "1636011479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n   \n    if (    bool(int(fragCoord.x+iTime*10.)&16)\n         && bool(int(fragCoord.y)&16))\n    {\n        r = 1.;\n    }\n    \n    if (    bool(int(fragCoord.x+fragCoord.y)&32)\n         && bool(int(fragCoord.y-fragCoord.x)&32))\n    {\n        g = 1.;\n    }\n    if (    bool(int(fragCoord.x)&64)\n         && bool(int(fragCoord.y+iTime*15.)&64))\n    {\n        b = 1.;\n    }\n    \n    vec3 col = vec3(r,g,b);\n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 578]], "test": "valid"}
{"id": "stdGz4", "name": "Fully Animated Subdivision", "author": "Tater", "description": "By removing any reference to the current pixel position in the seeding it's possible to animation all iterations of the suddivision. \n\n(Mouseable)\n\n3D coming soon", "tags": ["2d", "mouse", "subdivision", "boxes"], "likes": 35, "viewed": 490, "published": "Public API", "date": "1635808115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Rectagular Subdivisor\" by Tater. https://shadertoy.com/view/7sV3WD\n// 2021-09-21 21:08:49\n\n#define pi 3.1415926535\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return max(d.x,d.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,6000.)*0.8;\n    float px = 1./iResolution.y;\n    \n    vec2 dMin = vec2(-0.5);\n    vec2 dMax = vec2(0.5);\n    dMin.x*=R.x/R.y;\n    dMax.x*=R.x/R.y;\n    vec2 dim = dMax - dMin;\n    float id = 0.;\n    float ITERS = 7.;\n    float seed = 0.4;\n\n \n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    float MIN_SIZE = 0.01;\n    //float ITERS = its;\n    float BORDER_SIZE = 0.003;\n    float MIN_ITERS = 1.;\n\n    \n    //BIG THANKS to @0b5vr for letting me use his cleaner subdiv implementation\n    //https://www.shadertoy.com/view/NsKGDy\n    vec2 diff2 = vec2(1);\n    for(float i = 0.;i<ITERS;i++){\n    \n        \n        // divide the box into quads\n        //Big thanks to @SnoopethDuckDuck for telling me about tanh(sin(x)*a)\n        vec2 divHash=tanh(vec2(sin(t*pi/3.+id+i*t*0.05),cos(t*pi/3.+h11(id)*100.+i*t*0.05))*7.)*0.35+0.5;\n        \n        //Less agressive animation\n        //divHash=vec2(sin(t*pi/3.+id),cos(t*pi/3.+h11(id)*100.))*0.5+0.5;\n        \n        \n        \n        if(iMouse.z>0.5){\n        divHash = mix(divHash,M,0.3);\n        }\n        \n\n        vec2 divide = divHash * dim + dMin;\n        \n        //Clamp division line\n        divide = clamp(divide, dMin + MIN_SIZE+0.01, dMax - MIN_SIZE-0.01);\n        \n        \n        //Find the minimum dimension size\n        vec2 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min( minAxis.x, minAxis.y);\n        \n        //if minimum dimension is too small break out\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > MIN_ITERS) { break; }\n        \n        // update the box domain\n        dMax = mix( dMax, divide, step( uv, divide ));\n        dMin = mix( divide, dMin, step( uv, divide ));\n\n        //Deterministic seeding for future divisions \n        diff2 =step( uv, divide)-\n        vec2(h11(diff2.x)*10.,h11(diff2.y)*10.);\n        \n        // id will be used for coloring \n        id = length(diff2)*100.0;\n\n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    \n    //Calculate 2d box sdf\n    vec2 center = (dMin + dMax)/2.0;\n    float a = box(uv-center,dim*0.5);\n    //a = length(uv-center)-min(dim.x,dim.y)*0.5;\n    \n    //Color box\n    id = h11(id)*1000.0;\n    vec3 e = vec3(0.5);\n    vec3 al = pal(fract(id)*0.75+0.8,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n    col = clamp(al,0.,1.);\n    col-=smoothstep(-px,px,a+BORDER_SIZE);\n    //col = vec3(-a*10.0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 147, 147, 218], [219, 219, 240, 240, 292], [293, 306, 373, 373, 412], [413, 413, 439, 439, 489], [490, 490, 547, 547, 3094]], "test": "valid"}
{"id": "stdGzf", "name": "depth of field focus study 4", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 3, "viewed": 156, "published": "Public API", "date": "1636495638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-09 22:06:23\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .3;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    st *= log(length(st * .18));\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 493, 493, 579], [582, 582, 653, 653, 889], [891, 891, 946, 946, 1955]], "test": "valid"}
{"id": "stG3zw", "name": "mat4 Recursion Rainbow", "author": "akohdr", "description": "Apply mat4() and sin() recursively on slowly rotating field constructed with prime factors.\nResulting morphed space creates interesting rainbow effects, the evolving line density/contrast makes for good anti-alias testbed.  Includes four rook & radial AA.", "tags": ["color", "antialiasing"], "likes": 4, "viewed": 57, "published": "Public", "date": "1637628858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// needs gamma correction\n\n#define AA                       // uncomment to turn on anti aliasing\n#define RADIAL_AA\n#define FOUR_ROOK_AA\n\n#define ITS 7                      // iteration count\n#define SPEED 7e-2                 // global speed\n#define ZOOM 100.                  // zoom level\n//#define ORIGIN                   // highlight origin\n//#define DEBUG                    // flash any isnan red\n\n// performs two 2d offset rotations moving field origin in trefoil orbit\n#define ROTATE(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n//#define ROTATE(a) 1.   // no rotation\n//#define ROTATE(a) 2.   // see the bigger picture\n\n#define iR iResolution\n\nvoid calcImage( out vec4 k, in vec2 p )\n{\n    p*=ZOOM;\n\n    float wt = iTime*SPEED;        // wall time\n\n         wt += 2.5;                // starting time offset\n      \n          p *= .05;                // unzoom compensation\n          p -= iR.xy/2.;           // center coords\n          p += vec2(-1e3);         // offset\n          p *= ROTATE(wt);         // outer rotation\n\n     vec2 c  = p-iR.xy/2.;         // centered coords\n          c /= iR.y;               // aspect corrected/scaled\n          c *= ROTATE(-wt*3.);     // inner rotation\n          c += vec2(1);            // movement\n     \n     float t = wt+.2;              // local time\n    \n     vec4  P = vec4(2,3,5,7),      // primes\n          vx =  (P*c.x),           // x space component\n          vy =  (P*c.y);           // y space component\n        \n           k = vec4(0,0,0,1);      // initial condition\n    \n    for(int i=ITS; i>0; i--)      // iterate mat4 pipeline\n    {\n      // main transform\n      mat4 M = mat4(vx,vy,      \n                    t*P,\n                    k*(c.xyyx-1.5));\n                    \n      vec4 l = k;\n      k *= M;\n      k = sin(k/9.);\n      \n      #ifdef DEBUG\n          if(any(isnan(k))) k = l;\n      #endif\n    }\n    \n//    k = vec4(.5/length(k));    // grayscale\n//    k = normalize(k);\n\n    // show origin\n    #ifdef ORIGIN\n        k.g += smoothstep(.1,.0,length(c));\n    #endif\n    \n    // flash any isnan values red\n    #ifdef DEBUG\n       if(any(isnan(k))) k = vec4(mod(iTime,1.),0,0,0);\n    #endif\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n// shader is pretty much torture test for aliasing\n#ifdef AA\n    vec4 s = k = vec4(0);\n    \n#ifdef RADIAL_AA\n    for (float a=6.18; a>0.; a-=1.2){\n        calcImage(s,p+(a/9.)*vec2(cos(a), sin(a)));  \n        k = mix(k,s,.5);\n    }\n#endif\n    \n#ifdef FOUR_ROOK_AA\n    // apply four rook anti-aliasing \n    //   improves but doesn't eliminate issue in high contrast/freq. areas\n    float d1 = .125, d2 = .375;\n    calcImage(s,p+vec2( d1, d2));  k = mix(k,s,.5);\n    calcImage(s,p+vec2( d2,-d1));  k = mix(k,s,.5);\n    calcImage(s,p+vec2(-d2, d1));  k = mix(k,s,.5);\n    calcImage(s,p+vec2(-d1,-d2));  k = mix(k,s,.5);\n#endif\n    \n#else\n    calcImage(k,p);\n#endif\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3zw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[776, 776, 817, 817, 2289], [2291, 2291, 2332, 2383, 2996]], "test": "valid"}
{"id": "stGGDm", "name": "Persian carpet 28", "author": "jarble", "description": "More experiments with fractal carpet designs.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 80, "published": "Public API", "date": "1637795691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5, offset = .5;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale2 = 1.5;\n    float bend = 1.;\n    float scale = c1.z;\n    for(int i=0;i<3;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 9; k++){    \n            uv /= -scale2;\n            t2 = triangle_wave(uv.yx-offset,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = t2/bend+t3*bend;\n            bend *= -1.;\n            bend -= 1./3.-col.x;\n        }\n        //scale /= 1.+(scale2)*col.x/(8.);\n        scale2 -= (col.x-1.)/(4.);\n        col = col.yzx;\n        col[0] = abs((uv.x)-(uv.y));\n    }\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 144, 144, 189], [191, 191, 248, 248, 1053]], "test": "valid"}
{"id": "stGGzh", "name": "Function Graph", "author": "Death_From_Hell", "description": "Function graph", "tags": ["function"], "likes": 2, "viewed": 44, "published": "Public", "date": "1637133337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WIDTH 3.0\n#define FCOLOR vec3(1.0, 0.0, 0.0)\n#define BCOLOR vec3(1.0)\n#define DELTA 0.001\n#define CELL 50.0\n\nfloat func(float x) {\n    return sin(x * 10.0 + iTime * 3.0) / 2.5 + 0.5;\n}\n\nfloat grad(float x) {\n    return (func(x + DELTA) - func(x)) / DELTA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec3 colorCell = vec3(min(mod(fragCoord.x, CELL), mod(fragCoord.y, CELL)));\n    vec3 color = mix(FCOLOR, BCOLOR, smoothstep(0.0, WIDTH / iResolution.y, abs((func(uv.x) - uv.y) / length(vec2(grad(uv.x), 1)))));\n    color = min(colorCell, color);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 138, 138, 192], [194, 194, 215, 215, 265], [267, 267, 324, 324, 653]], "test": "valid"}
{"id": "stGGzK", "name": "TexturedLine", "author": "Del", "description": "A simple line function that also returns UV", "tags": ["line", "texture", "uv", "rect"], "likes": 3, "viewed": 95, "published": "Public API", "date": "1637971635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simple textured line test\n\n// returns distance, u, v\nvec3 TexturedLine( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    vec2 qq = (q)-vec2(l,th)*0.5;\n    q = abs(q)-vec2(l,th)*0.5;\n    float dd =  length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    float u = abs(qq.x)/l;\n    float v = abs(qq.y)/th;\n    return vec3(dd,u,v);\n}\n \nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float size = 0.3+(sin(iTime)*0.25);\n\n    vec2 p1 = vec2(0.0,size)*rotate(iTime);\n    vec2 p2 = vec2(size,0.0)*rotate(iTime);\n    \n    vec3 res = TexturedLine(uv,p1,p2,0.1);\n    \n    \n    float d = step(res.x,0.0);\n    if (iMouse.z>0.5)\n        col = d*texture(iChannel0, -res.yz ).xyz;    \n    else\n        col = d*vec3(res.y,res.z,0.0);\n        \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 56, 120, 120, 440], [443, 443, 465, 465, 532], [538, 538, 595, 595, 1073]], "test": "error"}
{"id": "stK3zy", "name": "Shader Game", "author": "peremoya2000", "description": "Small interactive rytm-like game. GPU-only. Meant to be played on PC. Click inside the circle when the lines and circles intersect with it.", "tags": ["2d", "interactive", "music", "videogame"], "likes": 1, "viewed": 25, "published": "Public", "date": "1638276489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//difficulty(0-1) lower is more difficult\nfloat diff=.4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uv = vec3((fragCoord-.5*iResolution.xy)/iResolution.y,0.f); \n    \n    //Shift center\n    vec2 center = vec2(\n    (sin(iTime*.7+iTime*.0002))*.5*cos(iTime*0.03),\n    (cos(iTime)*(.2+iTime*.0001))*cos(iTime*0.07));\n    uv.xy+=center;\n    uv.z = length(uv);\n    \n    vec2 mousePos = (iMouse.xy-.5*iResolution.xy)/iResolution.y + center; \n    \n    //beat frame\n    vec3 beat = vec3(smoothstep(.08,.11,uv.z)*smoothstep(.11,.1,uv.z));\n    \n    float circles,vbar,hbar;\n    hbar=sin(.23*iTime-uv.x-iTime*.0001);\n    vbar=cos(.33*iTime+uv.y-.7+iTime*.0001);\n    \n    //closing bars\n    beat += vec3(pow(1.f-abs(hbar),27.f));\n    beat += vec3(pow(1.f-abs(vbar),27.f));\n    \n    //closing rings\n    float speed = (1.f+cos(iTime*.6f)*.001f+.5f)+iTime*.0003;\n    circles=sin(speed*iTime+uv.z);\n    beat += vec3(pow(1.f-abs(circles),15.f));    \n    circles=min(abs(circles),min(abs(hbar),abs(vbar)));\n    \n    if (beat.x>1.01f && uv.z<.11){\n        if(iMouse.z>.1 && length(mousePos-uv.xy)<.19){            \n            beat*=vec3(0,1,0);\n            beat*=beat;\n        }else{\n            beat*=vec3(1,0,0);\n        }\n    }\n    if(circles>diff && iMouse.z>.1 && uv.z<.11){            \n        beat*=vec3(1,0,0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(beat,1.0);    \n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stK3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1447]], "test": "valid"}
{"id": "stKGDm", "name": "Glitter ex", "author": "BadBadDog", "description": "Just a simple glitter effect", "tags": ["glitter"], "likes": 1, "viewed": 33, "published": "Public", "date": "1637837592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.0,0.3,0.4) + 0.1*cos(iTime+uv.xyx+vec3(0,1,1));\n    \n    vec4 ns = texture( iChannel0, uv );\n    \n    float gltr1 = fract(iTime/121.0);\n    float gltr2 = fract(iTime/1922.0);\n    float gltr3 = fract(iTime/2363.0);\n    float gltr4 = fract(iTime/3435.0);\n    float glit1 = smoothstep( gltr1-0.001, gltr1, ns.x ) * smoothstep( gltr1+0.001, gltr1, ns.x );\n    float glit2 = smoothstep( gltr2-0.001, gltr2, ns.y ) * smoothstep( gltr2+0.001, gltr2, ns.y );\n    float glit3 = smoothstep( gltr3-0.001, gltr3, ns.z ) * smoothstep( gltr3+0.001, gltr3, ns.z );\n    float glit4 = smoothstep( gltr4-0.001, gltr4, ns.w ) * smoothstep( gltr4+0.001, gltr4, ns.w );\n    \n    col = max( max( max(vec3(glit1),vec3(glit2)), max(vec3(glit1),vec3(glit2)) ), col );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1003]], "test": "error"}
{"id": "stKGDw", "name": "Truchet Ridges 4rd  FORK", "author": "soundmasteraj", "description": "Ridgified, Weird looking shader that uses waves, truchet tiles, and iterations to make this 3D-like effect.\n\nIt may not be the fastest code but hey, it still works.", "tags": ["wave", "truchet", "fork", "depth"], "likes": 1, "viewed": 43, "published": "Public", "date": "1637824307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Truchet Ridges 3rd  FORK\" by soundmasteraj. https://shadertoy.com/view/stV3Ww\n// 2021-11-25 07:04:24\n\n// Fork of \"Truchet Ridges 2nd  FORK\" by soundmasteraj. https://shadertoy.com/view/slK3Ww\n// 2021-11-25 06:53:01\n\n// Fork of \"Truchet Ridges FORK\" by soundmasteraj. https://shadertoy.com/view/flV3Dm\n// 2021-11-25 06:34:55\n\n// Fork of \"Truchet Hills\" by gls9102. https://shadertoy.com/view/wslcz2\n// 2021-11-25 05:14:08\n\n// v1.0.1\n\n#define PI 3.1415\n#define ITERATIONS 25.\n\nfloat ran21(vec2 uv) {\n    return fract(cos(dot(cos(uv.x*uv.y)-32.2,tan(uv.x/uv.y)-23.5)*1322.24)*432122.62);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 uvb = uv;\n\n    vec3 col = vec3(0);\n    \n    \n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n    \n    \n    for(float i=1.;i<=ITERATIONS;i++) {\n        float cur = i/ITERATIONS;\n        uv = uvb;\n        \n        uv *= (ITERATIONS*ITERATIONS/(ITERATIONS+i))-(cur*1.)/(length(uvb/uv));\n        uv.y += iTime*0.6;\n        float halftime = iTime*.3;\n    \n        gv = fract(uv)-.5;\n        id = floor(uv);\n        \n        \n        float mul = mod(id.x+id.y,25./2.)>=1.5 ? -.675 : -ITERATIONS/i;\n            \n            \n        float modval = mod(iTime/1000., mul*PI);\n    \n        gv.x *= (ran21(id)>(.5)) ? -1. - mod(modval+id.y, mod(id.y, uv.x)) * mul - abs(cos( halftime/gv.x - modval/gv.y)* modval) : \n                                    1. + mod(modval-id.y, mod(id.y, uv.x)) * mul - abs(sin( iTime/gv.x + modval/gv.y)* modval);\n        \n        // gv.x *= (ran21(id)>(.5)) ? -1.- abs(sin(iTime+gv.x+modval*PI)*modval) : 1.+ abs(cos(-iTime-gv.x-i*PI)*modval);  \n        \n        vec2 ruv = gv-sign(gv.x+gv.y+.001)*.5;\n        float tile = smoothstep(.01,-.01,abs(length(ruv)-.5)-.1);\n        float rot = atan(ruv.x,ruv.y)/PI;\n    \n\n        float h = smoothstep((ITERATIONS/cur+.1)/gv.x,cur,sin(abs(rot*cur*mul+iTime)*PI)*.25+.75);\n        \n        col.b -= (h*tile*cur)/(h/i);\n        col.b *= .85-((h/i)/(h*tile*cur));\n        col.g *= .95-((col.r + col.g )/(h*i));\n\n        \n        col = max(col,h*tile*cur);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 509, 509, 598], [600, 600, 655, 655, 2196]], "test": "error"}
{"id": "stKGDz", "name": "Weird Tendrils", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 7, "viewed": 157, "published": "Public API", "date": "1637531705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.y += 0.08 * thc(2., 10. * mlength(uv) +\n    + iTime);\n    //uv.y += 0.01 * cos(100. * mlength(uv) + iTime);\n    float r = length(uv);\n    float a = atan(uv.y/uv.x);\n   \n    //uv = fract(uv / r);// + ths(1.,0.5 * iTime);\n   // uv = vec2(cos(0. * r + mlength(uv) + iTime),\n    //          sin(0. * a + mlength(uv) + iTime));\n    uv.x = r; // * 20.;\n    uv.y = a * 10.;\n\n    float time = iTime;\n\n    float sc = 0.5;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = 0.1 * (0.5 + 0.5 * cos(iTime)) + length(fpos);\n    float s = smoothstep(-0.1,0.1,0.5-d) - smoothstep(-0.1,0.1,0.42 - d);\n    s *= (0.5 + 0.5 * cos(uv.x + uv.y - iTime)) * h21(ipos + floor(length(ipos) * 100. + 0.2 * time));\n\n    vec3 col = 2. * s * pal(time + 10. * r + 0.5 * s, vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 212, 212, 255], [257, 257, 277, 277, 352], [354, 354, 378, 378, 418], [440, 440, 497, 497, 1460]], "test": "valid"}
{"id": "stKGzh", "name": "sprixels w improved motion", "author": "jneen", "description": "as seen in maj7 cover ring vol. 2 https://www.youtube.com/watch?v=FiC09s1ut2A\n\nandrew did some post-processing on it to add chromatic aberration and change the hue", "tags": ["sprixel"], "likes": 7, "viewed": 84, "published": "Public", "date": "1637175961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I (1.)\n#define O (0.)\n#define time (iTime*.2)\n\nvec2 uv;\n\nfloat[16] T1 = float[16](\n  I,O,O,O,\n  O,O,O,O,\n  O,O,I,O,\n  O,O,O,O\n);\n\nfloat[16] T2 = float[16](\n  O,O,I,O,\n  O,I,O,O,\n  I,O,O,O,\n  O,I,O,O\n);\n\nfloat[16] T3 = float[16](\n  O,I,I,O,\n  I,O,I,I,\n  O,I,O,I,\n  O,O,I,O\n);\n\nfloat[16] T4 = float[16](\n  I,I,I,I,\n  I,O,I,I,\n  I,I,I,I,\n  I,I,O,I\n);\n\nfloat px(float[16] arr, vec2 p) {\n  p = fract(p);\n  int x = int(p.x*4.);\n  int y = int((1.-p.y)*4.);\n  return arr[4*y+x];\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\n\n#define nsin(x) (.5+.5*sin(x))\n#define pmod(x,j) (mod(x,j)-.5*(j))\n\n#define MISS(x) (x>1000.)\n\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat boxle(vec3 p, float r, float q) {\n  return max(box(p, vec3(r)),-sphere(p,q*r));\n}\n\nfloat S(vec3 p) {\n  float gt = time*2.;\n  gt = (gt +.2*sin(gt))*1.5;\n  //float gtm = pmod(gt, .1);\n  p.xy *= rot(time*2.);\n  //p.yz *= rot(gt*2.);\n  //p+=vec3(.2,.2,2);\n  float rad = fract(gt);\n  float root_id = floor(gt);\n  float S = 1001.;\n  \n  float ft=1.;\n  \n  for (float i=0.;i<=2.;i+=1.){\n    float id = root_id + i;\n    float r=rad+i;\n    p.xz *= rot(r*(.35+.2*sin(gt)));\n    p.xy *= rot(r*.1);\n    p.xy *= rot(r*.05);\n\n    S = min(S, boxle(p, r, 1.+.07*r*r*r));\n  }\n \n\n\n  return S+max(0.,-S)*.2;\n}\n\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for(int i=0;i<50;i++){\n    float c=S(p+d*dir);\n    d+=c;\n    if (c<.1) return d;\n    if (MISS(d)) return d;\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(1e-3);\n  return normalize(S(p)-vec3(S(k[0]), S(k[1]),S(k[2])));\n}\n\nvec3 sat(vec3 p, float amt) {\n    vec3 mid = vec3((p.x+p.y+p.z)/3.);\n    vec3 side = p - mid;\n    \n    return mix(mid, side,amt);\n\n}\n\nfloat light(vec3 o, vec3 dir, float dist) {\n  vec3 hit = o+dir*dist;\n  vec3 n = normal(hit);\n  \n  float diff = dot(dir,-n);\n  \n  return diff;\n}\nvec3 HUE = vec3(0);\n\n\nfloat pxsel(float x, vec2 p) {\n  x *= 3.5;\n  x-=.1;\n  \n  if (x<1.) { HUE=vec3(0, p); return px(T1,p); }\n  if (x<2.) { HUE=vec3(p,0); return px(T2,p); }\n  if (x<3.) { HUE=vec3(p.y,0,p.x);return px(T3,p); }\n  return px(T4,p);\n}\n\n#define tri(x) (2.*abs(.5-fract(x)))\n#define gmix(A,B,Q) (A * pow(B/A, Q))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 C;\n    \n    float t = time;\n    t = tri(.1*t+.3);\n    //t -= nsin(t)*pmod(t, 1./200.);\n    \n    float RES=mix(6., 88., t*t);\n    \n    \n    vec2 px_aln = uv;\n    px_aln *= RES;\n    px_aln = floor(px_aln);\n    px_aln /= RES;\n    \n    vec3 o = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(px_aln,1));\n    \n    float dist = ray(o,dir);\n    float l = light(o,dir,dist);\n\n    if (MISS(dist)) {\n      C=pxsel(nsin(time), (uv+t)*RES)+vec3(1);\n      \n      C/=(RES*.2);\n    }\n    else {\n      float pix = pxsel(light(o,dir,dist),RES*(uv-px_aln));\n      C = vec3(rot(time)*uv+1.,0)*pix;\n      C.g *= .5;\n      C -= HUE;\n\n    }\n    \n    C = C.zxy;\n    //C = sqrt(C);\n    \n    //C = sqrt(C);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(C),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 501, 501, 551], [650, 650, 681, 681, 703], [704, 704, 731, 731, 815], [817, 817, 856, 856, 904], [906, 906, 923, 923, 1411], [1414, 1414, 1443, 1443, 1588], [1590, 1590, 1611, 1611, 1705], [1707, 1707, 1736, 1736, 1839], [1841, 1841, 1884, 1884, 1984], [2007, 2007, 2037, 2037, 2232], [2310, 2310, 2367, 2417, 3265]], "test": "valid"}
{"id": "stKGzy", "name": "Voronoz", "author": "kastorp", "description": "something\nmouse down=donuts, up=cylinders, left=few, right=many", "tags": ["voronoi", "extrusion"], "likes": 26, "viewed": 199, "published": "Public", "date": "1637971287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Voronoz by Kastorp\n//----------------------------\n\nvec3 erot(vec3 p, vec3 ax, float ro) { //@Blackle\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat xt( in vec3 p, in float sdf, in float h ){//@iq\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 hash22(vec2 p) //@Dave_Hoskins \n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voro(vec2 p){\n    float  d=1e5;\n    vec2 s=step(vec2(.5),fract(p));    \n    for(float i=-1.+s.x;i<2.+s.x;i++)for(float j=-1.+s.y;j<2.+s.y;j++) d=min(d,length(fract(p)-vec2(i,j)-.5+ \n        hash22(floor(p)+vec2(i,j) )\n        //mix( hash22(floor(p)+vec2(i,j) ), hash22(.5 +floor(p)+vec2(i,j) ),.5+.5*sin(iTime*.5))\n        ));\n    return d;\n}\n\nfloat kk;\nfloat scene(vec3 p){\n     if(p.z>.65) return (p.z-.6); //+10% framerate\n    float z =.3, h=iMouse.z>0.? .2-iMouse.x/iResolution.x*.1:.1,  d=1e5, s=voro(p.xy/z), tk=iMouse.z>0.?-1.+iMouse.y/iResolution.y*2.:0.;    \n    for( float k = -.5+fract(iTime)*h;k<.5;k+=h) { \n       float d1=  -h*.1*(1.1-tk)+xt(p+vec3(0,0,k*.2), -.0001+abs(s-k-.5)*z ,.5);\n       if(d1<d){kk=k;d=d1;}\n    }\n    return d;\n}\n\nvec3 norm(vec3 p) {//@blackle\n    mat3 k = mat3(p,p,p)-mat3(0.001);    \n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = scene(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(1.,0,3.)+vec3(0,.2,0)*iTime;\n    \n    float yrot =.8;\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 80 && !hit; i++) {\n        float dist =scene(p); \n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (dist>5. ||hit) break;\n    }\n    float k=kk;\n    vec3 n = norm(p);\n    vec3 ld= normalize(vec3(0,1,.5));\n    \n    vec3 base = (.5+sin(vec3(3,2,1)*k*4.)*.5);\n    float diff = pow(dot(n, ld) * .5 + .5,2.0);\n    float ao = getAmbiantOcclusion(p, n, 40.0);\n    float spec= pow(max(dot(-cam, reflect(-ld, n)), 0.0), 32.0);     \n    \n    bool sh =false;\n    if(hit){\n       \n        p+=n*.002;\n        for (int i = 0; i < 50 && !sh; i++) {\n            float dist = scene(p);\n            sh = dist*dist < 1e-6;\n            p+=dist*ld;\n            if (dist>2. ||sh) break;\n        }\n    }\n    vec3 col = (base *diff) * (sh?.4:1.) +(sh?0.:spec) ;\n    col = clamp(col, 0., 1.);\n \n    \n    fragColor = smoothstep(-.02,1.05,sqrt(vec4(col,1))) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 91, 102, 164], [166, 166, 214, 219, 315], [317, 317, 355, 355, 488], [490, 490, 509, 509, 838], [850, 850, 870, 870, 1246], [1248, 1248, 1267, 1277, 1397], [1398, 1408, 1460, 1460, 1723], [1725, 1725, 1782, 1782, 2979]], "test": "valid"}
{"id": "stt3D4", "name": "Modified Mandala", "author": "taellinglin", "description": "Modified from another shader slightly. I am also trying to make it render the black pixels as transparent.", "tags": ["modified"], "likes": 9, "viewed": 159, "published": "Public API", "date": "1636142377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define TAU 2.0*PI\n\n\nvoid amod(inout vec2 p, float c) {\n    float m = TAU / c;\n    float a = mod(atan(p.x, p.y)-m*.5, m) - m*.5;\n    p = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p = abs(p) - d;\n    if(p.y>p.x)p=p.yx;\n}\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smooth_stairs(float x) {\n    return tanh(5.*(x-floor(x)-0.5))/tanh(2.5)*0.5+floor(x)+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    uv.y = abs(uv.y);\n    \n    uv *= 3.0;\n    //amod(uv, 5.5+sin(iTime*0.2)*2.5);\n    float nrays = abs(mod(iTime*0.3, 10.)-5.);\n    amod(uv, 8.-smooth_stairs(nrays));\n    \n    mo(uv, vec2(1.2+sin(iTime*0.3), 0.6+sin(iTime*0.5)*0.3));\n    uv *= r2d(PI/12.-PI/8.*mod(iTime*0.2, 16.));\n    mo(uv, vec2(1.1+sin(iTime*0.5)*0.7, 0.4+0.5*1.5));\n    uv *= r2d(PI/6.-mod(iTime*0.25, 12.0)*PI/6.0);\n    mo(uv, vec2(.7+sin(iTime*0.45)*0.2, .2));\n    \n    //uv *= 10.;\n    uv *= 30.;\n    //float l = min(abs(uv.x), abs(uv.y));\n    //float l = max(abs(uv.x), abs(uv.y));\n    float l = abs(uv.x) + abs(uv.y);\n    float d = sin(l) - .3;\n    \n    d = smoothstep(0., fwidth(d), d);\n    fragColor = vec4(sqrt(d),sqrt(d),sqrt(d),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 75, 75, 192], [194, 194, 225, 225, 270], [272, 272, 291, 291, 357], [359, 359, 389, 389, 456], [458, 458, 515, 515, 1344]], "test": "valid"}
{"id": "stt3Dj", "name": "Persian carpet 22", "author": "jarble", "description": "What kind of sorcery is this?\nThese patterns are generated by a simple fractal formula.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 101, "published": "Public API", "date": "1636769414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/4.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 6; k++){       \n                uv /= scale2;\n                //float bend = abs(fract((uv.x/3.))-.5)/3.+1.;\n                //float bend = 1.+random3[k%3];\n                //float bend = 1.+1./3.;\n                float bend = 1.;\n                uv.yx = -triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                uv += vec2(random1[k%3],random2[k%3]);                \n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = abs(col[c] - abs((uv.x)-(uv.y)));\n            col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2206]], "test": "valid"}
{"id": "stt3Dr", "name": "Multiscale Truchet Tiles", "author": "byt3_m3chanic", "description": "Multiscale Truchet built off the quadtree shaders I've previously been working on - with help from @Shane's Quadtree Truchet example. https://www.shadertoy.com/view/4t3BW4", "tags": ["truchet", "tile", "multiscale", "quadtree"], "likes": 23, "viewed": 243, "published": "Public API", "date": "1636242260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    MultiScale Truchet [learning]\n    11/6/21 @byt3_m3chanic\n\n    https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n    \n    My original attempt at this >> https://www.shadertoy.com/view/fl33zn \n\n    I had some gaps I couldn't figure out so I turned to @Shane's example \n    to understand how to create layered trickery required for this. \n    \n    @Shane >> Quadtree Truchet ::  https://www.shadertoy.com/view/4t3BW4\n\n    As the pattern scales down the colors alternate, add in that each \n    tile can have \"wings\" that overlap to create the solid positive\n    and negative spaces around the scaling neighbors.\n    \n    I added an extra depth dimension to the quadtree and figured out\n    how to layer that in (i think?). I kept the patterns mostly simple\n    just to figure things out.\n\n    You should also look at this to get an idea of quadtrees in general.\n    @Shane >> Random Quadtree  ::  https://www.shadertoy.com/view/llcBD7\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(57, 27)));\n    return fract(vec2(262144, 32768)*n);\n}\n\nfloat bkptrn(vec2 p, float res) {\n    p *= res/10.;\n    vec2 id = floor(p*.5)-.5;\n    float hatch = clamp(sin((p.x - p.y)*PI*3.)*3. + 0.25, 0., 1.);\n    return clamp(hatch,.3,.7);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 suv = uv;\n\n    uv += T*.040; \n\n    // change scale if window is bigger?\n    // for pattern things you can get a\n    // better - detailed view\n    vec2 vuv= R.x>1000.?uv*4.:R.x>800.?uv*6.:uv*2.;\n  \n    float px = fwidth(vuv.x*2.);\n\n    // threshold values\n    const vec2 rndX[4]=vec2[4]( vec2(.5, .25), vec2(.5, .25), vec2(.5, .75), vec2(.5, 1));\n    // Distance field values.\n    vec4 d=vec4(1e5), d2=vec4(1e5), d3=vec4(1e5);\n    float level=1.;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // Comments are reduced to the main points I wanted to\n    // remember - please see his shader for full comments and\n    // explanations https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n    \n        vec2 id = floor(vuv*level);\n\n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n\n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 rnd = hash22(id+neighbors);\n                \n                // tiles need to be laid down from largest to smallest. \n                // If a large tile has taken up the space, you need to\n                // check on the next iterations and skip.\n                \n                vec2 rnd2 = hash22(floor((id+neighbors)/2.));\n                vec2 rnd4 = hash22(floor((id+neighbors)/4.));\n                vec2 rnd8 = hash22(floor((id+neighbors)/8.));\n                \n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rnd2.y<rndX[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rnd2.y<rndX[1].y || rnd4.y<rndX[0].y)) continue;\n                // If any of the three previous larger tiles have been rendered, continue.\n                if(k==3 && (rnd2.y<rndX[2].y || rnd4.y<rndX[1].y  || rnd8.y<rndX[0].y )) continue;\n\n                // threshold\n                if(rnd.y<rndX[k].y) {\n\n                    vec2 p = vuv -(id+.5+neighbors)/level;\n                   \n                    // square to mask off tiles.\n                    float square = max(abs(p.x), abs(p.y)) - .5/level;\n\n                    // TILE COLOR ONE.\n                    // Standard Truchet rotation and flipping.\n                    if(rnd.x<rndX[k].x) p.xy = p.yx;\n                    if(fract(rnd.x*57.5 + .35)<rndX[k].x) p.x = -p.x;\n                    \n                    // Four circles on the midway points of the grid boundary\n                    vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - vec2(.5, .5)*.7071/level;\n                    float c3 = length(p2) - .5/3./level;\n  \n                    // Truchet arc one.\n                    float c = abs(length(p - vec2(-.5, .5)/level) - .5/level) - .5/3./level;\n                    float c2 = abs(length(p - vec2(.5, -.5)/level) - .5/level) - .5/3./level;\n          \n                    // Line variant @Shane\n                    if(fract(rnd.x*113.467 + .51)<.15) c = abs(p.x) - .5/3./level;\n                    if(fract(rnd.x*123.853 + .49)<.15) c2 = abs(p.y) - .5/3./level;\n\n                    float truchet = min(c, c2);\n\n                    c = min(c3, max(square, truchet));\n                    // Tile color one.\n                    d[k] = min(d[k], c);\n                    // for extra decoration\n                    d3[k] = min(d3[k], c);\n\n                    // TILE COLOR TWO.\n                    p = abs(p) - .5/level;\n                    float l = length(p);\n                    \n                    // Four circles at the grid vertices and the square.\n                    c = min(l - 1./3./level, square);\n                    //c = max(c, -truchet);\n                    //c = max(c, -c3);\n                    \n                    // Tile color two.\n                    d2[k] = min(d2[k], c); \n\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    // layerd mixdown as each iteration is stored in xyzw\n    d.x = max(d2.x, -d.x);\n\n    float dz = abs(abs(abs(min(d3.w,d3.z))-.05)-.02)-.01;\n    d.x = min(max(d.x, -d2.y),  d.y);\n    d.x = max(min(d.x,  d2.z), -d.z);\n    d.x = min(max(d.x, -d2.w),  d.w);\n    // reuse of d.w - making border\n    d.w=abs(d.x)-.0025;\n\n    float dm = smoothstep(px, -px,d.x);\n    float dn = smoothstep(-px, px,d.x);\n    dz = smoothstep(px, -px, abs(dz)-.0025);\n\n    float ptrn = max(dn,bkptrn(vuv,125.));\n    vec3 C = mix(vec3(.045),vec3(.6),clamp((suv.y+.25)*.5,0.,1.))*ptrn;\n    \n    // color gradient \n    vec3 clrA = mix(vec3(0.902,0.380,0.098),vec3(0.137,0.580,0.804),clamp((suv.y+.45)*1.25,0.,1.));\n    vec3 clrB = vec3(0.706,0.659,0.941);\n    vec3 clrC = vec3(0.031,0.541,0.608);\n\n    // extra decoration\n    C = mix(C, clrA, clamp(dz-dm,0.,1.));\n    C = mix(C, clrC, smoothstep(px, -px, abs(d.y+.075)-.002));\n    // background\n    C = mix(C, C*clrA, smoothstep(.05+px, -px, d.x));\n    // outlines\n    C = mix(C, clrB, smoothstep(px, -px, d.w));\n\n    // Gamma and output\n    C = pow(C, vec3(.4545));        \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Dr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1203, 1203, 1223, 1223, 1268], [1269, 1269, 1290, 1290, 1345], [1347, 1367, 1388, 1736, 1820], [1822, 1822, 1855, 1855, 2003], [2005, 2005, 2046, 2046, 7140]], "test": "valid"}
{"id": "stt3Wr", "name": "Angular Capsules Lit", "author": "spalmer", "description": "simple lit capsules rendered using cross product haxx without any ray marching or equation root solving.\nw blending, fake depth of field, phong specular", "tags": ["lighting", "shading", "blend", "normal", "perspective", "cross", "capsule"], "likes": 6, "viewed": 60, "published": "Public", "date": "1636029903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fork of Angular Lighting 2 https://shadertoy.com/view/Nlc3z7\n// fork of AngularSeg https://shadertoy.com/view/ssyXzy\n\n// obtains view space normal estimate from cross product.\n// no actual marching or root solving!\n// lighting is imperfect but fast.\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy; float ry = min(r.x, r.y);\n    vec3 d = normalize(vec3((.5*r - p) / ry, -1)), n = -.1*d;\n    float N = 18., poof = .5, cov = .0, z = 9e9, ci = 0.; \n    for (float i = 1.; i > 1./N; i -= 2./N) { // brute force example toy\n        // points in view coordinates, skipping transformation\n        // animate point pos relative eye\n      #define P(t) vec3(0,0,-9) + 15.*poof/N * sin(vec3(9,8,7) * ((t) + .2* iTime)) + 3.*sin(vec3(0,11,7) + .12*iTime + vec3(3,4,5) * .08*iTime + 6.28*(t))\n        vec3 a = P(i), b = P(i - 1./N)\n        , dXa = cross(d, a), dXb = cross(d, b);\n        vec3 m = dXb - dXa;\n        // when the lighting looks wrong, this is why:\n        a = mix(b, a, clamp(dot(dXb, m) / dot(m, m), 0., 1.)); // now \"closest\" point on seg\n        // FIXME surely there's some redundancy in here that could be exploited\n        vec3 v = cross(d, a);\n        float aa = dot(a, a) // squared distance to point\n        , vv = dot(v, v);\n    //    if (dot(a, d) > 0.) // only if not behind camera! not needed here.. they never go behind camera\n        if (vv < poof*poof) { // only if hit something!\n            // FIXME too many sqrt!\n            float vl = sqrt(vv)\n            , ve = vl - poof\n            , al = sqrt(aa);\n            vec3 n3 = v / poof;\n            n3.xy = -n3.yx * vec2(-1,1); // un-cross-ify HACK only works in view space?\n            n3.z = sqrt(max(0., 1. - dot(n3.xy, n3.xy))); // compute normal\n            float z2 = al - n3.z * poof\n            , focpl = 10.\n            , defocus = min(1., abs(al - focpl) * .05)\n            , c2 = min(1., -ve * r.y / al // antialias edge coverage\n                / (1. + defocus * ry/35.) // \"depth of field\" blur\n                );\n            if (z2 < z) { // nearer? blend over bg\n                ci = i;\n                z = z2;                \n                n = mix(n, n3, c2);\n            } else { // blend behind fg\n                c2 = max(0., c2);                \n                n = mix(n, n3, (1.-cov) * c2);\n            }\n            cov = mix(cov, 1., c2);\n        }\n    }\n    n = normalize(n);\n    vec3 cp = z * d;\n    vec3 lp = vec3(0,2.*sin(.5*iTime),-9), l = normalize(lp - cp); //vec3 l = normalize(vec3(.6,.5,.7)); // point or directional light?\n    // could do shadows but would require iterating over the segments again!  should refactor\n    float nl = max(.04, dot(n,l)) // diffuse lighting\n    , spec = dot(l, reflect(d, n)) // phong specular lighting\n    , sexp = 32.;\n    spec = pow(max(spec, 0.), sexp) * (sexp / 8. / acos(-1.) + 1.) * nl; // simple phong specular / 8pi\n    vec3 c = vec3(nl * cov);\n    //c *= mix(vec3(1), n * .5 + .5, cos(.2*iTime)*cos(.2*iTime)); // show normals sometimes\n    // for it to blur correctly, would need to colorize inside the loop, probably lighting also\n    c *= max(cos(ci * 2. * 6.2 - vec3(0,2,4)), 0.); // colorize by capsule index\n    c += spec * cov;\n    vec3 lx = cross(d, lp); float ll = dot(lx, lx); // view ray vs. light \n    float cl = 1.2 * exp2(-6. * ll);  // halo shows light position\n    if (dot(lp, lp) > z*z) // not integrated properly so clips geo\n        cl *= 1.-cov;\n    c += cl;\n    o = vec4(pow(c, vec3(.45)), 1); // gamma\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 290, 290, 3493]], "test": "valid"}
{"id": "stt3z8", "name": "MarksExperiment001", "author": "Mr_Steve", "description": "playing with various shapes and animation", "tags": ["noob"], "likes": 1, "viewed": 35, "published": "Public", "date": "1635817824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// this work after shadertoy Lesson 4 by Martijn Steinrucken \n// and some Book of Shader, Lewis Lepton\n// and Bruno Simon's threejsjourney course\n\n// Band and Rect make a rectangle\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    float band1 = Band(uv.x,left,right,blur);\n    float band2 = Band(uv.y,bottom,top,blur);\n    \n    return band1*band2;\n}\n// make a circle\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r,r-blur,d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // set up color\n    vec3 col = vec3(.8);\n    \n    // x and y coords\n    float x = uv.x;\n    float y = uv.y;\n    \n    // rectangles\n    float rect01 = Rect(vec2(x,y),-.8,-.6,-.45,.45,.001);  \n    col -= vec3(.2,.8,.9)*rect01;\n    \n    float rect02 = Rect(vec2(x,y),-.75,-.65,.35,.4,.001);\n    col += vec3(0.,.9,.8)*rect02;\n    \n    x += y*.2-0.05;\n    float rect03 = Rect(vec2(x,y),-.75,-.65,.15,.3,.001);\n    col += vec3(.7,.9,.8)*rect03;\n    \n    float circle01 = Circle(vec2(x,y),vec2(-.75,-.375),.1,.001);\n    col += vec3(.9,.2,.2)*circle01;\n    \n    x = uv.x;\n    float rect04 = Rect(vec2(x,y),-.5,-.4,-.25,.45,.001);  \n    col -= vec3(.9,.4,.3)*rect04;\n    \n    for(int i = 0; i < 3;i++){\n        float circle01 = Circle(vec2(x,y),vec2(-.45,float(i)*.15),.035,.001);\n        col += circle01;\n    }\n    \n    float top = sin(x*iTime*1.1)-.625*(cos(x*5.)-.25);\n    float rect05 = Rect(vec2(x,y),-.3+y*.2,.75-y*.2,-.45,top,.001);  \n    col -= vec3(1.,.2,.2)*rect05;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 181, 237, 237, 378], [380, 380, 462, 462, 585], [586, 603, 654, 654, 736], [738, 738, 795, 812, 1921]], "test": "valid"}
{"id": "stt3zs", "name": "Night or Day", "author": "Mr_Steve", "description": "experiment with inspirinathan tutorial", "tags": ["basic"], "likes": 1, "viewed": 34, "published": "Public", "date": "1636831750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getBackgroundColor(vec2 uv) {\n    uv += 0.5; // remap uv from <-0.5,0.5> to <0,1>\n    vec3 gradientStartColor = vec3(1., 0., 1.);\n    vec3 gradientEndColor = vec3(0., 1., 1.);\n    return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset, float yOsc) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  \n  //x += sin(iTime*3.)*.03;\n  y += sin(iTime*yOsc)*.1;\n  \n  return length(vec2(x, y)) - r;\n}\n\nfloat opRepLim(vec2 p, float r, float c, vec2 l, float yOsc)\n{\n  vec2 q = p-c*clamp(round(p/c),-l,l);\n  return sdCircle(q, r, vec2(0),yOsc);\n}\n\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float circle = opRepLim(uv,.075,.2,vec2(7., 3.),1.);\n  float circle2 = opRepLim(uv+.15,.05,.2,vec2(7., 3.),1.9);\n  float circle3 = opRepLim(uv-.15,.05,.2,vec2(7., 3.),1.5);\n\n  \n  col = mix(vec3(1.,0.,.25),col,step(0.,circle));\n  col = mix(vec3(0.,.2,.8),col,step(0.,circle2));\n  col = mix(vec3(8.,.7,0.),col,step(0.,circle3));\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = drawScene(uv);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 278], [280, 280, 339, 339, 493], [495, 495, 557, 557, 637], [640, 640, 665, 665, 1050], [1053, 1053, 1110, 1110, 1269]], "test": "valid"}
{"id": "sttGWf", "name": "TimelordQ's Inside the Matrix", "author": "TimelordQ", "description": "TimelordQ's Matrix Rain v1.0\t\n\nI Loved the original shader so much (branched Inside the Matrix (https://www.shadertoy.com/view/4t3BWl)) But in converting it to Unity cG/HLSL, I needed a more simplistic version. \n\nThis is the result. ", "tags": ["green", "rain", "code", "digital", "matrix", "runes"], "likes": 16, "viewed": 251, "published": "Public", "date": "1636880387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Loved the original shader so much \n//     (Inside the Matrix (https://www.shadertoy.com/view/4t3BWl))\n// But in converting it to Unity cG/HLSL, I needed a more simplistic version\n// that didn't move or respond to mouse events, so I stripped all that out. \n// What's resulting here is the base unmoving Matrix view, which was\n// then converted to a Unity ready shader (available freely, below)\n// https://github.com/universalbri/MyUnityShaders/blob/main/MatrixRainV2.shader\n// Thanks to the original designer, your code absolutely rocked!\n\nconst int ITERATIONS = 40;   //use less value if you need more performance\nconst float SPEED = 1.;\n\nconst float STRIP_CHARS_MIN =  3.;\nconst float STRIP_CHARS_MAX = 40.;\nconst float STRIP_CHAR_HEIGHT = 0.15;\nconst float STRIP_CHAR_WIDTH = 0.10;\nconst float ZCELL_SIZE = 1. * (STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX);  //the multiplier can't be less than 1.\nconst float XYCELL_SIZE = 12. * STRIP_CHAR_WIDTH;  //the multiplier can't be less than 1.\nconst int BLOCK_SIZE = 8;  //in cells\nconst int BLOCK_GAP = 0;    //in cells\n\nconst float PI = 3.14159265359;\n\nfloat hash(float v) {\n    return fract(sin(v)*43758.5453123);\n}\n\nfloat hash(vec2 v) {\n    return hash(dot(v, vec2(5.3983, 5.4427)));\n}\n\nvec2 hash2(vec2 v)\n{\n    //v = vec2(v * mat2(127.1, 311.7,  269.5, 183.3));\n\treturn fract(sin(v)*43758.5453123);\n}\n\nvec4 hash4(vec2 v)\n{\n    vec4 p = vec4(v * mat4x2( 127.1, 311.7,\n                              269.5, 183.3,\n                              113.5, 271.9,\n                              246.1, 124.6 ));\n    return fract(sin(p)*43758.5453123);\n}\n\nvec4 hash4(vec3 v)\n{\n    vec4 p = vec4(v * mat4x3( 127.1, 311.7, 74.7,\n                              269.5, 183.3, 246.1,\n                              113.5, 271.9, 124.6,\n                              271.9, 269.5, 311.7 ) );\n    return fract(sin(p)*43758.5453123);\n}\n\n\nfloat rune_line(vec2 p, vec2 a, vec2 b)\n{\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\nfloat rune(vec2 U, vec2 seed, float highlight)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = hash4(seed);\n\t\tseed += 1.;\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\n\n\t\tif (pos.xy != pos.zw)  //filter out single points (when start and end are the same)\n\t\t    d = min(d, rune_line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n\treturn smoothstep(0.1, 0., d) + highlight*smoothstep(0.4, 0., d);\n}\n\nfloat random_char(vec2 outer, vec2 inner, float highlight) {\n    vec2 seed = vec2(dot(outer, vec2(269.5, 183.3)), dot(outer, vec2(113.5, 271.9)));\n    return rune(inner, seed, highlight);\n}\n\n\nvec3 rain(vec3 ro3, vec3 rd3, float time) {\n    vec4 result = vec4(0.);\n\n    // normalized 2d projection\n    vec2 ro2 = normalize(ro3.xy);\n    vec2 rd2 = normalize(rd3.xy);\n\n    // we use formulas `ro3 + rd3 * t3` and `ro2 + rd2 * t2`, `t3_to_t2` is a multiplier to convert t3 to t2\n    bool prefer_dx = abs(rd2.x) > abs(rd2.y);\n    float t3_to_t2 = prefer_dx ? rd3.x / rd2.x : rd3.y / rd2.y;\n\n    // at first, horizontal space (xy) is divided into cells (which are columns in 3D)\n    // then each xy-cell is divided into vertical cells (along z) - each of these cells contains one raindrop\n\n    ivec3 cell_side = ivec3(step(0., rd3));      //for positive rd.x use cell side with higher x (1) as the next side, for negative - with lower x (0), the same for y and z\n    ivec3 cell_shift = ivec3(sign(rd3));         //shift to move to the next cell\n\n    //  move through xy-cells in the ray direction\n    float t2 = 0.;  // the ray formula is: ro2 + rd2 * t2, where t2 is positive as the ray has a direction.\n    ivec2 next_cell = ivec2(floor(ro2/XYCELL_SIZE));  //first cell index where ray origin is located\n    for (int i=0; i<ITERATIONS; i++) {\n        ivec2 cell = next_cell;  //save cell value before changing\n        float t2s = t2;          //and t\n\n        //  find the intersection with the nearest side of the current xy-cell (since we know the direction, we only need to check one vertical side and one horizontal side)\n        vec2 side = vec2(next_cell + cell_side.xy) * XYCELL_SIZE;  //side.x is x coord of the y-axis side, side.y - y of the x-axis side\n        vec2 t2_side = (side - ro2) / rd2;  // t2_side.x and t2_side.y are two candidates for the next value of t2, we need the nearest\n        if (t2_side.x < t2_side.y) {\n            t2 = t2_side.x;\n            next_cell.x += cell_shift.x;  //cross through the y-axis side\n        } else {\n            t2 = t2_side.y;\n            next_cell.y += cell_shift.y;  //cross through the x-axis side\n        }\n        //now t2 is the value of the end point in the current cell (and the same point is the start value in the next cell)\n\n        //  gap cells\n        vec2 cell_in_block = fract(vec2(cell) / float(BLOCK_SIZE));\n        float gap = float(BLOCK_GAP) / float(BLOCK_SIZE);\n        if (cell_in_block.x < gap || cell_in_block.y < gap || (cell_in_block.x < (gap+0.1) && cell_in_block.y < (gap+0.1))) {\n            continue;\n        }\n\n        //  return to 3d - we have start and end points of the ray segment inside the column (t3s and t3e)\n        float t3s = t2s / t3_to_t2;\n\n        //  move through z-cells of the current column in the ray direction (don't need much to check, two nearest cells are enough)\n        float pos_z = ro3.z + rd3.z * t3s;\n        float xycell_hash = hash(vec2(cell));\n        float z_shift = xycell_hash*11. - time * (0.5 + xycell_hash * 1.0 + xycell_hash * xycell_hash * 1.0 + pow(xycell_hash, 16.) * 3.0);  //a different z shift for each xy column\n        float char_z_shift = floor(z_shift / STRIP_CHAR_HEIGHT);\n        z_shift = char_z_shift * STRIP_CHAR_HEIGHT;\n        int zcell = int(floor((pos_z - z_shift)/ZCELL_SIZE));  //z-cell index\n        for (int j=0; j<2; j++) {  //2 iterations is enough if camera doesn't look much up or down\n            //  calcaulate coordinates of the target (raindrop)\n            vec4 cell_hash = hash4(vec3(ivec3(cell, zcell)));\n            vec4 cell_hash2 = fract(cell_hash * vec4(127.1, 311.7, 271.9, 124.6));\n\n            float chars_count = cell_hash.w * (STRIP_CHARS_MAX - STRIP_CHARS_MIN) + STRIP_CHARS_MIN;\n            float target_length = chars_count * STRIP_CHAR_HEIGHT;\n            float target_rad = STRIP_CHAR_WIDTH / 2.;\n            float target_z = (float(zcell)*ZCELL_SIZE + z_shift) + cell_hash.z * (ZCELL_SIZE - target_length);\n            vec2 target = vec2(cell) * XYCELL_SIZE + target_rad + cell_hash.xy * (XYCELL_SIZE - target_rad*2.);\n\n            //  We have a line segment (t0,t). Now calculate the distance between line segment and cell target (it's easier in 2d)\n            vec2 s = target - ro2;\n            float tmin = dot(s, rd2);  //tmin - point with minimal distance to target\n            if (tmin >= t2s && tmin <= t2) {\n                float u = s.x * rd2.y - s.y * rd2.x;  //horizontal coord in the matrix strip\n                if (abs(u) < target_rad) {\n                    u = (u/target_rad + 1.) / 2.;\n                    float z = ro3.z + rd3.z * tmin/t3_to_t2;\n                    float v = (z - target_z) / target_length;  //vertical coord in the matrix strip\n                    if (v >= 0.0 && v < 1.0) {\n                        float c = floor(v * chars_count);  //symbol index relative to the start of the strip, with addition of char_z_shift it becomes an index relative to the whole cell\n                        float q = fract(v * chars_count);\n                        vec2 char_hash = hash2(vec2(c+char_z_shift, cell_hash2.x));\n                        if (char_hash.x >= 0.1 || c == 0.) {  //10% of missed symbols\n                            float time_factor = floor(c == 0. ? time*5.0 :  //first symbol is changed fast\n                                    time*(1.0*cell_hash2.z +   //strips are changed sometime with different speed\n                                            cell_hash2.w*cell_hash2.w*4.*pow(char_hash.y, 4.)));  //some symbols in some strips are changed relatively often\n                            float a = random_char(vec2(char_hash.x, time_factor), vec2(u,q), max(1., 3. - c/2.)*0.2);  //alpha\n                            a *= clamp((chars_count - 0.5 - c) / 2., 0., 1.);  //tail fade\n                            if (a > 0.) {\n                                float attenuation = 1. + pow(0.06*tmin/t3_to_t2, 2.);\n                                vec3 col = (c == 0. ? vec3(0.67, 1.0, 0.82) : vec3(0.25, 0.80, 0.40)) / attenuation;\n                                float a1 = result.a;\n                                result.a = a1 + (1. - a1) * a;\n                                result.xyz = (result.xyz * a1 + col * (1. - a1) * a) / result.a;\n                                if (result.a > 0.98)  return result.xyz;\n                            }\n                        }\n                    }\n                }\n            }\n            // not found in this cell - go to next vertical cell\n            zcell += cell_shift.z;\n        }\n        // go to next horizontal cell\n    }\n\n    return result.xyz * result.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (STRIP_CHAR_WIDTH > XYCELL_SIZE || STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX > ZCELL_SIZE) {\n        // error\n        fragColor = vec4(1., 0., 0., 1.);\n        return;\n    }\n\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    float time = iTime * SPEED;\n\n    float level1_size = float(BLOCK_SIZE) * XYCELL_SIZE;\n    float level2_size = 4. * level1_size;\n    float gap_size = float(BLOCK_GAP) * XYCELL_SIZE;\n\n    vec3 ro = vec3(gap_size/2., gap_size/2., 0.);\n    vec3 rd = vec3(uv.x, 2.0, uv.y);\n    vec2 p;\n    ro.xy += level1_size * p;\n\n    ro += rd * 0.2;\n    rd = normalize(rd);\n\n    vec3 col = rain(ro, rd, time);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1097, 1097, 1118, 1118, 1160], [1162, 1162, 1182, 1182, 1231], [1233, 1233, 1253, 1308, 1347], [1349, 1349, 1369, 1369, 1590], [1592, 1592, 1612, 1612, 1861], [1864, 1864, 1905, 1905, 2070], [2072, 2072, 2120, 2120, 2760], [2762, 2762, 2822, 2822, 2951], [9391, 9391, 9448, 9448, 10119]], "test": "valid"}
{"id": "sttGWn", "name": "Eyelord", "author": "nrosquist", "description": "Something", "tags": ["moire"], "likes": 1, "viewed": 98, "published": "Public API", "date": "1636010012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n//    float d = pow(uv.x,.2) + pow(uv.y,2.) - mod(iTime,4.)/8.0;\n    float d = (length(uv))-.8;\n    d = smoothstep(.13,.3+sin(iTime)*col.z,cos(mod(iTime/20.,d))-col.y);\n    // Output to screen\n    fragColor = vec4(vec3(d,col.y, col.z),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 534]], "test": "valid"}
{"id": "stVGDh", "name": "eindacor_dynamic_plaid", "author": "Eindacor_DS", "description": "it's fancy plaid, you dolt!", "tags": ["plaid"], "likes": 1, "viewed": 57, "published": "Public API", "date": "1637637825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.1415926\n#define ANTI_ALIAS .005\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat getNormalizedNonPeriodic(float seed) {\n    return (sin(2. * seed) + sin(PI * seed)+ 2.) / 4.;\n}\n\nfloat getNonPeriodic(float seed) {\n    return sin(2. * seed) + sin(PI * seed);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec4 getColorBlend(float timeScale, vec2 uv, float xHash, float xHashAA, float yHash, float yHashAA, float xBlend, float yBlend) {\n    vec2 xyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n    \n    vec2 xySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xyColor = xyFirst * xySecond;\n        \n    vec2 xAyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAyColor = xAyFirst * xAySecond;\n        \n    vec2 xyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n    vec2 xyAColor = xyAFirst * xyASecond;\n        \n    vec2 xAyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xAyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n      \n    vec2 xAyAColor = xAyAFirst * xAyASecond;\n\n    vec2 xLower = mix(xAyAColor, xyAColor, xBlend);\n    vec2 xUpper = mix(xAyColor, xyColor, xBlend);\n    \n    vec2 finalBlend = mix(xLower, xUpper, yBlend);\n    \n    return vec4(finalBlend.x, finalBlend.y, getNormalizedNonPeriodic(iTime * timeScale + 200.), 1.);\n}\n\nvec4 getBWBlend(float timeScale, vec2 uv, float xHash, float xHashAA, float yHash, float yHashAA, float xBlend, float yBlend) {\n    vec2 xyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n    \n    vec2 xySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xyColor = xyFirst * xySecond;\n        \n    vec2 xAyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAyColor = xAyFirst * xAySecond;\n        \n    vec2 xyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n    vec2 xyAColor = xyAFirst * xyASecond;\n        \n    vec2 xAyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xAyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n      \n    vec2 xAyAColor = xAyAFirst * xAyASecond;\n\n    vec2 xLower = mix(xAyAColor, xyAColor, xBlend);\n    vec2 xUpper = mix(xAyColor, xyColor, xBlend);\n    \n    vec2 finalBlend = mix(xLower, xUpper, yBlend);\n    \n    vec4 blended = vec4(finalBlend.x, finalBlend.y, getNormalizedNonPeriodic(iTime * timeScale + 200.), 1.);\n    return vec4(vec3(blended.x * blended.y), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    mat2x2 rotationMatrix = createRotationMatrix(PI / 4.);\n    \n    uv.y += getNonPeriodic(iTime * .1 + uv.x) * .1 + 100.;\n    uv = uv * rotationMatrix;\n       \n    float gridSize = .01;\n\n    float xFloor = floor(uv.x / gridSize);\n    float xHash = hash(vec2(xFloor));\n    float xHashAA = hash(vec2(xFloor - 1.));\n    float xBlend = smoothstep(0., ANTI_ALIAS / gridSize, fract(uv.x / gridSize));\n    \n    float yFloor = floor(uv.y / gridSize);\n    float yHash = hash(vec2(yFloor));\n    float yHashAA = hash(vec2(yFloor - 1.));\n    float yBlend = smoothstep(0., ANTI_ALIAS / gridSize, fract(uv.y / gridSize));\n    \n    float timeScale = .15;\n    \n    fragColor = getColorBlend(timeScale, uv, xHash, xHashAA, yHash, yHashAA, xBlend, yBlend);\n    \n    vec2 trueUv = fragCoord/iResolution.xy;\n    if (iMouse.z > 1.) {\n    \n        float cursorDist = distance(vec2(trueUv.x * aspectRatio, trueUv.y), vec2(iMouse.x / iResolution.x * aspectRatio, iMouse.y / iResolution.y));\n        \n        float spotlightRadius = .4;\n        float spotlightFade = spotlightRadius * .5;\n        float cursorVal = smoothstep(spotlightRadius - spotlightFade, spotlightRadius + spotlightFade, cursorDist);\n             \n        vec4 spotlightColor = getBWBlend(timeScale, uv, xHash, xHashAA, yHash, yHashAA, xBlend, yBlend) * vec4(1.0, 0.5, 0., 1.);\n    \n        fragColor = mix(spotlightColor, fragColor, cursorVal * cursorVal);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 94, 114, 114, 180], [182, 182, 226, 226, 283], [285, 285, 319, 319, 365], [367, 367, 412, 412, 516], [518, 518, 648, 648, 2909], [2911, 2911, 3038, 3038, 5357], [5359, 5359, 5416, 5416, 6964]], "test": "valid"}
{"id": "stVGzD", "name": "Riemann sphere projection", "author": "TotallyReal", "description": "Simulates the projection from the Riemann sphere to the plane.\nIf P is any point on the sphere other than the north pole Q, then there is a line going through P and Q intersects the plane at a unique point T(P), and the projection is P->T(P).", "tags": ["projection", "riemannsphere"], "likes": 8, "viewed": 113, "published": "Public", "date": "1637498914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// some color constants\nconst vec3 RED = vec3(1.,0.,0.);\nconst vec3 GREEN = vec3(0.,1.,0.);\nconst vec3 BLUE = vec3(0.,0.,1.);\nconst vec3 YELLOW = vec3(1.,1.,0.);\nconst vec3 GRAY = vec3(0.8);\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\n\n// --------------------------- drawing on the plane ---------------------------\n\n// To change what is actually drawn on the plane, change the pixelColor function below.\n\n\nstruct Ring {\n    vec2 center;\n    float radius;\n    float width;\n};\n\nbool inRing(vec2 p, Ring ring){\n    return abs(distance(p,ring.center)-ring.radius)<ring.width;\n}\n\nstruct Line {\n    vec2 point;\n    vec2 direction; // should be normalized\n    float width;\n};\n\nbool inLine(vec2 p, Line line){\n    vec2 v = p-line.point;\n    float len = dot(v, line.direction);\n    v -= len*line.direction; // The part perpendicular to the line\n    \n    return length(v)<line.width;\n}\n\n//                      center,      radius, width.\nconst Ring ring1 = Ring(vec2(1.),       1.,  0.05);\nconst Ring ring2 = Ring(vec2(-1.),      0.5, 0.05);\nconst Ring ring3 = Ring(-vec2(-3., 3.), 1.,  0.05);\nconst Ring ring4 = Ring(-vec2(2., -2.), 2.,  0.05);\n\nconst Line xAxis = Line(vec2(0.), vec2(1., 0.), 0.03);\nconst Line yAxis = Line(vec2(0.), vec2(0., 1.), 0.03);\n\nvec3 pixelColor(vec2 p){\n\n    if (inLine(p, xAxis) || inLine(p, yAxis))\n        return RED;\n    if (abs(p.x-round(p.x))<0.03 || abs(p.y-round(p.y))<0.03)  // draw grid\n        return YELLOW;\n    if (inRing(p, ring1) || inRing(p, ring2) || inRing(p, ring3) || inRing(p, ring4))\n        return GREEN;\n        \n    float d = (length(p)-1.+sin(iTime))/0.07;\n    d = 1. - d*d;\n    d = clamp(d, 0., 1.);\n    \n    return mix(texture(iChannel0, p/2.).rgb * 0.7, BLUE, d);\n}\n\n\n// --------------------------- ray computation ---------------------------\n\n\nconst float MAX_DIST = 1000000000.;\n\nvec3 planeHit(vec3 origin, vec3 direction, out float dist){\n    dist = MAX_DIST;\n    \n    if (direction.z == 0.)\n        return GRAY;\n    \n    dist = -origin.z/direction.z;\n    if (dist<0.){\n        dist = MAX_DIST;\n        return GRAY;\n    }\n    vec3 hitPoint = origin + dist*direction;\n    \n    \n    return pixelColor(hitPoint.xy);\n}\n\n\nstruct Light{\n    vec3 position;\n    float strength; //between 0 and 1\n};\n\nconst Light light = Light(vec3(2.), 0.5);\n\nvec3 sphereHit(vec3 origin, vec3 direction, out float dist){\n    dist = MAX_DIST;\n    vec3 center = vec3(0.,0.,0.5);\n    float r = 0.5;\n    // compute the intersection of the ray with the sphere\n    // |origin + t*direction - center|^2 = r^2\n    // |origin-center|^2 +2t<direction,origin-center> + t^2 |direction|^2 = r^2\n    \n    vec3 v = origin-center;                     \n    float a = dot(direction, direction);         \n    float b = 2.*dot(direction,v);               \n    float c = dot(v,v)-r*r;                      \n    // solve a*t^2 + b*t + c = 0\n    float disc = b*b-4.*a*c;\n    if (disc<0.)\n        return GRAY; // no intersection with the sphere\n        \n    dist = (-b - sqrt(disc))/(2.*a);\n    vec3 hitPoint = origin + dist*direction;\n    // Look at the ray starting at the north pole, and going through the hitting point,\n    // and find out its intersection with the plane\n    vec3 newDirection = hitPoint-center-vec3(0.,0.,r);\n    float planeDist;\n    vec3 planeColor = planeHit(\n        hitPoint, \n        newDirection,\n        planeDist);\n        \n    // Just to differentiate a little bit the sphere from the plane, add some lighting to the sphere.    \n    vec3 toLight = normalize(light.position-hitPoint);\n    vec3 normal = normalize(hitPoint-center);\n    vec3 lightReflection = reflect(toLight, normal);\n    float dotProduct = dot(direction, lightReflection)*light.strength;\n    return planeColor + WHITE*dotProduct;\n}\n\n\n// Set the location of the camera.\nvoid camera(out vec3 origin, out vec3 forward, out vec3 right, out vec3 up){\n    \n    float angle = iTime*0.5;\n    float r = 4.+sin(iTime);\n   \n    origin = vec3(r*cos(angle),r*sin(angle),3. + 2.3*cos(angle*0.8));\n    \n    forward = -normalize(origin);\n    right = cross(forward, vec3(0.,0.,1.));\n    up = cross(right,forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (height goes from 0 to 1, and keep the ratio with the width)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // camera\n    vec3 origin, forward, right,up;\n    camera(origin,forward, right,up);\n   \n    // ray direction\n    uv -= vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    vec3 direction = normalize(forward + uv.x*right + uv.y*up);\n       \n    // compute intersection with sphere\n    float dist = MAX_DIST;\n    vec3 color = BLACK;\n    \n    float sphereDist;\n    vec3 sphereColor = sphereHit(origin, direction, sphereDist);\n    if (sphereDist<dist){\n        dist = sphereDist;\n        color = sphereColor;\n    }\n\n    // compute intersection with the plane\n    float planeDist;\n    vec3 planeColor = planeHit(origin, direction, planeDist);\n    if (planeDist<dist){\n        dist = planeDist;\n        float fog = 2.-dist/10.;\n        fog = clamp(fog, 0., 1.);\n        color = planeColor*fog;\n    }\n\n    // Output to screen\n    fragColor = vec4(color ,1.0);\n    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 522, 522, 588], [685, 685, 716, 716, 890], [1264, 1264, 1288, 1288, 1729], [1846, 1846, 1905, 1905, 2181], [2302, 2302, 2362, 2362, 3746], [3749, 3784, 3860, 3860, 4113], [4116, 4116, 4173, 4270, 5169]], "test": "error"}
{"id": "stVGzG", "name": "Rusty metal cubes", "author": "bitless", "description": "Rusty metal cubes", "tags": ["2d", "cube", "metal", "hexagonal", "rust"], "likes": 23, "viewed": 159, "published": "Public", "date": "1637930590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Rusty metal cubes\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define maxd .48    //disk max diameter\n#define mind .1     //disk min diameter\n#define cnum 10.    //num of disks\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )                   //iq's palette\n#define rot(a)   mat2(cos(a + vec4(0,11,33,0)))                             //rotate 2d\n#define h21(a) ( fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123) ) //hash21\n\n//  Minimal Hexagonal Grid - Shane\n//  https://www.shadertoy.com/view/Xljczw\nvec4 getHex(vec2 p) //hex grid coords \n{\n    vec2 s = vec2(1, 1.7320508);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nvec3 HexToSqr (vec2 st) //hexagonal cell coords to square face coords \n{ \n    vec3 r;\n    if (st.y > 0.-abs(st.x)*0.57777)\n        if (st.x > 0.) \n            r = vec3(fract(vec2(-st.x,(st.y+st.x/1.73)*0.86)*2.),2.); //right face\n        else\n            r = vec3(fract(vec2(st.x,(st.y-st.x/1.73)*0.86)*2.),3.); //left face\n        else\n            r = vec3(fract(vec2((st.x+st.y*1.73),(st.x-st.y*1.73))),1.); //upper face\n    return r;\n} \n\nfloat sinc( float x, float k, float l)\n{\n    float h = k*x;\n    return sin(x*l)*h*exp(1.0-h);\n}\n\nvec4 Tex (vec4 hx, vec3 sqr, vec2 sh) //face texture\n{\n    float r = h21(hx.zw*vec2(sqr.z))*5.;\n    vec2 uv = ((sqr.xy + vec2(r))  - sh)*.5* rot(r);\n    vec4 t = texture(iChannel0, uv);\n    return mix(vec4(p(h21(vec2(hx.zw))*1.75,vec3(.18,.38,.32),vec3(.46,.42,.58),vec3(.11,.20,.22),vec3(.14,.16,.13))*.125,1.),t,.1);  \n}\n\nvoid tile(vec4 hx,inout vec4 C) \n{\n    vec3 sqr = HexToSqr(hx.xy);\n    vec2    st = sqr.xy - .5  //face square coordinates\n            ,shift;  //disk shift\n    float   n = sqr.z       //face id\n            ,sm = 3./iResolution.y  //smoothness\n            ,h = -sinc (mod(iTime+h21(hx.wz*vec2(n))*20., 10.), .75,3.5)*.3 //bump stright\n            ,df =  abs(h) * .8\n            ,b = (4.-n)*1.2+.8; //face lightness\n\n    C = Tex(hx,sqr,vec2(max(h,0.)*sin(1.2)*1.5)*vec2(1.,-1.))*b*(1.-max(h,0.)*5.);\n    \n    for (float i = 0.; i < cnum; i++)\n    {\n        float k = (h < 0.) ? cnum - 1. - i : i;\n        float diam = mind + (maxd-mind)/cnum*k;\n        shift = vec2(h*sin((cnum-1.-k)/cnum*1.2)*1.5)*vec2(1,-1);\n        vec4 col = Tex(hx,sqr,shift)*b;\n\n        if (h < 0.) //outer disks\n        {\n            C = mix(C, vec4(0.), smoothstep (diam+df,diam-sm,length(st-shift))*.2); //shadow;\n            C = mix(C, col * (1. - (cnum-k)/cnum*h*5.), smoothstep (diam+sm,diam-sm,length(st-shift))); //disk\n            C = mix(C, vec4(max(-st.y,-.1)*2.), smoothstep (.01,.0,abs(length(st-shift)-diam))*df); //disk edge\n        }\n        else //inner disks\n        {\n            C = mix(C, col* (1. - (cnum - 1. -i )/cnum*h*5.) , smoothstep (diam-sm,diam+sm,length(st-shift))); //disk\n            C = mix(C, vec4(st.y), smoothstep (.01,.0,abs(length(st-shift)-diam))*df); //disk edge\n        }\n    }\n    C = mix(C, vec4(0.),(smoothstep(.4,.5,-st.x)+smoothstep(.4,.5,st.y))*.3); //ambient occlusion\n    C = mix(C, vec4(1.),(smoothstep(.45,.5,st.x)+smoothstep(.45,.5,-st.y))*.08); //edge bevel\n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 rz = iResolution.xy\n        ,uv = (g+g-rz)/-rz.y;\n    \n    uv *= 1.2+sin(iTime*.3)*.25; //camera scale\n    uv += uv * pow(length(uv),2.)*.025 + vec2(sin(iTime*.2)+5.,-cos(iTime*.2)+9.); //lens distortion and camera moving\n    \n    vec4 hx = getHex(uv);\n    C = -C;\n    tile(hx,C);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[709, 786, 826, 826, 1061], [1063, 1063, 1135, 1135, 1501], [1504, 1504, 1544, 1544, 1599], [1601, 1601, 1655, 1655, 1923], [1925, 1925, 1959, 1959, 3510], [3512, 3512, 3552, 3552, 3844]], "test": "error"}
{"id": "stVGzR", "name": "Glowing lights and SDFs", "author": "lGuy", "description": "SDF objects swinging around lights", "tags": ["sdf"], "likes": 3, "viewed": 75, "published": "Public", "date": "1637087800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Creates the inverse of the view matrix\nmat4 invLookAt(in vec3 eye, in vec3 center, in vec3 up) {\n    vec3 f = vec3(normalize(center - eye));\n    vec3 s = vec3(normalize(cross(f, up)));\n    vec3 u = vec3(cross(s, f));\n\n    mat4 m = mat4(1.0);\n    m[0][0] = s.x;\n    m[0][1] = s.y;\n    m[0][2] = s.z;\n    m[1][0] = u.x;\n    m[1][1] = u.y;\n    m[1][2] = u.z;\n    m[2][0] =-f.x;\n    m[2][1] =-f.y;\n    m[2][2] =-f.z;\n    \n    m[3][0] = dot(s, eye);\n    m[3][1] = dot(u, eye);\n    m[3][2] =-dot(f, eye);\n    \n    return m;\n}\n\n// Creates a view matrix\nmat4 look_at(vec3 eye, vec3 center,vec3 up) {\n    vec3 f = vec3(normalize(center - eye));\n    vec3 s = vec3(normalize(cross(f, up)));\n    vec3 u = vec3(cross(s, f));\n\n    mat4 m = mat4(1.0f);\n    m[0][0] = s.x;\n    m[1][0] = s.y;\n    m[2][0] = s.z;\n    m[0][1] = u.x;\n    m[1][1] = u.y;\n    m[2][1] = u.z;\n    m[0][2] =-f.x;\n    m[1][2] =-f.y;\n    m[2][2] =-f.z;\n    m[3][0] =-dot(s, eye);\n    m[3][1] =-dot(u, eye);\n    m[3][2] = dot(f, eye);\n    return m;\n}\n\nfloat sdSphere( in vec3 p, in float r ) {\n    return length(p)-r;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n// Scene geometry\nfloat map(in vec3 wRayPos) {\n    float d = 1e10;\n    \n    float sphereD0, sphereD1, sphereD2;\n    \n    { // Sphere0\n        vec3 wSpherePosition = 4.0 * vec3(sin(iTime), 0.0, cos(iTime));\n        sphereD0 = sdSphere(wRayPos - wSpherePosition, 1.0);\n    }\n    \n    { // Sphere1\n        vec3 wSpherePosition = vec3(2.0, sin(iTime) * 2.0, cos(iTime));\n        sphereD1 = sdSphere(wRayPos - wSpherePosition, 2.0);\n    }\n    \n    { // Sphere2\n        vec3 wSpherePosition = vec3(cos(iTime) * 2.0, sin(iTime) * 2.0, 4.0 * cos(iTime));\n        sphereD2 = sdSphere(wRayPos - wSpherePosition, 1.5);\n    }\n    \n    d = min(d, smoothUnion(sphereD0, sphereD1, 0.6));\n    d = min(d, smoothUnion(d, sphereD2, 0.6));\n    \n    return d;\n}\n\n// Calculates the normal of a point on a surface.\nvec3 calcNormal(in vec3 pos) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\nstruct Light {\n    vec3 wPosition;\n    vec3 color;\n    float strength;\n    float speed;\n};\n\nconst int NUM_LIGHTS = 4;\nLight lights[NUM_LIGHTS];\n\n// Calculates the pixel coordinate of a 3D point in the world\nvec2 calcPixelCoord(in vec3 wPosition, in mat4 viewMatrix) {\n    float nearPlane = -1.0;\n\n    vec3 vPosition = (viewMatrix * vec4(wPosition, 1.0)).xyz;\n    \n    float ratio = nearPlane / vPosition.z;\n    \n    vec2 screenPos = -ratio * vPosition.xy;\n    \n    return screenPos;\n}\n\n// Calculates the diffuse\nvec3 calcSurfaceLighting(\n    in float dist,\n    in vec3 wPixelPosition, \n    in vec3 wRayDirection,\n    in Light light) {\n    vec3 wHitPosition = wPixelPosition + wRayDirection * dist;\n    vec3 wNormal = calcNormal(wHitPosition);\n        \n    float diffuse = dot(wNormal, normalize(light.wPosition - wHitPosition));\n    diffuse = clamp(diffuse, 0.1, 1.0);\n        \n    return vec3(diffuse) * light.color * 15.0;\n}\n\n// Classic raymarching\nfloat raymarch(\n    in vec3 wRayStart, \n    in vec3 wRayDirection) {\n    float stride = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 wCurrent = wRayStart + wRayDirection * stride;\n        \n        float field = map(wCurrent);\n        \n        if (abs(field) < 0.001) {\n            // We hit an object\n            return stride;\n        }\n        else {\n            // Keep marching\n            stride += field;\n        }\n        \n        if (stride > 10000.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\n// Calculates the light glow (this depends on the 2D coordinate of the light on the screen).\nvec4 screenLight(\n    vec2 p, \n    vec3 vLightPos,\n    vec2 center, \n    float strength, \n    vec4 color,\n    in mat4 invViewMatrix) {\n    // We need to see if this light is being occluded\n    vec3 vPixelPosition = vec3(center, -1.0);\n    vec3 vRayDirection = normalize(vPixelPosition);\n    \n    vec3 wPixelPosition = (invViewMatrix * vec4(vPixelPosition, 1.0)).xyz;\n    vec3 wRayDirection = (invViewMatrix * vec4(vRayDirection, 0.0)).xyz;\n\n    float dist = raymarch(wPixelPosition, wRayDirection);\n\n    if (dist == -1.0 || dist < length(vLightPos)) {\n        return strength * color / dot(p - center, p - center);\n    }\n    else {\n        return vec4(0.0);\n    }\n}\n\nstruct LightContribution {\n    vec3 bleed;\n    vec3 diffuse;\n};\n\n// Calculates both the diffuse contribution and light bleeding (glow)\nLightContribution calcLightContrib(\n    in Light light,\n    in mat4 viewMatrix,\n    in mat4 invViewMatrix,\n    in vec2 fragCoord,\n    in float dist,\n    in vec3 wPixelPosition,\n    in vec3 wRayDirection) {\n    LightContribution contrib;\n    contrib.bleed = vec3(0.0);\n    contrib.diffuse = vec3(0.0);\n\n    vec2 pLightPosition = calcPixelCoord(light.wPosition, viewMatrix);\n    vec3 vLightPosition = (viewMatrix * vec4(light.wPosition,1.0)).xyz;\n    contrib.bleed = screenLight(\n        fragCoord,\n        vLightPosition,\n        pLightPosition, \n        light.strength, \n        vec4(light.color, 1.0),\n        invViewMatrix).rgb;\n        \n    if (dist == -1.0) {\n        contrib.diffuse = vec3(0.0);\n    }\n    else {\n        contrib.diffuse = calcSurfaceLighting(dist, wPixelPosition, wRayDirection, light);\n    }\n    \n    return contrib;\n}\n\n// Calculates the color of a pixel (includes raymarching, lighting etc...)\nvec3 render(\n    in vec3 wPixelPosition, \n    in vec3 wRayDirection, \n    in mat4 invViewMatrix, \n    in mat4 viewMatrix, \n    in vec2 fragCoord) {\n    float dist = raymarch(wPixelPosition, wRayDirection);\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        LightContribution contrib = calcLightContrib(\n            lights[i],\n            viewMatrix,\n            invViewMatrix,\n            fragCoord,\n            dist,\n            wPixelPosition,\n            wRayDirection);\n            \n        finalColor += contrib.diffuse + contrib.bleed;\n    }\n    \n    return finalColor;\n}\n\n// Hashing function used for move\nvec2 hash( vec2 x ) {\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// Given an n, a unique varying position is produced\nvec3 move(int n, float speed) {\n    float h = hash(vec2(float(n))).x;\n    \n    return vec3(\n        cos(speed * iTime / 10.0 - h) * 0.7, \n        sin(speed * iTime / 20.0 + h) * 0.2,\n        sin(speed * iTime / 15.0 + h) * 0.5);\n}\n\n// Light parameters configuration\nvoid configureLights() {\n    lights[0].color = vec3(0.4, 0.2, 0.7);\n    lights[0].strength = 0.1;\n    lights[0].speed = 13.0;\n    \n    lights[1].color = vec3(0.1, 0.2, 0.8);\n    lights[1].strength = 0.1;\n    lights[1].speed = 8.0;\n    \n    lights[2].color = vec3(0.4, 0.6, 0.8);\n    lights[2].strength = 0.1;\n    lights[2].speed = 10.0;\n    \n    lights[3].color = vec3(0.9, 1.2, 0.6);\n    lights[3].strength = 0.1;\n    lights[3].speed = 7.0;\n}\n\n// Calculates the final color of the pixel with a given exposure\nvec3 calcFinalColor(vec3 color, float exposure) {\n    vec3 one = vec3(1.0);\n    vec3 expValue = exp(-color / vec3(1.0) * exposure);\n    vec3 diff = one - expValue;\n    vec3 gamma = vec3(1.0 / 2.2);\n    return pow(diff, gamma);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Sets up the light parameters\n    configureLights();\n\n    // Calculates the next positions of the lights\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        lights[i].wPosition = move(i, lights[i].speed) * 10.0;\n    }\n\n    // Set up world space properties fo the camera\n    //vec3 wEyePosition = vec3(0.0, 5.0, 15.0);\n    vec3 wEyePosition = vec3(0.0, 0.0, 1.0) * 15.0;\n    vec3 wEyeDirection = normalize(vec3(0.0) - wEyePosition);\n    vec3 wUp = normalize(vec3(sin(iTime * 0.5), cos(iTime * 0.4) + 1.1, 0.0));\n    \n    // Matrix will be used to convert world space positions of the SDF objects\n    // into view space coordinates (which the view ray will be in).\n    mat4 viewMatrix = invLookAt(wEyePosition, wEyePosition + wEyeDirection, wUp);\n    mat4 invViewMatrix = invLookAt(wEyePosition, wEyePosition + wEyeDirection, wUp);\n\n    // View space\n    vec3 vPixelPosition = vec3((fragCoord - 0.5*iResolution.xy)/iResolution.y, -1.0);\n    vec3 vRayDirection = normalize(vPixelPosition);\n    \n    // World space\n    vec3 wPixelPosition = (invViewMatrix * vec4(vPixelPosition, 1.0)).xyz;\n    vec3 wRayDirection = (invViewMatrix * vec4(vRayDirection, 0.0)).xyz;\n    \n    vec3 color = render(wPixelPosition, wRayDirection, invViewMatrix, viewMatrix, vPixelPosition.xy);\n    \n    // Final color\n    fragColor.rgb = calcFinalColor(color, 0.06);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 42, 99, 99, 522], [524, 549, 594, 594, 1008], [1010, 1010, 1051, 1051, 1077], [1079, 1079, 1129, 1129, 1205], [1207, 1225, 1253, 1253, 1947], [1949, 1999, 2029, 2029, 2263], [2410, 2472, 2532, 2532, 2749], [2751, 2777, 2899, 2899, 3191], [3193, 3216, 3284, 3284, 3750], [3752, 3845, 3979, 4033, 4510], [4577, 4647, 4852, 4852, 5488], [5490, 5565, 5712, 5712, 6185], [6187, 6221, 6242, 6242, 6380], [6382, 6435, 6466, 6466, 6665], [6667, 6701, 6725, 6725, 7144], [7146, 7211, 7260, 7260, 7439], [7441, 7441, 7496, 7532, 8842]], "test": "valid"}
{"id": "styGRm", "name": "Ray March glass and mirror", "author": "yurka", "description": "ray march", "tags": ["raymarch"], "likes": 6, "viewed": 178, "published": "Public API", "date": "1637499519", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 light = vec3(1.0, 1.0, 1.0);\n\nstruct scene_sf \n{\n    float d;\n    float depth;\n    vec3 col;\n    int type; // 0 - regular, 1 - mirror, 2 glass\n    vec3 n;\n};\n\nscene_sf scene_dist(vec3 ap)\n{\n    const float gridsteps = 11.0;\n    scene_sf rs;\n    //vec3 so = vec3(sin(iTime*0.4) * 0.3, sin(iTime*3.14*0.4)*0.1, cos(iTime*0.4) * 3.7 + 3.0);\n    vec3 so = vec3(sin(iTime*0.4) * 0.2, 0.1, cos(iTime*0.4) * 0.2);\n    rs.d = length(ap - so) - 0.1;\n    vec3 pn = -normalize(ap - so);\n    float ldot = dot(pn, light);\n    if (ldot < 0.0) ldot = 0.0;\n    float vdot = dot(pn, vec3(0.0, -sin(iTime * 1.2), cos(iTime * 1.2)));\n    float hdot = dot(pn, vec3(0.0, cos(iTime * 1.2), sin(iTime * 1.2)));\n    float sdot = dot(pn, vec3(1.0, 0.0, 0.0));\n    float vang = acos(vdot);\n    float hang = acos(hdot);\n    float sang = acos(sdot);\n    rs.col = vec3(1.0, 1.0, 1.0);\n    if (int(hang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(1.0, 0.0, 0.0);\n    if (int(vang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(0.0, 1.0, 0.0);\n    if (int(sang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(0.0, 0.0, 1.0);\n    rs.type = 0;\n    rs.n = -pn;\n    //ldot = 1.0;\n    \n    so = vec3(sin(iTime*0.4 + 2.093) * 0.2, 0.1, cos(iTime*0.4 + 2.093) * 0.2);\n    float glsd = length(ap - so) - 0.1;\n    if (glsd < rs.d) {\n        rs.d = glsd;\n        pn = -normalize(ap - so);\n        ldot = dot(pn, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.col = vec3(0.0, 0.5, 1.0);\n        rs.type = 1;\n        rs.n = -pn;\n    }\n    \n    so = vec3(sin(iTime*0.4 + 4.186) * 0.2, 0.1, cos(iTime*0.4 + 4.186) * 0.2);\n    glsd = length(ap - so) - 0.1;\n    if (glsd < rs.d) {\n        rs.d = glsd;\n        pn = -normalize(ap - so);\n        ldot = dot(pn, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.col = vec3(0.0, 0.5, 1.0);\n        rs.type = 2;\n        rs.n = -pn;\n    }\n    \n    float plane_h = 0.7;\n    if ((ap.y + plane_h) < rs.d) {\n        vec3 plnorm = vec3(0.0, 1.0, 0.0);\n        rs.d = (ap.y + plane_h);\n        if ((int(floor(ap.x)) % 2 + 2) % 2 == (int(floor(ap.z)) % 2 + 2) % 2 )\n            rs.col = vec3(1.0, 1.0, 1.0);\n        else\n            rs.col = vec3(0.0, 0.0, 0.0);\n        //rs.col = vec3(1.0, 0.0, 0.0);\n        ldot = -dot(plnorm, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.type = 0;\n        rs.n = plnorm;\n    }\n    \n    float athmo_r = 5.0;\n    if (athmo_r - length(ap) < rs.d) {\n        rs.d = athmo_r - length(ap);\n        float ag = atan(ap.x, ap.z) / 3.14;\n        float cr = 1.0 - 30.0 * abs(fract(ag * 36.0) - 0.5);\n        if (cr < 0.0) cr = 0.0;\n        float agv = atan(sqrt(ap.z*ap.z + ap.x*ap.x), ap.y) / 3.14;\n        float cg = 1.0 - 30.0 * abs(fract(agv * 36.0) - 0.5);\n        if (cg < 0.0) cg = 0.0;\n        rs.col = vec3(cr, cg, ap.y / athmo_r);\n        ldot = -dot(vec3(0.0, 1.0, 0.0), light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.type = 0;\n        rs.n = -normalize(ap);\n    }\n    \n    rs.col= rs.col * ldot;\n    return rs; // sphere\n}\n\nscene_sf rmarch(vec3 aro, vec3 ard) \n{\n    vec3 p = aro;\n    float depth = 0.0;\n    scene_sf sf;\n    float prefsfd = 1.0;\n    for (int i = 0; i < 250; i++) {\n        sf = scene_dist(p);\n        float ds = abs(sf.d);\n        if (ds < 0.0001) ds = 0.0001;\n        p += ds * ard;\n        depth += ds;\n        if (depth > 100.0)\n           break;\n        if (sf.type == 1 && sf.d < 0.000) {\n            if (dot(ard, sf.n) < 0.0) {\n                ard = reflect(ard, sf.n);\n            }\n        }\n        else\n        if (sf.type == 2) {\n            if (prefsfd > 0.0 && sf.d <= 0.0) {\n                ard = refract(ard, sf.n, 1.0/1.6290);\n            }\n            if (prefsfd <= 0.0 && sf.d > 0.0) {\n                ard = refract(ard, -sf.n, 1.6290);\n            }\n        }\n        else\n        if (sf.d < 0.000)\n            break;\n\n        prefsfd = sf.d;\n    }\n    if (depth > 100.0)\n        depth = 100.0;\n    sf.depth = depth;\n    return sf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light = vec3(sin(iTime*2.1), -1.0, cos(iTime*2.1));\n    light = vec3(1.0, -1.0, 1.0);\n    light = normalize(light);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec2 muv = iMouse.xy/iResolution.x;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.0) - ro);\n    \n    scene_sf sf = rmarch(ro, rd);\n    \n    float smoge = 1.0 - pow(0.91, sf.depth);\n    \n    vec3 col = vec3(0.88, 0.88, 0.88);\n    //if (sf.d < 0.001) \n    col = col * smoge + sf.col * (1.0 - smoge);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3032, 3032, 3070, 3070, 3978], [3980, 3980, 4037, 4095, 4648]], "test": "valid"}
{"id": "styGRW", "name": "Very Nice Screensaver", "author": "wainggan", "description": "very very nice", "tags": ["screensaver"], "likes": 7, "viewed": 126, "published": "Public", "date": "1637226347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ATMOSHPERE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec3 texCol = texture(iChannel0, uv).rgb;\n    \n    float time = iTime / 8.0;\n    vec3 colOut = vec3(0.0);\n    for (float i = 0.0; i < 32.0; i += 1.0) {\n        // pick random point\n        float rnd = i*(3.141 * 2.0 + .4123);\n\t\tvec2 pos = vec2(sin(time*0.95 + rnd*3.131)*0.5, cos(time*1.05 + rnd*5.763)*0.4) * 2.0;\n\t\tpos *= vec2(sin(time*1.05 + i*i*3.141/7.131), cos(time*.95 + i*(i-1.0)*3.141/4.235))*1.25;\n        \n        // random color\n        vec3 randCol = vec3(mod(rnd * 2.0, 1.0), mod(rnd, 1.0) * 0.8, mod(rnd * 3.0, 1.0));\n        \n        // adding the points together\n        float dist = clamp(1.0 - distance(p, pos) * 2.0, 0.0, 0.5);\n        colOut += mix(vec3(0.0), randCol, dist);\n    }\n    // bad idea, dont uncomment\n    //colOut = clamp(colOut, 0.0, 1.0);\n    \n    #ifdef ATMOSHPERE\n    vec3 col = colOut / 5.0;\n    fragColor = vec4(texCol + col,1.0);\n    #else\n    vec3 col = colOut / 2.0;\n    fragColor = vec4(col,1.0);\n    #endif\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 1144]], "test": "error"}
{"id": "styGzt", "name": "Mosaic fractal", "author": "jarble", "description": "A colorful mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 10, "viewed": 190, "published": "Public API", "date": "1638168699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){    \n            uv /= -scale;\n            uv -= (t2.yx)/(scale);\n            //uv -= (t2.yx)/(scale-t3.yx);\n            t2 = triangle_wave(-uv-.5,scale);\n            t3 = -triangle_wave(-uv.yx,scale);\n            //t3 = -triangle_wave(-uv.yx+.5/scale,scale);\n            \n            uv.yx = (t2+t3);\n            uv /= scale;\n            //uv /= scale+uv.yx;\n            //scale *= 1.005;\n            //uv.yx = (t2-t3)/scale;\n\n        }\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1148]], "test": "valid"}
{"id": "WsKGWD", "name": "3DPerlinNoise", "author": "drcd1", "description": "3D Perlin Noise", "tags": ["noise"], "likes": 2, "viewed": 49, "published": "Public", "date": "1637339374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT2_INV 0.70710678118f\n#define SQRT2 1.41421356237f\n#define LAYERS 5\nvec3 gradient[]=vec3[](\n    vec3(0.0f,SQRT2_INV,SQRT2_INV),vec3(0.0f,SQRT2_INV,-SQRT2_INV),vec3(0.0f,-SQRT2_INV,-SQRT2_INV),vec3(0,-SQRT2_INV,SQRT2_INV),\n    vec3(SQRT2_INV,0.0f,SQRT2_INV),vec3(SQRT2_INV,0,-SQRT2_INV),vec3(-SQRT2_INV,0,-SQRT2_INV),vec3(-SQRT2_INV,0,SQRT2_INV),\n    vec3(SQRT2_INV,SQRT2_INV,0.0f),vec3(SQRT2_INV,-SQRT2_INV,0.0f),vec3(-SQRT2_INV,-SQRT2_INV,0.0f),vec3(-SQRT2_INV,SQRT2_INV,0));\nint random_idx[] = int[](\n\t213, 16, 185, 39, 132, 110, \n    25, 215, 157, 12, 193, 5, \n    254, 166, 123, 222, 141, \n    54, 4, 95, 104, 73, 248, 224, \n    252, 88, 29, 20, 236, 210, 177, \n    118, 206, 124, 111, 255, 131, 43, \n    53, 115, 137, 164, 228, 10, 51, 172, \n    235, 155, 107, 65, 114, 83, 246, 91, 119, \n    105, 162, 201, 239, 28, 191, 178, 163, 64, 108,\n    67, 96, 122, 94, 212, 17, 237, 182, 184, 241, 34, \n    98, 211, 138, 159, 216, 134, 13, 22, 140, 205, 0, 180,\n    158, 220, 144, 247, 27, 223, 87, 80, 69, 75, 186, 231, \n    71, 74, 240, 50, 62, 21, 40, 152, 19, 66, 100, 209, 242, \n    99, 90, 168, 195, 93, 199, 32, 146, 136, 227, 109, 189, 221,\n    143, 55, 129, 161, 171, 44, 200, 23, 8, 225, 245, 2, 77, 203, \n    70, 38, 145, 81, 165, 24, 127, 18, 113, 60, 120, 35, 196, 126, \n    154, 7, 156, 176, 89, 37, 219, 190, 179, 52, 204, 232, 31, 175, \n    181, 226, 250, 45, 106, 167, 14, 59, 58, 47, 233, 48, 238, 197,\n    102, 121, 112, 9, 97, 169, 207, 49, 135, 78, 33, 30, 198, 82,\n    86, 130, 139, 128, 251, 11, 183, 229, 142, 202, 101, 79, 234, \n    133, 46, 15, 63, 244, 57, 148, 150, 174, 187, 36, 160, 117, 170, \n    26, 230, 217, 76, 61, 116, 153, 41, 103, 3, 218, 149, 125, 92, 192,\n    243, 56, 151, 1, 84, 42, 6, 208, 194, 249, 173, 68, 72, 188, 85, 214, \n    147, 253\n);\n\nfloat smooth_lerp(float a, float b, float t){\n\tfloat f = ((6.0f*t-15.0f)*t+10.0f)*t*t*t;\n    return a*(1.0f-f)+b*f;\n}\n\nfloat getPerlin(vec3 pos){\n    //x,y,x+1,y+1,bottom left,bottom right, top left, top right\n\tint x,y,z,x1,y1,z1,bl0,br0,tl0,tr0,bl1,br1,tl1,tr1;\n    //fractional values\n    float x_f,y_f,z_f;\n    x = pos.x<0.0f?(int(pos.x)):int(pos.x)+1;\n    y = pos.y<0.0f?(int(pos.y)):int(pos.y)+1;\n    z = pos.z<0.0f?(int(pos.z)):int(pos.z)+1;\n    //make sure all are positive modulo 256\n    x=x<0?x%256+256:x;\n    y=y<0?y%256+256:y;\n    z=z<0?z%256+256:z;\n    \n    x_f = pos.x-floor(pos.x);\n    y_f = pos.y-floor(pos.y);\n    z_f = pos.z-floor(pos.z);\n    \n    x1 = x+1;\n    y1 = y+1;\n    z1 = z+1;\n    bl0 = random_idx[(random_idx[(random_idx[x%256 ]+y )%256]+z )%256];\n    br0 = random_idx[(random_idx[(random_idx[x1%256]+y )%256]+z )%256];\n    tl0 = random_idx[(random_idx[(random_idx[x%256 ]+y1)%256]+z )%256];\n    tr0 = random_idx[(random_idx[(random_idx[x1%256]+y1)%256]+z )%256];\n    \n    bl1 = random_idx[(random_idx[(random_idx[x%256 ]+y )%256]+z1)%256];\n    br1 = random_idx[(random_idx[(random_idx[x1%256]+y )%256]+z1)%256];\n    tl1 = random_idx[(random_idx[(random_idx[x%256 ]+y1)%256]+z1)%256];\n    tr1 = random_idx[(random_idx[(random_idx[x1%256]+y1)%256]+z1)%256];\n    \n    \n    \n    vec3 grad_bl0 = gradient[bl0%12];\n    vec3 grad_br0 = gradient[br0%12];\n    vec3 grad_tl0 = gradient[tl0%12];\n    vec3 grad_tr0 = gradient[tr0%12];\n    vec3 grad_bl1 = gradient[bl1%12];\n    vec3 grad_br1 = gradient[br1%12];\n    vec3 grad_tl1 = gradient[tl1%12];\n    vec3 grad_tr1 = gradient[tr1%12];\n    \n    vec3 dist_bl0 = vec3(x_f     ,y_f     , z_f);\n    vec3 dist_br0 = vec3(x_f-1.0f,y_f     , z_f);\n    vec3 dist_tl0 = vec3(x_f     ,y_f-1.0f, z_f);\n    vec3 dist_tr0 = vec3(x_f-1.0f,y_f-1.0f, z_f);\n    \n    vec3 dist_bl1 = vec3(x_f     ,y_f     , z_f-1.0f);\n    vec3 dist_br1 = vec3(x_f-1.0f,y_f     , z_f-1.0f);\n    vec3 dist_tl1 = vec3(x_f     ,y_f-1.0f, z_f-1.0f);\n    vec3 dist_tr1 = vec3(x_f-1.0f,y_f-1.0f, z_f-1.0f);\n    \n    //value at each point\n    /*float v_bl = grad_bl.x*x_f        + grad_bl.y*y_f;\n    float v_br = grad_br.x*(1.0f-x_f) + grad_br.y*y_f;\n    float v_tl = grad_tl.x*x_f        + grad_tl.y*(1.0f-y_f);\n    float v_tr = grad_tr.x*(1.0f-x_f) + grad_tr.y*(1.0f-y_f);*/\n    float v_bl0 = dot(grad_bl0,dist_bl0);\n    float v_br0 = dot(grad_br0,dist_br0);\n    float v_tl0 = dot(grad_tl0,dist_tl0);\n    float v_tr0 = dot(grad_tr0,dist_tr0);\n    \n    float v_bl1 = dot(grad_bl1,dist_bl1);\n    float v_br1 = dot(grad_br1,dist_br1);\n    float v_tl1 = dot(grad_tl1,dist_tl1);\n    float v_tr1 = dot(grad_tr1,dist_tr1);\n    /*v_bl = grad_bl.x;\n    v_br = grad_br.x;\n\tv_tl = grad_tl.x;\n\tv_tr = grad_tr.x;*/\n    \n    return SQRT2*smooth_lerp(\n        smooth_lerp(smooth_lerp(v_bl0,v_br0,x_f),smooth_lerp(v_tl0,v_tr0,x_f),y_f),\n        smooth_lerp(smooth_lerp(v_bl1,v_br1,x_f),smooth_lerp(v_tl1,v_tr1,x_f),y_f),\n        z_f);\n    \n    \n    \n}\nfloat getNoise(vec3 pos){\n\t//return 1.0f/(1.0f+0.5f+0.25f+0.125f)*(getPerlin(pos)+0.5f*getPerlin(pos*2.0f)+0.25*getPerlin(pos*4.0f)+0.125*getPerlin(pos*8.0f));\n    float frequency = 2.f;\n    float attenuation = 0.5f;\n    float val_acc=0.0f;\n    float acc=0.0f;\n    float mul_val = 1.0f;\n    float mul_freq = 1.0f;\n    \n    for(int i = 0; i<LAYERS;i++){\n        acc+= mul_val*getPerlin(pos*mul_freq);\n        val_acc+= mul_val;\n        mul_val*=attenuation;\n        mul_freq*=frequency;\n    }\n    return acc/val_acc;\n    \n    //return (getPerlin(pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 10.0f;\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 pos = vec3(uv.x*scale,uv.y*aspect*scale,iTime);\n    float value = getNoise(pos)*0.5f+0.5f;\n    // Time varying pixel color\n    vec3 col = vec3(value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1797, 1797, 1842, 1842, 1914], [4760, 4760, 4785, 4919, 5313], [5315, 5315, 5372, 5423, 5751]], "test": "error"}
