{"id": "3dK3Dw", "name": "balls demo", "author": "patu", "description": "Balls", "tags": ["balls"], "likes": 0, "viewed": 69, "published": "Public API", "date": "1575889898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int BALLS = 12;  // go for \n\nconst vec2 G = vec2(32., 32.);\nfloat S = .5;\n\nvec2 sphereMap(vec3 p) {\n\treturn vec2(\n    \t.5 + atan(p.z, p.x) / (2.*3.14159),\n\t\t.5 - asin(p.y) / 3.14159\n    );\n}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat cs(vec3 p, vec2 rot) {\n    p.xy *= Rot(rot.x);\n    //p.yz *= Rot(rot.y);\n\t\n    vec2 cc1 = sphereMap(p);\n\n    float \n        c = 0.;\n    \tc += smoothstep(S, 1., abs(fract(cc1.x * G.x) * 2. - 1.));\n    \tc *= smoothstep(S, 1., abs(fract(cc1.y * G.y) * 2. - 1.));\n    \n    return c * c * (3. - 2. * c);\n}\n\nvec4 drawBalls(vec3 ro, vec3 rd) {\n    vec3 p;\n    vec3 col = vec3(0.);\n\tfloat r = .75;\n\n    ro.xz *= Rot(iTime);\n\trd.xz *= Rot(iTime);    \n    \n    float t1 = 1e3;\n    for (int i = 0; i < BALLS; i++) {        \n        float fi = float(i);\n        \n        // ball pos\n        vec3 s = vec3(\n            sin(fi * 323.34) * 4., \n            -abs(sin(iTime * 2. + fi)) * 2. + r, \n            cos(fi * 234.56) * 4.\n        );\n        \n        float t = dot(s - ro, rd);\n\n        p = ro + rd * t;\n\n        float y = length(s - p);\n\n        if (y < r) {\n            float x = sqrt(r * r - y * y);\n            vec2 rot = vec2(-iTime + fi, cos(-fi -iTime));\n            \n            col += cs(ro + rd * (t - x) - s, rot) * .75; \n            col += cs(ro + rd * (t + x) - s, rot) * .5;\n            \n            if (col.x > .0) break;\n        }\n    }\n    \n    return vec4(col, t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 col = vec3(.3, 0.1, .0) + smoothstep(1., .0, abs(U.y)) * .1 ;\n\t\n    vec3 ro = vec3(0., 1., 10.);\n    vec3 rd = normalize(vec3(U.x * .3, U.y * .3 - .01, 1.)); \n\t\n    float rot = iMouse.x / iResolution.x * 3.14 * 2.;\n    \n    ro.xz *= Rot(rot);\n\trd.xz *= Rot(rot);    \n    \n    col += drawBalls(ro, rd).rgb;\n    \n    // floor\n    float h = -ro.y / rd.y;\n    if (h > 0.) {\n        col -= .02;        \n        rd.y *= -1.;\n        S = 0.;\n        \n        col += drawBalls(vec3(ro.x, -ro.y + 3., ro.z), rd).rgb * .04;        \n    }\n    \n    fragColor = vec4(col / max(.05, smoothstep(.0, .02, length(rd.xy - vec2(.5, 0.)) / 12.)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dK3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 105, 105, 196], [198, 198, 217, 217, 283], [285, 285, 313, 313, 591], [593, 593, 627, 627, 1467], [1469, 1469, 1526, 1526, 2236]], "test": "ok"}
{"id": "3dKSDc", "name": "Rounded X - distance 2D", "author": "iq", "description": "Distance to a rounded \"X\" shape, given its width and thickness. It is exact in the exterior, and a bound in the interior", "tags": ["2d", "distancefield", "sdf", "distance", "x"], "likes": 3, "viewed": 896, "published": "Public API", "date": "1575209410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D rounded X shape. It is exact in the\n// exterior, and a bound in the interior.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // width\n\tfloat wi = 0.5 + 0.3*cos( iTime + 2.0 );\n    // radious\n    float ra = 0.1 + 0.08*sin(iTime*1.2);\n\n\tfloat d = sdRoundedX( p, wi, ra );\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundedX(m, wi, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKSDc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1342, 1342, 1397, 1397, 1460], [1462, 1462, 1519, 1519, 2267]], "test": "ok"}
{"id": "3l33DB", "name": "Simple Brick Texture", "author": "Assossa", "description": " ", "tags": ["texture", "brick"], "likes": 2, "viewed": 64, "published": "Public", "date": "1577386478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VERTICAL_BRICKS 8.0\n#define HORIZONTAL_BRICKS 4.0\n#define GAP 0.05\n\n#define BRICK_RATIO (HORIZONTAL_BRICKS / VERTICAL_BRICKS)\n#define X_GAP (GAP * BRICK_RATIO)\n#define BLUR ((2. / iResolution.y) * (VERTICAL_BRICKS / 2.0))\n#define X_BLUR (BLUR * BRICK_RATIO)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv += fract(iTime) * 0.5 + 1.0;\n    uv *= vec2(HORIZONTAL_BRICKS / 2.0, VERTICAL_BRICKS / 2.0);\n    \n    int layer_offset = abs(int(uv.y)) & 1;\n    // TODO: Fix doubled bricks\n    uv.x += float(layer_offset) * 0.5;\n    vec2 fract_uv = fract(uv);\n    \n    fragColor = vec4(1);\n    \n    fragColor *= smoothstep(GAP, GAP + BLUR, fract_uv.y);\n    fragColor *= smoothstep(1. - GAP, 1. - (GAP + BLUR), fract_uv.y);\n    \n    fragColor *= smoothstep(X_GAP, X_GAP + X_BLUR, fract_uv.x);\n    fragColor *= smoothstep(1. - X_GAP, 1. - (X_GAP + X_BLUR), fract_uv.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l33DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 322, 322, 947]], "test": "ok"}
{"id": "3l33DN", "name": "noisy sphere", "author": "aodnawg", "description": "noisy sphere", "tags": ["noise"], "likes": 11, "viewed": 319, "published": "Public", "date": "1576297899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N11(float n ) {\n    return fract(sin(n * 314.21)*521.53);\n}\n\nfloat N21(vec2 n) {\n\treturn N11(n.y+N11(n.x));\n}\nfloat N31(vec3 n) {\n\treturn N11(n.z+N11(n.y+N11(n.x)));\n}\nfloat ease(float n){\n\treturn n*n*(3.-2.*n);\n}\nfloat smoothNoise(vec2 uv, float z) {\n    vec2 gv = fract(uv * z);\n    vec2 id = floor(uv * z);\n    \n    float tl = N21(id);\n    float tr = N21(id+vec2(1., 0.));\n    float bl = N21(id+vec2(0., 1.));\n    float br = N21(id+vec2(1., 1.));\n    return mix(mix(tl, tr, ease(gv.x)), mix(bl, br, ease(gv.x)), ease(gv.y));\n}\nfloat smoothNoise(vec3 xyz, float z) {\n    vec3 gv = fract(xyz * z);\n    vec3 id = floor(xyz * z);\n    \n    float ftl = N31(id);\n    float ftr = N31(id+vec3(1., 0., 0.));\n    float fbl = N31(id+vec3(0., 1., 0.));\n    float fbr = N31(id+vec3(1., 1., 0.));\n    float front = mix(mix(ftl, ftr, ease(gv.x)), mix(fbl, fbr, ease(gv.x)), ease(gv.y));\n    \n    float rtl = N31(id+vec3(0., 0., 1.));\n    float rtr = N31(id+vec3(1., 0., 1.));\n    float rbl = N31(id+vec3(0., 1., 1.));\n    float rbr = N31(id+vec3(1., 1., 1.));\n    float rear = mix(mix(rtl, rtr, ease(gv.x)), mix(rbl, rbr, ease(gv.x)), ease(gv.y));\n    \n    return mix(front, rear, ease(gv.z));\n}\nfloat noisySphere(vec2 uv, float t) {\n    float m = 0.;\n    float noise = smoothNoise(vec3(uv,  t),5.);\n    float s = .7;\n    float a = mix(s*-1., s, noise) *.5 + 1.; \n    uv *= vec2(a);\n    m = distance(vec2(.0), uv);\n    m = smoothstep(.30, .29, m) - smoothstep(.29, .28, m);\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.x /= iResolution.y/iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    float m = 0.;\n    float z = 10.;\n\n    for(float i = 0.; i<=1.; i+=1./256.) {\n    \tm += noisySphere(uv, i + iTime * .1) * .025;\n    }\n    // m = noisySphere(uv, .1);\n    col = vec3(m);\n    \n    // apply color\n    col = pow(min(vec3(.9, 1, 1.2)*m, 1.), vec3(4, 3, 12));\n    \n    // col.rb = suv;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l33DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 65], [67, 67, 86, 86, 115], [116, 116, 135, 135, 173], [174, 174, 194, 194, 219], [220, 220, 257, 257, 535], [536, 536, 574, 574, 1188], [1189, 1189, 1226, 1226, 1479], [1481, 1481, 1538, 1588, 2107]], "test": "ok"}
{"id": "3l33WB", "name": "tunelhexagonov00", "author": "jorge2017a1", "description": "un poco lento el tunel!!!!", "tags": ["tunelhexagonov00"], "likes": 3, "viewed": 49, "published": "Public", "date": "1577372750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 opRepvec3( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d, dif1, dif2, dif3, dif4;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n   \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n         } \n     } \n    \n    \n    \n    p.x=p.x+0.025;\n    p.y=p.y+1.0;\n    p.z=mod(p.z, 8.0)-2.0;\n    \n    \n    \n    float sdh1=sdHexPrism( p-vec3(0.0,4,0.0), vec2(2.0,1.0) );\n    float sdh2=sdHexPrism( p-vec3(0.0,4,0.0), vec2(2.6,0.8) );\n    \n    float sdh3=sdHexPrism( p-vec3(0.0,4,2.0), vec2(2.0,1.0) );\n    float sdh4=sdHexPrism( p-vec3(0.0,4,2.0), vec2(2.6,0.8) );\n    \n    float sdh5=sdHexPrism( p-vec3(0.0,4,4.0), vec2(2.0,1.0) );\n    float sdh6=sdHexPrism( p-vec3(0.0,4,4.0), vec2(2.6,0.8) );\n    \n    float sdh7=sdHexPrism( p-vec3(0.0,4,6.0), vec2(2.0,1.0) );\n    float sdh8=sdHexPrism( p-vec3(0.0,4,6.0), vec2(2.6,0.8) );\n    \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,4,0.), vec3(3,5.0,5) );\n    \n    \n    dif1=differenceSDF(sdh2, sdh1);\n    dif2=differenceSDF(sdh4, sdh3);\n    dif3=differenceSDF(sdh6, sdh5);\n    dif4=differenceSDF(sdh8, sdh7);\n    \n    res=opU(res, vec2(dif1,7));\n    res=opU(res, vec2(dif2,3));\n    res=opU(res, vec2(dif3,4));\n    res=opU(res, vec2(dif4,5));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n\n    vec3 ro = vec3(0.25, 2.5, 1.5+iTime*0.5);\n    \n    vec3 rLuz=vec3(0.5, 3.5, iTime-4.0);\n    vec3 rLuz3=vec3(5.5, 1.5, iTime-4.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\t\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    float dif = GetLight(p);\n\n    //float dif2 = abs(1.0- GetLightv2(pluz));\n    //float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    float dif2 = abs(1.0- GetLight(pluz));\n    float dif3 = abs(1.0- GetLight(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2+dif3)/3.0;\n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l33WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 359, 392, 392, 457], [458, 476, 512, 512, 581], [582, 597, 628, 628, 778], [779, 799, 835, 835, 922], [923, 939, 971, 999, 1060], [1063, 1073, 1109, 1109, 1382], [1435, 1435, 1481, 1481, 1513], [1515, 1515, 1557, 1557, 1589], [1591, 1591, 1638, 1638, 1671], [1674, 1674, 1703, 1703, 1829], [1831, 1831, 1867, 1867, 1984], [1986, 1986, 2022, 2022, 2140], [2142, 2142, 2176, 2176, 2221], [2223, 2223, 2251, 2251, 3245], [3299, 3408, 3445, 3445, 3480], [3483, 3483, 3508, 3508, 5010], [5013, 5013, 5047, 5047, 5281], [5284, 5284, 5308, 5308, 5540], [5544, 5544, 5568, 5568, 5953], [5956, 5956, 5982, 5982, 6346], [6392, 6392, 6464, 6464, 6491], [6493, 6493, 6550, 6550, 7493]], "test": "error"}
{"id": "3l33zB", "name": "candy cane rings", "author": "cmarangu", "description": "I really need to clean up and optimize the code then I wil merge it with a different one\n\nInspired by a gif by @i_am_pi / pi-slices\n[url]https://twitter.com/concinnus/status/1206665313426608128[/url]", "tags": ["ice", "candycane"], "likes": 5, "viewed": 113, "published": "Public", "date": "1576661814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Need to add a billion twinkling stars\n// norther lights check min dist to aurora\n// and snow hills in the distance\n\nconst float FRAMES = 60.;\n\nfloat wnoise (float ix, float iy) {\n    iy = mod(iy, 20.*3./5.);\n    return mod(ix*ix*26.+ix*iy*41.+ix*55.+iy*77., 16.)/15.;\n}\n\nfloat gnoise (float px, float py) {\n    float mx = mod(px, 1.);\n    float my = mod(py, 1.);\n    mx = 3.*mx*mx-2.*mx*mx*mx;\n    my = 3.*my*my-2.*my*my*my;\n    \n    px = floor(px);\n    py = floor(py);\n    return mix(\n        mix(wnoise(px, py), wnoise(px+1., py), mx),\n        mix(wnoise(px, py+1.), wnoise(px+1., py+1.), mx),\n        my\n    );\n}\n\n// i know more\nconst float PI = 3.14159265358979323;\n\n#define arg (mod((float(iTime*5.)/1.), 30.)/30.)\n\nvec3 sund () {\n    // return normalize(\n    //     vec3(\n    //         cos(arg()*PI*2.),\n    //         1.,\n    //         sin(arg()*PI*2.)\n    //     )\n    // );\n    return normalize(\n        vec3(\n            -1.,\n            1.,\n            -1.\n        )\n    );\n}\n// const vec3 sund = normalize(vec3(-3., 0., -1.));\n\nvec3 skyTEX (vec3 d) {\n    vec3 skyTEXd = vec3(0.);\n    \n   \t\n    float azimuth = .5*atan(d.z, d.x);\n    float zenith =  .5*acos(d.y);\n    // skyTEXd += texture(iChannel0, vec2(azimuth, zenith)).rgb;\n    // skyTEXd = vec3(\n    //     pow(skyTEXd.r, 6.),\n    //     pow(skyTEXd.g, 6.),\n    //     pow(skyTEXd.b, 6.)\n    // );\n    \n    skyTEXd += vec3(0., 0., 100./255.)+pow(\n        clamp(dot(d, sund()), 0., 1.),\n        340.\n    );\n    \n    return clamp(skyTEXd, 0., 1.);\n}\n\nfloat objSDF (vec3 p) {\n    p.z = mod(p.z, 20.)-10.;\n    float pyxr = length(p.xy);\n    p.x = pyxr*cos(0.);\n    p.y = pyxr*sin(0.);\n    \n    return length(p-vec3(8., 0., 0.) )-1.;\n}\n\nfloat waterSDF (vec3 p) {\n    return p.y+1.+gnoise(p.x*.3, p.z*3./5.+p.x*.4)*.6;\n}\n\n// float auroraSDF (vec3 p) {\n//     // return max(abs(p.x - sin(p.z*PI*2./20.)*5.)-.5, (20.-p.y) );\n//     return max(mod(500.+p.x+sin(p.z*PI*2.*1./20.), 6.), (30.-p.y) );\n// }\n\nvec3 dobjSDF (vec3 p) {\n    float objSDFp = objSDF(p);\n    return normalize(\n        vec3(\n            objSDF(vec3(p.x+1e-3, p.y, p.z))-objSDFp,\n            objSDF(vec3(p.x, p.y+1e-3, p.z))-objSDFp,\n            objSDF(vec3(p.x, p.y, p.z+1e-3))-objSDFp\n        )\n    );\n}\n\nvec3 dwaterSDF (vec3 p) {\n    float waterSDFp = waterSDF(p);\n    return normalize(\n        vec3(\n            waterSDF(vec3(p.x+1e-3, p.y, p.z))-waterSDFp,\n            waterSDF(vec3(p.x, p.y+1e-3, p.z))-waterSDFp,\n            waterSDF(vec3(p.x, p.y, p.z+1e-3))-waterSDFp\n        )\n    );\n}\n\nvec3 objTEX (vec3 p, vec3 d, vec3 dobjSDFp, float argp) {\n    vec3 TEXp = vec3(1.);\n    float pyx = atan(p.y, p.x)/PI;\n    vec3 q = p;\n    q.z = mod(p.z, 20.)-10.;\n    float qyxr = length(q.xy);\n    q.x = qyxr*cos(0.);\n    q.y = qyxr*sin(0.);\n    q -= vec3(8., 0., 0.);\n    float ang2 = atan(q.z, q.x)/PI;\n    \n    if (mod(10.+pyx*14.+ang2*4.+sin(\n        argp*PI*2. + (floor((p.z+2.)/20.)-argp)*-.7\n    \t)*6., 2.) < 1.) {\n        TEXp = vec3(1., 0., 0.);\n    }\n    float lighting = 1.;\n    //lighting *= clamp(dot(dobjSDFp, sund()), 0., 1.);\n    // lighting = .7+.3*lighting;\n    return TEXp*lighting;\n}\n\nvec3 waterTEX (vec3 p, vec3 d, vec3 dwaterSDFp) {\n    vec3 TEXp = vec3(.4, .8, 1.);\n    // TEXp *= .8+.2*mod(floor(p.x*3.)+floor(p.y*3.), 2.);\n    float lighting = 1.;\n    lighting *= clamp(dot(dwaterSDFp, sund()), 0., 1.);\n    lighting = .5+.5*lighting;\n    return TEXp*lighting;\n}\n\nfloat objSPEX (vec3 p, vec3 d, vec3 dobjSDFp) {\n    return pow(\n        clamp(\n            dot(\n                reflect(\n                    d,\n                    dobjSDFp\n                ),\n            \tsund()\n            ),\n        \t0.,\n        \t1.\n        ),\n        10.\n    );\n}\n\nfloat waterSPEX (vec3 p, vec3 d, vec3 dwaterSDFp) {\n    return 0.*pow(\n        clamp(\n            dot(\n                reflect(\n                    d,\n                    dwaterSDFp\n                ),\n            \tsund()\n            ),\n        \t0.,\n        \t1.\n        ),\n        1.\n    );\n}\n\nvec3 march (vec3 p, vec3 d) {\n    vec3 cam = p;\n    float objSDFp;\n    float waterSDFp;\n    float auroraSDFp;\n    float SDFp;\n    \n    vec3 dobjSDFp;\n    vec3 dwaterSDFp;\n    \n    vec3 TEXp;\n    vec3 finalcol = vec3(0.);\n    float shiny = 1.;\n    float rxcount = 0.;\n    float closestaurora = 1e7;\n    \n    for (int i=0; i<460; ++i) {\n        objSDFp = objSDF(p);\n        waterSDFp = abs(waterSDF(p));\n        // auroraSDFp = auroraSDF(p);\n        SDFp = min(objSDFp, waterSDFp);\n        // SDFp = min(SDFp, auroraSDFp);\n        closestaurora = min(closestaurora, auroraSDFp);\n        if (SDFp < mix(1e-4, 1e-2, min(length(p-cam)/20., 0.) )) {\n            p = p+d*SDFp*.95;\n            // if (auroraSDFp < waterSDFp && auroraSDFp < objSDFp) {\n            //     break;\n            // }\n            // else {\n                if (objSDFp < waterSDFp) {\n                    dobjSDFp = dobjSDF(p);\n                    TEXp = objTEX(p, d, dobjSDFp, arg);\n                    finalcol = finalcol+clamp(TEXp*.4+objSPEX(p, d, dobjSDFp), 0., 1.)*shiny;\n                    shiny *= .6;\n                    d = reflect(d, dobjSDFp);\n                    p = p+d*.2;\n                    ++rxcount;\n                    ++rxcount;\n                    //break;\n                }\n                else {\n                    dwaterSDFp = dwaterSDF(p);\n                    TEXp = waterTEX(p, d, dwaterSDFp);\n                    finalcol = finalcol+clamp(TEXp*.6+waterSPEX(p, d, dwaterSDFp), 0., 1.)*shiny;\n                    shiny *= 1.-.6;\n                    d = reflect(d, dwaterSDFp);\n                    p = p+d*smoothstep(.05, 1., length(p-cam)/50.);\n                    ++rxcount;\n                }\n            // }\n            if (rxcount > 2.) {\n                break;\n            }\n            if (p.y < -10. || p.y > 20.) {\n                break;\n            }\n        }\n        p = p+d*SDFp;\n        if (length(p-cam) > 170.) {\n            break;\n        }\n    }\n    // add the sky color\n    // float am = 1./(1.+closestaurora/3.)*clamp(1.-sqrt(p.y-30.+.1)/6., 0., 1.);\n    // vec3 acol = vec3(0., .8, .9);\n    // if (am > .8) {\n    //     acol = mix(acol, vec3(1.), (am-.8)/.2);\n    // }\n    // am *= .7;\n    // finalcol = finalcol+acol*shiny*am;\n    // shiny *= 1.-am;\n    \n    finalcol = finalcol+shiny*skyTEX(d);\n    \n    return finalcol;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec2 maus =   (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n    if (iMouse.x == 0.) {\n        maus.x = 0.;\n        maus.y = 0.;\n    }\n    vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n    // rotate\n    float dzy = atan(d.z, d.y)+maus.y*PI*.5*3.;\n    float dzyr = sqrt(d.z*d.z+d.y*d.y);\n    d.y = dzyr*cos(dzy);\n    d.z = dzyr*sin(dzy);\n    float dzx = atan(d.z, d.x)+maus.x*PI*2.;\n    float dzxr = sqrt(d.z*d.z+d.x*d.x);\n    d.x = dzxr*cos(dzx);\n    d.z = dzxr*sin(dzx);\n    \n    \n    vec3 retina = march(vec3(0., 2., arg*20.), d);\n    fragColor = vec4(retina, 1.);\n}\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l33zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 181, 181, 272], [274, 274, 309, 309, 618], [724, 724, 738, 887, 991], [1045, 1045, 1067, 1067, 1519], [1521, 1521, 1544, 1544, 1702], [1704, 1704, 1729, 1729, 1786], [1967, 1967, 1990, 1990, 2237], [2239, 2239, 2264, 2264, 2527], [2529, 2529, 2586, 2586, 3133], [3135, 3135, 3184, 3184, 3417], [3419, 3419, 3466, 3466, 3702], [3704, 3704, 3755, 3755, 3995], [3997, 3997, 4026, 4026, 6335], [6337, 6337, 6393, 6393, 7031]], "test": "ok"}
{"id": "3l3GD7", "name": "Decalled Floppy Tube", "author": "dr2", "description": "Surface coordinates", "tags": ["torus", "coordinates", "decal"], "likes": 17, "viewed": 833, "published": "Public API", "date": "1576483133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Decalled Floppy Tube\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Provides coordinates useful for flexible shapes based on generalized toroidal\n  sections (e.g. fish bodies, snakes, wings); preferable to sheared coordinates\n  or multiple linear segements.\n*/\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, dLoop, sLoop, rCyl, sDir;\nint idObj;\nconst int idTube = 1, idBase = 2, idGrnd = 3;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b;\n  float dMin, d, hBase, aLoop, lb;\n  dMin = dstFar;\n  d = p.y;\n  DMIN (idGrnd);\n  hBase = 1.6;\n  p.x *= sDir;\n  aLoop = 0.25 * pi / sLoop;\n  q = p;\n  q.y -= 2. * hBase;\n  d = PrSphDf (q, rCyl);\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n  b = vec2 (length (q.xy) - dLoop, q.z);\n  lb = length (b);\n  d = min (d, max (lb - rCyl, dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)))));\n  d = min (d, PrSphDf (vec3 (Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.), q.z), rCyl));\n  if (d < dMin) {\n    dMin = d;\n    idObj = idTube;\n    qHit = vec3 (vec2 (atan (q.y, - q.x) * dLoop / (0.25 * pi), atan (b.x, b.y)) / pi, lb);\n  }\n  q = p;\n  q.y -= hBase - 0.5 * rCyl;\n  d = PrCylDf (q.xzy, rCyl, hBase - 0.5 * rCyl);\n  DMIN (idBase);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn;\n  vec2 p, ip;\n  float nDotL, sh, c;\n  vn = ObjNf (ro);\n  nDotL = max (dot (vn, ltDir), 0.);\n  if (idObj == idTube) {\n    if (qHit.z < 0.7 * rCyl) {\n      col4 = vec4 (1., 1., 0., 0.2) * (0.2 + 0.8 * smoothstep (0.1, 0.2, qHit.z / rCyl));\n    } else {\n      p = qHit.xy * vec2 (2. * sqrt3, 3.);\n      ip = PixToHex (p);\n      c = mod (dot (mod (2. * ip + ip.yx, 3.), vec2 (1., 2.)), 3.);\n      col4 = vec4 (1., 0., 0., 0.2);\n      if (c == 1.) col4.rgb = col4.gbr;\n      else if (c == 2.) col4.rgb = col4.brg;\n      col4 = mix (vec4 (1., 1., 0., 0.2), col4, smoothstep (0.05, 0.1,\n         HexEdgeDist (p - HexToPix (ip))));\n    }\n    nDotL *= nDotL;\n  } else if (idObj == idBase) {\n    col4 = vec4 (0.8, 0.8, 0.7, 0.1);\n  } else if (idObj == idGrnd) {\n    col4 = vec4 (0.4, 0.4, 0.45, 0.05);\n  }\n  sh = ObjSShadow (ro, ltDir);\n  col4.rgb = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n     0.2 * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  return col4.rgb;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float dstObj, tCyc, t;\n  tCyc = 10.;\n  t = tCur / tCyc;\n  sLoop = 1./3. + 200. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (t, 1.)), 8.);\n  sDir = 1.; // 2. * floor (mod (t, 2.)) - 1.;\n  dLoop = 6. * sLoop;\n  rCyl = 0.8;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col = ObjCol (ro, rd);\n   } else {\n    col = vec3 (0.5);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.1 * tCur;\n  }\n  el = clamp (el, -0.4 * pi, 0. * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 6., -25.);\n  zmFac = 3.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 70.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3GD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[750, 750, 772, 772, 1593], [1595, 1595, 1628, 1628, 1826], [1828, 1828, 1849, 1849, 2046], [2048, 2048, 2085, 2085, 2307], [2309, 2309, 2333, 2333, 2563], [2565, 2565, 2589, 2589, 2649], [2651, 2651, 2679, 2679, 2759], [2761, 2761, 2793, 2793, 3800], [3802, 3802, 3837, 3837, 4265], [4282, 4282, 4335, 4335, 5390], [5392, 5392, 5425, 5425, 5452], [5454, 5454, 5496, 5496, 5547], [5549, 5549, 5585, 5585, 5791], [5793, 5793, 5823, 5823, 5936], [5938, 5938, 5995, 5995, 6078]], "test": "ok"}
{"id": "3l3GRN", "name": "Orb neon", "author": "ad_lucem", "description": "Orb neon", "tags": ["orb", "neon"], "likes": 2, "viewed": 109, "published": "Public", "date": "1575685797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime\n#define PI 3.141593\n#define E 0.001\n#define R iResolution\n#define MD 100.\n#define GS 10.\n\nmat2 rot(float a){ float ca = cos(a); float sa = sin(a); return mat2(ca,sa,-sa,ca);}\nfloat cylSDF(vec3 p, float r){return length(p.yz)-r;}\n\nfloat kifs(vec3 p)\n{\n  for(int i = 0; i < 10; ++i)\n  {    \n    float t1 = T;\n    \n    p.xy *=rot(t1*0.2);\n    p.yz *= rot(t1*.07);\n \n    p = abs(p);\n    p-= vec3(.1,.2,.1);\n  }\n  \n  float g = 1.0;\n  p.x = mod(p.x-g*.5,g)-g*.5;\n  \n  return cylSDF(p, .05);\n}\n\nfloat sceneSDF(vec3 p)\n{\n  return kifs(p); \n}\n\nfloat raycast(in vec3 p,in vec3 dir,out float att)\n{\n  float d = 0.;\n  for(int i= 0; i <= 256; ++i)\n  {\n   d = sceneSDF(p);\n   if(d <= E) break;\n   if(d > MD) break;\n   p += dir * d;\n   att+= .1/(abs(d)+.1);\n  }\n\n  return d;\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n  vec2 uv = (2.*U-R.xy)/R.y;\n  vec4 color = vec4(0);\n  \n  vec3 eye = vec3(0,0,-3.8);\n  \n  vec3 dir = normalize(vec3(uv,1));\n  dir.xy *= rot(T*.2);\n  \n  float att = 0.;\n  \n  float d = raycast(eye, dir, att);\n  \n  color.rgb += att*.06 * vec3(.05,.03,.95);\n  color.rgb = pow(color.rgb, vec3(0.4545));\n  color *= 1.1-length(uv/GS); \n  \n  O = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3GRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 124, 124, 190], [191, 191, 221, 221, 244], [246, 246, 266, 266, 502], [504, 504, 528, 528, 549], [551, 551, 603, 603, 777], [779, 779, 818, 818, 1165]], "test": "ok"}
{"id": "3l3Gz8", "name": "Hyperspace Jump, ROTJ Style", "author": "blue_max", "description": "Trying to make an effect that is closer to what we see in the original trilogies. Adapted from https://www.shadertoy.com/view/MlKBWw. Soon to be added to X-Wing Alliance. Use the mouse to look around.\n", "tags": ["tunnel", "starfield", "hyperspace", "starwars"], "likes": 5, "viewed": 352, "published": "Public", "date": "1575657564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tSimplified and adapted from:\n\thttps://www.shadertoy.com/view/MlKBWw\n*/\n\n#define TAU 6.28318\n\n// Uncomment the following line to get a flare in the center (Disney-style)\n#define FLARE 1\n\n// The way this shader works is by looking at the screen as if it were a disk and then\n// this disk is split into a number of slices centered at the origin. Each slice renders\n// a single trail. So this setting controls the overall density of the effect:\n#define NUM_SLICES 125.0\n//#define NUM_SLICES 50.0\n\n// Each trail is rendered within its slice; but to avoid generating regular patterns, we\n// randomly offset the trail from the center of the slice by this amount:\nconst float MAX_SLICE_OFFSET = 0.4;\n\n// This is the length of the effect in seconds:\nconst float T_MAX = 2.0;\n// T_JUMP is in normalized [0..1] time: this is the time when the \n// trails zoom out of view because we've jumped into hyperspace:\nconst float T_JUMP = 0.75;\n// This is the speed during the final jump:\nconst float jump_speed = 15.0;\n\n// I've noticed that the effect tends to have a bluish tint. In this \n// shader, the blue color is towards the start of the trail, and the \n// white color towards the end:\nconst vec3 blue_col = vec3(0.3, 0.3, 0.5);\n//const vec3 white_col = vec3(0.95, 0.95, 1.0);\nconst vec3 white_col = vec3(0.85, 0.85, 0.9);\nconst vec3 flare_col = vec3(0.9, 0.9, 1.4);\n\nfloat array_mix(in float[4] array, in int n, float index)\n{\n    float dec = fract(index);\n    int i = int(floor(index));\n    if (i >= n - 1)\n        return array[i];\n    else\n    \treturn mix(array[i], array[i+1], dec);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ring;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*\n\tLens flare from: https://www.shadertoy.com/view/XdfXRX\n\tand: https://www.shadertoy.com/view/4sX3Rs \n*/\nvec3 lensflare(vec3 uv, vec3 pos, float flare_size, float ang_offset)\n{\n    float z = uv.z / length(uv.xy);\n\tvec2 main = uv.xy - pos.xy;\n    float dist = length(main);\n\tfloat num_points = 2.71;\n    float disk_size = 0.2;\n    float inv_size = 1.0 / flare_size;\n\tfloat ang = atan(main.y, main.x) + ang_offset;\n    float fade = (z < 0.0) ? -z : 1.0;\n    //if (z < 0.0) return vec3(0.0);\n    \n    float f0 = 1.0/(dist * inv_size + 1.0);\n    f0 = f0 + f0 * (0.1 * sin((sin(ang*2.0 + pos.x)*4.0 - cos(ang*3.0 + pos.y)) * num_points) + disk_size);\n    if (z < 0.0)\n\t\treturn clamp(mix(vec3(f0), vec3(0.0), 0.75 * fade), 0.0, 1.0);\n    else\n        return vec3(f0);\n}\n\nvec3 cc(vec3 color, float factor, float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color, vec3(w) * factor, w * factor2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float time = mod(iTime, T_MAX);\n    float t = time / T_MAX;\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p += vec2(0, -0.2); // In XWA the aiming HUD is not at the screen's center\n    \n    float ta = TAU * mod(iTime, 8.0) / 8.0;\n    //ta = 12.0 * 0.01745;\n    \n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    \n    /*\n    mat3 mZ = mat3(\n        cos(az), sin(az), 0.0,\n       -sin(az), cos(az), 0.0,\n            0.0,     0.0, 1.0\n    );\n    */\n    mat3 m = mX * mY;\n    //p += vec2(0.0, -0.1); // + 12.0*m;\n    //p = (mX * vec3(p, 1.0)).xy;\n    \n    float p_len = length(p);\n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    \n    // The following line reverts the effect:\n    //t = 1.0 - t;\n    // DEBUG\n    //t = 0.5;\n    // DEBUG\n    \n    //float[4] flare_size;\n    //flare_size[0] = 0.0\n    \n    float trail_start, trail_end;\n    // Fade all the trails into view from black to a little above full-white:\n    float fade = clamp(mix(0.1, 1.1, t * 2.0), 0.0, 2.0);\n    //fade = 1.0;\n    \n    // Each slice renders a single trail; but we can render multiple layers of\n    // slices to add more density and randomness to the effect:\n\tfor(float i = 0.0; i < 80.0; i++) \n    //float i = 1.0;\n    {\n        vec3 trail_color = vec3(0.0);\n\t\t//float angle = (atan(v.y, v.x) / 3.141592 / 3.0 + 0.5);\n        float angle = atan(v.y, v.x) / 3.141592 / 2.0 + 0.13 * i;\n        \n\t\tfloat slice = floor(angle * NUM_SLICES);\n        float slice_fract = fract(angle * NUM_SLICES);\n        \n        // Don't center the trail in the slice: wiggle it a little bit:\n        float slice_offset = MAX_SLICE_OFFSET * \n            rand(vec2(slice, 4.0 + i * 25.0)) - (MAX_SLICE_OFFSET / 2.0);\n        \n        \n        // Without dist, all trails get stuck to the walls of the\n        // tunnel.\n        //float dist = rand(vec2(slice, 1.0 + i * 10.0)) * (2.0 + i);\n        float dist = 10.0 * rand(vec2(slice, 1.0 + i * 10.0)) - 5.0;\n        float z = dist * v.z / length(v.xy);\n        // When dist is negative we have to invert a number of things:\n        float f = sign(dist);\n        if (f == 0.0) f = 1.0;\n        // This is the speed of the current slice\n        float fspeed = f * (0.1 * rand(vec2(slice, 1.0 + i * 10.0)) + i * 0.01);\n        float fjump_speed = f * jump_speed;\n        \n\t\t//trail_start = 5.0 + 2.0 * rand(vec2(slice, 0.0 + i * 10.0));\n        trail_start = 10.0 * rand(vec2(slice, 0.0 + i * 10.0)) - 5.0;\n        \n        // Accelerate the trail_start:\n        trail_start -= mix(0.0, fjump_speed, smoothstep(T_JUMP, 1.0, t));\n        trail_end = trail_start - t * fspeed;\n        \n        //float trail_x = smoothstep(trail_start, trail_end, p_len);\n        float trail_x = smoothstep(trail_start, trail_end, z);\n        trail_color = mix(blue_col, white_col, trail_x);\n        \n        // This line computes the distance from the current pixel, in \"slice-coordinates\"\n        // to the ideal trail centered at the slice center. The last argument makes the lines\n        // a bit thicker when they reach the edges as time progresses.\n        float h = sdLine(\n            vec2(slice_fract + slice_offset, z),\n            vec2(0.5, trail_start), \n            vec2(0.5, trail_end),\n            //0.0);\n\t       \tmix(0.0, 0.015, t * z));\n        \n        //h = smoothstep(0.075, 0.01, abs(h) - 0.05);\n        // This threshold adds a \"glow\" to the line. This glow grows with\n        // time:\n        //float threshold = mix(0.04, 0.175, smoothstep(0.0, 0.5, t));\n        float threshold = 0.09;\n        h = (h < 0.01) ? 1.0 : 0.85 * smoothstep(threshold, 0.0, abs(h));\n        \n        trail_color *= fade * h;\n        // DEBUG\n        // This part displays the size of each slice.\n        //float r = 0.0;\n        //if (trail_start <= p_len && p_len <= trail_end)\n        //    r = 1.0;\n        //trail_color = vec3(h, h, h);\n        // DEBUG\n        \n        // Accumulate this trail with the previous ones\n        color = max(color, trail_color);\n\t}\n\n#ifdef FLARE\n    // Add the disk at the center to transition into the hyperspace\n    // tunnel\n    float flare_size = mix(0.0, 0.1, smoothstep(0.35, T_JUMP + 0.2, t));\n    flare_size += mix(0.0, 20.0, smoothstep(T_JUMP + 0.05, 1.0, t));\n    vec3 flare = flare_col * lensflare(v, vec3(0.0), flare_size, t);\n    color += cc(flare, 0.5, 0.1);\n    //color += flare;\n    // Whiteout\n    color += mix(0.0, 1.0, smoothstep(T_JUMP + 0.1, 1.0, t));\n#else\n    // Whiteout\n    color += mix(0.0, 1.0, smoothstep(T_JUMP - 0.0, 1.0, t));\n#endif\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3Gz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1581, 1581, 1645, 1645, 1771], [1773, 1773, 1793, 1793, 1865], [1867, 1974, 2045, 2045, 2632], [2634, 2634, 2702, 2702, 2791], [2793, 2793, 2848, 2848, 7854]], "test": "ok"}
{"id": "3l3GzN", "name": "Hyperspace Exit, ROTJ Style", "author": "blue_max", "description": "The Hyperspace Exit effect, ROTJ style. Based on https://www.shadertoy.com/view/MlKBWw. Use the mouse to look around.", "tags": ["hyperspace", "starwars", "trails"], "likes": 7, "viewed": 298, "published": "Public", "date": "1575700432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tSimplified and adapted from:\n\thttps://www.shadertoy.com/view/MlKBWw\n*/\n\n#define TAU 6.28318\n\n// The way this shader works is by looking at the screen as if it were a disk and then\n// this disk is split into a number of slices centered at the origin. Each slice renders\n// a single trail. So this setting controls the overall density of the effect:\n#define NUM_SLICES 125.0\n//#define NUM_SLICES 50.0\n\n// Each trail is rendered within its slice; but to avoid generating regular patterns, we\n// randomly offset the trail from the center of the slice by this amount:\nconst float MAX_SLICE_OFFSET = 0.4;\n\n// This is the length of the effect in seconds:\nconst float T_MAX = 2.0;\n// T_JUMP is in normalized [0..1] time: this is the time when the trails zoom out of view\n// because we've jumped into hyperspace:\nconst float T_JUMP = 0.90;\n// This is the speed during the final jump:\nconst float jump_speed = 5.0;\n\n// I've noticed that the effect tends to have a bluish tint. In this shader, the blue color\n// is towards the start of the trail, and the white color towards the end:\nconst vec3 blue_col = vec3(0.3, 0.3, 0.6);\nconst vec3 white_col = vec3(0.8, 0.8, 0.95);\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ring;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float time = mod(iTime, T_MAX);\n    float t = time / T_MAX;\n\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float p_len = length(p);    \n    p += vec2(0, -0.2); // In XWA the aiming HUD is not at the screen's center\n    \n    float ta = TAU * mod(iTime, 8.0) / 8.0;\n    //ta = 12.0 * 0.01745;\n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    //ay += 135.0;\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    mat3 m = mX * mY;\n    \n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    \n    float trail_start, trail_end, trail_length = 1.0, trail_x;\n    // Fade all the trails into view from black to a little above full-white:\n    float fade = mix(1.4, 0.0, smoothstep(0.65, 0.95, t));\n    //float fade = 1.2;\n    \n    // Each slice renders a single trail; but we can render multiple layers of\n    // slices to add more density and randomness to the effect:\n\tfor(float i = 0.0; i < 60.0; i++) \n    //float i = 1.0;\n    {\n        vec3 trail_color = vec3(0.0);\n\t\t//float angle = (atan(v.y, v.x) / 3.141592 / 3.0 + 0.5);\n        float angle = atan(v.y, v.x) / 3.141592 / 2.0 + 0.13 * i;\n        \n\t\tfloat slice = floor(angle * NUM_SLICES);\n        float slice_fract = fract(angle * NUM_SLICES);\n        // Don't center the trail in the slice: wiggle it a little bit:\n        float slice_offset = MAX_SLICE_OFFSET * \n            rand(vec2(slice, 4.0 + i * 25.0)) - (MAX_SLICE_OFFSET / 2.0);\n        // Without dist, all trails get stuck to the walls of the\n        // tunnel. Allowing dist to be negative gives a more homogeneous \n        // coverage of all the space, both in front and behind the \n        // camera.\n        float dist = 10.0 * rand(vec2(slice, 1.0 + i * 2.0)) - 5.0;\n        float z = dist * v.z / length(v.xy);\n        \n        // When dist is negative we have to invert a number of things:\n        float f = sign(dist);\n        if (f == 0.0) f = 1.0;\n        // This is the speed of the current slice\n        float fspeed = f * (rand(vec2(slice, 1.0 + i * 0.1)) + i * 0.01);\n        float fjump_speed = f * jump_speed;\n        float ftrail_length = f * trail_length;\n        \n        trail_end = 10.0 * rand(vec2(slice, i + 10.0)) - 5.0;\n\t\ttrail_end -= t * fspeed;\n        \n        // Adding to the trail pushes it \"back\": Z+ is into the screen\n        // away from the camera... unless f is negative, then we invert\n        // the rules\n        trail_start = trail_end + ftrail_length;\n        if (f >= 0.0) {\n            // Shrink the trails into their ends:\n            trail_start = max(trail_end,\n                              trail_start - (t * fspeed) - \n                                mix(0.0, fjump_speed, \n                                                smoothstep(0.5, 1.0, t))\n                              );\n            //float trail_x = smoothstep(trail_start, trail_end, p_len);\n        } else {\n            // Shrink the trails into their ends:\n            trail_start = min(trail_end,\n                              trail_start - (t * fspeed) -\n                                mix(0.0, fjump_speed, \n                                                smoothstep(0.5, 1.0, t))\n                              );\n        }\n        trail_x = smoothstep(trail_start, trail_end, z);\n        trail_color = mix(blue_col, white_col, trail_x);\n        \n        // This line computes the distance from the current pixel, in \"slice-coordinates\"\n        // to the ideal trail centered at the slice center. The last argument makes the lines\n        // a bit thicker when they reach the edges as time progresses.\n        float h = sdLine(\n            vec2(slice_fract + slice_offset, z),\n            vec2(0.5, trail_start), \n            vec2(0.5, trail_end),\n        \tmix(0.0, 0.015, z));\n        \n        // This threshold adds a \"glow\" to the line. This glow grows with\n        // time:\n        float threshold = mix(0.12, 0.0, smoothstep(0.5, 0.8, t));\n        //float threshold = 0.12;\n        h = (h < 0.01) ? 1.0 : 0.75 * smoothstep(threshold, 0.0, abs(h));\n        \n        trail_color *= fade * h;\n        // DEBUG\n        // This part displays the size of each slice.\n        //float r = 0.0;\n        //if (trail_start <= p_len && p_len <= trail_end)\n        //    r = 1.0;\n        //trail_color = vec3(h, h, h);\n        // DEBUG\n        \n        // Accumulate this trail with the previous ones\n        color = max(color, trail_color);\n\t}\n    // Whiteout\n    color += mix(1.0, 0.0, smoothstep(0.0, 0.2, t));\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3GzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1167, 1167, 1231, 1231, 1357], [1359, 1359, 1379, 1379, 1451], [1454, 1454, 1509, 1509, 6410]], "test": "ok"}
{"id": "3lc3D4", "name": "Polyp 3", "author": "indigofracture", "description": "noise", "tags": ["jellyfish"], "likes": 2, "viewed": 64, "published": "Public", "date": "1576268325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265\n\n#define LIMBS 8\n#define JOINTS 32\n#define LIMB_LENGTH 0.025*0.25\n#define FATNESS 0.7\n\n// Reverse colors and thickness for cool effect.\n//#define REVERSED\n\n//#define DANCE\n\n\n// Optimized Simplex noise functions from Makio64: https://www.shadertoy.com/view/4sdGD8\n\n/*lowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}*/\n\n//#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0. ).x;\n}\n\n/*float hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}*/\n\n\n// Draw line and circle functions from Loeizd: https://www.shadertoy.com/view/4ljfRD\n\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nfloat drawCircle(vec2 p, float d, vec2 uv)\n{\n    return (distance(p, uv) <= d) ? 1. : 0.;\n}\n\n// Basic map function from: https://stackoverflow.com/questions/17134839/how-does-the-map-function-in-processing-work\n\nfloat map(float value, \n                              float istart, \n                              float istop, \n                              float ostart, \n                              float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\nvec3 bodycolor1 = vec3(1.0,0.8,0.8);\nvec3 bodycolor2 = vec3(0.2,0.0,0.3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*45.; //Pro Tipâ¢: multipluy time to go faster!\n\n    vec2 noise_vec = vec2(-t * 0.05, t * 0.05);\n    \n    float lines = 0.;\n    \n    vec2 init = vec2(0.5+sin(t*0.01) * 0.3, 0.5+cos(t*0.01) * 0.3);\n    #ifdef DANCE\n    init += noise(noise_vec)*0.15;\n    #endif\n    //vec2 noisebump = vec2(sin(noise(noise_vec)), cos(noise(noise_vec))) * 0.4;\n    //init += noisebump;\n    \n    #ifndef REVERSED\n    // Main fadeoff mapping\n    float fadeoff = map(distance(init,uv),0.,LIMB_LENGTH*float(JOINTS),FATNESS,0.0);//((LIMB_LENGTH*float(JOINTS))-distance(init, uv));\n\t#else\n    // Reversed fadeoff mapping (gives a cool widening effect)\n    float fadeoff = map(distance(init,uv),0.,LIMB_LENGTH*float(JOINTS),0.0,FATNESS);\n    #endif\n    \n    for(int i = 0; i < LIMBS; ++i) {\n            vec2 prevpos = init;\n        for(int j = 0; j < JOINTS; ++j) {\n            float theta = map(noise(noise_vec), -1., 1., pi, -pi) + (t*0.01);\n            //float theta = map(noise(noise_vec), -1., 1., pi/3.-(pi/4.), -pi/3.-(pi/4.)) + (t*0.01);\n            noise_vec += float(j);\n            vec2 nextpos = prevpos + (vec2(sin(theta), cos(theta)) * LIMB_LENGTH);\n            if(lines == 0.)\n            \tlines += drawLine(prevpos, nextpos, uv, fadeoff*16.) * fadeoff;//* map(float(j), 0., float(JOINTS), 1.0, 0.0);\n            prevpos = nextpos;\n        }\n    }\n    \n    if(lines == 0.)\n        lines += drawCircle(init, .02+(sin(t*0.1) + 1.)*0.02 * noise(noise_vec), uv) * fadeoff;\n    \n    vec3 col = vec3(0.,0.,0.);\n    col.r = map(lines, 1.0, 0.0, bodycolor1.r, bodycolor2.r);\n    col.g = map(lines, 1.0, 0.0, bodycolor1.g, bodycolor2.g);\n    col.b = map(lines, 1.0, 0.0, bodycolor1.b, bodycolor2.b);\n    \n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lc3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1097, 1097, 1123, 1123, 1754], [1758, 1758, 1784, 1784, 1933], [2511, 2511, 2564, 2564, 2976], [2978, 2978, 3022, 3022, 3069], [3190, 3190, 3392, 3392, 3472], [3550, 3550, 3607, 3607, 5399]], "test": "error"}
{"id": "3lc3Rr", "name": "Raymarching experiment D1", "author": "MeDope", "description": " ", "tags": ["raymarching", "kifs"], "likes": 7, "viewed": 160, "published": "Public", "date": "1575921096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Thanks IQ for distance functions\n//http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n//Thanks BigWings for KIFS Fractals explained\n//https://www.youtube.com/watch?v=il_Qg9AqQkE&t=\n\n#define pi 3.14159\n#define SURF_DIST .001\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n\nconst float eps = 0.001;\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat aaStep(float edge, float gradient)\n{\n    float halfPix = fwidth(gradient) / 2.0;\n    float low = edge - halfPix;\n    float hi  = edge + halfPix;\n    return clamp((gradient - low) / (hi - low), 0.0, 1.0);\n}\n\nvec2 KIFS(vec2 uv)\n{\n    uv *= 1.5;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    uv.x = abs(uv.x);\n    float angle = 5./6. * pi;\n    uv.y += tan(angle)*0.5;\n    vec2 norm = vec2(sin(angle), cos(angle));\n    float dist = dot(uv - vec2(0.5, 0.0), norm);\n    uv -= norm * 2. * max(dist, 0.);\n    angle = 2./3. * pi * (1. - mouse.y);\n    norm = vec2(sin(angle), cos(angle));\n\tuv.x += 0.5;\n    float scale = 1.0;\n    for(int i = 0; i < 4; i++){\n        scale *= 3.;\n        uv *= 3.;\n    \tuv.x -= 1.5;\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv *= rot(iTime*0.2 + mouse.x*10.);\n        uv -= norm * 2. * min(dot(uv, norm), 0.);\n    }\n    uv/= scale;\n    return uv;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf(vec3 p)\n{\n    p *= 0.5;\n    float f = max(min(abs(KIFS(p.xy).y), 1.0), sdBox(p, vec3(0.5, 0.5, 0.05))) - 0.0005;\n\treturn min(f, -p.z + 0.1);\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0 , d = MAX_DIST, it = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        d = sdf(ro+t*rd);\n     \tt += d;\n        if(abs(d) < SURF_DIST || t > MAX_DIST) break;\n        it += 1.0;\n    }\n    return vec2(t, it/float(MAX_STEPS));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld)\n{\n    p += 2. * eps * n;\n    float t = 0.0, d = MAX_DIST;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        d = sdf(p + t * ld);\n        t += d;\n        if (abs(d) < eps || t > 3.0) break;\n    }\n    return t <= 3.0 ? 0.05 : 1.0;\n}\n\nvec3 getNorm(vec3 p)\n{\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(sdf(p+e.xyy)-sdf(p-e.xyy), sdf(p+e.yxy)-sdf(p-e.yxy), sdf(p+e.yyx)-sdf(p-e.yyx)));\n}\n\nvec3 light(vec3 p)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(vec3(-1.0,1.0,-5.0));\n    vec3 n = getNorm(p);\n    float diff = max(dot(n, ld), 0.);\n    diff *= getShadow(p, n, ld);\n    col += diff;\n    return col;\n}\n\nvec3 bg(vec2 uv)\n{\n    vec2 ouv = uv;\n   \tuv.x += sin(ouv.y*40. + 3.5*iTime) * 0.01;\n    uv.y += sin(ouv.x*40. + 5.5*iTime) * 0.005;\n    uv = KIFS(uv);\n\tfloat l = abs(sin(uv.y*10.+iTime));\n    l = pow(0.1/l, 2.0);\n    return vec3(l) * vec3(0.07,0.25, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0., 0., -1.5);\n    vec3 col;\n\tvec2 m = march(ro, rd);\n    vec3 p = ro + rd * m.x;\n    col += p.z > 0.1 ? (light(p) * pow(0.01/(abs(KIFS(p.xy*0.5))).y, 2.2)) * vec3(0.2, 0.4, 2.3) + light(p) * 0.1 : light(p);\n    col += (m.y*m.y*m.y*m.y*m.y)*vec3(0.2, 0.4, 2.3)*100.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lc3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 337, 337, 389], [391, 391, 433, 433, 602], [604, 604, 624, 624, 1306], [1308, 1308, 1339, 1339, 1426], [1428, 1428, 1447, 1447, 1580], [1582, 1582, 1612, 1612, 1860], [1862, 1862, 1904, 1904, 2136], [2138, 2138, 2160, 2160, 2298], [2300, 2300, 2320, 2320, 2523], [2525, 2525, 2543, 2543, 2783], [2785, 2785, 2842, 2842, 3264]], "test": "timeout"}
{"id": "3lc3WN", "name": "Stellar magnetic field", "author": "tdhooper", "description": "See also https://t.co/THbz9C33CN?amp=1", "tags": ["field", "magnetic"], "likes": 44, "viewed": 1021, "published": "Public API", "date": "1576281478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CORRECT_STREAMLINES\n\n#define saturate(x) clamp(x, 0., 1.)\n\nconst float PI = 3.1419;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec2 force(vec2 p, vec2 pole) {\n    // return normalize(p - pole) / distance(p, pole);\n    // optim by Fabrice:\n  \tp -= pole;\n\treturn p / dot(p,p);\n}\n\nfloat calcVelocity(vec2 p) {\n  \tvec2 velocity = vec2(0);\n  \tvec2 pole;\n    vec2 f;\n  \tfloat o, r, m;\n \tfloat flip = 1.;\n    float j = 0.;\n  \tconst float limit = 15.;\n  \tfor (float i = 0.; i < limit; i++) {\n    \tr = rand(i / limit) - .5;\n    \tm = rand(i + 1.) - .5;\n    \tm *= (iTime+(23.78 * 1000.)) * 2.;\n    \to = i + r + m;\n    \tpole = vec2(\n      \t\tsin(o / limit * PI * 2.),\n      \t\tcos(o / limit * PI * 2.)\n    \t);\n    \tf = force(p, pole);\n        flip *= -1.;\n    \tvelocity -= f * flip;\n    \tj += atan(f.x, f.y) * flip;\n  \t}  \n  \tvelocity = normalize(velocity);\n    #ifdef CORRECT_STREAMLINES\n    \treturn j;\n   \t#endif\n    return atan(velocity.x, velocity.y);\n}\n\nvec2 dir(float a) {\n\treturn vec2(sin(a), cos(a));\n}\n\nfloat calcDerivitive(float a, vec2 p) {\n    vec2 v = dir(a);\n    float n = 2. / iResolution.x;\n    float d = 0.;\n\td += length(v - dir(calcVelocity(p + vec2(0,n))));\n    d += length(v - dir(calcVelocity(p + vec2(n,0))));\n    d += length(v - dir(calcVelocity(p + vec2(n,n))));\n\td += length(v - dir(calcVelocity(p + vec2(n,-n))));\n    d /= 4.;\n    return d;\n}\n\nfloat spacing = 1./30.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.x;\n\tp *= 3.;\n    float a = calcVelocity(p);\n    float deriv = calcDerivitive(a, p);\n    a /= PI * 2.;\n    //fragColor = vec4(vec2(sin(atan(v.x, v.y)), cos(atan(v.x, v.y))) * .5 + .5, 0, 0); return;\n    //fragColor = vec4(1.-abs(a)*2.); return;\n    //a = result.z;\n    float lines = fract(a / spacing);\n    // create stripes\n    lines = min(lines, 1. - lines) * 2.;\n    // thin stripes into lines\n   \tlines /= deriv / spacing;\n    // maintain constant line width across different screen sizes\n   \tlines -= iResolution.x * .0005;\n    // don't blow out contrast when blending below\n    lines = saturate(lines);\n\n    float disc = length(p) - 1.;\n    disc /= fwidth(disc);\n    disc = saturate(disc);\n    lines = mix(1. - lines, lines, disc);\n    lines = pow(lines, 1./2.2);\n    fragColor = vec4(lines);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lc3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 113, 113, 151], [153, 153, 184, 264, 302], [304, 304, 332, 332, 969], [971, 971, 990, 990, 1022], [1024, 1024, 1063, 1063, 1380], [1407, 1407, 1464, 1464, 2326]], "test": "ok"}
{"id": "3lc3zH", "name": "Infinite Cube Zoom", "author": "bitless", "description": "Another experiment with hexagons.\nPrevious was https://www.shadertoy.com/view/wdVSDy", "tags": ["2d", "cube", "zoom", "hexagon", "infinte"], "likes": 32, "viewed": 294, "published": "Public", "date": "1575554057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Infinite Cube Zoom\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define PI 3.1415926\n#define hash1( n ) fract(sin(n)*43758.5453)\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec4(0,23,21,0) ) )\n\nfloat grad(float a) {\n    float  sm = .005;\n    float f = 1./3.;\n    a = mod(a+1.,2.);\n    return mix(\n                    mix(.45 //SIDE1\n                       ,.65 //SIDE2\n                       , smoothstep (sm,-sm,abs(1.+f-a)-f)) \n                    ,.95 // BOTTOM-TOP\n                    , smoothstep (f+sm, f-sm, 1.-abs(1.-a))); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,st = (g+g-r)/r.y;\n    st += st * length(st)*.1;\n\n    float a = atan(st.x,st.y)/PI\n\t\t,T = iTime;\n\n    float g1  = grad(a)\n        ,g2 = grad(a+1.);\n\n    float l = dot(abs(st),normalize(vec2(1.,1.73)));\n    l = log2(max(l,abs(st.x)))-T;\n    float fl = fract(l);\n    \n    float sm = fwidth(l)*1.5;\n\n    vec4 c = hue(a+T*.1)\n        ,c2 = mix(hue(hash1(floor(l)-1.)),c,.3)\n        ,c3 = mix(hue(hash1(floor(l)+1.)),c,.3);\n    c = mix(hue(hash1(floor(l))),c,.3);\n\n    if (mod(l,2.)<1.) {\n        c *= g1;\n        c2 *= g2;\n        c = mix(\n                mix(c2,c,smoothstep(-sm,sm,fl-.005))\n                ,c2*.75\n                ,smoothstep (.4, 0., fl)*0.25)\n           * (1.-smoothstep(.1,0.,abs(mod(a+1.,2./3.)-1./3.))*.25);}\n    else {\n        c *= g2;\n        c2 *= g1;\n        c3 *= g1;\n        c = mix(\n                mix(c2,c,smoothstep(-sm,sm,fl-.005))\n                ,c3*.5\n                ,smoothstep (.7, 1., fl)*.2);}\n\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lc3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 456, 477, 477, 795], [797, 797, 845, 845, 1836]], "test": "ok"}
{"id": "3lcGDH", "name": "Swimming Fish", "author": "SadCat", "description": "My first shader.", "tags": ["2d", "beginner"], "likes": 1, "viewed": 90, "published": "Public", "date": "1576124998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n\tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat Fish(vec2 uv, vec2 p, float scale, float f) {\n\tfloat c = 0.0;\n    \n    uv /= scale;\n    uv -= p;\n    \n    for (float a = 0.0 ; a < 1.0 ; a += 0.1) {\n        vec2 p = vec2(a-0.5, (0.8-a)*0.1*sin(2.0*M_PI*f*iTime+a));\n        float r = 0.27*sin(a*2.4) + max(0.25-a,0.0); \n        r *= r;\n        c += Circle(uv, p, r, 0.01);\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float c = 0.0;\n    \n    c += Fish(uv , vec2(0.0), .4, 1.0);\n    c += Fish(uv , vec2(0.8), .38, 1.2);\n    c += Fish(uv , vec2(-0.8), .36, 1.4);\n    c += Fish(uv , vec2(-0.8,0.8), .34, 1.6);\n    c += Fish(uv , vec2(0.8,-0.8), .32, 1.8);\n\n    // Output to screen\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 173, 173, 259], [261, 261, 312, 312, 616], [618, 618, 675, 725, 1132]], "test": "ok"}
{"id": "3lcGR2", "name": "Twitch: PS1 Singularity Jorts", "author": "blackle", "description": "don't ask. it was very silly.\n\nwatch the stream highlight here: https://www.twitch.tv/videos/523838443", "tags": ["denim", "livecode", "twitchstream", "jorts"], "likes": 2, "viewed": 299, "published": "Public API", "date": "1576810868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(k - abs(a-b), 0.)/k;\n  return min(a,b) - h*h*h*k/6.;\n}\n\nfloat skeleton(vec3 p) {\n  float thighgap = 1.2;\n  float l1 = linedist(p, vec3(0,thighgap,-1), vec3(0,thighgap,1))-1.;\n  float l2 = linedist(p, vec3(0,-thighgap,-1), vec3(0,-thighgap,1))-1.;\n  float waist = linedist(p, vec3(0,-1,1), vec3(0,1,1))-1.1;\n  return smin(waist, min(l1,l2), 0.2);\n}\n\nfloat loop(vec3 p, vec2 b) {\n  float c = length(p.xz*vec2(1.5,1))-b.x;\n  return 0.5*(length(vec2(c,p.y))-b.y);\n}\n\nfloat crungy = 0.;\nfloat scene(vec3 p) {\n  //the singularity\n  if (fract(iTime/15.) > 0.9) {\n  p.x += sin(p.y*4.+iTime*6.)*0.1;\n  p.y += sin(p.z*4.+iTime*6.)*0.1;\n  }\n  float skel = skeleton(p);\n  float l = min(loop(p-vec3(-1.15,-1,1.1), vec2(0.2,0.05)), loop(p-vec3(-1.15,1,1.1), vec2(0.2,0.05)));\n  float jort = linedist(vec2(skel, p.z), vec2(0,1.3),vec2(0,-1.3))-0.05;\n  crungy = l < jort ? 1. : 0.;\n  return min(l,jort);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.01);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid erot(inout vec3 p, vec3 ax, float ro) {\n  p = mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat diffuse(vec3 n, vec3 l) {\n  return max(dot(n, l), 0.);\n}\n\nfloat spec(vec3 n, vec3 c, vec3 l, float k) {\n  //TODO;\n  vec3 r = reflect(c, n);\n  return pow(max(dot(r, l), 0.), k);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat noise(vec2 p) {\n  vec2 id = floor(p);\n  vec2 co = fract(p);\n  return mix(mix(hash(id),hash(id+vec2(1,0)),co.x),mix(hash(id+vec2(0,1)),hash(id+vec2(1,1)),co.x), co.y)*0.5+0.5;\n}\n\nvec2 rot(vec2 p, float ro) {\n  return mat2(cos(ro),-sin(ro),sin(ro),cos(ro))*p;\n}\n\nfloat maze(vec2 p) {\n  vec2 id = floor(p);\n  vec2 co = fract(p)-0.5;\n  co.y *= sign(hash(id));\n  return abs(abs(co.x+co.y)-0.5)/sqrt(2.);\n}\n\nfloat perlin(vec2 p) {\n  float avg = 0.;\n  float acc = 0.;\n  for (int i = 0; i < 6; i++) {\n    vec2 off = vec2(hash(vec2(float(i), cos(float(i)))),hash(vec2(float(i)+1., cos(float(i)+2.))));\n    float r = acos(-1.)*hash(vec2(float(i*i), cos(float(i)+4.)));\n    avg += noise(rot(p,r)*float(i+1)+off*20.);\n    acc += 1.;\n  }\n  return avg/acc;\n}\n\nvec3 denim(vec2 tex) {\n  float horiz = perlin(tex*vec2(1,90));\n  float vert = perlin(tex*vec2(90,1));\n  float fray = max(smoothstep(-1.1,-1.2,tex.y),crungy);\n  vec3 d = pow(mix(vec3(0.25,0.5,0.7),vec3(1),fray),vec3(2.5))*mix(horiz,vert,fray*0.5+0.5)*mix(0.2,1.5,perlin(rot(tex,0.2)*0.7));\n  float fade = max(cos(iTime+tex.x*0.05)*3.-2.,0.);\n  return mix(d, vec3(0,1,0), fade*smoothstep(0.05,0.,maze(tex*4.)));\n}\n\nvec3 shade(vec3 n, vec3 p, vec3 cam) {\n  vec3 col = mix(denim(p.yz), denim(p.xz), n.y*n.y);\n  n += col*0.1; // alkama's suggestion :3\n  \n  float diff = diffuse(n, vec3(1,0,0)) + diffuse(n, normalize(vec3(-1,1,0))) + diffuse(n, normalize(vec3(-1,0,0)))*0.5 + diffuse(n, normalize(vec3(1,-2,1)))*0.25;\n  float specex = max(mix(4.,0.5,col.b*1.2-0.2),0.);\n  float spec = spec(n, cam, vec3(1,0,0), specex) + spec(n, cam, normalize(vec3(-1,1,0)), specex);\n  return col*diff/4. + spec*0.015;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(-5,0,0);\n  \n  erot(init, vec3(0,0,1), sin(iTime)*0.4);\n  erot(cam, vec3(0,0,1), sin(iTime)*0.4);\n  erot(init, vec3(0,1,0), cos(iTime)*0.4);\n  erot(cam, vec3(0,1,0), cos(iTime)*0.4);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 200; i++) {\n    float dist = scene(p);\n    if (abs(dist) < 0.001) { hit = true; break; }\n    if (distance(p,init) > 100.) break;\n    p += dist*cam;\n  }\n  vec3 n = norm(p);\n  if (hit) {\n    fragColor.xyz = sqrt(shade(n, p, cam));\n  } else {\n    crungy = 0.;\n    fragColor.xyz = sqrt(denim(uv*2.));\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcGR2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 234, 234, 323], [325, 325, 365, 365, 454], [456, 456, 495, 495, 566], [568, 568, 592, 592, 859], [861, 861, 889, 889, 973], [994, 994, 1015, 1035, 1401], [1403, 1403, 1422, 1422, 1535], [1537, 1537, 1581, 1581, 1642], [1644, 1644, 1675, 1675, 1706], [1708, 1708, 1753, 1763, 1828], [1885, 1885, 1905, 1905, 1985], [1987, 1987, 2008, 2008, 2169], [2171, 2171, 2199, 2199, 2252], [2254, 2254, 2274, 2274, 2393], [2395, 2395, 2417, 2417, 2737], [2739, 2739, 2761, 2761, 3150], [3152, 3152, 3190, 3190, 3638], [3640, 3640, 3697, 3697, 4436]], "test": "timeout"}
{"id": "3lcGWn", "name": "pyramid and barycenter", "author": "Rai", "description": "first project in glsl. would like some tips", "tags": ["3d"], "likes": 10, "viewed": 264, "published": "Public", "date": "1575992173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\nconst float str = 0.5;\nstruct object {\n    float x;\n    float y;\n};\n\nvec3 bary(vec3 a, vec3 b, vec3 c, vec2 p) {\n    vec2 v0 = b.xy - a.xy, v1 = c.xy - a.xy, v2 = p - a.xy;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    vec3 bc = abs(vec3(u,v,w));\n    return bc * clamp(1.0 - floor(bc.x + bc.y + bc.z - 0.0001), 0.0, 1.0);\n}\n\nfloat drawLine (vec3 p1, vec3 p2, vec2 uv, float a) {\n    float one_px = 1.0 / iResolution.x;\n    float d = distance(p1.xy, p2.xy);\n    float d_uv = distance(p1.xy, uv);\n    return 1.0-floor(1.0-(a*one_px)+ distance(mix(p1.xy, p2.xy, clamp(d_uv/d, 0.0, 1.0)), uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    object obj;\n    obj.x = iTime - iResolution.x;\n    \n    vec3 p1 = vec3(0.5 + sin(obj.x)       *0.2, 0.25 + cos(obj.x+PI)    *0.1, 0.5 + sin(obj.x));\n    vec3 p3 = vec3(0.5 + sin(obj.x+PI)    *0.2, 0.25 + cos(obj.x)       *0.1, 0.5 + sin(obj.x+PI));\n    vec3 p2 = vec3(0.5 + sin(obj.x+PI/2.0)*0.2, 0.25 + cos(obj.x-0.5*PI)*0.1, 0.5 + sin(obj.x+PI/2.0)*0.2);\n    vec3 p4 = vec3(0.5 + sin(obj.x-PI/2.0)*0.2, 0.25 + cos(obj.x+0.5*PI)*0.1, 0.5 + sin(obj.x-PI/2.0)*0.2);\n    vec3 p5 = vec3(0.5 , 0.75, 0.0);\n\n    float lines = drawLine(p1, p2, uv, str)\n        \t\t+ drawLine(p2, p3, uv, str)\n        \t    + drawLine(p3, p4, uv, str)\n        \t    + drawLine(p4, p1, uv, str)\n        \t    + drawLine(p5, p1, uv, str)\n        \t    + drawLine(p5, p2, uv, str)\n        \t    + drawLine(p5, p3, uv, str)\n        \t    + drawLine(p5, p4, uv, str);\n    \n    vec3 bc1 = bary(p1, p2, p5, uv);\n    vec3 bc2 = bary(p2, p3, p5, uv);\n    vec3 bc3 = bary(p3, p4, p5, uv);\n    vec3 bc4 = bary(p4, p1, p5, uv);\n    vec3 bc5 = bary(p1, p2, p3, uv);\n    vec3 bc6 = bary(p1, p4, p3, uv);\n    \n\tfragColor = vec4(bc1 + bc2 + bc3 + bc4 + bc5 + bc6 + lines, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 134, 134, 497], [499, 499, 552, 552, 766], [768, 768, 823, 823, 2002]], "test": "ok"}
{"id": "3ld3DM", "name": "Joint 3D - distance", "author": "iq", "description": "Distance to a capped torys, like [url]https://www.shadertoy.com/view/tl23RK[/url], but parametrized differently so it can be used as a joint. Inspired by dr2's morphing experiment - [url]https://www.shadertoy.com/view/3l3GD7[/url]", "tags": ["3d"], "likes": 22, "viewed": 1411, "published": "Public API", "date": "1576587653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a capped torus, like https://www.shadertoy.com/view/tl23RK,\n// but parametrized differently so it can be used as a joint. Inspired\n// by dr2's experiment - https://www.shadertoy.com/view/3l3GD7. Based\n// on the 2D join SDF: https://www.shadertoy.com/view/WldGWM\n//\n// See https://www.shadertoy.com/view/3ttGW7\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec4 sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n    \n    // if perfectly straight\n    if( abs(a)<0.001 ) return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n                 (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n                 (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n                 p.z );\n}\n\nvec4 sdJoint3DFlat( in vec3 p, in float l, in float a, in float w)\n{\n    \n    // if perfectly straight\n    if( abs(a)<0.001 )\n    {\n        vec3 q = p; q.y -= 0.5*l;\n        q = abs(q) - vec3(w,l*0.5,w);\n        return vec4(min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)),p);\n    }\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n\t// distance\n    float u = abs(ra)-length(q);\n    float d = max(length( vec2(q.x+ra-clamp(q.x+ra,-w,w), q.y) )*sign(-q.y),abs(u) - w);\n\n    // parametrization (optional)\n    float s = sign(a);\n    float v = ra*atan(s*p.y,-s*p.x);\n    u = u*s;\n    \n    // square profile\n    q = vec2(d,abs(p.z)-w);\n    \n    d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n\n    \n    return vec4( d, u, v, p.z );\n}\n\n\nvec4 map( in vec3 pos )\n{\n    float an = 1.3*sin(iTime*1.1+3.0);\n    float le = 0.8;\n    float wi = 0.2;\n    \n    vec4 d1 = sdJoint3DSphere(pos-vec3(0.0,0.0, 0.4), le, an, wi );\n    vec4 d2 = sdJoint3DFlat(  pos-vec3(0.0,0.0,-0.4), le, an, wi );\n    \n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm( in vec3 p )\n{\n\n    p *= 16.0;\n\tconst mat3 m = mat3( 0.00,  0.80,  0.60,\n    \t                -0.80,  0.36, -0.48,\n        \t            -0.60, -0.48,  0.64 )*2.0;\n    float f = 0.0;\n    f += 0.500*noise( p ); p = m*p;\n    f += 0.250*noise( p ); p = m*p;\n    f += 0.125*noise( p ); p = m*p;\n    return f;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.6 + 0.1*iTime;\n\tvec3 ro = vec3( 1.4*sin(an), 0.2, 1.4*cos(an) );\n    vec3 ta = vec3( 0.0, 0.2, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        vec3 uvw = vec3(0.0);\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            \n            vec4 h = map(pos);\n            if( h.x<0.0001 || t>tmax )\n            {\n                uvw = h.yzw;\n                break;\n            }\n            t += h.x;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.8,0.5,0.4));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n            col *= fbm( uvw*2.0 );\n            col *= 1.75;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ld3DM.jpg", "access": "shaders20k", "license": "mit", "functions": [[1551, 1551, 1576, 1576, 1595], [1596, 1596, 1666, 1700, 2281], [2283, 2283, 2351, 2385, 3154], [3157, 3157, 3182, 3182, 3443], [3445, 3509, 3541, 3541, 3788], [3790, 3790, 3847, 3847, 3942], [3944, 3944, 3970, 3970, 4442], [4444, 4444, 4468, 4468, 4759]], "test": "timeout"}
{"id": "3ld3zX", "name": "snow snow", "author": "changjiu", "description": "snow\nç®æ³æ¥èªï¼https://blog.csdn.net/tjw02241035621611/article/details/80047566\nalgorithm from https://blog.csdn.net/tjw02241035621611/article/details/80047566", "tags": ["snow"], "likes": 6, "viewed": 366, "published": "Public API", "date": "1577240556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n*ç®æ³æ¥èªï¼https://blog.csdn.net/tjw02241035621611/article/details/80047566\n*algorithm from https://blog.csdn.net/tjw02241035621611/article/details/80047566\n*/\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec3(.1031, .1030, .0973, .1099)\n\nfloat SIZE_RATE = 0.1;\nfloat XSPEED = 0.2;\nfloat YSPEED = 0.5;\nfloat LAYERS = 10.;\n\nfloat Hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z); \n}\n\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nvec2 Rand22(vec2 co)\n{\n    float x = fract(sin(dot(co.xy ,vec2(122.9898,783.233))) * 43758.5453);\n    float y = fract(sin(dot(co.xy ,vec2(457.6537,537.2793))) * 37573.5913);\n    return vec2(x,y);\n}\n\nvec3 SnowSingleLayer(vec2 uv,float layer){\n    \n    vec3 acc = vec3(0.0,0.0,0.0);//è®©éªè±çå¤§å°åå\n                uv = uv * (2.0+layer);//éè§è§éåå¤§ææ\n                float xOffset = uv.y * (((Hash11(layer)*2.-1.)*0.5+1.)*XSPEED);//å¢å xè½´ç§»å¨\n                float yOffset = (YSPEED*iTime);//yè½´ä¸è½è¿ç¨\n                uv += vec2(xOffset,yOffset);\n                vec2 rgrid = Hash22(floor(uv)+(31.1759*layer));\n                uv = fract(uv);\n                uv -= (rgrid*2.-1.0) * 0.35;\n                uv -=0.5;\n                float r = length(uv);\n                //è®©å¤§å°ååç¹\n                float circleSize = 0.05*(1.0+0.3*sin(iTime*SIZE_RATE));\n                float val = smoothstep(circleSize,-circleSize,r);\n                vec3 col = vec3(val,val,val)* rgrid.x ;\n                return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    uv *= vec2(iResolution.x/iResolution.y,1.0);\n    \n    vec3 acc = vec3(0,0,0);\n    for (float i=0.;i<LAYERS;i++) {\n        acc += SnowSingleLayer(uv,i); \n    }\n\n    // Output to screen\n    fragColor = vec4(acc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ld3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 399, 399, 518], [520, 520, 541, 541, 659], [662, 662, 684, 684, 859], [861, 861, 903, 903, 1708], [1711, 1711, 1768, 1818, 2081]], "test": "ok"}
{"id": "3ldGDj", "name": "andalousia", "author": "dinialo", "description": "First shader experimentation", "tags": ["animation", "rotation", "mosaic"], "likes": 2, "viewed": 79, "published": "Public", "date": "1577827492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Adapted from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm */\nfloat sdTriPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5) - 0.01;   \n}\n\nfloat sdCube(vec3 p, float r, float isoSurface) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0)) - isoSurface;    \n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\n/**\n * Models/Objects\n */\nvec2 map(in vec3 position)\n{\n    // add support mouse rotation\n    vec4 mouse = normalize(iMouse);\n    float theta = sqrt((iMouse.x)*10.0)/10.0 + iTime; \t\n    float alpha = sqrt((iMouse.y)*10.0)/10.0;\n    float gama = sqrt((iMouse.y+iMouse.x))/10.0 + iTime;\n    vec4 rotate = vec4(position, 1.0)* rotationX(alpha) * rotationY(theta) * rotationZ(gama);\n    position = vec3(rotate.x, rotate.y, rotate.z);\n    // end rotation support \n\t\n    //float time = normalize(iTime);\n    //float theta = sqrt((time)*10.0)/10.0; \t\n    //vec4 rotate = vec4(position, 1.0) * rotationX(theta) * rotationY(theta) * rotationZ(theta);\n    //position = vec3(rotate.x, rotate.y, rotate.z); \n    \n    float timeRandmo1 = (cos(iTime)+1.0)/4.0;\n    float timeRandom2 = (sin(iTime+10.0)+1.0)/4.0;\n    float timeRandom3 = (cos(iTime*0.5)+1.0)/4.0;\n    float timeRandom4 = (cos(iTime*2.0)+1.0)/4.0;\n    float sphere = length(position) - timeRandmo1+0.05;\n    float cube = sdCube(position, timeRandom2, 0.04);\n    vec3 symetric = vec3(abs(position.x), abs(position.y), abs(position.z));\n    vec3 symetric2 = vec3(abs(position.y), abs(position.x), abs(position.z));\n    theta = 0.009;\n    rotate = vec4(symetric, 1.0) * rotationX(theta) * rotationY(theta) * rotationZ(theta);\n    vec3 symetric3 = vec3(abs(rotate.x), abs(rotate.y), abs(rotate.z));\n\n    float triPrism = sdTriPrism(vec3(symetric.x, symetric.y, symetric.z), vec2(timeRandom3, 0.53));\n    float triPrism2 = sdTriPrism(vec3(symetric.y, symetric.x, symetric.z), vec2(timeRandom2, 0.53));\n    float triPrism3 = sdTriPrism(vec3(symetric3.z, symetric3.x, symetric3.y), vec2(timeRandom3, 0.53));\n    //float triPrism4 = sdTriPrism(vec3(symetric3.x, symetric3.y, symetric3.z), vec2(0.50, 0.53));\n    float triPrism5 = sdTriPrism(vec3(symetric3.z, symetric3.y, symetric3.x), vec2(timeRandom4, 0.53));\n    \t\n    \n    //float ret = min(sphere, floor);\n    vec2 result = vec2(0, cube);\n    if (sphere < result.y)\n      result = vec2(1,sphere);\n    if (triPrism < result.y)\n      result = vec2(2,triPrism);  \n    if (triPrism2 < result.y)\n      result = vec2(3,triPrism2); \n    if (triPrism3 < result.y)\n      result = vec2(4,triPrism3);\n    //if (triPrism4 < result.y)\n    //  result = vec2(5,triPrism4);\n    if (triPrism5 < result.y)\n      result = vec2(5,triPrism5);\n    \n    //float ret = min(sphere, cube);\n    //ret = min(ret, triPrism);\n    //return ret;\n    return result;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(map(pos+e.xyy).y-map(pos-e.xyy).y,\n                          map(pos+e.yxy).y-map(pos-e.yxy).y,\n                          map(pos+e.yyx).y-map(pos-e.yyx).y));\n}\n\n// rematcher\nvec2 castRay(in vec3 cameraOrigin, in vec3 cameraDirection)\n{\n    float m = -1.0;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n    \tvec3 pos = cameraOrigin + t*cameraDirection;\n        vec2 map = map(pos);\n        float h = map.y;\n        m = map.x;\n        if (h < 0.001)\n            break;\n        \n        t += h;\n        if (t>20.0) \n            break;\n    }\n    if (t > 20.0)\n        t = -1.0;\n    \n    return vec2(t, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 pixel2dNormalized = (2.0*fragCoord-iResolution.xy)/iResolution.y; // we devide by only y to keep domain as square\n    \n    //float f = smoothstep(0.2, 0.3, length(pixel2dNormalized))*0.5;\n    float an = 1.0;//10.0*iTime/iResolution.x;\n    float bn = 1.0;//10.0*iTime/iResolution.y;\n    vec3 cameraOrigin = vec3(0, 0,5.5);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta-cameraOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 cameraDirection = normalize(pixel2dNormalized.x*uu + pixel2dNormalized.y*vv + 5.0*ww);\n\n    // Sky color\n    vec3 col = vec3(0.8, 0.8, 0.8) - 0.4*pixel2dNormalized.y;\n    // add Horizon fog\n    //col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*pixel2dNormalized.y));\n    \n    \n    vec2 castr = castRay(cameraOrigin, cameraDirection);\n    float t = castr.x;\n    if (t > 0.0) {\n        vec3 intersection = cameraOrigin + t*cameraDirection;\n        vec3 objectSurfaceNormal = calcNormal(intersection);\n             \n        // material base color\n        vec3 material = vec3(0.2, 0.2, 0.2);\n        if (castr.y == 1.0) { //sphere\n        \tmaterial *= vec3(1.0, 0.0, 0.0);\n        } else if (castr.y == 2.0) {\n            material *= vec3(0.1, 0.1, 7.0);  \n        } else if (castr.y == 3.0) {\n            material *= vec3(0.9, 0.9, 0.0);  \n        } else if (castr.y == 4.0) {\n            material *= vec3(0.0, 0.9, 0.0);  \n        } else if (castr.y == 5.0) {\n            material *= vec3(0.8, 0.4, 0.0);  \n        }\n\n        vec3 sunDirectionNormal = normalize(vec3(0.5, 0.5, 0.1));\n        float sunDiffusion = clamp(dot(objectSurfaceNormal, sunDirectionNormal), 0.0, 1.0);\n        float skyDiffusion = clamp(dot(objectSurfaceNormal, vec3(0.6, 0.6, 0.6)), 0.5, 1.0);\n        float sunShadow = step(castRay(intersection+objectSurfaceNormal*0.001, sunDirectionNormal).x, 0.0);\n        float bounceDiffuse = clamp(dot(objectSurfaceNormal, vec3(1.0, -1.0, 0.0)), 1.0, 0.0);\n        \n        // lighthing adjustment\n    \tcol  = material*vec3(5.0, 4.0, 4.0)*sunDiffusion*sunShadow;  \n        col += material*vec3(0.5, 0.8, 0.9)*skyDiffusion; \n        col += material*vec3(0.5, 0.3, 0.2)*bounceDiffuse;  \n    }\n    \n    // Gama correction\n    col = pow(col, vec3(0.4545));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 86, 120, 120, 215], [217, 217, 266, 266, 377], [379, 379, 413, 413, 552], [554, 554, 588, 588, 724], [726, 726, 760, 760, 893], [895, 921, 949, 983, 3325], [3327, 3327, 3357, 3357, 3573], [3575, 3588, 3649, 3649, 4026], [4028, 4028, 4085, 4136, 6475]], "test": "timeout"}
{"id": "3ldGRB", "name": "lawrence_csg", "author": "brad_grantham", "description": "Lawrence's CSG shader based on iq's stuff", "tags": ["csg"], "likes": 2, "viewed": 202, "published": "Public API", "date": "1576742134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sphere_dist(vec3 p, vec4 s) {\n    return distance(p, s.xyz) - s.w;\n}\n\nfloat box_dist(vec3 p, vec3 c, vec3 s, float r) {\n    vec3 d = abs(p - c) - (s - r);\n    return length(max(d, 0.0)) - r\n        + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat union_d(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat intersection_d(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat difference_d(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// (distance,oid)\n// oid -1.0 = miss\n// oid 0.0 = floor\n// oid 1.0 = main object\nvec2 dist(vec3 p, bool includeFloor) {\n    float sd = sphere_dist(p, vec4(0.0, 0.0, 0.0, 3.0));\n    float bd = box_dist(p, vec3(0.0, 0.0, 0.0), vec3(2.5), 0.5);\n\n    float od = difference_d(bd, sd);\n    // od = sd;\n\n    if (includeFloor) {\n\t    float fd = p.y - -3.0;\n    \tif (fd < od) {\n        \treturn vec2(fd, 0.0);\n    \t}\n    }\n\n    return vec2(od, 1.0);\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + d*rd;\n        vec2 f = dist(p, true);\n        d += f.x;\n        if (d > MAX_DIST || f.x < SURF_DIST) {\n            return vec2(d, f.y);\n        }\n    }\n\n    return vec2(0.0, -1.0);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n\n    return normalize(\n        dist(p, true).x - vec3(\n            dist(p - e.xyy, true).x,\n            dist(p - e.yxy, true).x,\n            dist(p - e.yyx, true).x));\n}\n\nvec3 shade(vec3 rd, vec3 p, int oid) {\n    vec3 l = vec3(0.0, 10.0, 0.0);\n    l.xz += vec2(sin(iTime+3.0), cos(iTime+3.0))*10.0;\n\n    vec3 to_l = normalize(l - p);\n    vec3 n = normal(p);\n    float diffuse = max(0.0, dot(to_l, n));\n    vec3 col;\n    if (oid == 0) {\n        // Floor.\n        float d = dist(p, false).x;\n        d = mod(d, 1.0) > 0.9 ? 1.0 : 0.9;\n        col = vec3(0.8, 0.8, 0.8)*diffuse*d;\n    } else if (oid == 1) {\n        // Object.\n        vec3 r = 2.0*dot(to_l, n)*n - to_l;\n        float specular = pow(max(dot(r, -rd), 0.0), 5.0);\n        col = vec3(1.0, 0.0, 0.0)*diffuse + vec3(1.0, 1.0, 1.0)*specular;\n    } else {\n        col = vec3(1.0, 1.0, 0.0);\n    }\n\n    // Shadow.\n    if (march(p + n*SURF_DIST*2.0, to_l).x < distance(l, p)) {\n        col *= 0.5;\n    }\n\n    return col;\n}\n\nmat3 makeCamera(vec3 eye, vec3 lookat) {\n    vec3 z = normalize(eye - lookat);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n\n    return mat3(x, y, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n\n    vec3 eye = vec3(sin((iTime + 3.0)/10.0)*10.0, 7.0, cos((iTime + 3.0)/10.0)*10.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    mat3 cam = makeCamera(eye, lookat);\n\n    vec3 rd = normalize(-cam[2]*1.5 + cam[0]*xy.x + cam[1]*xy.y);\n    vec3 ro = eye;\n\n    vec2 hit = march(ro, rd);\n    vec3 col;\n    if (hit.y == -1.0) {\n        col = vec3(1.0, 0.0, 1.0);\n    } else {\n\t    vec3 p = ro + rd*hit.x;\n    \tcol = shade(rd, p, int(hit.y));\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 279], [353, 353, 388, 388, 427], [429, 429, 478, 478, 595], [597, 597, 632, 632, 658], [660, 660, 702, 702, 728], [730, 730, 770, 770, 797], [799, 799, 839, 839, 960], [962, 1043, 1081, 1081, 1403], [1405, 1405, 1435, 1435, 1702], [1704, 1704, 1725, 1725, 1923], [1925, 1925, 1963, 1963, 2732], [2734, 2734, 2774, 2774, 2922], [2924, 2924, 2980, 2980, 3519]], "test": "ok"}
{"id": "3ldGRl", "name": "Worley Cellular Noise 3D", "author": "bluebean", "description": "3d Cellularåªå£°", "tags": ["3d", "noise", "worley", "cellular"], "likes": 2, "viewed": 147, "published": "Public", "date": "1577259203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//å¨æ°ç»ä¸­éæºåä¸ä¸ªå¼ï¼æ»¡è¶³æ³æ¾åå¸ï¼åå¼ä¸º2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\nå¨cellX,cellYæå®çæ¶æ ¼ä¸­éæ ·ï¼å¾å°æè¿çåä¸ªè·ç¦»\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //å¨æ¶æ ¼ä¸­äº§çè¥å¹²ä¸ªç¹å¾ç¹ï¼ä¸ªæ°å¨æ³æ¾åå¸è¡¨ä¸­éæºå¾å°\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //åç§»ç§å­ï¼ç¨ä»¥äº§çä¸ä¸ä¸ªä¸åçåç§»\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worleyç»èåªå£°\nè¾å¥ï¼ä½ç½®\nè¾åºï¼ä»å°å°å¤§æåºçè·ç¦»æè¿çåä¸ªç¹å¾ç¹çè·ç¦»\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //å¤æ­æ¯å¦å¾å°äºæè¿çåä¸ªè·ç¦»ï¼å¦ææ¯çè¯ï¼ä¸å¿å¨ç¸é»æ¶æ ¼è¿è¡éæ ·\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 773, 794, 794, 889], [891, 891, 917, 917, 1391], [1393, 1393, 1417, 1417, 1619], [1621, 1696, 1781, 1781, 2943], [2945, 3059, 3105, 3105, 6413], [6415, 6415, 6453, 6453, 6621], [6623, 6623, 6652, 6652, 6736], [6738, 6738, 6763, 6763, 6778], [6780, 6780, 6811, 6811, 6898], [6900, 6900, 6935, 6935, 6961], [6963, 6963, 6993, 6993, 7026], [7028, 7028, 7053, 7053, 7254], [7256, 7256, 7296, 7296, 7633], [7635, 7635, 7672, 7672, 8160], [8162, 8162, 8220, 8220, 8394], [8396, 8396, 8453, 8453, 9327]], "test": "error"}
{"id": "3ldGRr", "name": "BCC Noise, stuck in time", "author": "KdotJPG", "description": "I run 8 steps of gradient ascent on 3D noise, in the Z (time) axis only. The results are interesting.", "tags": ["2d", "noise"], "likes": 3, "viewed": 85, "published": "Public", "date": "1575471785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////// Re-oriented 8-point BCC noise by KdotJPG ////////////////////\n//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 bccNoiseDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 bccNoiseDerivatives_XYZ(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Might be good for terrain, or a time varying X/Y plane. Z repeats.\nvec4 bccNoiseDerivatives_PlaneFirst(vec3 X) {\n    \n    // Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y) * 8.0;\n    \n    // Initial input point\n    vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386);\n    \n    // 8 steps of gradient ascent\n    vec4 noiseResult;\n    for (int i = 0; i < 8; i++) {\n    \tnoiseResult = bccNoiseDerivatives_PlaneFirst(X);\n        X += vec3(0, 0, noiseResult.z) / 16.0;\n    }\n    \n    //Get the final value\n    float value = noiseResult.w;\n\n    // Time varying pixel color\n    vec3 col = vec3(value);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 214, 236, 236, 273], [275, 337, 360, 408, 1379], [1381, 1426, 1464, 1464, 2921], [2923, 3080, 3118, 3118, 3320], [3322, 3471, 3516, 3550, 3961], [4046, 4046, 4101, 4172, 4720]], "test": "ok"}
{"id": "3ldGz2", "name": "Cloud Cube", "author": "JohnShadow", "description": "Cloud Cube", "tags": ["cloudcube"], "likes": 2, "viewed": 145, "published": "Public", "date": "1576977235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define light normalize(vec3(sin(iTime), cos(iTime), 0.0))\nconst float stepsize = 0.1;\nconst float lightstepsize = 6.0;\nconst float deltas = 1.0;\nconst float cloudscale = 0.5;\nconst float cloudupdown = 0.4;\nconst float orbit = 30.0;\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60, -0.80,  0.36, -0.48, -0.60, -0.48,  0.64 );\n#define hdot(a, b) ((dot(a, b) + 1.0) * 0.5)\n\nstruct Ray\n{\n\tvec3 o, d;\n};\n\nstruct AABB\n{\n\tvec3 max, min;\n};\n    \nAABB worldbox = AABB(vec3(-5.0, -5.0, -5.0), vec3(5.0, 5.0, 5.0));\nvec2 rayAABB(Ray ray, AABB aabb, float tmin, float tmax) {\n    vec3 invD = 1.0/ray.d;\n\tvec3 t0s = (worldbox.min - ray.o) * invD;\n  \tvec3 t1s = (worldbox.max - ray.o) * invD;\n    \n  \tvec3 tsmaller = min(t0s, t1s);\n\tvec3 tbigger  = max(t0s, t1s);\n\n\ttmin = max(tmin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));\n\ttmax = min(tmax, min(tbigger[0], min(tbigger[1], tbigger[2])));\n\treturn vec2((tmin < tmax) ? tmin : 0.0, max(tmin, tmax));\n}\n    \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    x *= cloudscale;\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res - cloudupdown;\n}\n\n\nfloat shadow(Ray ray)\t\n{\n    vec2 hit = rayAABB(ray, worldbox, 0.0, 1e20);\n    float far = hit.y - hit.x;\n\t\n    float density = 0.0;\n    float dist = 0.0;\n    float dlightstepsize = far/lightstepsize;\n    vec3 pos = ray.o;\n\tfor(float i = 0.0; i < lightstepsize; ++i)\n    {\n\t\tpos += ray.d * dlightstepsize;\n\t\tdensity += max(noise(pos) * dlightstepsize, 0.0);\n\t}\n\treturn exp(-density);\n}\nfloat scatter(Ray ray, float far)\n{\n\tfloat dist = 0.0;\n    float density = 1.0;\n    float lightDensity = 0.0;\n\twhile(far > dist)\n\t{\n\t\tvec3 pos = ray.o + ray.d * dist;\n\t\tfloat pointDensity = max(noise(pos), 0.0);\n        if(pointDensity > 0.0)\n        {\n        \tlightDensity += pointDensity * shadow(Ray(pos, light)) * (1.0/lightstepsize);\n            density *= exp(-pointDensity * stepsize);\n            if(density < 0.01)\n                break;\n        }\n\t\tdist += stepsize;\n\t}\n\treturn (lightDensity + (1.0-density)) * 0.25;\n}\nfloat cloud(Ray ray)\n{\n\tvec2 boxhit = rayAABB(ray, worldbox, 0.0, 1.e20);\n    if(boxhit.x == 0.0)\n        return 0.0;\n    vec3 hitpoint = ray.o + ray.d * (boxhit.x + 0.001);\n\tfloat sss = scatter(Ray(hitpoint, ray.d), boxhit.y - boxhit.x);\n\treturn sss;\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 ori = vec3(orbit * sin(iTime * 0.5), 10.0, orbit * cos(iTime * 0.5));\n    mat4 viewToWorld = viewMatrix(ori, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 dir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\t\n\tvec3 c = vec3(0.0);\n\t\n\tfloat sss = cloud(Ray(ori, dir));\n\tc = vec3(sss);\n\t\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 557, 557, 938], [944, 944, 967, 967, 1006], [1007, 1007, 1033, 1033, 1478], [1481, 1481, 1505, 1505, 1866], [1867, 1867, 1902, 1902, 2396], [2397, 2397, 2419, 2419, 2650], [2651, 2651, 2716, 2716, 2848], [2849, 2849, 2898, 2933, 3159], [3160, 3160, 3217, 3217, 3626]], "test": "ok"}
{"id": "3ldGz8", "name": "Easing - bezier -", "author": "gaz", "description": "2d", "tags": ["easing"], "likes": 6, "viewed": 143, "published": "Public", "date": "1575605951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/wdKXDy\n// ++++++++++++++++++++++++++++\n\n#define TIME mod(iTime,3.5)\nfloat T,SAM;\n#define Q(a) T=clamp((TIME-SAM)/a, 0.0, 1.0);SAM+=a;\n\n#define PI acos(-1.0)\n#define hue(h) clamp((abs(fract(h+vec3(3,2,1)/3.0)*6.0-3.0)-1.0),0.0,1.0)\n#define hsv(h,s,v) mix(vec3(1),hue(h),s)*v\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 planeUv(vec3 ro, vec3 rd, vec3 p)\n{\n    float z = dot(p-ro,vec3(0,0,1))/dot(rd,vec3(0,0,1));\n    p-=ro+rd*z;\n    return vec2(dot(p,vec3(1,0,0)),dot(p,vec3(0,1,0)));\n}\n\nfloat aa(float d)\n{\n    return smoothstep(0.01,0.0,d);\n}\n\nfloat fog(float z)\n{\n    return exp(-z*z*0.005);\n}\n\nfloat rbox(vec2 p, float size)\n{\n    p-=clamp(p,-size,size);\n    return abs(length(p)-0.1);\n}\n\n\nfloat deLine(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    t=clamp(t,0.0,1.0);\n    return mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, vec2 d, float t){\n    return mix(bezier(a,b,c,t),bezier(b,c,d,t),t);\n}\n   \nvec2 bezierCurve(float t)\n{\n    vec2 a=vec2(0.3,0.5);\n    vec2 b=vec2(0.9,0.1);\n    return bezier(vec2(0),a,b,vec2(1),t);\n}\n\n// https://www.shadertoy.com/view/3slXD8\nfloat deEase(vec2 p)\n{\n    float ITR = 50.0, pitch = 1.0, t = 0.5, de = 1e10;\n    for(int j=0; j<2; j++)\n    {\n        float t0 = t-pitch*0.5;\n        pitch /= ITR;\n        for(float i=0.0; i<=ITR; i++) \n        {\n            float de0=distance(p,bezierCurve(t0));\n            if (de0<de)\n            {\n                de = de0;\n                t=t0;\n            }       \n            t0 += pitch;\n        }\n    }\n    return de;\n}\n\nfloat deEase2(vec2 p)\n{\n    float de=2.0;\n    for(float t=0.0;t<1.0;t+=1.0/20.0)\n    {\n        vec2 a=bezierCurve(t);\n        vec2 b=bezierCurve(t+1.0/20.0);\n        de=min(de,deLine(p,a,b));\n    }\n    return de;\n}\n\nfloat ease_bezier(float p)\n{\n    float ITR=30.0, pitch=1.0, t=0.5, de=1.0;   \n    for(int j=0; j<2; j++)\n    {\n        float t0=t-pitch*0.5;\n        pitch/=ITR;\n        for(float i=0.0; i<=ITR; i++) \n        {\n            float de0=abs(p-bezierCurve(t0).x);\n            if(de0<de)\n            {\n                de=de0;\n                t=t0;\n            }\n            t0+=pitch;\n        }\n    }\n    return bezierCurve(t).y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(1,3,8);\n    ro.xz*=rot(sin(TIME)*0.5-0.5);\n    ro.y*=sin(TIME);\n    vec3 ta=vec3(0,0,0);\n    vec3 w=normalize(ta-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 rd=normalize(u*p.x+cross(u,w)*p.y+w*2.0);\n    vec3 col=hsv(0.6,0.8,0.5);\n    \n    SAM=0.0;\n    Q(1.0)\n    Q(1.0)\n\n    float de;\n    de=rbox(p,0.5)-0.02;\n    col=mix(col,hsv(0.0,0.7,0.7),aa(de));\n    de=deEase(p+0.5)-0.02;\n    col=mix(col,hsv(0.0,0.9,1.0),aa(de));\n    de=deEase2(p+0.5)-0.005;\n    col=mix(col,hsv(0.25,0.7,1.0),aa(de));\n    float x=fract(T);\n    de=1.0;\n    de=min(de,length(p-vec2(x,0)+0.5));\n    de=min(de,length(p-vec2(0,ease_bezier(x))+0.5));\n    de=min(de,length(p-vec2(x,ease_bezier(x))+0.5));\n    col=mix(col,hsv(0.35,0.7,1.0),aa(de-0.05));\n   \n    for(float i=-1.0;i<1.1;i++)\n    {\n        vec3 coord=vec3(0,0,i*1.5);\n        vec2 uv=planeUv(ro,rd,coord);\n        uv*=rot(ease_bezier(T)*PI);\n        float de=rbox(uv,0.6+ease_bezier(T)*1.2)-0.01;\n        col=mix(col,vec3(1),aa(de)*fog(length(coord-ro)));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 399, 399, 530], [532, 532, 551, 551, 588], [590, 590, 610, 610, 640], [642, 642, 674, 674, 735], [738, 738, 776, 776, 900], [902, 902, 948, 948, 1015], [1017, 1017, 1070, 1070, 1123], [1128, 1128, 1155, 1155, 1251], [1253, 1294, 1316, 1316, 1723], [1725, 1725, 1748, 1748, 1939], [1941, 1941, 1969, 1969, 2365]], "test": "ok"}
{"id": "3lt3D8", "name": "Reflection Testing", "author": "NivBehar", "description": "Reflection", "tags": ["raymarching", "reflection"], "likes": 2, "viewed": 113, "published": "Public", "date": "1576189829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define MaxSteps 1000\n# define time iTime\n# define PI 3.141592654\n# define NumberOfReflections 20\n\nvec3 LightPos = vec3(5., 7., -5.);\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\nfloat sdBox(vec3 p, vec3 s) \n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 s, float r )\n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y)-r.y);\n}\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r ) {\n  return length(p)-r;\n}\nfloat sdSphereHex( vec3 p, float r ) {\n\tvec2 sUV = GetSphereUV(p, r);\n    vec4 h = HexCoords(sUV*vec2(6.,3.) + 10.);\n    float sphereDist = length(p)-r;\n    float sphereHex = sphereDist + 0.002*sin(h.y*10.)*cos(h.x*10.);//*sin(time*2.5);\n    return mix(sphereHex, sphereDist, 0.5 + 0.5*sin(time*0.367));\n}\nvec3 RotX (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x, p.y*cc + p.z*-ss,  p.y*ss + p.z*cc);\n}\nvec3 RotY (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc + p.z*ss, p.y, p.x*-ss + p.z*cc);\n}\nvec3 RotZ (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc  + p.y*-ss, p.x*ss + p.y*cc, p.z);\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec3 spherePos() {\n    return vec3(0.,1.05 + 0.15*sin(time),0.);\n}\nvec2 GetDist(vec3 p) // return vec2(min Distance, Object ID)\n{\n    //sky (a BIG sphere)\n    vec3 skyPos = vec3(0.,0.,0.);\n    float skyRad = 200.;\n    float skyDist = -sdSphere(p-skyPos, skyRad);\n    float skyID = 0.;\n    \n    vec2 res = vec2(skyDist, skyID);    \n    \n    //ground\n    float groundDist = p.y;\n    float groundID = 1.;\n    \n    // sphere (big HexSphere)\n    float sphereRad = 0.2;\n\tvec3 spherePosNew = p-spherePos();\n    //spherePosNew.x = fract(spherePosNew.x+1.)-0.5;\n    spherePosNew.y = fract(spherePosNew.y+1.)-0.5;\n    float sphereDist = sdSphereHex(spherePosNew, sphereRad);\n    \n    // box\n    vec3 boxSize = vec3(0.5,0.05,0.5);\n    vec3 boxPos = vec3(0.,0.5,0.);\n    //float boxDist = dBox(p - boxPos, boxSize);\n    vec3 boxPosNew = p - boxPos;\n    //boxPosNew.x = fract(boxPosNew.x+1.)-0.5;\n    //boxPosNew.z = fract(boxPosNew.z+1.)-0.5;\n    boxPosNew.y = sin(fract(boxPosNew.y+1.))-0.5;\n    float boxDist = sdRoundBox(boxPosNew, boxSize, 0.015);\n\n    // sphere2 (small sphere)\n    float sphere2Rad = 0.1;\n    vec3 sphere2Pos = vec3(0.4*sin(time),1.1 + 0.4*cos(time*0.3),0.4*cos(time));\n    vec3 sphere2PosNew = p-sphere2Pos;\n    //sphere2PosNew.x = fract(sphere2PosNew.x+1.)-0.5;\n    sphere2PosNew.y = fract(sphere2PosNew.y+1.)-0.5;\n    float sphere2Dist = sdSphere(sphere2PosNew, sphere2Rad);\n    \n    //box + spheres\n    float boxSphereDist = min(boxDist, sphereDist);\n    float boxSphereID = 2.;\n    boxSphereDist = min(boxSphereDist, sphere2Dist);\n    \n    if(groundDist < res.x)\n        res = vec2(groundDist, groundID);\n    if(boxSphereDist < res.x) \n        res = vec2(boxSphereDist, boxSphereID);\n\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;  \n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p);\n        if(abs(dS.x) < 0.0001) {break; }\n        dO += dS.x;\n    }     \n    return vec2(dO,dS.y);\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01, 0.);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy).x, \n                        GetDist(p-e.yxy).x, \n                        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 lightpos, int steps)\n{\n    float lightpower = 1.4;\n    float shadowstrength = 0.6;\n    vec3 l = normalize(lightpos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    float d = (RayMarch(p + n*0.01, l, steps)).x;\n    if(d < length(lightpos-p)) {dif *= shadowstrength;}\n    return dif;\n}\nvec3 groundCol(vec3 p)\n{\n    vec3 col = vec3(1.,1.,1.);\n    p.xz *= 10.;\n    float squares = smoothstep(-0.5, -0.4, sin(p.x)*cos(p.z));\n    return col*squares;\n}\nvec3 skyCol(vec3 p)\n{\n    vec3 col;\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-1., p.y);\n    float a = cos(y + 92.1);\n    col = vec3(0., 0.8078, 0.8196);\n    col *= vec3(a,a,1.);\n    return col;\n}\nvec3 applyFog( vec3  rgb, float distance) \n{\n    float b = 1.;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = 0.3;\n    float c = 0.2;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.7,1.,1.);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nvec3 GetCol(vec3 ro, vec3 rd, vec2 d, vec3 p, int refNum) // refNum for reflection number\n{\n\t//vec3 LightPos = vec3(5., 7., -5.);\n    float dif = GetLight(p, LightPos, MaxSteps);\n    float spRef = specularReflection(p, rd, LightPos, 1., 1000.);\n    vec3 col = vec3(0.,0.,0.);\n    \n    if(d.y == 0.) // sky col\n        col = skyCol(p);\n    \n    if(d.y == 1.) // ground col\n        col = groundCol(p)*dif;\n    \n    int refMarchSteps = MaxSteps;\n    while(refNum > 0)\n    {\n        refMarchSteps /= 2;\n        if(d.y == 2.) // boxSphere col + reflection\n        {\n            vec3 n = GetNormal(p);\n            rd = normalize(reflect(rd,n)); // reflect does: rd - 2.0 * dot(n, rd) * n\n            ro = p + rd*0.001;\n            d = RayMarch(ro, rd, MaxSteps);\n            p = ro + rd*d.x;\n            float reflectDif = GetLight(p, LightPos, refMarchSteps);\n            //float reflectSpRef = specularReflection(p, rd, LightPos, 0.5, 1000.);\n\n            if(d.y == 0.) // sky col\n                col = skyCol(p);\n\n            if(d.y == 1.) // ground col\n                col = groundCol(p)*reflectDif;\n            if(d.y == 2. && refNum == 1) // color for the last reflection\n                col = vec3(0);\n            col = applyFog(col, d.x, ro, rd);\n            //col += vec3(0.2,0.2,0.);\n            col *= vec3(1.9,1.4,1.); // color adjustment\n            col = 0.75*col*dif + 0.25*col;\n            col += spRef;\n        }\n        refNum -= 1;\n        \n    }\n    //col= col*dif;\n    \n    return col;\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n \n    vec3 lookat = vec3(0.,1.,0.);\n\n    float zoom = 0.5;\n    \n    vec2 mou = 5.*(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    mou.y += 2.;\n    mou.y = max(0.01, mou.y);\n    vec3 ro = vec3(1.,5.,1.);//vec3(mou,-1.);\n    ro.x += mou.x;\n    ro.y = mou.y;\n    ro.z = mou.y;\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    vec2 d = RayMarch(ro,rd, MaxSteps); // d.y = Object ID\n    vec3 p = ro + rd*d.x;\n    \n    col = GetCol(ro,rd,d,p,NumberOfReflections);\n    col = applyFog(col, d.x,ro, rd);\n\n    fragColor = vec4(col,0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 153, 153, 279], [280, 280, 310, 310, 397], [398, 398, 443, 443, 534], [535, 535, 566, 566, 637], [638, 638, 661, 661, 769], [770, 770, 796, 796, 1081], [1082, 1082, 1117, 1117, 1241], [1242, 1242, 1277, 1277, 1301], [1302, 1302, 1340, 1340, 1607], [1608, 1608, 1641, 1641, 1748], [1749, 1749, 1782, 1782, 1888], [1889, 1889, 1922, 1922, 2029], [2030, 2030, 2073, 2073, 2173], [2174, 2174, 2192, 2192, 2240], [2241, 2241, 2303, 2328, 3891], [3892, 3892, 3937, 3937, 4168], [4169, 4169, 4193, 4193, 4409], [4410, 4410, 4460, 4460, 4762], [4763, 4763, 4787, 4787, 4924], [4925, 4925, 4946, 4946, 5140], [5141, 5141, 5185, 5185, 5338], [5339, 5339, 5580, 5580, 5792], [5793, 5793, 5888, 5888, 6338], [6339, 6339, 6430, 6468, 7841], [7842, 7842, 7861, 7861, 7923], [7924, 7924, 7981, 7981, 8788]], "test": "timeout"}
{"id": "3lt3DB", "name": "tunel -circulo-v01", "author": "jorge2017a1", "description": "tunel -circulo-v01", "tags": ["tunelcirculov01"], "likes": 1, "viewed": 61, "published": "Public", "date": "1577460691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge flores.p\n// fecha -27/dic/2019\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\nvec3 glpRoRdNoMov;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n///--------------------------------------------\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\t//return textureLod(iChannel0,(p+.5)/32.,-16.).x;\n    return texture(iChannel0,p.xy).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*25.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n///--------------------------------------------\n\n///--------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n\tcase 11:\n        //float pattern = fract( 1.-Granite( glpRoRd)*8.) ;\t\n        float pattern = abs( 1.-Granite( glpRoRd)*0.15) ;\t\n        //return Granite(glpRoRd)*vec3(0.2,0.5,0.3);\n        return pattern*vec3(1.0);\n     case 12:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd); \n     case 13:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(-glpRoRdNoMov.zyx); \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n    float d , dif1, dif2;\n    vec2 res;\n    vec3 pp;\n    \n    d=999.9;\n    float planeDist = p.y;\n    pp=p;\n    \n    \n    res = vec2(9999, 0);\n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n            //res=vec2(res.x, 12);\n         } \n     } \n    \n \n    \n\n    p.z=mod(p.z, 8.0)-1.0;\n    \n    \n    float sdc1=sdCylinder( p.xzy-vec3(0.0,0.0,6.0), vec2(5.5,8.0) ) ;\n    float sdc2=sdCylinder( p.xzy-vec3(0.0,0.0,6.0), vec2(5.45,8.2) ) ;\n  \n\n    //res= opU(res, vec2(  differenceSDF(sdc1, sdc2),6)); \n    res= opU(res, vec2(  differenceSDF(sdc1, sdc2),13)); \n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 3.5, -15.5);\n\n    vec3 rLuz=vec3(0.5, -3.5, iTime*0.5);\n    \n    vec3 rLuz3=vec3(5.5, 0.5,  iTime*0.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    //glpRoRdNoMov=p.yxz;\n    glpRoRdNoMov=p;\n    \n    \n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    \n    float dif = GetLightv2(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n    dif=(dif+dif3)/1.5;\n    col = vec3(dif)*colobj;\n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[404, 421, 454, 454, 519], [520, 538, 574, 574, 643], [644, 659, 690, 690, 840], [841, 861, 897, 897, 984], [985, 1001, 1033, 1061, 1122], [1125, 1135, 1171, 1171, 1444], [1496, 1543, 1579, 1579, 1682], [1738, 1738, 1784, 1784, 1816], [1818, 1818, 1860, 1860, 1892], [1894, 1894, 1941, 1941, 1974], [1977, 1977, 2006, 2006, 2132], [2134, 2134, 2170, 2170, 2287], [2289, 2289, 2325, 2325, 2443], [2497, 2497, 2520, 2520, 2679], [2682, 2682, 2709, 2709, 2887], [2987, 2999, 3021, 3021, 3329], [3331, 3331, 3356, 3356, 3546], [3595, 3595, 3623, 3623, 4988], [5042, 5151, 5188, 5188, 5223], [5226, 5226, 5251, 5251, 6105], [6108, 6108, 6142, 6142, 6376], [6379, 6379, 6403, 6403, 6635], [6639, 6639, 6663, 6663, 7048], [7051, 7051, 7077, 7077, 7441], [7446, 7446, 7518, 7518, 7545], [7547, 7547, 7604, 7604, 8477]], "test": "error"}
{"id": "3lt3RB", "name": "cravo-elfhead", "author": "cravo", "description": "A festive elf head.  It was going to be santa but I ran out of time for the beard :-)  Imagine he's saying \"Ho ho ho\" over and over again.", "tags": ["christmas"], "likes": 4, "viewed": 120, "published": "Public", "date": "1576761924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by cravo\n\n// Makes use of a lot of distance functions and noise stuff by iq\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat noise(vec3 x) // iq's 3D noise\n{\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x)\n{   \n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n   \nfloat sdFluffBall(vec3 p, float s)\n{\n    float rad2 = s * 0.3;\n    s-= rad2 * fbm(p*8.0);\n    \n    float d = sdSphere(p,s);\n    \n    return d;\n}\n\nfloat sdFluffTorus(vec3 p, vec2 s)\n{\n    float rad2 = s.y * 0.3;\n    s.y -= rad2 * fbm(p*8.0);\n    return sdTorus(p,s);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//----------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opBlend( vec3 p, float d1, float d2 )\n{\n    return smin( d1, d2, 0.5 );\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{  \n    vec3 facePos = vec3(0.0,0.5,0.0);\n    float face = sdEllipsoid(pos - facePos, vec3(0.4,0.5,0.4));\n    \n    vec3 nosePos = vec3(0.0,0.5,0.4);\n    float nose = opBlend(pos, sdEllipsoid(pos - nosePos, vec3(0.1,0.05,0.05)),0.25);\n    \n    vec3 ear1Pos = vec3(-0.37, 0.6, 0.1);\n    float ear1 = sdEllipsoid(pos - ear1Pos, vec3(0.1,0.1,0.05));\n\n    vec3 ear2Pos = vec3(0.37, 0.6, 0.1);\n    float ear2 = sdEllipsoid(pos - ear2Pos, vec3(0.1,0.1,0.05));\n    \n    vec3 eye1Pos = vec3(-0.1,0.65,0.325);\n    float eye1 = sdEllipsoid(pos - eye1Pos, vec3(0.05,0.1,0.05));\n\n    vec3 eye2Pos = vec3(0.1,0.65,0.325);\n    float eye2 = sdEllipsoid(pos - eye2Pos, vec3(0.05,0.1,0.05));\n\n    vec3 mouthPos = vec3(0.0,0.25,0.28);\n    float mouth = sdEllipsoid(pos - mouthPos, vec3(0.1,abs(sin(iTime*4.0))*0.05,0.1));\n    \n    vec3 hatPos = vec3(0.0, 1.05, 0.0);\n    float hat = sdCone(pos - hatPos, 0.22, 0.3, 0.0);\n    \n    vec3 hatBobblePos = vec3(0.0,1.2,0.0);\n    float hatBobble = sdFluffBall(pos - hatBobblePos, 0.1);\n    \n    vec3 hatRingPos = vec3(0.0,0.8,0.0);\n    float hatRing = sdFluffTorus(pos - hatRingPos,vec2(0.3,0.1));\n    \n    face = opSubtraction(mouth,face);\n    \n    vec2 res = vec2(sdPlane(pos), 1.0);\n\tres = opU(vec2(face,2.0), res);\n    res = opU(vec2(nose,2.0), res);\n    res = opU(vec2(ear1, 2.0), res);\n    res = opU(vec2(ear2, 2.0), res);\n    res = opU(vec2(eye1,3.0), res);\n    res = opU(vec2(eye2,3.0), res);\n    res = opU(vec2(hat, 4.0), res);\n    res = opU(vec2(hatBobble,3.0), res);\n    res = opU(vec2(hatRing, 3.0), res);\n    \n    //res = vec2(sdFluffTorus(pos - facePos,vec2(0.5,0.1)),3.0);\n    \n    \n    return res;\n}\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        \tfloat h = map( ro + rd*t ).x;\n        \tres = min( res, k*h/t );\n        \tt += 0.02;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = vec3(0.8);\n\t\t\n        if(m == 2.0)\n        {\n            col = vec3(1.0,0.8,0.7);\n        }\n        else if(m == 4.0)\n        {\n            col = vec3(1.0,0.0,0.0);\n        }\n        \n\t\tvec3 lig = normalize( vec3(0.3, 0.6, 0.5) );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = 1.20*dif*vec3(1.00,1.0,1.0);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\n\t\tcol = bac + col*brdf + vec3(1.0)*col*spe;\n\n\t}\n\n\t// light falloff with distance\n\tcol *= exp( -0.01*t*t );\n\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3( sin(iTime) * 0.5, 0.7, 2.5 );\n\tvec3 ta = vec3( 0.0, 0.5, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 203, 203, 218], [220, 220, 255, 255, 281], [283, 283, 320, 320, 403], [405, 405, 438, 438, 503], [505, 505, 543, 543, 765], [767, 767, 786, 786, 959], [964, 964, 1000, 1000, 1108], [1110, 1110, 1146, 1146, 1231], [1233, 1233, 1258, 1258, 1277], [1278, 1278, 1343, 1343, 1681], [1757, 1757, 1798, 1798, 1891], [1893, 1893, 1923, 1923, 1956], [1958, 1958, 2003, 2003, 2037], [2039, 2039, 2082, 2082, 2104], [2180, 2180, 2205, 2205, 3843], [3848, 3848, 3903, 3903, 4222], [4225, 4225, 4311, 4311, 4545], [4547, 4547, 4579, 4579, 4800], [4802, 4802, 4844, 4844, 5149], [5154, 5154, 5193, 5193, 6176], [6178, 6178, 6235, 6235, 6763]], "test": "error"}
{"id": "3lt3Rf", "name": "paredv2", "author": "jorge2017a1", "description": "paredv2", "tags": ["paredv2"], "likes": 3, "viewed": 88, "published": "Public", "date": "1577071553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\nvec2 gluv;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n///---------------------------------------------------\n\n\nvec3 colorplaneta( vec2 fragCoord )\n{\n    vec2 uv;\n    //Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    //Equalize the aspect ratio\n    ///uv.y /= iResolution.x/iResolution.y;\n    uv=fragCoord;\n    \n    //Zoom out\n    uv *= 5.0;\n    \n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n\n    //Fragment colour\n    return col;\n}\n\n///-------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    case 11:\n        return \tcolorplaneta(gluv);\n    \n    \n    } \n}\n\n\n///-------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n   \n    p.z=p.z-6.0;\n    \n    p.x = mod(p.x, 7.0) - 3.5;\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,11); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n         } \n     } \n    \n    \n   \n    pp=p;\n    \n   float sdb1=sdBox(pp-vec3(0,0,0), vec3(3.,4.0,0.5));\n    \n    float sdb2=sdBox(pp-vec3(3.5,0,0.0), vec3(0.5,2.0,0.4));\n    float sdb3=sdBox(pp-vec3(-3.5,0,0.0), vec3(0.5,2.0,0.4));\n    \n    \n    float sds1= sdSphere(pp-vec3(0,1.5,-9), 2.0 );\n    \n    float sds2= sdSphere(pp-vec3(2.5,4.0,-9.0), 0.4 );\n    float sds3= sdSphere(pp-vec3(-2.5,4.0,-9.0), 0.4 );\n    \n    \n    dif1=differenceSDF(sdb1,  sds1);\n    res=opU(res, vec2(dif1,3));\n    \n    res=opU(res, vec2(sds2,8));\n    res=opU(res, vec2(sds3,8));\n    \n    res=opU(res, vec2(sdb2,6));\n    res=opU(res, vec2(sdb3,6));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tgluv=uv;\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));\n    vec3 ro = vec3(0, 3.5, -8.5);\n\n    //vec3 ro = vec3(0, 2.5, iTime*2.0);\n    \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n    //vec3 rd = normalize(vec3(uv.x+iMouse.x/iResolution.y, uv.y+iMouse.y/iResolution.y, 1.0));\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\t\n   \n    \n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    //float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    \n    \n    float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2+dif3)/2.0;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 373, 406, 406, 471], [472, 490, 526, 526, 595], [596, 611, 642, 642, 792], [793, 813, 849, 849, 936], [937, 953, 985, 1013, 1074], [1127, 1127, 1173, 1173, 1205], [1207, 1207, 1249, 1249, 1281], [1283, 1283, 1330, 1330, 1363], [1366, 1366, 1395, 1395, 1521], [1523, 1523, 1559, 1559, 1676], [1678, 1678, 1714, 1714, 1832], [1892, 1892, 1929, 1929, 2451], [2507, 2507, 2535, 2535, 3588], [3639, 3748, 3785, 3785, 3820], [3823, 3823, 3848, 3848, 5065], [5068, 5068, 5102, 5102, 5336], [5339, 5339, 5363, 5363, 5595], [5599, 5599, 5623, 5623, 6008], [6011, 6011, 6037, 6037, 6401], [6447, 6447, 6519, 6519, 6546], [6548, 6548, 6605, 6605, 7780]], "test": "error"}
{"id": "3lt3Rr", "name": "Cuarto chico-color-v3", "author": "jorge2017a1", "description": "Cuarto chico-color-v3", "tags": ["cuartochicocolorv3"], "likes": 0, "viewed": 35, "published": "Public", "date": "1575472322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 4-dic-2019\n\n//const int nrofrays = 15;\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   \n    \n    \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    res = opU(res, vec2(planeDist, 6));\n    \n    \n    \n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,0.8));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,0.8));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,0.8));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,0.8));\n    float bxAtras = sdBox (p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.1));\n    \n    \n    \n    res = opU(res, vec2(bxInf, CInf));\n    //res = opU(res, vec2(bxDer, CDer));\n    //res = opU(res, vec2(bxIzq, CIzq));\n    //res = opU(res, vec2(bxAtras, CAtras));\n    //res = opU(res, vec2(bxSup, CSup));\n    \n    \n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.45,0.8,0.4));\n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    float bxIzqVentana = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.11,0.30,0.25));\n    float bxDerVentana = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.11,0.55,0.25));\n    \n    \n    dif2=differenceSDF(bxIzq,bxIzqVentana);     \n    res = opU(res, vec2(dif2, CIzq));\n    //res = opU(res, vec2(bxIzqVentana, CIzq));\n    \n    \n    \n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n    res = opU(res, vec2(dif1, CAtras));\n    \n    \n    \n    \n       \n    dif2=differenceSDF(bxSup,bxSupVentana);     \n    res = opU(res, vec2(dif2, CSup));\n    \n    \n    \n    dif3=differenceSDF(bxDer,bxDerVentana);     \n    res = opU(res, vec2(dif3, CDer));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n\nvec3 hsv2rgb_smoothv2(vec3 p) {\n    vec3 rgb = clamp( abs(mod(p.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn p.z * mix( vec3(1), rgb, p.y);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));\n\n    vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    float dif = GetLight(p);\n    float dif2 = abs(1.25- GetLight(pluz));\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    colobj=(hsv2rgb_smoothv2(colobj)*0.8+colobj*1.85)/2.0;\n\t\n    vec3 col1;\n    col1=vec3(dif);\n    col1=(hsv2rgb_smoothv2(col1));\n    \n    \n    dif=(dif+dif2)/1.5;\n    \n    vec3 col2;\n    col2=vec3(dif);\n    col =( col2*colobj+col1)/1.5;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 406, 439, 439, 504], [505, 523, 559, 559, 628], [629, 644, 675, 675, 825], [826, 846, 882, 882, 969], [970, 986, 1018, 1046, 1107], [1160, 1160, 1206, 1206, 1238], [1240, 1240, 1282, 1282, 1314], [1316, 1316, 1363, 1363, 1396], [1399, 1399, 1428, 1428, 1554], [1608, 1608, 1636, 1636, 2617], [2672, 2672, 2697, 2697, 4484], [4487, 4487, 4521, 4521, 4755], [4758, 4831, 4879, 4879, 5035], [5038, 5038, 5069, 5069, 5231], [5235, 5235, 5259, 5259, 5491], [5495, 5495, 5519, 5519, 5904], [5911, 5911, 5968, 5968, 6834]], "test": "error"}
{"id": "3lt3zr", "name": "2d doodle v.2", "author": "julianlumia", "description": "version 2", "tags": ["2d"], "likes": 7, "viewed": 109, "published": "Public", "date": "1575477999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float circleDiv = .2;\n    float tau = 3.1415926535*circleDiv;\n    float a = atan(p.x,p.y);\n    float r = length(p)*tan(iTime*0.5);\n    vec2 uv = vec2(a/tau,r);\n\tfloat xCol = (uv.x - (iTime / 2.0)) * 1.0;\n\txCol = mod(xCol, 1.0);\n\tvec3 stripes = vec3(0.4, .2, .3);\t\n    float circlesize = 1.0;\n\tuv = (2.0 * uv) - 1.0;\n\tvec3 horBeam = vec3(0.1*cos(uv.y*4.0)*clamp(floor( circlesize*sin(iTime*4.)),4.0, 10.0)*abs(10.0 / (40.0 * uv.y)));\n\tif (xCol < .5) \n    \t{\n\t\t stripes.r *= sin(iTime) - xCol;\n         stripes.g *= cos(iTime)  - xCol;\n\t\t stripes.b += xCol;\n\t\t}\n    uv = p;\n    //uv *= abs(uv);\n  \tfloat r2 = max( 0.,  sin(iTime)+3. - length(uv) );\n    float t = (iTime*1.);\n    t = r2 * r2 * cos(r2+t) * 5.;    \n    uv *= mat2( cos(t), sin(t), cos(t), cos(t) );\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx);\n    col *=0.4;\n    vec3 horBeam2 = horBeam;\n    horBeam *= smoothstep(0.,.5, vec3(uv.yx,horBeam.z));\n    horBeam2 += smoothstep(0.,.5, vec3(uv.yx,horBeam.z));\n    horBeam = mix(horBeam,horBeam2,0.3);\n    fragColor = vec4((( horBeam) * stripes +col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1183]], "test": "ok"}
{"id": "3ltGDf", "name": "Mandelbrot Variable Iterations", "author": "FairlyArrogant", "description": "This is a simple Mandelbrot viewer used to show how changing  the max iterations in the escape time algorithm can affect the generated image. If you have any tips, tricks, or see anything I should improve on, please let me know in the comments!\n", "tags": ["2d", "fractal", "simple", "mandelbrot", "beginner", "iterations", "mandlebrot", "ink", "variable", "twodimensional"], "likes": 1, "viewed": 99, "published": "Public", "date": "1577788555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getGradientColor(int iteration, int maxIteration){\n    return 1.0 -float(iteration) / float(maxIteration);\n}\n\n//Thanks to FabriceNeyret2 for simplifying this method!\nfloat getSegmentedColors(int iteration,int maxIteration){\n\treturn 1.0 - min(1.0, float(iteration * 4 / maxIteration) / 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.y; \n    \n    //----------------------------Some interesting locations-------------------------------\n    //\n    //Full Mandelbrot\n    //xMin = -2.5, yMin = -1.0, change = 2.0, maxIteration = 500, and minIteration = 30.\n    //\n    //SeaHorses\n    //xMin = -0.75, yMin = 0.1, change = 0.01, maxIteration = 500, and minIteration = 0.\n    //\n    //Zoomed in sea horse.\n    //xMin = -0.748, yMin = 0.11, change = 0.004, maxIteration = 500, and minIteration = 0.\n    //\n    //-------------------------------------------------------------------------------------\n    \n    //xMin and yMin are the mandelbrot coordinates displayed in the bottom right corner of the display. \n    float xMin = -0.75; //The minimum x-coordinate for the viewing window. \n    float yMin =  0.1; //The minimum y-coordinate for the viewing window.\n    float change = 0.01;\n    \n    float speed = 1.0; //The animation play speed. Increase to play it faster.\n    int maxIteration = 600;\n    int minIteration = 30;\n    \n    vec2 location = vec2(uv.x * change + xMin, uv.y * change + yMin);\n    \n    int variableIteration = minIteration + int(float((maxIteration - minIteration)) * (cos(speed * iTime) * 0.5 + 0.5));\n\t\n    vec2 coordinates = vec2(0.0);\n    \n    int currentIteration = 0;\n    \n    for(int i = 0; i <= variableIteration; i++){\n        vec2 squared = vec2(pow(coordinates.x, 2.0), pow(coordinates.y,2.0));\n        currentIteration = i;\n        \n        if((dot(squared,vec2(1.0))) >= 4.0){\n            break;\n    \t}\n        else{\n            coordinates = vec2(squared.x - squared.y + location.x, (2.0 * coordinates.x * coordinates.y + location.y));\n        }\n    }\n    //There are two different coloring methods programmed in, one will color the mandelbrot with\n    //four different shades of gray/grey while the other will color each pixel with a linear gradient\n    //between white and black based on the iterations reached.\n    \n    float value = getSegmentedColors(currentIteration, variableIteration);\n    //float value = getGradientColor(currentIteration, variableIteration);\n    \n    vec3 col = vec3(1.0, 0.0, 0.53) * vec3(value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 114], [116, 172, 229, 229, 298], [300, 300, 357, 357, 2572]], "test": "ok"}
{"id": "3ltGRj", "name": "crowdy flashes ( 223/247 chars )", "author": "FabriceNeyret2", "description": "Golfing [url]https://shadertoy.com/view/Ml2Bz1 [/url]", "tags": ["star", "starfield", "2tweets", "golf"], "likes": 5, "viewed": 304, "published": "Public API", "date": "1576867390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfing of  https://shadertoy.com/view/Ml2Bz1 ( 455 chars )\n\n// -24 without the subtle color  + .004* r( vec4(5,6,7,0) )\n\n#define r(s)    fract( 1e4* sin( i.x + .1*s ) )                            //\nvoid mainImage(out vec4 O, vec2 U) {       \n    vec2 R = iResolution.xy, V, k=O.xw, i=k;\n    for (O -= .3 ; i.x++ < 4e2;\n        O += R.y / max(V.x,V.y)\n              * r(2.) * ( .02 + .004* r( vec4(5,6,7,0) ) )\n              * pow( .5 + .5* sin( (1.+r(3.))*iTime/.1 + 6.*r(4.) ) , 3.) )\n        V = abs( U - r(k) * R ) * mat2(4,0,2,3.4);\n}/*\n\n\n\n\n\n// --- 289 chars \n\n#define r(s)    fract( 1e4*sin(i+s) )                             //\n#define mainImage(O,U)                                             \\\n    vec2 R = iResolution.xy, V;                                    \\\n\tO -= .3;                                                       \\\n    for (float i=0.; i++ < 4e2; )                                  \\\n        V = abs(  ( U - r(vec2(0,.1)) *R )                         \\\n                 * mat2(cos(iTime+vec4(0,33,11,0))) )              \\\n            * mat2(4,0,2,3.4),                                     \\\n        O += .02*R.y / max(V.x,V.y)                                \\\n              * r(.2)                                              \\\n              * pow(.5 + .5* sin( (1.+r(.3))*iTime/.1 + r(.4)*6. ), 3.) \\\n              * ( 1. + .2*r(vec4(.5,.6,.7,0) ) )                  /*\n\n\n\n\n\n// --- 339 chars \n\n#define r(x)    fract(1e4*sin((x)*541.17))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, V;\n\tO -= .3;\n    for (float i=0.; i++<4e2; )\n        V = abs( ( U+U-R - ( 2.*r(i + vec2(0,.1)) -1. ) * R ) / R.y \n           * mat2(cos(iTime+vec4(0,33,11,0))) ) \n           * mat2(2,0,1,1.7),\n        O += .05/max(V.x,V.y)\n              * r(i+.2) \n              * pow(.5 + .5*sin( (10.+10.*r(i+.07)) *iTime + r(i+.35)*6.), 3.)*.4 \n              * (.9+.2*r(i + vec4(.4,.5,.6,0) ) ); \n}\n\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 239, 239, 543]], "test": "ok"}
{"id": "3ltGz8", "name": "InterferencePatt_InPhase", "author": "kslater3", "description": "InterferencePatt", "tags": ["interferencepatt"], "likes": 2, "viewed": 47, "published": "Public", "date": "1575604232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor.r = ( sin( 5.0f * (pow(uv.x - 0.3f, 2.0f)/pow(0.075f, 2.0f) + pow(uv.y - 0.5f, 2.0f)/pow(0.075f, 2.0f)) + iTime ) + sin( 5.0f * (pow(uv.x - 0.6f, 2.0f)/pow(0.075f, 2.0f) + pow(uv.y - 0.5f, 2.0f)/pow(0.075f, 2.0f)) + iTime ) ) / 2.0f;\n    fragColor.b = 0.0f;\n    fragColor.g = 0.0f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 450]], "test": "ok"}
{"id": "3sySWt", "name": "Twitch: Slime on Slime", "author": "blackle", "description": "made some slime by accident while listening to slime tom's music. watch the recording here https://www.twitch.tv/videos/515979354", "tags": ["slime", "twitch", "livecode"], "likes": 6, "viewed": 338, "published": "Public API", "date": "1575254718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 k) {\n  int x = FK(k.x);int y = FK(k.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat hash3(vec3 k) {\n  float h1 = hash(k.xy);\n  return hash(vec2(h1, k.z));\n}\n\nvec3 hash33(vec3 k) {\n  float h1 = hash3(k);\n  float h2 = hash3(k*h1);\n  float h3 = hash3(k*h2);\n  return vec3(h1, h2, h3);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec3 sphercoord(vec2 p) {\n  float l1 = acos(p.x);\n  float l2 = acos(-1.)*p.y;\n  return vec3(cos(l1), sin(l1)*sin(l2), sin(l1)*cos(l2));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(p,ax);\n}\n\nfloat comp(vec3 p, vec3 ro, float t) {\n  vec3 ax = sphercoord(ro.xy);\n  p = erot(p, ax, ro.z*acos(-1.));\n  p.z += t;\n  float scale = 4. + hash(ro.xz)*0.5+0.5;\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - 0.8;\n}\n\nfloat scene(vec3 p) {\n  float rad = 3.-abs(p.z);\n  float dist = 10000.;\n  for (int i = 0; i < 5; i++) {\n    vec3 rot = hash33(vec3(float(i+1), cos(float(i)), sin(float(i))));\n    float d = comp(p, rot, iTime/2.);\n    dist = smin(dist, d, 1.);\n  }\n  return mix(dist, rad, mix(0.3,0.8+sin(iTime)*0.2, sign(p.z)*0.5+0.5));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.1);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat drawdist = 40.;\nvec3 trace(vec3 init, vec3 cam, int itcout, inout bool hit) {\n  vec3 p = init;\n  hit = false;\n  for (int i = 0; i < itcout; i++) {\n    float dist = scene(p)*1.1;\n    if (abs(dist) < 0.001) { hit = true; p+= dist*cam; break;}\n    if (distance(p, init) > drawdist) { break; }\n    p += dist*cam;\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  uv.x += sin(uv.x*5.+iTime)*0.03;\n  uv.x += sin(uv.y*3.+0.9*iTime)*0.03;\n  uv.y += sin(uv.x*7.-0.7*iTime)*0.01;\n  uv.y += sin(uv.y*4.+0.6*iTime)*0.01;\n\n  \n  vec3 slimecol = vec3(0.05,0.4,0.05);\n  float bt = floor(iTime*0.8);\n  float beat = mod(bt, 4.);\n  if (beat ==1.) slimecol = slimecol.yxz;\n  if (beat ==2.) slimecol = vec3(0.05,0.2,0.4);\n  if (beat ==3.) slimecol = slimecol.yxy;\n  \n  vec3 cam = normalize(vec3(0.8,uv));\n  bool hit = false;\n  vec3 col = vec3(1);\n  vec3 totalball = vec3(1);\n  vec3 p; vec3 n;\n  vec3 init = vec3(0,0,sin(iTime*0.37)*1.4);\n  cam = erot(cam, vec3(0,1,0), -0.2);\n  init = erot(init, vec3(0,1,0), -0.2);\n  cam = erot(cam, vec3(1,0,0), hash(vec2(bt,bt))*0.2);\n  init = erot(init, vec3(1,0,0), hash(vec2(bt,bt))*0.2);\n  init += vec3(mod(iTime,100.)*3.+beat*8.,0.,0.);\n  vec3 firtn;\n  float fog;\n  for (int i = 0; i < 3; i++) {\n    p = trace(init, cam, 300/(i+1), hit);\n    if (!hit) break;\n    n = norm(p);\n    if (i ==0) firtn = n;\n    float fresnel = pow(1.-abs(dot(cam, n))*0.98,2.);\n    if (i==0) { fog = pow(distance(p, init)/drawdist, 2.); }\n    col *= fresnel*mix(slimecol,vec3(1),0.4);\n    cam = reflect(cam, n);\n    hit = false;\n    init = p+n*.01;\n  }\n  col = mix(col, vec3(1), fog);\n\n  fragColor.xyz = sqrt(1.-(1.-slimecol*(sin(firtn*4.)*0.3+0.7))*(1.-col));\n  fragColor.xyz = smoothstep(vec3(0),vec3(1),fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sySWt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[249, 249, 269, 269, 348], [350, 350, 371, 371, 428], [430, 430, 451, 451, 555], [557, 557, 598, 598, 682], [684, 684, 709, 709, 821], [823, 823, 861, 861, 925], [927, 927, 965, 965, 1147], [1149, 1149, 1170, 1170, 1470], [1472, 1472, 1491, 1491, 1601], [1625, 1625, 1686, 1686, 1935], [1937, 1937, 1994, 1994, 3500]], "test": "timeout"}
{"id": "3t33Rj", "name": "Metallic Blob", "author": "vlams1", "description": "It's.. alive?\nGot inspired by one of iq's shaders (don't know what it was called..) and tried to achieve something similar.", "tags": ["raymarcher"], "likes": 2, "viewed": 390, "published": "Public", "date": "1576790659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IT 32\n#define SD .005\n#define MD 8.\n\nmat2 rot(float a) {\n    float s = sin(radians(a));\n    float c = cos(radians(a));\n    return mat2(c,-s,s,c);\n}\n\nfloat dist(vec3 p) {\n    float d = dot(normalize(p),vec3(0.,1.,0.));\n    float s = sin(atan(p.x,p.z)*5.) * pow(1.-d,.75);\n    float c = cos(d*3.1415*2.5+iTime*2.);\n    return length(p)-2.+s*c*.3;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float td;\n    for (int i; i < IT; i++) {\n        float d = dist(p);\n        td += d;\n        p += rd * d;\n        if (abs(d) < SD || td > MD) break;\n    }\n    return p;\n}\n\nvec3 normal(vec3 p) {\n    vec2 o = vec2(SD,0);\n    return normalize(vec3(\n    dist(p+o.xyy)-dist(p-o.xyy),\n    dist(p+o.yxy)-dist(p-o.yxy),\n    dist(p+o.yyx)-dist(p-o.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,3,-5);\n    vec3 rd = normalize(vec3(uv,1));\n    rd.yz *= rot(31.);\n    ro.xz *= rot(iTime*18.);\n    rd.xz *= rot(iTime*18.);\n    vec3 p = raymarch(ro,rd);\n    vec3 n = normal(p);\n    vec3 ld = normalize(vec3(0,3,-1));\n    float l = length(raymarch(p+n*SD*2.,ld)-p) < MD ? 0. : max(dot(n,ld),0.);\n    float b = dot(rd,ld)*.5+.5;\n    float s = pow(max(dot(reflect(rd,n),ld),0.),50.);\n    vec3 obj = mix(vec3(0.,.1,.2),vec3(.7,.8,1.),l)+s*l;\n    vec3 sky = mix(vec3(0.,.05,.1),vec3(.4,.6,.9),b);\n    vec3 col = length(p) < 3. ? obj : sky;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t33Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 64, 64, 155], [157, 157, 177, 177, 354], [356, 356, 389, 389, 581], [583, 583, 604, 604, 759], [761, 761, 817, 817, 1465]], "test": "ok"}
{"id": "3t33W4", "name": "::circletest", "author": "psicoskl", "description": "test", "tags": ["test"], "likes": 1, "viewed": 64, "published": "Public", "date": "1576254685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv =  uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(dot(uv, uv));\n    col.r = sin(col.r + iTime*0.3) * 0.5 + 0.5;\n    col.g = sin(col.r + iTime*0.5) * 0.5 + 0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t33W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 437]], "test": "ok"}
{"id": "3t33Wr", "name": "Biquadratic family (hopefully)", "author": "inou", "description": "Biquadratic family (z^2+a)^2+b\nBased on (or, small modification of):\n \tJulia - Quaternion by inigo quilez\n \thttps://www.shadertoy.com/view/MsfGRr\n\nBy changing TYPE macro, one can choose which parameter set to draw.\n(See the source code for details).", "tags": ["raymarching", "mandelbrot"], "likes": 3, "viewed": 1203, "published": "Public", "date": "1575995514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Biquadratic family (z^2+a)^2+b by Hiroyuki Inou\n// Based on (or, small modification of):\n// \tJulia - Quaternion by inigo quilez\n// \thttps://www.shadertoy.com/view/MsfGRr\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// antialais level (1, 2, 3...)\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n// 0: slower escaping algorithm (non-shift locus/bifurcation locus)\n// 1: faster escaping algorithm (connectedness locus)\n// 2: non-escaping locus of the critical value b\n// 3: non-escaping locus of the critical point 0\n#define TYPE 1\n\n// 0: numerical normals (central differences)\n// 1: analytic normals\n// 2: analytic normals optimized\n#define METHOD 1\n\nconst int numIterations = 11;\n\nfloat map( in vec3 p, out vec4 oTrap, in float w0 )\n{\n    vec4 z = vec4(p, w0);\n    \n    vec4 trap = vec4(abs(z.xyz),dot(z,z));\n\n    float n = 2.0;  \n#if TYPE < 3\n    vec2 x = vec2(z.z,z.w); // x = b\n#else\n    vec2 x = vec2(0,0); // x = 0\n#endif    \n    vec2 mda = vec2(0,0); // a derivative of x\n    vec2 mdb = vec2(1,0); // b derivative of x\n\tfloat mz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + a)^2 + b\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        \n        mz2 = dot(x,x);\n        \n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n#if TYPE<2    \n    vec2 y = x;\n    vec2 mda1=mda;\n    vec2 mdb1=mdb;\n    float mz21=mz2;\n\n    float m = n;\n    n = 2.0;\n    x = vec2(z.x,z.y); // z = a\n    mda = vec2(1,0);\n    mdb = vec2(0,0);\n\tmz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + b)^2 + a\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        \n        mz2 = dot(x,x);\n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n    \n    // choose faster/slower escaping \n#if TYPE==1\n    if (exp2(-m)*log(mz21) > exp2(-n)*log(mz2)) {\n#else\n    if (exp2(-m)*log(mz21) < exp2(-n)*log(mz2)) {\n#endif\n        n=m; x=y; mda=mda1; mdb=mdb1; mz2=mz21;\n    }\n#endif\n    oTrap = trap;\n\n    return 0.25*sqrt(mz2/(dot(mda,mda)+dot(mdb,mdb)))*log(mz2);  \n}\n\n#if METHOD==0\nvec3 calcNormal( in vec3 pos, in float w0 )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, kk, w0 ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk, w0 ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk, w0 ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk, w0 ) );\n}\n#endif\n\n#if METHOD==1\nvec3 calcNormal( in vec3 p, in float w0 )\n{\n    vec4 z = vec4(p,w0);\n    \n    float n = 2.0;    \n#if TYPE < 3\n    vec2 x = vec2(z.z,z.w); // x = b\n#else\n    vec2 x = vec2(0,0); // x = 0\n#endif    \n    vec2 mda = vec2(0,0); // a derivative of x\n    vec2 mdb = vec2(1,0); // b derivative of x\n\tfloat mz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + a)^2 + b\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        \n        mz2 = dot(x,x);\n        \n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n#if TYPE<2    \n    vec2 y = x;\n    vec2 mda1=mda;\n    vec2 mdb1=mdb;\n    float mz21=mz2;\n\n    float m = n;\n    n = 2.0;\n    x = vec2(z.x,z.y); // z = a\n    mda = vec2(1,0);\n    mdb = vec2(0,0);\n\tmz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + b)^2 + a\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        \n        mz2 = dot(x,x);\n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n    \n    // choose faster/slower escaping \n#if TYPE==1\n    if (exp2(-m)*log(mz21) > exp2(-n)*log(mz2)) {\n#else\n    if (exp2(-m)*log(mz21) < exp2(-n)*log(mz2)) {\n#endif\n        x=y; mda=mda1;mdb=mdb1;\n    }\n#endif\n    return normalize(vec4(x.x*mda.x+x.y*mda.y,\n                          -x.x*mda.y+x.y*mda.x,\n                          x.x*mdb.x+x.y*mdb.y,\n                          -x.x*mdb.y+x.y*mdb.x).xyz);\n}\n#endif\n/*\n#if METHOD==2\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    // identity derivative\n    vec4 J0 = vec4(1,0,0,0);\n    vec4 J1 = vec4(0,1,0,0);\n    vec4 J2 = vec4(0,0,1,0);\n    \n  \tfor(int i=0; i<numIterations; i++)\n    {\n        vec4 cz = qconj(z);\n        \n        // chain rule of jacobians (removed the 2 factor)\n        J0 = vec4( dot(J0,cz), dot(J0.xy,z.yx), dot(J0.xz,z.zx), dot(J0.xw,z.wx) );\n        J1 = vec4( dot(J1,cz), dot(J1.xy,z.yx), dot(J1.xz,z.zx), dot(J1.xw,z.wx) );\n        J2 = vec4( dot(J2,cz), dot(J2.xy,z.yx), dot(J2.xz,z.zx), dot(J2.xw,z.wx) );\n\n        // z -> z2 + c\n        z = qsqr(z) + c; \n        \n        if(dot(z,z)>4.0) break;\n    }\n    \n\tvec3 v = vec3( dot(J0,z), \n                   dot(J1,z), \n                   dot(J2,z) );\n\n    return normalize( v );\n}\n#endif\n\n// this method does not work, but in my mind, it should\n#if METHOD==3\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    vec4 dz = vec4(1,0,0,0);\n    \n  \tfor(int i=0; i<numIterations; i++)\n    {\n        // z' = 2z'z\n\t\tdz = 2.0*qmul( z, dz );\n        \n        // z -> z2 + c\n        z = qsqr(z) + c; \n        \n        if(dot(z,z)>4.0) break;\n    }\n    \n\tvec4 v = qconj(qmul( dz, qconj(z) ));\n    \n    return normalize( v.xyz );\n}\n#endif\n*/\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 res, in float w0 )\n{\n    vec4 tmp;\n    float resT = -1.0;\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<300; i++ )\n    {\n        if( h<0.0001||t>maxd ) break;\n\t    h = map( ro+rd*t, tmp, w0);\n        t += h;\n    }\n    if( t<maxd ) { resT=t; res = tmp; }\n\n\treturn resT;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k, in float w0 )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk, w0);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float w0 )\n{\n\tconst vec3 sun = vec3(  0.577, 0.577,  0.577 );\n    \n\tvec4 tra;\n\tvec3 col;\n    float t = intersect( ro, rd, tra, w0 );\n    if( t < 0.0 )\n    {\n     \tcol = vec3(0.7,0.9,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,sun),0.0,1.0), 48.0 );\n\t}\n\telse\n\t{\n        vec3 mate = vec3(1.0,0.8,0.7)*0.3;\n\t\t//mate.x = 1.0-10.0*tra.x;\n        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, w0 );\n        \n\t\tfloat occ = clamp(2.5*tra.w-0.15,0.0,1.0);\n\t\t\n\n        col = vec3(0.0);\n\n        // sky\n        {\n        float co = clamp( dot(-rd,nor), 0.0, 1.0 );\n        vec3 ref = reflect( rd, nor );\n        //float sha = softshadow( pos+0.0005*nor, ref, 0.001, 4.0);\n        float sha = occ;\n        sha *= smoothstep( -0.1, 0.1, ref.y );\n        float fre = 0.1 + 0.9*pow(1.0-co,5.0);\n            \n\t\tcol  = mate*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*occ;\n\t\tcol +=  2.0*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*sha*fre;\n        }\n\n        // sun\n        {\n        const vec3 lig = sun;\n        float dif = clamp( dot( lig, nor ), 0.0, 1.0 );\n        float sha = softshadow( pos, lig, 0.001, 64.0, w0 );\n        vec3 hal = normalize( -rd+lig );\n        float co = clamp( dot(hal,lig), 0.0, 1.0 );\n        float fre = 0.04 + 0.96*pow(1.0-co,5.0);\n        float spe = pow(clamp(dot(hal,nor), 0.0, 1.0 ), 32.0 );\n        col += mate*3.5*vec3(1.00,0.90,0.70)*dif*sha;\n        col +=  7.0*3.5*vec3(1.00,0.90,0.70)*spe*dif*sha*fre;\n        }\n\n        // extra fill\n        {\n        const vec3 lig = vec3( -0.707, 0.000, -0.707 );\n\t\tfloat dif = clamp(0.5+0.5*dot(lig,nor), 0.0, 1.0 );\n        col += mate* 1.5*vec3(0.14,0.14,0.14)*dif*occ;\n        }\n        \n        // fake SSS\n        {\n        float fre = clamp( 1.+dot(rd,nor), 0.0, 1.0 );\n        col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\n        }\n    }\n\n\treturn pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // anim\n    float time = iTime*.15;\n    //vec4 c = vec4(1.5,1.5,0.7,0.7)*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.0,0.0,1.0,0.0);\n\tfloat w0 = sin(time*0.3);\n    \n    // camera\n\tfloat r = 1.5+0.15*cos(0.0+0.29*time);\n    vec3 ro = vec3(           r*cos(0.3+0.37*time), \n\t\t\t\t\t2.3 + 0.8*r*cos(1.0+0.33*time), \n\t\t\t\t\t          r*cos(2.2+0.31*time) );\n    //ro = ro.yxz;\n \tvec3 ta = vec3(0.0,0.0,0.0);\n    float cr = 0.1*cos(0.1*time);\n    \n    \n    // render\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(float(i),float(j))/float(AA))) / iResolution.y;\n\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        col += render( ro, rd, w0 );\n    }\n    col /= float(AA*AA);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.25);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t33Wr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[6941, 6941, 7011, 7011, 7293], [7295, 7295, 7373, 7373, 7648], [7650, 7650, 7702, 7702, 9566], [9568, 9568, 9625, 9637, 10756]], "test": "ok"}
{"id": "3t3Gzj", "name": "paraMejorarv1", "author": "jorge2017a1", "description": "paraMejorarv1", "tags": ["paramejorarv1"], "likes": 0, "viewed": 33, "published": "Public", "date": "1576793246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d, dif1, dif2;\n     vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n    pp.xz=opRep(pp.xz,10.0);\n    \n    \n\n    float bxDer = sdBox (pp-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,2.5));\n    float bxIzq = sdBox (pp-vec3(1.6,1.9,4.5),vec3(0.1,1.0,2.5));\n    float bxSup = sdBox (pp-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,2.5));\n\n    \n    float Cielo = sdBox (pp-vec3(0.0,5.0,4.5),vec3(8.0,0.1,8.0));\n    float dtri1=sdTriPrism(pp -vec3(0,3.5,4.5), vec2(1,1.5) );\n    \n   \n\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          {\n              res=vec2(res.x,CSky); \n              \n          }\n        else\n         { \n            //res=vec2(res.x, CPlane2);\n              vec2 cb = floor(p.xz);\n\t\t\t  float cb2 = mod(cb.x + cb.y, 2.0);\n              res=vec2(-cb2,11);\n         } \n     } \n    \n   \n    \n\n    res = opU(res, vec2(bxDer, CDer));\n    res = opU(res, vec2(bxIzq, CIzq));\n    res = opU(res, vec2(bxSup, CSup));\n    res=opU(res, vec2( Cielo, 8));\n    res=opU(res, vec2 (dtri1,11));\n\n\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);    \n    TObj Obj;\n    \n\n\n    vec3 ro = vec3(0, 2.5, iTime*2.0);\n    \n\n    vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n  \n    float dif = GetLightv2(p);\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2)/1.5;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3Gzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 349, 382, 382, 447], [448, 466, 502, 502, 571], [572, 587, 618, 618, 768], [769, 789, 825, 825, 912], [913, 929, 961, 989, 1050], [1103, 1103, 1149, 1149, 1181], [1183, 1183, 1225, 1225, 1257], [1259, 1259, 1306, 1306, 1339], [1342, 1342, 1371, 1371, 1497], [1551, 1551, 1579, 1579, 2560], [2614, 2723, 2760, 2760, 2795], [2798, 2798, 2823, 2823, 4084], [4087, 4087, 4121, 4121, 4355], [4361, 4361, 4385, 4385, 4617], [4621, 4621, 4645, 4645, 5030], [5033, 5033, 5059, 5059, 5423], [5428, 5428, 5485, 5485, 6159]], "test": "error"}
{"id": "3tc3D7", "name": "blend Colors", "author": "ligaobo", "description": "ä¸åé¢è²çèå", "tags": ["2dvoronoi", "polarvnoise"], "likes": 2, "viewed": 70, "published": "Public", "date": "1576490865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//åèï¼ https://www.shadertoy.com/view/XlByRc\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Voronoi noise\nfloat vnoise(vec2 p)\n{\n    vec2 cell_i = floor(p);\n    vec2 cell_f = fract(p);\n    \n    float min_dist = 2.0;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n        \n \t\t\tvec2 xy = vec2(float(x), float(y)); \n            vec2 point = random2(cell_i + xy);\n            point = 0.5 + 0.5*sin(6.2831*point);\n        \tfloat dist = distance(cell_f, xy + point);\n        \tmin_dist = min(min_dist, dist);\n        }\n    }\n\treturn min_dist;\n}\n\nfloat fbm(vec2 p)\n{\n    float v;\n    \n    v  = vnoise(p * 1.0) * 0.5;\n    v += vnoise(p * 2.0) * 0.25;\n    v += vnoise(p * 4.0) * 0.125;\n    v += vnoise(p * 8.0) * 0.0625;\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    if(length(uv) > 1.0) \n    {\n        fragColor = vec4(0.0);\n        //return;\n    }\n    \n    vec3 color;\n\n    vec2 polar = vec2(abs(atan(uv.y, uv.x)), length(uv) * 0.75);\n    polar *= 6.0;\n    float liquidDepth = mix(fbm(polar), fbm(uv * 1.0), smoothstep(2.0, 0.0, length(uv)));\n\n    color = mix(vec3(0.9, 0.0, 0.0), vec3(0.7, 0.6, 0.0), clamp(fbm(uv * 1.), 0.0, 0.7)) + 0.2;\n    \n    //color *= exp(-( liquidDepth * 0.5 - 0.2) * 2.0);\n    \n    //liquidDepth = log(exp(liquidDepth) - 0.2) * 2.0;\n    //liquidDepth = clamp((liquidDepth - 0.3) / (1.0 - 0.7), 0.0, 1.0);\n    \n    //color *= exp(-vec3(0.3, 0.1, 0.018) * (liquidDepth) * (1.0 + cos(iTime * 1.0)) * 2.0);\n    \n    //color = vec3(liquidDepth);\n    \n    //è¡°åå½æ°exp ä¸ smoothstepå¯¹æ¯æµè¯\n#if 0 \n    {\n        if(uv.x > 0.0)\n        \tcolor = mix(vec3(0.9, 0.0, 0.0), vec3(0.7, 0.6, 0.0), smoothstep(-1.0, 1.0, uv.y) - 0.0) + 0.2;\n        //color *= exp(vec3(0.9, 0.9, 0.9) * (uv.y - 1.0) * 0.5);\n        color *= exp(vec3(0.9, 0.9, 0.5) * (uv.y - 1.0) * 0.85);\n    }\n#else\n    //color *= exp(-( liquidDepth * 0.5 - 0.2) * 2.0);\n    \n    //liquidDepth = log(exp(liquidDepth) - 0.2) * 2.0;\n    //liquidDepth = clamp((liquidDepth - 0.3) / (1.0 - 0.7), 0.0, 1.0);\n    \n    color *= exp(-vec3(0.3, 0.1, 0.018) * (liquidDepth) * (1.0 + cos(iTime * 1.0)) * 2.0);\n    \n    //color = vec3(liquidDepth);\n#endif\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tc3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 75, 75, 168], [170, 187, 209, 209, 645], [647, 647, 666, 666, 839], [841, 841, 898, 898, 2380]], "test": "timeout"}
{"id": "3tc3RN", "name": "The Family Shader", "author": "blackle", "description": "today I plugged my computer to the family television and live coded a shader for my family while we all listened to music and my sister's boyfriend put on a fashion show. it was a good night c:", "tags": ["liveshader", "livecode"], "likes": 9, "viewed": 367, "published": "Public API", "date": "1575689615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat square(vec3 p, vec3 dim) {\n  p = abs(p);\n  p -= dim;\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat bpm = 117.;\n#define beat fract(iTime/60.*bpm)\n#define bar floor(iTime/60.*bpm)\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\n\nfloat cage(vec3 p, float r) {\n  p = abs(p);\n  vec3 t = (mod(bar,2.)==1.) ? vec3(0.,r,r) : vec3(r,0.,0.);\n  float bst = linedist(p, t.xyz, vec3(r,r,r));\n  bst = min(linedist(p, t.zxy, vec3(r,r,r)), bst);\n  bst = min(linedist(p, t.yzx, vec3(r,r,r)), bst);\n  return bst-0.1;\n}\n\nvec2 smin(vec2 a, vec2 b, float k){\n  float h = max(k - abs(a.x-b.x),0.)/k;\n  float fac = mix(a.y,b.y,smoothstep(-k/2., k/2., a.x-b.x));\n  return vec2(min(a.x,b.x)-h*h*h*k/6., fac);\n}\n\nfloat comp(vec3 p, vec3 sc, float sz) {\n  p = (fract(p*sc)-0.5)/sc;\n  return length(p) - sz;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat mat = 0.;\n#define time (iTime*2.)\nfloat scene(vec3 p) {\n  vec3 op = p - vec3(time,0,0);\n  op = erot(op, vec3(0,1,0),iTime);\n  op = erot(op, vec3(0,0,1),iTime*0.5);\n  op = erot(op, vec3(1,0,0),iTime*0.25);\n  \n  vec3 op2 = p - vec3(time,0,0);\n  op2 = erot(op, vec3(0,1,0),-iTime);\n  op2 = erot(op, vec3(0,0,1),iTime*0.25);\n  op2 = erot(op, vec3(1,0,0),-iTime*0.5);\n  float scene =0.2;\n  float sq = square(op, vec3(0.45));\n  vec2 best = vec2(comp(p, vec3(0.2), 1.), 0.);\n  best = smin(best, vec2(comp(p-vec3(0,0,iTime), vec3(0.2,0.2,1.2), 0.2),1.),1.);\n  best = smin(best, vec2(comp(p-vec3(0,iTime,0), vec3(0.2,1.2,0.2), 0.2),1.),1.);\n  best = smin(best, vec2(comp(p-vec3(iTime,0,0), vec3(1.2,0.2,0.2), 0.2),1.),1.); \n  mat = best.y;\n  if (sq < best.x) { \n    mat = 2.;\n    best.x = sq;\n  }\n  float cg = cage(op2, 1.5 + sin(iTime*7.)*0.5);\n  if (cg < best.x) { \n    mat = 3.;\n    best.x = cg;\n  }\n  return best.x;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.01);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 cam = normalize(vec3(1.+beat*0.1, uv));\n  vec3 init = vec3(-8.+pow(cos(iTime*acos(-1.)/60.*bpm/6.),2.)*2., 0,0);\n  cam = erot(cam, vec3(0,1,0),sin(iTime/2.)*0.3);\n  init = erot(init, vec3(0,1,0),sin(iTime/2.)*0.3);\n  cam = erot(cam, vec3(0,0,1),iTime*0.2);\n  init = erot(init, vec3(0,0,1),iTime*0.2);\n  \n  init += vec3(time,0,0);\n  vec3 p = init + cam;\n  bool hit = false;\n  for (int i =0; i< 28; i++) {\n    float dist = scene(p);\n    if (dist*dist<0.00001) { hit = true; break; }\n    if (distance(p,init)>40.) break;\n    p += cam*dist;\n  }\n  float fog = smoothstep(40.,0.,distance(init,p));\n  vec3 mcol = mix(vec3(1.), vec3(0.0,0.5,0.9), 1.-mat);\n  if (mat == 2.) mcol = vec3(1.,0.,0.8);\n  vec3 n = norm(p);\n  fragColor.xyz = mix(vec3(0.,0.3,0.5),mcol*(pow(dot(n,vec3(0,0,1))*0.5+0.5,2.)),fog);\n  fragColor.xyz = smoothstep(vec3(0), vec3(1), sqrt(fragColor.xyz));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tc3RN.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 226, 226, 286], [374, 374, 414, 414, 504], [506, 506, 535, 535, 779], [781, 781, 816, 816, 964], [966, 966, 1005, 1005, 1060], [1062, 1062, 1100, 1100, 1160], [1202, 1202, 1223, 1223, 2080], [2082, 2082, 2101, 2101, 2214], [2216, 2216, 2273, 2273, 3287]], "test": "timeout"}
{"id": "3tc3W7", "name": "LightBolt", "author": "Hotrhodium", "description": "Just a simple shader for a game.", "tags": ["streaks"], "likes": 3, "viewed": 89, "published": "Public", "date": "1576479904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0,0.0,0.0);\n    float thickness = 2.0;\n    float spacing = 20.0;\n    if (mod(fragCoord.x,spacing) > spacing-thickness)\n        {\n            col = vec3(1.0,1.0,5.0)*sin((-iTime*10.0)+(fragCoord.x*0.06)+(fragCoord.y*0.02));\n        }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tc3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 345]], "test": "ok"}
{"id": "3tc3zN", "name": "Infinite cogwheels", "author": "mrange", "description": "Messed around with cogwheels distance functions and applied it the IQ's Fractal Nyancat", "tags": ["2d", "julia"], "likes": 25, "viewed": 444, "published": "Public API", "date": "1575710770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by mrange/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Technique from: https://www.shadertoy.com/view/4slGWH\n\n// Messed around with cogwheels distance functions and applied it the IQ's Fractal Nyancat \n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float cogRadius = 0.02;\nconst float smallWheelRadius = 0.30;\nconst float bigWheelRadius = 0.55;\nconst float wheelOffset = smallWheelRadius + bigWheelRadius -cogRadius;\nconst vec3 baseCol = vec3(240.0, 115.0, 51.0)/vec3(255.0);\n\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat unevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(p,vec2(-b,a));\n  if( k < 0.0 ) return length(p) - r1;\n  if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n  return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat softMin(float a, float b, float k) {\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat smallCogwheel(vec2 p) {\n  rot(p, -iTime*2.0 + TAU/32.0);\n  vec2 op  = p;\n  float dc = circle(p, 0.25);  \n  vec2 pp = toPolar(p);\n  mod1(pp.y, TAU/16.0);\n  pp.y += PI/2.0;\n  vec2 cp = toRect(pp);\n  float ds = unevenCapsule(cp, 0.05, cogRadius, smallWheelRadius);\n  float dcw = softMin(ds, dc, 100.0);\n  float dic = circle(p, 0.125/2.0);\n  pp = toPolar(p);\n  mod1(pp.y, TAU/6.0);\n  vec2 ip = toRect(pp);\n  float dic2 = circle(ip - vec2(0.15, 0.0), 0.125/2.0);\n  float di = min(dic, dic2);\n  return max(dcw, -di);\n}\n\nfloat bigCogwheel(vec2 p) {\n  rot(p, iTime);\n  vec2 op  = p;\n  float dc = circle(p, 0.5);  \n  vec2 pp = toPolar(p);\n  mod1(pp.y, TAU/32.0);\n  pp.y += PI/2.0;\n  vec2 cp = toRect(pp);\n  float ds = unevenCapsule(cp, 0.1, cogRadius, bigWheelRadius);\n  float dcw = softMin(ds, dc, 100.0);\n  float dic = circle(p, 0.125);\n  pp = toPolar(p);\n  mod1(pp.y, TAU/6.0);\n  vec2 ip = toRect(pp);\n  float dic2 = circle(ip - vec2(0.3, 0.0), 0.125);\n  float di = min(dic, dic2);\n  return max(dcw, -di);\n}\n\nfloat cogwheels(vec2 p) {\n  p.x += wheelOffset*0.5;\n  float dsc = smallCogwheel(p - vec2(wheelOffset, 0.0));\n  float dbc = bigCogwheel(p);\n  return min(dsc, dbc);\n}\n\n\nfloat df(vec2 p) {\n  float i = modMirror1(p.x, wheelOffset);\n  float sy = mix(1.0, -1.0, mod(i, 2.0));\n  p.y *= sy;\n  float dcs = cogwheels(p);\n  return dcs;\n}\n\nvec4 sample_(vec2 p) {\n  const float borderStep = 0.001;\n  vec3 col = baseCol;  \n  p *= 4.0;\n  float d = df(p);\n  float t = smoothstep(-borderStep, 0.0, -d);\n  t *= exp(-dot(p, p)*0.005);\n  return vec4(col, t);\n}\n\nvec3 saturate(vec3 col) {\n  return clamp(col, 0.0, 1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n  p = vec2(0.5, -0.05) + p*0.75*pow(0.9, 20.0*(0.5+0.5*cos(0.3*sqrt(2.0)*iTime*sqrt(0.5))));\n\n  vec4 col = vec4(0.0);\n  vec3 ss = mix(vec3(0.2, 0.2, 0.5), vec3(0.2,-0.2,1.0), 2.2 + 1.25*sin(iTime*0.5));\n\n  vec2 c = vec2(-0.76, 0.15);\n  rot(c, 0.2*sin(iTime*sqrt(3.0)/12.0));\n  float f = 0.0;\n  vec2 z = p;\n\n  float transparency = 1.0;\n\n  vec3 bg = vec3(0.0);\n\n  float minTrap = 10000.0;\n\n  const int maxIter = 100;\n  const float maxIterF = float(maxIter);\n  for(int i=0; i<=maxIter; ++i)\n  {\n    if (transparency < 0.05) break;\n    float re2 = z.x*z.x;\n    float im2 = z.y*z.y;\n    if((re2 + im2>4.0) || (transparency<0.1)) break;\n    float reim = z.x*z.y;\n\n    z = vec2(re2 - im2, 2.0*reim) + c;\n    minTrap = min(minTrap, length(z - c));\n\n    float fi = f/maxIterF;\n    float shade = pow(1.0-0.5*fi, 1.5);\n\n    vec4 sample_ = sample_(ss.xy + ss.z*z);\n    float ff = mix(0.0, 0.5, pow(fi, 0.5));\n    sample_.xyz = pow(sample_.xyz, mix(vec3(1.0), vec3(75.0, 0.5, 0.0), ff));\n    sample_.xyz = mix(bg, sample_.xyz, shade);\n\n    transparency *= 1.0 - clamp(sample_.w, 0.0, 1.0);\n    vec4 newCol = vec4(col.xyz + sample_.xyz*(1.0 - col.w)*sample_.w, 1.0 - transparency);\n\n    col = newCol;\n    \n    f += 1.0;\n  }\n  \n  bg= vec3(0.3, 0.25, 0.4)*max(0.5 - sqrt(minTrap), 0.0);\n  col.xyz = mix(bg, col.xyz, col.w);\n  float fade = smoothstep(0.0, 3.0, iTime);\n  fragColor = vec4(fade*postProcess(col.xyz, q), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tc3zN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[546, 546, 585, 585, 710], [712, 712, 757, 757, 911], [913, 913, 935, 935, 979], [981, 981, 1002, 1002, 1047], [1049, 1049, 1107, 1107, 1332], [1334, 1334, 1365, 1365, 1391], [1393, 1393, 1426, 1426, 1511], [1513, 1513, 1555, 1555, 1622], [1624, 1624, 1653, 1653, 2142], [2144, 2144, 2171, 2171, 2631], [2633, 2633, 2658, 2658, 2797], [2800, 2800, 2818, 2818, 2959], [2961, 2961, 2983, 2983, 3173], [3175, 3175, 3200, 3200, 3233], [3235, 3235, 3278, 3278, 3550], [3552, 3552, 3607, 3607, 5111]], "test": "error"}
{"id": "3tcGRM", "name": "Smooth Non-realistic Noise Fire", "author": "KdotJPG", "description": "Simple non-realistic smooth fire-reminiscent effect from rising animated noise with a vertically varied threshold.", "tags": ["noise", "fire"], "likes": 1, "viewed": 216, "published": "Public", "date": "1575843465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////// Re-oriented 8-point BCC noise by KdotJPG ////////////////////\n//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 bccNoiseDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 bccNoiseDerivatives_XYZ(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Might be good for terrain, or a time varying X/Y plane. Z repeats.\nvec4 bccNoiseDerivatives_PlaneFirst(vec3 X) {\n    \n    // Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord / iResolution.y;\n    \n    // I think this helps prevent roundoff errors in the noise for big iTime?\n    vec3 baseNoiseInput = vec3(0, -iTime * 2.0, iTime);\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    baseNoiseInput = (fract(orthonormalMap * baseNoiseInput / 289.0) * 289.0) * orthonormalMap;\n    \n    float value = bccNoiseDerivatives_PlaneFirst(vec3(uv * 9.0, 0) + baseNoiseInput).w;\n\n    vec3 col = vec3(1.0, 0.77, 0.2) * (0.5 + 0.5 * value - uv.y * 1.125 + 0.25);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 214, 236, 236, 273], [275, 337, 360, 408, 1379], [1381, 1426, 1464, 1464, 2921], [2923, 3080, 3118, 3118, 3320], [3322, 3471, 3516, 3550, 3961], [4046, 4046, 4101, 4101, 4848]], "test": "ok"}
{"id": "3td3DB", "name": "3d simplex noise sphere 2", "author": "Bleuje", "description": "It loops perfectly.", "tags": ["raymarching"], "likes": 7, "viewed": 486, "published": "Public", "date": "1577461606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by @etiennejcb\n// Using code from : https://www.shadertoy.com/view/Xt2XDt\n// and 3D Simplex noise from https://www.shadertoy.com/view/XsX3zB\n// Got help from @tdhooper\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0006;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\n\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat TWO_PI = 2.0*3.141592;\n\nfloat sdSphere( vec3 p, float s )\n{\n  float angle = atan(p.z/p.x);\n  float rad = 1.3;\n  float offset = 1.0*angle/3.141592-2.5*p.y;\n  vec3 inp = vec3(rad*cos(TWO_PI*(iTime-offset)),rad*sin(TWO_PI*(iTime-offset)),3.0*p.y);\n  float ns =  simplex3d(inp);\n  float sph = abs(length(p)-s)-0.01;\n  float offset2 = 0.15; \n  if (sph < offset2) {\n    sph += 0.5*offset2 * ns;\n  }\n  return sph;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n\n    return vec2( sdSphere( pos - vec3( .0 , .0 , -0.4 ) , 0.75 ) , 1. ); ;\n    \n}\n\nvec3 result;\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if(t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += max(abs(h), 5.*INTERSECTION_PRECISION);\n        id = m.y;\n        result += vec3(0.0025);\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    result = vec3(0.);\n    vec3 color = vec3(0.,0.,0.);\n    for(float i=-0.25;i<=0.25;i+=0.5){\n        for(float j=-0.25;j<=0.25;j+=0.5){\n            vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(i,j)))/iResolution.y;\n\n            vec3 ro = vec3( 0., 0., 2.);\n            vec3 ta = vec3( 0. , 0. , 0. );\n\n            mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n            vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n            vec2 res = calcIntersection( ro , rd  );\n        }\n    }\n    fragColor = vec4(result,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3td3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 388, 388, 561], [668, 691, 716, 969, 1886], [1888, 1919, 1983, 1983, 2161], [2163, 2257, 2286, 2286, 2329], [2331, 2331, 2362, 2362, 2458], [2490, 2490, 2525, 2525, 2874], [2877, 2961, 2982, 2982, 3067], [3083, 3083, 3131, 3131, 3621], [3624, 3624, 3681, 3681, 4270]], "test": "ok"}
{"id": "3td3DX", "name": "original-32360-1", "author": "jorge2017a1", "description": "original-32360-1", "tags": ["original323601"], "likes": 6, "viewed": 102, "published": "Public", "date": "1577756273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.14159265;\n#define Power 10.0\n#define Bailout 2.0\n\nvoid powN1(inout vec3 z, float r, inout float dr) {\n\t// extract polar coordinates\n\tfloat theta = acos(z.z/r);\n\tfloat phi = atan(z.y,z.x);\n\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\n\t// scale and rotate the point\n\tfloat zr = pow( r,Power);\n\ttheta = theta*Power;\n\tphi = phi*Power;\n\t\n\t// convert back to cartesian coordinates\n\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n}\n\n\n// Compute the distance from `pos` to the Mandelbox.\nfloat DE(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=0.75;\n\tr=length(z);\n\tfor(int i=0; (i < 4); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tif (r>Bailout) break;\n\t}\n\t\n\treturn (cos(iTime*0.60+cos(iTime*0.3+(pos.x*pos.x+pos.y*pos.y+pos.z*pos.z)*50.0)*0.4)*0.06+0.14)*log(r)*r/dr;\n    \n}\n\nvec3 DEColor(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=1.0;\n\tr=length(z);\n\tfloat minR = 1000.0;\n\tfor(int i=0; (i < 2); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tminR = min(r,minR);\n\t\tif (r>Bailout) break;\n\t}\n\tfloat i = minR*minR*minR*minR*0.50;\n\treturn vec3(clamp(i,0.0,1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n\n  //Camera animation\n  vec3 vuv=vec3(0,1.0,0.5);//Change camere up vector here\n  vec3 vrp=vec3(0,cos(iTime)*0.25,sin(iTime)*0.25); //Change camere view here\n  float mx=iMouse.x*PI*1.0;\n  float my=iMouse.y*PI/1.0;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*2.0; //Trackball style camera pos\n  \n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn))*0.25;\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  //Raymarching\n  const vec3 e=vec3(0.001,0,0);\n  const float maxd=4.0; //Max depth\n  float s=0.0;\n  vec3 c,p,n;\n\n  float f=0.10;\n  for(int i=0;i<46;i++){\n    f+=s;\n    p=prp+scp*f;\n    s=DE(p)*1.0;\n    if (abs(s)<.0025||f>maxd) break;\n   \n  }\n  \t\n  if (f<maxd){\n    n=normalize(\n      vec3(s-DE(p-e.xyy),\n           s-DE(p-e.yxy),\n           s-DE(p-e.yyx)));\n    c = DEColor(p);\n    c.yz = max(mix(c.yz, n.yz, 0.2),0.3)+0.2;\n    float b=dot(n,normalize(prp-p));  \n    fragColor = mix(vec4((b*c+pow(b,256.0))*(1.0-f*.31),1.0), vec4(c,1.0),0.38);\n  }\n  else {\n      fragColor=vec4(0.0,0,0,1); //background color\n  }\n\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3td3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 112, 142, 454], [457, 510, 530, 530, 802], [804, 804, 828, 828, 1094], [1097, 1097, 1154, 1154, 2369]], "test": "ok"}
{"id": "3td3R2", "name": "paraMejorarv2", "author": "jorge2017a1", "description": "paraMejorarv2", "tags": ["paramejorarv2"], "likes": 1, "viewed": 53, "published": "Public", "date": "1576894790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\nconst int CCero = 0;\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\nconst int CPlane3 =10;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec2 glfragCoord;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 colorplaneta( )\n{\n    vec2 uv;\n    //Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    //Equalize the aspect ratio\n    ///uv.y /= iResolution.x/iResolution.y;\n    uv=glfragCoord;\n    \n    //Zoom out\n    uv *= 5.0;\n    \n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n\n    //Fragment colour\n    return col;\n}\n\n\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    case 11:\n        \t\n        return colorplaneta();\n    } \n}\n\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opTwistBx(  in vec3 p )\n{\n    const float k =40.0; //10.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.yx,p.y);\n    //return primitive(q);\n    \n    return  sdBox(q-vec3(-2.0,2.0,4.5),vec3(0.2,2.5,0.5));\n}\n\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n///--------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d, dif1, dif2, dif3, dif4;\n    \n    d=999.9;\n   \n    float planeDist = p.y+3.0;\n    \n    vec2 res;\n    res=vec2(999.9);\n    \n    vec3 pp;\n    pp=p;\n    \n    vec3 pr;\n    pr=p;\n    pr.xz*= rotate(iTime * 0.5);\n    \n    \n    //piso grande\n    float sdbg1= sdBox(  pr- vec3(0,0.5,0), vec3(5,0.5,5));\n    \n    //columnas\n    float sdbc1= sdBox(  pr- vec3(-4,0.5,4), vec3(0.5,7.0,0.5));\n    float sdbc2= sdBox(  pr- vec3(4,0.5,4), vec3(0.5,7.0,0.5));\n    float sdbc3= sdBox(  pr- vec3(-4,0.5,-4), vec3(0.5,7.0,0.5));\n    float sdbc4= sdBox(  pr- vec3(4,0.5,-4), vec3(0.5,7.0,0.5));\n    \n    \n    pp.xz = mod(p.xz, 2.0) - vec2(0.1,1.0);\n    \n    \n    //piso inferior\n    float sdb1= sdBox(  pp- vec3(0,0,0), vec3(1,0.5,1));\n    float sdb2= sdBox(  pp- vec3(2,0,0), vec3(1,0.5,1));\n    float sdb3= sdBox(  pp- vec3(0,0,1), vec3(1,0.5,1));\n    float sdb4= sdBox(  pp- vec3(2,0,1), vec3(1,0.5,1));\n    \n    \n     //cubo solo\n    vec3 pbB=vec3(1.0,0.5,1.0);\n    vec3 pbBPos=vec3(0,2.5,0);\n    pbBPos.xz *= rotate(iTime *2.0 );\n    float bx1 = sdBox(pr-pbBPos,pbB);\n    \n    \n    \n    \n    \n    res=vec2(planeDist,4);\n    res=opU(res, vec2(sdb1,3));\n    res=opU(res, vec2(sdb2,5));\n    res=opU(res, vec2(sdb3,5));\n    res=opU(res, vec2(sdb4,3));\n    res=opU(res, vec2(sdbg1,6));\n    \n    \n    res=opU(res, vec2(sdbc1,7));\n    res=opU(res, vec2(sdbc2,7));\n    res=opU(res, vec2(sdbc3,7));\n    res=opU(res, vec2(sdbc4,7));\n    \n    \n    res=opU(res, vec2(bx1,11));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    glfragCoord=uv;\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, -1.5+4.5*sin(iTime));\n    //vec3 ro = vec3(0, 2.5, -1.5+4.8*sin(iTime*0.5));\n    vec3 ro = vec3(0, 2.5, -10);\n    \n\n    \n    vec3 rLuz=vec3(-0.5, -8.5, -5.5);\n    \n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    \n    \n    //float dif = GetLight(p);\n    float dif = GetLightv2(p);\n    \n    //float dif2 = abs(1.0- GetLight( pluz));\n    float dif2 = abs(1.0- GetLightv2( pluz));\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n  \n    dif=(dif+dif2)/1.5;\n    \n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3td3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 408, 441, 441, 506], [507, 525, 561, 561, 630], [631, 646, 677, 677, 827], [828, 848, 884, 884, 971], [972, 988, 1020, 1048, 1109], [1162, 1162, 1208, 1208, 1240], [1242, 1242, 1284, 1284, 1316], [1318, 1318, 1365, 1365, 1398], [1401, 1401, 1430, 1430, 1556], [1610, 1610, 1632, 1632, 2156], [2161, 2161, 2189, 2189, 3210], [3214, 3261, 3297, 3297, 3400], [3456, 3456, 3501, 3501, 3592], [3595, 3595, 3626, 3626, 3890], [3893, 3893, 3915, 3915, 3982], [3984, 4032, 4057, 4057, 5630], [5633, 5633, 5667, 5667, 5901], [5907, 5907, 5931, 5931, 6163], [6167, 6167, 6191, 6191, 6576], [6579, 6579, 6605, 6605, 6997], [7004, 7004, 7061, 7061, 7986]], "test": "error"}
{"id": "3td3zN", "name": "Shader de NoÃ«l moche", "author": "Windless", "description": "InspirÃ© par le pull de Nicole Ferroni,je decide de faire un shader de noel moche.", "tags": ["test", "christmasshader"], "likes": 1, "viewed": 89, "published": "Public", "date": "1575803741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nuniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n#define NB_BRANCHES 3.0\n\n#define C_FOND       0\n#define C_PAYSAGE    1\n#define C_TRONC      2\n#define C_BRANCHES   3\n#define C_NEIGE      4\n\nvec3 couleur(int c) {\n  if (c == C_FOND)     return vec3(1.00, 0.00, 0.00);     \n  if (c == C_PAYSAGE)  return vec3(0.90, 0.90, 0.90);\n  if (c == C_TRONC)    return vec3(0.40, 0.15, 0.00);\n  if (c == C_BRANCHES) return vec3(0.00, 0.80, 0.00);\n  if (c == C_NEIGE)    return vec3(1.00, 1.00, 1.00);\n}\n\nint paysage(in vec2 uv) {\n  return int(min(1., 1.35 - uv.y + cos(uv.x * 3.) / 12.));\n}\n\nint tronc(in vec2 uv) {    \n\n  uv = abs(uv);\n  \n  return int(\n    1. - (step(0.2, uv.y) + step(0.1, uv.x) )\n  );\n}\n\nint branches(in vec2 uv) {\n\n  uv = abs(uv);\n  float l =\n    1.0\n    - (uv.x + uv.y)\n    + floor(uv.y * 5.) / 8.0;\n\n  l = step(0.5, l);\n  \n  l *= step(0.2, uv.y);\n\n  return int(l);\n}\n\nint neige(in vec2 uv) {\n  float angle = atan(uv.y,uv.x);\n  float radius = length(uv);\n  \n  angle *= NB_BRANCHES;\n  \n  uv = vec2(cos(angle + iTime),sin(angle + iTime)) * radius;\n\n  vec2 uv2 = uv;\n  \n  uv = abs(uv);\n  float t =\n    step(uv.x, 0.045)\n    * step(uv.y, 0.3);\n  \n  t +=\n    step(uv.x, 0.15)\n    * step(abs(uv.y - 0.2), 0.015);\n\n  t +=\n    step(uv.x, 0.25)\n    * step(abs(uv.y - 0.1), 0.025);\n\n  return int(min(1., t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv.x -= 0.2;\n  \n  int plan = 0;\n  \n  float sx = 2.2 - mod(iTime / 4.0, 3.);\n   \n  plan = max(plan, tronc(uv - vec2(sx, 0.))         * C_TRONC);\n  plan = max(plan, branches(uv - vec2(sx, 0.))      * C_BRANCHES);\n  plan = max(plan, paysage(uv + vec2(iTime/13.,0.)) * C_PAYSAGE);\n  plan = max(plan, neige(fract( (uv- vec2(0.3,-0.2) * float(iTime))*5.0) -0.5 )       * C_NEIGE);\n \n  fragColor = vec4(couleur(plan), 1.0);\n}", "image_inputs": [{"id": "XlS3RR", "previewfilepath": "https://soundcloud.com/loicmusique/8bit-christmas", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/loicmusique/8bit-christmas", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3td3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 267, 267, 544], [546, 546, 571, 571, 632], [634, 634, 657, 657, 748], [750, 750, 776, 776, 931], [933, 933, 956, 956, 1364], [1366, 1366, 1423, 1423, 1968]], "test": "error"}
{"id": "3tdGD7", "name": "MSAA 12162019", "author": "bad_dreams_", "description": "ð", "tags": ["msaa"], "likes": 3, "viewed": 169, "published": "Public", "date": "1576564210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float checkerboard(vec2 uv) {\n    vec2 adjusted = floor(uv);\n \tbool inside = mod(adjusted.y, 2.0) == 1.0\n\t\t? mod(adjusted.x, 2.0) == 0.0\n        : mod(adjusted.x, 2.0) == 1.0;\n    return inside ? 1.0 : 0.0;\n}\n\nstruct HitResult { bool hit; vec3 point; };\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Plane { vec3 origin; vec3 normal; };\n\nmat4 rotateY(float angle) {\n \tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n\t\ty, 0,-x, 0,\n        0, 1, 0, 0,\n        x, 0, y, 0,\n        0, 0, 0, 1\n     );\n}\n\nHitResult rayPlaneIntersect(Ray ray, Plane plane) {\n \tfloat horizonDot = dot(ray.direction, plane.normal);\n    if (horizonDot < 0.00001) {\n\t\tvec3 difference = plane.origin - ray.origin;\n        float time = dot(difference, plane.normal) / horizonDot;\n        \n        bool hit = time > 0.0;\n        vec3 point = hit\n            ? ray.origin + ray.direction * time\n            : vec3(0.0);\n        \n        return HitResult(hit, point);\n    }\n    \n    return HitResult(false, vec3(0.0));\n}\n\nvec3 scene(vec2 uv) {\n    const vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 origin = vec3(0.0, 2.0 + cos(iTime), 0.0);\n    mat4 rotation = rotateY(iTime * 0.2);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 0.9));\n    rayDirection = (rotation * vec4(rayDirection, 0.0)).xyz;\n    \n    Ray ray = Ray(origin, rayDirection);\n    Plane plane = Plane(vec3(0.0), up);  \n    \n    \n    HitResult result = rayPlaneIntersect(ray, plane);\n\n    float value = checkerboard(uv * 10.0);\n    vec3 color = result.hit\n        ? vec3(checkerboard(result.point.xz))\n        : vec3(rayDirection.x, rayDirection.y, rayDirection.z);\n\n   \treturn color;\n}\n\nconst float PI = 3.14159;\n\nvec2 coordToUv(vec2 coord) {\n \treturn (coord - iResolution.xy * 0.5) / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 singleSample = scene(uv);\n    \n    float a = (3.0 / 8.0);\n    float b = (1.0 / 8.0);\n    vec3 acc = vec3(0.0);\n    acc += scene(coordToUv(fragCoord + vec2(-a, b)));\n    acc += scene(coordToUv(fragCoord + vec2(-b, -a)));\n    acc += scene(coordToUv(fragCoord + vec2(a, -b)));\n    acc += scene(coordToUv(fragCoord + vec2(b, a)));\n    acc /= 4.0;\n\n    vec3 color = fragCoord.x / iResolution.x > 0.5\n        ? acc\n        : singleSample;\n    \n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color *= step(0.001, abs(fragCoord.x / iResolution.x - 0.5));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 208], [344, 344, 371, 371, 521], [523, 523, 574, 574, 1011], [1013, 1013, 1034, 1034, 1648], [1677, 1677, 1705, 1705, 1764], [1766, 1766, 1823, 1823, 2494]], "test": "ok"}
{"id": "3tdGR4", "name": "Codevember19 - Colors", "author": "z0rg", "description": "My participation to codevember ", "tags": ["colors", "abstract", "codevember"], "likes": 1, "viewed": 47, "published": "Public API", "date": "1576930644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nfloat lenny(vec2 uv)\n{\n  return abs(uv.x)+abs(uv.y);\n}\nfloat sdf_cir(vec2 uv,float r)\n{\n  return length(uv)-r;\n}\n\nfloat _union(float a, float b)\n{\n  return max(a,b);\n}\n\nvec4 rdr(vec2 uv, float tim)\n{\n  float sharp = 5.;\n  float sz = 0.1;\n  float a = 1.-sat(sdf_cir(uv-vec2(sin(tim),sin(tim*2.)*0.5)*0.3,sz)*sharp);\n  vec3 cola = 0.8*vec3(0.,1.,1.)*min(1.,a*100.);\n\n  float b = 1.-sat(sdf_cir((uv-vec2(sin(-tim+1.),sin(tim*2.+3.)*0.5)*0.3),sz)*sharp);\n  vec3 colb = 1.2*vec3(1.,0.75,.4)*min(1.,b*100.);\n\nfloat c = 1.-sat(sdf_cir((r2d(PI/2.)*uv-vec2(sin(tim+0.8),sin(tim*2.)*0.5)*0.3),sz)*sharp);\n  vec3 colc = vec3(1.,0.,.3)*min(1.,c*100.);\n\n\n  return vec4(cola+colb+colc,a+b+c);\n}\n\nvec3 rdrblur(vec2 uv)\n{\n  const int blurSamples = 8;\n  float iTimeSp = 0.1;\n  vec3 col = vec3(.42,.4,.4)*.6;\ncol *= 1.-sat(lenny(uv*.5));\n\n  vec3 acc;\n  float opa = 0.;\n  for (int i= 0; i<blurSamples;++i)\n  {\n    vec4 rdrCol = rdr(uv, iTime-float(i)*iTimeSp);\n    acc += rdrCol.xyz;\n    opa = max(opa, rdrCol.w)*float(blurSamples-i)/8.;\n  }\n\n  return mix(col,acc, sat(opa)*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*(iResolution.xy/iResolution.xx);\n  vec3 col ;\nuv *= 2.5;\n\n  //cyan vec3(0.,1.,1.)\n  // mangenta vec3(1.,0.,.3)\n  // yellow vec3(1.,0.65,.3)\n  col = mix(col, vec3(1.,0.65,.3), sat((1.-length(uv)*8.)*30.));\n  col = rdrblur(uv);\n  col += rdrblur(mod(2.*abs(uv*vec2(1.*uv.y,abs(uv.x))),0.5)*2.)*0.5;\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGR4.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[426, 426, 444, 444, 505], [507, 507, 527, 527, 554], [555, 555, 577, 577, 609], [610, 610, 642, 642, 667], [669, 669, 701, 701, 722], [724, 724, 754, 754, 1235], [1237, 1237, 1260, 1260, 1617], [1619, 1619, 1676, 1676, 2067]], "test": "ok"}
{"id": "3tdGRf", "name": "paredv1", "author": "jorge2017a1", "description": "paredv1", "tags": ["paredv1"], "likes": 0, "viewed": 45, "published": "Public", "date": "1577069874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n        \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n   \n    p.z=p.z-6.0;\n    \n    p.x = mod(p.x, 7.0) - 3.5;\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n         } \n     } \n    \n    \n   \n    pp=p;\n    \n   float sdb1=sdBox(pp-vec3(0,0,0), vec3(3.,4.0,0.5));\n    \n    float sdb2=sdBox(pp-vec3(3.5,0,0.0), vec3(0.5,2.0,0.4));\n    float sdb3=sdBox(pp-vec3(-3.5,0,0.0), vec3(0.5,2.0,0.4));\n    \n    \n    float sds1= sdSphere(pp-vec3(0,1.5,-9), 2.0 );\n    \n    float sds2= sdSphere(pp-vec3(2.5,4.0,-9.0), 0.4 );\n    float sds3= sdSphere(pp-vec3(-2.5,4.0,-9.0), 0.4 );\n    \n    \n    dif1=differenceSDF(sdb1,  sds1);\n    res=opU(res, vec2(dif1,3));\n    \n    res=opU(res, vec2(sds2,8));\n    res=opU(res, vec2(sds3,8));\n    \n    res=opU(res, vec2(sdb2,6));\n    res=opU(res, vec2(sdb3,6));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));\n    vec3 ro = vec3(0, 3.5, -8.5);\n\n    //vec3 ro = vec3(0, 2.5, iTime*2.0);\n    \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n    //vec3 rd = normalize(vec3(uv.x+iMouse.x/iResolution.y, uv.y+iMouse.y/iResolution.y, 1.0));\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\t\n   \n    \n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    //float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    \n    \n    float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2+dif3)/2.0;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1116, 1116, 1162, 1162, 1194], [1196, 1196, 1238, 1238, 1270], [1272, 1272, 1319, 1319, 1352], [1355, 1355, 1384, 1384, 1510], [1512, 1512, 1548, 1548, 1665], [1667, 1667, 1703, 1703, 1821], [1825, 1825, 1853, 1853, 2856], [2910, 3019, 3056, 3056, 3091], [3094, 3094, 3119, 3119, 4338], [4341, 4341, 4375, 4375, 4609], [4612, 4612, 4636, 4636, 4868], [4872, 4872, 4896, 4896, 5281], [5284, 5284, 5310, 5310, 5674], [5720, 5720, 5792, 5792, 5819], [5821, 5821, 5878, 5878, 7044]], "test": "error"}
{"id": "3tdGRl", "name": "Desert 3000", "author": "onlinerocker", "description": "Some fun terrain/stone structure generation using value noise.\n:)", "tags": ["noise", "terrain", "valuenoise", "desert"], "likes": 4, "viewed": 80, "published": "Public", "date": "1577247753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define VIEW_DIST 50.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n    \n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\n//slightly modified for octave spcification\nfloat fbm5(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat fbm3(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n//iq, modified color and made fog amount grow exponentially\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( \tvec3(0.8, 0.6, 0.2),\n        \t\t\t\t\tvec3(0.3, 0.6, 1.0),\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 1.0;\n    o.specKs = 0.0;\n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    vec3 planePos = pos;\n    float yVal = 3.0*fbm3(pos/4.0);\n    //float yVal = 6.0+5.0*sin(2.0*pos.x + pos.z);\n    planePos.y -= yVal;\n    float dPlane = sdPlaneInf(planePos, 0.0);\n    if(dPlane < o.dist)\n    {\n        o.dist = dPlane;\n        o.color = mix(vec3(194., 178., 128.)/255.0, vec3(133., 100., 50.)/255.0, fbm3(pos*100.0));\n    }\n    \n    vec3 bbPos = pos;\n    bbPos.x = mod(bbPos.x, -5.0);\n    bbPos.z = abs(bbPos.z);\n    \n   \tfloat bound = sdRoundBox(bbPos-vec3(-3.0,2.1,2.0), vec3(0.2, 3.0, 0.2), 0.1);\n    if(bound < o.dist)\n    {\n        vec3 pillPos = pos;\n        vec2 id = floor(pillPos.xz/5.0);\n        float h = sin(id.x) * 1337.0 * cos(id.y) * 420.69;\n        h = -0.5 + mod(h, 1.1);\n        \n        //pillPos.y += 0.15*fbm(pillPos*10.0) * smoothstep(0.7, 0.8, pillPos.y);\n        \n        pillPos.z -= sin(pillPos.y*2.0+2.0*iTime+id.x*id.y)*0.2*smoothstep(yVal, yVal+1.0, pillPos.y);\n        float dist = 0.1*fbm5(pillPos*5.0);\n        pillPos.z += dist;// * step(sin(pillPos.z) + cos(pillPos.x), 0.0);\n        pillPos.x += dist;// * step(sin(pillPos.z) + cos(pillPos.x), 0.0);\n\n        //red orbs to pillars?\n\n        pillPos.x = mod(pillPos.x, -5.0);\n        pillPos.z = abs(pillPos.z);\n        pillPos -= vec3(-3.0,1.1+h,2.0);\n        float dBox = sdRoundBox(pillPos, vec3(0.1, 3.0, 0.1), 0.1);\n        if(dBox < o.dist)\n        {\n            o.dist = dBox;\n            //o.dist = smin(o.dist, dBox, 0.2);      \n            o.difVal = 1.0;\n            o.color = mix(vec3(44,53,57)/255.0, vec3(194., 178., 128.)/255.0, fbm3(pos*200.0));\n            \n            o.specVal = 20.0;\n            o.specKs = 0.4;\n        }\n        \n    \n    }\n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<100; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.0001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nfloat marchSoftShadow(vec3 pos, Light l, float speed, float w)\n{\n \tMarchRes res;\n    Object o;\n    vec3 dir = normalize(l.pos);\n    float len = length(l.pos - pos);\n    float maxDist = len;\n    \n    res.totalDist = 0.001;\n\n    float sha = 1.0;\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        sha = min( sha, 0.5*o.dist/(w*res.totalDist) );\n        if(sha < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist > maxDist) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\t\n    \n    sha = max(sha,0.0);\n    return sha*sha*(3.0-2.0*sha);\n}\n\nfloat calcShadowSoft(vec3 pos, Light l)\n{\n    //MarchRes res;\n    float val;\n    val = marchSoftShadow(pos, l, 1.0, 0.05); //march slower to prevent shadow artifacts\n\treturn val;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(-iTime,3.0,0.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = PI/2.0;//-iMouse.x/20.0;//\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    //vec2 camXZ = rotCam * camEye.xz;\n    //camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 0.5;\n    light.pos = vec3(10, 3, 0.0);\n    light.color = vec3(1.0, 0.8, 0.65);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    \n    y = smoothstep(1.1, 0.5, y);\n    vec3 col = (vec3(0.8, 0.6, 0.2)*(y) + vec3(0.3, 0.6, 1.0)*(1.0-y));\n    col += vec3(0.8, 0.6, 0.2)*smoothstep(sqrt(length(uv)), sqrt(length(uv))+0.05, 0.3);\n\n    vec3 bg = col;\n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, vec3(0)) * calcShadowSoft(pos, light) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        col += calcSpecLight(res.obj, light,pos, camEye) * calcShadowSoft(pos, light);\n        col = applyFog(col, length(pos)-iTime, normalize(pos), normalize(light.pos - pos));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 573, 594, 594, 661], [663, 703, 724, 724, 1485], [1487, 1571, 1591, 1591, 1751], [1753, 1753, 1773, 1773, 1933], [1935, 1940, 1977, 1977, 2002], [2004, 2009, 2054, 2054, 2149], [2152, 2212, 2457, 2457, 2803], [2805, 2861, 2902, 2902, 2995], [3001, 3001, 3023, 3023, 4856], [4858, 4858, 4895, 4895, 5188], [5194, 5194, 5246, 5246, 5887], [5889, 5889, 5953, 5953, 6676], [6678, 6678, 6719, 6739, 6858], [6860, 6860, 6912, 6912, 7051], [7053, 7053, 7115, 7115, 7491], [7493, 7493, 7550, 7550, 9156]], "test": "timeout"}
{"id": "3tdGz2", "name": "4D sphere boys", "author": "BernieBud", "description": "omg look at my sweet little boys", "tags": ["4d", "hypersphere", "glome"], "likes": 1, "viewed": 113, "published": "Public", "date": "1577032812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// IMPORTANT TO NOTE each \"slice\" is not of its own 3D space but rather to be treated as another \"row\" of pixels on a 3D image\n// This is why the checkboard pattern acts the way it does when you move away from the center W slice.\n// Click and drag to see different 2D slices of the 3D image created by this 4D world\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define R_STEP 8. // How many samples along the uv.z coordinate don't set this much higher than like 32 or else you'll die\n// set above to .5 so we only get a single image\n#define W_CROP 128. // How far along the W axis do we render our samples? (Bigger number = Narrower slice)\n#define PI 3.14159265\n\nfloat GetDist(vec4 p)\n{\n vec4 glome[4];\n    glome[0]  = vec4(.5,1.,6,0);\n    glome[1]  = vec4(-1,-1.5,12,1);\n    glome[2]  = vec4(2.,-1.5,8,.0);\n    glome[3]  = vec4(-1,-1.5,4,0);\n    float radius = 1.0;\n    float sDIST = 100.;\n    \n    for(int i = 0;i < 4;i++)\n    {sDIST = min(length(p-glome[i])-radius,sDIST);}\n    sDIST = min(sDIST,p.y+2.5);\n    return sDIST;\n}\n\n\nfloat RayMarch(vec4 ro, vec4 rd)\n{\n float dO = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec4 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n        \n    }\n    \n    return dO;\n}\n\nvec4 GetNormal(vec4 p)\n{\n    float D = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec4 n = D - vec4(\n        GetDist(p-e.xyyy),\n        GetDist(p-e.yxyy),\n        GetDist(p-e.yyxy),\n        GetDist(p-e.yyyx)\n        );\n    return normalize(n);\n}\n\nfloat GetLight(vec4 p)   \n{\n    vec4 LightPos = vec4(4,8,4,4);\n   \n    vec4 l = normalize(LightPos-p);\n    vec4 n = GetNormal(p);\n    float s = RayMarch(p+n*SURF_DIST*2.,l);\n    if(s<length(LightPos-p)) l *= .0;\n    \n    float GAY = dot(n,l);\n\treturn GAY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 col = vec4(0);\n\n    // Time varying pixel color\n    vec4 space = vec4(uv,iMouse.x/iResolution.x - 0.5,iMouse.y/iResolution.y - 0.5);\n    //space = vec4(uv,0,0); // Locks W value to 0.\n    float T = (iTime/20. - float(int(iTime/20.)))*2.-1.;\n    T = clamp(iMouse.x/iResolution.x - 0.5,-1.,1.);\n    \n    //space = vec4(uv,0,round(T*64.)/64.);\n    space = vec4(uv,0,T); // set T to 0.0 so we lock on the center slice of pixels\n    \n    vec4 rO = vec4(cos(iTime/2.)*9.,0,6.+sin(iTime/2.)*9.,0);\n    vec4 rD = normalize(vec4(space.xy,1.0,space.w));\n    float D = 0.;\n    vec3 lightcol = vec3(1.0,1.0,1.0);\n    \n    for(float i = -R_STEP;i < R_STEP;i++)\n    {\n        float YAW = iTime/2.+PI/2.;\n        \n    space = vec4(uv,0,i/R_STEP/W_CROP + T);\n    rD = normalize(vec4(\n        cos(YAW)*space.x - sin(YAW),\n        space.y,\n        sin(YAW)*space.x + cos(YAW),\n        space.w));\n    D = RayMarch(rO,rD);\n    \n        vec4 p = rO + rD * D;\n    //vec4 col = vec4(1.-1./D);\n    float CHK = 0.0;\n    if(int(p.x+64.) % 2 >= 1) // p.x+64. is so the checkerboard pattern repeats properly with negative numbers\n        CHK = 1.;\n    if(int(p.z+64.) % 2 >= 1)\n        CHK = 1.-CHK;\n    if(int(p.w+64.) % 2 >= 1)\n        CHK = 1.-CHK;\n    CHK = 1.-CHK/3.;\n        if(p.y >= -2.49) // makes the checkerboard only affect the grid and shit agh\n            CHK = 1.;\n        \n    //lightcol = vec3(clamp(1.-i*2. ,.0,1.), clamp(1.+i*2. ,.0,1.) , 0.);\n        lightcol = vec3(CHK,1.0-CHK/2.,1.0);\n    \n    col += vec4(  (clamp(GetLight(p),0.,1.) + 0.1)  ) * vec4(lightcol,1.) / R_STEP/2.;\n    }\n    \n    // Tonemapping\n    //col = (col/(col+1.))*1.9-0.1;\n    \n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[686, 686, 709, 709, 1051], [1054, 1054, 1088, 1088, 1319], [1321, 1321, 1345, 1345, 1565], [1567, 1567, 1594, 1594, 1824], [1826, 1826, 1883, 1938, 3702]], "test": "ok"}
{"id": "3tdGzn", "name": "from Blue-ish Noise to Gabor", "author": "FabriceNeyret2", "description": "exploring around JohnShadow's [url]https://www.shadertoy.com/view/tlcGRr[/url]\nMouse = freq,a\nIndeed, very close to Gabor noise with infinite kernel.\nSimplifing JS shader + algo (no square, only sin.x, hash), and adding angle span control + freq variation", "tags": ["noise", "bluenoise", "gabornoise", "phasornoise", "faked"], "likes": 10, "viewed": 359, "published": "Public API", "date": "1575469154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// exploring from JohnShadow's https://www.shadertoy.com/view/tlcGRr\n\nfloat n = 20.;\n\n#define pi 3.1415927\n#define rot(a) mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 200. * u / R.y,\n         M = length(iMouse.xy) > 10. ? iMouse.xy/ R : vec2(.3, .015*pi);\n    \n    float df = M.x, da = pi*M.y,\n          t = 10.*iTime,\n          s = 0., m, v, \n        noise = 1., _n=0.;\n    \n    for( m = 0.; m < n; m++)\n    {\n        _n = noise;\n        noise = 2.* fract(1e3*sin( 1e3 * m ) ) - 1.;\n        s += sin( (1.+ df *_n)* ( U * rot( da * noise) ).x  -t -m );\n    }\n    s /= 2.*sqrt(m);\n    O = .5 + .5* vec4( u.x < R.x/2. ? s : s/fwidth(s) ); // normalized phasor noise\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 202, 202, 743]], "test": "ok"}
{"id": "3ttGDH", "name": "[TWITCH] Peaceful", "author": "Flopine", "description": "Sahder made during a live stream, you can see all of them here: https://www.twitch.tv/flopine", "tags": ["raymarching", "colors", "toonshading", "twitchstream"], "likes": 4, "viewed": 150, "published": "Public", "date": "1576192790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\n#define PI 3.141592\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(13.4,18.5)))*1478.5);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat scenery (vec3 p)\n{\n    p.y += cos((p.z+sin(p.x)*0.2)*5.)*0.05;\n    p.y += texNoise(p.xz*.15).g*0.15;\n    p.y += 15.8;\n\n    float b1 = box(p,vec3(4.,15.,15.));\n    p.z += 3.;\n    float b2 = box(p,vec3(18.,15.,5.));\n    return min(b2,b1);  \n}\n\nfloat lantern (vec3 p)\n{\n    vec3 pp = p;\n    float c1 = cyl(p.xzy, 0.1+(abs(p.y-0.5)-0.1)*0.15, .6);\n    p.y -= 0.85;\n    float c2 = cyl(p.xzy+vec3(0.,0.,cos(p.x*3.)*0.1), 0.3, 0.02);\n    p.y -= 0.1;\n    float c3 = max(-box(p,vec3(0.1,0.1,10.))+0.05,cyl (p.xzy, 0.25,0.18));\n    p.y -= 0.5;\n    float c4 = cyl(p.xzy, 0.01-p.y, 0.3);\n    float c5 = cyl(p.xzy, 0.05, 0.05);\n    return stmin(c1,min(c2,min(c3,stmin(c4,c5,0.1,2.))),0.3,2.);\n}\n\nfloat lanterns (vec3 p)\n{\n    float per = 1.5;\n    p.z += 3.;\n    p.x = abs(p.x)-4.;\n    p.z = abs(p.z)-1.;\n    return lantern(p);\n}\n\nfloat fence (vec3 p)\n{\n    p.y += .25;\n    p.x = abs(p.x)-1.5;\n    float b1 = min(box(p, vec3(0.06,0.7,0.06)),length(p-vec3(0.,.8,0.))-.15);\n    float b2 = box(p-vec3(-1.,.4,0.),vec3(1.,0.06,0.06));\n    float b3 = box(p-vec3(-1.,0.,0.),vec3(1.,0.06,0.06));\n    float b4 = box(p-vec3(-1.,-0.1,0.),vec3(0.06,0.6,0.06));\n    return min(b1,min(b2,min(b3,b4)));\n}\n\nfloat fences (vec3 p)\n{\n    vec3 pp = p;\n    p.z -= 8.;\n    p.x = abs(p.x)-2.;\n    float f1 = fence(p);\n\n    p = pp;\n    p.z -= 4.;\n    p.xz *= rot(PI/2.);\n    p.xz = abs(p.xz)-vec2(1., 3.6);\n    float f2 = fence(p);\n\n    p = pp;\n    p.z -= 1.;\n    p.x = abs(p.x)-6.8;\n    p.x = abs(p.x)-1.5;\n    float f3 = fence(p);\n\n    return min(f3,min(f2,f1));\n}\n\nfloat water (vec3 p)\n{\n    p.y += (texNoise(p.xz*0.1+time*0.05).r + texNoise(p.xz*0.05-time*0.04).r)*0.4;\n    return p.y;\n}\n\nfloat prim1 (vec3 p)\n{\n    p.xz *= rot(sin(p.y*2.-time));\n    p.x = abs(p.x)-.5;\n\n    p.x += sin(p.y*5.+time)*0.3;\n    p.y += cos(p.x+time)*0.5;\n    float s = cyl(p.xzy, 0.1+p.y*0.5, 10.);\n    return s;\n}\n\nfloat pool (vec3 p)\n{\n    p.z -= 4.;\n    float b1 = max(-box(p,vec3(2.,10.,1.5)),box(p,vec3(2.5,.4,2.)))-0.05;\n    float w = max(water(p-vec3(0.,0.5,0.)),\n                  box(p,vec3(2.5,.6,2.)));\n    return min(smin(w,prim1(p),1.),b1);\n}\n\nfloat SDF (vec3 p)\n{\n    return min(water(p+vec3(0.,1.,0.)),min(fences(p),min(lanterns(p),stmin(scenery(p),pool(p),.7,3.))));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f*0.85 + l*uv.x + u*uv.y);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.05,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return max(dot(n,l),0.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.001,3.,-8.),\n        p = ro,\n        tar = vec3(0.,0.5,0.),\n        rd = getcam(ro,tar, uv),\n        l = normalize(vec3(0.,0.5, -3.)),\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad =  i/64.;\n            break;\n        }\n        d *= 0.5+dither*0.1;\n        p += d*rd;\n    }\n    \n    float t = length(ro-p);\n    vec3 n = getnorm(p);\n    float fre = clamp(pow(1.-dot(n,-rd),2.5),0.,1.);\n    float light = pow(floor(lighting(n,l)*4.)/4., 0.5);\n    \n    col = mix(vec3(0.,0.3,0.7), vec3(0.8,0.4,0.7), light)*(1.-fre);\n    col += fre*vec3(1.,0.8,0.2);\n\n    col = mix(col, vec3(0.7,0.8,0.6), 1.-exp(-0.003*t*t));\n\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 479, 503, 503, 741], [743, 743, 763, 763, 806], [808, 808, 830, 830, 880], [882, 882, 932, 932, 1036], [1038, 1038, 1079, 1079, 1172], [1174, 1174, 1202, 1202, 1287], [1289, 1289, 1327, 1327, 1367], [1369, 1369, 1393, 1393, 1615], [1617, 1617, 1641, 1641, 2056], [2058, 2058, 2083, 2083, 2190], [2192, 2192, 2214, 2214, 2550], [2552, 2552, 2575, 2575, 2903], [2905, 2905, 2927, 2927, 3028], [3030, 3030, 3052, 3052, 3234], [3236, 3236, 3257, 3257, 3475], [3477, 3477, 3497, 3497, 3604], [3606, 3606, 3648, 3648, 3815], [3817, 3817, 3840, 3840, 3953], [3955, 3955, 3988, 3988, 4013], [4015, 4015, 4072, 4072, 5028]], "test": "error"}
{"id": "3ttGR4", "name": "Twisted graphene", "author": "vegardno", "description": "Two hexagonal grids overlaid at a slight angle", "tags": ["grid", "interference", "interference", "moire", "hexagon", "hexagonalgrid"], "likes": 9, "viewed": 134, "published": "Public", "date": "1575749607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Original: https://www.shadertoy.com/view/Xd2GR3\n// Inspired by: https://www.quantamagazine.org/how-twisted-graphene-became-the-big-thing-in-physics-20190430\n\n#define AA 2\n\n// { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nvec2 rot(in vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c) * p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int mm=0; mm<AA; mm++ )\n    for( int nn=0; nn<AA; nn++ )\n    {\n        vec2 off = vec2(mm,nn)/float(AA);\n        vec2 uv = (fragCoord+off)/iResolution.xy;\n        vec2 pos = (-iResolution.xy + 2.0*(fragCoord+off))/iResolution.y;\n    #else    \n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 pos = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\n        float d0 = hexagon(20.0*pos + .5*iTime).z;\n        float d1 = hexagon(rot(20.0*pos, radians(10.) * sin(radians(15.) * iTime))  + .5*iTime).z;\n        float d = min(d0, d1);\n\n        vec3 col = vec3(1, 1, 1);\n        col *= smoothstep( 0.02, 0.04, d );\n\n        col *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.1 );\n\n        tot += col;\n\t}\t\n \t#if AA>1\n    tot /= float(AA*AA);\n    #endif\n        \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGR4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[300, 358, 383, 383, 894], [896, 896, 926, 926, 1006]], "test": "ok"}
{"id": "3ttGRB", "name": "Orbo Spherical", "author": "onlinerocker", "description": "Orbo chillin' on chcekerboard island\nOptimization tips appreciated ;p", "tags": ["raymarching", "phong", "fun", "animation", "spheretracing", "character"], "likes": 4, "viewed": 84, "published": "Public", "date": "1576782287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define VIEW_DIST 70.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n//iq\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\n//iq\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//slightly modified, but IQ\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.dist = 1000.0;\n    o.normEps = 0.00001;\n    o.color = vec3(0);\n    \n    float yOff = 0.05*sin(5.0*iTime);\n    vec3 offset = vec3(0, yOff, 0);\n    \n    //ground\n    vec3 boardPos = pos;\n    boardPos.z = mod(boardPos.z, 10.0);\n    boardPos.x = mod(boardPos.x, 12.0);\n\tfloat dBoard = sdRoundBox(boardPos - vec3(0,-3,0), vec3(12, 0.5, 10.0), 0.1);\n    if(dBoard < o.dist)\n    {\n        o.dist = dBoard;\n        o.difVal = 0.9;\n        \n        //checker board\n        vec3 col;\n        float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n        float goldMod = step(-2.0, pos.x) * step(pos.x, 2.0);\n        \n        col = vec3(1.0*(1.0-goldMod)) + vec3(0.0,0.4,0.6)*goldMod;\n        col *= (round(step((modi)*sin(pos.x*1.0*PI), 0.0)));\n        \n        o.color = col;\n        o.specVal = 200.0;\n        o.specKs = 0.5;\n    }\n    \n    //tree \n    vec3 treePos = pos;\n    vec2 id = floor(vec2(treePos.x/3.5, treePos.z/5.5));\n    treePos.x = abs(treePos.x);\n    treePos.z = mod(treePos.z, 5.5);\n    treePos.x = mod(treePos.x, 7.0);\n    treePos -= vec3(5.5, -4.5, 2.5);\n    \n    float h = sin(id.x) * 337.0 * sin(id.y) * 43.3;\n    h = -1.0 + mod(h, 3.0);\n    float timeMod = 0.5 + mod(id.x*123.0 / id.y*1234.0, 1.0);\n    h *= sin(iTime*1.0 + 43.445*id.y + 122.89*id.x);\n    treePos.y -= h;\n    \n    float treeBound = sdVerticalCapsule(treePos, 5.0, 0.75);\n    \n    if(treeBound < o.dist)\n    {\n        \n        float dTree = sdVerticalCapsule(treePos, 5.0, 0.5);\n        dTree = smin(dBoard, dTree, 0.3);\n        if(dTree < o.dist)\n        {\n            o.dist = dTree;   \n            o.difVal = 0.9;\n            float modi = 2.0*(round(step(sin(pos.z*PI), 0.0)) - 0.5);\n            float yStep = smoothstep(0.0, 0.3, treePos.y);\n\n            vec3 colTrunk = vec3(0.4, 0.3, 0) + vec3(sin(10.0*floor(10.0*treePos.y)))*0.05;\n            vec3 col = mix(vec3(1)*(round(step((modi)*sin(pos.x*1.0*PI), 0.0))),colTrunk, yStep);\n\n            o.color = col;\n            o.specVal = 200.0;\n            o.specKs = 0.0;\n        }\n        //tree leaves\n        vec3 leafPos = pos;\n        leafPos.x = abs(leafPos.x);\n        leafPos.z = mod(leafPos.z, 5.5);\n        leafPos.x = mod(leafPos.x, 7.0);\n        leafPos -= vec3(5.5, 1.5, 2.5);\n        leafPos.y -= h;\n\n        float dLeaf = sdEllipsoid(leafPos, vec3(1.5, 1.0, 1.5));\n        dTree = smin(dTree, dLeaf, 0.5);\n        if(dLeaf < o.dist)\n        {\n            o.dist = dTree;   \n            o.difVal = 0.9;\n\n            float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n\n            float yStep = smoothstep(-1.0, -0.8, leafPos.y);\n            vec3 col = mix(vec3(0.4, 0.3, 0) ,vec3(0, 0.3, 0), yStep);\n\n            o.color = col;\n            o.specVal = 200.0;\n            o.specKs = 0.0;\n        }\n    }\n    \n    //character bounding box\n    float dBBChar = sdSphere(pos - vec3(0,-0.9,0), 1.7);     \n    if(dBBChar < o.dist)\n    {\n        //body\n\t\tfloat dSphere = sdSphere(pos - vec3(0,-0.9,0) + offset, 1.0);\n        \n        //brows\n        float ang = 0.0;\n        vec3 browPos = pos;\n        browPos.x = abs(browPos.x);\n        browPos = browPos - vec3(0.35,-0.5,0.85) + offset;  \n        browPos.y -= -2.0*browPos.x *(2.0*browPos.x/2.0);\n        mat2 browRot = mat2( vec2(cos(ang), -sin(ang)), vec2(sin(ang), cos(ang)) );\n        browPos = vec3(browRot * browPos.xy, browPos.z);\n        float dBrow = sdEllipsoid(browPos, vec3(0.24, 0.1, 0.16));\n        dSphere = smin(dBrow, dSphere, 0.07);\n        \n        if(dSphere < o.dist)\n        {\n            o.dist = dSphere;\n            float z = pos.y + 1.0;\n            vec3 col = vec3(235.0/255.0, 182.0/255.0, 255.0/255.0);\n            col = mix(col,vec3(0.2, 0, .3), (z/2.0));\n            o.color = col;\n            o.specVal = 55.0;\n            o.specKs = 0.04;\n        }\n\n        //mouth\n        vec3 mouthPos = pos - vec3(0, -1.2, 0.9) + offset;\n        mouthPos.y -=  2.0*mouthPos.x * (mouthPos.x/2.0);\n        float mouthHeight = 0.02 + 0.1*clamp(sin(iTime/2.0), 0.0, 1.0);\n        float dMouth = sdEllipsoid(mouthPos, vec3(0.34, mouthHeight, 0.8));\n\t\tif(-dMouth > o.dist)\n            o.color = vec3(255.0/255.0, 182.0/255.0, 215.0/255.0) * 0.6;\n        o.dist = max(o.dist, -dMouth);\n        \n\n\n\n        //hair sdRoundBox( vec3 p, vec3 b, float r )\n        vec3 hairPos = pos - vec3(0, 0.1, 0);\n        hairPos.y -= -hairPos.z * (hairPos.z/2.0);\n        hairPos.y -= 0.05*sin(hairPos.z*25.0);\n        hairPos += offset;\n        float dHair = sdRoundBox(hairPos, vec3(0.1, 0.2, 0.7), 0.05);\n        if(dHair < o.dist)\n        {\n            o.dist = dHair;\n            //o.color = vec3(0.5, 1.0, 0.5);\n            o.color = vec3(1, 0.5, 0.5) + vec3(0, hairPos.y*1.53, 0);\n            o.specVal = 2.0;\n            o.specKs = 0.0;\n        }\n\n        //add bobbing and swinging animation\n        //\n\n        //feet\n        ang = -PI/4.0;\n        vec3 footPos = pos; \n        footPos.x = abs(footPos.x);\n        mat2 footRot = mat2( vec2(cos(ang), -sin(ang)), vec2(sin(ang), cos(ang)) );\n        vec2 footXZ = footRot * footPos.xz;\n        footPos = vec3(footXZ.x, pos.y, footXZ.y);\n        float dFoot = sdEllipsoid(footPos - vec3(0.3,-2.3,0.6), vec3(0.3, 0.3, 0.4));\n        if(dFoot < o.dist)\n        {\n            o.dist = dFoot;\n            o.color = vec3(0.5, 0., 0.);\n            o.specVal = 2.0;\n            o.specKs = 0.4;\n        }\n\n        //hands\n        float hAng = PI/2.0;\n        vec3 handPos = pos;\n        float modi = handPos.x / abs(handPos.x);\n        handPos.x = abs(handPos.x);\n        \n        handPos = handPos - vec3(1.35+offset.y,-1.5,0.0);\n        //handPos += offset;\n        //handPos = opCheapBend(handPos);\n        mat2 handRot = mat2( vec2(cos(hAng), sin(hAng)), vec2(-sin(hAng), cos(hAng)) );\n        vec2 handXZ = handRot * handPos.xz;\n        handPos = vec3(handXZ.x, handPos.y, handXZ.y);\n        //handRot = mat2( vec2(cos(hAng), -sin(hAng)), vec2(sin(hAng), cos(hAng)) );\n        //handPos = vec3(handPos.x, handRot * handPos.yz);\n        float dHand = sdEllipsoid(handPos, vec3(0.3, 0.35, 0.23));\n        if(dHand < o.dist)\n        {\n            o.dist = dHand;\n            o.color = vec3(1);\n            o.specVal = 50.0;\n            o.specKs = 0.4;\n        }\n\n        //eyes\n        vec3 eyePos = pos;\n        eyePos.x = abs(eyePos.x);\n        eyePos += offset;\n        float dEye = sdSphere(eyePos - vec3(0.34,-0.7,0.8), 0.2);\n        if(dEye < o.dist)\n        {\n            o.dist = dEye;\n            o.color = vec3(1);\n            o.specVal = 100.0;\n            o.specKs = 2.0;\n        }\n\n        //pupils\n        vec3 pupPos = pos;\n        pupPos.x = abs(pupPos.x);\n        pupPos += offset;\n        float dEyePup = sdSphere(pupPos - vec3(0.32,-0.7,0.94), 0.08);\n        if(dEyePup < o.dist)\n        {\n            o.dist = dEyePup;\n            o.color = vec3(0);\n            o.specVal = 100.0;\n            o.specKs = 2.0;\n        }\n        \n        //eye lid\n        vec3 lidPos = pos;\n        //lidPos.y = clamp(lidPos.y, -0.8,-0.5);\n        lidPos.x = abs(lidPos.x);\n        lidPos += offset;\n        float dLid = sdSphere(lidPos - vec3(0.34,-0.7,0.8), 0.225);\n        \n        //consulted IQ's happy jumping for a similar blink rate function\n        if(dLid < o.dist && lidPos.y > 1.0 - 2.0*pow(sin(iTime),40.0))\n        {\n            o.dist = dLid;\n            o.color = vec3(235.0/255.0, 182.0/255.0, 255.0/255.0);\n            o.specVal = 55.0;\n            o.specKs = 0.04;\n        }\n    \n    }\n    \n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\n//iq (modified slightly)\nfloat marchSoftShadow(vec3 pos, Light l, float speed, float w)\n{\n \tMarchRes res;\n    Object o;\n    vec3 dir = normalize(l.pos);\n    float len = length(l.pos - pos);\n    float maxDist = len;\n    \n    res.totalDist = 0.001;\n\n    float sha = 1.0;\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        sha = min( sha, 0.5*o.dist/(w*res.totalDist) );\n        if(sha < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist > maxDist) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\t\n    \n    sha = max(sha,0.0);\n    return sha*sha*(3.0-2.0*sha);\n}\n\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n \tfloat t = mint;\n    float res = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n     \tObject h = map(ro + t*rd);\n        res = min( res, h.dist/(w*t) );\n    \tt += clamp(h.dist, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\nfloat calcShadowSoft(vec3 pos, Light l)\n{\n    //MarchRes res;\n    float val;\n    \n    //val = apprSoftShadow(pos, normalize(l.pos), 0.1, 20.0, 0.005);\n    \n    if(VIEW_DIST > 20.0)\n \t\tval = marchSoftShadow(pos, l, 1.0, 0.05); //march slower to prevent shadow artifacts\n    else\n    \tval = marchSoftShadow(pos, l, 1.0, 0.05);\n\n\treturn val;\n}\n\nfloat calcShadow(vec3 pos, Light l)\n{\n    MarchRes res;\n    if(VIEW_DIST > 20.0)\n \t\tres = marchRay(pos, normalize(l.pos - pos), 0.3); //march slower to prevent shadow artifacts\n    else\n    \tres = marchRay(pos, normalize(l.pos - pos), 1.0);\n        \n    if(res.totalDist < VIEW_DIST)\n        return 0.0;\n\treturn 1.0;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,-0.5,3.5);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = PI/15.0 + iMouse.x/20.0;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    vec2 camXZ = rotCam * camEye.xz;\n    camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 1.0;\n    light.pos = vec3(0, 4, 10);\n    light.color = vec3(1);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n    //add bounce light\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    vec3 col = (vec3(0.3, 0.6, 0.85)*(y) + vec3(1)*(1.0 - y));\n    col += step(pow(dir.x*10.0, 2.0) + pow(dir.z*50.0+50.0, 2.0), 1.0) * vec3(1,0,0) * vec3(sin(dir.x*10.0)*sin(dir.z*50.0));\n\t//col += vec3(1) * mod(dir*50.0, 2.0) * step(50.0, pos.y);\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos) * calcShadowSoft(pos, light)\n            + calcDiffuseLight(res.obj, lightSky, vec3(0));\n        //col += calcDiffuseLight(res.obj, light1, pos);\n        col += calcSpecLight(res.obj, light,pos, camEye) * calcShadowSoft(pos, light);\n        col = applyFog(col, sqrt(pow(pos.x,2.0) + pow(pos.y,2.0) + pow(pos.z,2.0)), normalize(pos), normalize(light.pos - pos));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 532, 569, 569, 599], [601, 606, 643, 643, 668], [670, 675, 708, 708, 740], [742, 747, 800, 800, 867], [869, 874, 919, 919, 1014], [1016, 1021, 1058, 1058, 1147], [1149, 1177, 1422, 1422, 1800], [1802, 1858, 1899, 1899, 1992], [1998, 1998, 2020, 2020, 9548], [9550, 9550, 9587, 9587, 9880], [9886, 9886, 9938, 9938, 10580], [10582, 10607, 10671, 10671, 11394], [11396, 11396, 11469, 11469, 11810], [11812, 11812, 11853, 11873, 12152], [12154, 12154, 12191, 12191, 12472], [12474, 12474, 12526, 12526, 12665], [12667, 12667, 12729, 12729, 13105], [13107, 13107, 13164, 13164, 14906]], "test": "timeout"}
{"id": "3ttGRl", "name": "fire fire", "author": "changjiu", "description": "fire\n/*\n*ç®æ³æ¥èªï¼https://blog.csdn.net/tjw02241035621611/article/details/80045381\n*algorithm from https://blog.csdn.net/tjw02241035621611/article/details/80045381\n*/", "tags": ["fire"], "likes": 1, "viewed": 219, "published": "Public API", "date": "1577240069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n*ç®æ³æ¥èªï¼https://blog.csdn.net/tjw02241035621611/article/details/80045381\n*algorithm from https://blog.csdn.net/tjw02241035621611/article/details/80045381\n*/\n\n#define HASHSCALE1 .1031\n#define PI 3.14159265\n\nvec3 _Color = vec3(1.0,0.3,0.0);\nfloat _GridSize = 30.;\nfloat _RotSpd = 0.5;\nfloat _YSpd = 0.7;\n\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 acc = vec3(0.0,0.0,0.0);\n\n    float rotDeg = 3.*_RotSpd * iTime;\n    float yOffset = 4.*_YSpd* iTime;\n\n    vec2 coord = uv*_GridSize - vec2(0.,yOffset);//æ´ä½æ²¿yè½´ä¸å\n    if (abs(mod(coord.y,2.0))<1.0){\n        coord.x += 0.5;\n    }\n    vec2 gridIndex = vec2(floor(coord));\n    float rnd = Hash12(gridIndex);//æ ¹æ®ID è·åhashå¼\n    // å¼¥è¡¥yè½´ä¸åçéå·® è·ååæ¥çyå¼ \n    // åæ¶å ä¸ºgridIndex = floor(coord) çåå   ä¼è®©tempYå¼å¨éå®åºå®çgridçåæ¶è¶æ¥è¶å¤§;\n    float tempY = gridIndex.y + yOffset ;\n    float life = min(10.0*(1.0-min((tempY)/(24.0-20.0*rnd),1.0)),1.0);\n    if (life>0.0 ) {\n        float size = 0.08*rnd;//è®©å¤§å°éæºå\n        float deg = 999.0*rnd*2.0*PI + rotDeg*(0.5+0.5*rnd);//æ·»å æè½¬éæºå\n        vec2 rotate = vec2(sin(deg),cos(deg));//åä½åæè½¬åç§»\n        float radius =  0.5-size*0.2;\n        vec2 cirOffset = radius*rotate;//\n        vec2 part = fract(coord-cirOffset) - 0.5 ;//è®©æ ¼å­èªå·±æè½¬èµ·æ¥ ä½ç½®å æ¹åä¸å\n        float len = length(part);\n        float sparksGray = max(0.0,1.0 -len/size);//ç»å\n        float sinval = sin(PI*1.*(0.3+0.7*rnd)*iTime+rnd*10.);//å ç¹äº®åº¦çååå®ç°éªç \n        float period = clamp(pow(pow(sinval,5.),5.),0.,1.);\n        float blink =(0.8+0.8*abs(period));\n        acc = life*sparksGray*_Color*blink;\n    }\n\n    // Output to screen\n    fragColor = vec4(acc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 336, 336, 458], [460, 460, 517, 567, 2051]], "test": "ok"}
{"id": "3ttGRs", "name": "Gnarly Apollian Tree", "author": "mrange", "description": "A gnarly apollian tree\nBased upon: https://www.shadertoy.com/view/4ds3zn", "tags": ["raymarcher"], "likes": 70, "viewed": 908, "published": "Public API", "date": "1577269165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A gnarly apollian tree\n// Based upon: https://www.shadertoy.com/view/4ds3zn\n#define PI  3.141592654\n\nconst int   max_iter      = 130;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2))*2.0 - vec2(1.0);\n    return c;\n}\n\nfloat apollian(vec3 p) {\n  vec3 op = p;\n  float s = 1.3 + smoothstep(0.15, 1.5, p.y)*0.95;\n//  float s = 1.3 + min(pow(max(p.y - 0.25, 0.0), 1.0)*0.75, 1.5);\n  float scale = 1.0;\n\n  float r = 0.2;\n  vec3 o = vec3(0.22, 0.0, 0.0);\n\n  float d = 10000.0;\n    \n  const int rep = 7;\n\n  for( int i=0; i<rep ;i++ ) {\n    mod1(p.y, 2.0);\n    modMirror2(p.xz, vec2(2.0));\n    rot(p.xz, PI/5.5);\n\n    float r2 = dot(p,p) + 0.0;\n    float k = s/r2;\n    float r = 0.5;\n    p *= k;\n    scale *= k;\n  }\n  \n  d = box(p - 0.1, 1.0*vec3(1.0, 2.0, 1.0)) - 0.5;\n  d = abs(d) - 0.01;\n  return 0.25*d/scale;\n}\n\nfloat df(vec3 p) { \n  float d1 = apollian(p);\n  float db = box(p - vec3(0.0, 0.5, 0.0), vec3(0.75,1.0, 0.75)) - 0.5;\n  float dp = p.y;\n  return min(dp, max(d1, db)); \n} \n\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n  float res;\n  float t = 0.2;\n  iter = max_iter;\n    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    res = df(p);\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > 20.) t = -1.;\n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n  vec3 n = normal(p);\n  float fake = float(iter)/float(max_iter);\n  float fakeAmb = exp(-fake*fake*9.0);\n  float amb = ambientOcclusion(p, n);\n\n  vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n  return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 uv = -1.0 + 2.0*q; \n  uv.y += 0.225;\n  uv.x*=iResolution.x/iResolution.y; \n    \n  vec3 la = vec3(0.0, 0.5, 0.0); \n  vec3 ro = vec3(-4.0, 1., -0.0);\n  rot(ro.xz, 2.0*PI*iTime/120.0);\n  vec3 cf = normalize(la-ro); \n  vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n  vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  \n  float t = intersect(ro, rd, iter);\n    \n  if(t > -0.5) {\n    p = ro + t * rd;\n    col = lighting(p, rd, iter); \n    col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n  } \n    \n\n  col=post(col, q);\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 225, 225, 310], [312, 312, 339, 339, 426], [428, 428, 467, 467, 600], [602, 602, 644, 644, 816], [818, 818, 842, 842, 1406], [1408, 1408, 1426, 1426, 1576], [1580, 1580, 1629, 1629, 1901], [1903, 1903, 1943, 1943, 2145], [2147, 2147, 2173, 2173, 2381], [2383, 2383, 2425, 2425, 2655], [2657, 2657, 2686, 2686, 2935], [2937, 2937, 2995, 2995, 3779]], "test": "error"}
{"id": "3ttGRX", "name": "Wizard Morph (Outline/glow demo)", "author": "onlinerocker", "description": "Simple outline: see if you barely missed the object, draw the outline if so ;p\n\nLine 280\n\n->The effect is calculated the same way as softshadows, but being used to create a border \"glow\" effect.", "tags": ["raymarching", "spheretracing", "magic", "easy", "outline"], "likes": 3, "viewed": 129, "published": "Public", "date": "1577064854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define VIEW_DIST 70.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    float minDist;\n    float glowAmt;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n//iq\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\n//iq\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//slightly modified, but IQ\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.dist = 1000.0;\n    o.normEps = 0.00001;\n    o.color = vec3(0);\n    \n    float yOff = 0.05*sin(5.0*iTime);\n    vec3 offset = vec3(0, yOff, 0);\n    \n    //ground\n    /*vec3 boardPos = pos;\n    boardPos.z = mod(boardPos.z, 10.0);\n    boardPos.x = mod(boardPos.x, 12.0);\n\tfloat dBoard = sdRoundBox(boardPos - vec3(0,-3,0), vec3(12, 0.5, 10.0), 0.1);\n    if(dBoard < o.dist)\n    {\n        o.dist = dBoard;\n        o.difVal = 0.9;\n        \n        //checker board\n        vec3 col;\n        float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n\n        col = vec3(1.0);\n        col *= (round(step((modi)*sin(pos.x*1.0*PI), 0.0)));\n        \n        o.color = col;\n        o.specVal = 200.0;\n        o.specKs = 0.5;\n    }*/\n    \n    vec3 objPos = pos - vec3(0, 1.5, 0);\n    float ang = PI/4.0;\n    vec2 objPosXZ = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * objPos.xz;\n    objPos = vec3(objPosXZ.x, objPos.y, objPosXZ.y);\n    \n    float dCube = sdRoundBox(objPos, vec3(0.5), 0.1);\n    float dSphere = sdSphere(objPos, 1.0);\n    float dElip = sdEllipsoid(objPos, vec3(0.5, 1.0, 0.5));\n    //float dCube1 = sdRound\n    \n    float mixVal = (1.0+sin((PI*(iTime + 0.1)) / 3.0));\n        \n    float dMix = mix(dSphere, dCube, mixVal) * step(mixVal, 1.0001)\n        \t\t + mix(dCube, dElip, mixVal - 1.0) * step(mixVal, 2.0) * step(1.0, mixVal);\n    if(dMix < o.dist){\n        o.dist = dMix;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;\n    }\n        \n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    res.minDist = 100000.0;\n    res.glowAmt = 1.0;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        res.glowAmt = min(res.glowAmt, 0.5*o.dist/(0.02+abs(0.02*sin(iTime))*res.totalDist));\n        if(abs(o.dist) < 0.00001)\n        {\n            res.minDist = o.dist;\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        if(o.dist < res.minDist)\n            res.minDist = o.dist;\n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    res.glowAmt = max(res.glowAmt, 0.0);\n    res.glowAmt = smoothstep(0.0, 1.0, res.glowAmt);// res.glowAmt*res.glowAmt*(3.0-2.0*res.glowAmt);\n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0, 2.4,3.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = -0.2;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    vec2 camXZ = rotCam * camEye.xz;\n    //camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirZY = rotCamX * dir.yz;\n    dir = vec3(dir.x, dirZY.xy);\n    \n    Light light;\n    light.intensity = 1.00;\n    light.pos = vec3(0, 10, 10);\n    light.color = vec3(1);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n    //add bounce light\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    /*float timeMod = 1.0 - sqrt(pow(uv.x, 2.0) + pow(uv.y, 2.0));\n    float time = iTime * timeMod;\n    vec2 newUv = mat2(cos(time), sin(time), -sin(time), cos(time)) * uv;\n    //newUv.y -= timeMod;\n    float y = newUv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);*/\n    vec2 newUv = uv;\n\t//newUv *= 100.0;\n    vec3 uv3D = vec3(newUv, iTime/3.0);\n    uv3D.z = mod(uv3D.z, 1.0);\n    uv3D.xy = -0.25 + mod(uv3D.xy, 0.5);\n    uv3D.xy = uv3D.xy/uv3D.z;\n    \n    \n    float y = uv.y + 2.3;\n    y = y / 1.62;\n    vec3 col = (vec3(0.3, 0.0, 0.75)*(y) + vec3(0.8)*(1.7 - y));\n\tcol += step(sqrt(pow(uv3D.x, 2.0) + pow(uv3D.y, 2.0)), 0.5) \n        * step(0.45, sqrt(pow(uv3D.x, 2.0) + pow(uv3D.y, 2.0))) * vec3(1,0,0);\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        col += calcSpecLight(res.obj, light,pos, camEye);\n        col = applyFog(col, sqrt(pow(pos.x,2.0) + pow(pos.y,2.0) + pow(pos.z,2.0)), normalize(pos), normalize(light.pos - pos)); \t\n    }else{\n     \tif(res.minDist < 0.3) //check if we barely missed the surface, if so, draw an outline :)\n            col = mix(vec3(0.2, 0.5, 0.75), col, res.glowAmt);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 570, 607, 607, 637], [639, 644, 681, 681, 706], [708, 713, 746, 746, 778], [780, 785, 838, 838, 905], [907, 912, 957, 957, 1052], [1054, 1059, 1096, 1096, 1185], [1187, 1215, 1460, 1460, 1838], [1840, 1896, 1937, 1937, 2030], [2036, 2036, 2058, 2058, 3634], [3636, 3636, 3673, 3673, 3966], [3972, 3972, 4024, 4024, 5050], [5052, 5052, 5104, 5104, 5243], [5245, 5245, 5307, 5307, 5683], [5685, 5685, 5742, 5742, 7908]], "test": "ok"}
{"id": "3ttGW7", "name": "Joints test", "author": "iq", "description": "Testing sdJoint3D [url]https://www.shadertoy.com/view/3ld3DM[/url] . Similar to [url]https://www.shadertoy.com/view/wlj3zV[/url] but with full UVW coords, for 2D and 3D texturing. Triggered by dr2's test [url]https://www.shadertoy.com/view/3l3GD7[/url]", "tags": ["3d", "animation", "joint", "run", "body"], "likes": 66, "viewed": 2481, "published": "Public API", "date": "1576587659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A test for sdJoint3D (https://www.shadertoy.com/view/3ld3DM), which\n// was inspired by dr2's https://www.shadertoy.com/view/3l3GD7 but\n// I think simpler. It's an evolution of my \"Torus Pipes\" shader\n// (https://www.shadertoy.com/view/wlj3zV) but with full UVW texture\n// coordinates. This allows for consistent 2D or 3D texture mapping\n// and displacement that sticks to the surface, which is very convenient.\n//\n// The shader shows 2D texturing (the checkerboard), 3D solid\n// texturing (the sine wave pattern) and displacement.\n\n\n#define AA 1\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec4(mix(b.x,a.x,h)-k*h*(1.0-h), (b.x<a.x)?b.yzw:a.yzw);\n}\n\nvec4 dmin( in vec4 a, in vec4 b )\n{\n    return (a.x<b.x) ? a : b;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://www.shadertoy.com/view/3ld3DM\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec2 sdJoint3D( in vec3 p, in float l, in float a, \n                out vec3 uvw, out vec3 qos, inout float ioV)\n{\n    qos = p;\n    \n    // if perfectly straight\n    if( abs(a)<0.001 )\n    {\n        float v = p.y;\n        p.y -= clamp(p.y,0.0,l);\n        qos.y -= l;\n        uvw = vec3(p.x,v,p.z) + vec3(0,ioV,0);\n        ioV += l;\n\t\treturn vec2(length(p),clamp(v/l,0.0,1.0));\n    }\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n\t// distance\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n\n    // parametrization\n    float s = sign(a);\n#if 0\n    float v = ra*atan(s*p.y,-s*p.x);\n    u = u*s;\n    if( v<0.0 ) { if( s*p.x>0.0 ) { v = abs(ra)*6.283185 + v; } else { v = p.y; u = q.x + ra; } }\n#else\n    float v = (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y;\n          u = (p.y>0.0) ? s*u : sign(-s*p.x)*(q.x+ra);\n#endif    \n    uvw = vec3(u,v,p.z) + vec3(0,ioV,0);\n    ioV += l;\n    \n    // out coordinate system\n    vec2 scb = vec2(sc.y*sc.y-sc.x*sc.x,2.0*sc.x*sc.y);\n\tqos.x -= ra;    \n    qos.xy = mat2(scb.x,scb.y,-scb.y,scb.x)*qos.xy;\n    qos.x += ra;\n    \n\t// distance    \n    return vec2(sqrt(d2+p.z*p.z), clamp(v/l,0.0,1.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdLine( vec3 p, in float l, \n             out vec3 uvw, out vec3 qos, inout float ioV )\n{\n    qos = p + vec3(0,-l,0);\n\tuvw = p + vec3(0,ioV,0);\n    ioV += l;\n    float h = clamp( p.y/l, 0.0, 1.0 );\n\tp.y -= h*l;\n    return vec2( length( p ), h );\n}\n\n//-------------------------------------------------------------------\n\nvec4 leg( in vec3 pos, in float time )\n{\n    // basic/stupid/test leg animation\n    float tempo = 0.5 + 0.5*sin(time);\n    tempo = 0.5*tempo + 0.5*tempo*tempo*(3.0-2.0*tempo);\n    float an0 = mix(0.25,-0.75,tempo*tempo*0.5+0.5*tempo);\n    float an1 = mix(0.80, 0.80,1.0-(1.0-tempo)*(1.0-tempo));\n    an1 -= 0.8*4.0*tempo*(1.0-tempo)*tempo;\n    float an2 = -0.65 - 0.2*4.0*tempo*(1.0-tempo);\n\n    //---------------\n    \n    vec4  res;\n    vec3  qos = vec3(0.0);\n    float h = 0.0;\n    \n    // join\n    {\n        vec3 uvw;\n        vec2 d2 = sdJoint3D(pos, 0.4, -an0, uvw, qos, h );\n        float d = d2.x - mix(0.26,0.24,smoothstep(0.0,1.0,d2.y) );\n        res = vec4(d,uvw);\n    }\n    \n    // segment\n    {\n        vec3 uvw;\n        vec2 d2 = sdLine( qos, 0.4, uvw, qos, h );\n        float ra = mix(0.24,0.19,smoothstep(0.0,1.0,d2.y));\n        float d = d2.x - ra;\n        if( d<res.x ) res = vec4(d,uvw);\n    }\n    \n    // join\n    {\n        vec3 uvw;\n        vec2 d2 = sdJoint3D(qos, 0.3, -an1, uvw, qos, h );\n        float d = d2.x - mix(0.19, 0.17, smoothstep(0.0,1.0,d2.y));; \n        if( d<res.x ) res = vec4(d,uvw);\n    }\n\n\t// segment\n    {\n        vec3 uvw;\n    \tvec2 d2 = sdLine( qos, 0.9, uvw, qos, h );\n        float ra = 0.17;\n        ra = mix(ra,0.19,smoothstep(0.0,0.3,d2.y));\n        ra = mix(ra,0.11,smoothstep(0.3,1.0,d2.y));\n        ra -= 1.4*sin(atan(uvw.x,uvw.z))*smoothstep(0.0,1.0,d2.y)*(1.0-smoothstep(0.9,1.0,d2.y))*exp2(-d2.y*8.0);\n        float d = d2.x - ra;\n        \n    \tif( d<res.x ) res = vec4(d,uvw );\n    }\n    \n    // join\n    {\n        vec3 uvw;\n        vec2 d2 = sdJoint3D(qos, 0.2, -an2, uvw, qos, h );\n        float d = d2.x - mix(0.11,0.08,smoothstep(0.0,1.0,d2.y) );\n        if( d<res.x ) res = vec4(d,uvw);\n    }\n\n\t// segment\n    {\n        vec3 uvw;\n    \tvec2 d2 = sdLine( qos-vec3(0.0,-0.15,0.0), 0.3, uvw, qos, h );\n        uvw.y-=0.15;\n        float d = d2.x - 0.08;\n    \tif( d<res.x ) res = vec4(d,uvw );\n    }\n\n    return res;\n}\n\nfloat waves( in vec3 p )\n{\n    return 0.5+0.5*sin(p.x*80.0)*sin(p.y*80.0)*sin(p.z*80.0);\n}\n\nfloat disp(in vec3 p, in float s )\n{\n    vec3 q = p;\n    p *=0.4;\n    p.xz *= 0.2;\n\n    float f = 0.0;\n    f += 0.6*waves(p*1.0);    \n    f += 0.4*waves(p*2.0+1.0);\n    f += 0.03*sin(atan(q.x,q.z-s*0.27)*90.0);\n\n    return f;\n}\n\n#define ZERO min(iFrame,0)\n\nvec4 map( in vec3 pos, in float time, float doDisplace )\n{\n    time = time*3.0;\n\n    // body\n\tvec3 bpos = pos;\n    bpos.y -= 0.3*sqrt(0.5-0.5*cos(time*2.0+1.0));\n    bpos.x -= 0.1;\n    bpos.y += 0.35;\n    bpos.x -= 0.2*pow(0.5+0.5*cos(time*2.0+0.5),2.0);\n    vec3 tpos = bpos - vec3(-0.1,0.45,0.0);\n    bpos.xy = -bpos.xy;\n    vec4 res2 = vec4(sdEllipsoid(tpos,vec3(0.3,0.7,0.45)),bpos);\n    \n\t// legs\n#if 0\n    vec4 l1 = leg( bpos-vec3(0.0,0.0, 0.27), 3.1416+time );\n    vec4 l2 = leg( bpos-vec3(0.0,0.0,-0.27), time );\n    vec4 res = dmin(l1,l2);\n    res.w += 0.27*sign(l2.x-l1.x);\n#else\n    // trick to prevent inlining - compiles faster\n    vec4 dl[2];\n    for( int i=ZERO; i<2; i++ )\n       dl[i] = leg( bpos-vec3(0.0,0.0,((i==0)?1.0:-1.0)*0.27), ((i==0)?3.1416:0.0)+time );\n    vec4 res = dmin(dl[0],dl[1]);\n    res.w += 0.27*sign(dl[1].x-dl[0].x);\n#endif    \n        \n    res = smin( res, res2, 0.08 );\n\n\t// displacement\n    float di = disp(res.yzw, sign(pos.z));\n\tfloat tempo = 0.5 + 0.5*sin(time);\n    tempo = 0.5*tempo + 0.5*tempo*tempo*(3.0-2.0*tempo);\n    float an0 = mix(1.0,0.0,tempo);\n    di *= 0.8 + 1.7*an0*(smoothstep(-0.6,0.40,res.z)-smoothstep(0.8,1.4,res.z));\n\tdi *= 1.0-smoothstep(1.9,1.91,res.z);\n    res.x += (0.015-0.03*di)*doDisplace;\n    res.x *= 0.85;\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time, in float doDisplace )\n{\n    const float eps = 0.0005;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*eps,time,doDisplace ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps,time,doDisplace ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps,time,doDisplace ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps,time,doDisplace ).x );\n#else\n    // trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = map(s.xyz, time, doDisplace).x;\n    }\n    return normalize(n.xyz-n.w);\n#endif   \n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, in float doDisplace )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<25; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time, doDisplace ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.025, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time, in float doDisplace )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.5*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, time, doDisplace ).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - occ*0.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n        #endif\n\n        // animation\n        float displace = smoothstep(-0.4,0.4,sin(0.5*time));\n\n        // camera movement\t\n        float an = -0.6 + 0.2*sin(time*0.2) + 9.0*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.3*sin(an), -0.3, 2.3*cos(an) );\n        vec3 ta = vec3( 0.0, -0.8, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv =          ( cross(uu,ww));\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n        \n        // raymarch\n        const float tmax = 4.0;\n        float t = 0.0;\n        vec3 uvw = vec3(0.0);\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            \n            vec4 h = map(pos,time,displace);\n            if( abs(h.x)<0.0001 || t>tmax )\n            {\n                uvw = h.yzw;\n                break;\n            }\n            t += h.x;\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.02);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time, displace);\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            vec3 lig = normalize(vec3(0.5,0.4,0.51));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            dif *= calcSoftshadow( pos, lig, 0.001, 2.0, time, displace );\n            float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n            float amb = 0.55 + 0.45*dot(nor,vec3(0.0,1.0,0.0));\n            float occ = calcOcclusion( pos, nor, time, displace );\n            amb *= occ;\n            \n            // basic ligthing\n            vec3 lin = vec3(0.0);\n            lin += vec3(0.3,0.35,0.4)*amb;\n            lin += vec3(1.1,0.9,0.7)*dif;\n            \n            // material\n            col = mix(vec3(0.8),vec3(0.5,0.1,0),smoothstep(-0.1,0.1,(sin( 50.0*uvw.x )+sin( 50.0*uvw.y )+sin( 50.0*uvw.z ))/3.0));\n            col = mix(col,vec3(0.4,0.25,0.2), displace*smoothstep(1.9,1.91,uvw.y) );\n\n            col = lin*col + spe + fre*fre*fre*0.1*occ;\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGW7.jpg", "access": "shaders20k", "license": "mit", "functions": [[1629, 1681, 1719, 1719, 1843], [1845, 1845, 1880, 1880, 1912], [1914, 1984, 2028, 2028, 2117], [2119, 2160, 2185, 2185, 2204], [2205, 2205, 2319, 2319, 3537], [3539, 3609, 3703, 3703, 3861], [3934, 3934, 3974, 4013, 5907], [5909, 5909, 5935, 5935, 5999], [6001, 6001, 6037, 6037, 6228], [6258, 6258, 6316, 6316, 7556], [7558, 7622, 7690, 7690, 8304], [8306, 8368, 8482, 8482, 8766], [8768, 8768, 8853, 8853, 9167]], "test": "timeout"}
{"id": "3ttGzM", "name": "Animated stars", "author": "vlams1", "description": "Another stylized animated background.", "tags": ["background", "stylized"], "likes": 4, "viewed": 132, "published": "Public API", "date": "1575922873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MS 8\n\nmat2 r(float a) { //Rotate\n    float s = sin(radians(a));\n    float c = cos(radians(a));\n    return mat2(c,-s,s,c);\n}\n\nvec4 stars(vec2 uv) { //Image\n    vec2 id = floor(uv+.5); //Split grid into cells\n    float d = abs(length(fract(uv)-.5)+(sin(iTime-id.x+id.y*.4)*.05-.6))-.02;\n    return mix(vec4(.3,.15,.6,1.),vec4(.6,.4,.9,1.),d < 0. ? 1. : 0.); //Return color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { //Main\n    vec2 uv = fragCoord/iResolution.xy*2.-1.; //Calculate UVs\n    uv.x *= iResolution.x / iResolution.y; //Extend Horizontal UVs to account for aspect ratio\n    uv *= 2.5; //Zoom\n    vec4 c; //Multisample \n    for (int i; i < MS; i++) c += stars(uv + (vec2(2,0) / iResolution.xy) * r(float(i)/float(MS)*360.));\n    fragColor = c / float(MS);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 31, 40, 131], [133, 133, 154, 162, 380], [382, 382, 439, 446, 790]], "test": "ok"}
{"id": "4ttXW4", "name": "Dither Noise", "author": "bradleygriffith", "description": "Dither noise", "tags": ["blotter"], "likes": 2, "viewed": 67, "published": "Public", "date": "1576860079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ANIMATED\n//#define CHROMATIC\n\n\n\n\n\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st, in float speed) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(st + speed * iTime);\n        st *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid combineColors( out vec4 adjustedColor, in vec4 bg, in vec4 color ) {\n    float a = color.a;\n\n    float r = (1.0 - a) * bg.r + a * color.r;\n    float g = (1.0 - a) * bg.g + a * color.g;\n    float b = (1.0 - a) * bg.b + a * color.b;\n\n    adjustedColor = vec4(r, g, b, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    const float c0 = 128.0;\n\n    float speed = 0.35;\n    float spread = 2.0;\n\n    float its = mix(0.0, 1.0 / c0, 0.985 + (0.015 * sin(speed * iTime)));\n    float ofs = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy / spread).r;\n\n    vec3 ditherColor;\n    ditherColor = vec3(its + (ofs / 255.0));\n    ditherColor.rgb = floor( ditherColor.rgb * 255.0 ) / 255.0;\n    ditherColor.rgb *= c0;\n\n    vec4 outColor = vec4(vec3(0.0), 1.0 - min(ditherColor.r, min(ditherColor.g, ditherColor.b)));\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 noise = vec3(0.0);\n    noise += fbm(st * 3.344, speed * 5.0);\n\t\n    \n    outColor = vec4(outColor.rgb, (outColor.a) * smoothstep(0.0, 1.0, (noise.r + noise.g + noise.b) / 3.0) - 0.085);\n    \n    combineColors(fragColor, vec4(1.0), outColor);\n\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 72, 72, 147], [149, 227, 253, 253, 635], [655, 655, 695, 717, 984], [997, 997, 1070, 1070, 1275], [1278, 1278, 1335, 1335, 2201]], "test": "error"}
{"id": "ltyXRt", "name": "GR - Rotating Wave S (Hug Edge)", "author": "bradleygriffith", "description": "wave", "tags": ["wave"], "likes": 1, "viewed": 29, "published": "Public", "date": "1576860173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358\n\n//bool isinf(float val) {\n//    return (val != 0.0 && val * 2.0 == val) ? true : false;\n//}\n\n// Fix a floating point number to two decimal places\nfloat toFixedTwo(float f) {\n    return float(int(f * 100.0)) / 100.0;\n}\n\n// Returns the slope of a line given the degrees of the angle on which that line is rotated;\nfloat slopeForDegrees(float deg) {\n\t// Ensure degrees stay withing 0.0 - 360.0\n    deg = mod(deg, 360.0);\n    \n    float radians = deg * (PI / 180.0);\n\n    return tan(radians);\n}\n\n// Returns slope adjusted for screen ratio.\nfloat normalizedSlope(float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n\treturn ((slope * 100.0) / p.x) / (100.0 / p.x);\n}\n\n// Returns offsets (+/-) for any coordinate at distance given slope.\n//   Note: This function does not normalize distance.\n//   Note: This function does not adjust slope for screen ratio.\nvec2 offsetsForCoordAtDistanceOnSlope(float d, float slope) {\n\treturn vec2(\n        (d * cos(atan(slope))),\n        (d * sin(atan(slope)))\n    );\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with an infinite line, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineIntersection (out vec2 intersect, in vec2 p1, in float m1, in vec2 p2, in float m2) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m1;\n\n\tfloat dxx = 1.0;\n\tfloat dyy = m2;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n    \n   \tif (isinf(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p1.x, p2.y);\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dyy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p2.x, p1.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (p2.y - p1.y)) + (dy * (p1.x - p2.x))) / denominator;\n\n\tisIntersecting = true;\n\tintersect = p2 + (u * vec2(dxx, dyy));\n\n\treturn isIntersecting;\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with a line segment, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineSegmentIntersection (out vec2 intersect, in vec2 point, in float m, in vec2 pA, in vec2 pB) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m;\n\n\tfloat dxx = pB.x - pA.x;\n\tfloat dyy = pB.y - pA.y;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(point.x, pB.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (pA.y - point.y)) + (dy * (point.x - pA.x))) / denominator;\n\n\tif (u >= 0.0 && u <= 1.0) {\n\t\t// Intersection occured on line segment\n\t\tisIntersecting = true;\n\t\tintersect = pA + (u * vec2(dxx, dyy));\n\t}\n\n\treturn isIntersecting;\n}\n\n// Dev Note: Terrible code. Needs refactor. Just trying to find \n//   which two edges of the rect the intersections occur at.\nvoid intersectsOnRectForLine(out vec2 iA, out vec2 iB, in vec2 rMinXY, in vec2 rMaxXY, in vec2 point, in float slope) {\n\tbool firstIntersectFound = false;\n\n\tvec2 intersectA = vec2(0.0);\n\tvec2 intersectB = vec2(0.0);\n\tvec2 intersectC = vec2(0.0);\n\tvec2 intersectD = vec2(0.0);\n\n\tbool intersectsLeft = lineLineSegmentIntersection(intersectA, point, slope, rMinXY, vec2(rMinXY.x, rMaxXY.y));\n\tbool intersectsTop = lineLineSegmentIntersection(intersectB, point, slope, vec2(rMinXY.x, rMaxXY.y), rMaxXY);\n\tbool intersectsRight = lineLineSegmentIntersection(intersectC, point, slope, rMaxXY, vec2(rMaxXY.x, rMinXY.y));\n\tbool intersectsBottom = lineLineSegmentIntersection(intersectD, point, slope, rMinXY, vec2(rMaxXY.x, rMinXY.y));\n\n\tif (intersectsLeft) {\n\t\tiA = intersectA;\n\t\tfirstIntersectFound = true;\n\t}\n    \n\tif (intersectsTop) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectB;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectB;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsRight) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectC;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectC;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsBottom) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectD;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectD;\n\t\t}\n\t}\n}\n\nfloat isWave(vec2 uv, float deg, float wavelength, float edgeDistance, float centerDistance) {\n    \n    // Setup\n    // -------------------------------\n    \n    // Dev Note: I've seen some strange artifacting when the input degrees have\n    //   a high number of decimal places. Fixing degrees to a max of two decimal places\n    //   fixes this bug. Not sure that it's the full solution but the problem is mitigated.\n\tdeg = toFixedTwo(deg);\n    \n    vec2 centerUv = vec2(0.5);\n\tfloat slope = normalizedSlope(slopeForDegrees(deg));\n    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\n    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg));\n   \n\n    // Get wave details\n    // -------------------------------\n\n    // Find point on elipses (imagine oval where radius moves between half height and half width) for perpendicularDeg, adjusting for \n    //   distance from, center space, and amplitude of our wave. Resolution x/y divided by 4 for two waves on screen with amplitude \n    //   equal to 1/4 directional resolution.\n    float ampX = (((iResolution.x / 4.0) - (edgeDistance / 2.0) - (centerDistance / 2.0)) * cos(perpendicularDeg * (PI / 180.0)));\n    float ampY = (((iResolution.y / 4.0) - (edgeDistance / 2.0) - (centerDistance / 2.0)) * sin(perpendicularDeg * (PI / 180.0)));\n    float amplitude = distance(vec2(0.0), vec2(ampX, ampY));\n\n    // Find point on elipses (imagine oval where radius moves between half height and half width) for perpendicularDeg, adjusting for \n    //   distance from, center space, and amplitude of our wave. Resolution x/y divided by 4 for two waves on screen with amplitude \n    //   equal to 1/4 directional resolution. We add centerDistance here (note amplitude subtracts it) to push radius towards edge,\n    //   adjusting for shortened amplitude.\n  \tfloat radiusX = (((iResolution.x / 4.0) - (edgeDistance / 2.0) + (centerDistance / 2.0)) * cos(perpendicularDeg * (PI / 180.0)));\n  \tfloat radiusY = (((iResolution.y / 4.0) - (edgeDistance / 2.0) + (centerDistance / 2.0)) * sin(perpendicularDeg * (PI / 180.0)));\n    float radius = abs(distance(vec2(0.0), vec2(radiusX, radiusY)));\n    \n    \n    // Get offset UVs for width of line, adjacent to center point\n    // -------------------------------\n\n    float angleA = perpendicularDeg;\n    float angleB = mod(perpendicularDeg + 180.0, 360.0); // Offset angle by 180.0, but keep it from exceeding 360.0\n    \n    float slopeA = normalizedSlope(slopeForDegrees(angleA));\n    float slopeB = normalizedSlope(slopeForDegrees(angleB));\n    \n    vec2 kA = offsetsForCoordAtDistanceOnSlope(radius, slopeA);\n    vec2 kB = offsetsForCoordAtDistanceOnSlope(radius, slopeB);\n    \n    vec2 offsetCoordA = centerUv * iResolution.xy;\n    vec2 offsetCoordB = centerUv * iResolution.xy;\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kA;\n    }\n    else {\n        offsetCoordA -= kA;\n    }\n\n    if (angleB <= 90.0 || angleB >= 270.0) {\n        offsetCoordB += kB;\n    }\n    else {\n        offsetCoordB -= kB;\n    }\n\t\n    // Denormalize uvs and uv offsets and find closest point on line for our uv, then renormalize.\n    vec2 uvA = vec2(0.0);\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n    vec2 uvB = vec2(0.0);\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n\n\n\t// Find intersects for line with edges of viewport\n    // -------------------------------\n\n    vec2 uvAIntersectA = vec2(0.0);\n    vec2 uvAIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvAIntersectA, uvAIntersectB, vec2(0.0), iResolution.xy, offsetCoordA, slope);\n    \n    vec2 uvBIntersectA = vec2(0.0);\n    vec2 uvBIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvBIntersectA, uvBIntersectB, vec2(0.0), iResolution.xy, offsetCoordB, slope);\n    \n    vec2 perpendicularIntersectA = vec2(0.0);\n    vec2 perpendicularIntersectB = vec2(0.0);\n    // Note: We use `uvA` here. `uvB` would have same effect and what we want is to\n    //   find the intersect perpedicular to the uv's closest point on the line.\n    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), iResolution.xy, uvA * iResolution.xy, perpendicularSlope); \n\t\n    \n    // Prepare wave\n    // -------------------------------\n    \n    // Find length of each edge of line in relation to the viewport, and to the\n    //   perpendicular line cutting through each uv's closest point on the line.\n    float aLength = distance(uvAIntersectA, uvAIntersectB);\n    float bLength = distance(uvBIntersectA, uvBIntersectB);\n    float perpendicularIntersectionLength = distance(perpendicularIntersectA, perpendicularIntersectB);\n\n    // Find percent of edge length that the uv's closest point on the line constitutes\n    //   for each edge of the line.\n    float aDistance = (distance(offsetCoordA, uvA * iResolution.xy) / aLength) - ((wavelength / 4.0) / aLength);\n    float bDistance = (distance(offsetCoordB, uvB * iResolution.xy) / bLength) - ((wavelength / 4.0) / bLength);\n\n    // Create wave, adjusting input wavelength and amplitude (in pixels) in accordance with\n    //   resolution of line edges along the line's slope. This is kind of convuluted so \n    //   consider a value between 0 and 1 on a diagonal line. That's the value on which each\n\t//   'pixel' of the wave's edge must be based. \n    float varianceA = sin(aDistance * PI * (aLength / (wavelength / 2.0))) * (amplitude / perpendicularIntersectionLength);\n    float varianceB = sin(bDistance * PI * (bLength / (wavelength / 2.0))) * (amplitude / perpendicularIntersectionLength);\n    varianceA *= perpendicularIntersectionLength;\n    varianceB *= perpendicularIntersectionLength;\n\n    // Use wave variance as offsets of each point along our line and adjust each uv's closest\n    //   point on the line accordingly.\n    vec2 kVA = offsetsForCoordAtDistanceOnSlope(varianceA, slopeA);\n    vec2 kVB = offsetsForCoordAtDistanceOnSlope(varianceB, slopeB);\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kVA;\n    }\n    else {\n        offsetCoordA -= kVA;\n    }\n    \n    if (angleB <= 90.0 || angleB >= 270.0) {\n\t\toffsetCoordB += kVB;\n    }\n    else {\n    \toffsetCoordB -= kVB;\n    }\n  \t\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n    \n\n    // Define wave edges\n    // -------------------------------\n    \n   \tfloat distX = abs(step(uvB, uv).x - step(uvA, uv).x);\n   \tfloat distY = abs(step(uvB, uv).y - step(uvA, uv).y);\n   \tfloat wave = max(distX, distY);\n\n\n    return wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // Setup\n    // -------------------------------\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    lowp float deg = 90.0;\n\n    float wavelength = 100.0;\n\n    if (iMouse.z > 0.0) {\n    \twavelength = iMouse.x;\n    }\n\n    float distanceFromEdge = 20.0;\n    float distanceFromCenter = 50.0;\n\tfloat speed = 0.025;\n    \n\n    // Prepare edge details \n    // -------------------------------\n\n\tdeg = fract(iTime * speed) * 360.0;\n    float wave = isWave(uv, deg, wavelength, distanceFromEdge, distanceFromCenter);\n    \n    fragColor = 1.0 - vec4(wave);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 172, 199, 199, 243], [245, 338, 372, 416, 516], [518, 562, 598, 598, 690], [692, 880, 941, 941, 1027], [1029, 1263, 1361, 1603, 2213], [2215, 2447, 2553, 2795, 3394], [3396, 3522, 3641, 3641, 4741], [4743, 4743, 4837, 5159, 11573], [11575, 11575, 11632, 11686, 12185]], "test": "error"}
{"id": "tdGSDc", "name": "Stretch Matrix", "author": "undeadmockingbird", "description": "stretch matrix", "tags": ["matrix"], "likes": 3, "viewed": 93, "published": "Public", "date": "1575162955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c, in vec2 uv) \n{\n  uv = (uv * 2.0 - iResolution.xy) / iResolution.xy / 10.0;\n  uv *= mat2x2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime)) / 5.0;\n  uv /= vec2(dot(uv,uv) * 30.0, dot(uv,uv) * 20.0);\n  c.rgb = vec3(mod(floor(uv.x)+floor(uv.y),2.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 273]], "test": "ok"}
{"id": "tdGSDd", "name": "Box SDF (from iQ's website)", "author": "mstange", "description": "SIGNED distance to a non-rounded box, with a long comment describing what's going on", "tags": ["2d", "distance", "signed"], "likes": 1, "viewed": 505, "published": "Public", "date": "1575317454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D rounded box\n\n// List of some other 2D distances:\n//\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Arc:                  https://www.shadertoy.com/view/wl23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// (0, 0) is the center of the box.\n// The four corners of the box are (+/- b.x, +/- b.y).\n// d is the vector between p and the closest box corner,\n// mapped into the positive quadrant: negative values\n// for dimensions inside the box and positive values for\n// dimensions outside the box.\n// max(d, vec2(0)) is 0 for dimensions inside the box\n// and negative for dimensions outside the box.\n// length(max(d,vec2(0))) is 0 if p is inside the box and\n// the distance from the closest point inside the box if\n// p is outside the box.\n// If p is outside the box, max(d.x,d.y) is positive and\n// min(max(d.x,d.y),0.0) is zero.\n// If p is inside the box, max(d.x,d.y) is the negative\n// distance from p to the closest point on an edge of the box,\n// and min(max(d.x,d.y),0.0) is the same.\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tvec2 ra = 0.4 + 0.3*cos( iTime + vec2(0.0,1.57) + 0.0 );\n\n\tfloat d = sdBox( p, ra);\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGSDd.jpg", "access": "shaders20k", "license": "mit", "functions": [[3370, 3370, 3407, 3407, 3491], [3493, 3493, 3550, 3550, 3905]], "test": "ok"}
{"id": "tdKSD3", "name": "Perlin Noise Practice", "author": "specialsaucewc", "description": "Perlin Noise", "tags": ["noise"], "likes": 0, "viewed": 54, "published": "Public", "date": "1575234669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21Old(vec2 p) {\n   return fract( sin(p.x * 100. + p.y*6574.)*5647.);\n}\n\nfloat N21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx*1500.) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise(vec2 uv) {\n   vec2 cv = fract(uv);\n   vec2 id = floor(uv);\n   cv = cv*cv*(3.-2.*cv);\n   \n   \n   float bl = N21(id);\n   float br = N21(id+vec2(1, 0));\n   float b = mix(bl, br, cv.x);\n   \n   float tl = N21(id+vec2(0, 1));\n   float tr = N21(id+vec2(1, 1));\n   float t = mix(tl, tr, cv.x);\n   return mix(b, t, cv.y);\n}\n\nfloat SmoothNoise2(vec2 uv, float nBase) {\n   float c = SmoothNoise(uv*nBase);\n   c += SmoothNoise(uv*(2.*nBase)) * .5;\n   c += SmoothNoise(uv*(4.*nBase)) * .25;\n   c += SmoothNoise(uv*(8.*nBase)) * .125;\n   c += SmoothNoise(uv*(16.*nBase)) * .0625;\n   \n   return c / 1.9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n   uv += iTime * .4;\n   float c = SmoothNoise2(uv, 4.);\n   \n   vec3 col = vec3(c);\n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 77], [79, 79, 98, 98, 221], [223, 223, 251, 251, 555], [557, 557, 599, 599, 831], [833, 833, 890, 890, 1048]], "test": "ok"}
{"id": "tdVXDt", "name": "gÃ©nÃ©ration de terrain", "author": "DanielDht", "description": "gÃ©nÃ©ration de terrain", "tags": ["gnrationdeterrain"], "likes": 8, "viewed": 125, "published": "Public", "date": "1575367046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PIP \n\n// View distance\nconst float view=6500.0;\n\n// Iterations\nconst int N=400;\n\n// Lipschitz constant\nconst float K=8.0;\n\n// Hashing function\nfloat Hash(vec3 p)  \n{\n    p  = fract( p*0.3183099+0.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise\nfloat Noise( in vec3 x ) // x : Point\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat ridge_noise(in vec2 p, in float k)\n{\n    float n  = Noise(vec3(p.xy,0.0));\n    for( float i=0.0; i<k; i++ )\n    {\n        n = min(n, Noise(vec3(p.xy + i*5.0, 0.0)));\n    }\n    return n;\n}\n\n// Terrain\nfloat Terrain( in vec2 x ) // x : Position in the plane\n{\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8); // Rotation matrix\n\n    const float l0 = 600.0; // longueur d'onde ini\n    const float a0 = 400.0; // y (altitude) scale\n    \n\tvec2  p = x/l0;\n    float a = 0.0;      // altitude\n    float alpha = 1.0;  // coeff de reduction\n    float b = 1.0;      // frÃ©quence rÃ©duite par 2\n    \n    for( int i=0; i<8; i++ ) \n    {\n        float n = ridge_noise(p, 2.0);\n        a += b*n *alpha; \n        alpha *= smoothstep(-0.30, 0.99 , a); \n\t\tb *= 0.6; \n        p = m2*p*2.0;\n    }\n\treturn 0.0 +a0*a;\n}\n\nbool Intersect( in vec3 ro, in vec3 rd, out float t, out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<N; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - Terrain( pos.xz );\n\t\tif( abs(h)<(0.01*t)  ) return true;\n\t\tif( t>view ) return false;\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += h*sqrt(1.0+8.0*t/view)/K;\n\t}\n\n\treturn false;\n}\n\n// Normal of the Terrain\nvec3 Normal( in vec2 p) // p : Position in the plane\n{\n    vec2 eps = vec2( 0.25, 0.0 );\n    return normalize( vec3( Terrain(p-eps.xy) - Terrain(p+eps.xy),\n                            2.0*eps.x,\n                            Terrain(p-eps.yx) - Terrain(p+eps.yx) ) );\n}\n\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // ro : Camera transform\n    // rd : Camera ray\n\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    \n\tvec3 color;\n    float t;\n    int it;\n    bool b=Intersect( ro, rd, t , it);\n    if( b==false)\n    {\n        // sky\t\t\n        color = vec3(0.35,0.65,0.95) - rd.y*rd.y*0.5;\n    }\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 p = ro + t*rd;\n        vec3 n = Normal( p.xz );\n\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n\n        color=vec3(0.471,0.361,0.110);\n        \n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif*2.0; // *alpha: intensitÃ© \n        \n        color += dif*vec3(0.35,0.35,0.35);\n\n\t\t// fog\n        float fo = 1.0-exp(-pow(0.0005*t,1.5) );\n        fo *= 0.85;\n        //float fo = 0.f; // fog dÃ©sactivÃ©\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        color = mix( color, fco, fo );\n\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    float s=float(it)/float(N);\n\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    // Gamma with square root\n    return vec4( sqrt(color), t );\n    }\n}\n\n// Camera path\nvec3 Path( float time )\n{\n    // desynchronize cos and sin for epic lissajou path, circle otherwise\n\treturn vec3( 1100.0*cos(0.25*time), (613.0 ), 1100.0*sin(0.85*time) );\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro = Path( time );\n\t\n    // Target\n    vec3 ta = Path( time + 3.0 );\n\tta.y = ro.y - 362.0;\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw +0.2);\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/3.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.2 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; // set par moveCamera\n    mat3 cam = moveCamera( time, ro);   \n\n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n    \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0)); \n     \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n    //fragColor = vec4( 0.0,0.0,0.0, 0.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 151, 173, 173, 269], [271, 297, 336, 336, 810], [812, 812, 854, 854, 1005], [1007, 1018, 1075, 1075, 1612], [1614, 1614, 1679, 1679, 2000], [2002, 2027, 2081, 2081, 2294], [2296, 2296, 2345, 2421, 3565], [3567, 3582, 3607, 3681, 3755], [3757, 3757, 3799, 3810, 4083], [4085, 4085, 4133, 4158, 4558], [4560, 4560, 4617, 4669, 5172]], "test": "timeout"}
{"id": "tl33Wj", "name": "Color Wave (Practice #4)", "author": "Coda_", "description": "Color Wave (Practice #4)", "tags": ["wave", "distortion", "color"], "likes": 9, "viewed": 200, "published": "Public", "date": "1577566214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define time iTime\n\nfloat cube(vec3 p, vec3 s)\n{\n   \tfloat v = 0.78; \n   \tp.xy *= mat2(cos(v),-sin(v),sin(v),cos(v)) ;\n   \tvec3 q = fract(p)*2.0 -1.0;\n\treturn length(max(abs(q)-s,0.0));\n}\n    \nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t =0.0;\n    for(int i = 0; i < 100;i++)\n    {\n    \tvec3 p = o+r*t;\n        float d = cube(p-vec3(-2,0.5,0),vec3(0.01,0.05,3));\n        t += d * 0.25;         \n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 uv = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x,1.0);\n\tuv.y *= (sin(5.0*uv.y+ time)*0.5+0.5)/5.0;\n    vec3 r = normalize(vec3(uv,1.0)); \n    r.xy*= mat2(cos(0.79),-sin(0.79),sin(0.79),cos(0.79)) ;\n    vec3 o = vec3(-0.75,0,0);\n    float t = trace(o,r);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float fog = 1.0/(1.0+t*t*0.01);\n\n\n    fragColor = vec4(vec3(fog*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl33Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 49, 49, 188], [194, 194, 223, 223, 411], [414, 414, 471, 471, 955]], "test": "ok"}
{"id": "tl33zn", "name": "HUD UI", "author": "Sachiemon", "description": "acads", "tags": ["acads"], "likes": 5, "viewed": 100, "published": "Public", "date": "1575442115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n   //return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 10.0 * dot(m, g);\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 36.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 2.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(360.0*atan(d.y,d.x)/M_PI/theta0,150.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,10.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    float offset=1.5*snoise(uv+sin(iTime));\n    float noise=.5*gnoise(uv);\n    return SMOOTH(r+width-2.0,radius*1.5)-SMOOTH(r*width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width*2.0,radius)-SMOOTH(r+width/5.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float offset=1.5*snoise(uv+sin(iTime));\n    float noise=.5*gnoise(uv);\n    float theta = offset*(atan(d.y,d.x)/M_PI);\n    return smoothstep(4.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*iTime, 80.0);\n    return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n   // finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(iTime)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*iTime)+0.15*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+7.0)+0.2*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl33zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 605, 605, 845], [847, 862, 887, 887, 1398], [1400, 1418, 1476, 1476, 1614], [1616, 1616, 1643, 1643, 2041], [2043, 2060, 2081, 2081, 2128], [2129, 2129, 2150, 2150, 2197], [2198, 2198, 2220, 2220, 2255], [2257, 2257, 2279, 2279, 3326], [3346, 3346, 3370, 3392, 3643], [3644, 3644, 3698, 3722, 4352], [4354, 4354, 4417, 4417, 4599], [4601, 4601, 4680, 4680, 4890], [4891, 4891, 4955, 4955, 5358], [5360, 5360, 5413, 5413, 5834], [5836, 5836, 5886, 5886, 6080], [6081, 6081, 6129, 6129, 6450], [6451, 6451, 6485, 6485, 6531], [6532, 6532, 6566, 6566, 6790], [6791, 6791, 6848, 6848, 7970]], "test": "ok"}
{"id": "tl3GDH", "name": "sdfOp--n01", "author": "jorge2017a1", "description": "sdfOp--n01", "tags": ["sdfopn01"], "likes": 0, "viewed": 42, "published": "Public", "date": "1576162759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\nconst int CCero = 0;\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    float dif4;\n    \n    \n    d=999.9;\n    float planeDist = p.y;\n    vec2 res;\n    \n    res=vec2(planeDist,4);\n   \n    \n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(2.65,1.5,0.8));\n    \n    \n    float sdc0=sdCylinder( p.xzy-vec3(-1.5,4.5,1.5), vec2(0.5,4.0) ) ;\n    float sdc1=sdCylinder( p.xzy-vec3(0.0,4.5,1.5), vec2(0.5,2.0) ) ;\n    float sdc2=sdCylinder( p.xzy-vec3(1.5,4.5,1.5), vec2(0.5,4.0) ) ;;\n  \n    \n        \n    res = opU(res, vec2(bxInf, CInf));\n    \n    res = opU(res, vec2(sdc0, CAtras));\n    res = opU(res, vec2(sdc1, CAtras));\n    res = opU(res, vec2(sdc2, CAtras));\n   \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, -3.5);\n    \n\n    //vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    vec3 rLuz=vec3(-0.5, -4.5, -5.5);\n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    float dif = GetLight(p);\n    \n    float dif2 = abs(1.0- GetLight( pluz));\n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    dif=(dif+dif2)/1.5;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3GDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 369, 402, 402, 467], [468, 486, 522, 522, 591], [592, 607, 638, 638, 788], [789, 809, 845, 845, 932], [933, 949, 981, 1009, 1070], [1123, 1123, 1169, 1169, 1201], [1203, 1203, 1245, 1245, 1277], [1279, 1279, 1326, 1326, 1359], [1362, 1362, 1391, 1391, 1517], [1571, 1571, 1599, 1599, 2580], [2584, 2631, 2667, 2667, 2770], [2826, 2826, 2851, 2851, 3605], [3608, 3608, 3642, 3642, 3876], [3882, 3882, 3906, 3906, 4138], [4142, 4142, 4166, 4166, 4551], [4558, 4558, 4615, 4615, 5330]], "test": "error"}
{"id": "tl3GR7", "name": "2da-Columna-jf", "author": "jorge2017a1", "description": "2da-Columna-jf", "tags": ["2dacolumnajf"], "likes": 2, "viewed": 51, "published": "Public", "date": "1575905313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\nconst int CCero = 0;\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    float dif4;\n    \n    \n    d=999.9;\n    float planeDist = p.y;\n    vec2 res;\n    \n    \n    // This makes everything below repeat infinitely.\n    p.xz = mod(p.xz, 8.5) - vec2(2.5,1.5);\n    //p.xz = mod(p.xz, 4.5) -vec2(2.0,2.8);\n    \n    res=vec2(planeDist,4);\n   \n    \n    float bxInf = sdBox (p-vec3(0.0,0.2,4.5),vec3(0.8,0.6,0.8));\n    float bxSup = sdBox (p-vec3(0.0,6.0,4.5),vec3(6.5,0.3,6.0));\n    \n    \n    float sdc1=sdCylinder( p-vec3(0.0,1.5,4.5), vec2(0.5,2.5) ) ;\n    float sp1=sdSphere(p-vec3(0.0,3.9,-4.5),0.8);\n  \n    \n    res = opU(res, vec2(bxInf, 2));\n    res = opU(res, vec2(sdc1, CInf));\n    res = opU(res, vec2(sp1, 5));\n    res = opU(res, vec2(bxSup, 9));\n    \n    \n    \n   \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, -1.5+4.5*sin(iTime));\n\n    //vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    vec3 rLuz=vec3(-0.5, -4.5, -5.5);\n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    //float dif =0.30- GetLight(p);\n    float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    //float dif2 = abs(1.0- GetLight( pluz));\n    \n    float dif2 = abs(1.0- GetLight( pluz));\n    \n    //float dif2 =0.0;\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2)/1.5;\n    //dif=(dif+dif2)*3.0;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3GR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 368, 401, 401, 466], [467, 485, 521, 521, 590], [591, 606, 637, 637, 787], [788, 808, 844, 844, 931], [932, 948, 980, 1008, 1069], [1122, 1122, 1168, 1168, 1200], [1202, 1202, 1244, 1244, 1276], [1278, 1278, 1325, 1325, 1358], [1361, 1361, 1390, 1390, 1516], [1570, 1570, 1598, 1598, 2579], [2583, 2630, 2666, 2666, 2769], [2825, 2825, 2850, 2850, 3711], [3714, 3714, 3748, 3748, 3982], [3988, 3988, 4012, 4012, 4244], [4248, 4248, 4272, 4272, 4657], [4664, 4664, 4721, 4721, 5648]], "test": "error"}
{"id": "tlcGDX", "name": "Daily Coding [2]", "author": "ozu", "description": "Wow, 2D Grid!\nAs FabriceNeyret2 recommended I used 1. / iResolution.y instead of 'magic number' for antialiasing.\n", "tags": ["circles", "grid", "packing", "forloop"], "likes": 6, "viewed": 118, "published": "Public", "date": "1577727370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float radius, float blur){\n\n    float d = length(uv - p);    \n    float c = smoothstep(blur,0.,abs(d-radius));\n   // c -= smoothstep(radius - blur, radius - 2. * blur, d);\n       \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = (fragCoord - .5* iResolution.xy) / iResolution.x;\n    float c = 0.;\n    vec2 p ;\n\n    int max_i = 20;\n    int max_j = 20;\n    float dist = 1. / float(max_i);\n    float radius = dist;\n    float speed = -2.;\n    \n    for (int i=0; i<max_i; i++){\n            p.x = float(i) * dist -.5 + dist / 2.;\n        for (int j=0; j<max_j; j++){\n\n            p.y = float(j) * dist -.5 + dist / 2.;\n       \t\tfloat t = sin(speed * iTime + float(i) * .125) * .5 +.5;\n       \t\tradius = t * (sin(float(i/max_i)) * .5 +.5) * dist;\n\t\t\tfloat blur = 1.5/ iResolution.y;\n\n            \n            float circle = Circle(uv, p, radius, blur);\n            c +=circle;\n        }\n     }\n    \n    fragColor = vec4(c, c, c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcGDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 225], [227, 227, 282, 282, 997]], "test": "ok"}
{"id": "tlcGRB", "name": "Multisegment Floppy Tube", "author": "dr2", "description": "Long floppy tube closeup (as in \"Elevating Platter\")", "tags": ["geometry", "helix", "kinematics"], "likes": 11, "viewed": 328, "published": "Public API", "date": "1576691120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Multisegment Floppy Tube\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\nvec4 hxHit;\nvec3 ltDir;\nfloat tCur, dstFar, aMin, dLoop, aLoop, hLen, rCyl;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float nSeg = 5.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b, c;\n  float dMin, d, lb, dr, rSph;\n  dMin = dstFar;\n  rSph = 0.9 *rCyl;\n  p.x -= - 0.5 * hLen;\n  p.xy = Rot2D (p.xy, 0.5 * pi - aLoop);\n  for (float k = 0.; k < nSeg; k ++) {\n    q = p;\n    q.xy = Rot2D (q.xy, 0.5 * pi);\n    q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n    b = vec2 (length (q.xy) - dLoop, q.z);\n    lb = length (b);\n    c = atan (vec2 (q.y, b.x), vec2 (- q.x, b.y)) * vec2 (4. * dLoop / pi, 1.) / pi;\n    dr = SmoothBump (0.15, 0.85, 0.1, mod (2. * c.x +\n       2. * c.y * (mod (float (k), 2.) - 0.5), 1.)) - 0.5;\n    d = max (min (abs (lb - 0.95 * rCyl) + 0.05 * dr * rCyl, lb - 0.7 * rCyl),\n       dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi))));\n    if (k == 0.) d = min (d, PrSphDf (p, rSph));\n    p.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n    p.x *= -1.;\n    if (k == nSeg - 1.) d = min (d, PrSphDf (p, rSph));\n    if (d < dMin) {\n      dMin = d;\n      hxHit = vec4 (c, lb, k);\n    }\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  vec2 p, ip;\n  float dstObj, tCyc, sLoop, vDotL, sh, c;\n  tCyc = 10.;\n  aMin = 0.6;\n  sLoop = aMin + 20. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (tCur / tCyc, 1.)), 4.);\n  aLoop = 0.25 * pi / sLoop;\n  dLoop = 6. * 0.25 * pi * sLoop;\n  hLen = 2. * nSeg * dLoop * sin (aLoop);\n  rCyl = 2.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (hxHit.z < 0.2 * rCyl) {\n      col4 = (hxHit.x < 0.) ? vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.);\n    } else if (hxHit.z < 0.91 * rCyl) {\n      hxHit.x -= 1.5 * hxHit.y * (mod (hxHit.w, 2.) - 0.5);\n      p = hxHit.xy * vec2 (2. * sqrt3, 3.);\n      ip = PixToHex (p);\n      c = mod (dot (mod (2. * ip + ip.yx, 3.), vec2 (1., 2.)), 3.);\n      col4 = (c == 0.) ? vec4 (0.7, 0.6, 0., 0.2) : ((c == 1.) ? vec4 (0.8, 0.8, 0.4, 0.2) :\n         vec4 (0.4, 0.2, 0., 0.2));\n      col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.07, HexEdgeDist (p - HexToPix (ip)));\n    } else {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    }\n    if (col4.a >= 0.) {\n      sh = ObjSShadow (ro, ltDir);\n      vDotL = max (dot (vn, ltDir), 0.);\n      col = col4.rgb * (0.2 + 0.8 * sh * vDotL * vDotL) +\n         0.2 * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n  } else {\n    col = vec3 (0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 2. * pi * mPtr.y;\n  } else {\n    az += 0.01 * 2. * pi * tCur;\n  }\n  zmFac = 3.5;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -50.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcGRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[533, 533, 555, 555, 1542], [1544, 1544, 1577, 1577, 1775], [1777, 1777, 1798, 1798, 1995], [1997, 1997, 2034, 2034, 2256], [2258, 2258, 2282, 2282, 2512], [2514, 2514, 2538, 2538, 2598], [2600, 2600, 2628, 2628, 2708], [2710, 2710, 2745, 2745, 4169], [4171, 4171, 4224, 4224, 5274], [5276, 5276, 5309, 5309, 5336], [5338, 5338, 5374, 5374, 5580], [5582, 5582, 5612, 5612, 5725], [5727, 5727, 5784, 5784, 5867]], "test": "ok"}
{"id": "tlcGz4", "name": "Capsule SpongeV1", "author": "jorge2017a1", "description": "a menger sponge with cylinders, Capsule  instead of cubes.", "tags": ["capsulesponge"], "likes": 7, "viewed": 96, "published": "Public", "date": "1575726489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --2019-dic-07\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n\nfloat DE(vec3 p){\n    \n    //float d = cylIntersection(p);\n\tfloat d;\n    float distToCapsule = dsCapsule(vec3(-0.0,0.0,0.0), vec3(2.0,1.0,0.1), 1.0, p);    \n    \n    d=distToCapsule;\n    \n    float s = 1.;\n    \n    \n    for(int i = 0;i<5;i++){\n        p *= 3.;\n    \ts*=3.;\n    \tfloat d2 = cylUnion(p) / s;\n        \n        \n        float d3=sdBox(p, vec3(2.0,1.0,2.5));\n        //d2=d2*d3/2.0;\n            \n        //float m = texelFetch(iChannel0, ivec2(32, 0), 0).x * 2. - 1.;\n        float m = -1.0;\n        \n    \td = max(d,m*d2);\n   \t \tp = mod(p+1. , 2.) - 1.; \t\n    }\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime * .04;\n    float time = iTime * .6;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float s1 = sin(time), c1 = cos(time);\n    float arg = 1.5*sin(time*.7894)*.5 + .5;\n    float s2 = sin(arg), c2 = cos(arg);\n    \n    vec3 ro = vec3(0, .2, 1)*2.5;\n    \n    \n    ro.yz = mat2(c2,-s2,s2,c2)*ro.yz;\n    ro.xz = mat2(c1,s1,-s1,c1)*ro.xz;\n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 350, 350, 381], [383, 383, 414, 414, 505], [508, 508, 531, 531, 668], [670, 670, 700, 700, 837], [887, 887, 956, 1035, 1076], [1078, 1078, 1160, 1160, 1391], [1393, 1393, 1453, 1453, 1594], [1644, 1644, 1661, 1702, 2232], [2234, 2234, 2263, 2263, 2451], [2453, 2453, 2494, 2494, 2670], [2672, 2672, 2713, 2713, 2865], [2867, 2867, 2888, 2888, 3018], [3020, 3020, 3047, 3047, 3294], [3296, 3296, 3353, 3385, 3982]], "test": "ok"}
{"id": "tld3RN", "name": "Hiccup Sine Glow", "author": "tombla", "description": "Hiccup sine glow ", "tags": ["glow", "sine"], "likes": 3, "viewed": 337, "published": "Public API", "date": "1576229621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COLORF            vec3(1.0, 0.5, 0.0)\n#define COLORG            vec3(0.1, 0.9, 0.1)\n#define COLORH            vec3(0.2, 0.2, 1.0)\n\n#define COLOR_INNER       vec3(1.0, 1.0, 1.0)\n\n#define OUTER 0.07\n#define INNER 0.01\n\n\nfloat pulse(float factor, float x)\n{\n    float t = factor*x;\n    return t*exp(1.0-t);\n}\n\nvec3 mindist_f(float a, float b, vec2 uv, float step)\n{\n    vec3 mindist = vec3(10., 10., 10.);\n    for(float d=-0.05; d<=0.05; d+=0.005) {\n        float x = uv.x + d;\n        float y1 = 0.5 + (0.30 + a + b) * sin(0.5 + x * 12. + step);\n        float y2 = 0.5 + (0.25 + 1.2 * a + 0.8 * b) * sin(4. + x * 9. + step * 1.1);\n        float y3 = 0.5 + (0.20 + 1.4 * a + 0.7 * b) * sin(3. + x * 7. + step * 1.2);\n        float dist1 = distance(uv, vec2(x, y1));\n        float dist2 = distance(uv, vec2(x, y2));\n        float dist3 = distance(uv, vec2(x, y3));\n        mindist = min(mindist, vec3(dist1, dist2, dist3));\n    }\n    return mindist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1 for y, from 0 to n for x)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Step based on time\n    float step = iTime * 3.;\n    \n    // Slow and small amplitude.\n    float a = 0.02 * cos(iTime * 4.);\n    // Longer and larger amplitude\n    float b = 0.1 * pulse(10., mod(iTime * 1.5, 4.));\n    \n    vec3 dist = mindist_f(a, b, uv, step);\n    float fx = dist[0];\n    float gx = dist[1];\n    float hx = dist[2];\n    // Blue and white parts.\n    float fcolor = smoothstep(OUTER, 0., fx);\n    float fwhite = smoothstep(INNER, 0., fx);\n    float gcolor = smoothstep(OUTER, 0., gx);\n    float gwhite = smoothstep(INNER, 0., gx);\n    float hcolor = smoothstep(OUTER, 0., hx);\n    float hwhite = smoothstep(INNER, 0., hx);\n    vec3 color = fcolor * COLORF +\n                 gcolor * COLORG +\n                 hcolor * COLORH +\n                 fwhite * COLOR_INNER +\n                 gwhite * COLOR_INNER +\n                 hwhite * COLOR_INNER;\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tld3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 262, 262, 313], [315, 315, 370, 370, 955], [957, 957, 1014, 1089, 2092]], "test": "ok"}
{"id": "tldGRX", "name": "Animated arrow", "author": "dtsmio", "description": "animated arrow", "tags": ["animation"], "likes": 1, "viewed": 243, "published": "Public API", "date": "1577101557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nvoid rotate2d(inout vec2 v, float a) {\n    mat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n    v = m * v;\n}\n\nfloat arrow(vec2 av) {\n    \n    float line1 = length(av - vec2(0., clamp(av.y, -0.2, 0.2)));\n    line1 = smoothstep(0.06, 0.05, line1);\n    \n    vec2 rav = av;\n    rav.y += 0.23;\n    rotate2d(rav, PI/4.);\n    \n    float line2 = length(rav - vec2(0., clamp(rav.y, 0., 0.2)));\n    line2 = smoothstep(0.06, 0.05, line2);\n\n    rotate2d(rav, -PI/2.);\n    float line3 = length(rav - vec2(0., clamp(rav.y, 0., 0.2)));\n    line3 = smoothstep(0.06, 0.05, line3);\n    \n    return clamp(line1 + line2 + line3, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n\n    float time = fract(iTime / 1000.) * 600.;\n    \n    float at = fract(time); // 0..1\n    at -= 0.5;\n\tat *= at * at;\n    \n    vec2 av = uv;\n    av.y += at * 6.;\n\tfloat a = arrow(av);\n    \n    float cir = length(uv);\n    cir = smoothstep(0.36, 0.35, cir);\n    \n    float ca = fract(time); // 0..1\n    ca = (ca * 6. - 1.);\n    ca *= -ca;\n    ca += 1.;\n    ca /= 2.;\n    ca = clamp(ca, 0., 1.);\n    float cir2 = length(uv - vec2(0., .65 + ca/12.));\n    cir2 = smoothstep(0.26 + ca/1., 0.15 + ca/4., cir2);\n    \n    \n    float ca2 = fract(time); // 0..1\n    ca2 = (ca2 * 6. - 5.);\n    ca2 *= -ca2;\n    ca2 += 1.;\n    ca2 /= 2.;\n    ca2 = clamp(ca2, 0., 1.);\n    float cir3 = length(uv - vec2(0., -.65 + ca2/12.));\n    cir3 = smoothstep(0.26 + ca2/1., 0.15 + ca2/4., cir3);\n\t    \n    col = vec3(cir - a - cir2 - cir3);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 57, 57, 126], [128, 128, 150, 150, 637], [640, 640, 697, 697, 1643]], "test": "ok"}
{"id": "tldGz4", "name": "radar chart", "author": "ducklett", "description": "simple radar chart made with iq's polygon function", "tags": ["sdf", "chart"], "likes": 3, "viewed": 318, "published": "Public API", "date": "1575819216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float a = 3.1415/3.;\n    \n    //float[] ivs = float[](14.,0.,31.,31.,31.,31.);\n    \n    float center=2.;\n    float lim=31.;\n    \n    vec2[6] poly;\n    vec2[6] bg;\n    float[6] ivs;\n    for (int i=0;i<6;i++){\n        float fi = float(i);\n        ivs[i] = noise(vec2((iTime), fi*a))*lim;\n    \tpoly[i] = vec2(sin(fi*a), cos(fi*a))/(lim+center)*(ivs[i]+center);\n        bg[i] = vec2(sin(fi*a), cos(fi*a))/(lim+center)*(lim+center);\n    }\n\t\n\tfloat d = sdPoly(poly, p );\n    float db = sdPoly(bg, p );\n\n    vec3 gaugec = vec3(.5,.8,.8)*smoothstep(0.,-0.01,d);\n    vec3 bgc = vec3(.4,.4,.5)*smoothstep(0.,-0.01,db);\n    \n\tfragColor = vec4(max(gaugec, bgc),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 632, 632, 739], [740, 740, 766, 766, 1283]], "test": "ok"}
{"id": "tldGzr", "name": "Worley Chebyshev Noise", "author": "dragonyhr", "description": "http://www.sygreer.com/projects/voronoi/", "tags": ["noise"], "likes": 3, "viewed": 169, "published": "Public", "date": "1575516032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592654\n\nvec2 hash22(vec2 p)//Dave Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\treturn fract(cos(p*mat2(-64.2,71.3,81.4,-29.8))*8321.3);\n}\n\n                    \nfloat Worley(vec2 q)\n{\n    float n = 9e9;\n    \n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++){\n            vec2 p = floor(q) + vec2(i, j);\n            vec2 h = hash22(p);\n            vec2 g = p + 0.5+ 0.5 * sin(h*12.6);\n            float xx = abs(q.x-g.x);\n            float yy = abs(q.y-g.y);\n            float d = max(xx, yy);\n            if(d < n){n = d;}\n            //n = n*1;\n        }\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 Color, in vec2 Coord)\n{\n\tColor = vec4(vec3(Worley(Coord.xy/32.0+iTime)),1.0+iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 97, 97, 157], [180, 180, 202, 202, 615], [617, 617, 665, 665, 727]], "test": "ok"}
{"id": "tlt3DB", "name": "tunel-cuadro-v3", "author": "jorge2017a1", "description": "tunel-cuadro-v3", "tags": ["tunelcuadrov3"], "likes": 1, "viewed": 48, "published": "Public", "date": "1577497827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge flores p. //fecha 26-dic--2019\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n///--------------------------------------------\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\t//return textureLod(iChannel0,(p+.5)/32.,-16.).x;\n    return texture(iChannel0,p.xy).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*25.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n///--------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n\tcase 11:\n        //float pattern = fract( 1.-Granite( glpRoRd)*8.) ;\t\n        float pattern = abs( 1.-Granite( glpRoRd)*0.15) ;\t\n        //return Granite(glpRoRd)*vec3(0.2,0.5,0.3);\n        return pattern*vec3(1.0);\n     case 12:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd); \n     case 13:\n        return  vec3(0.5, 0.5, 1.0) * floorTex(glpRoRd); \n     case 14:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(-glpRoRd.zyx); \n     case 15:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd.zyx); \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n    float d, dif1, dif2;\n   vec3 pp;\n    vec2 res;\n    \n    d=999.9;\n    float planeDist = p.y;\n    pp=p;\n   \n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n             res=vec2(res.x, 9);\n         } \n     } \n    \n    \n    \n    \n    p.z=mod(p.z, 1.0)-1.0;\n    \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,5.5,0.), vec3(7,5.8,5) );\n    float sdb2=sdBox(p-vec3(0.0,6.0,0.), vec3(7,5.2,6.0) );\n    \n    \n    \n    float sdb3pisoinf=sdBox(p-vec3(0.0,1.0,0.0), vec3(7,0.1,5.1) );\n    float sdb3pisoizq=sdBox(p-vec3(-6.5,6.0,0.0), vec3(0.2,5.0,5.1) );\n    float sdb3pisoder=sdBox(p-vec3(6.5,6.0,0.0), vec3(0.2,5.0,5.1) );\n    \n    dif1=differenceSDF(sdb1, sdb2);\n    \n    res=opU(res, vec2(dif1,6));\n    \n    \n    res=opU(res, vec2(sdb3pisoinf,14));\n    res=opU(res, vec2(sdb3pisoizq,13));\n    res=opU(res, vec2(sdb3pisoder,13));\n    \n    \n    \n    \n    \n            \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n   \n    vec3 ro = vec3(0, 3.5, -16.5+ iTime*0.5);\n    \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\t\n   \n    \n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    \n    \n    float dif = GetLight(p);\n   \n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2+dif3)/2.0;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlt3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[385, 402, 435, 435, 500], [501, 519, 555, 555, 624], [625, 640, 671, 671, 821], [822, 842, 878, 878, 965], [966, 982, 1014, 1042, 1103], [1106, 1116, 1152, 1152, 1425], [1478, 1478, 1524, 1524, 1556], [1558, 1558, 1600, 1600, 1632], [1634, 1634, 1681, 1681, 1714], [1717, 1717, 1746, 1746, 1872], [1874, 1874, 1910, 1910, 2027], [2029, 2029, 2065, 2065, 2183], [2237, 2237, 2260, 2260, 2419], [2422, 2422, 2449, 2449, 2627], [2678, 2690, 2712, 2712, 3020], [3022, 3022, 3047, 3047, 3237], [3285, 3285, 3313, 3313, 4821], [4875, 4984, 5021, 5021, 5056], [5059, 5059, 5084, 5084, 6218], [6221, 6221, 6255, 6255, 6489], [6492, 6492, 6516, 6516, 6748], [6752, 6752, 6776, 6776, 7161], [7164, 7164, 7190, 7190, 7554], [7560, 7560, 7617, 7617, 8470]], "test": "error"}
{"id": "tlt3WN", "name": "Procedural Hexagon Texture", "author": "MikeXenix", "description": "Modified shader from my precious MechZoneEX project. It is an animated texture inspired by Zone Of The Enders VR training scene. This is my first shader here so it is not excellent...", "tags": ["procedural", "hexagon"], "likes": 10, "viewed": 207, "published": "Public", "date": "1576441030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Michael Yllo - MikeXenix/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Animated texture inspired by Zone Of The Enders VR training scene\n\n// Original version can be seen in the video https://youtu.be/L0oue-ccvNM\n\n// A bit of a hacked together procedural texture computing the closest distance to a hexagon grid using planes and voronoi regions\nfloat hexTex(vec2 Tex)\n{\n    float degAlpha = 57.0;\n    \n    float alpha = (degAlpha) / 360.0 * 2.0 * 3.14159, cal = cos(alpha), sal = sin(alpha);\n\tfloat beta = ((90.0 - degAlpha) / 360.0 * 2.0 * 3.14159), cbe = cos(beta), sbe = sin(beta);\n\tfloat r = 0.5 / cbe;\n\tvec2 P1 = vec2(r*sbe, r*cbe);\n\tvec2 P2 = vec2(2.0 * r*cal, 0.0);\n\tvec2 N = normalize(P2 - P1);\n\tfloat D = dot(vec2(-N.y, N.x), P1);\n    \n\tfloat v = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.y), 1.0));\n\tfloat v2 = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.x), 1.0));\n\tfloat d = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D);\n\tfloat d2 = (dot(vec2(-N.y, -N.x), vec2(v2, v)));\n\n\tif (v2 <= r * cal)\n\t{\n\t\tif (d2 > 0.0)\n\t\t\td = abs(d) / D;\n\t\telse if (v < 0.5)\n\t\t\td = abs(0.5 - v) * 2.0;\n\t\telse if (d > 0.0)\n\t\t\td = abs(d2) / D;\n\t\telse\n\t\t\td = abs(0.5 - v) * 2.0;\n\t}\n\telse if (d <= 0.0)\n\t{\n\t\td = abs(d) / D;\n\t}\n\telse\n\t{\n\t\tif (v2 >= 2.0 * r*cal)\n\t\t{\n\t\t\tif (v < 0.5)\n\t\t\t{\n\t\t\t\tvec2 P3 = vec2(0.25, 0.5);\n\t\t\t\tvec2 N2 = normalize(P3 - P2);\n\t\t\t\tfloat D2 = dot(vec2(-N2.y, N2.x), P2);\n\t\t\t\tfloat d3 = (dot(vec2(-N2.y, -N2.x), vec2(v2, v)) - D2);\n\t\t\t\tif (d3 < 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d) / D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat d4 = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D * 2.0);\n\t\t\t\tif (d4 > 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d2) / D;\n\t\t\t}\n\t\t}\n\t\telse if (v > 0.5)\n\t\t\td = abs(dot(vec2(-N.y, -N.x), vec2(v2, v))) / D;\n\t\telse\n\t\t\td = abs(d) / D;\n\t}\n\n    return min(0.999, d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float c = pow(1.0-hexTex(uv.xy*vec2(6.0,3.0)),3.1+2.0*sin(iTime)); // eval texture and bend with pow\n    float ang = atan(uv.x-0.5,uv.y-0.5);\n    float len = length(uv.xy-vec2(0.5,0.5))*5.0;\n    float clrRing = 2.0 * max(0.0,-len * 0.2 + pow(1.0 - abs(sin(-iTime + len + 0.2*cos(ang * 6.0))), 3.0) * (0.5 + pow(c, 2.0)));\n    c = c*abs(sin(iTime*2.0))*(1.0-len*0.3)+clrRing; // combine and animate more\n\n    // Output to screen\n    fragColor = vec4(0,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlt3WN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[277, 408, 432, 432, 1862], [1863, 1863, 1920, 1970, 2510]], "test": "ok"}
{"id": "tlt3WS", "name": "simplex noise tunnel", "author": "Bleuje", "description": "Tunnel test.\nupdate : improved fps", "tags": ["raymarching"], "likes": 18, "viewed": 255, "published": "Public", "date": "1577468903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by @etiennejcb\n// Using code from : https://www.shadertoy.com/view/Xt2XDt\n// and 3D Simplex noise from https://www.shadertoy.com/view/XsX3zB\n// Got help from @tdhooper\n\nconst float MAX_TRACE_DISTANCE = 100.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 190;\n\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat TWO_PI = 2.0*3.141592;\n\n\nfloat sdTunnel( vec3 p, float s )\n{\n  vec3 inp = vec3(5.5*p.x,1.5*p.y,20.0*p.z-5.0*iTime);\n  float ns =  simplex3d(inp);\n  float yy = -0.45*pow(max(0.,-0.5*p.z),1.5);\n  float angle2 = atan((p.y+yy),p.x);\n  float sph = abs(length(vec2(p.x,p.y+yy))-s)+0.01+0.017*sin(5.0*angle2+6.0*p.z-TWO_PI*iTime);\n  float offset2 = 0.05;\n  if (sph < offset2) {\n    sph += offset2 * ns;\n  }\n  return sph;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n \tvec2 res = vec2( sdTunnel( pos - vec3( .0 , .0 , -0.4 ) , 0.7 ) , 1. ); \n    \n    return res;\n    \n}\n\nvec3 result;\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if(t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += max(abs(h), INTERSECTION_PRECISION);\n        id = m.y;\n        result += vec3(4.*0.013/(0.5+3.0*abs((ro+rd*t).z-2.0)));\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    result = vec3(0.);\n    vec3 color = vec3(0.,0.,0.);\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(0,0)))/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( ro , rd  );\n    \n    fragColor = vec4(result,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlt3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 389, 389, 562], [669, 692, 717, 970, 1887], [1889, 1920, 1984, 1984, 2162], [2164, 2258, 2287, 2287, 2330], [2332, 2332, 2363, 2363, 2459], [2492, 2492, 2527, 2527, 2882], [2885, 2969, 2990, 2990, 3100], [3116, 3116, 3164, 3164, 3684], [3687, 3687, 3744, 3744, 4192]], "test": "ok"}
{"id": "tltGzr", "name": "[delete]2D bounding volume", "author": "delete", "description": "bounding volume,box,sphere,ellipsoid", "tags": ["boundingvolume", "pca"], "likes": 9, "viewed": 163, "published": "Public", "date": "1575635913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P_COUNT 10\n\nvec2 points1[P_COUNT];\nfloat hash11( float n )\n{\n    return fract(sin(n*13.)*43758.5453);\n}\nvec2 hash12(float n){\n    return fract(vec2(sin(n*17.),cos(n*13.))*43758.5453);\n}\n\nvec3 checkboard(vec2 uv){\n\tuv=floor(uv);\n    return vec3(mod(uv.x+uv.y,2.))-0.8;\n}\n\nfloat lineSDF(vec2 p,vec2 p1,vec2 p2){\n\tvec2 v1=p-p1;\n    vec2 v2=p2-p1;\n    vec2 projv1ATv2=dot(v1,v2)*v2/dot(v2,v2);\n    vec2 k=projv1ATv2/v2;\n    \n    if(k.x<0.||k.y<0.)return length(v1);\n    if(k.x>1.||k.y>1.)return length(p-p2);\n\tfloat d=length(v1-projv1ATv2);\n    return d;\n}\nfloat circleSDF(vec2 p,vec2 sc,float r){\n\treturn length(p-sc)-r;\n}\n\nfloat ellipsoidSDF(vec2 p,vec2 sc,mat2 r){\n    mat2 M=inverse(r);\n    p=M*p;\n    vec2 r2=vec2(length(r[0]),length(r[1]));\n\treturn length((p-M*sc))-1.;\n}\n\nfloat unionSDF(float d1,float d2){return min(d1,d2);}\n\nvec2 bmin=vec2(0.),bmax=vec2(0.);\nfloat boxAABB(vec2 xy){\n    float d=lineSDF(xy,bmin,vec2(bmax.x,bmin.y));\n\td=unionSDF(d,lineSDF(xy,bmin,vec2(bmin.x,bmax.y)));\n    d=unionSDF(d,lineSDF(xy,bmax,vec2(bmin.x,bmax.y)));\n    d=unionSDF(d,lineSDF(xy,bmax,vec2(bmax.x,bmin.y)));\n    return d;\n}\n\nmat2 axis=mat2(0.);\nmat2 ext=mat2(0.);\nvec2 sc=vec2(0.);\nbool naturalAxis(vec2 pos[P_COUNT]){\n\tvec2 mid=vec2(0.);\n    for(int i=0;i<P_COUNT;++i)mid+=pos[i];\n\tmid/=float(P_COUNT);\n\tmat2 M=mat2(0.);\n    for(int i=0;i<P_COUNT;++i){\n        vec2 v=pos[i]-mid;\n    \tM+=outerProduct(v,v);\n   \t}\n    M/=float(P_COUNT);\n    float b=-(M[0][0]+M[1][1])/2.;\n    float c=M[0][0]*M[1][1]-M[0][1]*M[1][0];\n    if(M[0][1]*M[1][0]==0.)return false;\n    float delta=b*b-c;\n    if(delta<=0.)return false;\n    delta=sqrt(delta);\n    vec2 lambda=vec2(delta,-delta)-b;\n\tmat2 M1=M-lambda[0]*mat2(1.,0.,0.,1.);\n    \n    axis[0]=normalize(vec2(1.,-M1[0][0]/M1[0][1]));\n    M1=M-lambda[1]*mat2(1.,0.,0.,1.);\n    axis[1]=normalize(vec2(1.,-M1[0][0]/M1[0][1]));\n    ext[0]=vec2(dot(axis[0],pos[0]));\n    ext[1]=vec2(dot(axis[1],pos[0]));\n    for(int i=1;i<P_COUNT;++i){\n    \tvec2 aa=vec2(dot(axis[0],pos[i]),dot(axis[1],pos[i]));\n        ext=mat2(min(ext[0].x,aa.x),\n        max(ext[0].y,aa.x),\n        min(ext[1].x,aa.y),\n        max(ext[1].y,aa.y));\n    }\n    sc=((ext[0].x+ext[0].y)*axis[0]+(ext[1].x+ext[1].y)*axis[1])/2.;\n    return true;\n}\n\n\nfloat boundingBox(vec2 xy){\t\n    mat4x2 pp;\n    pp[0]=axis[0]*ext[0].x+axis[1]*ext[1].x;\n    pp[1]=axis[0]*ext[0].y+axis[1]*ext[1].x;\n    pp[2]=axis[0]*ext[0].y+axis[1]*ext[1].y;\n    pp[3]=axis[0]*ext[0].x+axis[1]*ext[1].y;\n    \n    float d=lineSDF(xy,pp[0],pp[1]);\n    d=unionSDF(d,lineSDF(xy,pp[1],pp[2]));\n    d=unionSDF(d,lineSDF(xy,pp[2],pp[3]));\n    d=unionSDF(d,lineSDF(xy,pp[3],pp[0]));\n    \n    #if 0\n    vec2 lmin,lmax;\n    lmin=pp[0];lmax=lmin;\n    for(int i=1;i<4;++i){\n    \tlmin=min(pp[i],lmin);\n        lmax=max(pp[i],lmax);\n    }\n    \n    d=unionSDF(d,lineSDF(xy,lmin,vec2(lmax.x,lmin.y)));\n    d=unionSDF(d,lineSDF(xy,lmin,vec2(lmin.x,lmax.y)));\n    d=unionSDF(d,lineSDF(xy,lmax,vec2(lmin.x,lmax.y)));\n    d=unionSDF(d,lineSDF(xy,lmax,vec2(lmax.x,lmin.y)));\n    #endif\n    \n    return d;\n}\n\nfloat boundingSphere(vec2 xy,vec2 pos[P_COUNT]){\n\tvec2 pk,pl;\n    pk=axis[0]*ext[0][0];\n    pl=axis[0]*ext[0][1];\n\tfloat r=length((pk-pl)/2.);\n    vec2 sc2=sc;\n    for(int i=0;i<P_COUNT;++i){\n        if(length(pos[i]-sc2)>r){\n        \tsc2=(pos[i]+sc2+normalize(sc2-pos[i])*r)/2.;\n            r=length(sc2-pos[i]);\n        }\n    }\n    float d=circleSDF(xy,sc2,r);\n    return d;\n}\nfloat boundingEllipsoid(vec2 xy,vec2 pos[P_COUNT]){\n    mat2 M=axis*mat2(1./(ext[0][1]-ext[0][0]),0.,0.,1./(ext[1][1]-ext[1][0]))*transpose(axis);\n    for(int i=0;i<P_COUNT;++i)pos[i]=M*pos[i];\n    float r=.5;\n    vec2 sc2=M*sc;\n    for(int i=0;i<P_COUNT;++i){\n        if(length(pos[i]-sc2)>r){\n        \tsc2=(pos[i]+sc2+normalize(sc2-pos[i])*r)/2.;\n            r=length(sc2-pos[i]);\n        }\n    }\n    mat2 invM=inverse(M);\n    sc2=invM*sc2;\n    mat2 r2=invM*r;\n    float d=min(ellipsoidSDF(xy,sc2,r2),1.);\n    return d;\n}\n\nfloat pointSDF(vec2 uv,vec2 pos[P_COUNT]){\n\tfloat d=100.;\n    for(int i=0;i<P_COUNT;++i){\n    \td=unionSDF(d,length(uv-pos[i]));\n    }\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y*=iResolution.y/iResolution.x;\n    uv*=7.;\n    uv.x-=1.5;\n    uv.y-=1.0;\n    \n    for(int i=1;i<=P_COUNT;++i){\n        float t=iTime*hash11(float(i))*3.;\n    \tint a=int(floor(t))+1;\n        float b=fract(t);\n    \tpoints1[i-1]=mix(hash12(float(i*a)),hash12(float(i*(a+1))),b)*(hash12(float(i))-0.5)*3.+vec2(1.5,1.);\n        if(i==1){bmin=points1[0];bmax=bmin;continue;}\n        bmax=max(bmax,points1[i-1]);\n        bmin=min(bmin,points1[i-1]);\n    }\n\tif(!naturalAxis(points1))return;\n    //\n\tvec3 bgColor=checkboard(uv);\n    if(abs(uv.x)<.02||abs(uv.y)<.02)bgColor=vec3(0.0,0.3,.1);\n    vec3 col=bgColor;\n    \n    //plot\n    float f1=abs(boxAABB(uv));\n   \tcol=mix(vec3(1.),col,smoothstep(0.01,0.02,f1));\n    float f2=abs(boundingBox(uv));\n   \tcol=mix(vec3(1.,0.,0.),col,smoothstep(0.01,0.02,f2));\n    float f3=abs(boundingSphere(uv,points1));\n   \tcol=mix(vec3(0.,1.0,0.),col,smoothstep(0.01,0.02,f3));\n    float f4=abs(boundingEllipsoid(uv,points1));\n   \tcol=mix(vec3(0.,.0,1.),col,smoothstep(0.01,0.02,f4));\n    //show points\n    float d=smoothstep(0.03,0.04,pointSDF(uv,points1));\n    col=mix(vec3(1.0,0.7,0.0),col,d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 68, 68, 111], [112, 112, 133, 133, 193], [195, 195, 220, 220, 277], [279, 279, 317, 317, 560], [561, 561, 601, 601, 627], [629, 629, 671, 671, 781], [783, 783, 817, 817, 836], [872, 872, 895, 895, 1126], [1185, 1185, 1221, 1221, 2246], [2249, 2249, 2276, 2276, 3054], [3056, 3056, 3104, 3104, 3434], [3435, 3435, 3486, 3486, 3958], [3960, 3960, 4002, 4002, 4106], [4108, 4108, 4165, 4215, 5446]], "test": "error"}
{"id": "tscSWf", "name": "shadetober #29 (injured)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["fbm", "domainwarping", "inktober", "shadertober", "shadetober", "inktober2019"], "likes": 6, "viewed": 289, "published": "Public API", "date": "1577265539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// mostly warping from https://www.iquilezles.org/www/articles/warp/warp.htm\n\n// iq noise fn\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat fbm( in vec2 x, in float hurst)\n{    \n    float gain = exp2(-hurst);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < 4; i++ )\n    {\n        t += a * noise((f*x).xyy);\n        f *= 2.0;\n        a *= gain;\n    }\n    return t;\n}\n\nvoid fbms(in vec2 uv, out vec3 color) {\n    float h = 1.;\n    vec2 t1 = vec2(fbm(uv, h), fbm(uv + vec2(4.3,-2.1)*sin(iTime * .02), h));\n    vec2 t2 = vec2(fbm(uv + 2.*t1 + vec2(-1.9,3.9)*cos(iTime * .07), h),\n                   fbm(uv + 2.*t1 + vec2(2.2,3.1)*sin(iTime * .05), h));\n    float t3 = fbm(uv + 2.*t2 + vec2(5.6,1.4)*cos(iTime * .06), h);\n    color = vec3(t3, t3 - 1., t3 - 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.;\n\tuv += 10.;\n    vec3 c;\n    fbms(uv, c);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 93, 114, 114, 364], [366, 366, 405, 405, 628], [630, 630, 669, 669, 1021], [1023, 1023, 1078, 1078, 1229]], "test": "timeout"}
{"id": "tsdGWB", "name": "Shapes without conditionals", "author": "sux2bthatguy", "description": "Shapes without conditionals", "tags": ["shapes"], "likes": 6, "viewed": 87, "published": "Public", "date": "1575677863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 center = vec2(.5,.5);\nfloat radius = .25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    center.y *= iResolution.y/iResolution.x;\n    \n    vec3 col = .5 + .5*abs(tan(iTime+uv.xyx+vec3(0,2,4)));\n    vec3 col2 = .5 + .5*abs(cos(iTime+uv.xyx+vec3(0,2,4)));\n    \n    float onOff = 1.0 - smoothstep(radius, radius +.1, length(uv-center));\n    \n    col = col * (onOff) + col2 * (1.0 - onOff);\n\t\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 155, 598]], "test": "ok"}
{"id": "tsGSDc", "name": "Wobble Chess", "author": "g4b0r", "description": "I modeled the \"Wobble Chess Set\" by Umbra. \nProduct Link: https://www.umbra.com/products/wobble-chess\nImage: https://images-na.ssl-images-amazon.com/images/I/71bGxoCicpL._SL1500_.jpg", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives", "chess"], "likes": 14, "viewed": 363, "published": "Public API", "date": "1575778434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// The MIT License\n// Copyright Â© 2019 Gabor Nagy\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// I modeled the \"Wobble Chess Set\" by Umbra. \n// Product Link: https://www.umbra.com/products/wobble-chess\n// Image: https://images-na.ssl-images-amazon.com/images/I/71bGxoCicpL._SL1500_.jpg\n//\n// I own this physical chess board, and I wanted to see if I could render\n// it real-time with ray-marching techniques.\n//\n// On my Mac Mini and a Radion RX Vega 56 eGPU, I'm getting 60fps at 800x450.\n// Each chess piece is only placed on the map one time, and using repetition\n// and symetry to get the full chess set on the board. Without that trick\n// I was not able to get real-time performnce.\n//\n// Credits:\n// Based on concepts and code written by Inigo Quilez. Thanks for all of the\n// articles and code you have made public!\n//\n// 3D wood texture by Otavio Good. \n// Taken from: https://www.shadertoy.com/view/ldscDM\n//\n\n#define AA 1\n#define skyColor vec3(.7,.7,.9)\n\n//-------------------- Start: wood texture\nfloat repramp(in float x) {\n\treturn pow(sin(x)*0.5+0.5, 8.0) + cos(x)*0.7 + 0.7;\n}\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 3D, Seed 1, Waves 128, Octaves 7, Smooth 1\nfloat NoiseGen(in vec3 p) {\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec3(-1.316, 0.918, 1.398))) * 0.0783275458;\n    wave1 += sin(dot(p, vec3(0.295, -0.176, 2.167))) * 0.0739931495;\n    wave0 += sin(dot(p, vec3(-0.926, 1.445, 1.429))) * 0.0716716966;\n    wave1 += sin(dot(p, vec3(-1.878, -0.174, 1.258))) * 0.0697839187;\n    wave0 += sin(dot(p, vec3(-1.995, 0.661, -0.908))) * 0.0685409863;\n    wave1 += sin(dot(p, vec3(-1.770, 1.350, -0.905))) * 0.0630152419;\n    wave0 += sin(dot(p, vec3(2.116, -0.021, 1.161))) * 0.0625361712;\n    wave1 += sin(dot(p, vec3(0.405, -1.712, -1.855))) * 0.0567751048;\n    wave0 += sin(dot(p, vec3(1.346, 0.945, 1.999))) * 0.0556465603;\n    wave1 += sin(dot(p, vec3(-0.397, -0.573, 2.495))) * 0.0555747667;\n    wave0 += sin(dot(p, vec3(0.103, -2.457, -1.144))) * 0.0516322279;\n    wave1 += sin(dot(p, vec3(-0.483, -1.323, 2.330))) * 0.0513093320;\n    wave0 += sin(dot(p, vec3(-1.715, -1.810, -1.164))) * 0.0504567036;\n    wave1 += sin(dot(p, vec3(2.529, 0.479, 1.011))) * 0.0500811899;\n    wave0 += sin(dot(p, vec3(-1.643, -1.814, -1.437))) * 0.0480875812;\n    wave1 += sin(dot(p, vec3(1.495, -1.905, -1.648))) * 0.0458268348;\n    wave0 += sin(dot(p, vec3(-1.874, 1.559, 1.762))) * 0.0440084357;\n    wave1 += sin(dot(p, vec3(1.068, -2.090, 2.081))) * 0.0413624154;\n    wave0 += sin(dot(p, vec3(-0.647, -2.197, -2.237))) * 0.0401592830;\n    wave1 += sin(dot(p, vec3(-2.146, -2.171, -1.135))) * 0.0391682940;\n    wave0 += sin(dot(p, vec3(2.538, -1.854, -1.604))) * 0.0349588163;\n    wave1 += sin(dot(p, vec3(1.687, 2.191, -2.270))) * 0.0342888847;\n    wave0 += sin(dot(p, vec3(0.205, 2.617, -2.481))) * 0.0338465332;\n    wave1 += sin(dot(p, vec3(3.297, -0.440, -2.317))) * 0.0289423448;\n    wave0 += sin(dot(p, vec3(1.068, -1.944, 3.432))) * 0.0286404261;\n    wave1 += sin(dot(p, vec3(-3.681, 1.068, 1.789))) * 0.0273625684;\n    wave0 += sin(dot(p, vec3(3.116, 2.631, -1.658))) * 0.0259772492;\n    wave1 += sin(dot(p, vec3(-1.992, -2.902, -2.954))) * 0.0245830241;\n    wave0 += sin(dot(p, vec3(-2.409, -2.374, 3.116))) * 0.0245592756;\n    wave1 += sin(dot(p, vec3(0.790, 1.768, 4.196))) * 0.0244078334;\n    wave0 += sin(dot(p, vec3(-3.289, 1.007, 3.148))) * 0.0241328015;\n    wave1 += sin(dot(p, vec3(3.421, -2.663, 3.262))) * 0.0199736126;\n    wave0 += sin(dot(p, vec3(3.062, 2.621, 3.649))) * 0.0199230290;\n    wave1 += sin(dot(p, vec3(4.422, -2.206, 2.621))) * 0.0192399437;\n    wave0 += sin(dot(p, vec3(2.714, 3.022, 4.200))) * 0.0182510631;\n    wave1 += sin(dot(p, vec3(-0.451, 4.143, -4.142))) * 0.0181293526;\n    wave0 += sin(dot(p, vec3(-5.838, -0.360, -1.536))) * 0.0175114826;\n    wave1 += sin(dot(p, vec3(-0.278, -4.565, 4.149))) * 0.0170799341;\n    wave0 += sin(dot(p, vec3(-5.893, -0.163, -2.141))) * 0.0167655258;\n    wave1 += sin(dot(p, vec3(4.855, -4.153, 0.606))) * 0.0163155335;\n    wave0 += sin(dot(p, vec3(4.498, 0.987, -4.488))) * 0.0162770287;\n    wave1 += sin(dot(p, vec3(-1.463, 5.321, -3.315))) * 0.0162569125;\n    wave0 += sin(dot(p, vec3(-1.862, 4.386, 4.749))) * 0.0154338176;\n    wave1 += sin(dot(p, vec3(0.563, 3.616, -5.751))) * 0.0151952226;\n    wave0 += sin(dot(p, vec3(-0.126, 2.569, -6.349))) * 0.0151089405;\n    wave1 += sin(dot(p, vec3(-5.094, 4.759, 0.186))) * 0.0147947096;\n    wave0 += sin(dot(p, vec3(1.319, 5.713, 3.845))) * 0.0147035221;\n    wave1 += sin(dot(p, vec3(7.141, -0.327, 1.420))) * 0.0140573910;\n    wave0 += sin(dot(p, vec3(3.888, 6.543, 0.547))) * 0.0133309850;\n    wave1 += sin(dot(p, vec3(-1.898, -3.563, -6.483))) * 0.0133171360;\n    wave0 += sin(dot(p, vec3(1.719, 7.769, 0.340))) * 0.0126913718;\n    wave1 += sin(dot(p, vec3(-2.210, -7.836, 0.102))) * 0.0123746071;\n    wave0 += sin(dot(p, vec3(6.248, -5.451, 1.866))) * 0.0117861898;\n    wave1 += sin(dot(p, vec3(1.627, -7.066, -4.732))) * 0.0115417453;\n    wave0 += sin(dot(p, vec3(4.099, -7.704, 1.474))) * 0.0112591564;\n    wave1 += sin(dot(p, vec3(7.357, 3.788, 3.204))) * 0.0112252325;\n    wave0 += sin(dot(p, vec3(-2.797, 6.208, 6.253))) * 0.0107206906;\n    wave1 += sin(dot(p, vec3(6.130, -5.335, -4.650))) * 0.0105693992;\n    wave0 += sin(dot(p, vec3(5.276, -5.576, -5.438))) * 0.0105139072;\n    wave1 += sin(dot(p, vec3(9.148, 2.530, -0.383))) * 0.0103996383;\n    wave0 += sin(dot(p, vec3(3.894, 2.559, 8.357))) * 0.0103161113;\n    wave1 += sin(dot(p, vec3(-6.604, 8.024, -0.289))) * 0.0094066875;\n    wave0 += sin(dot(p, vec3(-5.925, 6.505, -6.403))) * 0.0089444733;\n    wave1 += sin(dot(p, vec3(9.085, 10.331, -0.451))) * 0.0069245599;\n    wave0 += sin(dot(p, vec3(-8.228, 6.323, -9.900))) * 0.0066251015;\n    wave1 += sin(dot(p, vec3(10.029, -3.802, 12.151))) * 0.0058122824;\n    wave0 += sin(dot(p, vec3(-10.151, -6.513, -11.063))) * 0.0057522358;\n    wave1 += sin(dot(p, vec3(-1.773, -16.284, 2.828))) * 0.0056578101;\n    wave0 += sin(dot(p, vec3(11.081, 8.687, -9.852))) * 0.0054614334;\n    wave1 += sin(dot(p, vec3(-3.941, -4.386, 16.191))) * 0.0054454253;\n    wave0 += sin(dot(p, vec3(-6.742, 2.133, -17.268))) * 0.0050050132;\n    wave1 += sin(dot(p, vec3(-10.743, 5.698, 14.975))) * 0.0048323955;\n    wave0 += sin(dot(p, vec3(-9.603, 12.472, 14.542))) * 0.0043264378;\n    wave1 += sin(dot(p, vec3(13.515, 14.345, 8.481))) * 0.0043208884;\n    wave0 += sin(dot(p, vec3(-10.330, 16.209, -9.742))) * 0.0043013736;\n    wave1 += sin(dot(p, vec3(-8.580, -6.628, 19.191))) * 0.0042005922;\n    wave0 += sin(dot(p, vec3(-17.154, 10.620, 11.828))) * 0.0039482427;\n    wave1 += sin(dot(p, vec3(16.330, 14.123, -10.420))) * 0.0038474789;\n    wave0 += sin(dot(p, vec3(-21.275, 10.768, -3.252))) * 0.0038320501;\n    wave1 += sin(dot(p, vec3(1.744, 7.922, 23.152))) * 0.0037560829;\n    wave0 += sin(dot(p, vec3(-3.895, 21.321, 12.006))) * 0.0037173885;\n    wave1 += sin(dot(p, vec3(-22.705, 2.543, 10.695))) * 0.0036484394;\n    wave0 += sin(dot(p, vec3(-13.053, -16.634, -13.993))) * 0.0036291121;\n    wave1 += sin(dot(p, vec3(22.697, -11.230, 1.417))) * 0.0036280459;\n    wave0 += sin(dot(p, vec3(20.646, 14.602, 3.400))) * 0.0036055008;\n    wave1 += sin(dot(p, vec3(5.824, -8.717, -23.680))) * 0.0035501527;\n    wave0 += sin(dot(p, vec3(6.691, 15.499, 20.079))) * 0.0035029508;\n    wave1 += sin(dot(p, vec3(9.926, -22.778, 9.144))) * 0.0034694278;\n    wave0 += sin(dot(p, vec3(-9.552, -27.491, 2.197))) * 0.0031359281;\n    wave1 += sin(dot(p, vec3(21.071, -17.991, -11.566))) * 0.0030453280;\n    wave0 += sin(dot(p, vec3(9.780, 1.783, 28.536))) * 0.0030251754;\n    wave1 += sin(dot(p, vec3(8.738, -18.373, 22.725))) * 0.0029960272;\n    wave0 += sin(dot(p, vec3(14.105, 25.703, -8.834))) * 0.0029840058;\n    wave1 += sin(dot(p, vec3(-24.926, -17.766, -4.740))) * 0.0029487709;\n    wave0 += sin(dot(p, vec3(1.060, -1.570, 32.535))) * 0.0027980099;\n    wave1 += sin(dot(p, vec3(-24.532, -19.629, -16.759))) * 0.0025538949;\n    wave0 += sin(dot(p, vec3(28.772, -21.183, -9.935))) * 0.0024494819;\n    wave1 += sin(dot(p, vec3(-28.413, 22.959, 8.338))) * 0.0024236674;\n    wave0 += sin(dot(p, vec3(-27.664, 22.197, 13.301))) * 0.0023965996;\n    wave1 += sin(dot(p, vec3(-27.421, 20.643, 18.713))) * 0.0023203498;\n    wave0 += sin(dot(p, vec3(18.961, -7.189, 35.907))) * 0.0021967023;\n    wave1 += sin(dot(p, vec3(-23.949, 4.885, 33.762))) * 0.0021727461;\n    wave0 += sin(dot(p, vec3(35.305, 8.594, 20.564))) * 0.0021689816;\n    wave1 += sin(dot(p, vec3(30.364, -11.608, -27.199))) * 0.0021357139;\n    wave0 += sin(dot(p, vec3(34.268, 26.742, 0.958))) * 0.0020807976;\n    wave1 += sin(dot(p, vec3(-26.376, -17.313, -32.023))) * 0.0020108850;\n    wave0 += sin(dot(p, vec3(31.860, -32.181, -2.834))) * 0.0019919601;\n    wave1 += sin(dot(p, vec3(25.590, 32.340, 21.381))) * 0.0019446179;\n    wave0 += sin(dot(p, vec3(-17.771, -23.941, 37.324))) * 0.0018898258;\n    wave1 += sin(dot(p, vec3(-38.699, 19.953, -22.675))) * 0.0018379538;\n    wave0 += sin(dot(p, vec3(-46.284, 11.672, -15.411))) * 0.0017980056;\n    wave1 += sin(dot(p, vec3(-32.023, -43.976, -7.378))) * 0.0016399251;\n    wave0 += sin(dot(p, vec3(-42.390, -21.165, -31.889))) * 0.0015752176;\n    wave1 += sin(dot(p, vec3(-18.949, -40.461, 39.107))) * 0.0015141244;\n    wave0 += sin(dot(p, vec3(-21.507, -5.939, -58.531))) * 0.0014339601;\n    wave1 += sin(dot(p, vec3(-51.745, -43.821, 9.651))) * 0.0013096306;\n    wave0 += sin(dot(p, vec3(39.239, 25.971, -52.615))) * 0.0012701774;\n    wave1 += sin(dot(p, vec3(-49.669, -35.051, -36.306))) * 0.0012661695;\n    wave0 += sin(dot(p, vec3(-49.996, 35.309, 38.460))) * 0.0012398870;\n    wave1 += sin(dot(p, vec3(27.000, -65.904, -36.267))) * 0.0011199347;\n    wave0 += sin(dot(p, vec3(-52.523, -26.557, 57.693))) * 0.0010856391;\n    wave1 += sin(dot(p, vec3(-42.670, 0.269, -71.125))) * 0.0010786551;\n    wave0 += sin(dot(p, vec3(-9.377, 64.575, -68.151))) * 0.0009468199;\n    wave1 += sin(dot(p, vec3(14.571, -29.160, 106.329))) * 0.0008019719;\n    wave0 += sin(dot(p, vec3(-21.549, 103.887, 36.882))) * 0.0007939609;\n    wave1 += sin(dot(p, vec3(-42.781, 110.966, -9.070))) * 0.0007473261;\n    wave0 += sin(dot(p, vec3(-112.686, 18.296, -37.920))) * 0.0007409259;\n    wave1 += sin(dot(p, vec3(71.493, 33.838, -96.931))) * 0.0007121903;\n    return wave0+wave1;\n}\n\nvec3 woodTexture(in vec3 p) {\n\tfloat rings = repramp(length(p.xz + vec2(NoiseGen(p*vec3(8.0, 1.5, 8.0)), \n                                             NoiseGen(-p*vec3(8.0, 1.5, 8.0)+4.5678))*0.05)*64.0) / 1.8;\n\trings -= NoiseGen(p *1.0)*0.75;\n\tvec3 te = mix(vec3(0.3, 0.19, 0.075)*0.95, vec3(1.0, 0.73, 0.326)*0.4, rings)*1.5;\n\tte = max(vec3(0.0), te);\n\tfloat rough = (NoiseGen(p*64.0*vec3(1.0, 0.2, 1.0))*0.1+0.9);\n\tte *= rough;\n    te = clamp(te, 0., 1.);\n    return te;\n}\n//-------------------- End: wood texture\n\nvoid rotate(inout vec2 point, float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    float px = point.x * c - point.y * s;\n    float py = point.x * s + point.y * c;\n    point.x = px;\n    point.y = py;\n}\n\nfloat dot2(in vec3 v )\n{\n    return dot(v,v);\n}\n\n//-------------------- Start: distance functions (primitives)\n// More info by Inigo Quilez:\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane(in vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2(pa*l2 - ba*y);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCylinder(in vec3 p, in vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderH(in vec3 p, in vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//-------------------- End: distance functions (primitives)\n\n// Intersection\nfloat opI(in float d1, in float d2)\n{\n    return max(d2,d1);\n}\n\n// Subtraction\nfloat opS(in float d1, in float d2)\n{\n    return max(-d2,d1);\n}\n\n// Union\nvec2 opU(in vec2 d1, in vec2 d2)\n{\t\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n// Union (float)\nfloat opU(in float d1, in float d2)\n{\t\n    return min(d1,d2);\n}\n\n// Smooth Union\nvec2 opSU(in vec2 d1, in vec2 d2, in float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n\treturn vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y);\n}\n\n// Smooth Union (float)\nfloat opSU(in float d1, in float d2, in float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Repeat with limit\nvec2 opRepLim(in vec2 p, in float s, in vec2 limmin, in vec2 limmax)\n{\n    return p-s*clamp(round(p/s),-limmin,limmax);\n}\n\n//-------------------- Start: Chess Pieces\nvec2 pawn(in int id, in vec3 p)\n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.55, 0.0), 0.55), \n                           sdBox(pos-vec3(0., .55 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.55, 0.0), 0.55), \n                        sdBox(pos-vec3(0., .55 - .5, 0.), vec3(1.,.5,1.))), float(id)+100.0);    \n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 1.55, 0.0), 0.33 ), 4. ), 0.38);\n    \n    return opU(bottom, top);\n}\n\nvec2 bishop(in int id, in vec3 p) \n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.5, 0.0)), vec2(.15, .7)), float(id)+100.0), 0.6);\n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 2.5, 0.0), 0.4 ), float(id)+100.0), 0.3);\n    top.x = opS(top.x, sdBox(pos-vec3(0., 2.8, 0.), vec3(.05,0.2,1.05)));\n    \n    return opU(bottom, top);\n}\n\nvec2 king(in int id, in vec3 p)\n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.7, 0.0)), vec2(.15, 1.4)), float(id)+100.0), 0.6);\n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 2.9, 0.0), 0.4 ), float(id)+100.0), 0.3);\n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 2.0, 0.0)), vec2(.3, .04)), float(id)+100.0), 0.12);\n    \n    vec2 hat = vec2(sdBox(pos-vec3(0.,3.4,0.), vec3(.05,.2,.05)), 10.0);\n    hat = opU(hat, vec2(sdBox(pos-vec3(0.,3.45,0.), vec3(.18,.05,.05)), 10.0));\n    \n    return opU(opU(bottom, top), hat);\n}\n\nvec2 queen(in int id, in vec3 p) \n{   \n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.7, 0.0)), vec2(.15, 1.4)), float(id)+100.0), 0.6);\n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 2.9, 0.0), 0.4 ), float(id)+100.0), 0.3);\n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 2.0, 0.0)), vec2(.3, .04)), float(id)+100.0), 0.12);\n    \n    vec2 hat = vec2(sdSphere(pos-vec3(0.,3.35,0.), .1), 10.0);\n    \n    return opU(opU(bottom, top), hat);\n}\n\nvec2 rook(in int id, in vec3 p)\n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.2, 0.0)), vec2(.285, .7)), float(id)+100.0), 0.3);\n    top = opSU(top, vec2(sdCylinder(pos-vec3( 0.0, 2.1, 0.0), vec2(0.45,0.15)), float(id)+100.0), 0.3);\n    top.x = opS(top.x, sdBox(pos-vec3(0., 2.3, 0.), vec3(.05,0.2,1.05)));\n    top.x = opS(top.x, sdBox(pos-vec3(0., 2.3, 0.), vec3(1.05,0.2,.05)));\n    \n    return opU(bottom, top);\n}\n\nvec2 knight(in int id, in vec3 p) \n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opU(top, vec2(opS(opI(sdBox(pos-vec3(0., 1.7, 0.), vec3(.7,1.,.15)),\n                                sdCylinderH(pos-vec3(3.005-.68, .7, 0.), vec2(3.01,.15))),\n                                sdCylinderH(pos-vec3(3.0-.20, .7, 0.), vec2(3.0,.25))), float(id)+100.0));\n    \n    vec3 boxPos = pos;\n    rotate(boxPos.xy, 3.15/5.9);\n    top.x = opU(top.x, sdBox(boxPos - vec3(-0.9,1.7,0.0), vec3(.4,.25,.15)));\n    top.x = opS(top.x, sdBox(boxPos - vec3(-1.5,2.82,0.0), vec3(1.1,1.0,.35)));\n        \n    return opU(bottom, top);\n}\n//-------------------- End: Chess Pieces\n\nvec2 map(in vec3 pos)\n{\n    // Board\n    vec2 res = vec2(sdBox(pos - vec3(-0.,-.5,-0.), vec3(16., .45, 16.)), 11.0);\n    vec2 board = vec2(sdBox(pos - vec3(-0.05,.3,-0.05), vec3(7.9, .3, 7.9)), 1.0);     \n    res = opU(res, board);\n    \n    // Cut repeated spheres\n    vec3 q = pos - vec3(1.,0.,1.);\n    q.xz = opRepLim( q.xz, 2., vec2(4.0,4.0), vec2(3.0,3.0));\n    res.x = opS(res.x, sdSphere(q - vec3(0., 5.4, 0.), 5.));   \n    \n    // Add chess pieces\n    // We can place one of each piece, and the rest is symmetry.\n    float bottom = 0.325;\n    \n    // Unique id for each chess piece\n    int id = int(clamp(pos.z + 8.,0.,15.) / 2.0)*8 + int(clamp(pos.x + 8.,0.,15.) / 2.0);\n\n    vec3 mirrorZPos = pos;\n    mirrorZPos.z = abs(mirrorZPos.z);\n    \n    vec3 mirrorZXPos = mirrorZPos;\n    mirrorZXPos.x = abs(mirrorZXPos.x);\n    \n    vec3 pawnPos = mirrorZPos - vec3(1.,0.,5.);\n    pawnPos.xz = opRepLim( pawnPos.xz, 2., vec2(4.0,0.0), vec2(3.0,0.0));\n\tres = opU(res, pawn(id, pawnPos - vec3(0., bottom, 0.)));\n\n    vec3 knightPos = mirrorZPos - vec3(5.,0.,7.);\n    knightPos.xz = opRepLim( knightPos.xz, 10., vec2(1.0,0.0), vec2(0.0,0.0));\n\tres = opU(res, knight(id, knightPos - vec3(0., bottom, 0.)));    \n\n\tres = opU(res, rook(id, mirrorZXPos - vec3(7., bottom, 7.)));    \n\tres = opU(res, bishop(id, mirrorZXPos - vec3(3., bottom, 7.)));    \n    res = opU(res, queen(id, mirrorZPos - vec3(1., bottom, 7.)));\n    res = opU(res, king(id, mirrorZPos - vec3(-1., bottom, 7.)));\n    \n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = .05;\n    float tmax = 100.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<70; i++ )\n    {\n\t    float precis = 0.0001*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    \n    float t = .2;\n    for( int i=0; i<70; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)/t );\n        if( res<0.001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec4 colorForMat(in float m, in vec3 pos, in vec3 nor) \n{\n\tvec3 col = vec3(0.);\n    float mirror = 0.;\n    \n    if( m<1.5 )\n    {    \n        if (nor.y > 0.5) {\n            col = (mod(pos.x, 4.0)>2.)!=(mod(pos.z, 4.0)>2.) ? .01+texture(iChannel0,pos.zx*1.5).xyz*.15 : .3+texture(iChannel0,pos.zx*0.5).xyz*.7*vec3(.7,1.,1.);\n        } else if (abs(nor.x) > 0.5) {\n            col = .01+texture(iChannel0,pos.zy*0.5).xyz*.15;\n        } else {\n\t\t\tcol = .01+texture(iChannel0,pos.xy*0.5).xyz*.15;\n        }\n  \t} \n    else if ( m==10.0 ) \n    {\n        col = vec3(0.01);\n        mirror = 0.9;\n    }\n    else if ( m==11.0 )\n    {\n        col = vec3(0.4);\n        mirror = 0.5;\n        col = (0.5 + texture(iChannel1,pos.xz*.05).xyz * 0.5) * .6;\n    }\n    else if ( m >= 100.0 ) \n    {\n        int id = int(m - 100.0);\n        vec3 te = woodTexture(pos.xyz*0.75);\n        \n        if (id >= 32) {\n            col = 0.01 + te*0.15*vec3(1.3,1.,1.);\n        } else {\n        \tcol = 0.2 + te*0.8;\n        }\n    }\n    \n    return vec4(clamp(col,0.0,1.0), mirror);\n}\n\nvec3 lighting(in vec3 pos, in vec3 nor, in vec3 rd, in vec3 ref, out float spe) \n{\n\tfloat occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.1) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    dif *= calcShadow(pos, lig, 50.);\n\n    spe = pow(clamp(dot(nor, hal), 0.0, 1.0),16.0)*\n        dif *\n        (0.04 + 0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0), 5.0));\n\n    vec3 lin = vec3(0.0);\n\n\tlin += 3.80*dif*vec3(1.30,1.00,0.70);\n\tlin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n\tlin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n\tlin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;    \n    lin *= 0.30;\n\n    return lin;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{     \n\tvec3 col = vec3(0.0);\n\tfloat atten = 1.0;\n    \n\tfor( int k=0; k<2; k++ )\n\t{\n    \tvec2 res = castRay(ro,rd);\n    \tfloat t = res.x;\n\t\tfloat m = res.y;\n                \n        if( m>-0.5 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos );   \n            vec3 ref = reflect( rd, nor );\n\n            vec4 material = colorForMat(m, pos, nor);\n\n            float spe = 0.;\n            vec3 lin = lighting(pos, nor, rd, ref, spe);\n\n            vec3 c = material.rgb*lin.xyz;       \n            c += 9.0*spe*vec3(1.00,0.90,0.70);\n\n            col += c * atten;\n\n            atten *= material.w;\n            ro = pos + 0.001*nor;\n            rd = ref;\n        } else if (t > 1.) {\n            col += skyColor * atten;\n            break;\n        }\n    \n\t\tif (atten == 0.0) break;\n    }\n\treturn clamp(col,0.0,1.0);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 rayOrigin(in vec2 mo, in float time) {\n    vec3 ro = vec3(18.*cos(0.2*time), 8.+mo.y*6.0, 18.*sin(0.2*time));\n    return ro;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 2.*iTime + 23.41;\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        vec3 ro = rayOrigin(mo, time);\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n        vec3 col = render(ro, rd);\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    tot = pow(tot, vec3(0.45));\n    fragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSDc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1952, 1995, 2022, 2022, 2077], [2079, 2196, 2223, 2223, 11332], [11334, 11334, 11363, 11363, 11809], [11852, 11852, 11894, 11894, 12064], [12066, 12066, 12090, 12090, 12113], [12282, 12282, 12308, 12308, 12323], [12325, 12325, 12364, 12364, 12390], [12392, 12392, 12427, 12427, 12518], [12520, 12520, 12598, 12662, 13247], [13249, 13249, 13289, 13289, 13388], [13390, 13390, 13431, 13431, 13530], [13592, 13608, 13645, 13645, 13670], [13672, 13687, 13724, 13724, 13750], [13752, 13761, 13795, 13795, 13832], [13834, 13851, 13888, 13888, 13914], [13916, 13932, 13979, 13979, 14092], [14094, 14118, 14168, 14168, 14261], [14263, 14284, 14354, 14354, 14405], [14407, 14450, 14483, 14483, 14947], [14949, 14949, 14985, 14985, 15632], [15634, 15634, 15667, 15667, 16517], [16519, 16519, 16554, 16554, 17317], [17319, 17319, 17352, 17352, 18087], [18089, 18089, 18125, 18125, 19000], [19043, 19043, 19066, 19079, 20542], [20544, 20544, 20582, 20582, 20910], [20912, 20912, 20963, 20963, 21235], [21237, 21301, 21331, 21331, 21539], [21541, 21541, 21581, 21581, 21894], [21896, 21896, 21953, 21953, 22949], [22951, 22951, 23033, 23033, 23831], [23833, 23833, 23864, 23864, 24712], [24714, 24714, 24767, 24767, 24944], [24946, 24946, 24989, 24989, 25077]], "test": "error"}
{"id": "tsGXR1", "name": "Noobing around with a cat", "author": "justanoob", "description": "A very cool cat for a very cool guy (ï¾Î¦ ï» Î¦ï¾).\n\nSoundtrack: Very Cool People & Ralfs Eilands - Dance Of the Sugar Plum Fairy\n", "tags": ["firstshader"], "likes": 1, "viewed": 52, "published": "Public", "date": "1576613884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur, d);\n    \n    return c;\n}\n\n// line from A to B\nfloat segment(vec2 P, vec2 A, vec2 B, float thickness, float blur) {\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(thickness, blur*thickness, d);\n}\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nfloat polygon(vec2 uv, vec2 coord, int n, float dim, float blur) {\n    uv += coord;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = TWO_PI/float(n);\n    \n    // Shaping function that modulate the distance\n    float d = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return 1.0 - smoothstep(dim, dim+blur, d);\n}\n\nfloat band(float t, float start, float end, float blur) {\n\tfloat step1 = smoothstep(start-blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1*step2;\n}\n\nfloat rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n\tfloat band1 = band(uv.x, left, right, blur);\n    float band2 = band(uv.y, bottom, top, blur);\n    \n    return band1*band2;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5; // -0.5 <--> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    float music = texture(iChannel0, vec2(.0, .0)).x;\n    \n    \n    // head\n    float mask = Circle(uv, vec2(0., -.15), .15, .005);\n    \n    // eyes\n    mask -= Circle(uv, vec2(-.04, -.1), .03*music, .003);\n    mask -= Circle(uv, vec2(.04, -.1), .03*music, .003);\n    \n    //ears\n    mask += polygon(uv, vec2(.05, .015), 3, .025, .004);\n    mask += polygon(uv, vec2(-.05, .015), 3, .025, .004);\n    \n    //nose\n    mask -= segment(uv, vec2(-.02, -.15), vec2(.02, -.18), .004, .5);\n    mask -= segment(uv, vec2(.02, -.15), vec2(-.02, -.18), .004, .5);\n    \n    // tale\n    vec2 tale_uv = uv;\n    tale_uv.x += sin(t+40.*tale_uv.y)*(.015);\n    mask += segment(tale_uv, vec2(0., -.01), vec2(0., .27), .015, .7); \n    //mask += rect(tale_uv, -0.015, 0.015, -0.01, 0.27, 0.003);\n    \n    // end of tale\n    vec2 eot_uv = uv;\n    eot_uv.x += sin(t+150.)*.015;\n    mask += Circle(eot_uv, vec2(0., .27), .03, .004);\n    \n    //body\n    mask += segment(uv, vec2(-0.04, -0.3), vec2(0.04, -0.3), 0.04, 0.9);\n    \n    \n    //legs\n    mask += segment(uv, vec2(-0.069, -0.2), vec2(-0.065, -0.36), 0.013, 0.9);\n    mask += segment(uv, vec2(0.069, -0.2), vec2(0.065, -0.36), 0.013, 0.9);\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(1. - mask),1.0);\n}", "image_inputs": [{"id": "MlBGzR", "previewfilepath": "https://soundcloud.com/verycoolpeople/very-cool-people-ralfs-eilands-dance-of-the-sugar-plum-fairy", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/verycoolpeople/very-cool-people-ralfs-eilands-dance-of-the-sugar-plum-fairy", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 145], [147, 167, 235, 235, 396], [452, 452, 518, 518, 759], [761, 761, 818, 818, 957], [959, 959, 1041, 1041, 1175], [1177, 1177, 1234, 1284, 2678]], "test": "error"}
{"id": "tsj3Dc", "name": "torus_thingy_21", "author": "balkhan", "description": " ", "tags": ["raymarching"], "likes": 4, "viewed": 75, "published": "Public", "date": "1575823284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nfloat\tm_id;\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    m_id = floor((a-an*.5)*count)/count;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n   return dot(p - origin,normal);   \n}\n\nfloat\tscene(vec3 p)\n{  \n    p.z += 0.;\n    float\tvar;\n    float\tmind = 1e5;\n    float\tcage = 1e5;\n    rotate(p.xz, 1.57-.35*iTime );\n    rotate(p.yz, 1.57);\n    vec3 op = p;\n    var  = atan(op.x,op.y);\n    var /= 6.28;\n    var += .5;\n    \n    p = op;\n    vec3 pp = p;\n    vec2 q = vec2(length(pp.xy)-20., pp.z);\n    q = vec2(length(pp.xy)-40., pp.z);\n    rotate(q, iTime*1. + var*2.*6.28+2.*sin(iTime*.25+var*6.28*1.));\n    q.xy = modA(q.xy, 16.);\n    q.x -= 10.;\n    q.x = abs(q.x)-8.;q.x = abs(q.x)-1.;q.x = abs(q.x)-1.;q.x = abs(q.x)-1.;q.x = abs(q.x)-1.;\n    \n    mind = length(q)-0.-var*.25*20.0+1.1\n        -step(var, .11)*3.*(1.65-var*15.)\n        \n        ;\n    pp.y -= 20.;\n    rotate(pp.yz, iTime*-1. +1.05 + -1.0*var*2.*6.28 );\n    pp.yz = modA(pp.yz, 3.);\n    pp.y -=5.;\n    ret_col = vec3(.90, .82, .70);\n    h -= vec3(-1.50,.21250,0.25)*vec3(1.)*.0125/(.0051+.1*mind*mind);\n    h -= vec3(2.7505,-.2505,1.)*vec3(1.)*.0125/(.0125+mind*mind);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.5;\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max(abs(p.z)+.5*abs(p.x), ret);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsj3Dc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[617, 617, 660, 660, 1035], [1121, 1121, 1154, 1154, 1326], [1351, 1351, 1398, 1398, 1438], [1440, 1440, 1461, 1461, 2414], [2416, 2416, 2448, 2448, 2830], [2846, 2846, 2870, 2870, 2967], [2969, 2969, 2993, 2993, 3127], [3129, 3129, 3169, 3169, 3244], [3246, 3246, 3274, 3274, 3382], [3384, 3384, 3406, 3406, 3612], [3614, 3614, 3664, 3664, 3927]], "test": "error"}
{"id": "tsVSW3", "name": "Trux in Space", "author": "dr2", "description": "What to do with the excess production... (mouseable)", "tags": ["raymarch", "repetition", "truck", "tesla"], "likes": 14, "viewed": 451, "published": "Public API", "date": "1575228790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Trux in Space\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    1   // optional antialisaing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nvec3 Hashv3v3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nmat3 flMat;\nvec3 trkAx, trkAy, trkFx, trkFy, flPos, ltDir, cId, obRnd, obDisp;\nvec2 obRotCs;\nfloat bGrid, tCur, dstFar, spd, obOcc, szFac;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nvoid ObjState ()\n{\n  obRnd = Hashv3v3 (cId);\n  obDisp = vec3 (0.6, 0.6, 0.2) * bGrid * (obRnd - 0.5);\n  obRotCs = cos (0.2 * pi * (obRnd.z - 0.5) * sin (1.5 * pi * (obRnd.y - 0.5) * tCur) +\n     vec2 (0., 0.5 * pi));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, b;\n  float dMin, d, h;\n  dMin = dstFar / szFac;\n  p = (p - obDisp) / szFac;\n  p = vec3 (Rot2Cs (p.xy, obRotCs.xy), - p.z);\n  b = vec3 (1.3, 0.9, 3.);\n  q = p;\n  b.x -= 0.2 * abs (q.y + 0.02 * q.z + 0.1);\n  h = ((q.z > 0.5) ? 0.21 : 0.13) * abs (q.z - 0.5);\n  q.y -= - h;\n  b.yz -= vec2 (h, 0.1 * abs (q.y - 0.3));\n  d = max (PrBoxDf (q, b), - PrBoxDf (p - vec3 (0., 0.1, -2.), vec3 (1.15, 0.5, 0.9)));\n  q = p;\n  q.xz = abs (q.xz) - vec2 (1.1, 2.);\n  h = 0.15 * abs (q.z);\n  q.y += 0.8 + h;\n  d = max (d, - PrBoxDf (q, vec3 (0.15, 0.4, 0.6) - vec3 (0., h, 0.6 * q.y)));\n  DMIN (1);\n  q = vec3 (p.x, p.y + 0.95, abs (p.z) - 2.);\n  d = PrCylDf (q.yzx, 0.08, 1.4);\n  DMIN (2);\n  q = p;\n  q.y -= -0.88;\n  d = PrBoxDf (q, vec3 (1.3, 0.03, 1.4));\n  DMIN (3);\n  q = vec3 (abs (p.xz) - vec2 (1.18, 2.), p.y + 0.95).xzy;\n  d = PrRoundCylDf (q.yzx, 0.48, 0.07, 0.2);\n  DMIN (4);\n  return 0.7 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = abs (Minv3 (s)) + eps;\n    if (obRnd.x < obOcc && length (cId.xy - floor (TrackPath (bGrid * cId.z).xy / bGrid)) >= 1.)\n       d = min (d, ObjDf (p - (bGrid * (cId + 0.5))));\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 col4;\n  float z, r, s;\n  p = (p - obDisp) / szFac;\n  p = vec3 (Rot2Cs (p.xy, obRotCs.xy), - p.z);\n  col4 = vec4 (0.7, 0.1, 0.1, 0.4);\n  if (idObj == 1) {\n    z = abs (p.z - 0.5);\n    if (p.y > 0.15 && abs (z - 0.78) < 0.72 && (abs (p.x) < 1.2 - 0.2 * p.y ||\n       p.y < 0.85 - 2. * ((p.z > 0.5) ? 0.21 : 0.13) * z)) col4 = vec4 (0., 0., 0., -2.);\n    else if (p.z < - 2.98 && abs (p.y + 0.1) < 0.05 && abs (p.x) < 1.25)\n       col4 = vec4 (1., 0., 0., -1.);\n    else if (p.z > 2.98 && abs (p.y + 0.2) < 0.05 && abs (p.x) < 1.25)\n       col4 = vec4 (1., 1., 0.8, -1.);\n    else if (p.y < - 0.75 || abs (p.y) < 0.85 && z < 0.008 || \n       abs (p.y + 0.09) < 0.31 && abs (p.z - 2.01) < 0.008 ||\n       abs (p.y + 0.15) < 0.61 && abs (p.z + 1.01) < 0.008) col4.rgb *= 0.6;\n    else if (p.z > 2.8 && abs (p.y + 0.5) < 0.15 && abs (p.x) < 0.8)\n       col4.rgb *= 1. - 0.3 * step (0.2, cos (8. * pi * p.x));\n    else if (p.y > -0.5 && abs (p.x) < 1.1 && abs (p.z + 2.) < 0.85)\n       col4.rgb *= 0.9 + 0.1 * cos (16. * pi * p.x);\n  } else if (idObj == 2) {\n    col4 = vec4 (0.3, 0.3, 0.4, 0.1);\n  } else if (idObj == 3) {\n    col4.rgb *= 0.4;\n  } else if (idObj == 4) {\n    s = sign (p.z);\n    p = vec3 (abs (p.xz) - vec2 (1.18, 2.), p.y + 0.95).xzy;\n    r = length (p.yz);\n    if (r < 0.2) {\n      p.yz = Rot2D (p.yz, - pi * tCur * s);\n      if (abs (abs (p.y) - abs (p.z)) < 0.1) col4 = vec4 (0.9, 0.9, 1., 0.3);\n    } else if (r > 0.3) col4 = vec4 (0.15, 0.15, 0.15, 0.) * (0.7 + 0.3 * step (0., cos (32. * pi * p.x)));\n  }\n  return col4;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, -0.04, 1.));\n  erRad = 0.025;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  bool isBg, isRefl;\n  isRefl = false;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    cId = floor (ro / bGrid);\n    ObjState ();\n    ro -= bGrid * (cId + 0.5);\n    vn = ObjNf (ro);\n    vn.xy = Rot2Cs (vn.xy, vec2 (obRotCs.x, - obRotCs.y));\n    col4 = ObjCol (ro);\n    col4.rgb *= 1. - 0.7 * smoothstep (0.6, 1., dstObj / dstFar);\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n         col4.a * pow (max (dot (reflect (rd, vn), ltDir), 0.), 16.);\n      if (idObj == 1) col += 0.2 * StarPat (reflect (rd, vn), 16.);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.2 - 0.8 * dot (rd, vn));\n    } else if (col4.a == -2.) {\n      rd = reflect (rd, vn);\n      isRefl = true;\n      isBg = true;\n    }\n  } else isBg = true;\n  if (isBg) {\n    col = ErCol (rd);\n    if (length (col) < 0.03) col += StarPat (rd, 16.);\n    if (isRefl) col *= 0.8;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = - asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl = clamp (rl - 3. * TrackAcc (s).x, -0.4 * pi, 0.4 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 1.;\n  obOcc = 0.5;\n  szFac = 0.12;\n  tCur = mod (tCur, 1800.) + 11.1;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az += 0.3 * pi * SmoothBump (0.2, 0.7, 0.15, mod (0.03* tCur, 1.)) * (2. * mod (floor (0.03 * tCur), 2.) - 1.);\n  }\n  vuMat = StdVuMat (el, az);\n  bGrid = 1.;\n  trkAx = 0.5 * vec3 (0.7, 0.8, 1.2);\n  trkAy = 0.5 * vec3 (1., 1.1, 0.9);\n  trkFx = vec3 (0.43, 0.33, 0.23);\n  trkFy = vec3 (0.41, 0.31, 0.12);\n  FlyerPM (spd * tCur, 0.1 * pi * (Fbm1 (0.1 * tCur) - 0.5), 1.);\n  ro = flPos;\n  zmFac = 5.;\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * (rd * flMat);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (clamp (col, 0., 1.), vec3 (0.6)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVSW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[798, 798, 824, 824, 905], [907, 907, 932, 932, 1039], [1041, 1041, 1066, 1066, 1189], [1191, 1191, 1209, 1209, 1409], [1411, 1411, 1433, 1433, 2343], [2345, 2345, 2378, 2378, 3086], [3088, 3088, 3109, 3109, 3306], [3308, 3308, 3330, 3330, 4876], [4878, 4878, 4913, 4913, 5366], [5368, 5368, 5390, 5390, 5875], [5877, 5877, 5912, 5912, 6966], [6968, 6968, 7012, 7012, 7534], [7536, 7536, 7592, 7592, 9000], [9002, 9002, 9034, 9034, 9134], [9136, 9136, 9178, 9178, 9229], [9231, 9231, 9288, 9288, 9452], [9454, 9454, 9490, 9490, 9696], [9698, 9698, 9720, 9720, 9758], [9760, 9760, 9782, 9782, 9820], [9822, 9822, 9879, 9879, 9962], [9964, 9964, 9994, 9994, 10107], [10109, 10109, 10140, 10140, 10204], [10238, 10238, 10262, 10262, 10315], [10317, 10317, 10341, 10341, 10471], [10473, 10473, 10497, 10497, 10690], [10692, 10692, 10717, 10717, 10863], [10865, 10865, 10890, 10890, 11076], [11078, 11078, 11100, 11100, 11254], [11256, 11256, 11277, 11277, 11432]], "test": "error"}
{"id": "tsySWt", "name": "Animated 3D grid", "author": "foez", "description": "3d cartesian grid, I want to get smooth rotation and visit all octants not sure how to do it yet.", "tags": ["3d", "grid"], "likes": 8, "viewed": 159, "published": "Public", "date": "1575297751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    \n    float t = dot(ap, ab)/dot(ab, ab);\n    vec3 c = a + t*ab;\n    \n    return length(c-p) - r;\n}\n\nfloat plane(vec3 p, vec4 n) {\n    n = normalize(n);\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat pmod1(float a, float m) {\n    return mod(a-m/2., m) - m/2.;\n}\n\nfloat dF(vec3 p) {\n    float xaxis = capsule(p, vec3(0), vec3(1., 0, 0), 1.);\n    float yaxis = capsule(p, vec3(0), vec3(0, 1., 0), 1.);\n    float zaxis = capsule(p, vec3(0), vec3(0, 0, 1.), 1.);    \n    float axis = min(xaxis, yaxis);\n    axis = min(axis, zaxis);\n    \n    float xzp = abs(plane(p, vec4(0, 1, 0, 100)));\n    float xyp = abs(plane(p, vec4(0, 0, 1, 100)));\n    float yzp = abs(plane(p, vec4(1, 0, 0, 100)));\n    float planes = min(xzp, xyp);\n    planes = min(planes, yzp);\n    \n    float lines = 200.;\n    if(abs(p.z) < 1.) {\n        p.x = pmod1(p.x, 2.);\n        p.y = pmod1(p.y, 2.);\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 1, 0), .2));\n        lines = min(lines, capsule(p, vec3(0), vec3(1, 0, 0), .2));\n    } else if(abs(p.x) < 1.) {\n        p.y = pmod1(p.y, 2.);\n        p.z = pmod1(p.z, 2.);\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 1, 0), .2));\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 0, 1), .2));\n    } else if(abs(p.y) < 1.) {\n        p.x = pmod1(p.x, 2.);\n        p.z = pmod1(p.z, 2.);\n        lines = min(lines, capsule(p, vec3(0), vec3(1, 0, 0), .2));\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 0, 1), .2));\n    }\n    \n    \n    float scene = min(planes, axis); \n    return min(scene, lines);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i=0;i<100;i++) {\n        float dd = dF(ro + d*rd);\n        if(dd < 0.001 || d > 101.) break;\n        d += dd;\n    }\n    return d;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n\treturn normalize(vec3(\n    \tdF(p+e.xyy) - dF(p-e.xyy),\n        dF(p+e.yxy) - dF(p-e.yxy),\n        dF(p+e.yyx) - dF(p-e.yyx)\n    ));\n}\n\nfloat getDiffuse(vec3 p, vec3 lightPos) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 n = getNormal(p);\n    return max(0.8, dot(lightDir, n));\n}\n\nvec4 image(vec2 uv, vec2 resolution)\n{\n    vec3 col = vec3(0);\n    float ar = resolution.x/resolution.y;\n    uv.x *= ar;\n    \n    vec3 ro = vec3(30, 10, 30);\n    vec3 la = vec3(0);\n    \n    float t = iTime*0.5;\n    \n    ro.xz *= rot(t*.5);\n\tt *= 2.;\n    ro.y *= sin(t+sin(t+sin(t + 0.5)));\n    vec3 f = normalize(la-ro);\n    vec3 u = normalize(vec3(0, 1, 0));\n    vec3 r = normalize(cross(f, u));\n    \n    float focal_length = ar/tan(55.0*3.14/180.);\n    vec3 rd = normalize(focal_length*f + uv.x*r + uv.y*u);\n    \n    float d = rayMarch(ro, rd);\n    \n    if(d < 100.) {\n        vec3 p = ro + d*rd;\n        float diffuse = getDiffuse(p, vec3(10, 10, 10));\n        col = mix(vec3(1)*diffuse, vec3(0), d/100.);\n        \n        if(p.x > 1.1 && abs(p.y) < 1.1 && abs(p.z) < 1.1) col *= vec3(1, 0, 0);\n        else if(p.x < -1.1 && abs(p.y) < 1.1 && abs(p.z) < 1.1)col *= 0.5*vec3(1, 0, 0);\n        \n        \n        if(p.y > 1.1 && abs(p.x) < 1.1 && abs(p.z) < 1.1) col *= vec3(0, 1, 0);\n        else if(p.y < -1.1 && abs(p.x) < 1.1 && abs(p.z) < 1.1) col *= 0.5*vec3(0, 1, 0);\n        \n        if(p.z > 1.1 && abs(p.y) < 1.1 && abs(p.x) < 1.1) col *= vec3(0, 0, 1);\n        else if(p.z < -1.1 && abs(p.y) < 1.1 && abs(p.x) < 1.1) col *= 0.5*vec3(0, 0, 1);\n    }\n    \n    return vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2.*fragCoord/iResolution.xy;\n    fragColor = image(uv, iResolution.xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsySWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 192], [194, 194, 223, 223, 279], [281, 281, 312, 312, 348], [350, 350, 368, 368, 1626], [1628, 1628, 1662, 1662, 1825], [1827, 1827, 1846, 1846, 1922], [1925, 1925, 1949, 1949, 2114], [2116, 2116, 2157, 2157, 2268], [2270, 2270, 2308, 2308, 3563], [3566, 3566, 3623, 3623, 3717]], "test": "timeout"}
{"id": "tt33Df", "name": "[2TC] Illusion_0 (154c)", "author": "balkhan", "description": "2d lookin a bit 3dish ", "tags": ["illusion", "codegolf"], "likes": 3, "viewed": 70, "published": "Public", "date": "1577737692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Fabrice, -41c, 154c\nvoid mainImage(out vec4 o, vec2 f)\n{\n    vec2 R = iResolution.xy,\n         u = (f-R*.5) / R;\n    u *= mat2(cos(sin(u*R/.64+iTime).y+vec4(0,33,11,0)));\n\to += step(.01* abs(sin(iTime/8.*3.14)), abs(u.x) );\n}\n\n// 195c\n/*\n#define mainImage( o, f )\\\n    vec2 R = iResolution.xy,\\\n         u = (f.xy-R*.5) / R.xy,\\\n         v = u*.0+sin(u.y*R.y/.64+iTime),\\\n         a = vec2(cos(v.x),sin(v.y));\\\n    u *= mat2(a,-a.y,a.x);\\\n    o += step(-abs(u.x)+.01*sin(fract(iTime/8.)*3.14)+.001, .0)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 24, 60, 60, 229]], "test": "error"}
{"id": "tt33DN", "name": "Rectangle+Wave+Remap", "author": "izutionix", "description": "Following along ShaderToy Tutorial Part 3 - Making a Rectangle by The Art of Code: https://youtu.be/bigjgiavOM0", "tags": ["fromtutorial"], "likes": 1, "viewed": 86, "published": "Public", "date": "1576357571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur) {\n    float step1 = smoothstep(start+blur, start-blur, t);\n\tfloat step2 = smoothstep(end-blur, end+blur, t);\n        \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float horizontal, float vertical, float blur) {\n\tfloat band1 = Band(uv.x, -horizontal, horizontal, -blur);\n    float band2 = Band(uv.y, -vertical, vertical, -blur);\n    \n\treturn band1*band2;\n}\n\nfloat Remap(float v, float fmn, float fmx, float tmn, float tmx) {\n    return (v-fmn) / (fmx-fmn) * (tmx-tmn) + tmn;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.y += .2*sin(iTime*-1.5+uv.x*8.);\n    \n    float mask = Rect(uv, .5, .1, Remap(uv.x, -.3, .5, .01, .25));\n    \n    fragColor = vec4(vec3(mask), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 199], [201, 201, 268, 268, 413], [415, 415, 481, 481, 533], [539, 539, 596, 596, 818]], "test": "ok"}
{"id": "tt33DS", "name": "Turn Around Blue (Practice #3)", "author": "Coda_", "description": "Turn Around Blue(Practice #3) I'll redo the code later because this is a mess.", "tags": ["torus", "blue", "turnaround"], "likes": 3, "viewed": 78, "published": "Public", "date": "1577398573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time  iTime\n\n\n\n\n\n\n\nfloat torus (vec3 p, vec2 r,float sp)\n{\n\n  p.yz *= mat2(cos(1.57),-sin(1.57),sin(1.57),cos(1.57)); \n  p.xy *= mat2(cos(time*mix(-sp,sp,sin(time)*0.015)),-sin(time*mix(-sp,sp,sin(time)*0.015)),sin(time*mix(-sp,sp,sin(time)*0.015)),cos(time*mix(-sp,sp,sin(time)*0.015)));\n  float x = length(p.xz) - r.x;\n  return length(vec2(x,p.y)) - r.y;   \n}\n\nfloat trace (vec3 o, vec3 r)\n{\n  float t = 0.0;\n  for(int i = 0;i < 100;i++)\n  {\n      vec3 p = o+r*t;\n      float d0 = torus(p-vec3(0,0,0),vec2(0.1,0.1),0.0);\n      float d1 = torus(p-vec3(0,0,0),vec2(0.5,0.15),1.0);\n      float d2 = torus(p-vec3(0,0,0),vec2(1.0,0.15),1.0);\n      d1 = min(d1,d0);\n      d1 = min(d1,d2);\n      float dx;\n      float tt = 0.25;\n      float tx = 1.0;\n      for(int i = 1; i < 20;i++)\n      {\n        dx = torus(p-vec3(0,0,0),vec2(tx,0.15),1.5+tt);\n        d1 = min(d1,dx);\n        tt += 0.07;\n        tx += 0.5;\n      }\n      \n      \n      t += d1*0.25;\n  }\n  return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  \tuv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1.0);\n\n  \tvec3 r = normalize(vec3(uv,1.0));\n\n  \tvec3 o = vec3(0.0,0.0,-25);\n  \tfloat t = trace(o,r); \n  \n  \tfloat fog = 1.0/(1.0+t*t*0.001);\n\n    fragColor = vec4(vec3(fog)*vec3(0.0,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 66, 66, 369], [371, 371, 401, 401, 974], [978, 978, 1035, 1035, 1368]], "test": "ok"}
{"id": "tt33Wf", "name": "PSP Waves", "author": "jackwitherell", "description": "its psp waves", "tags": ["waves", "psp", "sony", "gaming"], "likes": 3, "viewed": 334, "published": "Public API", "date": "1577732500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave(vec2 uv, float inv_size, float period, float inv_amplitude, float x_offset, float y_offset, float flip, float speed){\n    float wv = ((uv.y-y_offset)*inv_size)-(sin(((x_offset+uv.x)/period)+(speed*iTime))/inv_amplitude);\n    if(abs(wv)>0.4){\n        wv=0.0;\n    }\n    return flip*wv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //background color\n    vec3 col = vec3(0.0,0.0,0.3+((uv.x+uv.y)/3.0));\n    //waves\n    //(uv, inverted size, period, inverted amplitude, x, y offset, flip, speed)\n\tcol+=clamp(wave(uv,4.0,1.0,3.0,0.0,0.4,1.0,-0.1),0.0,0.4);\n    col+=clamp(wave(uv,4.0,0.4,1.0,0.0,0.5,1.0,0.1),0.0,0.4);\n    \n\tcol+=clamp(wave(uv,4.0,0.2,6.0,3.0,0.3,-1.0,0.13),0.0,0.4);\n    col+=clamp(wave(uv,4.0,0.15,7.0,4.0,0.4,-1.0,-0.18),0.0,0.4);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 128, 128, 296], [298, 298, 355, 405, 929]], "test": "ok"}
{"id": "tt33z2", "name": "3D Function Grapher", "author": "kindpotato", "description": "Here is a crappy way I figured out how I could graph a 3D function. For each ray I make small steps forward until I pass the surface. Then I use the bisection method to find a better intersection. Here I graph a wave function with 16 modes.", "tags": ["functiongrapherbisection"], "likes": 7, "viewed": 158, "published": "Public", "date": "1577370914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi 3.14159265\n\n\n//func is a mode of vibration of a 2D plane with fixed boundary conditions\n//Look up membrane modes of vibrations\nfloat func(vec2 mn, vec2 uv){\n  float mag = length(mn);\n  return sin(iTime*mag)/mag*sin(mn.x*uv.x)*sin(mn.y*uv.y);\n}\n//I this case f is the addition of 16 modes of vibration on a 2D membrane.\nfloat f(float x, float y){ //this defines the function that is graphed.\n  float total = 0.;\n  for (float m = 1.; m < 4.1; m += 1.){\n    for (float n = 1.; n < 4.1; n += 1.){\n      total += func(vec2(m,n),vec2(x,y));\n    }\n  }\n\n  return total/3.;\n}\n/*float f(float x, float y){\n    return x*x +y*y-10.+sin(6.*x)+sin(6.*y);\n}*/\nvec2 times(vec2 a, vec2 b){\n  return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n  vec3 v = normalize(vec3(uv,1));\n  /*v is the ray for our current pixel. We must find a value \"t\"\n    which when multiplied by v is the intersection of v and the\n    func.*/\n  float angle = pi/6.;\n  v.zy = times(v.zy,vec2(cos(angle),-sin(angle)));\n  vec3 planePos = 3.*vec3(0,-1,1);//This is the position of the origin relative to camera\n  float a = 0., b = 0.;\n  vec3 pa = a*v-planePos; //Our starting pos relative to func origin\n\n\n  if (f(pa.x,pa.z) > pa.y){ //if our cam below func leave\n    fragColor = vec4(0);\n    return;\n  }\n  //step forward along v in coarse steps until we pass through the func\n  for (float i = 3.;i < 20.;i += 0.5){\n    vec3 pb = i*v-planePos;\n    if (f(pb.x,pb.z) > pb.y){\n      a = i-0.5; //Once we pass through, set a to slightly above func, and b below \n      b = i;\n      break;\n    }\n  }\n  if (b == 0.){ //if ray doesn't pass through the func\n    fragColor = vec4(0);\n    return;\n  }\n  float mid, diff; //midpoint of a and b and diff\n  int count = 0;\n  do { //Use bisections to find a better approximation for \n    mid = (a+b)/2.;\n    vec3 pm = mid*v-planePos;\n    diff = f(pm.x,pm.z) - pm.y;\n    if (diff < 0.)\n      a = mid;\n    else\n      b = mid;\n    ++count;\n  }while (abs(diff) > 0.001 && count < 10);\n//mid is now adequately close to the func\n  vec3 p = mid*v-planePos;\n    \n  const float dx = 0.05;\n  //gradX is a small vector which starts at point p (a point on the func)\n  //and ends at a point on the func when making a small step in the x dir\n  vec3 gradX = vec3(dx,f(p.x+dx,p.z)-p.y,0.);\n  vec3 gradZ = vec3(0.,f(p.x,p.z+dx)-p.y,dx);\n  //A vector perp to gradX and gradZ is a normal to our funcs surface\n  vec3 normal = normalize(cross(gradX,gradZ));\n  //Calculate lighting given our pos, lightPos, normal and texture\n  normal.y *= -1.;\n  vec3 reflected = reflect(v,normal);\n  vec3 toLight = normalize(vec3(0,1,0));\n  vec3 tex = texture(iChannel0,p.xz/pi).rgb;\n  float diffuse = dot(normal,toLight);\n  float specular = pow(abs(dot(toLight,reflected)),8.);\n  vec3 color = 0.6*vec3(specular)+diffuse*tex;\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 139, 168, 168, 255], [256, 331, 357, 402, 578], [579, 657, 684, 684, 739], [740, 740, 795, 795, 2939]], "test": "error"}
{"id": "tt3GRj", "name": "Worley Cellular Noise 2D", "author": "bluebean", "description": "Cellularåªå£°", "tags": ["2d", "noise", "worley", "cellular"], "likes": 2, "viewed": 134, "published": "Public", "date": "1577105511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//å¨æ°ç»ä¸­éæºåä¸ä¸ªå¼ï¼æ»¡è¶³æ³æ¾åå¸ï¼åå¼ä¸º2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\nå¨cellX,cellYæå®çæ¶æ ¼ä¸­éæ ·ï¼å¾å°æè¿çåä¸ªè·ç¦»\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //å¨æ¶æ ¼ä¸­äº§çè¥å¹²ä¸ªç¹å¾ç¹ï¼ä¸ªæ°å¨æ³æ¾åå¸è¡¨ä¸­éæºå¾å°\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //åç§»ç§å­ï¼ç¨ä»¥äº§çä¸ä¸ä¸ªä¸åçåç§»\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worleyç»èåªå£°\nè¾å¥ï¼ä½ç½®\nè¾åºï¼ä»å°å°å¤§æåºçè·ç¦»æè¿çåä¸ªç¹å¾ç¹çè·ç¦»\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //å¤æ­æ¯å¦å¾å°äºæè¿çåä¸ªè·ç¦»ï¼å¦ææ¯çè¯ï¼ä¸å¿å¨ç¸é»æ¶æ ¼è¿è¡éæ ·\n    if(dx1<fs[max_order-1])//å·¦\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//ä¸\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//å·¦ä¸\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//å³\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//ä¸\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//å³ä¸\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//å·¦ä¸\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//å³ä¸\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3GRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[759, 759, 780, 780, 875], [877, 877, 903, 903, 1377], [1379, 1379, 1403, 1403, 1555], [1557, 1632, 1707, 1707, 2779], [2781, 2895, 2941, 2941, 4226], [4229, 4229, 4267, 4267, 4435], [4437, 4437, 4466, 4466, 4550], [4552, 4552, 4609, 4609, 5531]], "test": "error"}
{"id": "ttc3z2", "name": "Hexagon Tunnel", "author": "MikeXenix", "description": "First 3D shape, using a previous procedural texture I made. Tunnel computation by iq", "tags": ["hexagons"], "likes": 11, "viewed": 180, "published": "Public", "date": "1576860764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Michael Yllo - MikeXenix/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n\nUsing some code from https://www.shadertoy.com/view/Ms2SWW   inigo quilez - iq/2013\nMore info: http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\n\n*/\n\n// A bit of a hacked together procedural texture computing the closest distance to a hexagon grid using planes and voronoi regions\nfloat hexTex(vec2 Tex)\n{\n    float degAlpha = 57.0;\n    \n    float alpha = (degAlpha) / 360.0 * 2.0 * 3.14159, cal = cos(alpha), sal = sin(alpha);\n\tfloat beta = ((90.0 - degAlpha) / 360.0 * 2.0 * 3.14159), cbe = cos(beta), sbe = sin(beta);\n\tfloat r = 0.5 / cbe;\n\tvec2 P1 = vec2(r*sbe, r*cbe);\n\tvec2 P2 = vec2(2.0 * r*cal, 0.0);\n\tvec2 N = normalize(P2 - P1);\n\tfloat D = dot(vec2(-N.y, N.x), P1);\n    \n\tfloat v = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.y), 1.0));\n\tfloat v2 = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.x), 1.0));\n\tfloat d = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D);\n\tfloat d2 = (dot(vec2(-N.y, -N.x), vec2(v2, v)));\n\n\tif (v2 <= r * cal)\n\t{\n\t\tif (d2 > 0.0)\n\t\t\td = abs(d) / D;\n\t\telse if (v < 0.5)\n\t\t\td = abs(0.5 - v) * 2.0;\n\t\telse if (d > 0.0)\n\t\t\td = abs(d2) / D;\n\t\telse\n\t\t\td = abs(0.5 - v) * 2.0;\n\t}\n\telse if (d <= 0.0)\n\t{\n\t\td = abs(d) / D;\n\t}\n\telse\n\t{\n\t\tif (v2 >= 2.0 * r*cal)\n\t\t{\n\t\t\tif (v < 0.5)\n\t\t\t{\n\t\t\t\tvec2 P3 = vec2(0.25, 0.5);\n\t\t\t\tvec2 N2 = normalize(P3 - P2);\n\t\t\t\tfloat D2 = dot(vec2(-N2.y, N2.x), P2);\n\t\t\t\tfloat d3 = (dot(vec2(-N2.y, -N2.x), vec2(v2, v)) - D2);\n\t\t\t\tif (d3 < 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d) / D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat d4 = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D * 2.0);\n\t\t\t\tif (d4 > 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d2) / D;\n\t\t\t}\n\t\t}\n\t\telse if (v > 0.5)\n\t\t\td = abs(dot(vec2(-N.y, -N.x), vec2(v2, v))) / D;\n\t\telse\n\t\t\td = abs(d) / D;\n\t}\n\n    return min(0.999, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // rotate\n    float rotateSpeed = 0.4;\n\tp=vec2(p.x*cos(iTime*rotateSpeed)+p.y*sin(iTime*rotateSpeed),p.y*cos(iTime*rotateSpeed)-p.x*sin(iTime*rotateSpeed));\n    \n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n\n    // squareish tunnel\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/16.0 );\n    \n    // index texture by (animated inverse) radious and angle\n    uv = vec2( 0.3/r, a/3.1415927 );\n\n    // Texture computation\n    float c = pow(1.0-hexTex(vec2(iTime,0)+uv.xy*vec2(6.0,3.0)),4.1+2.0*sin(iTime)); // eval texture and bend with pow\n\n    // fade by time\n    c = 0.1+0.9*c*abs(sin(iTime*2.0));\n\n    // spiral\n    c *= 0.2+0.8*pow(abs(sin(uv.x*10.0-iTime*10.0+uv.y*3.14159)),4.0);\n\n    // fade by distance\n    c *= min(max(1.0-uv.x,0.0),1.0);\n\n    // Output to screen\n    fragColor = vec4(0,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttc3z2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[293, 424, 448, 448, 1878], [1880, 1880, 1937, 1987, 3007]], "test": "ok"}
{"id": "ttcGzS", "name": "RandomThings", "author": "Hei149", "description": "raymarching, kifs", "tags": ["raymarching", "kifs"], "likes": 10, "viewed": 187, "published": "Public", "date": "1576681852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA\n\n#define rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n\nfloat bump(vec3 p)\n{\n \tfloat a = texture(iChannel0, p.xy).r;\n    float b = texture(iChannel1, p.yz).r;\n    float c = texture(iChannel2, p.zx).r;\n    return (a + b + c) / length(p);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n \tvec3 q = abs(p) - b;\n    return max(q.x, max(q.y, q.z)) + bump(p) * 0.05;\n}\n\nfloat map(vec3 p)\n{\n\n  p.xz *= rot(iTime);\n  float itr = 8.;\n  \n  for(float i = 0.; i < itr; ++i)\n  {\n    float ang = 3.1415 * 0.9 + iTime * 0.1;\n   \tp = abs(p) - 0.4;\n\n    p.xy *= rot(ang);\n    p.yz *= rot(ang);\n  \tp.xz *= rot(ang);\n  }\n    \n  float d = sdBox(p, vec3(0.3, 1.0, 0.3));\n  return d;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.0);\n \treturn normalize(vec3(\n    \tmap(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n    \tmap(p + e.yyx) - map(p - e.yyx)\n    ));   \n}\n\nbool raymarch(vec3 r0, vec3 rd, float t_min, float t_max, out float d)\n{\n    d = t_min;\n    for(int i = 0; i < 100; ++i)\n    {\n     \tvec3 p = r0 + d * rd;   \n        float t = map(p);\n        \n        d += t;\n        if(t < 0.001) return true;\n        if(d > t_max) break;\n    }\n    \n    return false;\n}\n\n\nfloat occ(vec3 r0, vec3 rd)\n{\n    float occ = 0.0;\n    float denom = 0.15;\n    for(float i = 0.0; i < 10.0; ++i)\n    {\n        float stepSize = (i + 1.0) / 20.0;\n        denom *= 2.0;\n        float t = map(r0 + stepSize * rd);\n        occ += (stepSize - t) / denom;\n    }\n \treturn clamp((1.0 - occ), 0.0, 1.0);   \n}\n\nvec3 getSkyColor(vec2 uv)\n{\n    return  mix(vec3(0.1, 0.1, 0.1), vec3(0.2, 0.2, 0.1), length(uv) - 0.25);\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 rd)\n{\n    \n    vec3 ld = normalize(vec3(-0.5, 0.5, -0.5));\n    vec3 col = (max(dot(n, ld), 0.0)) * vec3(1.28, 1.2, 0.99);\n    col += clamp((0.5 * n.y + 0.5), 0.0, 1.0) * vec3(0.16, 0.2, 0.28);\n\tcol += clamp(dot(n, ld * vec3(-1.0, 0.0, -1.0)), 0.0, 1.0) * vec3(0.4, 0.28, 0.2);\n    col += smoothstep(0.0, 1.0, occ(p, ld));\n    return col * vec3(0.7, 0.8, 0.5) * 0.7;\n}\n\n\nvec2 rand(vec2 val)\n{\n    return fract(sin(dot(val, vec2(43943.8, 95438.4))) * vec2(29430.6, 92929.3));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = vec2(fragCoord.xy / iResolution.xy);\n    vec3 col = vec3(0.0);\n    vec2 mouse = iMouse.xy / iResolution.xy * 5.0;\n    \n\tint numItr = 1;\n    #ifdef AA\n    \tnumItr = 3;\n    #endif\n    for(int i = 0; i < numItr; ++i){\n        \n        vec2 off = rand(uv + float(i) * 100.);\n        uv = (fragCoord + off - 0.5 * iResolution.xy) / iResolution.y;\n\n\t\t\n        vec3 r0 = vec3(12.0 * cos(mouse.x), 2.0, -12.0 * sin(mouse.x));\n        vec3 tgt = vec3(0.0);\n\n        vec3 ww = normalize(tgt - r0);\n        vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n        vec3 vv = normalize(cross(ww, uu));\n        vec3 rd = normalize(uv.x * uu + uv.y * vv + ww);\n\n\t\n    \tfloat d = 0.0;\n        if(raymarch(r0, rd, 0.0, 100.0, d)){\n\n            vec3 p = r0 + d * rd;\n            vec3 n = norm(p);\n\n            col += shade(p, n, rd); \n        }\n        else\n           col += getSkyColor(uv);\n\n    }\n    col /= float(numItr);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 96, 96, 258], [260, 260, 289, 289, 367], [369, 369, 388, 388, 668], [670, 670, 689, 689, 873], [875, 875, 947, 947, 1178], [1181, 1181, 1210, 1210, 1496], [1498, 1498, 1525, 1525, 1605], [1607, 1607, 1644, 1644, 2006], [2009, 2009, 2030, 2030, 2114], [2117, 2117, 2174, 2174, 3166]], "test": "error"}
{"id": "ttd3Rf", "name": "Butterfly", "author": "pik33", "description": "Another variation of sin/cos iterations. Added symmetry by using abs to calculate coordinates and used log to make the transform nonlinear. Smoothsteps converts the color field to lines on the black background", "tags": ["patterns"], "likes": 1, "viewed": 94, "published": "Public", "date": "1577115829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Dancing pixels 2\" by pik33. https://shadertoy.com/view/WsV3Wt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=vec2(1.1)+0.1*log(abs((2.*fragCoord.xy-iResolution.xy))/max(iResolution.x,iResolution.y));\n\n\tfor(int i=1;i<40;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=(0.5/float(i))*pow(2.,cos(float(i)*p.y+iTime*0.2*11.0/37.0)+0.03*float(i))+2.;\t\t\n\t\tnewp.y+=(0.5/float(i))*pow(2.,sin(float(i)*p.x+iTime*0.2*17.0/41.0)+0.03*float(i+10))-2.;\n\t\tp=newp;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(1.3*p.x+1.7*p.y));\n    col=smoothstep(0.75,0.8,col)-smoothstep(0.8,0.85,col);\n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttd3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 132, 638]], "test": "ok"}
{"id": "ttd3WX", "name": "tenkinoko kouhaku", "author": "aodnawg", "description": "ç´ç½ã®radwimpsã®ãã¤", "tags": ["dot"], "likes": 7, "viewed": 172, "published": "Public", "date": "1577804116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nfloat N11(float n) {\n\treturn fract(sin(n*939.19)*138.131);\n}\nvec3 pointLight(vec2 uv, float noise,float t, float ratio_) {\n    vec2 ratio =  vec2(ratio_,1.);\n    float r = .4+mix(-.1,.1,noise);\n    float sRange = .3;\n    float s = sin(t+noise*983.12)*.5+.5;\n    float m = S(r,r-.05,length(uv*ratio)) * s *noise;\n    float hue = mix(.5, .6, N11(noise));\n    float b = mix(.4, .8, N11(N11(noise)));\n    return m*hsl2rgb(vec3(hue,1.,b));;\n}\nfloat N21(vec2 n) {\n\treturn N11(N11(n.x)+n.y);\n}\nfloat mask(vec2 uv, vec2 id, float zy) {\n    float n = N11(id.x);\n\treturn step(floor(mix(-.5,.5,n)*zy)/zy, uv.y);\n}\nvec3 layer(vec2 uv, float z_, float seed) {\n    float ratio = 8.;\n    vec2 z = vec2(z_, z_*ratio);\n    vec2 uv_ = uv + vec2(seed, N11(seed));\n    vec2 gv = fract(uv_*z)-.5;\n    vec2 id = floor(uv_*z)-.5;\n    return pointLight(gv, N21(id), iTime, ratio)*mask(uv, id, z.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime*.5;\n    \n    // Time varying pixel color\n    vec3 col =vec3(0.);\n\n    uv.x += iTime*.05;\n    \n    for(float i=1.; i <= 32.; i++) {\n        col +=  layer(uv,5.+i, N11(i))*.8;\n    } \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttd3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 48, 48, 188], [189, 189, 209, 209, 249], [250, 250, 311, 311, 626], [627, 627, 646, 646, 675], [676, 676, 716, 716, 791], [792, 792, 835, 835, 1065], [1066, 1066, 1123, 1173, 1488]], "test": "ok"}
{"id": "ttdGDj", "name": "Daily Coding [1]", "author": "ozu", "description": "grid, circles, forloop, packing", "tags": ["circles", "grid", "packing", "forloop"], "likes": 1, "viewed": 70, "published": "Public", "date": "1577660102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float radius, float blur){\n\n    float d = length(uv - p);    \n    float c = smoothstep(blur,  0., abs(d-radius));\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    float c = 0.;\n    \n\n    vec2 p ;\n    //vec2 p = vec2(-.5 + radius, 0.);\n    int max_i = 20;\n    float dist = 1. / float(max_i);\n    float radius = dist / 2.;\n    float speed = -2.;\n    \n    for (int i=0; i<max_i; i++){\n\t\t\n        p.x = float(i) * dist -.5 + dist / 2.;\n        float t = sin(speed * iTime + float(i) * .125) * .5 +.5;\n        radius = t * (sin(float(i/max_i)) * .5 +.5) * dist;\n        float blur  = 1.5 / iResolution.x;\n\n        float circle = Circle(uv, p, radius, blur);\n        //circle -= Circle(uv, p, radius - .002, 0.003);\n\n        c +=circle;\n    }\n    \n\t// Output to screen\n    fragColor = vec4(c, c, c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 164], [166, 166, 221, 221, 959]], "test": "ok"}
{"id": "ttdGR2", "name": "one cube challenge ( 253 chars )", "author": "FabriceNeyret2", "description": "deeper golfing of fabrice's 2015 \"one cube challenge - v3\" [url]https://shadertoy.com/view/Xs33RH[/url]\n\ncould it be shorter ? ( with same look ).", "tags": ["cube", "2tweets", "short", "codegolf"], "likes": 4, "viewed": 291, "published": "Public API", "date": "1576944717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// deeper golfing of https://shadertoy.com/view/Xs33RH  ( 265 chars )\n\n#define L  *I ; \\\n    o += 3e-3 / length( clamp( dot(u-a,v=b-a)/dot(v,v), 0.,1.) *v - u+a );a//\n#define P  b=c= vec2(r.x,.7)/(2.8+r.y) L;             \\\n           b=a L=c L=c; r = I*r.yx;                  //\nvoid mainImage(out vec4 O, vec2 U) {\n\tvec2 I = vec2(1,-1), c = iResolution.xy,\n         u = ( U+U - c ) / c.y,  a,b,o,v,\n         r = sin(iTime-11.*O.xw);\n    P  o-=o;\n    P P P P   O += o.x;\n}/*\n\n\n\n\n\n// --- 255 chars        \n\n#define L  *I ; \\\n    o += 3e-3 / length( clamp( dot(u-a,v=b-a)/dot(v,v), 0.,1.) *v - u+a )//\n#define P  b=c= vec2(r.x,.7)/(2.8+r.y) L;             \\\n           b=a L;   a=c L;   a=c; r = I*r.yx;        //\n#define mainImage(O,U)                                \\\n\tvec2 I = vec2(1,-1), c = iResolution.xy,          \\\n         u = ( U+U - c ) / c.y,  a,b,o,v,             \\\n         r = sin(iTime-11.*O.xw);                     \\\n    P  o-=o;                                          \\\n    P P P P   O += o.x                               /*\n\n\n\n\n\n// --- 259 chars        \n\n#define L  *I ; o+= 3e-3 / length( clamp( dot(u-a,v=b-a)/dot(v,v), 0.,1.) *v - u+a )//\n#define P  b=c= vec2(r.x,1)/(4.+r.y) L;               \\\n           b=a L;   a=c L;   a=c; r= I*r.yx;         //\n#define mainImage(O,U)                                \\\n\tvec2 I = vec2(1,-1), c = iResolution.xy,          \\\n         u = ( U+U - c ) / c.y,  a,b,o,v,             \\\n         r = sin(iTime-.8*I); r += I*r.yx;            \\\n    P  o-=o;                                          \\\n    P P P P   O += o.x                               /*\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "ttdGRX", "name": "Color Delight (Practice #1)", "author": "Coda_", "description": "Color Delight (Practice #1) first shader", "tags": ["color"], "likes": 2, "viewed": 77, "published": "Public", "date": "1577099216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat map(vec3 p)\n{\n    vec3 q = fract(p) *2.0 -1.0;\n    return length(q) - 0.25;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n  float t = 0.0;\n  for(int i ;i < 64;i++)\n  {\n    vec3 p = o + r *t;\n    float d = map(p);\n    \n    t += d*0.5;\n  }\n  return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  \tuv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \tuv*=(sin(time)*0.5+0.5)*50.0;\n  \tvec3 r = normalize(vec3(uv,1.0));\n  \n  \tvec3 o = vec3(0,sin(time),time);\n  \n  \tfloat t =trace(o,r);\n  \n  \tfloat fog = 1.0/(1.0 + t*t*0.8);\n  \n  \n  \tvec3 color = 0.5 + 0.5*cos(time+uv.yxy+vec3(1,2,4));\n\n\n\tfragColor = vec4(vec3(fog)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 103], [105, 105, 134, 134, 264], [267, 267, 324, 324, 751]], "test": "ok"}
{"id": "ttdGW7", "name": "Website Background", "author": "JasperMeiners", "description": "The background interaction shader for my portfolio website.", "tags": ["backgroundwebsite"], "likes": 3, "viewed": 534, "published": "Public API", "date": "1576592908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat simplex( vec2 uv)\n{\n\tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\nfloat lerp(float a, float b, float t)\n{\n    if(t < 0.0) t = 0.0;\n    else if (t > 1.0) t = 1.0;\n    return (a * (1.0-t)) + (b * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 dir = vec2(iTime * .2, 0.0);\n    vec2 dir2 = vec2(iTime * -.05, iTime * 0.1);\n    \n    float f = simplex(fragCoord / 100.0 + dir);\n    float f2 = simplex(fragCoord / 200.0 + dir2);\n    f = (f * f2);\n\n    // Time varying pixel color\n    vec3 col = vec3(1,1,pow(f,2.0) - 0.5) / 1.0;\n    \n    //col -= pow(distance(iMouse.xy, fragCoord.xy),1.3) / 2000.0 * (sin(  iTime*1.0)*0.3+1.5);\n    \n    float wave = distance(uv, vec2(0.5, 0.5));\n    float sine = sin(iTime * 0.5) * 2.0;\n    float waveSmooth = 1.0-distance(wave, sine);\n    \n    col = vec3(1.0, 1.0, 1.0) * lerp(0.5, 1.0, waveSmooth) * lerp(0.0, 1.0, f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 172], [174, 174, 200, 200, 679], [681, 681, 706, 706, 940], [942, 942, 981, 981, 1075], [1077, 1077, 1134, 1184, 1900]], "test": "ok"}
{"id": "ttdGW8", "name": "Foldable Cube 2", "author": "ShnitzelKiller", "description": "smoother motion, and different shading style.", "tags": ["raymarching", "fractal", "cube"], "likes": 10, "viewed": 339, "published": "Public API", "date": "1576214863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ITERS 100\n#define TOL 1e-3\n#define fdist 0.5\n#define maxdist 10.\n#define LEVELS 9\n#define PI 3.1415926\n\nfloat oscillate(float t_low, float t_high, float t_transition, float t_offset) {\n    float t_osc = 0.5*(t_high+t_low)+t_transition;\n    float h_l = 0.5*t_low/t_osc;\n    float h_h = (0.5*t_low+t_transition)/t_osc;\n    return smoothstep(0., 1., (clamp(abs(mod(iTime + t_offset, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n}\n\nvec4 map(in vec3 pos)   \n{\n    float t = oscillate(2., 2., 7., 0.) * PI * 0.5;\n    float t2 = oscillate(7., 7., 2., 5.);\n    if (iMouse.z > 1.0)\n    {\n    \tt = iMouse.y/iResolution.y*PI*0.5;\n    }\n    float c = cos(t);\n    float s = sin(t);\n    mat3 rotZ = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    mat3 rotX = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    float sc = 0.5;\n    float truncdist = -1e6;\n    for (int i=0; i<LEVELS; i++)\n    {\n        pos = abs(rotX * rotZ * pos) - sc;\n        truncdist = max(truncdist, (pos.x+pos.y+pos.z)/sqrt(3.)-(2.-t2)*sc);\n     \tsc *= 0.5;\n    }\n    vec3 bx = max(vec3(0.), pos-sc*2.);\n    float dist = max(truncdist, length(bx));\n    return vec4(dist, step(pos.zxy, pos.xyz) * step(pos.yzx, pos.xyz));\n}\n\nvec3 getnormal(vec3 ro) {\n    vec2 d = vec2(TOL, 0.0);\n    float x1 = map(ro+d.xyy).x;\n    float x2 = map(ro-d.xyy).x;\n    float y1 = map(ro+d.yxy).x;\n    float y2 = map(ro-d.yxy).x;\n    float z1 = map(ro+d.yyx).x;\n    float z2 = map(ro-d.yyx).x;\n    return normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2));\n}\n\nvec4 march(in vec3 pos, in vec3 dir)\n{\n    float t = 0.;\n    vec4 dist;\n    int i=0;\n    for (; i<ITERS; i++)\n    {\n        vec3 currpos = t*dir+pos;\n    \tdist = map(currpos);\n        t += dist.x;\n        if (abs(dist.x) < TOL)\n        {\n            return vec4(t, dist.yzw);\n        } else if (t > maxdist) {\n            break;\n        }\n    }\n    return vec4(t, vec3(-1., t/maxdist*0.8, float(i)/float(ITERS)));\n}\n\nfloat shadowmarch(in vec3 pos, in vec3 dir) {\n    float t = 0.;\n    for (int i=0; i<50; i++) {\n        vec3 currpos = t*dir+pos;\n        float dist = map(currpos).x;\n        if (dist <= 0.) return 0.;\n        t += max(0.01, dist);\n        if (t > maxdist) break;\n    }\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ang = iTime * 0.3;\n    if (iMouse.z > 1.0) {\n        ang = iMouse.x/iResolution.x*PI*2.;\n    }\n    float c = cos(ang);\n    float s = sin(ang);\n    mat3 rot = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x;\n    vec3 ro = rot * vec3(1.,1.,1.) * (2.+s*0.3);\n    vec3 nw = -normalize(ro);\n    vec3 up = vec3(0.,0.,1.);\n    vec3 nu = cross(nw, up);\n    vec3 nv = cross(nu, nw);\n   \tvec3 rd = normalize(nw*fdist + uv.x*nu + uv.y*nv);\n    vec4 d = march(ro, rd);\n    vec3 pos = d.x * rd + ro;\n    vec3 n = getnormal(pos);\n    vec3 col = vec3(0.);\n    if (d.y > -0.5) {\n        vec3 albedo = d.yzw + 0.75*d.wyz;\n        vec3 lightdir = normalize(vec3(1., 0.5, 2.));\n        float origfac = dot(n, lightdir);\n        float fac = max(0., origfac);\n        float shadowfac = shadowmarch(pos+lightdir*TOL, lightdir);\n\n        float ambfac = abs(origfac);\n        float occfac = clamp(map(pos + n * 0.25).x*4., 0., 1.);\n        col = occfac*(fac * shadowfac + vec3(0.25) * ambfac) * albedo;\n    } else {\n        col = vec3(d.z, d.w, d.w);\n    }\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdGW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 193, 193, 444], [446, 446, 472, 472, 1175], [1177, 1177, 1202, 1202, 1499], [1501, 1501, 1539, 1539, 1916], [1918, 1918, 1963, 1963, 2203], [2205, 2205, 2262, 2262, 3400]], "test": "ok"}
{"id": "ttt3R2", "name": "one cube challenge ( 203 chars )", "author": "FabriceNeyret2", "description": "deeper golfing of  iapafoto's 2015 \"one cube challenge\" [url]https://shadertoy.com/view/4d33R8[/url]\n( ray-tracing approach of the cube challenge ) ", "tags": ["cube", "2tweets"], "likes": 4, "viewed": 273, "published": "Public API", "date": "1576945585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// deeper golfing of  https://shadertoy.com/view/4d33R8\n\n#define M length ( max( O-O, abs( vec3(O.xz * mat2(cos(iTime+vec4(0,33,11,0))), O.y)) //\nvoid mainImage(out vec4 o, vec2 U) {\n    for( vec3 O = vec3(2,0,7); o.w++ < 99.; o.rgb = O.bbb+3. )\n        O -=   vec3( .6* U/iResolution.y -.3, .9 )\n             * max( .12 - M -.9)), M -1.)) );\n}/*\n\n\n\n\n\n// --- 206 chars \n\n#define M length ( max( O-O, abs( vec3(O.xz * mat2(cos(iTime+vec4(0,33,11,0))), O.y)) //\n#define mainImage(o,p)                                  \\\n    for( vec3 O = vec3(2,0,7) ; o.w++ < 99.; )          \\\n        O += .6 * ( .5 - vec3( p/iResolution.y, 2 ))    \\\n                *  max( .12 - M -.9)), o.r = M -1.)) ); \\\n    o = 1.-o.rrrr                                      /*\n\n\n\n\n\n// --- 210 chars -1 by coyote\n\n#define M length ( max( O-O, abs( O * mat3(c,0,-s,0,1,0,s,0,c) )  //\n#define mainImage(o,p)                                \\\n    float C=iTime, s=sin(C), c=cos(C);                \\\n    for( vec3 O = vec3(2,0,7) ; o.w++ < 99.; )        \\\n        O += .6 * ( .5 - vec3( p/iResolution.y, 2 ))  \\\n                *  max( .12 - M -.9)), C = M -1.)) ); \\\n    o -= --C                                         /*\n\n\n\n\n\n// --- 214 chars\n\n#define M(k) length (max( abs(O*mat3(c,0,-s,0,1,0,s,0,c)) -k , 0. )) //\n#define mainImage(o,p)                           \\\n    float C=iTime, s=sin(C), c=cos(C);           \\\n    for(vec3 O = vec3(2,0,7) ;o.w++<99.; )       \\\n        O += .6 * (.5-vec3(p/iResolution.y,2))   \\\n                * max(.12-M(.9),C=M(1.));        \\\n    o += 1.-C                                   /*\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttt3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "ttt3zX", "name": "Alien engine", "author": "mrange", "description": "Alien engine, based upon: https://www.shadertoy.com/view/4ds3zn", "tags": ["raymarching"], "likes": 10, "viewed": 385, "published": "Public API", "date": "1577107396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Alien engine\n// Based upon: https://www.shadertoy.com/view/4ds3zn\n\n#define PI         3.141592654\n#define TAU        (2.0*PI) \n#define TOLERANCE  0.0003\n#define REPS       11\n#define MAX_DIST   20.\n#define MAX_ITER   120\n\nconst vec3  green  = vec3(1.5, 2.0, 1.0);\nconst vec3  dark   = vec3(0.2);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvoid r45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat apollian(vec3 p, float tolerance, out int layer) {\n  const float s = 1.9;\n  float scale = 1.0;\n\n  float r = 0.2;\n  vec3 o = vec3(0.22, 0.0, 0.0);\n\n  float d = 0.0;\n\n  for(int i = 0; i < REPS; ++i) {\n    p = (-1.00 + 2.0*fract(0.5*p+0.5));\n//    rot(p.xz, -float(i)*PI/4.0);\n    r45(p.xz);\n\n    float r2 = dot(p,p) + 0.0;\n    float k = s/r2;\n    float ss = pow((1.0 + float(i)), -0.15);\n    p *= pow(k, ss);\n    scale *= pow(k, -ss*ss);\n    d = 0.25*abs(p.y)*scale;\n    layer = i;\n    if(abs(d) < tolerance) break;\n  }\n  \n  return d;\n}\n\nfloat df(vec3 p, float tolerance, out int layer) { \n  float d = apollian(p, tolerance, layer);\n  return d;\n} \n\n\nfloat intersect(vec3 ro, vec3 rd, out int iter, out int layer) {\n  float res;\n  float t = 1.6;\n  iter = MAX_ITER;\n    \n  for(int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + rd * t;\n    float tolerance = TOLERANCE * t;\n    res = df(p, tolerance, layer);\n    if(res < tolerance || res > MAX_DIST) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > MAX_DIST) t = -1.;\n    \n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n  \n  int layer;\n\n  for(int i = 0; i < 12; i++) {\n    float tolerance = TOLERANCE * t;\n    float d = df(p + n * t, tolerance, layer);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  int layer;\n  float tolerance = TOLERANCE * eps.x;\n  nor.x = df(pos+eps.xyy, tolerance, layer) - df(pos-eps.xyy, tolerance, layer);\n  nor.y = df(pos+eps.yxy, tolerance, layer) - df(pos-eps.yxy, tolerance, layer);\n  nor.z = df(pos+eps.yyx, tolerance, layer) - df(pos-eps.yyx, tolerance, layer);\n  return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 uv = -1.0 + 2.0*q; \n  uv.x*=iResolution.x/iResolution.y; \n    \n  vec3 la = vec3(0.0,0.5,0.0); \n  vec3 ro = vec3(2.5, 1.5, 0.0);\n  rot(ro.xz, iTime/40.0);\n\n  vec3 cf = normalize(la-ro); \n  vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);\n\n  vec3 bg = mix(dark*0.25, dark*0.5, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  int layer = 0;\n  \n  float t = intersect(ro, rd, iter, layer);\n    \n  if(t > -1.0) {\n    p = ro + t * rd;\n    vec3 n = normal(p);\n    float fake = float(iter)/float(MAX_ITER);\n    float fakeAmb = exp(-fake*fake*4.0);\n    float amb = ambientOcclusion(p, n);\n    \n\n    vec3 dif;\n\n    float ll = length(p);\n\n    if (layer == 0)\n    {\n      dif = 0.75*green;\n    } else {\n      dif = green*pow((1.0 + 0.5*cos(-PI*2.0*float(layer)/float(REPS) + iTime*0.25 - 0.5*PI*ll)), 4.0)/pow(float(layer), 1.5);\n    }\n\n\n    const float fogPeriod = TAU*2.0;\n    float fogHeight = 0.25 + 0.325*(abs(p.y) + 0.125*(sin(fogPeriod*p.x) * cos(fogPeriod*p.z)));\n    float dfog = (fogHeight - ro.y)/rd.y;\n    float fogDepth = t > dfog && dfog > 0.0 ? t - dfog : 0.0;\n    float fogFactor = exp(-fogDepth*4.0);\n\n    col = dif;\n    col *= vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb);\n    col = mix(green*0.5, col, fogFactor); \n    col = mix(bg, col, exp(-0.0125*t*t)); \n  } \n\n  float pp = 1.0 - (1.0 - step(0.5, q.y))*smoothstep(0.85, 1.3, length(2.0*q-1.0));\n  \n    \n  col *= pp;\n    \n\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttt3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 333, 333, 418], [420, 420, 444, 444, 484], [486, 486, 542, 542, 1026], [1028, 1028, 1078, 1078, 1136], [1140, 1140, 1204, 1204, 1545], [1547, 1547, 1587, 1587, 1860], [1862, 1862, 1888, 1888, 2255], [2257, 2257, 2315, 2315, 3917]], "test": "ok"}
{"id": "tttGDr", "name": " Famous solid [glitched]", "author": "frankiezafe", "description": "based on \"Famous solid\" by nimitz : https://www.shadertoy.com/view/ltlGWM", "tags": ["dodecahedron"], "likes": 3, "viewed": 136, "published": "Public", "date": "1576081069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Famous solid by nimitz 2015 (twitter: @stormoid)\n// https://www.shadertoy.com/view/ltlGWM\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tQuick laydown of what's going on:\n\t\t-knighty's folding technique to get dodecahedron distance (see: https://www.shadertoy.com/view/XlX3zB)\n\t\t-Linear extrapolation of sphere to \"hyberbolize\" the dodecahedron\n\t\t-Fold symmetries are used to displace, shade and color\n\t\t-Cheap analytic curvature for shading (see: https://www.shadertoy.com/view/Xts3WM)\n\t\t-Wave noise for bump mapping (generalized triangle noise: https://www.shadertoy.com/view/XtX3DH)\n\t\t-eiffie's auto-overstep raymarching method: https://www.shadertoy.com/view/ldSSDV\n\t\t-Lighting mostly from iq\n*/\n\n//Type 1 to 4, Let me know which one you think looks best.\n#define TYPE 4\n\n#define ITR 400\n#define FAR 20.\n#define time iTime\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\nfloat map(in vec3 p)\n{\n    vec3 fp = fold(p) - vec3(0.,0.,1.275);\n    float mt = pow( ( sin( time * 2.134 ) + 1.75 ) * 0.35, 2.0 ) ;\n    //float mt = float((time * 1000) % 1000) * 0.001;\n    //float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);\n    float d = mix(dot(fp,vec3(mt,0,1.)), length(p)-1.15,-3.6);\n    \n    #if (TYPE == 1)\n    d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;\n    d += tri(fp.y*5.)*0.04;\n    d*= 0.9;\n    #elif (TYPE == 2)\n    d*= 0.7;\n    d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;\n    d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;\n    d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;\n    #elif (TYPE == 3)\n    d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;\n    d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;\n    #else\n    d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;\n    #endif\n    \n    return d*0.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.0005;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*( 3.8 + sin(time*1.4)*0.15 + sin(time*0.283)*0.15 );\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.0001;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//Cheap analytic curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p)\n{\n    vec2 e = vec2(-1., 1.)*0.03;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .15/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nfloat wav(in float x){return sin(x*6.283)*0.25+0.25;}\nvec2 wav2(in vec2 p){return vec2(wav(p.x+wav(p.y*1.5)),wav(p.y+wav(p.x*1.5)));}\n\nfloat wavenoise(in vec2 p)\n{\n    float z=2.;\n    float z2=1.;\n\tfloat rz = 0.;\n    vec2 bp = p;\n    rz+= (wav(-time*0.5+p.x*(sin(-time)*0.3+.9)+wav(p.y-time*0.2)))*.7/z;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec2 dg = wav2(bp*2.)*.8;\n        dg *= mm2(time*.2);\n        p += dg/z2;\n\n        bp *= 2.4;\n        z2 *= 1.05;\n\t\tz *= 2.4;\n\t\tp *= 1.4;\n        \n        rz+= (wav(p.x+wav(p.y)))/z;\n\t}\n\treturn rz;\n}\n\nvec3 tex(in vec3 p)\n{    \n    #if (TYPE == 1)\n    float rz= p.y*115.+p.x*30.+p.z*25.;\n    vec3 col = (sin(vec3(.7,2.,.1-rz*0.2)+rz*.1+0.45))*0.5+0.5;\n    #elif (TYPE==2)\n    float rz= (sin(p.x*0.+p.z*20.)-p.y*20.);\n    vec3 col = (sin(vec3(2.1,.7,.1)+rz*.09+4.15))*0.5+0.5;\n    #elif (TYPE==3)    \n    float rz= sin(p.z*3.+p.x*6.)*0.5+0.5;\n    vec3 col = mix(vec3(.7,0.1,0.),vec3(1,.5,0.4),rz)*0.5+0.05;\n    #else\n    float rz= p.z*15. + p.x*30. + time;\n    vec3 col = (sin(vec3(2.2,.1,.9)+rz*.1+4.2))*1.3+1.3;\n    #endif\n    \n    return col;\n}\n\n//Bump mapping\nfloat bumptex(in vec3 p)\n{\n    #if (TYPE == 1)\n    return wavenoise(mix(p.zy,p.yx,1.)*0.55);\n    #elif (TYPE == 2)\n    return wavenoise(mix(p.yz,p.xy,.5)*0.55);\n    #elif (TYPE == 3)\n    return wavenoise(mix(p.zy,p.xy,.5)*0.44);\n    #else\n    return wavenoise(mix(p.zy,p.xy,.1)*0.85);\n    #endif\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bumptex(p);\n    vec3 d = vec3(bumptex(p+e.xyy)-n0, bumptex(p+e.yxy)-n0, bumptex(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*.3);\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<15; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.01, .1 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    // zoom\n    p *= 0.65;\n    \n\tvec2 mo = iMouse.xy / iResolution.xy*1.5-.75;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo += vec2(time*0.03, time*0.04);\n    \n\tvec3 ro = vec3(.0,0.0,-5.7);\n    vec3 rd = vec3(p,1.2);\n\tro = rotx(ro, -mo.y*3.0);ro = roty(ro, mo.x*3.0);\n\trd = rotx(rd, -mo.y*3.0);rd = roty(rd ,mo.x*3.0);\n\t\n    float rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        //setup\n        vec3 pos = ro+rz*rd;\n        float crv= curv(pos);\n        vec3 nor = normal(pos);\n       \tvec3 fpos = fold(pos);\n        vec3 lgt = normalize(vec3(.0, 1., 0.9));\n        float shd = shadow( pos, lgt * 2., 0.2, 30.0 );\n        nor = bump(fpos, nor);\n        \n        //components\n        float dif = max(dot(nor,lgt),0.0)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt.x,lgt.y,-lgt.z)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,10.)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        float occ= crv*0.25+0.75;\n\t\t\n        //compose\n        col  = 0.2*occ + dif*vec3(1.0,0.8,0.6) \n            + 0.4*bac*vec3(1.0)*occ;\n        col *= 0.5*pow(tex(fpos),vec3(.5));\n        col += .4*fre*vec3(1.0) + .35*spe*vec3(1.0);\n        col *= ao(pos,nor);\n        col = pow(col,vec3(.75))*1.3;\n    }\n    \n    //vignetting from iq\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5;\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttGDr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[925, 925, 946, 946, 998], [1000, 1000, 1022, 1022, 1190], [1192, 1192, 1222, 1222, 1336], [1338, 1338, 1360, 1360, 1389], [1391, 1391, 1413, 1413, 2338], [2340, 2340, 2377, 2377, 2659], [2661, 2661, 2685, 2685, 2845], [2847, 2913, 2936, 2936, 3146], [3148, 3148, 3170, 3170, 3201], [3202, 3202, 3223, 3223, 3281], [3283, 3283, 3311, 3311, 3693], [3695, 3695, 3716, 3716, 4239], [4241, 4256, 4282, 4282, 4553], [4555, 4555, 4588, 4588, 4770], [4772, 4772, 4840, 4840, 5091], [5093, 5093, 5131, 5131, 5427], [5429, 5429, 5456, 5456, 5544], [5545, 5545, 5572, 5572, 5661], [5663, 5663, 5720, 5720, 7256]], "test": "timeout"}
{"id": "tttGW2", "name": "Antialiasing Lattice", "author": "LobsterCrew", "description": "First try on antialiasing with multisampling", "tags": ["antialiasing", "multiisampling"], "likes": 4, "viewed": 111, "published": "Public", "date": "1577656922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float ldist = 0.1;\nconst float llength = 0.5;\n\nfloat lattice(vec2 q)\n{\n    float res = 0.;\n    float a = atan(q.y, q.x) + .1 * iTime;\n    float r = length(q);\n    \n    q = vec2(r * cos(a), r * sin(a));\n    \n    for(int i = -3; i <= 3; i++)\n    {\n        res += smoothstep(0.011, 0.01, abs(q.y - float(i) * ldist));\n    }\n    res *= smoothstep(llength + .001, llength, abs(q.x));\n    return clamp(res, 0., 1.);\n}                  \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 q = 2.*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col;\n    //lattice on the left without AA\n    if (q.x < 0.)\n    {\n        float lat1 = lattice(q - vec2(-.9, 0.));\n        col = vec3(1, 1, 1) * lat1;\n    }\n    else\n    //lattice on the right with multisampling AA\n    {\n        float lat2 = 0.;\n        for (int i = -2; i <= 2; i++)\n        for (int j = -2; j <= 2; j++)\n        {    \n            lat2 += lattice(q - vec2(.9, 0.) - float(i + j) / (2. * iResolution.y)) / 25.;\n        }\n    \tcol = vec3(1, 1, 1) *lat2;\n    }\n    \n    // middle bar\n    col += smoothstep(.031, .03, abs(q.x));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 76, 76, 417], [440, 440, 497, 548, 1221]], "test": "ok"}
{"id": "tttGWr", "name": "Graphics Final", "author": "FelixTheWolfrick", "description": "Final for Graphics", "tags": ["pattern", "curtain"], "likes": 2, "viewed": 66, "published": "Public", "date": "1576073151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //UV\n    uv = floor(uv * 30.0);\n    \n    //Interchange Color\n    if(mod(uv.x, 2.0) == 0.0 && mod(uv.y, 2.0) == 0.0){\n       col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); \n    }else{\n    \tcol = vec3(0.0, 0.0, 0.0);   \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 527]], "test": "ok"}
{"id": "wdcSWf", "name": "shadetober #28 (ride)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["pseudo", "inktober", "shadertober", "shadetober", "inktober2019"], "likes": 8, "viewed": 675, "published": "Public API", "date": "1576924248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === original ===================================================================\n const vec3 GRASS = vec3(0., .5, 0.);\n const vec3 WHITE = vec3(1., 1., 1.);\n const vec3 WARN = vec3(1., 1., 0.);\n const vec3 ROAD = vec3(.2, .2, .2);\n const vec3 KERB = vec3(1., 0., 0.);\n const float ROWS = 20.;\n\n vec3 scanlineRoad(in vec2 p, in float row, in float scaling)\n {\n     row += floor(iTime * 20.);\n    \n \tvec2 mirp = abs(p);\n     mirp *= scaling;\n    \n     if (mirp.x < .02) { \n         return mix(WHITE, ROAD, mod(floor(row * .5), 2.)); \n     }\n     if (mirp.x < .53) { return ROAD; }\n     if (mirp.x < .55) { \n         return mix(WHITE, WARN, mod(floor(row * .333333), 2.)); \n     }\n     if (mirp.x < .6) { return ROAD; }\n     if (mirp.x < .64) {\n         return mix(WHITE, KERB, mod(row, 2.));\n     }\n     else { return GRASS; }\n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = (fragCoord * vec2(1., ROWS)) / iResolution.xy;\n     uv.y *= 4.;\n    \n     float row = floor(uv.y);\n     // float row = pow(2.0, floor(uv.y + 1.0) * 0.07); // suggestion from jaszunio15 for a perspective tweak\n     uv.y = fract(uv).y;\n     uv.x -= 0.5;\n    \n     uv.x += sin(iTime + row * .1) * .1;\n        \n     // Time varying pixel color\n     vec3 col = scanlineRoad(uv, row, row * .1 + 1.);\n\n     // Output to screen\n     fragColor = vec4(col,1.0);\n }\n// ================================================================================\n\n// below, some code golfing suggestion from Fabrice!\n\n// --- after some code golfing... -------------------------------------------------\n\n// vec3 scanlineRoad(vec2 p, float row, float scaling)\n// {\n//     row += floor(iTime * 20.);\n// \tfloat x = abs(p.x) * scaling;\n\n//     // some features are dashed lines which are sometimes white, sometimes a different color (e.g. check the red/white kerbs).\n//     // k is a scaling factor so that the on/off state can span over multiple rows\n// #define m(C,k) mod(floor(row * k), 2.) == 0. ? WHITE : C\n\n//     return   x < .02 ? m(ROAD,.5)\n//            : x < .52 ? ROAD \n//            : x < .55 ? m(WARN,.33)\n//            : x < .6  ? ROAD\n//            : x < .68 ? m(KERB,1.)\n//            :           GRASS; \n// }\n\n// void mainImage( out vec4 fragColor, in vec2 fragCoord )\n// {\n//     vec2 uv = (fragCoord * vec2(1., 4. * ROWS)) / iResolution.xy;\n//     float row = floor(uv.y);\n//     uv.y = fract(uv.y);\n//     uv.x += .1 * sin(iTime + row * .1) - .5;\n//     fragColor.rgb = scanlineRoad(uv, row, row * .1 + 1.);\n// }\n\n// --- after more code golfing ----------------------------------------------------\n// #define m(k)  int( k * (r + ceil(iTime*20.)) )%2 < 1 ? vec4(1) : //\n// #define mainImage(O,u)                         \\\n//     vec2  U = u/iResolution.xy;                \\\n//     float r = floor(U.y*=80.),                 \\\n//           x = abs( U.x + .1 * sin(iTime + r*.1) - .5 ) * (r*.1+1.); \\\n//     vec4 R = O+.2;                             \\\n//     O  =     x < .02 ? m(.5) R                 \\\n//            : x < .52 ? R                       \\\n//            : x < .55 ? m(.33) O.wwxw           \\\n//            : x < .6  ? R                       \\\n//            : x < .68 ? m(1.)  O.wxxw           \\\n//            :           vec4(0,.5,0,1)", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 361, 361, 830], [833, 833, 891, 942, 1412]], "test": "ok"}
{"id": "wdGSDd", "name": "Ripple Sheet", "author": "matan", "description": "Very basic attempt at making a ripple-like effect with ray tracing.", "tags": ["raytracing", "ripples"], "likes": 16, "viewed": 230, "published": "Public", "date": "1575320207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.1415926535897932384626433832795\n\nfloat kDiffuse = 0.8;\nfloat kAmbient = 0.4;\n\nvec3 kBackgroundColor = vec3(0.7, 0.75, 0.7);\n\nvec3 kLightSource = vec3(-5.0, 10.0, -5.0);\n\nfloat kInfinity = 1000000.0;\n\n// TODO: for some reason, passing around Ray (instead of direction/source directly)\n// causes the shader not to work on my android\n/* struct Ray {\n    vec3 direction;\n    vec3 source;\n}; */\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\n// 23 fps\n//const int kResolution = 50;\n//const float kSphereRadius = 0.02;\n//const int kLookRange = 13;\n\n// 55 fps\n    \nconst int kResolution = 30;\nconst float kSphereRadius = 0.05;\nconst int kLookRange = 8;\n\nconst float kRippleLength = 2.0 * M_PI / 8.0;\n\nstruct Ripple {\n    vec2 center;\n    float height;  \n};\n\nRipple getRippleForIndex(in int ripple_i) {\n    float[4] heights;\n    heights[0] = 0.22;\n    heights[1] = -0.1;\n    heights[2] = 0.2;\n    heights[3] = -0.2;\n    ripple_i = ripple_i % 8;\n    Ripple ripple;\n    \n    if (ripple_i <= 1) {\n        ripple.center = vec2(0.0, 0.0);\n    } else if (ripple_i <= 3) {\n        ripple.center = vec2(0.5, 0.0);\n    } else if (ripple_i <= 5) {\n        ripple.center = vec2(-0.5, 0.5);\n    } else if (ripple_i <= 7) {\n        ripple.center = vec2(0.5, 0.5);\n    }\n    if (ripple_i % 2 == 0) {\n    \tripple.height = heights[ripple_i / 2];\n    } else {\n        ripple.height = 0.0;\n    }\n    return ripple;\n}\n\nRipple getRipple() {\n    // Interpolate between the two ripples with a sigmoid function to make transitions smooth\n\tfloat ripple_f = iTime / kRippleLength;\n    int ripple_i = int(ripple_f + 0.5);\n    float d = ripple_f - float(ripple_i);\n    Ripple r1 = getRippleForIndex(ripple_i - 1);\n    Ripple r2 = getRippleForIndex(ripple_i);\n    float k = 10.0;\n    float s = 1.0 / (1.0 + exp(-k * d));\n    Ripple ripple;\n    ripple.center = r1.center * (1.0-s) + r2.center * s;\n    ripple.height = r1.height * (1.0-s) + r2.height * s;\n    \n    return ripple;\n}      \n\n// Get the height at (u,v) for the current ripple\nfloat getHeightForRipple(in Ripple ripple, in float u, in float v) {\n    float d = length(vec2(u, v) - ripple.center);\n    float y = ripple.height * cos(3.0 * d - 8.0 * iTime) - ripple.height;\n    // make the ripple weaker as it goes away from the ripple center\n    y /= (1.0 + d * 4.0);\n    return y;\n}\n\nSphere getSphere(in int i, in int j) {\n    \n    Ripple ripple = getRipple();\n    float t = iTime;\n    \n    float u = (float(i) / float(kResolution)) * 2.0 - 1.0;\n    float v = (float(j) / float(kResolution)) * 2.0 - 1.0;\n\n    // baseline waves\n    float y = 0.02 * sin(v * M_PI * 2.0 + 5.0 * iTime) + 0.02 * sin(u * M_PI * 2.0 + 5.0 * iTime);\n    y += getHeightForRipple(ripple, u, v);\n    \n    Sphere sphere;\n    sphere.center = vec3(u, y, v);\n \tsphere.radius = kSphereRadius;\n    sphere.color = vec3(0.5 + 2.0*y + 0.1*u, 0.5 + 2.0*y + 0.1*v, 0.7 + 0.15 * u + 0.15 * v + 0.6 * y);\n    return sphere;\n}\n    \n\nvoid traceRayThroughSphere(\n    in vec3 source, in vec3 direction, in Sphere sphere, out float hit_t) {\n    \n\thit_t = kInfinity;  \n\n    vec3 v = source - sphere.center;\n\n    float a = 1.0;\n    float b = 2.0*dot(v, direction);\n    float c = dot(v, v) - sphere.radius * sphere.radius;\n\n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0) {\n        float t1 = (-b + sqrt(det)) / (2.0 * a);\n        float t2 = (-b - sqrt(det)) / (2.0 * a);            \n        if (t1 > 0.0) {\n            hit_t = t1;\n        }\n        if (t2 > 0.0) {\n            hit_t = min(hit_t, t2);\n        }\n    }    \n}\n\n\nvoid traceRay(in vec3 source, in vec3 direction, out float mint, out vec3 hit_p, out vec3 over_p, out vec3 norm, out vec3 color, out bool is_hit) {\n    mint = 99999.0;\n    \n    // The following is kind of hacky code to make collision checking more efficient\n    // It checks collision of the ray with the y=0 plane and then only looks at spheres\n    // with (u,v) indices around that point.\n    // TODO: make more precise, taking into account current viewpoint and max/min height of\n    // spheres.\n    float plane_t = -source.y / direction.y;\n    vec3 plane_hit = source + direction * plane_t;\n\n    int hit_i = int((plane_hit.x + 1.0) * 0.5 * float(kResolution));\n    int hit_j = int((plane_hit.z + 1.0) * 0.5 * float(kResolution));\n    \n    int start_i = clamp(hit_i - kLookRange, 0, kResolution - 1);\n    int end_i = clamp(hit_i + kLookRange, 0, kResolution - 1);\n    int start_j = clamp(hit_j - kLookRange, 0, kResolution - 1);\n    int end_j = clamp(hit_j + kLookRange, 0, kResolution - 1);\n    \n    for (int sphere_i = start_i; sphere_i <= end_i; ++sphere_i) {\n        for (int sphere_j = start_j; sphere_j <= end_j; ++sphere_j) { \n            Sphere sphere = getSphere(sphere_i, sphere_j);\n            float cur_t;\n            traceRayThroughSphere(source, direction, sphere, cur_t);\n            if (cur_t < mint) {\n                mint = cur_t;\n                hit_p = cur_t * direction + source;\n                norm = normalize(hit_p - sphere.center);\n                color = sphere.color;\n            }\n        }\n    }\n    \n    vec3 col = kBackgroundColor;\n\n    is_hit = false;\n    \n    if (mint < 99998.0) {\n        vec3 light_v = normalize(kLightSource - hit_p);\n        vec3 light_reflect = light_v - 2.0 * norm * dot(light_v, norm);\n        \n\n        float cos_alpha = dot(norm, light_v);   \n        if (cos_alpha < 0.0) cos_alpha = 0.0;\n\n        col = kAmbient * color + kDiffuse * color * cos_alpha;\n        \n        is_hit = true;\n    }\n    \n    color = col;\n    over_p = hit_p + norm * 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = gl_FragCoord.xy / iResolution.xy;  \n\n    \n    float camera_dist = 7.0;\n    float camera_height = 4.0;\n    vec3 camera_p = vec3(sin(0.1*iTime) * camera_dist, camera_height, cos(0.1*iTime) * camera_dist);\n    \n    vec3 camera_look_at = vec3(0.0, 0.0, 0.0);\n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = normalize(camera_look_at - camera_p);\n    vec3 camera_right = cross(camera_forward, camera_up);\n    \n    float width = 2.0;\n    float height = width / iResolution.x * iResolution.y;  // 1.125\n    \n    vec3 screen_p = camera_forward * 5.0 + camera_p;\n    screen_p += (-width*0.5 + (p.x * width)) * camera_right;\n    screen_p += (-height*0.5 + p.y * height) * camera_up;\n    \n    vec3 d = normalize(screen_p - camera_p);\n\n    float mint = 99999.0;\n    vec3 hit_p;\n    vec3 over_p;\n    vec3 norm;\n    vec3 color;\n    bool is_hit;\n    traceRay(camera_p, d, mint, hit_p, over_p, norm, color, is_hit);\n    \n    fragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1433, 1433, 1453, 1547, 1984], [1992, 2042, 2110, 2110, 2345], [2956, 2956, 3059, 3059, 3542], [3545, 3545, 3692, 3692, 5557], [5559, 5559, 5616, 5616, 6588]], "test": "ok"}
{"id": "WdKXDt", "name": "Frozen Fractals", "author": "harry7557558", "description": "And one thought crystallizes like an icy blast...\n\nFake snowflakes generated by mirroring complex fractals. \n", "tags": ["fractal", "iteration", "snowflake"], "likes": 9, "viewed": 243, "published": "Public", "date": "1575344149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n#define AA 3\n\nint sn; \t// index of snowflake\n\nvec3 fractal(vec2 p){\n    p.x=-p.x-(cos(iTime)+5.0)/3.0;\n    vec3 col=vec3(0.0);\n    vec2 z = vec2(0.0);\n    int i;\n    for (i=0;i<64;i++){\n\n        // different iteration functions generate different snowflakes\n        if (sn==0) z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+p;\n        else if (sn==3) z=vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+p;\n        else if (sn==1) z=vec2(abs(z.x*z.x-z.y*z.y),2.0*z.x*z.y)+p;\n        else if (sn==4) z=vec2(abs(z.x*z.x-z.y*z.y),-2.0*z.x*z.y)+p;\n        else if (sn==2) z=vec2(z.x*z.x-z.y*z.y,-abs(2.0*z.x*z.y))+p;\n\n        // color function for Mandelbrot (https://www.shadertoy.com/view/wl2SWt)\n        float h = dot(z,z);\n        if (h>1.8447e+19){\n            float n = float(i)-log2(.5*log2(h))+4.;\n            float m = exp(-n*n/20000.);\n            n = mix(4.*pow((log(n+1.)+1.),2.),n,m);\n            m = 5.*sin(.1*(n-6.))+n;\n            col += vec3(\n                pow(sin((m-8.)/20.),6.),\n                pow(sin((m+1.)/20.),4.),\n                (.8*pow(sin((m+2.)/20.),2.)+.2)*(1.-pow(abs(sin((m-14.)/20.)),12.))\n            );\n            break;\n        }\n    }\n    if (i==64) col=vec3(1.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.3*length(iResolution.xy);\n    vec3 col=vec3(0.0);\n    sn = int(iTime/(2.*PI))%5;\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n    \t\tvec2 p = (fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)/s;\n            // rotation and mirroring\n    \t\tfloat m = length(p);\n    \t\tfloat a = abs(mod(atan(p.y,p.x)+iTime,PI/3.0)-PI/6.0);\n    \t\tcol += fractal(vec2(m*cos(a),m*sin(a)));\n        }\n    }\n    fragColor = vec4(col/float(AA*AA),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 95, 95, 1220], [1222, 1222, 1279, 1279, 1740]], "test": "timeout"}
{"id": "wdsXzS", "name": "Search Lights", "author": "Altcat", "description": "A very simple shader with RGB values moving and scaling with a sin function", "tags": ["simple"], "likes": 0, "viewed": 62, "published": "Public", "date": "1576097655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float time = sin(iTime) * 0.5;\n    \n    vec2 t = vec2(0.55 + time, 0.5);\n    vec2 t2 = vec2(0.75 - time, 0.5);\n    vec2 t3 = vec2(0.95 + time, 0.5);\n    float d = length(uv - t);\n    float d2 = length(uv - t2);\n    float d3 = length(uv - t3);\n    \n    float r = smoothstep(0.45 + time, 0.1 + time, d);\n    float g = smoothstep(0.45 + time, 0.1 + time, d2);\n    float b = smoothstep(0.45 + time, 0.1 + time, d3);\n    \n    // Output to screen\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 673]], "test": "ok"}
{"id": "WdVGzG", "name": "LAYERS_SJD", "author": "sux2bthatguy", "description": "For school", "tags": ["layers"], "likes": 0, "viewed": 33, "published": "Public", "date": "1575677860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 position = vec2(.70,.25);\nvec2 position2 = vec2(.30,.25);\nvec2 position3 = vec2(.50,.60);\n\nfloat radius = .2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Fixes scaling of the circles \n    uv.y *= (iResolution.y / iResolution.x);\n\n    //Move third circle up and down\n    position3.y *= abs(sin(iTime) * .6);   \n    \n    \n    vec4 circle = vec4(1.0,0.0,0.0,1.0); //Red Circle\n    \n    \n    vec4 circle2 = vec4(0.0, 1.0, 0.0, 1.0); //Green Circle\n    \n    \n    vec4 circle3 = vec4(0.0, 0.0, 1.0, 1.0); //Blue Circle \n    \n    \n    //Defines all 3 circles\n    circle *= step(length(uv - position), radius); \n    circle2 *= step(length(uv - position2), radius);\n    circle3 *= step(length(uv - position3), radius);\n    \n    \n    //Blending the circles together\n    vec4 composite = mix(circle, circle3, circle3.a);\n    composite = mix(composite, circle2, circle2.a);\n    \n    \n    //Display\n    fragColor = composite;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 173, 223, 1035]], "test": "ok"}
{"id": "wdVSDc", "name": "sofake", "author": "cmarangu", "description": "wip... 2020 1/17", "tags": ["fractal", "snowflake"], "likes": 14, "viewed": 616, "published": "Public API", "date": "1575520451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\n// TODO\n// - use digits of number as array (hard but super awesome)\n// - or just use nested for-loops\n// to traverse binary tree ignoring \"other side\" branches each iter\n// figure out what \"level\" using floor(log_2(y))\n\n\n\n\n \n\n#define debuglines 0\n\n\n\n// i know more\n#define PI 3.1415926535897932384626433832795028841971693993751058209749\n#define TAU (PI*2.)\n\n#define arg mod(float(iFrame)/60./6., 1.)\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = (fragCoord.xy-iResolution.xy/2.)/iResolution.y*2.;\n    float SDFp = 1e6;\n    float scalene = 1.;\n    \n    // weird slice morphthingy\n    //float qyx = atan(q.y, q.x)+rot+iTime*PI*.1;\n    float th = mod(atan(q.y, q.x)+arg*TAU/6., TAU/6.)+arg*TAU/6.;\n    float r = length(q);\n    q.x = r*cos(th);\n    q.y = r*sin(th);\n    \n    // rotate to make 6 branch from 1\n    th = mod(atan(q.y, q.x)+arg*TAU/6., TAU/6.)+PI*.5-PI*.5/3.;\n    r = length(q)*2.;\n    q.x = r*cos(th);\n    q.y = r*sin(th);\n    \n    // recursion\n    for (int i=0; i<10; ++i) {\n        q.x = abs(q.x);\n        // top branch\n        if ((q.y-.9)-q.x*.4+.1 > 0.) {\n            q.y -= .9;\n            q *= 1.6;\n            scalene *= 1.6;\n        }\n        // left and right branches\n        else if (q.x > .04) {\n            q.x -= .03;\n            q.y -= .23;\n            float qyx = atan(q.y, q.x)+PI*.27;\n            float qyxr = length(q);\n            q.x = qyxr*cos(qyx);\n            q.y = qyxr*sin(qyx);\n            // q.y -= .2;\n            q *= 3.;\n            scalene *= 3.;\n        }\n    }\n    \n    \n    // rounded rect\n    q.y -= .46;\n    q = abs(q);\n    q = max(q-vec2(.0, .4), 0.);\n    SDFp = min(SDFp, length(q)-.02);\n    // distance scaling correction\n    SDFp /= scalene;\n    \n    \n    \n    // rendering\n    vec3 retina;\n    if (SDFp <= 0.) {\n        retina = vec3(1.);\n    }\n    else {\n        retina = mix(\n            vec3(0., 1., 1.),\n            vec3(0., 0., 100./255.),\n            clamp(pow(SDFp, .2), 0., 1.)\n        );\n        #if debuglines\n        \tif (mod(SDFp-iTime*.1, .1) < .01) {\n            \tretina = mix(retina, vec3(0., 0., 0.), .4);\n            }\n        \t// if (mod(atan(dFdy(SDFp),dFdx(SDFp)), .25)<.05 && SDFp > .25) {\n            // \tretina = mix(retina, vec3(0., 0., 0.), .4);\n            // }\n        #endif\n        // retina = vec3(0.);\n    }\n    fragColor = vec4(retina, 1.);\n    \n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 406, 462, 462, 2362]], "test": "ok"}
{"id": "wdVSDy", "name": "\"Control\" Symbol Infinite Zoom", "author": "bitless", "description": "Symbol from \"Control\", video game by Remedy.", "tags": ["2d", "hex", "conrol"], "likes": 18, "viewed": 237, "published": "Public", "date": "1575289159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Control Infinite Zoom?\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n// Version 2.0 :)\n// The code is completely rewritten using Fabrice's advice, and thank you very much for that.\n\n#define hash1( n ) fract(sin(n)*43758.5453)\n#define PI 3.1415926\n#define BORDER1 0.025\n#define BORDER2 0.005\n\n\nvoid mainImage( out vec4 fragColor, in vec2 g)\n{\n    vec2 r = iResolution.xy\n    \t,st = (g+g-r)/r.y;\n    float a = atan(st.x,st.y)/PI\n    \t,sm = fwidth(a)*1.5\n    \t,iT = iTime\n    \t,c1 = (a*1.5+2.5)\n    \t,c2 = (a*1.5+2.);\n    c2 += (c2 < 1.) ? 3. : 0.;\n    float l = dot(abs(st),normalize(vec2(1.,1.73)));\n    l = log2(max(l,abs(st.x)))-iT;\n    vec2 c_gr = (mod(l,2.)>1.) ? vec2(c1,c2) : vec2(c2,c1) ;\n    float sm2 = fwidth(l);\n\n    float i = step(.5,hash1(floor(l)*floor(c_gr.x)));\n    float c = i > .5 \n        \t? 0. \n        \t:\tsmoothstep (0.,sm,abs(.5-fract(c_gr.y))-BORDER2)\n    \t\t\t* smoothstep (sm2, -sm2, abs(.5-fract(l))-.5+BORDER1)\n    \t\t\t* smoothstep(-8.,-1.,floor(l)+iT);\n\n    fragColor = vec4(vec3(c),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[556, 556, 604, 604, 1276]], "test": "ok"}
{"id": "wl33Rj", "name": "576 colors plasma!", "author": "Windless", "description": "Yeah ! You thought it was impossible, but Windless did it: 576 colors plasma running at 60 VBL! Take that, Amiga. Greetings fly to Ziggy Stardust, Patapom, MajorX, Arrakis, Roudoudou, Anal0g, Jylam, AlexKid, Luvia and all people from 3614 RTEL and #demofr", "tags": ["oldschool", "plasma", "demo"], "likes": 7, "viewed": 146, "published": "Public", "date": "1576835478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 HSV_to_RGB(vec3 hsv) {\n        \n  float C = hsv.z * hsv.y;\n  float X = C * (1. - abs( mod( (hsv.x * 6.),  2.) - 1.) );\n  float m = hsv.z - C;\n  \n  vec3 rgb;\n\n  switch (int(hsv.x * 6.)) {\n      case 0: rgb = vec3(C,X,0); break;\n      case 1: rgb = vec3(X,C,0); break;\n      case 2: rgb = vec3(0,C,X); break;\n      case 3: rgb = vec3(0,X,C); break;\n      case 4: rgb = vec3(X,0,C); break;\n      case 5: rgb = vec3(C,0,X); break;\n  }\n    \n  rgb += m;\n  \n  return rgb;\n}\n\nvec3 plasma(vec2 uv) {\n  // plasma\n  vec2 uvc = uv - 0.5;\n  uvc.x += cos(iTime) / 2.;\n  uvc.y += sin(iTime) / 2.;\n  vec3 hsv = vec3 (\n  \n    (cos(length(uvc*3.) * cos(uv.x*2. + iTime / 1.8) + iTime / 1.7) + 1.) / 2.1,\n    1.,\n    (sin(length(uvc*2.) * cos(uv.x*5. + iTime / 1.5) + iTime / 1.2) + 1.) / 2.\n\n  );\n\n  return hsv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  // discretise coordinates to make it all pixelised\n  uv.x = floor(uv.x * 320.) / 320.;\n  uv.y = floor(uv.y * 200.) / 200.;\n\n  vec3 hsv = plasma(uv);\n    \n  // discretise HSV color because who need 16.777.216 colors ?\n  hsv.x = floor(hsv.x * 24.) / 24.;\n  hsv.y = floor(hsv.y * 16. + 16.) / 32.;\n  hsv.z = floor(hsv.z * 24. + 8.) / 32.;\n  \n  fragColor = vec4(HSV_to_RGB(hsv), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 471], [473, 473, 495, 507, 800], [802, 802, 859, 907, 1330]], "test": "ok"}
{"id": "Wl33RN", "name": "Striped 2D Waves", "author": "Codax", "description": "Saw a fun GIF and wanted to re-create it.  First version went pretty quick until I realized there was a slight overlap on wave crests.  Love any feedback, improvements, and optimizations.  Thanks!", "tags": ["2d", "wave", "overlap", "stripe", "offset"], "likes": 7, "viewed": 384, "published": "Public API", "date": "1576037221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Miguel \"Codax\" Nieves\n// Twitter: @GameDevMig\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define PI 3.14159265359\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //How many stripes to show (even works best)\n    float stripes = 16.0;\n    //Wave Scroll Speed\n    float speed = 0.35;\n    \n    //Animated height of each wave from -1 to 1\n    float amplitude = sin(iTime * 2.0);\n    //float amplitude = (2.0 * abs( (2.0 * fract(iTime * 0.5))-1.0 ) - 1.0); //Triangle Wave\n    amplitude *= 0.68;//0.78;\n    \n    uv.y = uv.y * stripes;\n    uv.x = uv.x * 4.0;\n    \n    float waveID = round(uv.y);\n    \n    //Current Wave but cap the parts would overlap\n    vec2 waveUV = uv;\n    waveUV.x += iTime  * speed * (2.0 * step(1.0,mod(waveID,2.0)) - 1.);\n    waveUV.y += max(-0.5, min(0.5, sin(waveUV.x * PI * 2.0) * amplitude));\n\n\t//Use next line only if amplitude is between -0.5 and 0.5\n    //waveUV.y += sin(waveUV.x * PI * 2.0) * amplitude; \n    \n    //Hold on to the current Stripe value\n    float midWave = waveUV.y;\n    \n    //Calculate the Value from the Stripe Above\n    float upperWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID + 1.0,2.0)) - 1.));\n    upperWave = sin(upperWave * PI * 2.0) * amplitude;\n    \n    upperWave *= 1.0- step(0.5, fract(uv.y));\n    /*if (fract(uv.y) >= 0.5) //Optimized Out\n    {\n        upperWave = 0.0;\n    }*/\n                      \n\tupperWave += fract(uv.y);\n    upperWave = step(1.0, upperWave);\n    \n    //Calculate the Value from the Strip Below\n    float lowerWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID - 1.0,2.0)) - 1.));\n    lowerWave = sin(lowerWave * PI * 2.0) * amplitude;\n    \n    lowerWave *= step(0.5, fract(uv.y));\n    /*if (fract(uv.y) < 0.5) //Optimized Out\n    {\n        lowerWave = 0.0;\n    }\n\t*/\n    lowerWave += fract(uv.y);\n    lowerWave = step(0.00, lowerWave);\n\n\n    //Mix and Overlap\n\tmidWave *= upperWave;\t//Use the Upperwave to first mask the mid wave\n    upperWave *= step(0.000,midWave - waveID); //Then overlap the upperwave by the midwave\n    \n    waveUV.y *= (1.0 - upperWave); //Mask out the upper Wave\n    waveUV.y += upperWave * (uv.y + 1.0); //Add in the upper \n    \n\twaveUV.y *= lowerWave;  //Mask out the lower wave from the \n    waveUV.y += (1.0 - lowerWave) * (uv.y - 1.0); //Put in the overlap from the lower wave\n\n   \n    //Create a color ID from 0.0 - 1.0\n    float colorID = floor( waveUV.y ) / stripes;\n    \n    float ct = iTime * 0.1;\n    //vec3 col = pal( colorID, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,1.0),vec3(0.4 * sin(ct*1.23),0.40 * cos(ct*2.14),0.80 * sin(-ct)) );\n    vec3 col = pal( colorID, vec3(0.5,0.5,1.0),vec3(0.5,0.5,1.0),vec3(2.0, 1.0, 0.0),vec3(0.2+sin(ct*1.23), 0.2+cos(ct*2.14), 0.1 + sin(-ct)));\n    \n    //Darken the bottom few waves\n    col *= smoothstep(1.0, 0.6, 1.0 - colorID);\n\n    // Wave Debug\n    //col = vec3(colorID);// * fract(uv.y));\n\n    // Output to screen \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl33RN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1138, 1212, 1280, 1280, 1323], [1325, 1325, 1382, 1432, 4255]], "test": "ok"}
{"id": "Wl33RS", "name": "Elevating Platter", "author": "dr2", "description": "More floppy tube stuff", "tags": ["torus", "tube", "coordinates", "flexing"], "likes": 10, "viewed": 285, "published": "Public API", "date": "1576607121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Elevating Platter\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\n\nvec4 hxHit;\nvec3 ltPos;\nfloat tCur, dstFar, aMin, dLoop, aLoop, hPlat, rCyl;\nint idObj;\nconst float nSeg = 5.;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  vec2 b, c;\n  float dMin, d, dn, lb, dr, a, bRad, bHt, rSph;\n  dMin = dstFar;\n  bRad = 14.;\n  bHt = 0.4;\n  rSph = 1.1 * rCyl;\n  p.y -= rSph + bHt;\n  pp = p;\n  a = (length (p.xz) > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p.xz = Rot2D (p.xz, 2. * pi * (floor (5. * a + 0.5) / 5.));\n  p.x += bRad;\n  p.xy = Rot2D (p.xy, - aLoop);\n  q = p;\n  d = PrSphDf (q, rSph);\n  DMIN (2);\n  for (float k = 0.; k < nSeg; k ++) {\n    q = p;\n    q.xy = Rot2D (q.xy, 0.5 * pi);\n    q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n    b = vec2 (length (q.xy) - dLoop, q.z);\n    lb = length (b);\n    c = atan (vec2 (q.y, b.x), vec2 (- q.x, b.y)) * vec2 (4. * dLoop / pi, 1.) / pi;\n    dr = SmoothBump (0.15, 0.85, 0.1, mod (4. * c.x +\n       3. * c.y * (mod (float (k), 2.) - 0.5), 1.)) - 0.5;\n    dn = max (min (abs (lb - 0.9 * rCyl) + 0.1 * dr * rCyl, lb - 0.6 * rCyl),\n       dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi))));\n    if (dn < d) {\n      d = dn;\n      hxHit = vec4 (c, lb, k);\n    }\n    p.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n    p.x = - p.x;\n  }\n  DMIN (1);\n  q = p;\n  d = PrSphDf (q, rSph);\n  DMIN (2);\n  q = pp;\n  q.y = abs (q.y - 0.5 * hPlat) - (0.5 * hPlat + rSph + bHt);\n  d = PrRoundCylDf (q.xzy, bRad + 4., 0.2, bHt);\n  DMIN (3);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (2. * h, 0.1, 3.);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltDir, vn, col;\n  vec2 p, ip;\n  float dstObj, dstGrnd, tCyc, sLoop, vDotL, sh, att, c;\n  tCyc = 10.;\n  aMin = 0.45;\n  sLoop = aMin + 20. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (tCur / tCyc, 1.)), 4.);\n  aLoop = 0.25 * pi / sLoop;\n  dLoop = 6. * 0.25 * pi * sLoop;\n  hPlat = 2. * nSeg * dLoop * sin (aLoop);\n  rCyl = 2.;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    ltDir = normalize (ltPos);\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vDotL = max (dot (vn, ltDir), 0.);\n      if (idObj == 1) {\n        if (hxHit.z < 0.75 * rCyl) {\n          hxHit.x -= 1.5 * hxHit.y * (mod (hxHit.w, 2.) - 0.5);\n          p = hxHit.xy * vec2 (2. * sqrt3, 3.);\n          ip = PixToHex (p);\n          c = mod (dot (mod (2. * ip + ip.yx, 3.), vec2 (1., 2.)), 3.);\n          col4 = (c == 0.) ? vec4 (0.7, 0.6, 0., 0.2) : ((c == 1.) ? vec4 (0.8, 0.8, 0.4, 0.2) :\n             vec4 (0.4, 0.2, 0., 0.2));\n          col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.07, HexEdgeDist (p - HexToPix (ip)));\n        } else col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n        vDotL *= vDotL;\n      } else if (idObj == 2) {\n        col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n        vDotL *= vDotL;\n      } else if (idObj == 3) {\n        col4 = vec4 (0.8, 0.85, 0.8, 0.2);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      col4 = vec4 (0.43, 0.4, 0.4, 0.1) * (0.8 + 0.2 * Fbm2 (0.5 * ro.xz));\n      vDotL = max (dot (vn, ltDir), 0.);\n    }\n    att = smoothstep (0.96, 0.985, dot (normalize (ltPos - ro), ltDir));\n    sh = ObjSShadow (ro, ltDir, length (ltPos - ro));\n    col = att * (col4.rgb * (0.2 + 0.8 * sh * vDotL) +\n       0.2 * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, ltEl, ltAz, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.05 * pi;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.6 * pi * sin (0.01 * 2. * pi * tCur);\n  }\n  el = clamp (el, -0.2 * pi, 0.02 * pi);\n  zmFac = 2.4;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 20. /*3. * pi * nSeg * aMin * sin (0.25 * pi / aMin)*/, -70.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 300.;\n  ltEl = -0.3 * pi * (1. + 0.15 * sin (0.1 * 2. * pi * tCur));\n  ltAz = pi + 0.2 * pi * cos (0.125 * 2. * pi * tCur);\n  ltPos = vec3 (0., 0., 200.);\n  ltPos.yz = Rot2D (ltPos.yz, ltEl);\n  ltPos.xz = Rot2D (ltPos.xz, ltAz);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl33RS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[616, 616, 638, 638, 1944], [1946, 1946, 1979, 1979, 2177], [2179, 2179, 2200, 2200, 2397], [2399, 2399, 2448, 2448, 2703], [2705, 2705, 2729, 2729, 2959], [2961, 2961, 2985, 2985, 3045], [3047, 3047, 3075, 3075, 3155], [3157, 3157, 3192, 3192, 5085], [5087, 5087, 5140, 5140, 6471], [6473, 6473, 6506, 6506, 6533], [6535, 6535, 6592, 6592, 6756], [6758, 6758, 6794, 6794, 7000], [7002, 7002, 7032, 7032, 7145], [7147, 7147, 7204, 7204, 7287], [7321, 7321, 7345, 7345, 7475], [7477, 7477, 7502, 7502, 7688], [7690, 7690, 7711, 7711, 7866]], "test": "error"}
{"id": "wl33RX", "name": "arbolv1", "author": "jorge2017a1", "description": "arbolv1", "tags": ["arbolv1"], "likes": 1, "viewed": 51, "published": "Public", "date": "1577032318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n///-----------------------------------------\n//referencia  Created by bluebean in 2019-12-17\n//https://www.shadertoy.com/view/Wtc3DM\n\n#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.1\n#define CR30 0.3\n#define CR31 1.0\n#define CR32 0.2\n#define CR33 0.1\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 1\n\n///-----------------------------------------\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 3.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//æ ¹æ®må¨colors[1]å°colors[n-1]ä¹é´è¿è¡æ ·æ¡çº¿æå¼\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = ceil(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\n\n///--------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    case 11:\n        \t\n        \tm = marble(glpRoRd);\n        \tm = 0.5*m;\n        \treturn marbleColor(m)*vec3(.9,0.4,0.3);\n    case 12:\n        \t//verde\n        \t\n        \tm = marble(glpRoRd);\n        \tm = 0.5*m;\n        \treturn marbleColor(m)*vec3(0.0,1.0,0.0);\n    case 13:\n        \t//azul\n        \t\n        \tm = marble(glpRoRd);\n        \tm = 0.5*m;\n        \treturn marbleColor(m)*vec3(0.1,0.0,1.0);\n        \n        \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    //res = opU(res, vec2(planeDist, cPlane));\n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n         } \n     } \n    \n    float bxc1=sdBox(p-vec3(0,0,0),vec3(1,0,1));  //piso xz\n    float bxc2=sdBox(p-vec3(0,0,0),vec3(0.1,1.8,0.1));\n    \n    float bxc3=sdBox(p-vec3(0,0,4),vec3(1,1,0));\n    \n    \n    float spp1=sdSphere(p-vec3(0.0),4.5);\n    \n    float bxc4=sdBox(p-vec3(-6,0,3),vec3(1,6,0));\n    float spp2=sdSphere(p-vec3(-11.,7.,3.),4.5);\n    \n \n    res=opU(res, vec2(bxc1,11));\n    res=opU(res, vec2(bxc2,3));\n    \n    res=opU(res, vec2(spp1,12));\n    \n    res=opU(res, vec2(bxc4,11));\n    \n    res=opU(res, vec2(spp2,12));\n    \n                    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));\n    vec3 ro = vec3(0, 3.5, -8.5);\n\n    //vec3 ro = vec3(0, 2.5, iTime*2.0);\n    \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n    //vec3 rd = normalize(vec3(uv.x+iMouse.x/iResolution.y, uv.y+iMouse.y/iResolution.y, 1.0));\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\t\n   \n    \n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    //float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    \n    \n    float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2+dif3)/2.0;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1042, 1059, 1092, 1092, 1157], [1158, 1176, 1212, 1212, 1281], [1282, 1297, 1328, 1328, 1478], [1479, 1499, 1535, 1535, 1622], [1623, 1639, 1671, 1699, 1760], [1813, 1813, 1859, 1859, 1891], [1893, 1893, 1935, 1935, 1967], [1969, 1969, 2016, 2016, 2049], [2052, 2052, 2081, 2081, 2207], [2261, 2261, 2283, 2283, 2378], [2380, 2380, 2408, 2408, 2909], [2911, 2911, 2932, 2932, 3081], [3083, 3146, 3172, 3172, 4228], [4280, 4280, 4308, 4308, 5721], [5775, 5884, 5921, 5921, 5956], [5959, 5959, 5984, 5984, 7104], [7107, 7107, 7141, 7141, 7375], [7378, 7378, 7402, 7402, 7634], [7638, 7638, 7662, 7662, 8047], [8050, 8050, 8076, 8076, 8440], [8485, 8485, 8521, 8521, 8638], [8640, 8640, 8676, 8676, 8794], [8796, 8796, 8868, 8868, 8895], [8897, 8897, 8954, 8954, 10120]], "test": "error"}
{"id": "Wl33z2", "name": "Nested Circles 2d", "author": "yp3y5akh0v", "description": "Nested Circles", "tags": ["circles"], "likes": 7, "viewed": 92, "published": "Public", "date": "1576915163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 80.\n#define L 20.\n#define PI radians(180.)\n#define s(n, k) (n / sqrt(k))\n#define t iTime\n\nfloat getCircles(vec2 uv, float i, float attempt, float flip) {\n    float a = 2. * PI * (i + 1.) / s(N, attempt);\n    float offset = 0.5 - mix(0., 0.45, (attempt + 1.) / L);\n    float r = 0.0003 - mix(0., 0.0002, (attempt + 1.) / L);\n    float x0 = (offset + r) * cos(a - offset * flip * t);\n    float y0 = (offset + r) * sin(a + offset * flip * t);        \n    float d = length(uv - vec2(x0, y0));         \n    float q = r / d;\n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    float s = 1.;\n    \n    for (float k = 1.; k < L; k++) {\n        for (float i = 0.; i < N; i++) {\n            if (i >= s(N, k)) break;\n            float q = getCircles(uv, i, k, s=-s);\n            col += vec3(q);\n        }    \n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl33z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 163, 163, 544], [546, 546, 603, 603, 969]], "test": "timeout"}
{"id": "Wl33zB", "name": "boxTest", "author": "BrianDeLange", "description": "creating a box test", "tags": ["3d"], "likes": 2, "viewed": 117, "published": "Public", "date": "1576704146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INFINITY 10000.\n\nmat4 inv(mat4 matrix)\n{\n    mat4 m = mat4(1., 0., 0., 0.,\n                  0., 1., 0., 0.,\n                  0., 0., 1., 0.,\n                  0., 0., 0., 1.);\n    \n    for(int row = 0; row < 4; row++){\n        float v = 1./matrix[row][row];\n        for(int col = 0; col < 4; col++){\n            matrix[row][col] *= v;\n            m[row][col] *= v;\n        }\n        for(int r = 0; r < 4; r++){\n            if(r != row){\n                float e = -matrix[r][row];\n                for(int col = 0; col < 4; col++){\n                    matrix[r][col] += e*matrix[row][col];\n                    m[r][col] += e*m[row][col];\n                }\n            }\n        }\n    }\n    return m;\n}\n\nmat4 Camera(vec3 position, vec3 forward, vec3 upguide)\n{\n    forward = normalize(forward);\n    vec3 right = normalize(cross(upguide, forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    return mat4(right.x, up.x, forward.x, position.x,\n                right.y, up.y, forward.y, position.y,\n                right.z, up.z, forward.z, position.z,\n                0., 0., 0., 1.);\n}\n\nmat4 rotateX(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(1., 0., 0., 0.,\n                0., c , -s, 0.,\n                0., s , c , 0.,\n                0., 0., 0., 1.);\n}\n\nmat4 rotateY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(c , 0., s , 0.,\n                0., 1., 0., 0.,\n                -s, 0., c , 0.,\n                0., 0., 0., 1.);\n}\n\nmat4 rotateZ(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(c , -s, 0., 0.,\n                s , c , 0., 0.,\n                0., 0., 1., 0.,\n                0., 0., 0., 1.);\n}\n\nmat4 GetBoxTransform(vec3 position, vec3 scale, vec3 rotation)\n{\n    mat4 rot = rotateX(rotation.x)*rotateY(rotation.y)*rotateZ(rotation.z);\n    return mat4(scale.x, 0., 0., 0.0,\n                0., scale.y, 0., 0.0,\n                0., 0., scale.z, 0.0,\n                0., 0., 0., 1.)*\n        rot*\n        mat4(1., 0., 0., position.x,\n             0., 1., 0., position.y,\n             0., 0., 1., position.z,\n             0., 0., 0., 1.);\n}\n    \nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Plane{\n    vec3 position;\n    vec3 normal;\n};\n    \nstruct Box{\n    vec3 position;\n    mat4 transform;\n};\n    \nstruct BoundingBox{\n    vec3 Min;\n    vec3 Max;\n};\n\nstruct Data{\n    vec3 normal;\n    float dist;\n};\n\n    \nvec3 getPostion(Ray ray, float dist){\n\n    return ray.origin + ray.direction * dist;\n\n}\n\nData distPlane(Ray ray, Plane plane)\n{\n    Data d;\n    float denom = dot(plane.normal, ray.direction);\n    if (denom < 0.)\n    {\n        vec3 originPosition = plane.position - ray.origin;\n        \n        d.normal = plane.normal;\n        d.dist = dot(originPosition, plane.normal) / denom;\n        \n        return d;\n    }\n    d.dist = INFINITY;\n    return d;\n}\n\nfloat checkPosition(Plane plane, Ray ray, Box box){\n    vec3 vecMin = vec3(-.5, -.5, -.5);\n    vec3 vecMax = vec3(.5, .5, .5);\n\n    \n    float dist = distPlane(ray, plane).dist;\n    vec3 intersectionPoint = (getPostion(ray, dist));\n    if(dist > 0. && \n       intersectionPoint.x > vecMin.x-0.001 && intersectionPoint.x < vecMax.x+0.001 && \n       intersectionPoint.y > vecMin.y-0.001 && intersectionPoint.y < vecMax.y+0.001 && \n       intersectionPoint.z > vecMin.z-0.001 && intersectionPoint.z < vecMax.z+0.001)\n        return dist;\n    return INFINITY;\n}\n\n\nData distBox(Ray ray, Box box)\n{\n    Data d;\n    d.dist = INFINITY;\n    ray.origin = (vec4((ray.origin.xyz), 1.)*inverse(box.transform)).xyz;\n    ray.direction = (vec4((ray.direction.xyz), 0.)*inverse(box.transform)).xyz;\n    \n    vec3 Fractal = 1./ray.direction;\n    \n    float Vmin = -1.;\n    float Vmax =  1.;\n    \n    float t1 = (Vmin - ray.origin.x) * Fractal.x;\n    float t2 = (Vmax - ray.origin.x) * Fractal.x;\n    float t3 = (Vmin - ray.origin.y) * Fractal.y;\n    float t4 = (Vmax - ray.origin.y) * Fractal.y;\n    float t5 = (Vmin - ray.origin.z) * Fractal.z;\n    float t6 = (Vmax - ray.origin.z) * Fractal.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (!(tmax < 0. || tmin > tmax))\n    {\n        d.dist = tmin;\n        vec3 centerVec = d.dist*ray.direction+ray.origin;\n        if(centerVec.x > 0.9999) d.normal = vec3(1., 0., 0.);\n        if(centerVec.x < -0.9999) d.normal = vec3(-1., 0., 0.);\n        if(centerVec.y > 0.9999) d.normal = vec3(0., 1., 0.);\n        if(centerVec.y < -0.9999) d.normal = vec3(0., -1., 0.);\n        if(centerVec.z > 0.9999) d.normal = vec3(0., 0., 1.);\n        if(centerVec.z < -0.9999) d.normal = vec3(0., 0., -1.);\n    }\n\n    return d;\n}\n\nBoundingBox calculateBoundingBox(Box box){\n    BoundingBox b;\n    \n    mat4 inv = box.transform;\n\n    float xPos = inv[0][3];\n    float yPos = inv[1][3];\n    float zPos = inv[2][3];\n    \n    float x = (abs(inv[0][0])+abs(inv[0][1])+abs(inv[0][2]));\n    float y = (abs(inv[1][0])+abs(inv[1][1])+abs(inv[1][2]));\n    float z = (abs(inv[2][0])+abs(inv[2][1])+abs(inv[2][2]));\n    \n    float minX = xPos-x;\n    float minY = yPos-y;\n    float minZ = zPos-z;\n    \n    float maxX = xPos+x;\n    float maxY = yPos+y;\n    float maxZ = zPos+z;\n    \n    b.Min = vec3(minX, minY, minZ);\n    b.Max = vec3(maxX, maxY, maxZ);\n    \n    return b;\n}\n\nbool RenderBoundingBox(Ray ray, BoundingBox box)\n{\n    \n    vec3 Fractal = 1./ray.direction;\n    \n    vec3 Vmin = box.Min;\n    vec3 Vmax = box.Max;\n    \n    float t1 = (Vmin.x - ray.origin.x) * Fractal.x;\n    float t2 = (Vmax.x - ray.origin.x) * Fractal.x;\n    float t3 = (Vmin.y - ray.origin.y) * Fractal.y;\n    float t4 = (Vmax.y - ray.origin.y) * Fractal.y;\n    float t5 = (Vmin.z - ray.origin.z) * Fractal.z;\n    float t6 = (Vmax.z - ray.origin.z) * Fractal.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (!(tmax < 0. || tmin > tmax))\n    {\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 camPosition = vec3(0., 0., -4.);\n    mat4 cam = Camera(camPosition, vec3(0., 0., 1.), vec3(0., 1., 0.));\n    \n    Ray ray;\n    ray.origin = camPosition;\n    ray.direction = normalize(cam * vec4(uv.xy, 1.0, 0.)).xyz;\n    \n    Plane plane;\n    plane.position = vec3(0., -3., 0.);\n    plane.normal = vec3(0., 1., 0.);\n    \n    vec3 pos = vec3(0.);\n    \n    vec2 mouseUv = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    Ray positionRay;\n    positionRay.origin = camPosition;\n    positionRay.direction = normalize(cam * vec4(mouseUv, 1.0, 0.)).xyz;\n    \n    Data p = distPlane(positionRay, plane);\n    pos = p.dist * positionRay.direction + positionRay.origin;\n    \n    Box boxes[3];\n    boxes[0].transform = GetBoxTransform(pos, vec3(0.5, 0.5, 0.5), vec3(iTime, iTime, 0.));\n    //boxes[0].transform = rotateX(iTime*2.)*(rotateZ(iTime)*boxes[0].transform);\n    boxes[1].transform = GetBoxTransform(vec3(-3., 0., 6.), vec3(2., 2., 1.), vec3(2.*iTime, 0., 2.*iTime));\n    boxes[2].transform = GetBoxTransform(vec3( 3., 0., 6.), vec3(2., 2., 1.), vec3(iTime, 0., 2.*iTime));\n    \n    BoundingBox boundingBoxes[3];\n    boundingBoxes[0] = calculateBoundingBox(boxes[0]);\n    boundingBoxes[1] = calculateBoundingBox(boxes[1]);\n    boundingBoxes[2] = calculateBoundingBox(boxes[2]);\n    \n    vec3 col;\n    Data d = distPlane(ray, plane);\n    //d.dist = INFINITY;\n    vec3 intersectPoint = ray.direction*d.dist+ray.origin;\n    vec3 localNormal = vec3(0., 1., 0.);\n    for(int i = 0; i < 3; i++){\n        Data d2 = distBox(ray, boxes[i]);\n        if(d2.dist < d.dist) {\n            d = d2;\n            localNormal = d.normal;\n            d.normal = (vec4(d.normal, 0.)*boxes[i].transform).xyz;\n            intersectPoint = (boxes[i].transform* vec4((inverse(boxes[i].transform)*vec4(ray.direction, 0.)).xyz*d.dist, 0.)).xyz+\n                              ray.origin;\n            \n        }\n    }\n                    \n    vec3 lights[4];\n    lights[0] = vec3(0., 0., 0.);\n    lights[1] = vec3(-6., 4., -5.73);\n    lights[2] = vec3(2., -1., -2.423);\n    lights[3] = vec3(0., -3., -4.5);\n    \n    for(int i = 0; i < 4; i++){\n        if(d.dist > 0. && d.dist < INFINITY) col += (localNormal*0.5+0.5) * dot(d.normal, \n                                        normalize(lights[i]-intersectPoint));\n    }\n\n    fragColor = vec4(col,1.0);\n    \n    for(int i = 0; i < 3; i++){\n        if(RenderBoundingBox(ray, boundingBoxes[i])){\n            fragColor += vec4(1., 0., 0., .5);\n        }\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl33zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 48, 48, 709], [711, 711, 767, 767, 1104], [1106, 1106, 1133, 1133, 1321], [1323, 1323, 1350, 1350, 1538], [1540, 1540, 1567, 1567, 1755], [1757, 1757, 1821, 1821, 2200], [2483, 2483, 2520, 2520, 2570], [2572, 2572, 2610, 2610, 2933], [2935, 2935, 2986, 2986, 3492], [3495, 3495, 3527, 3527, 4771], [4773, 4773, 4815, 4815, 5403], [5405, 5405, 5455, 5455, 6094], [6096, 6096, 6153, 6153, 8707]], "test": "error"}
{"id": "Wl3GDB", "name": "plane-cuadrado", "author": "jorge2017a1", "description": "plane-cuadrado", "tags": ["planecuadrado"], "likes": 1, "viewed": 53, "published": "Public", "date": "1577382281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge flores p. //fecha 26-dic--2019\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n///--------------------------------------------\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\t//return textureLod(iChannel0,(p+.5)/32.,-16.).x;\n    return texture(iChannel0,p.xy).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*25.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n///--------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n\tcase 11:\n        //float pattern = fract( 1.-Granite( glpRoRd)*8.) ;\t\n        float pattern = abs( 1.-Granite( glpRoRd)*0.15) ;\t\n        //return Granite(glpRoRd)*vec3(0.2,0.5,0.3);\n        return pattern*vec3(1.0);\n     case 12:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd); \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n    float d, dif1, dif2;\n   vec3 pp;\n    vec2 res;\n    \n    d=999.9;\n    float planeDist = p.y;\n    pp=p;\n   \n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n             res=vec2(res.x, 12);\n         } \n     } \n    \n            \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));\n    vec3 ro = vec3(0, 3.5, -8.5);\n\n    //vec3 ro = vec3(0, 2.5, iTime*2.0);\n    \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n    //vec3 rd = normalize(vec3(uv.x+iMouse.x/iResolution.y, uv.y+iMouse.y/iResolution.y, 1.0));\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\t\n   \n    \n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    //float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    \n    \n    float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2+dif3)/2.0;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3GDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[385, 402, 435, 435, 500], [501, 519, 555, 555, 624], [625, 640, 671, 671, 821], [822, 842, 878, 878, 965], [966, 982, 1014, 1042, 1103], [1106, 1116, 1152, 1152, 1425], [1478, 1478, 1524, 1524, 1556], [1558, 1558, 1600, 1600, 1632], [1634, 1634, 1681, 1681, 1714], [1717, 1717, 1746, 1746, 1872], [1874, 1874, 1910, 1910, 2027], [2029, 2029, 2065, 2065, 2183], [2237, 2237, 2260, 2260, 2419], [2422, 2422, 2449, 2449, 2627], [2678, 2690, 2712, 2712, 3020], [3022, 3022, 3047, 3047, 3237], [3285, 3285, 3313, 3313, 4596], [4650, 4759, 4796, 4796, 4831], [4834, 4834, 4859, 4859, 5362], [5365, 5365, 5399, 5399, 5633], [5636, 5636, 5660, 5660, 5892], [5896, 5896, 5920, 5920, 6305], [6308, 6308, 6334, 6334, 6698], [6704, 6704, 6761, 6761, 7927]], "test": "error"}
{"id": "wl3GDf", "name": "Raymarch Tutorial v03", "author": "tombla", "description": "Raymarching tutorial exercise with composite object and simple anti alias.", "tags": ["raymarch", "tutorial", "antialias", "composite"], "likes": 2, "viewed": 249, "published": "Public API", "date": "1577735889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on youtube tutorial\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// Raymarched scene with antialiasing (9 samples).\n\n#define SPHERE_POS_1 vec3(0., 0.7, 6.)\n#define SPHERE_RAD_1 1.\n#define SPHERE_POS_2 vec3(-0.6, 0.7, 5.4)\n#define SPHERE_RAD_2 0.5\n#define PLANE_POS 0.\n#define LIGHT_POS vec3(-0., 6., 2.)\n#define JUMP_SPEED 1.4\n\n#define AA_PIXEL_STEP 0.8\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define CLOSENESS 0.01\n\nvec2 rescale(in vec2 p) {\n    return vec2((p - 0.5 * iResolution.xy) / iResolution.y);\n}\n\nfloat twoUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat twoSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nfloat twoIntersect(float a, float b) {\n    return max(a, b);\n}\n\n// Get distance to sphere 1.\nfloat getDistSphere1(vec3 p) {\n    vec3 spherePos = SPHERE_POS_1;\n    float x = mod(iTime * JUMP_SPEED, 2.);\n    spherePos.y += 1.7 * (1. - (x - 1.) * (x - 1.));\n    float dS = length(spherePos - p) - SPHERE_RAD_1;\n    return dS;\n}\n\n// Get distance to sphere 2.\nfloat getDistSphere2(vec3 p) {\n    vec3 spherePos = SPHERE_POS_2;\n    float x = mod(iTime * JUMP_SPEED, 2.);\n    spherePos.y += 1.7 * (1. - (x - 1.) * (x - 1.));\n    float dS = length(spherePos - p) - SPHERE_RAD_2;\n    return dS;\n}\n\n// Get distance to both spheres.\nfloat getDistSpheres(vec3 p) {\n    float dS1 = getDistSphere1(p);\n    float dS2 = getDistSphere2(p);\n    return twoSubtract(dS1, dS2);\n}\n\n// Get distance to plane and spheres.\nfloat getDistAll(vec3 p) {\n    float dS = getDistSpheres(p);\n    float dP = p.y - PLANE_POS;\n    return min(dS, dP);\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n    float dist = 0.;\n    for(int i=0; i < MAX_STEPS; ++i) {\n        vec3 ray = origin + direction * dist;\n        float step = getDistAll(ray);\n        dist += step;\n        if (step < CLOSENESS || dist > MAX_DIST) break;\n    }\n    return min(dist, MAX_DIST);\n}\n\nvec3 getNormal(vec3 p) {\n    float toSurface = getDistAll(p);\n    vec2 e = vec2(0.01, 0.);\n    vec3 plane = toSurface - vec3(\n        getDistAll(p - e.xyy),\n        getDistAll(p - e.yxy),\n        getDistAll(p - e.yyx));\n    return normalize(plane);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = LIGHT_POS;\n    lightPos.xz += 2. * vec2(sin(iTime), cos(iTime));\n    vec3 lightVector = normalize(lightPos - p);\n    vec3 surfaceVector = getNormal(p);\n//    float diffusion = dot(surfaceVector, lightVector);\n    float diffusion = dot(lightVector, surfaceVector);\n    diffusion = clamp(diffusion, 0., 1.);\n\n    float toLight = rayMarch(p + surfaceVector * 1.05 * CLOSENESS, lightVector);\n    if (toLight < length(p - lightPos)) {\n        diffusion *= 0.3;\n    }\n\n    return diffusion;\n}\n\n// Returns non-aliased distance (x) and diffusion (y)\nvec2 singleRay(vec2 uv) {\n    // Camera position\n    vec3 ro = vec3(0., 1., 0.);\n    // Camera direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    // Distance to a shape.\n    float dist = rayMarch(ro, rd);\n    // Point at the shape\n    vec3 ray = ro + rd * dist;\n    // Light diffusion\n    float diffusion = getLight(ray);\n    return vec2(dist, diffusion);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv1 = rescale(fragCoord-AA_PIXEL_STEP);\n    vec2 uv2 = rescale(fragCoord+AA_PIXEL_STEP);\n    vec4 uv = vec4(uv1, uv2);\n    vec3 color = vec3(1.);\n\n    vec2 scene = vec2(0, 0);\n    for(float dx = -1.; dx <= 1.1; dx += 1.) {\n        for(float dy = -1.; dy <= 1.1; dy += 1.) {\n            vec2 uv = rescale(vec2(fragCoord.x + dx * AA_PIXEL_STEP, fragCoord.y + dy * AA_PIXEL_STEP));\n            scene += singleRay(uv);\n        }\n    }\n    scene /= 9.;\n    float dist = scene.x;\n    float diffusion = scene.y;\n    color *= diffusion;\n    // Sky\n    vec3 sky = vec3(0.3, 0.3, 0.8);\n    float skyMix = smoothstep(MAX_DIST * 0.5, MAX_DIST * 0.9, dist);\n\n    // Final color\n    vec3 final = mix(color, sky, skyMix);\n\n\n    fragColor = vec4(final, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3GDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 459, 459, 522], [524, 524, 558, 558, 582], [584, 584, 621, 621, 646], [648, 648, 686, 686, 710], [712, 741, 771, 771, 972], [974, 1003, 1033, 1033, 1234], [1236, 1269, 1299, 1299, 1405], [1407, 1445, 1471, 1471, 1563], [1565, 1565, 1610, 1610, 1872], [1874, 1874, 1898, 1898, 2124], [2126, 2126, 2150, 2150, 2657], [2659, 2713, 2738, 2761, 3080], [3082, 3082, 3137, 3137, 3890]], "test": "timeout"}
{"id": "Wl3GDM", "name": "ColumnaCubosv1", "author": "jorge2017a1", "description": "ColumnaCubosv1", "tags": ["columnacubosv1"], "likes": 1, "viewed": 76, "published": "Public", "date": "1576456320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\nconst int CCero = 0;\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    case 11:\n        return vec3(0.0, 0.8, 0.2);\n    case 12:\n        return vec3(0.3, 0.7, 0.3);\n    case 13:\n    return vec3(0.0, 1.0, 0.4);\n    \n        \n    } \n}\n\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opTwistBx(  in vec3 p )\n{\n    const float k =40.0; //10.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.yx,p.y);\n    //return primitive(q);\n    \n    return  sdBox(q-vec3(-2.0,2.0,4.5),vec3(0.2,2.5,0.5));\n}\n\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n///--------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    float d;\n    d=999.9;\n    float planeDist = p.y+3.0;\n    vec2 res;\n    \n \n    res=vec2(planeDist,3);\n   \n   \n    \n    vec3 pbA=vec3(1.0,0.25,1.0);\n    vec3 pt;\n    \n    \n    const int NumBx=13;\n    //NumBx=20;\n    float bxArr[NumBx];\n    \n    float grados;\n    \n    grados=360.0/float( NumBx);\n    \n    vec3 pPosA=vec3(1,1,1);\n    vec3 pPosB=vec3(1,1,1);\n    \n    \n    pPosB=pPosA;\n    \n    pt=p;\n    \n   \n    float tiempoGiro=iTime*0.25;\n    \n    for (int i = 1; i <NumBx ; i++) \n    {\n        pt.xz*= rotate(tiempoGiro);\n        \n        \n        pPosB.y=pPosB.y+0.50;\n\n        pPosB.xz*= rotate(tiempoGiro);\n \n    \tbxArr[i] = sdBox(pt-pPosB,pbA);\n        \n      \tres = opU(res, vec2(bxArr[i], i ));  \n    }\n      \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, -1.5+4.5*sin(iTime));\n    //vec3 ro = vec3(0, 2.5, -1.5+4.8*sin(iTime*0.5));\n    vec3 ro = vec3(0, 3.5, -8);\n    \n\n    \n    vec3 rLuz=vec3(-0.5, -4.5, -10.5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    \n    \n    float dif = GetLight(p);\n    \n    float dif2 = abs(1.0- GetLight( pluz));\n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n  \n    dif=(dif+dif2)/1.5;\n    \n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3GDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 368, 401, 401, 466], [467, 485, 521, 521, 590], [591, 606, 637, 637, 787], [788, 808, 844, 844, 931], [932, 948, 980, 1008, 1069], [1122, 1122, 1168, 1168, 1200], [1202, 1202, 1244, 1244, 1276], [1278, 1278, 1325, 1325, 1358], [1361, 1361, 1390, 1390, 1516], [1570, 1570, 1598, 1598, 2717], [2721, 2768, 2804, 2804, 2907], [2963, 2963, 3008, 3008, 3099], [3102, 3102, 3133, 3133, 3397], [3400, 3400, 3422, 3422, 3489], [3491, 3539, 3564, 3564, 4381], [4384, 4384, 4418, 4418, 4652], [4658, 4658, 4682, 4682, 4914], [4918, 4918, 4942, 4942, 5327], [5334, 5334, 5391, 5391, 6190]], "test": "error"}
{"id": "wl3GR2", "name": "cpy-39788", "author": "jorge2017a1", "description": "cpy-39788", "tags": ["cpy39788"], "likes": 1, "viewed": 44, "published": "Public", "date": "1576850950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 surfacePosition;\n\n\nfloat saturate(float x)\n{\n    return clamp(x,0.,1.);\n}\n\n\nvec4 tex(vec2 u){\n\tvec2 p=fract(fract(u)+(sin(u.y+iTime)/4.));\n    \n\tfloat f=1.-saturate((max(length(p-vec2(0.25,0.5)),length(p-vec2(0.75,0.5)))-.5)*50.);\n    float f2,f3;\n    \n\tf-=1.-saturate((length(p-.5)-(((sin(iTime+u.x)+2.)/3.)*.25))*50.);\n    f2=fract( sin(iTime+u.x)+2. )-f;\n    f3= fract(sin(iTime+u.x)*0.4 )-f;\n    \n    \n\t//return vec4(f,f,f,0.);   ///original\n    return vec4(f,f2,f3,0.);\n}\n\nvec4 tex2( vec2 g )\n{\n    g /= 10.;\n    float color = sign((mod(g.x, 0.1) - 0.05) * (mod(g.y, 0.1) - 0.05));\n    \n    return sqrt(vec4(color));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \t//surfacePosition=fragCoord;\n        //vec2 uv = surfacePosition * 2.;\n    \n    vec2 uv =fragCoord.xy/iResolution.xy-vec2(0.5,0.5);\n    \n    float t = iTime * 0.5;\n    uv.y += sin(t) * .5;\n    uv.x += cos(t) * .5;\n    \n    float a = atan(uv.x,uv.y)/1.57;\n    float d = max(max(abs(uv.x),abs(uv.y)), min(abs(uv.x)+uv.y, length(uv)));\n   \n    vec2 k = vec2(a,0.8/d + t);\n    \n    vec4 tx = tex(k*6.);\n    vec4 tx2 = tex2(k*2.);\n    \n    // ground\n    fragColor = tx2;\n    \n    // wall\n    if (d<=abs(uv.x)+0.05||d<=abs(uv.x)+uv.y)\n        fragColor = tx;\n    \n    fragColor *= d;\n\tfragColor.a = 1.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3GR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 49, 49, 78], [81, 81, 98, 98, 481], [483, 483, 504, 504, 628], [633, 633, 690, 771, 1300]], "test": "ok"}
{"id": "wl3GRH", "name": "Shaky cube", "author": "Anskiere", "description": "-", "tags": ["raymarching", "fractal", "sdf", "cube"], "likes": 10, "viewed": 138, "published": "Public", "date": "1575729453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define time iTime\n\nconst float maxDist = 200.;\nconst float planeDist = 2.;\n\nvec3 cameraPos()\n{\n    float t = time*0.2;\n    float r = 7.;\n\n    vec3 res = vec3(sin(t),1.3,-cos(t));\n    res *= r;\n\n    return res;\n}\n\nvec3 getRay(vec2 uv)\n{\n    vec3 cam = cameraPos();\n    vec3 origin = vec3(0, 0, 0);\n    vec3 look = normalize(origin - cam);\n    vec3 upGlob = vec3(0,1,0);\n    vec3 right = normalize(cross(upGlob, look));\n    vec3 camUp = normalize(-cross(right, look));\n\n    vec3 p = cam + camUp * uv.y + right * uv.x;\n    p += look * planeDist;\n\n    vec3 res = p - cam;\n    return normalize(res);\n}\n\nfloat getSphere(vec3 p, float size, vec3 origin)\n{\n    return length(p - origin) - size;\n}\n\nfloat getSphere(vec3 p, float size)\n{\n    return getSphere(p, size, vec3(0,0,0));\n}\n\nvec2 rot(vec2 p, float a)\n{\n    float ca = cos(a), sa = sin(a);\n    mat2 m = mat2(ca, sa, -sa, ca);\n    return p * m;\n}\n\nvec3 rot(vec3 p, vec3 u, float a)\n{\n    float omc = 1. - cos(a);\n    float sa = sin(a);\n    float ca = cos(a);\n\n    mat3 m = mat3(\n        ca + u.x*u.x*omc,\n        u.x*u.y*omc + u.z*sa,\n        u.x*u.z*omc - u.y*sa,\n\n        u.x*u.y*omc - u.z*sa,\n        ca + u.y*u.y*omc,\n        u.y*u.z*omc + u.x*sa,\n\n        u.x*u.z*omc + u.y*sa,\n        u.y*u.z*omc - u.x*sa,\n        ca + u.z*u.z*omc\n    );\n\n    return m * p;\n}\n\nfloat getSd(vec3 uv)\n{\n    const int steps = 7;\n    float t = time * 0.5;\n    float s = 1.;\n\n    vec3 u = normalize(vec3(1));\n    vec3 ouv = uv;\n\n    for (int i = 0; i < steps; i++)\n    {\n        uv = abs(uv);\n        uv -= .5;\n        uv = rot(uv, u, .3*cos(ouv.y*2. + t*5.));\n        \n        uv *= 2.;\n        s *= 2.;\n    }\n\n    float res = getSphere(uv, 0.5)/s;\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.001; // or some other value const\n    vec2 k = vec2(1,-1);\n\n    return\n        normalize(\n            k.xyy*getSd( p + k.xyy*h ) +\n            k.yyx*getSd( p + k.yyx*h ) +\n            k.yxy*getSd( p + k.yxy*h ) +\n            k.xxx*getSd( p + k.xxx*h ) );\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n    float depth = 0.;\n\n    for(int i = 0; i < 150; i++)\n    {\n        vec3 p = sp + ray * depth;\n        float dist = getSd(p);\n\n        if (dist <= 0.001)\n            return depth - dist;\n\n        depth += dist;\n\n        if (depth >= maxDist)\n            return depth;\n    }\n\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= .65;\n    \n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n    float d = raymarch(camPos, ray);\n\n    vec3 col = vec3(1);\n\n    if (d > 30.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec3 intP = camPos + d*ray;\n    vec3 n = calcNormal(intP);\n    float dis = length(intP-camPos);\n    vec3 lightDir = normalize(vec3(-1,1,1));\n    float dd = dot(n, lightDir);\n\n    dd = dd *.1 + .9;\n\n    vec3 res = col * intP * dd;\n\n    res = pow(abs(res), vec3(1.2));\n    fragColor = vec4(res, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3GRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 191, 191, 308], [310, 310, 332, 332, 693], [695, 695, 745, 745, 785], [787, 787, 824, 824, 870], [872, 872, 899, 899, 991], [993, 993, 1028, 1028, 1410], [1412, 1412, 1434, 1434, 1797], [1799, 1799, 1825, 1825, 2104], [2106, 2106, 2141, 2141, 2438], [2440, 2440, 2497, 2497, 3112]], "test": "ok"}
{"id": "wl3GWN", "name": "No idea", "author": "sebost1234", "description": "yes", "tags": ["yes"], "likes": 1, "viewed": 45, "published": "Public", "date": "1576342975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int nrofspheres = 3;\nvec4 getSphere(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec4(1.0+sin(iTime)*1.0,0.5,0.6, 0.3);\n    case 1:\n        return vec4(2.6+sin(iTime)*0.1,0.9,2.1, 0.3);\n    case 2:\n        return vec4(0.1+sin(iTime)*0.1,0.9+cos(iTime)*0.5,2.1, 0.8);\n    } \n}\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(167, 107, 41)/255.0f;\n    case 1:\n        return vec3(167, 107, 41)/255.0f;\n    case 2:\n        return vec3(167, 107, 41)/255.0f;\n    } \n}\n\nfloat getSphereOpacity(int i)\n{\n    return 0.8;    \n}\n\n\nvec3 getLightDir()\n{\n    return vec3(-1.,-1.,0.2);\n}\n\nvec3 skyColor(vec3 ray)\n{\n    float diffuse = clamp(dot(ray,-getLightDir()), 0.0, 10.0);\n    float specular = pow(diffuse, 2.);\n    \n    float tmp1 = diffuse+specular+0.1f;\n    \n    vec3 light = (vec3(tmp1*1., tmp1*1., tmp1*1.)+vec3(0.1,0.1,0.1));\n\n    return light;\n\n    //return texture(iChannel0, ray).rgb;\n}\n\n\nstruct RayCastInfo\n{\n\tint sphereid;//-1 if not hit\n\tfloat t0;\n    float t1;\n};\n\nRayCastInfo calculateRay(vec3 pos, vec3 dir)\n{\n    int sphereid = -1;\n    float truet0=999999999999.;\n    float truet1=999999999999.;\n\n    for(int i = -1;i<nrofspheres;i++)\n    {\n        vec4 sphere = getSphere(i);\n\n        vec3 L = sphere.xyz - pos; \n        float tca = dot(L,dir); \n        if (tca >= 0.)\n        {\n            float d2 = dot(L,L) - tca * tca; \n            if (d2 <= sphere.w)\n            {\n                float thc = sqrt(sphere.w - d2); \n                float t0 = tca - thc; \n                float t1 = tca + thc;\n\n                if(t0<truet0)\n                {\n                    sphereid = i;\n                    truet0 = t0;\n                    truet1 = t1;\n                }\n\n            }\n        }\n    }\n\n    RayCastInfo tmp;\n    tmp.sphereid = sphereid;\n    tmp.t0 = truet0;\n    tmp.t1 = truet1;\n  \treturn tmp;\n}\n\n\nconst int nrofrays = 4;\n\nvec3 calculateMainRay(vec3 startpos, vec3 startdir)\n{\n    vec3 pos[nrofrays];\n    vec3 dir[nrofrays];\n    vec3 color[nrofrays];\n    float count[nrofrays];\n    bool finished[nrofrays];\n    int raycount = 1;\n    \n    pos[0] = startpos;\n    dir[0] = startdir;\n    color[0] = vec3(1.0);\n    finished[0] = false;\n    count[0] = 1.;\n    \n    \n    for(int i = 0;i<nrofrays-1;i++)\n    {\n        for(int o = 0;o<raycount;o++)\n        {\n            if(!finished[o])\n            {\n                RayCastInfo tmp = calculateRay(pos[o],dir[o]);\n\n                if(tmp.sphereid!=-1)\n                {\n                    vec4 sphere = getSphere(tmp.sphereid);\n                    vec3 spherecolor = getSphereColor(tmp.sphereid);\n\t\t\t\t\tfloat sphereopacity = getSphereOpacity(tmp.sphereid);\n                    \n                    pos[o] = pos[o] + dir[o]*tmp.t0;\n                    vec3 normal = normalize(pos[o] - sphere.xyz);\n                    \n\n                    //refraction\n                    if(raycount<nrofrays&&sphereopacity>0.001)\n                    {\n                        raycount++;\n                        \n                        float size = tmp.t1 - tmp.t0;\n                        \n                        vec3 shiftdir = cross(normal, -dir[o]);\n                       \n                        pos[raycount-1] =  pos[o] + dir[o]*tmp.t1 + shiftdir*size;\n\n                        dir[raycount-1] = dir[o];\n                        color[raycount-1] = (spherecolor/(size+0.1))*color[o];\n                        color[raycount-1] *= sphereopacity;\n                        \n                        finished[raycount-1] = false;\n                        count[raycount-1] = count[o];\n                    }\n\n                    //reflection\n                    {\n                        dir[o] = reflect(dir[o], normal);\n                        \n                        color[o] *= spherecolor;\n                        \n                        count[o]++;\n                    }\n\n\n                }\n                else \n                {\n                    finished[o] = true;\n                    color[o] *= skyColor(dir[o]);\n                }\n            }\n        }\n    }\n    \n    vec3 finalcolor = vec3(0.0);\n    for(int i = 0;i<raycount;i++)\n    {\n        finalcolor += color[i]/count[i];\n    }\n    \n    return finalcolor/float(raycount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(fragCoord/iResolution.y, 0); \n    \n    \n    vec2 center = vec2((iResolution.x*0.5)/iResolution.y, (iResolution.y*0.5)/iResolution.y);\n    \n    vec3 raydirection = normalize(pos - vec3(center, pos.z-0.6));\n\n\n    \n    fragColor = vec4(calculateMainRay(pos, raydirection), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3GWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 44, 44, 283], [285, 285, 313, 313, 501], [503, 503, 534, 534, 556], [559, 559, 579, 579, 611], [613, 613, 638, 638, 924], [1007, 1007, 1053, 1053, 1851], [1879, 1879, 1932, 1932, 4230], [4232, 4232, 4289, 4289, 4587]], "test": "error"}
{"id": "Wl3GzB", "name": "Noise in 3d", "author": "yp3y5akh0v", "description": "Noise in 3d", "tags": ["3d", "noise", "rand"], "likes": 1, "viewed": 88, "published": "Public", "date": "1576655633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI radians(180.)\n\nfloat rand(vec3 p) {\n    return fract(sin(dot(sin(p), vec3(12.9898, 78.233, 37.719))) * 143758.5453);\n}\n\nfloat noise(vec3 p, float scale) {\n    vec3 ps = p * scale;\n\tvec3 id = floor(ps);\n    vec3 q = smoothstep(0., 1., fract(ps));\n    vec2 e = vec2(1., 0.);\n    \n    float n1 = smoothstep(0., 1., mix(rand(id), rand(id + e.xyy), q.x));\n    float n2 = smoothstep(0., 1., mix(rand(id + e.yyx), rand(id + e.xyx), q.x));\n    float n3 = smoothstep(0., 1., mix(rand(id + e.yxy), rand(id + e.xxy), q.x));\n    float n4 = smoothstep(0., 1., mix(rand(id + e.yxx), rand(id + e.xxx), q.x)); \n    float n12 = smoothstep(0., 1., mix(n1, n2, q.z));\n    float n34 = smoothstep(0., 1., mix(n3, n4, q.z));\n    \n    return smoothstep(0., 1., mix(n12, n34, q.y));\n}\n\nmat3 rot(float a, float b, float g) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n\tfloat cb = cos(b);\n    float sb = sin(b);\n    float cg = cos(g);\n    float sg = sin(g);\n    mat3 ma = mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n    mat3 mb = mat3(cb, 0., sb, 0., 1., 0., -sb, 0., cb);\n    mat3 mg = mat3(1., 0., 0., 0., cg, sg, 0, -sg, cg);\n    return ma * mb * mg;\n}\n\nfloat snoise(vec3 p, float scale, float steps) {\n\tfloat s = 0., sk = 0.; \n    for (float i = 0.; i < steps; i++) {\n        float k = pow(2., i);\n    \ts += noise(p, scale * k) / k;\n        sk += 1. / k;\n        float a = 2. * PI * (i + 1.) / steps;\n        p *= rot(a, a, a);\n    } \n    return smoothstep(0., 1., s / sk);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;    \n\tfloat n = snoise(vec3(uv, iTime * 0.035), 8., 32.);\n    vec3 col = vec3(n);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3GzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 129], [131, 131, 165, 165, 771], [773, 773, 810, 810, 1139], [1141, 1141, 1189, 1189, 1463], [1465, 1465, 1522, 1522, 1680]], "test": "ok"}
{"id": "wlc3DH", "name": "My First Raymarched Scene", "author": "TheCreator", "description": "This is my first raymarched scene I created, following this tutorial: https://www.youtube.com/watch?v=yxNnRSefK94", "tags": ["raymarching", "color", "first"], "likes": 3, "viewed": 66, "published": "Public", "date": "1576176441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 point) {\n    vec3 q = fract(point) * 2.0 - 1.0;\n    \n    return length(q) - 0.3;\n}\n\nfloat trace(vec3 origin, vec3 direction) {\n    float trace = 0.0;\n    \n    for(int i = 0; i < 40; i++) {\n        vec3 intersectPoint = origin + direction * trace;\n        \n        float dist = map(intersectPoint);\n        trace += dist * 0.5;\n    }\n    \n    return trace;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 direction = normalize(vec3(uv, 1.0));\n    float timeMod = iTime * 0.25;\n    direction.xz *= mat2(cos(timeMod), -sin(timeMod), sin(timeMod), cos(timeMod));\n    \n    vec3 origin = vec3(0.0, timeMod * 2.0, timeMod);\n    \n    float trace = trace(origin, direction);\n    \n    float fog = 1.0 / (1.0 + trace * trace * 0.01);\n    vec3 color = vec3((0.5 * cos(timeMod) + 0.5) * fog, (0.5 * cos(2.0 + timeMod) + 0.5) * fog, (0.5 * cos(4.0 + timeMod) + 0.5) * fog);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlc3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 97], [99, 99, 141, 141, 372], [374, 374, 431, 431, 1056]], "test": "ok"}
{"id": "Wlc3DN", "name": "SNOWMAN!!!", "author": "onlinerocker", "description": "Here's a snowman.\nTis the season!", "tags": ["raymarching", "lighting", "snowman", "chirstmas"], "likes": 5, "viewed": 74, "published": "Public", "date": "1576365654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nstruct object\n{\n \tfloat dist;\n    vec3 color;\n    bool isSnow;\n};\n    \nstruct ray\n{\n \tvec3 curRay;   \n    object obj;\n    float totalDist;\n};\n    \nfloat fmod(float x, float y)\n{\n \treturn x - y * floor(x/y); \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat4 getTransXYZ(float alpha, float beta, float gamma, float x, float y, float z)\n{\n \tvec4 col =  vec4(cos(beta)*cos(gamma),\n                     cos(alpha)*sin(gamma) + sin(alpha)*sin(beta)*cos(gamma),\n                     sin(alpha)*sin(gamma) - cos(alpha)*sin(beta)*cos(gamma),\n                     0);\n    \n    vec4 col1 = vec4(-cos(beta)*sin(gamma),\n                      cos(alpha)*cos(gamma) - sin(alpha)*sin(beta)*sin(gamma),\n                      sin(alpha)*cos(gamma) + cos(alpha)*sin(beta)*sin(gamma),\n                      0);\n                     \n    vec4 col2 = vec4(sin(beta),\n                    -sin(alpha)*cos(beta),\n                     cos(alpha)*cos(beta),\n                     0);\n                     \n    vec4 col3 = vec4(x, y, z, 1);\n                    \n    return mat4(col,\n                col1,\n                col2,\n                col3);\n    \n}\n\n//START IQ FUNCTIONS\n\nfloat sdSphere(vec3 pos, vec3 center, float rad)\n{\n \treturn length(pos - center) - rad;   \n}\n\nfloat sdPlane(vec3 pos, float y)\n{\n    return pos.y - y;   \n}\n\nfloat sdCone(vec3 p, float radAng)\n{\n    /*if(p.x < 0.)\n        return 24.;\n    p -= vec3(1.0, 0.8, 0);\n    p = vec3(getTransXYZ(.0, -PI/2.0, .0, .0, .0, .0) * vec4(p,1));\n    \n    vec2 c = vec2(sin(2.), sin(.2));\n\tfloat q = length(p.xy);\n  \treturn dot(c,vec2(q,p.z));*/\n    if(p.x < -1.0)\n        return 24.0;\n    vec2 c = vec2(sin(2.), sin(.2));\n\tfloat q = length(p.yz);\n  \treturn dot(normalize(c),vec2(q,p.x));\n    \n    /*vec2 vals = vec2(sin(2.95), sin(2.));\n    vec3 tipPos = vec3(-3, 0.8, 0);\n    \n    float len = length(pos.zy - tipPos.zy);\n    return dot(vals, vec2(pos.x - 1., len));\n\t*/\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(0.2+(sin(iTime)*0.04)) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat sdRoundCone( vec3 p, vec3 loc, float r1, float r2, float h, mat4 transform)\n{\n  p = p - loc;\n  p = vec3(transform * vec4(p,1));\n    \n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n//END IQ FUNCIONS\n\nvec3 getMapColor(float d, float dNew, vec3 col, vec3 colNew)\n{\n    return step(dNew, d)*colNew + step(d, dNew)*col;\n}\n\n//maps body and ground plane\nobject map(vec3 pos)\n{\n    object obj;\n    obj.dist = 1000.0;\n    obj.color = vec3(1);\n\n    //combing top, mid, and btm of snowman here\n    //change x < 5 and z > -5 to fix nose... why? idfk\n \n    float dGr = sdPlane(pos, -2.0); //ground\n    if(dGr < obj.dist) obj.color = vec3(1);\n    obj.dist = min(dGr, obj.dist);\n    \n    float lightX = pos.x;\n    float lightZ = pos.z;\n    if(lightX < 0.95 && lightX > -0.5)\n    {\n        lightZ = abs(pos.z);\n        lightX = fmod(pos.x, 0.5);   \n    }\n\n    vec3 lightPos = vec3(lightX, pos.y, lightZ);\n    float dL = sdSphere(lightPos , vec3(0., -1.97, 1.5), 0.05); //light\n    if(dL < obj.dist) obj.color = vec3(2,0,0);\n    //col = getMapColor(d, dL, col, vec3(2,0,0));\n    obj.dist = min(obj.dist, dL);\n    \n    float dl1 = sdSphere(lightPos, vec3(0.3, -1.97, 1.3), 0.05);//light\n    if(dl1 < obj.dist) obj.color = vec3(0,1,0);\n    //col = getMapColor(d, dl1, col, vec3(0,1,0));\n    obj.dist = min(dl1, obj.dist);\n    \n    float dRop = sdCapsule(lightPos, vec3(0, -1.97, 1.5), vec3(0.3, -1.97, 1.3), 0.03); //rope\n    float dRop1 = sdCapsule(lightPos, vec3(0.3, -1.97, 1.3), vec3(0.6, -1.97, 1.6), 0.03); //rope 1\n    dRop1 += 1000.0*step(0.6, pos.x); //clip last rope off\n    \n    dRop = min(dRop, dRop1);\n    if(dRop < obj.dist) obj.color = vec3(0);\n    //col = getMapColor(d, dRop, col, vec3(0));  \n    obj.dist = min(dRop, obj.dist);\n    \n    float boundingCap = sdSphere(pos, vec3(0, -1, 0), 1.3);\n\t//obj.dist = boundingCap;\n    \n    if(boundingCap < obj.dist)\n    {\n        float top = sdSphere(pos, vec3(0,-1.5,0), 1.0);\n        float mid = sdSphere(pos, vec3(0,-.3,0), 0.8);\n        float bottom = sdSphere(pos, vec3(0,0.7,0), 0.6);\n        float bodyDist = min(mid, bottom);\n        bodyDist = min(top, bodyDist);\n        obj.dist = min(bodyDist, obj.dist);\n        obj.color = vec3(1);\n        \n        //btns\n        float btnY = pos.y;\n    \tfloat btnX = pos.x;\n    \n    \tbtnX += step(0.0, btnY)*0.07;\n    \tif(btnY < 0.4 && btnY > -0.6)\n    \t{\n        \tbtnY = fmod(pos.y, -0.4);\n    \t}\n        \n        float dBtn = sdSphere(vec3(btnX, btnY, pos.z), vec3(0.8,-0.3,0.0), .07); //buttons\n        if(dBtn < obj.dist) obj.color = vec3(0);\n        //col = getMapColor(d, dBtn, col, vec3(0));\n        obj.dist = min(dBtn, obj.dist);\n        \n        float eyeZ = abs(pos.z);\n        float dEye = sdSphere(vec3(pos.xy, eyeZ), vec3(0.5,0.9,0.2), .1); //eyes\n        if(dEye < obj.dist) obj.color = vec3(0);\n        //col = getMapColor(d, dEye, col, vec3(0));\n        obj.dist = min(dEye, obj.dist);\n        \n        float dNose = sdCone(pos - vec3(1.0, 0.8, 0), 0.05); //nose\n        if(dNose < obj.dist) obj.color = vec3(235./255., 137./255., 33./255.);\n        //col = getMapColor(d, dNose, col, vec3(235./255., 137./255., 33./255.));\n        obj.dist = min(dNose, obj.dist);\n        \n        vec3 pipePos1 = vec3(getTransXYZ(-PI/4.0, .0, .0,.0, .0, .0) * vec4(pos,1)); //pipe\n        vec3 pipePos = pipePos1 - vec3(.92, 0.8, -0.3);\n        pipePos = vec3(getTransXYZ(.0, -PI/4.0, .0, .0, .0, .0) * vec4(pipePos, 1.0));\n\n        float dPipe = sdCappedCylinder(pipePos, vec3(.0, -0.1, .0), vec3(.0, .1, .0), 0.05);\n        float dPipe1 = sdCapsule(pipePos1, vec3(.92, 0.8, -0.3), 0.5*normalize(vec3(-1,-0.1,-0.4)), 0.03);    \n        dPipe = min(dPipe, dPipe1);\n        if(dPipe < obj.dist) obj.color = vec3(0.35, 0.1, 0.1);\n        //col = getMapColor(d, dPipe, col, vec3(0.35, 0.1, 0.1));\n        obj.dist = min(dPipe, obj.dist);\n        \n        vec3 rotPos = vec3(getTransXYZ(.0, .0, -PI/10.0, .0, .0, .0) * vec4(pos,1)); //hat\n        \n        float dHat = sdRoundedCylinder(rotPos - vec3(0.2, 1.4, .0), 0.2, 0.1, 0.25); \n        float dHatBtm = sdRoundedCylinder(rotPos - vec3(0.2, 1.15, .0), 0.3, 0.05, 0.015);\n        dHat = min(dHat, dHatBtm);\n        if(dHat < obj.dist) obj.color = vec3(0);\n        obj.dist = min(dHat, obj.dist);\n        \n        float dHatRib = sdCappedCylinder(rotPos - vec3(0.2, 1.2, .0), vec3(0), vec3(.0, 0.13, .0), 0.43);\n        if(dHatRib < obj.dist) obj.color = vec3(0.7,0,0);\n        obj.dist = min(dHatRib, obj.dist);\n        \n\n    }\n\n    obj.isSnow = false;\n \treturn obj;   \n}\n\nvec3 calcNorm(vec3 pos)\n{\n    float ep = 0.001;\n \tfloat x = map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist;  \n    float y = map(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist;  \n    float z = map(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist;  \n    \n    return normalize(vec3(x, y, z));\n}\n\nray marchRay(vec3 pos, vec3 dir)\n{\n    vec3 curRay;\n    float dist = 0.001;\n    object obj;\n    ray r;\n    \n    for(int x=0; x<100; x++)\n    {\n        curRay = pos + dist*dir;\n        \n        obj = map(curRay);\n        float d = obj.dist;\n        dist += d;\n        \n        if(d < 0.001)\n            break;\n        if(dist > 25.0)\n            break;\n        \n             \n    }\n    \n    r.curRay = curRay;\n    r.obj = obj;\n    r.totalDist = dist;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.x)/iResolution.y;\n\tvec3 camPos = vec3(0, 0, 0);\n\tvec3 dir = normalize(vec3(uv, -1));\n       \n    float rotMod = PI/2.0 + sin(iTime/4.0) * PI/3.0;\n\n    //(2.2+rotMod*iTime/4.0)\n    mat4 camTransform = getTransXYZ(0.0, rotMod, 0., \n                                    4.*sin(rotMod), 2., 4. * cos(rotMod));\n\n    dir = normalize(vec3(camTransform * vec4(dir,0))); //transform direction\n    camPos = vec3(camTransform * vec4(camPos,1)); //rotate camera around sphere\n    \n    //lights\n    vec3 sunLightPos = vec3(10, 10, 1);\n    vec3 skyLightPos = vec3(0, 12, 0);\n    vec3 bouLightPos = vec3(0, -1.9, -1);\n    \n    vec3 xmasLightPos = vec3(0, -1.8, 1.5);\n    vec3 xmasLightPos1 = vec3(0.3, -1.8, 1.3);\n    vec3 xmasLightPos2 = vec3(0.6, -1.8, 1.5);\n    vec3 xmasLightPos3 = vec3(0.9, -1.8, 1.3);\n    vec3 xmasLightPos4 = vec3(-0.5, -1.9, 1.5);\n    vec3 xmasLightPos5 = vec3(-0.2, -1.9, 1.3);\n    \n    float sunLightInt = 5.0;\n    float skyLightInt = 1.0;\n    float bouLightInt = 1.0;\n    float xmasLightInt = 0.3;\n    \n    ray ret = marchRay(camPos, dir);\n    vec3 curRay = ret.curRay;\n    float dist = ret.totalDist;\n    \n    vec3 rayNorm = calcNorm(curRay);\n    \n    ray shaRet = marchRay(curRay + rayNorm*0.01, normalize(sunLightPos - curRay));\n    float shaDist = shaRet.totalDist;\n    \n    //ray shaRetBou = marchRay(curRay + rayNorm*0.01, normalize(bouLightPos - curRay));\n    //float shaDistBou = shaRetBou.totalDist;\n    \n    bool objIsSnow = shaRet.obj.isSnow;\n    if(objIsSnow)\n        shaDist = 26.0;\n    \n    vec3 col;\n    \n    vec3 xmasRay = curRay;\n    vec3 xmasNorm = rayNorm;\n    xmasRay.z = abs(xmasRay.z);\n    xmasNorm.z = abs(xmasNorm.z);\n    \n    float slIntensity = sunLightInt * clamp(dot(rayNorm, normalize(sunLightPos - curRay)), 0.0, 1.0);\n    float skLIntensity = skyLightInt * clamp(dot(rayNorm, normalize(skyLightPos - curRay)), 0.0, 1.0);\n    float bouIntensity = bouLightInt * clamp(dot(rayNorm, normalize(bouLightPos - curRay)), 0.0, 1.0);\n    \n    float xmInt = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos - xmasRay)), 0.0, 1.0);\n    float xmInt1 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos1 - xmasRay)), 0.0, 1.0);\n    float xmInt2 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos2 - xmasRay)), 0.0, 1.0);\n    float xmInt3 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos3 - xmasRay)), 0.0, 1.0);\n    float xmInt4 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos4 - xmasRay)), 0.0, 1.0);\n    float xmInt5 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos5 - xmasRay)), 0.0, 1.0);\n\n    vec3 slCol = vec3(0.2, 0.2, 0.2) * slIntensity;\n    vec3 skCol = vec3(0.0, 0.0, 0.2) * skLIntensity;\n    vec3 bouCol = vec3(0.2, 0.2, 0.2) * bouIntensity;\n    vec3 xmCol = vec3(1, 0, 0) * xmInt;\n    vec3 xmCol1 = vec3(0, 1, 0) * xmInt1;\n    vec3 xmCol2 = vec3(1, 0, 0) * xmInt2;\n    vec3 xmCol3 = vec3(0, 1, 0) * xmInt3;\n    vec3 xmCol4 = vec3(1, 0, 0) * xmInt4;\n    vec3 xmCol5 = vec3(0, 1, 0) * xmInt5;\n    \n    vec3 allLightMod = slCol*step(25., shaDist) + skCol + bouCol + xmCol + xmCol1 + xmCol2 + xmCol3 + xmCol4 + xmCol5;\n    \n    if(dist > 25.0)\n    {\n        col = (0.6+uv.y)*vec3(0.0, 0.2, 0.4) + (1.0-uv.y)*vec3(0.1);\n        col = applyFog(col, dist, curRay, sunLightPos);\n    }\n    else\n    {        \n        col = ret.obj.color * (allLightMod);\n        col = applyFog(col, dist, curRay, sunLightPos);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlc3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 203, 203, 235], [237, 237, 257, 257, 329], [331, 331, 414, 414, 1206], [1230, 1230, 1280, 1280, 1322], [1324, 1324, 1358, 1358, 1385], [1387, 1387, 1423, 1657, 1985], [1988, 1988, 2040, 2040, 2167], [2169, 2169, 2414, 2414, 2751], [2753, 2753, 2836, 2836, 3155], [3157, 3157, 3214, 3214, 3550], [3552, 3552, 3616, 3616, 3733], [3754, 3754, 3816, 3816, 3871], [3873, 3902, 3924, 3924, 8065], [8067, 8067, 8092, 8092, 8399], [8401, 8401, 8435, 8435, 8871], [8873, 8873, 8930, 8980, 12495]], "test": "timeout"}
{"id": "wlc3DS", "name": "2d something noise", "author": "alarch", "description": "2d noise", "tags": ["2d", "noise"], "likes": 1, "viewed": 157, "published": "Public", "date": "1577403548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise1(int x, int y)\n{\n    int n;\n    n = x+y*57;\n    x = (n<<13) ^ n;\n    return ( 1.0 - float( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);\n \n}\n\nfloat smoothedNoise2D(int x, int y)\n{\n    int multiplier = 1;\n    float corners, sides, center;\n    corners = ( noise1(int(x-multiplier), int(y-multiplier))+noise1(int(x+multiplier), int(y-multiplier))+noise1(int(x-multiplier), int(y+multiplier))+noise1(int(x+multiplier), int(y+multiplier)) ) / 16.0;\n    sides   = ( noise1(int(x-multiplier), int(y))+noise1(int(x+multiplier), int(y))+noise1(int(x), int(y-multiplier))+noise1(int(x), int(y+multiplier)) ) /  8.0;\n    center  =  noise1(int(x), int(y)) / 4.0;\n    return corners + sides + center;\n}\n\n\nfloat interpol(float a, float b, float x)\n{\n    float ft, f;\n    ft = x * 3.1415927;\n    f = (1.0 - cos(ft)) * 0.5;\n    return  a*(1.0-f) + b*f;\n}\n\nfloat interpolatedNoise(float x,float y)\n{\n      float fractional_X,fractional_Y,v1,v2,v3,v4,i1,i2;\n      int integer_X,integer_Y;\n   \n      integer_X    = int(x);\n      fractional_X = x - float(integer_X);\n \n      integer_Y    = int(y);\n      fractional_Y = y - float(integer_Y);\n \n      v1 = smoothedNoise2D(integer_X,     integer_Y);\n      v2 = smoothedNoise2D(integer_X + 1, integer_Y);\n      v3 = smoothedNoise2D(integer_X,     integer_Y + 1);\n      v4 = smoothedNoise2D(integer_X + 1, integer_Y + 1);\n \n      i1 = interpol(v1 , v2 , fractional_X);\n      i2 = interpol(v3 , v4 , fractional_X);\n \n      return interpol(i1 , i2 , fractional_Y);\n \n}\n\nfloat fbmNoise(float x,float y)\n{\n    x = x*1000.0;\n    y = y*1000.0;\n    float total,p, frequency,amplitude;\n    int i,n;\n    total = 0.0;\n    p = 2.0;\n    n = 8;\n \n \n    for(i=0; i<=n;i++)\n    {\n        frequency = pow(2.0,float(i));    \n        amplitude = sin(iTime)+p/(pow(2.0,float(i)));\n        total = total+interpolatedNoise(x*frequency/20.0,y*frequency/20.0)*amplitude;\n    }\n    return total;\n}\n\n// END lesson04\n\nprecision lowp    float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv;\n\n    // same as vec2 uv = fragCoord/iResolution.xy;\n    uv.x = fragCoord.x/iResolution.x;\n    uv.y = fragCoord.y/iResolution.y;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n        \n    // set Image aspect to square or you will get an oval\n    uv *= iResolution.xy  / iResolution.y;\n    // same as vec2 uv = fragCoord/iResolution.xy;\n    \n   \n    int rngSeed = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    float col2;\n    \n    col2 = fbmNoise(uv.x+1.0, uv.y+1.0); // add 1.0 to coords, since perlin func only seems to work with positive floats\n       \n    fragColor = vec4(0.0, col2, 0.0, 1.0);\n}\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlc3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 181], [183, 183, 220, 220, 730], [733, 733, 776, 776, 879], [881, 881, 923, 923, 1532], [1534, 1534, 1567, 1567, 1939], [1984, 1984, 2041, 2041, 2662]], "test": "ok"}
{"id": "wlc3z8", "name": "Glowing tunnel", "author": "ad_lucem", "description": "Another glowing tunnel...", "tags": ["raymarching", "tunnel", "glow"], "likes": 12, "viewed": 357, "published": "Public", "date": "1575565413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution\n#define T iTime\n#define PI 3.141593\n#define DtR 0.01745\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// From iq - https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat tunnel(vec3 p)\n{\n    p.z+=T;\n    p.xy+=sin(p.z)*.5+sin(p.xz*12.)*.05+sin(p.zy*20.)*.025; \n    return 1.-length(p.xy);\n}\n\nfloat map(vec3 p)\n{\n    return tunnel(p);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = (2.*U-R.xy)/R.y;\n    \n    vec3 cz = normalize(vec3(0,0,1));\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    \n    vec3 z = vec3(cx*uv.x + cy*uv.y + cz*.15);\n    vec3 pos = vec3(0);\n    \n    float d = 0.;\n    float att = 0.;\n    \n    for(int i = 0; i < 256; ++i)\n    {\n        d=map(pos);\n        if(d < .0001) break;\n        if(d > 10000.0)break;\n        pos+= z * d;\n        att+=0.2/(abs(d)+0.2);\n    }\n    \n    vec3 color = rgb2hsv(vec3(.75,.2,0.10));\n    color.r=pos.z*0.01+sin(-T*0.05);\n    color = hsv2rgb_smooth(color);\n    \n    if(d < 10000.0)\n    {\n        color *= 0.3 + att*0.006;\n    }\n    \n   \t//color=pow(color,vec3(0.4545));\n    color*=1.0-length(uv);\n    \n    O = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlc3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 101, 101, 432], [434, 485, 519, 519, 697], [699, 699, 721, 721, 824], [826, 826, 845, 845, 869], [871, 871, 912, 912, 1665]], "test": "ok"}
{"id": "wlc3zM", "name": "primera columna-jf", "author": "jorge2017a1", "description": "primera columna-jf", "tags": ["primeracolumnajf"], "likes": 0, "viewed": 33, "published": "Public", "date": "1575904629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\nconst int CCero = 0;\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    float dif4;\n    \n    \n    d=999.9;\n    float planeDist = p.y;\n    vec2 res;\n     \n    // This makes everything below repeat infinitely.\n    p.xz = mod(p.xz, 8.5) - vec2(2.5,1.5);\n       \n    res=vec2(planeDist,4);\n\n    float bxInf = sdBox (p-vec3(0.0,0.2,4.5),vec3(0.8,0.6,0.8));  \n    float sdc1=sdCylinder( p-vec3(0.0,1.5,4.5), vec2(0.5,2.5) ) ;\n    float sp1=sdSphere(p-vec3(0.0,3.5,-4.5),0.8);\n  \n    res = opU(res, vec2(bxInf, CInf));\n    res = opU(res, vec2(sdc1, CInf));\n    res = opU(res, vec2(sp1, 5));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, -1.5+4.5*sin(iTime));\n\n    //vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    vec3 rLuz=vec3(-0.5, -4.5, -5.5);\n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    \n    float dif = GetLight(p);\n    \n    float dif2 = abs(1.0- GetLight( pluz));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2)/1.5;\n    \n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlc3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 368, 401, 401, 466], [467, 485, 521, 521, 590], [591, 606, 637, 637, 787], [788, 808, 844, 844, 931], [932, 948, 980, 1008, 1069], [1122, 1122, 1168, 1168, 1200], [1202, 1202, 1244, 1244, 1276], [1278, 1278, 1325, 1325, 1358], [1361, 1361, 1390, 1390, 1516], [1570, 1570, 1598, 1598, 2579], [2583, 2630, 2666, 2666, 2769], [2825, 2825, 2850, 2850, 3528], [3531, 3531, 3565, 3565, 3799], [3805, 3805, 3829, 3829, 4061], [4065, 4065, 4089, 4089, 4474], [4481, 4481, 4538, 4538, 5299]], "test": "error"}
{"id": "wlc3zr", "name": "Water Caustics with OpenSimplex2", "author": "KdotJPG", "description": "Domain-warping noise with its own derivative produces a smooth rudimentary water caustics effect.\n\nFaster (but more triangle biased) version using domain-rotated value noise with a cosine fade curve https://www.shadertoy.com/view/Ns2Xzh", "tags": ["2d", "noise", "water", "caustic"], "likes": 33, "viewed": 1363, "published": "Public", "date": "1575462328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////// Re-oriented 8-point BCC noise (OpenSimplex2S) by KdotJPG ////////////////////\n//////////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 bccNoiseDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 bccNoiseDerivatives_XYZ(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Might be good for terrain, or a time varying X/Y plane. Z repeats.\nvec4 bccNoiseDerivatives_ImproveXYPlanes(vec3 X) {\n    \n    // Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y) * 8.0;\n    \n    // Initial input point\n    vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386);\n    \n    // Evaluate noise once\n    vec4 noiseResult = bccNoiseDerivatives_ImproveXYPlanes(X);\n    \n    // Evaluate noise again with the derivative warping the domain\n    // Might be able to approximate this by fitting to a curve instead\n    noiseResult = bccNoiseDerivatives_ImproveXYPlanes(X - noiseResult.xyz / 16.0);\n    float value = noiseResult.w;\n    \n    /* You can sort of imitate the effect by fitting a curve instead of calling noise again.\n       Not quite as good, and not sure of speed differences.\n       Could probably experiment with non-trig curves too.\n    float p = asin(noiseResult.w);\n    float derivMag = length(noiseResult.xyz);\n    float sinScale = derivMag / cos(p);\n    float value = sin(p - sinScale * derivMag / 20.0);*/\n\n    // Time varying pixel color\n    vec3 col = vec3(.431, .8, 1.0) * (0.5 + 0.5 * value);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlc3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 246, 268, 268, 305], [307, 369, 392, 440, 1411], [1413, 1458, 1496, 1496, 2953], [2955, 3112, 3150, 3150, 3352], [3354, 3503, 3553, 3587, 3998], [4083, 4083, 4138, 4209, 5271]], "test": "ok"}
{"id": "wlcGD4", "name": "Space is watching you.", "author": "Logos", "description": "Modular polar experiments.\n", "tags": ["eyes", "eye", "mod", "polar", "dream", "spirituality"], "likes": 20, "viewed": 360, "published": "Public", "date": "1576330370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Robert Åmietana (Logos) - 14.12.2019\n// Bielsko-BiaÅa, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    //--- calculate point coordinates ---//\n    \n\tvec2 cartesian = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 polar     = vec2(atan(cartesian.y, cartesian.x) + 0.057*iTime, mod(log(length(cartesian)), 0.2));\n    \n    float l = length(cartesian);\n    float s = sin(12.0*polar.x);\n    \n    float d;\n\n    \n    //--- measure first sinus ---//\n    \n    vec2 sinus1 = polar;\n    sinus1.y   += 0.08 * s;\n    \n    d = abs(sinus1.y - 0.1);    \n    \n    \n    //--- measure second sinus ---//\n    \n    vec2 sinus2 = polar;\n    sinus2.y   -= 0.08 * s;\n    \n    d = min(d, abs(sinus2.y - 0.1));\n\n    \n    //--- measure eye --//\n    \n    vec2 eye = polar;\n    eye.x    = mod(eye.x, 3.1415926535 / 12.0);\n    \n    d = min(d, length(eye - vec2(0.135, 0.1)) - 0.035  - 0.025*sin(iTime - 6.0*l));\n\n\n    //--- calculate final pixel color ---//\n                  \n    vec3 outputColor = vec3(0.5 - 0.50*cos(polar.x + iTime), \n                       \t\t0.6 - 0.07*sin(polar.x - 0.22*iTime),\n                            0.5 - 0.50*sin(polar.x - 0.90*iTime));\n\n\toutputColor *= 1.0 - exp(-45.0*abs(d));\n    outputColor *= 0.8 + 0.2*cos(240.0*d);\n    outputColor  = l * mix(vec3(1.0), outputColor, smoothstep(0.0, 0.0142, abs(d)));\n\n    fragColor = vec4(outputColor, 1.0);\n                  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 188, 233, 1473]], "test": "ok"}
{"id": "WlcGRj", "name": "[Twitch] Day 1 of MDTMJVM", "author": "jeyko", "description": "MDTMJVM = Middecembertomidjanuaryvember\nCoding daily at http://twitch.tv/wwrighter", "tags": ["tunnel", "repetition", "twitch", "mdtmjvm"], "likes": 20, "viewed": 641, "published": "Public API", "date": "1576789757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x + up*uv.y;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;  \n}\nfloat sdTube(vec3 p, float r) {\n    return length(p.xy) - r;\n}\n#define pi acos(-1.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat sdRuby (vec3 p, float r){\n  //p.z \n  p = abs(p);\n  p.z -= r;\n  p.yz *= rot(0.125*pi);\n  p.zx *= rot(-0.125*pi);\n  return p.z;\n}\n\n\n#define pi acos(-1.)\n\nfloat mpow(float num, float times) {\n    for (float i = 0.; i < times; i++) {\n    \tnum *= num;\n    }\n    return num;\n}\n\nfloat getScale(float z) {\n  //return 1;\n  \n  return 2.;\n  float sep = 3.;\n  z = mod(z, sep);\n  float id = floor(mod(z, sep));\n  if (id == sep - 1.) {\n    \n      return 1. + mpow(sin(fract(z - sep + 1.)*pi), 4.);\n  } else {\n    \n      return 1.;\n  }\n}\n\nfloat r21(vec2 u){\n\treturn fract(sin(u.y*3515125.1 + u.x *124215.125125)*1224115.125235);\n}\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*3515125.1 + u.x *124215.125125 + u.z*12525.215215215)*1224115.125235);\n}\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup =  mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup =  mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return j;\n    float h = mix(i, j, fd.z); \n        \n    float res = h;\n    \n\treturn res;\n}\n\nfloat fbm(vec3 uv){\n  uv.z = mod(uv.z, 20.);\n\tfloat res = 0.;\n  float amp = 1.;\n  float gain= 0.5;\n  float lac = 2.;\n  \n  for (float i = 0.; i < 1.;i++){\n    uv = abs(uv);\n    res += valueNoise(uv*lac)*amp;\t\n    amp *= gain;\n    lac *=2.;    \n  }\n\n\treturn res;\n}\n\n\n#define dmin(dA, dB) (dA.x < dB.x) ? dA : dB\nvec3 camOffs(float z){\n  z *= 0.2;\n  return vec3(\n    sin(z) + sin(z*0.2)*0.4,\n    cos(z),\n    0\n  )* ( 1. - getScale(z)) * 0.5;\n}\n\nvec3 pipeOffset(float z, float idx) {\n  float zScale = z*0.2;\n  float scale = 1.;\n  float scaleMod = 0.5 - getScale(zScale ) ;\n  if (idx == 0.) {\n    return vec3(\n      cos(z),\n      sin(z),\n      0\n    )*scale*scaleMod;    \n  } else if (idx == 2.) {\n    return vec3(\n      cos(z + 2.4),\n      sin(z + 2.4),\n      0\n    )*scale*scaleMod;    \n  } else if (idx == 3.) {\n    return vec3(\n      cos(z + 4.6),\n      sin(z + 4.6),\n      0\n    )*scale*scaleMod*0.6;    \n  } else if (idx == 4.) {\n    return vec3(\n      cos(z + 5.1),\n      sin(z + 5.4),\n      0\n    )*scale*scaleMod*2.;    \n  }\n}\n\n#define dmod(p, x) (mod(p, x) - x*0.5)\n\nfloat getTube(vec3 p, float idx) {\n  float d = 10e3;\n  p.z *= 0.5;\n  if (idx == 0.) {\n    vec3 pPipe = p - pipeOffset(p.z, 0.);\n    float dTube = sdTube(pPipe,0.2);\n    \n    pPipe.xy *= rot(p.z*1.6 + sin(iTime + p.z));\n    vec2 uv = vec2(atan(pPipe.x, pPipe.y));\n    \n      \n    dTube -= sin(uv.x*10. + sin(uv.y)*1. + iTime*5.)*0.07;\n    \n    return dTube/2.;  \n  } else if (idx == 2.) {\n    vec3 pPipe = p - pipeOffset(p.z, 2.);\n    float dTube = sdTube(pPipe,0.2);\n    \n      float dbetween = 0.2;\n      vec3 pSphere = dmod(p+ vec3(0,0,iTime*0.1), dbetween) ;\n      dTube = max(dTube, sdSphere(pSphere, 0.08));  \n    \n    return dTube;\n  } else if (idx == 3.) {\n    \n    vec3 pPipe = p - pipeOffset(p.z, 3.);\n    float dbetween = 0.2;\n    vec3 pRuby= pPipe + vec3(0,0,iTime*0.1);\n    pRuby.xy *= rot(0.2 + iTime*0.1 + sin(iTime + p.z));\n    \n    pRuby.z = dmod(p.z, dbetween);\n    \n    float id = floor(p.z);\n    \n    pRuby.y *= 0.9;\n    float dTube = sdTube(pPipe,0.1);\n    \n    float dRuby = sdRuby(pRuby, 0.056);\n    \n    dTube = min(dTube, dRuby);\n    \n    //dTube = max(dTube, sdRuby(pRuby, 0.5));\n      \n    \n    return dTube;\n  } else if (idx == 4.) {\n    vec3 pPipe = p - pipeOffset(p.z, 4.);\n    float dTube = sdTube(pPipe,0.2) - fbm(vec3(p.x*1.,p.y*3.,p.z))*0.07;\n    \n    \n    return dTube;\n  }\n  \n \n  return d;\n}\n\n\nvec2 map(vec3 p){\n  p.xy -= 5.;\n  p.xy = dmod(p.xy, 10.);\n  vec2 d = vec2(10e3, 100);\n  \n  d = dmin(d, vec2(getTube(p, 0.), 0.));\n  d = dmin(d, vec2(getTube(p, 2.), 2.));\n  d = dmin(d, vec2(getTube(p, 3.), 3.));\n  d = dmin(d, vec2(getTube(p, 4.), 4.));\n  \n  //d = dmin(d, vec2(sdRuby(p - vec3(0,0,iTime + 3), 0.2), 3.));\n  \n  \n  \n  return d/3.;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.006,0);\n    return normalize(\n      vec3(map(p).x) - vec3(\n        map(p + t.xyy).x,\n        map(p + t.yxy).x,\n        map(p + t.yyx).x\n      )  \n    );\n}\n\n#define spectra(inp) (0. + 0.6*sin(vec3(0.9,0.7,5.1) + inp))\n\nvec3 glow = vec3(0);\nvec4 render(vec2 uv) {\n  \n  vec3 col = vec3(0);\n  vec3 ro = vec3(0.,0.,0. + iTime*3.) ;\n  vec3 lookAt = ro + vec3(0. + sin(iTime*0.25)*0.6,0. + sin(iTime*0.25)*0.6,5.);\n  ro += camOffs(ro.z);\n  \n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  vec2 t = vec2(0);\n  vec3 p = ro;\n  \n  for (int i = 0; i < 150; i++) {\n      vec2 d = map(p);\n      \n      glow += spectra(d.x*20.)*0.0002;\n      if (d.x < 0.001) {\n        // collision\n        \n        vec3 posLightA = lookAt - vec3(0,3,2);// + vec3(cos(iTime*0.2), sin(iTime*0.2), 0);\n        \n        float diff = 0.;\n        float spec = 0.;\n        \n        vec3 n = getNormal(p);\n        \n        vec3 l = normalize(posLightA - p);\n        \n        if (d.y == 0.) {\n          float fres = max(pow(1. - dot(-rd, n), 5.), 0.);\n          float diff = max(dot(n,l),0.);\n          float spec = max(dot(normalize(ro - p), n),0.);\n          col += vec3(0.1) * (spec + diff);\n          //col = vec3(1.);\n        } else if (d.y == 1.) {\n          float fres = max(pow(1. - dot(rd, n), 5.), 0.);\n          float diff = max(dot(n,l),0.);\n          col += vec3(0.03) *(fres*diff);\n        } else if (d.y == 2.) {\n          float fres = max(pow(1. - dot(rd, n), 5.), 0.);\n          float diff = max(dot(n,l),0.);\n          col += vec3(0.1) *(fres);\n        } else if (d.y == 3.) {\n          float fres = max(pow(1. - dot(-rd, n), 1.), 0.);\n          float diff = max(dot(n,l),0.);\n          float thingie = max(dot(normalize(ro - p), n),0.);\n          col += vec3(2) *(thingie + diff);\n        }else  {\n          float fres = max(pow(0.6 - dot(rd, n), 1.), 0.);\n          float diff = max(dot(n,l),0.);\n          col += vec3(0.06) * fres;\n        }\n        \n        //col *= spectra(d.y*1 + 5);\n        break;\n      }\n      if (d.x > 2000.) {\n        // wall\n        col = vec3(0.0);\n        break;\n      }\n      t.x += d.x;\n      p = ro + t.x * rd;\n  }\n  col += glow;\n  col = pow(col, vec3(0.44));\n  \n  return vec4(col, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    col.g *= 0.5;\n    col.b *= 0.2;\n    col *= 4.6;\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 44, 44, 220], [223, 223, 256, 256, 286], [287, 287, 318, 318, 349], [422, 422, 453, 462, 555], [580, 580, 616, 616, 698], [700, 700, 725, 739, 950], [952, 952, 970, 970, 1043], [1044, 1044, 1062, 1062, 1157], [1158, 1158, 1184, 1184, 1934], [1936, 1936, 1955, 1955, 2198], [2246, 2246, 2268, 2268, 2376], [2378, 2378, 2415, 2415, 2966], [3008, 3008, 3042, 3042, 4334], [4337, 4337, 4354, 4354, 4683], [4686, 4686, 4710, 4710, 4885], [4970, 4970, 4992, 4992, 6923], [6926, 6926, 6983, 6983, 7155]], "test": "error"}
{"id": "wlcGRM", "name": "Procedural Brick Texture 2D", "author": "bluebean", "description": "2Dåé¯é½¿ç åè´´å¾", "tags": ["2d", "brick", "antialiase"], "likes": 6, "viewed": 150, "published": "Public", "date": "1576151122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//å¥æ°è¡æ°´å¹³åç§»åä¸ªç å\n        s += 0.5;\n    //åç´ ç¹æå¨ç åç¼å·\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///åç´ ç¹å¨ç åååæ \n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//å¥æ°è¡æ°´å¹³åç§»åä¸ªç å\n        s += 0.5;\n    ///åç´ ç¹å¨ç åååæ \n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 587, 587, 1042], [1045, 1045, 1074, 1074, 1479], [1482, 1482, 1539, 1539, 2025]], "test": "ok"}
{"id": "wlcGWN", "name": "procedural_world_pdf", "author": "diogotito", "description": "guidelines I followed from a cool PDF on the web", "tags": ["procedural"], "likes": 3, "viewed": 125, "published": "Public", "date": "1576348464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Point vec2\n#define Color vec4\n\n\nvoid getSkyColor(float x, float y, inout Color color) {\n    float h = max(0.0, 1.4 - y - pow(abs(x - 0.5), 3.0));\n    color.r = pow(h, 3.0);\n    color.g = pow(h, 7.0);\n    color.b = 0.2 + pow(max(0.0, h - 0.1), 10.0);\n}\n\n\n// a one-liner I found on the web somewhere\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat hash(float i) { return rand(vec2(i, i*123.4+245.6)); }\n\n\nfloat noise(float x) {\n    float i = floor(x), f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 2.0 * mix(hash(i), hash(i + 1.0), u) - 1.0;\n}\n\n\nfloat terrain(float x) {\n    float y = 0.0;\n    for (int octave = 0; octave < 10; ++octave) {\n        float k = pow(2.0, float(octave));\n        y += noise(x * k) / k;\n    }\n    \n    return y * 0.4 + 0.66;\n}\n\n\nfloat water(float x) {\n    return 0.22 + 0.005 * sin(200.0 * (x + iTime * 0.03));\n}\n\n\nvoid mainImage( out Color color, in Point coord )\n{\n    // Normalized coordinates\n    float x = coord.x / iResolution.x;\n    float y = coord.y / iResolution.y;\n     \n    getSkyColor(x, y, color);\n    \n\tfloat shift = 0.09 * iTime + 0.2;\n    x += shift;\n    \n    float h = max(water(x), terrain(x));\n    if (y < h) { color = Color(0.0); }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 95, 95, 259], [262, 306, 326, 326, 396], [397, 397, 418, 418, 457], [460, 460, 482, 482, 616], [619, 619, 643, 643, 826], [829, 829, 851, 851, 912], [915, 915, 966, 996, 1253]], "test": "ok"}
{"id": "wlcGzN", "name": "Voronoi 3D_", "author": "Anskiere", "description": "-", "tags": ["voronoi"], "likes": 2, "viewed": 195, "published": "Public", "date": "1575744023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(65.9898,\n                                    78.233))) * 25758.5497);\n}\n\nfloat rand11(float x)\n{\n    return fract(sin(x * 35.7313) * 437.5453);\n}\n\nvec3 rand13(float x)\n{\n    vec3 r;\n    r.x = rand11(x);\n    r.y = rand11(r.x);\n    r.z = rand11(r.z);\n    \n    return r;\n}\n\nvec2 rand22(vec2 co)\n{\n    vec2 res;\n    res.x = rand(co);\n    res.y = rand11(res.x);\n\n    return res;\n}\n\nfloat rand31(vec3 co)\n{\n    return fract(sin(dot(co,vec3(65.9898,\n                                 78.233, 29.3471))) * 1537.5497);\n}\n\nvec3 rand33(vec3 co)\n{\n    float r1 = rand31(co);\n    float r2 = rand11(r1);\n    float r3 = rand11(r2);\n\n    return vec3(r1, r2, r3);\n}\n\n\nvec3 getPoint(vec3 ijk)\n{\n    vec3 p;\n    p = rand33(ijk);\n\n    return p;\n}\n\nfloat n(vec3 uv)\n{\n    vec3 ijk = floor(uv);\n    vec3 luv = fract(uv);\n\n    float d = 10000.;\n    vec3 di = ijk;\n\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    for(int k = -1; k <= 1; k++)\n    {\n    \tvec3 p = getPoint(ijk + vec3(i,j,k));\n        p += vec3(i,j,k);\n        float dist = distance(p, luv);\n\n        if (dist < d)\n        {\n            d = dist;\n            di = ijk + vec3(i,j,k);\n        }\n    }\n    \n    return rand31(di);\n}\n\nfloat noise(vec3 uv)\n{\n    float res;\n    int steps = 1;\n    float p = 1.;\n    \n    for (int i = 0; i < steps; i++)\n    {\n        res += n(uv * p) / p;\n        \n        p *= 2.;\n    }\n    \n    //res /= 2.;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * .02;\n    vec3 uv = vec3(fragCoord.xy / iResolution.x, t);\n\n    uv *= 10.;\n\n\tfloat res = noise(uv);\n        \n    //res = pow(res, 1.);\n    vec3 col = rand13(res);\n\t//col *= res;\n\n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 129], [131, 131, 154, 154, 203], [205, 205, 227, 227, 327], [329, 329, 351, 351, 433], [435, 435, 458, 458, 568], [570, 570, 592, 592, 705], [708, 708, 733, 733, 783], [785, 785, 803, 803, 1248], [1250, 1250, 1272, 1272, 1478], [1480, 1480, 1537, 1537, 1769]], "test": "ok"}
{"id": "wld3D4", "name": "DogBone 2D SDF", "author": "BigWIngs", "description": "Needed this for a logo, I suppose it could be useful to others as well.", "tags": ["dogbone"], "likes": 9, "viewed": 355, "published": "Public", "date": "1576611799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"DogBone SDF\" by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// The MIT License\n// Copyright Â© 2019 Martijn Steinrucken\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// I needed something like this for a logo and I think it might\n// be useful for other things as well.\n// It is made by fitting circles together. The code could probably\n// be simpler, especially if you take just the pinch, or just the bulge.\n//\n// See comments for a slightly more compact version by IQ\n\nfloat sdDogBone(vec2 p, float w, float r, float b) {\n    // p = point to evaluate\n    // w = half distance between end points\n    // r = radius of endpoints\n    // b = bulge -> -1 = pinch to center 0 = straight >0 = bulge out\n    \n    if(abs(b)<1e-7) b = 1e-7;\t// prevent division by 0\n    float sb = sign(b);\n    \n    p = abs(p);\n    \n    vec2 ep = p-vec2(w, 0);\t\t\t// end point\n    float dE = length(ep)-r;\t\t// distance to end circle\n    float y = (w*w-r*r)/(2.*r*b);\t// height of center circle\n    vec2 cp = vec2(p.x, p.y-y);\t\t// position of center circle\n    vec2 ec = sb*(ep-cp);\t\t\t// vec from end point to center point\n    float rc = length(ec)-r*sb;\t\t// radius of center circle\n    float dC = sb*(rc-length(cp));\t// distance to center circle\n    \n    return ec.x*ep.y-ec.y*ep.x < 0. ? dE : dC;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    float t = iTime;\n    \n    uv *= 2.;\n    \n    float d = sdDogBone(uv, .75+sin(t)*.25, .25, sin(t));\n    \n    // coloring from IQ\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3D4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1625, 1625, 1677, 1850, 2426], [2428, 2428, 2485, 2485, 2952]], "test": "ok"}
{"id": "wld3R2", "name": "Bracewell Probe #1020", "author": "blackle", "description": "a strange place", "tags": ["landscape", "crosshair"], "likes": 6, "viewed": 323, "published": "Public API", "date": "1576950880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 sq(vec2 uv) {\n  return vec3(cos(uv.x), sin(uv.x)*sin(uv.y),sin(uv.x)*cos(uv.y));\n}\n\nfloat comp(vec3 p, vec3 off, vec3 ro) {\n  float scale = 2.2;\n  p+=off;\n  p=erot(p,sq(ro.xy),acos(-1.)*ro.z);\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - 0.1;\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a); int y = FK(b);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 hash3(float a) {\n  float t1 = hash(a, cos(a));\n  float t2 = hash(t1, cos(a+t1));\n  float t3 = hash(t2, cos(a+t2));\n  return vec3(t1,t2,t3);\n}\n\nfloat smin(float a, float b, float k){\n  float h = max(0.,k-abs(a-b))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat scene(vec3 p) {\n  float dist = 100000.;\n  for (int i = 0; i < 4; i++) {\n    vec3 off = hash3(float(i));\n    vec3 rot = hash3(cos(float(i*i)));\n    dist = smin(comp(p,off,rot),dist,0.2);\n  }\n  float offset = sin(p.x)+cos(p.y*0.8)+sin((p.x+p.y)*0.2)*0.5+cos((p.x-p.y)*0.3)*0.5;\n  return linedist(vec2(dist,p.z), vec2(0,0), vec2(0.95+cos(iTime)*0.05,2.5+offset*0.2))-0.2;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 cam) {\n  return pow(smoothstep(-0.3,1.,scene(p+reflect(cam,n))*vec3(0.9,0.9,1)),vec3(2));\n}\n\nfloat borders(vec2 frag, vec2 res) {\n  vec2 frg = floor(frag);\n  vec2 crungy = floor(abs(frag-res/2.));\n  vec2 quad = floor(res/2.-abs(frag-res/2.));\n  float borderpos = floor(min(res.x,res.y)/4.);\n  if (quad.x == borderpos || quad.y == borderpos) return 1.;\n  if (quad.y == borderpos/2.) return 1.;\n  if (mod(iTime,2.)>0.5){\n  if (frg.x == floor(res.x/2.) && frg.y < res.y/2.+8. && frg.y > res.y/2.-8.) return 1.;\n  if (frg.y == floor(res.y/2.) && frg.x < res.x/2.+8. && frg.x > res.x/2.-8.) return 1.;\n  }\n  return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord - .5* iResolution.xy ) / iResolution.y;\n  \n\n  vec3 cam = normalize(vec3(0.7, uv));\n  vec3 init = vec3(0,sin(iTime/30.)*30.,4. + cos(iTime/10.)*0.5);\n  cam = erot(cam, vec3(0,1,0), cos(iTime*0.3)*0.5+0.5);\n  cam = erot(cam, vec3(0,0,1), sin(iTime*0.3)*0.8);\n  \n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 300; i++) {\n    float dist = scene(p);\n    if (cam.z>0.)break;\n    if (dist*dist < 0.0001) { p+=dist*cam; hit = true; break; }\n    if (distance(init, p) > 100.) break;\n    p+=dist*cam;\n  }\n  float fog = sqrt(smoothstep(0.,50.,distance(p,init)));\n  vec3 n = norm(p);\n  fragColor.xyz = sqrt(hit ? mix(shade(p,n,cam),vec3(0.9),fog) : vec3(0.9));\n  float dx = dFdx(fragColor.z);\n  float dy = dFdy(fragColor.z);\n  fragColor.xyz -= dot(uv,vec2(dx,dy))*vec3(2,1,0);\n  \n  float b = borders(fragCoord.xy, iResolution.xy);\n  fragColor.xyz = mix(fragColor.xyz*0.95 + hash(uv.x+cos(iTime),uv.y+iTime)*0.02, vec3(1), b);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3R2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 314, 314, 383], [385, 385, 424, 424, 555], [612, 612, 642, 642, 718], [720, 720, 741, 741, 866], [868, 868, 906, 906, 972], [974, 974, 1014, 1014, 1102], [1104, 1104, 1125, 1125, 1480], [1482, 1482, 1501, 1501, 1612], [1614, 1614, 1652, 1652, 1737], [1739, 1739, 1775, 1775, 2261], [2263, 2263, 2320, 2320, 3276]], "test": "timeout"}
{"id": "wld3Rr", "name": "cuarto en temblor", "author": "jorge2017a1", "description": "cuarto en temblor", "tags": ["cuartoentemblor"], "likes": 2, "viewed": 54, "published": "Public", "date": "1575513753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 30-nov-2019\n\n//const int nrofrays = 15;\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(0.8, 0.5, 0.7);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        //return  vec3(0.5, 0.8, 0.9);\n        return vec3(0.0, 0.0, 1); \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        return vec3(55./255., 30./255.,  255./255.); \n        \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        //return vec3(0.5, 0.6, 0.6);\n        return vec3(0.25, 0.36, 0.8);\n        \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   \n    \n    \n    \n    \n    \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    res = opU(res, vec2(planeDist, 6));\n    \n    \n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,2.5));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,2.5));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,2.5));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,2.5));\n    float bxAtras = sdBox(p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.1));\n    \n    res = opU(res, vec2(bxInf, CInf));\n    //res = opU(res, vec2(bxDer, CDer));\n    //res = opU(res, vec2(bxIzq, CIzq));\n    //res = opU(res, vec2(bxAtras, CAtras));\n    //res = opU(res, vec2(bxSup, CSup));\n    \n    \n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.45,0.8,0.4));\n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    float bxIzqVentana = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.11,0.30,0.25));\n    float bxDerVentana = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.11,0.55,0.25));\n    \n    float bxSupVentanab = sdBox (p-vec3(0.0,3.0,2.5),vec3(0.5,0.31,0.4));\n    float bxDerVentanab = sdBox (p-vec3(-1.6,1.9,3.0),vec3(0.11,0.55,0.6));\n    \n    \n    dif2=differenceSDF(bxIzq,bxIzqVentana);     \n    res = opU(res, vec2(dif2, CIzq));\n    //res = opU(res, vec2(bxIzqVentana, CIzq));\n    \n     \n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n    res = opU(res, vec2(dif1, CAtras));\n    \n    \n    dif2=differenceSDF(bxSup,bxSupVentana);     \n    dif2=differenceSDF(dif2,bxSupVentanab);     \n    \n    res = opU(res, vec2(dif2, CSup));\n    \n    \n    \n    dif2=differenceSDF(bxSup,bxSupVentanab);     \n    //res = opU(res, vec2(dif2, 3));\n    \n    \n    dif3=differenceSDF(bxDer,bxDerVentana);\n    dif3=differenceSDF(dif3,bxDerVentanab);\n    \n        \n    res = opU(res, vec2(dif3, CDer));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvec3 hash33(vec3 p)\n{\n    return fract(13406.456*sin(p.xyz)*sin(p.zxy));\n}\n\n\nfloat rnd()\n{\n    float m;\n    float k;\n    k=hash11(sin(iTime));\n    return  2.* fract(1e3*sin( 1e3 * m+k ) ) - 1.;;\n}\n\n\n\n\nvec3 disturbance()\n{\n\n    float dispersion=1205.5;\n    float a;\n    float b;\n    float c;\n    \n    a=(dispersion / 32000.0) * (1.0 * rnd());\n    b=(dispersion / 32000.0) * (1.0 * rnd());\n    c=0.0;\n    return vec3(a, b, c);\n\n}\n    \nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n\nvec3 hsv2rgb_smoothv2(vec3 p) {\n    vec3 rgb = clamp( abs(mod(p.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn p.z * mix( vec3(1), rgb, p.y);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\tvec3 di=disturbance();\n    \n    vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime))+di;\n\n    vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    float dif = GetLight(p);\n    float dif2 = abs(1.25- GetLight(pluz));\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    colobj=(hsv2rgb_smoothv2(colobj)*0.8+colobj*1.85)/2.0;\n\t\n    vec3 col1;\n    col1=vec3(dif);\n    col1=(hsv2rgb_smoothv2(col1));\n    \n    \n    dif=(dif+dif2)/1.5;\n    \n    vec3 col2;\n    col2=vec3(dif);\n    col =( col2*colobj+col1)/1.5;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 407, 440, 440, 505], [506, 524, 560, 560, 629], [630, 645, 676, 676, 826], [827, 847, 883, 883, 970], [971, 987, 1019, 1047, 1108], [1161, 1161, 1207, 1207, 1239], [1241, 1241, 1283, 1283, 1315], [1317, 1317, 1364, 1364, 1397], [1400, 1400, 1429, 1429, 1555], [1609, 1609, 1637, 1637, 2661], [2716, 2716, 2741, 2741, 4864], [4867, 4867, 4890, 4890, 4975], [4978, 4978, 4999, 4999, 5052], [5055, 5055, 5068, 5068, 5174], [5179, 5179, 5199, 5199, 5405], [5411, 5411, 5445, 5445, 5679], [5682, 5755, 5803, 5803, 5959], [5962, 5962, 5993, 5993, 6155], [6159, 6159, 6183, 6183, 6415], [6419, 6419, 6443, 6443, 6828], [6835, 6835, 6892, 6892, 7794]], "test": "error"}
{"id": "wld3W4", "name": "tests with sdfs, leech teeth", "author": "sasha_sortai", "description": "a test to see how sdfs combine, coded in Bozomatic", "tags": ["raymarching", "sdf"], "likes": 6, "viewed": 102, "published": "Public", "date": "1576421983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n//prototypes\nmat3 cspace(vec3);\nmat3 inter(vec3, vec3);\nfloat de(vec3);\nvec3 grade(vec3);\nfloat cir(vec3, float);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float period = 360.;\n  float time = fract(iTime/period)*period;\n  vec3 col;\n  vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)*2./min(iResolution.x,iResolution.y); //the (-1;1)^2 square is always inside the initial screen coordinates\n  uv = (uv*2.+vec2(0,0)); //remapping to whatever patch we need\n  \n  //camera setup\n  vec3 cpos = vec3(cos(time*PI/8.),sin(time*PI/8.),1.25)*sqrt(.5)*12.;\n  vec3 tpos = vec3(0,0,-1.5);\n  mat3 ctra = cspace(normalize(tpos-cpos));\n  vec3 ray = normalize(ctra*vec3(uv,2.6));\n  \n  mat3 mr = inter(cpos,ray);\n  \n  if (mr[2]==vec3(-1)) col = vec3(.1,.2,.3)*.7;\n  else\n  {\n    col = (normalize(mr[1])+1.)/2.;\n    col *= max(0.,dot(normalize(mr[1]),normalize(vec3(5)-mr[0])))+.5*dot(normalize(mr[1]),normalize(vec3(1,-.3,0)))+.05;\n  }\n  \n  //col = pow(col,vec3(1.5+sin(time*2.*PI/24.)));\n  \n  if (1!=1)\n  {\n    int np = 10;\n    col *= float(float(np))-.5;\n    col = floor(col);\n    col /= float(np);\n  }\n  \n  fragColor = vec4(col,1);\n}\n\n\nmat3 cspace(vec3 fo)\n{\n  mat3 res;\n  res[2] = fo;\n  res[0] = cross(fo, vec3(0,0,1));\n  res[1] = cross(res[0],fo);\n  return res;\n}\n\nmat3 inter(vec3 cpos, vec3 ray)\n{\n  mat3 res = mat3(0);\n  int hit = 0;\n  float h; float t = 0.;\n  for (int i = 0; i<250; i++)\n  {\n    h = de(cpos+t*ray);\n    if (h<.0005)\n    {\n      hit = 1;\n      break;\n    }\n    t+=h;\n  }\n  res[0] = cpos+t*ray;\n  res[1] = grade(cpos+t*ray);\n  if (hit==0) res[2] = vec3(-1);\n  return res;\n}\n\nfloat de(vec3 p)\n{\n  /*\n  p = abs(p);\n  vec3 q = vec3(min(p.x,1.), min(p.y,1.), min(p.z,1.));\n  return distance(p,q)-1.;\n  */\n  \n  float r=sin(iTime*PI/2.)*4.;\n  float t = 0.;\n  for (int i = 0; i<3; i++)\n  {\n    //t+=1./distance(p,r*vec3(cos(PI*2.*i/6.), sin(PI*2.*i/6.),0));\n    t+=exp(-distance(p,r*vec3(cos(PI*2.*float(i)/3.), sin(PI*2.*float(i)/3.),0)));\n  }\n  \n  return -log(exp(-max(-log(t)-1.,abs(p.z)-.1))+exp(.5-cir(p,4.)));\n  \n}\n\nvec3 grade(vec3 p)\n{\n  vec3 e = vec3(.001,0,0);\n  return vec3(\n    de(p+e.xyz)-de(p-e.xyz),\n    de(p+e.zxy)-de(p-e.zxy),\n    de(p+e.yzx)-de(p-e.yzx)\n  )/(e.x*2.);\n}\n\nfloat cir(vec3 p, float r)\n{\n  vec3 q = vec3(p.xy/length(p.xy),0);\n  return distance(p, r*q);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 191, 191, 1152], [1155, 1155, 1177, 1177, 1284], [1286, 1286, 1319, 1319, 1612], [1614, 1614, 1632, 1739, 2052], [2054, 2054, 2074, 2074, 2218], [2220, 2220, 2248, 2248, 2315]], "test": "error"}
{"id": "Wld3W7", "name": "Radioactive", "author": "onlinerocker", "description": "Warning: Highly radioactive. Do not touch the blob.\nStill making tweaks, but I'll make this public for now ;)", "tags": ["raymarching", "phong", "lighting", "deformation", "green", "slime", "goo", "xbox"], "likes": 3, "viewed": 118, "published": "Public", "date": "1576610661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nstruct Object\n{\n \tfloat dist;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;   \n}\n\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r, float rd)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rd;\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nmat4 getTransXYZ(float alpha, float beta, float gamma, float x, float y, float z)\n{\n \tvec4 col =  vec4(cos(beta)*cos(gamma),\n                     cos(alpha)*sin(gamma) + sin(alpha)*sin(beta)*cos(gamma),\n                     sin(alpha)*sin(gamma) - cos(alpha)*sin(beta)*cos(gamma),\n                     0);\n    \n    vec4 col1 = vec4(-cos(beta)*sin(gamma),\n                      cos(alpha)*cos(gamma) - sin(alpha)*sin(beta)*sin(gamma),\n                      sin(alpha)*cos(gamma) + cos(alpha)*sin(beta)*sin(gamma),\n                      0);\n                     \n    vec4 col2 = vec4(sin(beta),\n                    -sin(alpha)*cos(beta),\n                     cos(alpha)*cos(beta),\n                     0);\n                     \n    vec4 col3 = vec4(x, y, z, 1);\n                    \n    return mat4(col,\n                col1,\n                col2,\n                col3);\n    \n}\n\nfloat fmod(float x, float y)\n{\n \treturn x - y * floor(x/y); \n}\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nObject map(vec3 pos)\n{\n    Object o;\n    o.dist = 1000.0;\n    o.normEps = 0.0001;\n    \n    vec3 ballPos = pos;\n    ballPos.z = abs(ballPos.z);\n                                \n    float dBaseBall = sdSphere(ballPos - vec3(0, -2.1, 0.85), 0.16);    \n    if(dBaseBall < o.dist)\n    {\n        o.dist = smin(o.dist, dBaseBall, 0.1);\n        o.color = vec3(60.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n    \n    vec3 ball1Pos = pos;\n    ball1Pos.x = abs(ball1Pos.x);\n    float dBaseBall1 = sdSphere(ball1Pos - vec3(0.8, -2.1, 0.2), 0.16); \n    if(dBaseBall1 < o.dist)\n    {\n        o.dist = smin(o.dist, dBaseBall1, 0.1);\n        o.color = vec3(60.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n    \n    vec3 ball2Pos = pos;\n    ball2Pos.x = abs(ball2Pos.x);\n    ball2Pos.z = abs(ball2Pos.z);\n    float dBaseBall2 = sdSphere(ball2Pos - vec3(0.5, -2.1, 0.66), 0.16);\n    \n    if(dBaseBall2 < o.dist)\n    {\n        o.dist = smin(o.dist, dBaseBall2, 0.1);\n        o.color = vec3(60.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n    \n    /*float dBaseBallBig = sdSphere(pos - vec3(0, -2.25, 0.0), 0.52);\n    o.dist = smin(o.dist, dBaseBallBig, 0.1);\n    if(dBaseBallBig < o.dist)\n    {\n        o.color = vec3(23.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.normEps = 0.000001;\n    }*/\n    \n\n    float dTubeBase = sdCappedCylinder(pos - vec3(0, -2.26, 0), 1.1, 0.15, 0.02);\n    float dTubeBaseBtm = sdCappedCylinder(pos - vec3(0, -2.55, 0), 2.0, 0.15, 0.03);\n    float dTubeBaseRing = sdTorus(pos - vec3(0, -2.445, 0), vec2(1.65, 0.1));\n    dTubeBase = smin(dTubeBaseBtm, dTubeBase, 0.02);\n    dTubeBase = smin(dTubeBase, dTubeBaseRing, 0.01);\n    if(dTubeBase < o.dist)\n    {\n        o.dist = dTubeBase;\n        o.color = vec3(23.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 10.0;\n        o.specVal = 2.5;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n\n    vec3 pipePos = pos;\n    pipePos.x = abs(pipePos.x);\n    float dPipeBound = sdSphere(pipePos - vec3(1.8, -3., 1.8), 1.0);    \n    if(dPipeBound < o.dist)\n    {\n\n        float ang = PI/2.0;\n        vec2 col1 = vec2(cos(ang), sin(ang));\n        vec2 col2 = vec2(-sin(ang), cos(ang));\n        mat2 rotMat = mat2(col1, col2);\n\n        vec2 col3 = vec2(cos(-ang/2.0), sin(-ang/2.0));\n        vec2 col4 = vec2(-sin(-ang/2.0), cos(-ang/2.0));\n        mat2 rotMat1 = mat2(col3, col4);\n\n        pipePos = vec3(pipePos.x, rotMat * pipePos.yz);\n        pipePos = vec3(rotMat1 * pipePos.xy, pipePos.z);\n\n\n        float dPipe = sdCappedCylinder(pipePos - vec3(-0.2,-2.9,-2.8), 0.3, 0.91, 0.02);\n        if(dPipe < o.dist)\n        {\n            o.dist = smin(o.dist , dPipe, 0.02);\n            o.color = vec3(23.0 / 255.0, 23.0/255.0, 30.0/255.0);\n            o.specVal = 10.0;\n            o.specVal = 5.5;\n            o.specKs = 0.5;\n            o.normEps = 0.0001;\n        }\n    }\n\n    \n    float dSphereBound = sdSphere(pos-vec3(0,-1.,0), 1.3); //blob's bounding sphere\n    if(dSphereBound < o.dist)\n    {\n        //o.dist = sphereBound; //uncomment to show bounding sphere...\n        vec3 spherePos = vec3(getTransXYZ(0., iTime/2.0, .0, .0, .0, .0) * vec4(pos, 1));\n\n        //modified version of deformation pattern at \n        //https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n        float xMod = 0.12*cos(iTime/2.0)*sin(12.0*spherePos.y)*sin(12.0*spherePos.x)*sin(12.0*spherePos.z);\n        float yMod = 0.12*cos(iTime/2.0)*cos(spherePos.y)*sin(10.0*spherePos.x)*sin(10.0*spherePos.z);\n        float zMod = 0.12*(cos(iTime/2.0))*sin(10.0*spherePos.y)*sin(10.0*spherePos.x)*sin(9.0*spherePos.z);\n\n        spherePos = vec3(getTransXYZ(0., 1.5*iTime, .0, .0, .0, .0) * vec4(spherePos, 1));\n        spherePos = (spherePos - vec3(.0, -1.1, .0) - vec3(xMod, yMod, zMod));\n\n        float dSphere = sdSphere(spherePos, 1.0);\n\n        if(dSphere < o.dist)\n        {\n            o.dist = dSphere;\n            o.color = vec3(.1, 0.5, .1);\n            o.specVal = 50.0;\n            o.specKs = 1.0;\n            o.normEps = 0.0001;\n        }      \n    }\n    \n\n    \n    return o;\n}\n\nvec3 calcNorm(vec3 pos, float eps)\n{\n    float ep = min(0.0001, eps);\n    //float ep = 0.0001;\n \tfloat x = map(pos + vec3(ep, .0, .0)).dist - map(pos - vec3(ep, .0, .0)).dist;\n    float y = map(pos + vec3(.0, ep, .0)).dist - map(pos - vec3(.0, ep, .0)).dist;\n   \tfloat z = map(pos + vec3(.0, .0, ep)).dist - map(pos - vec3(.0, .0, ep)).dist;\n    return normalize(vec3(x,y,z));\n}\n\nfloat calcLight(vec3 pos, vec3 lightDir)\n{\n    return dot(pos, lightDir);\n}\n\nMarchRes marchRays(vec3 pos, vec3 dir)\n{\n    MarchRes res;\n    Object o;\n    float totalDist = 0.001;\n    vec3 curRay = pos;\n    for(int x=0; x<100; x++)\n    {\n        curRay = pos + (dir*totalDist);\n     \to = map(curRay);\n        \n        if(abs(o.dist) < 0.0002)\n            break;\n        if(totalDist > 20.0)\n            break;\n        \n        totalDist += o.dist*0.85; //slow down to handle insane morphing of sphere\n    }\n    \n    res.totalDist = totalDist;\n    res.curRay = curRay;\n    res.obj = o;\n\n    if(totalDist <= 20.0)\n        res.obj.normal = calcNorm(curRay, res.obj.normEps);\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.x)/iResolution.y;\n\tvec3 camEye = vec3(0, 0.0, 3.2 + -0.5*sin(iTime/3.0));\n    vec3 dir = vec3(uv, -1);\n    dir = normalize(dir);\n    \n    vec3 light = vec3(0, 10, 10);\n    vec3 lightBlob = vec3(1., -0.5, 0.);\n    float lightTime = fmod(iTime, 7.0);\n    float lightInt = 2.7 + fract(lightTime*lightTime / 3.0);\n    float lightBlobInt = 2.0;\n    vec3 lightCol = vec3(0.4,0.55,0.4);;\n    vec3 lightBlobCol = vec3(0., 0.2, 0);\n    \n    MarchRes res = marchRays(camEye, dir);\n    vec3 col = vec3(0);\n    if(res.totalDist < 20.0)\n    {\n        vec3 pos = res.curRay;\n        \n        float lightShadow = step(20.0, marchRays(pos, normalize(light)).totalDist);\n        vec3 lightDif = lightCol * clamp(calcLight(res.obj.normal, normalize(light - pos)), 0.0, 1.0) * lightInt;\n        vec3 lightSpecR = 2.0 * \n            clamp(dot(res.obj.normal, normalize(light-pos)), 0.0, 1.0) \n            * res.obj.normal - normalize(light-pos);\n        \n        float lightSpec = clamp(dot(normalize(camEye-pos), lightSpecR), 0.0, 1.0);\n        \n        vec3 lightBlobFinal = lightBlobCol * clamp(calcLight(res.obj.normal, normalize(lightBlob - pos)), .0, 1.) * lightBlobInt;\n        col = res.obj.color * (lightCol*lightDif) * lightShadow;\n        col += lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n        \n    }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wld3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 433, 470, 470, 503], [506, 580, 644, 644, 765], [767, 841, 902, 902, 1018], [1020, 1094, 1127, 1127, 1196], [1198, 1198, 1281, 1281, 2073], [2075, 2075, 2105, 2105, 2137], [2139, 2195, 2236, 2236, 2329], [2331, 2331, 2353, 2353, 6644], [6646, 6646, 6682, 6682, 7024], [7026, 7026, 7068, 7068, 7101], [7103, 7103, 7143, 7143, 7719], [7721, 7721, 7778, 7778, 9222]], "test": "timeout"}
{"id": "wld3WN", "name": "Glitchy Glitch", "author": "piyushslayer", "description": "Just experimenting with different kinds of glitching effects, plus a cool old school CRT screen effect. ", "tags": ["noise", "crt", "rgb", "postprocess", "glitch", "analog", "digital", "hash"], "likes": 22, "viewed": 1107, "published": "Public API", "date": "1576886851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n Just messing around with different types of glitching effects.\n*/\n\n// try commenting/uncommenting these to isolate/combine different glitch effects.\n#define ANALOG\n#define DIGITAL\n#define CRT\n\n// amount of seconds for which the glitch loop occurs\n#define DURATION 5.\n// percentage of the duration for which the glitch is triggered\n#define AMT .5 \n\n#define SS(a, b, x) (smoothstep(a, b, x) * smoothstep(b, a, x))\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\n// Hash by David_Hoskins\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\n// Gradient noise by iq\nfloat gnoise(vec3 x)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n    \n    // gradients\n    vec3 ga = hash33(p + vec3(0., 0., 0.));\n    vec3 gb = hash33(p + vec3(1., 0., 0.));\n    vec3 gc = hash33(p + vec3(0., 1., 0.));\n    vec3 gd = hash33(p + vec3(1., 1., 0.));\n    vec3 ge = hash33(p + vec3(0., 0., 1.));\n    vec3 gf = hash33(p + vec3(1., 0., 1.));\n    vec3 gg = hash33(p + vec3(0., 1., 1.));\n    vec3 gh = hash33(p + vec3(1., 1., 1.));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    float gNoise = va + u.x * (vb - va) + \n           \t\tu.y * (vc - va) + \n           \t\tu.z * (ve - va) + \n           \t\tu.x * u.y * (va - vb - vc + vd) + \n           \t\tu.y * u.z * (va - vc - ve + vg) + \n           \t\tu.z * u.x * (va - vb - ve + vf) + \n           \t\tu.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n    \n    return 2. * gNoise;\n}\n\n// gradient noise in range [0, 1]\nfloat gnoise01(vec3 x)\n{\n\treturn .5 + .5 * gnoise(x);   \n}\n\n// warp uvs for the crt effect\nvec2 crt(vec2 uv)\n{\n    float tht  = atan(uv.y, uv.x);\n    float r = length(uv);\n    // curve without distorting the center\n    r /= (1. - .1 * r * r);\n    uv.x = r * cos(tht);\n    uv.y = r * sin(tht);\n    return .5 * (uv + 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = iTime;\n    \n    // smoothed interval for which the glitch gets triggered\n    float glitchAmount = SS(DURATION * .001, DURATION * AMT, mod(t, DURATION));  \n\tfloat displayNoise = 0.;\n    vec3 col = vec3(0.);\n    vec2 eps = vec2(5. / iResolution.x, 0.);\n    vec2 st = vec2(0.);\n#ifdef CRT\n\tuv = crt(uv * 2. - 1.); // warped uvs\n    ++displayNoise;\n#endif\n    // analog distortion\n    float y = uv.y * iResolution.y;\n    float distortion = gnoise(vec3(0., y * .01, t * 500.)) * (glitchAmount * 4. + .1);\n    distortion *= gnoise(vec3(0., y * .02, t * 250.)) * (glitchAmount * 2. + .025);\n#ifdef ANALOG\n    ++displayNoise;\n    distortion += smoothstep(.999, 1., sin((uv.y + t * 1.6) * 2.)) * .02;\n    distortion -= smoothstep(.999, 1., sin((uv.y + t) * 2.)) * .02;\n    st = uv + vec2(distortion, 0.);\n    // chromatic aberration\n    col.r += textureLod(iChannel0, st + eps + distortion, 0.).r;\n    col.g += textureLod(iChannel0, st, 0.).g;\n    col.b += textureLod(iChannel0, st - eps - distortion, 0.).b;\n#else\n    col += texture(iChannel0, uv, 0.).xyz;\n#endif\n    \n#ifdef DIGITAL\n    // blocky distortion\n    float bt = floor(t * 30.) * 300.;\n    float blockGlitch = .2 + .9 * glitchAmount;\n    float blockNoiseX = step(gnoise01(vec3(0., uv.x * 3., bt)), blockGlitch);\n    float blockNoiseX2 = step(gnoise01(vec3(0., uv.x * 1.5, bt * 1.2)), blockGlitch);\n    float blockNoiseY = step(gnoise01(vec3(0., uv.y * 4., bt)), blockGlitch);\n    float blockNoiseY2 = step(gnoise01(vec3(0., uv.y * 6., bt * 1.2)), blockGlitch);\n    float block = blockNoiseX2 * blockNoiseY2 + blockNoiseX * blockNoiseY;\n    st = vec2(uv.x + sin(bt) * hash33(vec3(uv, .5)).x, uv.y);\n    col *= 1. - block;\n    block *= 1.15;\n    col.r += textureLod(iChannel0, st + eps, 0.).r * block;\n    col.g += textureLod(iChannel0, st, 0.).g * block;\n    col.b += textureLod(iChannel0, st - eps, 0.).b * block;\n#endif\n    // white noise + scanlines\n    displayNoise = clamp(displayNoise, 0., 1.);\n    col += (.15 + .65 * glitchAmount) * (hash33(vec3(fragCoord, mod(float(iFrame),\n\t\t\t\t\t1000.))).r) * displayNoise;\n    col -= (.25 + .75 * glitchAmount) * (sin(4. * t + uv.y * iResolution.y * 1.75))\n\t\t\t\t\t* displayNoise;\n#ifdef CRT\n    //crt vignette (from https://www.shadertoy.com/view/Ms23DR)\n    float vig = 8.0 * uv.x * uv.y * (1.-uv.x) * (1.-uv.y);\n\tcol *= vec3(pow(vig, .25)) * 1.5;\n    if(uv.x < 0. || uv.x > 1.) col *= 0.;\n#endif\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[574, 599, 620, 620, 718], [720, 744, 766, 778, 2053], [2055, 2089, 2113, 2113, 2147], [2149, 2180, 2199, 2199, 2410], [2413, 2413, 2470, 2470, 4952]], "test": "error"}
{"id": "Wld3z4", "name": "2d SDF Test", "author": "Sciman101", "description": "e", "tags": ["sdf"], "likes": 4, "viewed": 100, "published": "Public", "date": "1576341191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 RING_COL = vec3(.6,.2,.1);\nconst float SCALE = 2.5;\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdSquare(vec2 p, vec2 s) {\n    vec2 b = abs(p) - s;\n\treturn max(b.x,b.y);    \n}\n\n//Thanks iq\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n//Thanks again iq\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-clamp(p.x+p.y,0.0,w)*0.5) - r;\n}\n\n//Rotate a point about the origin\nvec2 rotate(vec2 p, float a) {\n    float s = sin(a);\n  \tfloat c = cos(a);\n    \n    float xnew = p.x * c - p.y * s;\n  \tfloat ynew = p.x * s + p.y * c;\n    \n    return vec2(xnew,ynew);\n}\n\n//Given a point, find the closest distance\nfloat scene(vec2 p) {\n    \n    float st = sin(iTime);\n    \n    //p = rotate(p,length(p)*st);\n    \n    float repeat = .75;\n    vec2 pr = mod(p,repeat)-repeat/2.;\n    \n    float square = abs(sdSquare(rotate(pr,iTime),vec2(.2)))-.025;\n    float x = sdRoundedX(rotate(pr,0.7853982),.75,.1);\n    \n  \t//float circle = sdCircle(p-vec2(sin(iTime),cos(iTime))*.5,.2);\n    \n    return max(square,-x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord/iResolution.xy - .5) * SCALE;\n\n    //Multiply by aspect\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Get distance from point to nearest surface\n    float dist = scene(uv);\n    vec3 col;\n    if (dist <= 0.) {\n        col = vec3(1.);\n    }else{\n        //Get ring\n        float rings = step(mod(dist*100.0-iTime*5.0,7.5),.5);\n\n        col = mix(RING_COL,RING_COL*.75,rings)*(3.-dist);\n        col = col * .5;\n        \n        //Get mouse position\n        vec2 mp = (iMouse.xy / iResolution.xy - .5) * SCALE;\n        mp.x *= iResolution.x / iResolution.y;\n        \n        float mDist = distance(uv,mp);\n        vec2 mDir = normalize(mp-uv);\n        \n        //Gradient for light, thanks cleiprelli\n        col /= 1. + mDist*mDist;\n        \n        float t = 0.;\n        float k;\n        float minK = 1000.;\n        while (t < mDist) {\n            k = scene(uv+mDir*t);\n            minK = min(k,minK);\n            if (k < .0001) {\n                col *= .5;\n                break;\n            }\n            t += k;\n        }\n    }\n\t\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wld3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 97, 97, 125], [127, 127, 159, 159, 212], [214, 226, 278, 278, 377], [378, 396, 451, 451, 520], [522, 556, 586, 586, 740], [742, 785, 806, 806, 1177], [1179, 1179, 1236, 1291, 2417]], "test": "ok"}
{"id": "wld3zj", "name": "paraMejorarV3", "author": "jorge2017a1", "description": "paraMejorarV3", "tags": ["paramejorarv3"], "likes": 2, "viewed": 34, "published": "Public", "date": "1576941452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\nconst int CCero = 0;\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\nconst int CPlane3 =10;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec2 glfragCoord;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    case 11:\n         return texture(iChannel0, vec2(glfragCoord.x,glfragCoord.y)).xyz;\n     case 12:\n        return   texture(iChannel1, vec2(glfragCoord.x,glfragCoord.y)).xyz+vec3(0.425, 0.56, 0.9)/1.5;\n    } \n}\n\n\n\n//--------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//-------------------------------------------------\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opTwistBx(  in vec3 p )\n{\n    const float k =40.0; //10.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.yx,p.y);\n    //return primitive(q);\n    \n    return  sdBox(q-vec3(-2.0,2.0,4.5),vec3(0.2,2.5,0.5));\n}\n\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n///--------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    float dif4;\n    \n    \n    d=999.9;\n    \n    float planeDist = p.y+3.0;\n    \n    vec2 res;\n    res=vec2(999.9);\n    \n  \n    vec3 pp;\n    pp=p;\n    \n    vec3 pr;\n    pr=p;\n    pr.xz*= rotate(iTime * 0.5);\n    \n    \n    //piso grande\n    float sdbg1= sdBox(  pr- vec3(0,0.5,0), vec3(5,0.5,5));\n    \n    //columnas\n    float sdbc1= sdBox(  pr- vec3(-4,0.5,4), vec3(0.5,7.0,0.5));\n    float sdbc2= sdBox(  pr- vec3(4,0.5,4), vec3(0.5,7.0,0.5));\n    float sdbc3= sdBox(  pr- vec3(-4,0.5,-4), vec3(0.5,7.0,0.5));\n    float sdbc4= sdBox(  pr- vec3(4,0.5,-4), vec3(0.5,7.0,0.5));\n    \n    \n    pp.xz = mod(p.xz, 2.0) - vec2(0.1,1.0);\n    \n    \n    //piso inferior\n    float sdb1= sdBox(  pp- vec3(0,0,0), vec3(1,0.5,1));\n    float sdb2= sdBox(  pp- vec3(2,0,0), vec3(1,0.5,1));\n    float sdb3= sdBox(  pp- vec3(0,0,1), vec3(1,0.5,1));\n    float sdb4= sdBox(  pp- vec3(2,0,1), vec3(1,0.5,1));\n    \n    vec3 pbB=vec3(1.0,3.5,1.0);\n    vec3 pbBPos=vec3(0,2.5,0);\n    pbBPos.xz *= rotate(iTime *2.0 );\n    \n    vec3 prs=p;\n    prs.xz*=rotate( p.y);\n    \n    \n    float bx1 = sdBox(prs-pbBPos,pbB);\n    \n    res=vec2(planeDist,4);\n    res=opU(res, vec2(sdb1,3));\n    res=opU(res, vec2(sdb2,5));\n    res=opU(res, vec2(sdb3,5));\n    res=opU(res, vec2(sdb4,3));\n    res=opU(res, vec2(sdbg1,6));\n    \n    \n    res=opU(res, vec2(sdbc1,12));\n    res=opU(res, vec2(sdbc2,12));\n    res=opU(res, vec2(sdbc3,12));\n    res=opU(res, vec2(sdbc4,12));\n    \n    \n    res=opU(res, vec2(bx1,11));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    glfragCoord=uv;\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    //vec3 ro = vec3(0, 2.5, -1.5+4.5*sin(iTime));\n    //vec3 ro = vec3(0, 2.5, -1.5+4.8*sin(iTime*0.5));\n    vec3 ro = vec3(0, 2.5, -10);\n    \n\n    \n    vec3 rLuz=vec3(10.5, 8.5, 50.5);\n    \n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    \n    \n    //float dif = GetLight(p);\n    float dif = GetLightv2(p+vec3(0,4,5));\n    \n    //float dif2 = abs(1.0- GetLight( pluz));\n    float dif2 = abs(1.0- GetLightv2( pluz));\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n  \n    dif=(dif+dif2)/1.5;\n    \n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 408, 441, 441, 506], [507, 525, 561, 561, 630], [631, 646, 677, 677, 827], [828, 848, 884, 884, 971], [972, 988, 1020, 1048, 1109], [1162, 1162, 1208, 1208, 1240], [1242, 1242, 1284, 1284, 1316], [1318, 1318, 1365, 1365, 1398], [1401, 1401, 1430, 1430, 1556], [1611, 1611, 1639, 1639, 2811], [2815, 2862, 2898, 2898, 3001], [3057, 3057, 3102, 3102, 3193], [3196, 3196, 3227, 3227, 3491], [3494, 3494, 3516, 3516, 3583], [3585, 3633, 3658, 3658, 5300], [5303, 5303, 5337, 5337, 5571], [5577, 5577, 5601, 5601, 5833], [5837, 5837, 5861, 5861, 6246], [6249, 6249, 6275, 6275, 6667], [6674, 6674, 6731, 6731, 7667]], "test": "error"}
{"id": "Wld3zM", "name": "Inside an Infinity Mirror", "author": "RobRob", "description": "This shader was made for someone very special. It is based on an infinity mirror we gazed at for a long time.\n\nRobRob\n\nNote: There are probably better techniques for rendering scenes like these. If so, please let me know. :)", "tags": ["3d", "raymarching", "rgb", "bloom", "rainbow", "modulo", "mirror", "infinity", "robrob"], "likes": 20, "viewed": 955, "published": "Public API", "date": "1575927914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n// International License.\n\n// Created by RobRob for display on shadertoy.com.\n\n// Number of spheres that spawn randomly.\n#define SPHERE_AMOUNT 14.\n\n// Determines how quickly the camera moves through space.\n#define MOVEMENT_SPEED 4.\n\n// Determines how long it takes before the spectrum repeats itself.\n// Values between [0, 1] make it go faster, values larger than 1 make it go slower.\n#define SPECTRUM_SPEED 4.\n\n// Determines how often colours repeat. Larger values will show more coloured 'stripes'.\n#define SPECTRUM_REPETITION 2.\n\n// All lights will spawn between [-interval, interval] on the x and y-axes.\n#define INTERVAL 40.\n\n// Repetition period per axis. Set to 0 for no repetitions.\n// This case means repetition on the y and z axes.\n#define REPEAT vec3(0., 5., 5.)\n\n#define MAX_STEPS 50\n#define MAX_DIST 1000.\n#define SURF_DIST .02\n#define Z_PLANE 15.\n#define FLOAT_MAX 3.402823466e+38\n#define WORLD_UP vec3(0., 1., 0.)\n#define WHITE vec3(1.)\n\n// Credits to David Hoskins for the hash21() function.\n// Can be found at https://www.shadertoy.com/view/3t23DD\n// Licensed under\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Note that the function in this shader was modified slightly.\n\n// Take a float as input and return two random floats in range [0, 1].\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.2602, .0905, .2019));\n\tp3 += dot(p3, p3.yzx + 19.98);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Return the distance to the closest sphere from point p.\nfloat GetSphereDist(vec3 p) {\n    \n    // All spheres will have this radius.\n    // Note that there appear to be more spheres along the\n    // z-axis due to the repeated rendering that we do below.\n    \n    // Radius will be in range [0.09, 0.99]\n    float radius = (sin(iTime / 6.) + 1.1) * .09;\n    \n    float minDist = FLOAT_MAX;\n    \n    // Calculate the distance to the closest sphere.\n    // Note that the position of the spheres is randomly generated\n    // based on 'i' in the loop below.\n    for (float i = 0.; i < SPHERE_AMOUNT; i++) {\n        // Every sphere's 'real' position will be at z = Z_PLANE.\n        // However, due to the repeated rendering (see below)\n        // there appear to be many more spheres.\n        vec3 pos = vec3(hash21(i), Z_PLANE);\n        \n        // Convert values from [0, 1] to [-interval, interval].\n        pos.xy = pos.xy * INTERVAL * 2. - INTERVAL;\n            \n    \t// Repeater set-up based on Bekre's UFO shader, retrieved from:\n    \t// https://www.shadertoy.com/view/4dXGD4\n        \n        // Do the same as:\n\t\t// vec3 repeater = mod(p - pos, REPEAT) - 0.5 * REPEAT;\n        // But make mod(x, 0) = x, which is not defined on all platforms.\n        vec3 repeater = p - pos;\n        for(int zeroOneTwo = 0; zeroOneTwo < 3; zeroOneTwo++) {\n            if (REPEAT[zeroOneTwo] > 0.) {\n                repeater[zeroOneTwo] = mod(repeater[zeroOneTwo], REPEAT[zeroOneTwo]);\n            }\n        }\n        repeater -= 0.5 * REPEAT;\n        \n\t\tfloat dist = length(repeater) - radius;\n        \n        if (dist < minDist) {\n            minDist = dist;\n        }    \n    }\n    \n    return minDist;\n}\n\n// Return (distance, distance to closest object,\n// x-coordinate of hit, y-coordinate of hit).\n// Distance is -1 if there is no hit.\nvec4 RayMarch(vec3 origin, vec3 direction) {\n\t\n    float distance = 0.;\n    float closest = FLOAT_MAX;\n    vec2 closestPoint = vec2(0.);\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        \n    \tvec3 p = origin + direction * distance;        \n        float sphereDistance = GetSphereDist(p);\n        \n        distance += sphereDistance;\n        \n        // If the calculated distance to the closest sphere\n        // is smaller than what it was, update it and\n        // update the hit point as well.\n        if (sphereDistance < closest ) {\n            closest = sphereDistance;\n            closestPoint = p.xy;\n        }\n        \n        if (distance > MAX_DIST) {\n            // No hit\n            return vec4(-1, closest, closestPoint);\n        }\n        \n        if (sphereDistance < SURF_DIST) {\n            // Sphere hit\n            return vec4(distance, 0, closestPoint);\n        }\n    }\n    \n    // No hit\n    return vec4(-1, closest, closestPoint);\n}\n\n// Starting point of the application.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Basic camera and raymarching setup adapated from\n    // \"ShaderToy Tutorial - CameraSystem\"\n    // found at https://www.shadertoy.com/view/4dfBRf\n\t// by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n    // Licensed under\n\t// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    // The middle pixel will become (0, 0).\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;    \n    \n    // Set the camera position.\n    vec3 cameraPos = vec3(0., 1., iTime * MOVEMENT_SPEED);\n    \n    // Set the point we look at.\n    float t = iTime / 4.;\n    vec3 look = cameraPos + vec3(cos(t), sin(t), 3.);\n    \n    // Calculate the camera parameters.\n    vec3 forward = normalize(look - cameraPos);\n    vec3 right = normalize(cross(WORLD_UP, forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    // Calculate the 3D coordinate of the current pixel.\n    vec3 intersection = cameraPos + forward + uv.x * right + uv.y * up;\n    \n    // Calculate the ray from the camera through this pixel.\n    vec3 cameraDir = normalize(intersection - cameraPos);\n\n    // Perform ray marching.\n    vec4 rayMarch = RayMarch(cameraPos, cameraDir);\n    \n    // The distance from the camera to the object\n    // if the ray hits, or -1 for no hit.\n    float distance = rayMarch.x;\n    \n    if (distance == -1.) {\n        // No hit, calculate bloom.\n        \n        // The coordinates of the point closest to the ray.\n        vec2 xy = rayMarch.zw;\n        \n        // Convert the coordinates from [-interval, interval]\n        // to [0, 1].\n        xy = (xy + INTERVAL) / (2. * INTERVAL);\n        \n        // Calculate the bloom color based on the point's coordinates and the time.\n        \n        // Calculation based on defcon8's RGB Rainbow shader found at\n        // https://www.shadertoy.com/view/MsByzV\n        vec3 col =\n            sin(\n            \tSPECTRUM_REPETITION * (xy.x + xy.y + iTime / SPECTRUM_SPEED)\n                + vec3(0, 2, 4)\n        \t)\n            * .5 + .5;\n        \n        // The distance from the ray to the closest point.\n        float closest = rayMarch.y;\n        \n        // Bloom calculation adapted from takumifukasawa's\n        // emissive cube shader found at\n        // https://www.shadertoy.com/view/wd2SWD\n        vec3 bloom = col * pow(closest + 1., -2.);\n        \n        fragColor = vec4(bloom, 1.);        \n    } else {\n        // Hit a sphere, render white.\n        fragColor = vec4(WHITE, 1.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wld3zM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[1320, 1391, 1413, 1413, 1546], [1548, 1607, 1636, 1853, 3244], [3246, 3379, 3423, 3423, 4341], [4343, 4381, 4436, 4798, 6916]], "test": "ok"}
{"id": "Wld3zr", "name": "Emanating Rocks (Cellular Noise)", "author": "KdotJPG", "description": "Marching a cone (mapped to the plane) through some 3D Cellular noise (F2-F1), to create an Emanating animated rocky effect.", "tags": ["noise", "cellular", "emanating"], "likes": 12, "viewed": 176, "published": "Public", "date": "1575480168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cellular/Worley Noise by Stefan Gustavson\n// https://github.com/Erkaman/glsl-worley\n// https://github.com/Erkaman/glsl-worley/blob/master/LICENSE\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / maxRes;\n    vec2 center = iResolution.xy / maxRes / 2.0;\n    float uvFade = dot(uv - center, uv - center) * 16.0;\n    uv = (uv - center) * 12.0;\n    float dist = length(uv);\n    \n    vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386 - dist * 1.4);\n    \n    // Re-orient to hide subtle cubic boundaries in the flow.\n    // This is an orthonormal matrix that takes Z up the main diagonal.\n    X = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626) * X;\n    \n    // F2-F1 noise\n    float noise = dot(worley(X, 1.0, false), vec2(-1.0, 1.0));\n    \n    float value = (noise + 1.0 - uvFade) / 2.0;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.0, 1.0, 1.0) * value;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wld3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 197, 219, 219, 264], [266, 266, 326, 326, 411], [413, 413, 472, 472, 4912], [4915, 4915, 4970, 5041, 6013]], "test": "ok"}
{"id": "wld3zs", "name": "Training 08 (Copo)", "author": "coposuke", "description": "Training.\nreference http://glslsandbox.com/e#41999.0.", "tags": ["training"], "likes": 6, "viewed": 104, "published": "Public", "date": "1577604667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI    3.14159265357989\n#define PI_2  1.57079632678994\n\nfloat rope(float dist, float angle, float time, float twist, float thickness)\n{\n    //http://glslsandbox.com/e#41999.0\n    vec4 s = thickness * cos(vec4(0,1,2,3) * PI_2 + time + twist);\n    vec4 e = s.yzwx;\n    vec4 f = max(dist - s, e - dist);\n    return -dot(clamp(f * 500.0, 0.0, 1.0), (s - e) / thickness);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.x);\n    vec2 uvBackup = uv;\n    \n    const int DEPTH = 8;\n    for(int i=1 ; i<=DEPTH ; ++i)\n    {\n        float SIZE = 0.43 - 0.065 * float(i);\n        float THICKNESS = 0.045 - 0.0055 * float(i);\n\t    float TWIST = 6.0 + 6.0 * float(i);\n\t    float angle, dist;\n        \n        uv += (i != 1 ? 0.5 / float(i) : 1.0);\n\n        // horizone\n        angle = uv.x;\n        dist = mod(uv.y, SIZE) - SIZE * 0.5;\n        float idH = abs(floor(uv.y / SIZE)) + 1.0;\n        float whichH = cos(idH * PI); // -1 or 1\n\n        vec4 ropeH = rope(dist, angle, iTime * whichH, angle * TWIST, THICKNESS) * vec4(0.5);\n\n        // vertical\n        angle = uv.y;\n        dist = mod(uv.x, SIZE) - SIZE * 0.5;\n        float idV = abs(floor(uv.x / SIZE)) + 1.0;\n        float whichV = cos(idV * PI); // -1 or 1\n\n        vec4 ropeV = rope(dist, angle, iTime * whichV, angle * TWIST, THICKNESS) * vec4(0.5);\n\n        // mix\n        float alpha = ropeH.a;\n        float priority = 0.0;\n        priority += clamp(whichH * whichV * step(0.01, ropeV.a), 0.0, 1.0);\n        priority += clamp(whichH * -whichV * step(ropeH.z, 0.01), 0.0, 1.0);\n        priority = clamp(priority, 0.0, 1.0);\n\n        vec4 sH = cos(vec4(0,1,2,3) * PI_2 + uv.y * 50.0 + iTime);\n        sH = sH * 0.05 + 1.7;\n        sH.a = 1.0;\n        \n        vec4 sV = cos(vec4(0,1,2,3) * PI_2 + uv.x * 50.0 + iTime);\n        sV = sV * 0.05 + 1.7;\n        sV.a = 1.0;\n        \n        vec4 color = vec4(0);\n        color = mix(ropeH * sH, ropeV * sV, priority);\n        color *= 1.0 - float(i) / float(DEPTH);\n\n\t\tfragColor = mix(color, fragColor, step(0.01, fragColor.a));\n    }\n\n    vec4 s = cos(vec4(0,1,2,3) * PI_2 + atan(uvBackup.y, uvBackup.x) + iTime);\n    vec4 f = max(length(uvBackup) - s, s.yzwx - length(uvBackup));\n    float bg = step(length(fragColor.rgb), 0.1);\n    fragColor += (1.0 - bg) * f * 0.05;\n    fragColor += bg * vec4(0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wld3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 142, 181, 375], [378, 378, 435, 435, 2426]], "test": "timeout"}
{"id": "wldGD8", "name": "Planet Reboot", "author": "dr2", "description": "After the apocalypse... (mouseable)", "tags": ["voronoi", "terrain", "life", "tube", "kinematics"], "likes": 6, "viewed": 341, "published": "Public API", "date": "1576231342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Planet Reboot\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec2 HexVor (vec2 p);\nmat3 StdVuMat (float el, float az);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 arcLimV[2];\nfloat tCur, tCyc, dstFar, rBase, rIn, sLoopV[2], aLoopV[2], rLoop, armP, kMin, rBilGrnd, szVeg;\nint idObj;\nconst int idArm = 1, idArmE = 2, idCylL = 3, idCylU = 4, idVeg = 5, idGrnd = 6;\nconst float nArm = 6.;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 sv;\n  float dMin, d, s, sLoop, aLoop, t, r, h, hVeg;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  h = 0.;\n  if (r < rBilGrnd) {\n    sv = HexVor (0.5 * q.xz + 0.05 * Noisev2v2 (4. * q.xz));\n    h += 0.2 * (smoothstep (0.01 + 0.01 * sv.y, 0.1 + 0.03 * sv.y, sv.x) - 1.) *\n       (1. - smoothstep (0.8, 1., r / rBilGrnd));\n  }\n  q = p;\n  d = 0.5 * (q.y - h - 1.5e-3 * r * r);\n  DMIN (idGrnd);\n  p.y -= rIn + 0.15;\n  for (float k = 0.; k < nArm / 2.; k ++) {\n    q = p;\n    q.xz = Rot2D (q.xz, (2. * pi / nArm) * k);\n    if (k == armP) {\n      sLoop = sLoopV[0];\n      aLoop = aLoopV[0];\n    } else {\n      sLoop = sLoopV[1];\n      aLoop = aLoopV[1];\n    }\n    q.xy = Rot2D (vec2 (rBase - abs (q.x), q.y - rLoop * sLoop), aLoop - 0.5 * pi);\n    s = mod ((64. / aLoop) * atan (q.y, - q.x) / pi + 0.5, 1.);\n    r = length (vec2 (length (q.xy) - rLoop * sLoop, q.z)) - rIn;\n    d = max (r - 0.02 * SmoothBump (0.25, 0.75, 0.1, s), - r - 0.15);\n    d = 0.8 * max (d, dot (vec2 (q.x, abs (q.y)), ((k == armP) ? arcLimV[0] : arcLimV[1])));\n    if (d < dMin) {\n      dMin = d;\n      idObj = idArm;\n      qHit = q;\n      kMin = k;\n    }\n    q.xy = Rot2D (q.xy, aLoop) - vec2 (- rLoop * sLoop, 0.27);\n    d = max (PrRoundCylDf (q.xzy, rIn + 0.03, 0.1, 0.3), rIn - 0.15 - length (q.xz));\n    if (d < dMin) kMin = k;\n    DMIN (idArmE);\n  }\n  q = p;\n  d = PrRoundCylDf (q.xzy, rBase + 0.05, 0.15, rIn + 0.1);\n  DMIN (idCylL);\n  q = p;\n  q.y -= 3. * rIn;\n  d = PrRoundCylDf (q.xzy, 0.5 * rBase, 0.1, 3. * rIn);\n  DMIN (idCylU);\n  hVeg = 0.03 + 0.22 * szVeg;\n  q = p - vec3 (10.9, -0.3 + hVeg, 9.9);\n  d = PrCylDf (q.xzy, 0.03, hVeg);\n  q.y -= hVeg;\n  q.xz = abs (q.xz) - max (0.08 * (1. + szVeg) - 0.1, 0.02);\n  d = min (d, PrSphDf (q, 0.05 * (1. + szVeg)));\n  DMIN (idVeg);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.03;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (3. * h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, sunCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  q = 0.01 * (ro.xz + 16. * tCur + ((128. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  sd = clamp (dot (sunDir, rd), 0., 1.);\n  sunCol = 2. * vec3 (1., 0.8, 0.7) * pow (sd, 1024.) + vec3 (1., 0.4, 0.2) * pow (sd, 256.);\n  return 0.5 * col + 0.5 * Maxv3 (col) * vec3 (1., 0., 0.) + sunCol;\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec4 col4;\n  vec3 vn;\n  vec2 sv;\n  float nDotL, sh, s, a;\n  vn = ObjNf (ro);\n  nDotL = max (dot (vn, sunDir), 0.);\n  if (idObj == idArm) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2);\n    if (length (vec2 (length (qHit.xy) - rLoop *\n       ((kMin == armP) ? sLoopV[0] : sLoopV[1]), qHit.z)) < rIn - 0.01)\n       col4 = vec4 (0.6 + 0.4 * sin (512. * atan (qHit.y, - qHit.x) + 5. * tCur), 0., 0., -1.);\n    nDotL *= nDotL;\n  } else if (idObj == idArmE) {\n    col4 = vec4 (0.8, 0.7, 0.8, 0.1);\n    nDotL *= nDotL;\n  } else if (idObj == idCylL) {\n    col4 = vec4 (0.8, 0.8, 0.7, 0.1);\n  } else if (idObj == idCylU) {\n    col4 = vec4 (0.8, 0.8, 0.7, 0.1);\n    a = atan (ro.z, - ro.x) / (2. * pi);\n    if (abs (vn.y) < 0.01) col4.rgb *= 0.9 + 0.1 * sin (60. * pi * a);\n    s = length (Rot2D (ro.xz, 2. * pi * (floor (6. * a + 0.5) / 6.)) + vec2 (0.7, 0.)) - rIn;\n    if (s < 0.) {\n      if (s < -0.1) col4 = vec4 (0.6 + 0.4 * sin (5. * tCur), 0., 0., -1.);\n      else col4.rgb *= 0.7;\n    }\n  } else if (idObj == idVeg) {\n    col4 = vec4 (0., 0.6, 0., 0.1);\n  } else if (idObj == idGrnd) {\n    s = Fbm2 (16. * ro.xz);\n    col4 = mix (vec4 (0.4, 0.4, 0.45, 0.05), vec4 (0.5, 0.3, 0.1, 0.) *\n       (0.9 + 0.2 * smoothstep (0.5, 0.6, s)), smoothstep (0.35, 0.4, s));\n    vn = VaryNf (8. * ro, vn, 2. - 1.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n    nDotL = max (dot (vn, sunDir), 0.);\n    s = length (ro.xz);\n    if (s > 0.8 * rBilGrnd) {\n      sv = HexVor (0.5 * ro.xz + 0.05 * Noisev2v2 (4. * ro.xz));\n      col4 *= mix (0.6 + 0.4 * smoothstep (0.01 + 0.01 * sv.y, 0.1 + 0.03 * sv.y, sv.x), 1.,\n         smoothstep (0.3, 0.8, s / dstFar));\n    } else col4 *= 0.5 + 0.5 * smoothstep (-0.2, -0.02, ro.y - 1.5e-3 * s * s);\n  }\n  if (col4.a >= 0.) {\n    sh = min (ObjSShadow (ro, sunDir), 1. - 0.3 * smoothstep (0.4, 0.6,\n       Fbm2 (0.1 * ro.xz + 0.2 * tCur)));\n    col4.rgb = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, colR;\n  float dstObj;\n  int idObjP;\n  bool doRefl;\n  rIn = 0.3;\n  rBase = 2.8;\n  rLoop = 6.;\n  tCyc = 8.;\n  armP = floor (mod (tCur / tCyc, nArm / 2.));\n  sLoopV[0] = 1./3. + 100. * pow (1. - SmoothBump (0.25, 0.75, 0.22, mod (tCur / tCyc, 1.)), 2.);\n  sLoopV[1] = 1./3. + 100.;\n  for (int k = 0; k < 2; k ++) {\n    aLoopV[k] = 0.25 * pi / sLoopV[k];\n    arcLimV[k] = sin (aLoopV[k] + vec2 (0., 0.5 * pi));\n  }\n  szVeg = SmoothBump (0.25, 0.75, 0.2, mod (tCur / 10., 1.));\n  HexVorInit ();\n  doRefl = false;\n  rBilGrnd = 25.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    idObjP = idObj;\n    ro += dstObj * rd;\n    col4 = ObjCol (ro, rd, dstObj);\n    if (col4.a >= 0. && idObjP != idVeg && idObjP != idGrnd) doRefl = true;\n    col = col4.rgb;\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (doRefl) {\n    rd = reflect (rd, ObjNf (ro));\n    ro += 0.01 * rd;\n    rBilGrnd = 5.;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      colR = ObjCol (ro, rd, dstObj).rgb;\n    } else {\n      colR = SkyCol (ro, rd);\n    }\n    col = mix (col, 0.9 * colR, 0.6);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, tSmooth;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = -0.05 * pi + pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 2.);\n    tSmooth = (floor (32. * t) + smoothstep (0.8, 1., mod (32. * t, 1.))) / 32.;\n    az = 2.5 * pi * (0.5 - abs (tSmooth - 1.));\n    el = -0.05 * pi - 0.14 * pi * (0.5 + 0.5 * cos (2. * az));\n  }\n  el = clamp (el, -0.4 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -25.);\n  zmFac = 3. + 0.6 * el;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec2 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec2 (SmoothMin (sd.y, sd.z, 0.1) - sd.x, Hashfv2 (udm.zw));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v2 (vec2 p)\n{\n  return vec2 (Noisefv2 (p), Noisefv2 (p + vec2 (17., 23.)));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldGD8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1077, 1077, 1099, 1099, 2895], [2897, 2897, 2930, 2930, 3135], [3137, 3137, 3158, 3158, 3355], [3357, 3357, 3394, 3394, 3647], [3649, 3649, 3681, 3681, 4340], [4342, 4342, 4388, 4388, 6404], [6406, 6406, 6441, 6441, 7618], [7620, 7620, 7673, 7673, 8541], [8543, 8543, 8576, 8576, 8603], [8605, 8605, 8647, 8647, 8698], [8700, 8700, 8757, 8757, 8921], [8923, 8923, 8947, 8947, 9177], [9179, 9179, 9203, 9203, 9263], [9289, 9289, 9309, 9309, 9529], [9531, 9531, 9553, 9553, 10147], [10149, 10149, 10185, 10185, 10391], [10393, 10393, 10415, 10415, 10453], [10455, 10455, 10485, 10485, 10598], [10600, 10600, 10645, 10645, 10748], [10750, 10750, 10807, 10807, 10890], [10924, 10924, 10948, 10948, 11008], [11010, 11010, 11034, 11034, 11164], [11166, 11166, 11191, 11191, 11377], [11379, 11379, 11404, 11404, 11468], [11470, 11470, 11491, 11491, 11646], [11648, 11648, 11677, 11677, 11889], [11891, 11891, 11930, 11930, 12110]], "test": "error"}
{"id": "WldGDX", "name": "failTunelLuzn1", "author": "jorge2017a1", "description": "failTunelLuzn1", "tags": ["failtunelluzn1"], "likes": 0, "viewed": 73, "published": "Public", "date": "1577754687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\nvec3 glpRoRdNoMov;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n///--------------------------------------------\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\t//return textureLod(iChannel0,(p+.5)/32.,-16.).x;\n    return texture(iChannel0,p.xy).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*25.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n///--------------------------------------------\n\n///--------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n\tcase 11:\n        //float pattern = fract( 1.-Granite( glpRoRd)*8.) ;\t\n        float pattern = abs( 1.-Granite( glpRoRd)*0.15) ;\t\n        //return Granite(glpRoRd)*vec3(0.2,0.5,0.3);\n        return pattern*vec3(1.0);\n     case 12:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd); \n     case 13:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(-glpRoRdNoMov.zyx); \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n            //res=vec2(res.x, 12);\n         } \n     } \n    \n    \n    p.xz=opRep( p.xz, 15. );\n    \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,5.5,0.), vec3(15,5.8,5) );\n    float sdb2=sdBox(p-vec3(0.0,6.0,0.), vec3(7,5.2,7.0) );\n    \n    float sdb3d=sdBox(p-vec3(0.0,6.0,0.), vec3(1,1.0,1.0) );\n    \n    \n    \n    float sdb3pisoi=sdBox(p-vec3(-5.0,3.0,0.0), vec3(3,1.1,2.) );\n    float sdb4pisod=sdBox(p-vec3(5.0,3.0,0.0), vec3(3,1.1,2.) );\n    \n    float sdb5pisoi=sdBox(p-vec3(-5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    float sdb6pisod=sdBox(p-vec3(5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    \n    \n   \n    dif2=differenceSDF(sdb1,sdb3pisoi);\n    dif2=differenceSDF(dif2,sdb4pisod);\n    dif2=differenceSDF(dif2,sdb5pisoi);\n    dif2=differenceSDF(dif2,sdb6pisod);\n    \n\n    dif1=differenceSDF(dif2,sdb2);\n    \n    \n    res=opU(res, vec2(dif1,13));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\t\n    vec3 ro = vec3(0.1, 2.0, -15.0 + iTime+cos(iTime));\n\tvec3 ta = vec3(0.0, 2.4, 0.7 + iTime);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = cross(fwd, vec3(0, 1, 0));\n\tvec3 up = cross(right, fwd);\n\tvec3 rd = normalize(fwd + uv.x * right + uv.y * up);\n\n    \n    \n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    \n    vec3 rLuz=vec3(0, 0.0,  -15.5+iTime*0.5);\n    \n    vec3 rLuz3=vec3(0., 0.0,iTime*0.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n   \n    glpRoRdNoMov=p;\n    \n    \n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n   \n    float dif = GetLightv2(p);\n    \n    float dif2 =1.-  GetLightv2(pluz);\n    float dif3 =1.0 - GetLightv2(pluz3);\n    \n    vec3 c = vec3(float(dif) * 0.02);\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    \n    dif=(dif+dif3)/1.5;\n    \n    col = vec3(dif)*colobj+c;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldGDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 378, 411, 411, 476], [477, 495, 531, 531, 600], [601, 616, 647, 647, 797], [798, 818, 854, 854, 941], [942, 958, 990, 1018, 1079], [1082, 1092, 1128, 1128, 1401], [1454, 1454, 1500, 1500, 1532], [1534, 1534, 1576, 1576, 1608], [1610, 1610, 1657, 1657, 1690], [1693, 1693, 1722, 1722, 1848], [1850, 1850, 1886, 1886, 2003], [2005, 2005, 2041, 2041, 2159], [2213, 2213, 2236, 2236, 2395], [2398, 2398, 2425, 2425, 2603], [2703, 2715, 2737, 2737, 3045], [3047, 3047, 3072, 3072, 3262], [3311, 3311, 3339, 3339, 4704], [4758, 4867, 4904, 4904, 4939], [4942, 4942, 4967, 4967, 6319], [6322, 6322, 6356, 6356, 6590], [6593, 6593, 6617, 6617, 6849], [6853, 6853, 6877, 6877, 7262], [7265, 7265, 7291, 7291, 7655], [7701, 7701, 7773, 7773, 7800], [7802, 7802, 7859, 7859, 9007]], "test": "error"}
{"id": "WldGWB", "name": "Sci-Fi (unfinished)", "author": "Tara", "description": "Unfinished\nThis is based on some artwork I forgot where to find.", "tags": ["raymarching", "scifi"], "likes": 4, "viewed": 156, "published": "Public", "date": "1577454066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO: Use the actual distance fields for advancing the ray!\n\n//#define RENDER_DEPTH\n#define ENABLE_FOG\n//#define ANIMATE_CUBES\n\nconst int max_shadow_ray_samples = 32;\nconst int max_ray_samples = 512;\t// TODO: Rename to \"max_view_ray_samples\".\nconst float max_view_distance = 12.0;\t// TODO: Adjust!\nconst float wall_distance = 0.3;\n\nconst vec3 light_color_blue = vec3(0.2, 0.275, 1.0) * 40.0;\nconst vec3 light_color_pink = vec3(1.0, 0.325, 0.35) * 10.0;\n\n//const vec3 fog_color = vec3(0.2, 0.2, 1.0) * 1.7;\nconst vec3 fog_color = light_color_blue * 0.1;\n\n// Perlin noise:\nfloat mod289(float x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod289(vec4 x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 perm(vec4 x)\n{\n\treturn(mod289(((x * 34.0) + 1.0) * x));\n}\n\nfloat perlin_2d(vec2 p)\n{\n    vec2 a = floor(p);\n    vec2 d = p - a.xy;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = vec4(a.x, a.x + 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.yyyy;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.y + o1 * (1.0 - d.y);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return(o4.y * 0.0 + o4.x * 1.0);\n}\n\nfloat calculate_height(vec3 position)\n{\n    vec2 p = round(position.yz * 3.0) / 3.0;\t// Round the coordinates so we get a blocky heightmap.\n     \n\tfloat n = //perlin_2d(p) +\n              //0.5 * perlin_2d(p * 2.0) +\n                0.25 * perlin_2d(p * 4.0) +\n                0.125 * perlin_2d(p * 8.0) +\n                0.0625 * perlin_2d(p * 16.0) +\t// TODO: PERFORMANCE: How detailed does the noise function need to be?\n                0.03125 * perlin_2d(p * 32.0);\n              //+ 0.015625 * perlin_2d(p * 64.0);\n    \n    \n    \n   \n    \n    // TODO: Instead of calculating an offset for the noise every frame,\n    //       how about simply transforming the ray instead?\n    \n    /*\n#ifdef ANIMATE_CUBES\n    float noise_value = wall_distance + max(n * sin(n * 31.42 + iTime * 2.0) * 0.5, 0.0);\n        \n#else\n    float noise_value = wall_distance + n * 0.3;\n#endif\n    */\n    float noise_value = n;\n    \n    return(noise_value);\n    \n    /*\n    float offset_y = step(mod(uv.y * 4.0, 7.0), 1.0);\n    offset_y += step(mod(uv.x * 40.0, 3.0), 1.0);\n    offset_y *= step(mod(uv.x * 40.0, 3.0), 1.0);\n\n\treturn(offset_y); \n\t*/\n}    \n\n// Source: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat repeated_box(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    //return primitve(q);\n    return(0.0);\n}\n\n// Source: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat signed_distance_box_repeating(vec3 p, vec3 box_position, vec3 box_dimensions, vec3 spacing)\n{\n    // Translation:\n    p -= box_position;\n    \n    // Repetition:\n    //const vec3 c = vec3(0.0, 0.0, 2.5);\n    //p = mod(p, c) - 0.5 * c;\n    p = mod(p, spacing) - 0.5 * spacing;\n    \n    \n\tvec3 d = abs(p) - box_dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Source: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat signed_distance_box(vec3 p, vec3 box_position, vec3 box_dimensions)\n{\n    // Translation:\n    p -= box_position;\n        \n\tvec3 d = abs(p) - box_dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat signed_distance_plane(vec3 p, vec3 plane_normal, float plane_distance)\n{\n    // Project the point onto the plane:\n    return(dot(plane_normal, p) + plane_distance);\n}\n\nvec3 get_surface_color(vec3 point_of_intersection, float surface_height)\n{\n    \n    if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(vec3(0.1, 0.17, 1.0) * 5.0);\n    }\n    else if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(vec3(0.5, 0.2, 0.2) * 5.0);\n    }\n\n    // TODO: Fix the coordinate offset!\n    float cube_corner_step_z = step(mod(point_of_intersection.z - 0.48, 1.0 / 3.0), 0.025);\n    float cube_corner_step_y = step(mod(point_of_intersection.y - 0.48, 1.0 / 3.0), 0.025);\n\n    vec3 cube_corner_glow = vec3(0.0);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.08, 0.08) * 3.0, cube_corner_step_z);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.08, 0.08) * 3.0, cube_corner_step_y);\n\n    return(cube_corner_glow);\n\n    return(vec3(0.0));\n    return(vec3(surface_height));\n}\n\n\nfloat get_wall_distance(vec3 p, vec3 eye_position)\n{\n    //const float floor_position_y = -2.0;\n    \n    const vec3 wall_left_normal = normalize(vec3(2.0, -1.0, 0.0));\n    const float wall_left_distance = -1.5;\n    \n    const vec3 wall_right_normal = normalize(vec3(-2.0, -1.0, 0.0));\n    const float wall_right_distance = -1.5;\n    \n    const vec3 floor_normal = normalize(vec3(0.0, 1.0, 0.0));\n    const float floor_distance = -3.0;\n    \n    // Project the point onto the plane:\n    float smallest_distance = dot(wall_left_normal, p) - wall_left_distance;\n    smallest_distance = min(smallest_distance, dot(wall_right_normal, p) - wall_right_distance);\n    //smallest_distance = min(smallest_distance, dot(floor_normal, p) - floor_distance);\t// TODO: This one could be simplified.\n\n    \n    \n    \n    const vec3 bottom_wall_left_normal = normalize(vec3(1.0, 0.0, 0.0));\n    const float bottom_wall_left_distance = -3.0;\n    \n    const vec3 bottom_wall_right_normal = normalize(vec3(-1.0, 0.0, 0.0));\n    const float bottom_wall_right_distance = -3.0;\n    \n    smallest_distance = min(smallest_distance, dot(bottom_wall_left_normal, p) - bottom_wall_left_distance);\n    smallest_distance = min(smallest_distance, dot(bottom_wall_right_normal, p) - bottom_wall_right_distance);\n    \n    \n    const vec3 wall_ceiling_left_normal = normalize(vec3(2.5, -1.0, 0.0));\n    const float wall_ceiling_left_distance = -0.5;\n    \n    const vec3 wall_ceiling_right_normal = normalize(vec3(-2.5, -1.0, 0.0));\n    const float wall_ceiling_right_distance = -0.5;\n    \n    \n    //smallest_distance = 999.9;\n    \n    float wall_ceiling_distance = dot(wall_ceiling_left_normal, p) - wall_ceiling_left_distance;\n    wall_ceiling_distance = max(wall_ceiling_distance, dot(wall_ceiling_right_normal, p) - wall_ceiling_right_distance);\n    \n    \n\tsmallest_distance = min(smallest_distance, wall_ceiling_distance);\n    \n    \n    // Blocks near the walls:\n    const vec3 block_dimensions = vec3(0.3, 2.0, 0.3);\n    const vec3 block_spacing = vec3(0.0, 0.0, 7.0);\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -4.2, 0.0), block_dimensions, block_spacing));\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(2.6, -4.2, 0.0), block_dimensions, block_spacing));\n\n    // Block sticking out of the walls below the above blocks:\n    smallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.3, -5.1, 0.0), block_dimensions, block_spacing));\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(2.3, -5.1, 0.0), block_dimensions, block_spacing));\n\n    // \"ladders\" going across:\n    float ladder_thickness = 0.035;\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -3.5, 0.3 - ladder_thickness), vec3(5.0, ladder_thickness, ladder_thickness), block_spacing));\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -3.5, -0.3), vec3(5.0, ladder_thickness, ladder_thickness), block_spacing));\n    \n    // \"ladders\" steps:\n    smallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -3.5, 0.0 - ladder_thickness), vec3(ladder_thickness, ladder_thickness, block_dimensions.z), vec3(0.5, 0.0, block_spacing.z)));\n\n    // Long bars along the walls:\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(-2.6, -13.0, -5.0), vec3(0.3, 10.0, 1000000.0)));\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(2.6, -13.0, -5.0), vec3(0.3, 10.0, 1000000.0)));\n\n    \n    // Moving platform:\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(0.0, -1.45, -0.5) + eye_position, vec3(0.5, 0.1, 1.5)));\n\n    \n    \n    \n    // TODO: Add cubes.\n\n    \n    return(smallest_distance);\n    \n    //return(p.y - floor_position_y);\n    //return(distance(vec3(p.x, 0.0, p.z), vec3(0.0)));\t// TODO: Use signed distance!\n    \n    //return(false);\n}    \n\nfloat compute_ambient_occlusion(vec3 position, vec3 normal, float max_distance, int samples, vec3 eye_position)\n{\n    const float surface_offset = 0.001;\n    const float sample_distance = 0.08;\n    \n    float occlusion = 0.0;\n    \n    //float sample_sum = 0.0;\n    \n    for(int i=0; i<8; ++i)\n    { \n        float sample_offset_distance = surface_offset + float(i) * sample_distance;\n        vec3 sample_position = position + normal * sample_offset_distance;\n        float sample_weight = 1.0 / float(i + 1);\n        //sample_sum += sample_weight;\n        \n        //occlusion += sample_weight * sample_offset_distance - get_wall_distance(sample_position, eye_position);\n\t\tocclusion += sample_weight * max(sample_offset_distance - get_wall_distance(sample_position, eye_position), 0.0);\n    }\n    \n    return(1.0 - occlusion);\n}\n\nfloat calculate_shadow(vec3 p, vec3 light_position, vec3 eye_position)\n{    \n    vec3 p_to_light = light_position - p;\n    float p_to_light_distance = length(p_to_light);\n    vec3 n_ray_direction = normalize(p_to_light);\n    \n    p += n_ray_direction * 0.05;\t// Offset\t// TODO: Offset using the normal.\n    \n    float travelled_distance = 0.0;\n    \n    float step_size = p_to_light_distance / float(max_shadow_ray_samples - 1);\t// Incrase the step size so we step over the light.\n        \n    for(int i=0; i<max_shadow_ray_samples; ++i)\n    {\n        travelled_distance += step_size;\n        vec3 sample_point = p + n_ray_direction * travelled_distance;\n        \n        if(get_wall_distance(sample_point, eye_position) < 0.0)\n        {\n            return(0.0);\n        }\n        \n        if(travelled_distance > p_to_light_distance)\n        {\n            return(1.0);\n        }  \n    }\n    \n    return(0.0);\n}\n\nvec3 calculate_lighting(vec3 p, vec3 eye_position, vec3 light_position, vec3 light_color, vec3 n_normal)\n{\n    float ambient_occlusion = compute_ambient_occlusion(p, n_normal, 0.01, 8, eye_position);\n\n    vec3 p_to_light = light_position - p;\n    vec3 n_light_direction = normalize(p_to_light);\n    vec3 direct_lighting_diffuse = light_color * max(dot(n_light_direction, n_normal), 0.0);\n    float squared_p_to_light_distance = dot(p_to_light, p_to_light);\n    direct_lighting_diffuse /= squared_p_to_light_distance;\t// Inverse square falloff.\n    \n    // TODO: Add specular.\n    \n    float shadow = 1.0;\n    \n    //if(1.0 / squared_p_to_light_distance > 0.01)\n    {\n    \tshadow = calculate_shadow(p, light_position, eye_position);\n    }\n            \n    \n    return(shadow * ambient_occlusion * direct_lighting_diffuse);\n\n}  \n\n// Parallax mapping basically:\nvec3 trace_ray(vec3 ray_origin, vec3 n_ray_direction, inout float depth)\n{\n    vec3 eye_position = ray_origin;\n    \n    /*\n    // TODO: Use dot product between Z and X axis only!\n    //float dot_product = max(dot(n_ray_direction, vec3(0.0, 0.0, -1.0)), 0.0);\n    float dot_product = max(dot(normalize(n_ray_direction.xz), vec2(0.0, -1.0)), 0.0);\n    \n    \n    //dot_product = 1.0 - pow(1.0 - dot_product, 2.0);\t// Make the value go bigger towards the center of the screen.\n    dot_product = pow(dot_product, 10.0);\t// Make the value go bigger towards the center of the screen.\n    //return vec3(dot_product);\n    \n    dot_product *= 0.1;\n  \n    \n    // TODO: Do a binary search?\n    \n    float step_size = max(dot_product, 0.01);\n    */\n    \n    \n    /*\n    float intersection_distance = max_view_distance;\n    vec3 bounding_plane_point_of_intersection = intersect_wall_bounding_plane(ray_origin, n_ray_direction, intersection_distance);\n    \n    if(intersection_distance >= max_view_distance)\n    {\n    \treturn(fog_color);\n    }    \n    \n    // Offset the ray to the intersection of the bounding plane to speed up the parallax mapping.\n    ray_origin = bounding_plane_point_of_intersection;\n    \n    */\n        \n    \n    //float step_size = 0.001;\t// TODO: Base step size on something proper.\n    float step_size = max_view_distance / float(max_ray_samples);\t// TODO: Base step size on something proper.\n    float min_step_size = max_view_distance / float(max_ray_samples);\t// TODO: Base step size on something proper.\n        \n    for(int i=0; i<max_ray_samples; ++i)\n    {\n        float distance_to_nearest_surface = get_wall_distance(ray_origin, eye_position);\n        //step_size = max(distance_to_nearest_surface, min_step_size * 0.01);\n        \n        //ray_origin += n_ray_direction * 0.01;\n        ray_origin += n_ray_direction * step_size;\n        \n        //depth = distance(ray_origin, eye_position);\t// TODO: Calculate this differently?\n        \n        \n        if(distance_to_nearest_surface < 0.0)\n        {\n            depth = abs(ray_origin.z - eye_position.z);\n            \n            const float offset = 0.0001;\t// Small enough to hide artifacts but still be correct.\n            \n            vec3 n_normal;\n\t\t\tn_normal.x = get_wall_distance(ray_origin + vec3(offset, 0.0, 0.0), eye_position) - get_wall_distance(ray_origin - vec3(offset, 0.0, 0.0), eye_position);            \n\t\t\tn_normal.y = get_wall_distance(ray_origin + vec3(0.0, offset, 0.0), eye_position) - get_wall_distance(ray_origin - vec3(0.0, offset, 0.0), eye_position);            \n\t\t\tn_normal.z = get_wall_distance(ray_origin + vec3(0.0, 0.0, offset), eye_position) - get_wall_distance(ray_origin - vec3(0.0, 0.0, offset), eye_position);            \n            n_normal = normalize(n_normal);\n            \n            \n            /*\n            float brightness = (sin(ray_origin.z * 10.0) * 0.5 + 0.5) *\n                 \t\t\t   (sin(ray_origin.y * 10.0) * 0.5 + 0.5) *\n                \t\t\t   (sin(ray_origin.x * 10.0) * 0.5 + 0.5);\n            */\n            float wire_texture = step(sin(abs(ray_origin.z) * 10.0), 0.9) *\n                 \t\t\t   step(sin(abs(ray_origin.y) * 10.0), 0.9) *\n                \t\t\t   step(sin(abs(ray_origin.x) * 10.0), 0.9);\n            //brightness = pow(brightness, 2.0);            \n\t\t\t//brightness = step(brightness, 0.5);\n            wire_texture = clamp(1.0 - wire_texture, 0.0, 1.0);\n            \n            //vec3 light_direction = normalize(vec3(0.5, 0.5, 0.5));\n            //vec3 light_direction = normalize(vec3(0.0, 0.0, -1.0));\n            //vec3 light_position = eye_position - vec3(1.0, 0.0, 3.0);\n            \n            vec3 albedo = vec3(wire_texture);\n            //vec3 light_position_pink = eye_position - vec3(0.0, 1.0, 2.0);\n            vec3 light_position_pink = eye_position + vec3(0.0, -4.5, -2.0);\n            \n            vec3 light_position_blue = eye_position + vec3(0.0, -1.0, -10.0);\n            \n            \n            vec3 lighting = vec3(0.0);\n            \n            lighting += calculate_lighting(ray_origin, eye_position, light_position_pink, light_color_pink, n_normal);\n           \tlighting += calculate_lighting(ray_origin, eye_position, light_position_blue, light_color_blue, n_normal);\n           \n            //float ambient_occlusion = compute_ambient_occlusion(ray_origin, normal, 0.01, 8, original_ray_origin);\n            //return(vec3(ambient_occlusion));\n            \n            if(ray_origin.y > -2.0)\n            {\n                lighting += vec3(step(calculate_height(ray_origin * vec3(10.0, 10.0, 5.0)), 0.15)) * \n                    step(sin(0.5 + ray_origin.y * 3.0), 0.0) * \n                    step(sin(ray_origin.z * 2.0), 0.0) *\n                    (sin(iTime * 10.0 + ray_origin.y * 10.0 + ray_origin.z * 10.0 + ray_origin.x * 10.0) * 0.5 + 0.5);\n            }\n            \n            //return vec3(shadow);\n            \n            return(lighting);\n            \n            return(albedo * lighting);\n            \n            //return ray_origin;            \n            \n            //return vec3(max(dot(vec3(0.0, 1.0, 0.0), normal), 0.0));\n            \n            //return normal;\n\n            //return vec3(mod(distance(ray_origin, light_position), 1.0));\n            \n\n            return vec3(wire_texture);\n            \n    \t\treturn(vec3(wire_texture + 0.5)) * 0.25;\n            \n    \t\treturn(vec3(0.0, 0.5, 0.0));\n        }\n        \n        /*\n        float surface_height = calculate_height(ray_origin);\n        //surface_height = 0.1;\n        if(abs(ray_origin.x) > surface_height)\t// TODO: Do the ABS before entering this loop!\n        {\n            depth = distance(ray_origin, eye_position);\t// TODO: Calculate this differently?\n\n            if(depth >= max_view_distance)\n            {\n                depth = max_view_distance;\n                return(fog_color);\n            }\n\n            return(get_surface_color(ray_origin, surface_height));\n        }\n        */\n    }\n    \n    depth = max_view_distance;\n\n    return(vec3(0.0));\n    return(fog_color);\n    return(vec3(0.0, 1.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 clean_uv = fragCoord / iResolution.xy;\n    \n    //vec2 half_resolution = vec2(iResolution.x * 0.5, iResolution.y);\n    //vec2 half_resolution = iResolution.xy * 0.5;\n    //vec2 distance_to_screen_center = abs(fragCoord.xy - half_resolution);\n    \n    //float dist = 0.075 + 0.9 * (distance_to_screen_center.x / half_resolution.x);\n    /*\n\tvec2 uv;\n    uv.x = (distance_to_screen_center.x / dist) / iResolution.x;\n    uv.y = ((fragCoord.y - half_resolution.y) / dist) / iResolution.x;\n    \n    uv.x -= iTime * 0.1;\n    */\n    // TODO: Reset camera position so it loops (because we are getting precsion issues!).\n    \n    vec3 ray_origin = vec3(0.0, 0.0, 0.0);\n    ray_origin.z -= iTime * 3.0;\n    //vec3 n_ray_direction = normalize(vec3(clean_uv * 2.0 - vec2(1.0), -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    vec3 n_ray_direction = (vec3(clean_uv * 3.0 - vec2(1.5), -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    \n    /*\n    // TODO: Why doesn't the rotation work?\n    // TODO: Add the ability to look around using the mouse.\n    float angle = iTime;\n    n_ray_direction.x = cos(angle) * n_ray_direction.x - sin(angle) * n_ray_direction.z;\n    n_ray_direction.z = sin(angle) * n_ray_direction.x + cos(angle) * n_ray_direction.z;\n    //n_ray_direction = normalize(n_ray_direction);\n    */\n    \n    // TODO: Use view plane depth or actual distance?\n    float depth = max_view_distance;\n    vec3 trace_result = trace_ray(ray_origin, n_ray_direction, depth);\n    \n    float normalized_depth = depth / max_view_distance;\n    \n    \n#ifdef RENDER_DEPTH\n    fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    return;\n#endif\n    \n    \n\t///fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t//fragColor = vec4(uv.xy, 0.5, 1.0);\n    \n    \n    //fragColor.rgb = calculate_texture(uv);\n    \n    //fragColor.rgb =  trace_result * n_ray_direction;\n    fragColor = vec4(trace_result, 1.0);\n    \n    //fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    //return;\n    \n\t//fragColor.rgb = mix(vec3(0.0), fog_color, clamp((1.0 - pow(1.0 - normalized_depth, 2.0)) * 1.0, 0.0, 1.0));\n    //return;\n    \n#ifdef ENABLE_FOG\n    //float inverse_depth = 1.0 - dist;\n    //inverse_depth = 1.0 - normalized_depth;\n\n    //fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(inverse_depth, 1.8) * 1.2, 0.0, 1.0));\n\t//fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(normalized_depth, 1.0) * 1.25, 0.0, 1.0));\n    \n    //float mix_factor = 1.0 - pow(1.0 - normalized_depth, 5.0);\n    float mix_factor = pow(normalized_depth, 1.0);\n    mix_factor = max((mix_factor - 0.25) * 1.5, 0.0);\n    fragColor.rgb = mix(fragColor.rgb, fog_color, mix_factor);\n#endif    \n    \n    //fragColor.rgb = vec3(detailed_noise_flat(uv * 50.0));\n    \n    \n   \t//fragColor = vec4(0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[557, 574, 597, 597, 646], [648, 648, 669, 669, 718], [720, 720, 739, 739, 782], [784, 784, 809, 809, 1293], [1295, 1295, 1334, 1334, 2423], [2429, 2507, 2543, 2543, 2622], [2624, 2702, 2801, 2821, 3090], [3092, 3170, 3245, 3265, 3395], [3397, 3397, 3475, 3516, 3569], [3571, 3571, 3645, 3645, 4434], [4437, 4437, 4489, 4532, 8415], [8421, 8421, 8534, 8534, 9249], [9251, 9251, 9323, 9323, 10161], [10163, 10163, 10269, 10269, 10987], [10991, 11022, 11096, 11096, 17115], [17117, 17117, 17174, 17174, 20039]], "test": "timeout"}
{"id": "wldGzf", "name": "Laser Behind Glass", "author": "CJG", "description": "Small rotating laser beams behind glass", "tags": ["abstract"], "likes": 8, "viewed": 194, "published": "Public", "date": "1577122480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define NUM_ITER 10.0\n\nfloat snakePattern(vec2 uv, float t){\n    uv += vec2(-t, sin(uv.x / 5.0 + t));\n\treturn abs(sin(uv.x) * sin(uv.y)) / (uv.y * uv.y);\n}\n\n//from https://stackoverflow.com/a/17897228\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 uv ) {\n\tuv /= iResolution.xy;\n    uv.y -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(0.0);\n    \n    for(float i = 1.0; i <= NUM_ITER; ++i) {\n        float p = i / NUM_ITER;\n        vec3 color = hsv2rgb(vec3(sin(iTime * p / 10.0), p, 0.5));\n      \tvec2 pos = uv * 10.0 * (1.0 + texture(iChannel0, uv).x / 5.0);\n        float offset = iTime + p * 2.0 * PI;\n\t\tfragColor.xyz += snakePattern(pos, offset) * color / NUM_ITER;   \n    }\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 79, 79, 174], [176, 220, 242, 242, 411], [413, 413, 460, 460, 915]], "test": "error"}
{"id": "WldGzr", "name": "Emanating Noise (Re-formed)", "author": "KdotJPG", "description": "Emanating noise by marching a cone forward. But the value is replaced by the dot product of the rotated derivative with the unit direction from the center. The derivative's higher frequency in its axis is exploited to un-squash the noise features.", "tags": ["noise", "derivative", "emanating"], "likes": 8, "viewed": 104, "published": "Public", "date": "1575477634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////// Re-oriented 8-point BCC noise by KdotJPG ////////////////////\n//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 bccNoiseDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 bccNoiseDerivatives_XYZ(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Might be good for terrain, or a time varying X/Y plane. Z repeats.\nvec4 bccNoiseDerivatives_PlaneFirst(vec3 X) {\n    \n    // Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / maxRes;\n    vec2 center = iResolution.xy / maxRes / 2.0;\n    float uvFade = dot(uv - center, uv - center) * 16.0;\n    uv = (uv - center) * 12.0;\n    float dist = length(uv);\n    \n    vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386 - dist * 1.2);\n    \n    vec4 noiseResult = bccNoiseDerivatives_PlaneFirst(X);\n    \n    float value = dot(normalize(uv), vec2(noiseResult.y, -noiseResult.x)) / 8.0 + 1.0 - uvFade;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.0, 1.0, 1.0) * value;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 214, 236, 236, 273], [275, 337, 360, 408, 1379], [1381, 1426, 1464, 1464, 2921], [2923, 3080, 3118, 3118, 3320], [3322, 3471, 3516, 3550, 3961], [4046, 4046, 4101, 4172, 4811]], "test": "ok"}
{"id": "wldGzs", "name": "dancy bonsais ", "author": "mrpawel", "description": "derived from Dancy Tree Doodle 3D by wyatt https://www.shadertoy.com/view/4lVyzh\n\ncreating a binary int id for each branch then scaling length / shifting branch positions based on the id. now with perlin distortion.\n", "tags": ["ifs", "tree", "kifs"], "likes": 4, "viewed": 131, "published": "Public", "date": "1577339704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//derived from Dancy Tree Doodle 3D by wyatt https://www.shadertoy.com/view/4lVyzh\n#define pi 3.1415926\nvec3 light;\n\n//perlin noise from https://www.shadertoy.com/view/4lB3zz\nconst int firstOctave = 3;\nconst int octaves = 3;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\n\n\nfloat ln (vec3 p, vec3 a, vec3 b, float R, float accum) { \n    float r = dot(p-a,b-a)/dot(b-a,b-a);\n    r = clamp(r,0.,1.);\n\tp.x+=((clamp(1.0-2.0*abs(0.5-r),0.,1.))*PerlinNoise2D(accum+p.y,iTime/10.0)) / (accum+5.);\n   //p.x+= 0.2*sqrt(R)*smoothstep(1.,0.,abs(r*2.-1.))*cos(pi*(2.*iTime));\n    return length(p-a-(b-a)*r)-R*(1.5-0.4*r);\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n\nfloat hash(int branchid){\n    int treeNumber = int(iTime/3.0);\n\n    int factor = treeNumber%15+1;\n\treturn 1.0-float(branchid%factor)/float(factor)/2.0;\n}\n\nfloat hash2(int branchid){\n    int treeNumber = int(iTime/3.0);\n    int factor = treeNumber%5+1;\n\treturn 1.0-float(branchid%factor)/float(factor);\n}\n\nfloat hash3(int branchid){\n    int treeNumber = int(iTime/3.0);\n    int factor = treeNumber%13+1;\n\treturn 1.0-float(branchid%factor)/float(factor);\n}\n\nfloat map (vec3 p) {\n    float l = length(p-light)-1e-2;\n    l = min(l,abs(p.y+0.4)-1e-2);\n    l = min(l,abs(p.z-0.4)-1e-2);\n    l = min(l,abs(p.x-0.7)-1e-2);\n    p.y += 0.4;\n    p.z += 0.1;\n    float accum = 0.0;\n    int branchid = 1;\n    //p.zx *= ro(.5*iTime);\n    vec2 rl = vec2(0.02,.3);\n    for (int i = 1; i <14; i++) {\n        \n        l = min(l,ln(p,vec3(0),vec3(0,rl.y,0),rl.x, accum));\n    \tp.y -= rl.y*0.9;\n        //p.xy *= ro(iTime*1.);\n        if(p.x>0.0){\n        \tbranchid*=2;\n            p.y += rl.y*hash2(branchid); //shift branch position based on id\n        }else{\n            branchid*=2;\n            branchid++;\n        }\n        \n        accum+=p.y;\n        \n        p.x = abs(p.x);\n       \n        float per = PerlinNoise2D(p.x,p.y);\n        \n        p.xy+=sign(p.xy)*per*length(p.xy);\n\n        p.xy *= ro(0.6+0.4*sin(iTime)*sin(0.871*iTime/4.0)+0.05*float(i)*sin(2.*iTime/3.0));\n        p.zx *= ro(0.5*pi+0.2*sin(0.5278*iTime/5.0)+0.8*float(i)*(sin(0.1*iTime/3.0)*(sin(0.1*pi*iTime/4.5)+sin(0.333*iTime/6.0)+0.2*sin(1.292*iTime/4.0))));\n        \n        \n        p.xz *= ro(p.y*hash3(branchid)); //twirl\n        \n        rl *=0.8;\n        \n        rl.y*=hash(branchid); //scale branch down based on id\n        \n        l=min(l,length(p)-0.04*sqrt(rl.y));\n    }\n\treturn l;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float o = 1e3;\n    for (int i = 0; i < 24; i++) {\n        float l = map(p);\n    \tp += l*d;\n        if (l < 1e-3)break;\n    }\n    return p;\n}\nvec3 norm (vec3 p) { // iq\n\t\tvec2 e = vec2 (.001,0.);\n\t\treturn normalize(vec3(\n\t\t\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\t\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\t\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t\t\t));\n\t}\nvoid mainImage( out vec4 C, in vec2 U )\n{   vec2 R = iResolution.xy;\n    light = vec3(0.2*sin(iTime),0.5,-.5);\n    if (iMouse.z > 0.) light = vec3(vec2(-0.5,0.5)*0.+0.7*(iMouse.xy-0.5*R)/R.y,-.3);\n    \n    U = (U-0.5*R)/R.y;\n    vec3 p = vec3(0,0,-1);\n    vec3 d = normalize(vec3(U,1));\n    p =  march(p,d);\n    vec3 n = norm(p);\n\tC = 0.6+0.4*sin(1.1*vec4(1,2,3,4)*dot(d,n));\n    vec3 D = light-p;\n    d = normalize(D);\n    vec3 lp = march(p+d*1e-2,d);\n    C *= 2.5*(dot(d,n))*(.3+0.7*length(lp-p)/length(light-p));\n    C = atan(C)/pi*2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 428, 454, 454, 603], [605, 605, 637, 637, 791], [793, 793, 842, 842, 934], [936, 936, 980, 980, 1396], [1398, 1398, 1436, 1436, 1761], [1765, 1765, 1822, 1822, 2102], [2103, 2103, 2122, 2122, 2182], [2185, 2185, 2210, 2210, 2338], [2340, 2340, 2366, 2366, 2488], [2490, 2490, 2516, 2516, 2639], [2641, 2641, 2661, 2661, 3940], [3942, 3942, 3971, 3971, 4116], [4117, 4117, 4137, 4143, 4303], [4304, 4304, 4345, 4345, 4844]], "test": "timeout"}
{"id": "wlt3DM", "name": "[I3D'20] Flow bands", "author": "I3D20_23", "description": "Flow bands", "tags": ["i3d20"], "likes": 1, "viewed": 206, "published": "Public API", "date": "1576589284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise from https://www.shadertoy.com/view/4sdGD8\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n////////////////////////\n// fields for figures //\n////////////////////////\nvec2 ctr0=vec2(0.5, 0.5);\n\n//#define N 79.0\n//#define M 71.0\n\n#define N 79.0\n#define M 53.0\n\nconst float log_step = N/M;\n\nvec2 uv(vec2 p) {\n    vec2 f = vec2(p) + 20.0*vec2(snoise(p.xy*0.015 + 0.04*iTime),snoise(p.yx*0.015 + 0.04*iTime));\n    return f.xy;\n}\n\nfloat d(vec2 p) {\n    \n    //return log_step; // uncomment to reveal distortion\n    \n    float delta = 1.0;\n    float dudx = ( uv(p - vec2(delta,0.0)).x - uv(p + vec2(delta,0.0)).x ) * 0.5 / delta;\n    float dudy = ( uv(p - vec2(0.0,delta)).x - uv(p + vec2(0.0,delta)).x ) * 0.5 / delta;\n    float d = log_step / (0.000001 + length(vec2(dudx,dudy)));\n    return max(log_step,d);\n}\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\n#define keyToggle(ascii) (texelFetch(iChannel0,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)   (texelFetch(iChannel0,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)  (texelFetch(iChannel0,ivec2(ascii,0),0).x > 0.)\n\n// keyboard mapping\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\n\n//////////////////////////\n// forward declarations //\n//////////////////////////\n\nvec4 getRandomColor(uvec4 id);\n\nfloat spacing(float d);\nint getLocalID(float u, float d, out float ctr);\nuvec4 getGlobalID(int localID, float d);\nfloat getLocalIDCenter(uint id, float d);\n\nfloat quantize(float d);\nfloat up(float d);\nfloat down(float d);\nfloat interpolate(float d);\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\n///////////////////////\n// draws for figures //\n///////////////////////\n\n\nvec4 draw(vec2 p) {\n    float d = d(p);\n    float u = uv(p).x;\n    float ctr = 0.0;\n    int lid = getLocalID(u, d, ctr);\n    uvec4 gid = getGlobalID(lid, d);\n\n    if (gid == uvec4(0u)) return vec4(1.0);        \n\n    return getRandomColor(gid);\n        \n}\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\nfloat quantize(float d) {\n    return pow(log_step,floor(log(d)/log(log_step)));\n}\n\nint d2level(float d) {\n    return int(floor(log(d)/log(log_step)));\n}\n\nfloat level2d(int level) {\n  return pow(log_step,round(float(level)));\n}\n\nfloat interpolate(float d) {\n    int   level   = d2level(d);\n    float df      = level2d(level);\n    float dc      = level2d(level-1);    \n    float linear  = (d - df) / (df - dc) / log_step;\n    return smoothstep(0.0,1.0,linear);\n}\n\nfloat spacing(float d) {\n    return 1.0/d;   \n}\n\nfloat shift(float d) {\n    if (N == 2.0) {\n        return spacing(d) / 2.0;\n    }\n    return d ; //* iTime*0.001;\n}\n\nfloat id2Lborder(int id, float d) {\n    return (float(id) +       (shift(d) / spacing(d)) ) * spacing(d);\n}\n\nfloat id2center(int id, float d) {\n    return (float(id) + 0.5 + (shift(d) / spacing(d)) ) * spacing(d);\n}\n\nint u2id(float u, float d) {\n    return int(floor( u / spacing(d) - (shift(d) / spacing(d)) ));\n}\n\nint u2closestLBorderId(float u, float d) {\n    int lid = u2id(u, d);\n    if (u < id2center(lid, d)) {\n        return lid;\n    } else {\n        return lid+1;\n    }\n}\n\nfloat u2closestBorder (float u, float d) {\n    return id2Lborder(u2closestLBorderId(u,d), d);\n}\n\n/**********************************************/\n\nint getLocalID(float u, float d, out float ctr) {\n  // fine and coarse densities\n  int   level = d2level(d);\n  float df    = level2d(level  );\n  float dc    = level2d(level-1);\n  // enclosing band id\n  int   lid     = u2id(u, df); \n  // get the borders of the fine band\n  float lf_brdr = id2Lborder(lid, df);\n  float rf_brdr = id2Lborder(lid+1, df);\n  // get the closest coarser band borders\n  float lc_brdr = u2closestBorder(lf_brdr, dc);\n  float rc_brdr = u2closestBorder(rf_brdr, dc);\n  // interpolate between fine and coarse borders\n  float a     = interpolate(d);\n  float left  = lf_brdr * a + lc_brdr * (1.0 - a);\n  float right = rf_brdr * a + rc_brdr * (1.0 - a);    \n  // adjust enclosing band after interpolation\n  if      (u < left ) lid--;\n  else if (u > right) lid++;\n\n  if (abs(left - right) < 0.5 * spacing(df)) {\n    ctr = -99999.0;\n  } else {\n    ctr = (left + right)/2.0;\n  }\n\n  return lid;\n}\n\n/**********************************************/\n\nuvec4 setId(uvec4 id,uint bit) // 128 bits IDs\n{\n    if (bit > 127u) return id;\n    if (bit < 64u) {\n        if (bit < 32u) { // 0 - 31 (w) LSBs\n            return uvec4(id.x,id.y,id.z,id.w | (1u << bit));\n        } else {         // 32 - 63 (x)\n            return uvec4(id.x,id.y,id.z | (1u << (bit-32u)),id.w);            \n        }\n    } else {\n        if (bit < 96u) { // 64 - 95 (x)\n            return uvec4(id.x,id.y | (1u << (bit-64u)),id.z,id.w);            \n        } else {         // 96 - 127 (x) MSBs\n            return uvec4(id.x | (1u << (bit-96u)),id.y,id.z,id.w);            \n        }\n    }\n}\n\n/**********************************************/\n\nuvec4 getGlobalID(int lid, float d) {\n  uvec4 gid = uvec4(0u);\n  int start_level = d2level(d);\n  for (int level = start_level; level > 0; level--) {\n    float df      = level2d(level);\n    float dc      = level2d(level-1);\n    float lf_brdr = id2Lborder(lid  , df);\n    float rf_brdr = id2Lborder(lid+1, df);\n    // get the closest borders on the coarse bands\n    int lid_brdr = u2closestLBorderId(lf_brdr, dc);\n    int rid_brdr = u2closestLBorderId(rf_brdr, dc);\n    if (lid_brdr == rid_brdr) {\n      // this band is closing between parents, tag in ID (lower 96 bits)\n      gid = setId(gid,uint(96 - level));\n      lid  = u2id(lf_brdr, dc);\n      if (level == start_level) {\n        // the start band is appearing\n        //gid.x = uint(lid_brdr);\n        //return uvec4(0);\n      }\n    } else {\n      // move up to parent\n      lid  = lid_brdr;\n        \n    }      \n  }\n  // parent ids go into the most significant 32 bits\n  gid.x = uint(lid);\n  return gid;\n}\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\nvec4 getRandomColor(uvec4 id) {\n    vec3 tmp = vec3(fract(float(id.x^id.w)/213789.0), fract(float(id.y^1489u)/348789.0), fract(float(id.z^2789u)/5689.0));\n    for (int i = 0; i < 16; i++) {\n      tmp = fract(vec3(13.14159265359,1.41421356237,6.62607004) * tmp.zyx + tmp.yxz / vec3(13.14159265359,1.41421356237,6.62607004));\n    }\n    return vec4(tmp, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = 60.0 * fragCoord / iResolution.y ;\n    fragColor = draw( p );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlt3DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1026, 1026, 1043, 1043, 1161], [1163, 1163, 1180, 1242, 1543], [2599, 2599, 2618, 2618, 2853], [3003, 3003, 3028, 3028, 3084], [3086, 3086, 3108, 3108, 3155], [3157, 3157, 3183, 3183, 3229], [3231, 3231, 3259, 3259, 3463], [3465, 3465, 3489, 3489, 3512], [3514, 3514, 3536, 3536, 3629], [3848, 3848, 3876, 3876, 3945], [3947, 3947, 3989, 3989, 4111], [4113, 4113, 4155, 4155, 4208], [4260, 4260, 4309, 4340, 5169], [5221, 5221, 5269, 5269, 5830], [5882, 5882, 5919, 5919, 6843], [6993, 6993, 7024, 7024, 7351], [7353, 7353, 7410, 7410, 7487]], "test": "error"}
{"id": "Wlt3DX", "name": "failTunelLuzn2", "author": "jorge2017a1", "description": "failTunelLuzn2", "tags": ["failtunelluzn2"], "likes": 0, "viewed": 47, "published": "Public", "date": "1577755364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\nvec3 glpRoRdNoMov;\nvec3 glpRd;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n///--------------------------------------------\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\t//return textureLod(iChannel0,(p+.5)/32.,-16.).x;\n    return texture(iChannel0,p.xy).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*25.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n///--------------------------------------------\n\n///--------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n\tcase 11:\n        //float pattern = fract( 1.-Granite( glpRoRd)*8.) ;\t\n        float pattern = abs( 1.-Granite( glpRoRd)*0.15) ;\t\n        //return Granite(glpRoRd)*vec3(0.2,0.5,0.3);\n        return pattern*vec3(1.0);\n     case 12:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd); \n     case 13:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(-glpRoRdNoMov.zyx); \n     case 14:\n     return vec3(0.8, 1.0, 0.4) * floorTex(-glpRd.zyx); \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n     vec2 res;\n    \n    res = vec2(9999, 0);\n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n            //res=vec2(res.x, 12);\n         } \n     } \n    \n    \n    p.xz=opRep( p.xz, 15. );\n    \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,5.5,0.), vec3(15,6.8,5) );\n    float sdb2=sdBox(p-vec3(0.0,6.0,0.), vec3(7,6.2,7.0) );\n    \n    float sdb3d=sdBox(p-vec3(0.0,6.0,0.), vec3(1,1.0,1.0) );\n    \n    \n    \n    float sdb3pisoi=sdBox(p-vec3(-5.0,3.0,0.0), vec3(3,1.1,2.) );\n    float sdb4pisod=sdBox(p-vec3(5.0,3.0,0.0), vec3(3,1.1,2.) );\n    \n    float sdb5pisoi=sdBox(p-vec3(-5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    float sdb6pisod=sdBox(p-vec3(5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    \n    \n   \n    dif2=differenceSDF(sdb1,sdb3pisoi);\n    dif2=differenceSDF(dif2,sdb4pisod);\n    dif2=differenceSDF(dif2,sdb5pisoi);\n    dif2=differenceSDF(dif2,sdb6pisod);\n    \n    //dif1=differenceSDF(sdb1, sdb2);\n    dif1=differenceSDF(dif2,sdb2);\n    \n    \n    res=opU(res, vec2(dif1,14));\n    //res=opU(res, vec2(dif2,6));\n    //res=opU(res, vec2(sdb3piso,6));\n    \n    \n    //res=opU(res, vec2(sdb3piso,13));\n    //res=opU(res, vec2(sdb3piso,10));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    \n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\t//float t = time;\n\n\t//vec3 ro = vec3(0.1, 0.0, -2.0 + iTime+cos(iTime));\n    vec3 ro = vec3(0.1, 2.0, -15.0 + iTime+cos(iTime));\n    \n\tvec3 ta = vec3(0.0, 2.4, 0.7 + iTime);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = cross(fwd, vec3(0, 1, 0));\n\tvec3 up = cross(right, fwd);\n\tvec3 rd = normalize(fwd + uv.x * right + uv.y * up);\n\n    \n    \n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    vec3 rLuz=vec3(0, 0.0,  -15.5+iTime*0.5);\n    \n    vec3 rLuz3=vec3(0., 0.0,iTime*0.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    //glpRoRdNoMov=p.yxz;\n    glpRoRdNoMov=p;\n    glpRd=rd*d-ro;\n    \n    \n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    float dif = GetLightv2(p);\n    \n    \n    float dif2 =1.-  GetLightv2(pluz);\n    float dif3 =1.0 - GetLightv2(pluz3);\n    \n    vec3 c = vec3(float(dif) * 0.02);\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n dif=(dif+dif3)/1.5;\n   \n    col = vec3(dif)*colobj+c;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlt3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 390, 423, 423, 488], [489, 507, 543, 543, 612], [613, 628, 659, 659, 809], [810, 830, 866, 866, 953], [954, 970, 1002, 1030, 1091], [1094, 1104, 1140, 1140, 1413], [1466, 1466, 1512, 1512, 1544], [1546, 1546, 1588, 1588, 1620], [1622, 1622, 1669, 1669, 1702], [1705, 1705, 1734, 1734, 1860], [1862, 1862, 1898, 1898, 2015], [2017, 2017, 2053, 2053, 2171], [2225, 2225, 2248, 2248, 2407], [2410, 2410, 2437, 2437, 2615], [2715, 2727, 2749, 2749, 3057], [3059, 3059, 3084, 3084, 3274], [3323, 3323, 3351, 3351, 4787], [4841, 4950, 4987, 4987, 5022], [5025, 5025, 5050, 5050, 6595], [6598, 6598, 6632, 6632, 6866], [6869, 6869, 6893, 6893, 7125], [7129, 7129, 7153, 7153, 7538], [7541, 7541, 7567, 7567, 7931], [7977, 7977, 8049, 8049, 8076], [8078, 8078, 8135, 8195, 9425]], "test": "error"}
{"id": "wlt3RX", "name": "Srce", "author": "Zigi", "description": "Srce", "tags": ["srce"], "likes": 1, "viewed": 196, "published": "Public API", "date": "1577105356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float srce( vec2 p )\n{\n    p *= 0.5;\n    p.x = abs(p.x);\n    p.y = -0.15 -p.y*1.2 + p.x*(1.0-p.x);\n    return length(p) - 0.5;\n}\n\nvec3 hsv(float h,float s,float v) { return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v; }\nfloat pow4(float x) { x *= x; return x * x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    //pozadina\n    const float brzinaP = 0.15;\n    const float duzinaP = 2.0;\n    const vec3 maska = vec3(1.0, 0.6, 0.6);\n\n    \n    //srce\n    float velicina =  2.0;// + (1.0 - sqrt(1.0 - sin(iTime) * sin(iTime)));\n    vec3 boja = vec3(1.0, 0.2, 0.1);\n\n    const float debljinaOko = 0.03;\n    const vec3 bojaOko = vec3(1.0);\n\t\n \n    vec2 P = velicina * 2.0 * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\tfloat d = srce(P);\n \n    vec3 pozadina = hsv(\n        brzinaP * iTime - d * 0.1 / duzinaP, \n        0.65, \n        0.9);\n\n    boja = mix(maska, pozadina, clamp(d / (debljinaOko / 2.0), 0.0, 1.0));\n\n    boja = mix(bojaOko, boja, clamp(pow4(abs(d / debljinaOko)), 0.0, 1.0));\n\n    \n    fragColor = vec4(mix(boja, pozadina, clamp(d, 0.0, 1.0)),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlt3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 128], [130, 130, 165, 165, 249], [250, 250, 271, 271, 295], [297, 297, 354, 373, 1143]], "test": "ok"}
{"id": "wlt3W4", "name": "FancyGear", "author": "changlongLi", "description": "This is a moving color gear, learn the \"shader\" process codeing in the demo", "tags": ["demo", "gear", "moveing"], "likes": 3, "viewed": 81, "published": "Public", "date": "1576420500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author:changlongLi\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define u_time iTime\n#define u_resolution iResolution.xy\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 createGear(vec2 pos,float scale,vec2 uv){\n    \n    vec2 dir = pos - uv;\n    float radius = length(dir)*scale;\n    float angle = atan(dir.y,dir.x);\n\t\n   \tfloat f = smoothstep(-0.484,1., cos(angle*10.0+u_time*50.))*0.080+0.372;\n   \n    vec3 col = hsb2rgb(vec3((pos.y),1.000,1.0));\n    return vec3( 1.-smoothstep(f,f+0.02,radius)) * col;\n}\n\n\n// \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = gl_FragCoord.xy/u_resolution.xy;\n    vec3 gearleLists = vec3(0.014,0.054,0.210);\n    gearleLists = vec3(0.014,0.054,0.210);\n    float spaceX = 0.;\n    float spaceY = 0.;\n\n    float speedX = 0.5;\n\t float speedY = 0.3;\n\t float size = 25.0;\n\t for(int i = 0;i<31;i ++){\n      spaceX += 0.1;\n      spaceY += 0.1;\n      vec2 pos = vec2(spaceX,spaceY);\n      pos.x =  abs(sin(speedX*u_time+spaceX));\n      pos.y =  abs(cos(speedY*u_time+spaceY));\n      vec3 gear = createGear(pos,size,uv);\n      gearleLists += gear;\n    }\n    fragColor = vec4(gearleLists , 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlt3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 154, 154, 313], [316, 316, 362, 362, 657], [660, 664, 720, 720, 1293]], "test": "ok"}
{"id": "wlt3WS", "name": "Eruption", "author": "onlinerocker", "description": "Don't touch the lava!", "tags": ["raymarching", "landscape", "spheretracing", "lava", "volcano"], "likes": 2, "viewed": 92, "published": "Public", "date": "1577487832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define VIEW_DIST 50.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n    \n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\n//slightly modified for octave spcification\nfloat fbm5(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat fbm3(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq, modified color and made fog amount grow exponentially, shrink as y gets bigger\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    fogAmount -= rayDir.y;\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), \n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 20.0;\n    o.specKs = 0.0;\n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    vec3 btmPos = pos;\n    btmPos.x += iTime*0.75;\n    btmPos.y -= 0.03*sin(btmPos.x*2.0);\n    float dPlaneBtm = sdPlaneInf(btmPos, 0.3);\n    if(dPlaneBtm < o.dist)\n    {\n        o.dist = dPlaneBtm;\n        //o.color = vec3(1.0, 1.0, 0.1);\n        o.color = mix(vec3(1.0, 1.0, 0.1)*(1.3+abs(0.5*sin(iTime))), vec3(1.0, 0.1, 0.), fbm5(btmPos*3.0));\n    }\n\n\n    vec3 planePos = pos;\n    planePos.x += iTime;\n    float yVal = fbm3(planePos/2.5);\n    yVal -= 0.2*fbm5(planePos*1.5);\n    planePos.y -= yVal;\n    float dPlane = sdPlaneInf(planePos, 0.0);\n    if(dPlane < o.dist)\n    {\n        o.dist = dPlane;\n\t\to.specKs = 0.15;\n        o.color = mix(vec3(1.0, 0.7, 0.1)*2.0, vec3(0.8, 0.1, 0.), smoothstep(0.0, 0.5, yVal));\n        o.color = mix(o.color, vec3(0.5, 0.1, 0.), smoothstep(0.4, 0.6, yVal));\n        //o.color += mix(o.color, vec3(0), smoothstep(0.0, 1.0, yVal*fbm5(planePos*10.0)));\n    }\n\n    vec3 bbPos = pos;\n    bbPos.x = mod(bbPos.x, -5.0);\n    bbPos.z = abs(bbPos.z);\n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n        \n    for(int x=0; x<100; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.0001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvec3 drawVolcano(vec3 origCol, vec3 col, vec2 uv, vec2 yBound)\n{\n    uv.x = abs(uv.x);\n    return mix(origCol, col, smoothstep(uv.y, uv.y+0.01, yBound.x)\n               *smoothstep(uv.y-0.01, uv.y+0.01, pow(-uv.x*2.0 + 1.0,3.0) - 0.025)*step(yBound.y, uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0.0,3.0,0.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = 0.0;//-iMouse.x/20.0;//\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    //vec2 camXZ = rotCam * camEye.xz;\n    //camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 1.0;\n    light.pos = vec3(10, 5, -10.0);\n    light.color = vec3(1.0);\n    \n    Light lightSky;\n    lightSky.intensity = 0.3;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(1);\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    \n    y = smoothstep(1.1, 0.5, y);\n    vec3 col = (vec3(1)*(y) + vec3(0.3, 0.3, 0.4)*(1.0-y));\n    //col = vec3(0);\n    vec3 volCol = mix(vec3(0.3, 0.3, 0.4), vec3(0.83, 0.35, 0.35)*abs(1.0 + 0.3*sin(iTime)), smoothstep(0.37, 0.4, uv.y));\n    col = drawVolcano(col, volCol, uv, vec2(0.4, -0.3));\n\n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, vec3(0)) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        col += calcSpecLight(res.obj, light, pos, camEye);// * calcShadowSoft(pos, light);\n    }\n    \n    col = applyFog(col, length(pos), normalize(pos), normalize(light.pos - pos));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlt3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 573, 594, 594, 661], [663, 703, 724, 724, 1485], [1487, 1571, 1591, 1591, 1751], [1753, 1753, 1773, 1773, 1933], [1935, 1940, 1977, 1977, 2002], [2004, 2089, 2334, 2334, 2727], [2729, 2785, 2826, 2826, 2919], [2925, 2925, 2947, 2947, 4098], [4100, 4100, 4137, 4137, 4430], [4436, 4436, 4488, 4488, 5137], [5139, 5139, 5191, 5191, 5330], [5332, 5332, 5394, 5394, 5770], [5772, 5772, 5836, 5836, 6033], [6035, 6035, 6092, 6092, 7722]], "test": "timeout"}
{"id": "WltGDB", "name": "tunel-v02", "author": "jorge2017a1", "description": "tunel-v02", "tags": ["tunelv02"], "likes": 0, "viewed": 48, "published": "Public", "date": "1577459270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\nvec3 glpRoRd;\nvec3 glpRoRdNoMov;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n///--------------------------------------------\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\t//return textureLod(iChannel0,(p+.5)/32.,-16.).x;\n    return texture(iChannel0,p.xy).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*25.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n///--------------------------------------------\n\n///--------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n\tcase 11:\n        //float pattern = fract( 1.-Granite( glpRoRd)*8.) ;\t\n        float pattern = abs( 1.-Granite( glpRoRd)*0.15) ;\t\n        //return Granite(glpRoRd)*vec3(0.2,0.5,0.3);\n        return pattern*vec3(1.0);\n     case 12:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(glpRoRd); \n     case 13:\n        return  vec3(0.8, 1.0, 0.4) * floorTex(-glpRoRdNoMov.zyx); \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n    float d , dif1, dif2;\n    vec2 res;\n    vec3 pp;\n    \n    d=999.9;\n    float planeDist = p.y;\n    pp=p;\n    \n    \n    res = vec2(9999, 0);\n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n            //res=vec2(res.x, 12);\n         } \n     } \n    \n    p.z=mod(p.z, 1.0)-1.0;\n    \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,5.5,0.), vec3(7,5.8,5) );\n    float sdb2=sdBox(p-vec3(0.0,6.0,0.), vec3(7,5.2,6.0) );\n    \n    \n    \n    float sdb3piso=sdBox(p-vec3(0.0,1.0,0.0), vec3(7,0.1,5.1) );\n    \n    \n    dif1=differenceSDF(sdb1, sdb2);\n    res=opU(res, vec2(dif1,6));\n    \n    \n    res=opU(res, vec2(sdb3piso,13));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 3.5, -15.5);\n\n    vec3 rLuz=vec3(0.5, -3.5, iTime*0.5);\n    \n    vec3 rLuz3=vec3(5.5, 0.5,  iTime*0.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    //glpRoRdNoMov=p.yxz;\n    glpRoRdNoMov=p;\n    \n    \n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    \n    float dif = GetLightv2(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n    dif=(dif+dif3)/1.5;\n    col = vec3(dif)*colobj;\n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 378, 411, 411, 476], [477, 495, 531, 531, 600], [601, 616, 647, 647, 797], [798, 818, 854, 854, 941], [942, 958, 990, 1018, 1079], [1082, 1092, 1128, 1128, 1401], [1454, 1454, 1500, 1500, 1532], [1534, 1534, 1576, 1576, 1608], [1610, 1610, 1657, 1657, 1690], [1693, 1693, 1722, 1722, 1848], [1850, 1850, 1886, 1886, 2003], [2005, 2005, 2041, 2041, 2159], [2213, 2213, 2236, 2236, 2395], [2398, 2398, 2425, 2425, 2603], [2703, 2715, 2737, 2737, 3045], [3047, 3047, 3072, 3072, 3262], [3311, 3311, 3339, 3339, 4704], [4758, 4867, 4904, 4904, 4939], [4942, 4942, 4967, 4967, 5874], [5877, 5877, 5911, 5911, 6145], [6148, 6148, 6172, 6172, 6404], [6408, 6408, 6432, 6432, 6817], [6820, 6820, 6846, 6846, 7210], [7215, 7215, 7287, 7287, 7314], [7316, 7316, 7373, 7373, 8246]], "test": "error"}
{"id": "WltGR4", "name": "Codevember28 - Repeat", "author": "z0rg", "description": "Participation to codevember a bit late", "tags": ["abstract", "repeat", "codevember"], "likes": 10, "viewed": 111, "published": "Public API", "date": "1576930741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nfloat _union(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat sdf_cir(vec2 uv, float r)\n{\n  return length(uv)-r;\n}\n\nfloat sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nbool inTriangle(vec2 A, vec2 B, vec2 C, vec2 P, float thick)\n{\n  vec2 v0 = C - A ;\n  vec2 v1 = B - A ;\n  vec2 v2 = P - A; // Compute dot products\n  float dot00 = dot(v0, v0) ;\n  float dot01 = dot(v0, v1) ;\n  float  dot02 = dot(v0, v2) ;\n  float dot11 = dot(v1, v1) ;\n  float dot12 = dot(v1, v2) ;\n  // Compute barycentric coordinates\n  float invDenom = 1. / (dot00 * dot11 - dot01 * dot01) ;\n  float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n   float v = (dot00 * dot12 - dot01 * dot02) * invDenom ;\n   // Check if point is in triangle return\n   ;\n   return (u >= 0.) && (v >= 0.) && (u + v < 1.) &&\n   (u<thick||v<thick||(u+v)>1.-thick);\n}\n\nfloat curve(float a)\n{\n  return max(mod(iTime,10.)/10.,0.5)*(sin(iTime+a*102.4)*0.5+0.5)*((sin(a*5.-iTime*15.)*0.3+0.3)+(sin((iTime+a)*13.5)*0.5+0.5));\n}\n\nvec3 mix3(vec3 a, vec3 b, vec3 c, float f)\n{\n\n  vec3 gradA = mix(a, b, sat(f*2.));\n  vec3 gradB = mix(gradA, c, sat(f-0.5)*2.);\n  return gradB;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n\ncol = mix(vec3(0.6,0.3,.7),vec3(0.),abs(uv.y)*0.5);\n  if (uv.y <0.)\n  col = mix(vec3(0.),0.5*vec3(0.81,0.1,.937),pow(-uv.y,.5)*.5);\n\n  vec2 posT= vec2(0.,-0.6);\n  float rT = 1.2;//1.7+float(mod(iTime,0.25*sin(iTime)));\n  float aT = (PI*2.)/3.;\n  float offA = 0.;//iTime;\n\n  vec2 A = vec2(rT*sin(aT*1.+offA),rT *cos(aT*1.+offA))-posT;//+vec2(0.,0.1*sin(iTime));\nvec2 B = vec2(rT*sin(aT*2.+offA),rT *cos(aT*2.+offA))-posT;\nvec2 C = vec2(rT*sin(aT*3.+offA),rT *cos(aT*3.+offA))-posT;\n\nvec2 posT2= vec2(0.,0.6);\nfloat angleB = 3.14159265;\nvec2 A2 = vec2(rT*sin(aT*1.+angleB),rT *cos(aT*1.+angleB))-posT2;//+vec2(0.,0.1*sin(iTime));\nvec2 B2 = vec2(rT*sin(aT*2.+angleB),rT *cos(aT*2.+angleB))-posT2;\nvec2 C2 = vec2(rT*sin(aT*3.+angleB),rT *cos(aT*3.+angleB))-posT2;\n\nif(inTriangle(A,B,C,uv,1.))\n  col += mix3(vec3(0.),vec3(0.6,0.,1.),vec3(1.),abs(uv.y));\nif(inTriangle(A2,B2,C2,uv,1.))\n  col += mix3(vec3(0.),vec3(0.7,0.,1.),vec3(1.),abs(uv.y))*float(0.02*sin(2.*uv.x+iTime*5.)+mod(abs(uv.y+iTime*0.05),0.07)<0.01);\n  return col;\n}\n\n\nvec3 rdrChroma(vec2 uv)\n{\n  float r = lenny(uv)*(sin(iTime*0.4)*0.3+0.3);\n//  uv = uv+vec2(sin(iTime),cos(iTime))*0.2;\n  vec3 col;\n\n  col += rdr(uv+uv*r).r*vec3(0.63,0.72,0.75);\n  col += rdr(uv).r;\n  col +=rdr(uv-uv*r).r;\n  return col/3.;\n}\n\nvec3 rdrRetro(vec2 uv)\n{\n  vec2 posT= vec2(0.,-.8);\n  float rT = 3.2;//1.7+float(mod(iTime,0.25*sin(iTime)));\n  float aT = (PI*2.)/3.;\n  float offA = PI;//sin(iTime)*0.2+1.;//iTime;\n\nvec2 A = 0.5*vec2(rT*sin(aT*1.+offA)*sin(iTime),rT *cos(aT*1.+offA))-posT;//+vec2(0.,0.1*sin(iTime));\nvec2 B = 0.5*vec2(rT*sin(aT*2.+offA)*sin(iTime),rT *cos(aT*2.+offA))-posT;\nvec2 C = vec2(rT*sin(aT*3.+offA),rT *cos(aT*3.+offA))-posT;\n\nfloat inTriA = float(inTriangle(A,B,C,uv,0.2));\n  return vec3(0.48,0.43,0.57).zyx*inTriA+0.5;\n}\n\nvec3 rdrChroma2(vec2 uv)\n{\n  float r = 0.05*clamp(length(uv),0.,0.4);\n  vec3 col;\n  col.r = rdrChroma(uv+uv*r).r;\n  col.g = rdrChroma(uv).r;\n  col.b = rdrChroma(uv-uv*r).r;\n\n   col += sat(1.-lenny(uv*0.5))*vec3(.1,.4,.6);\n\n   col*= rdrRetro(uv);\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv = uv-(iResolution.xy/iResolution.xx)*0.5;\nuv*=10.;\n vec3 col;// = vec3(length(uv));\n col += rdrChroma2(uv);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltGR4.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[428, 428, 449, 449, 479], [480, 480, 500, 500, 527], [529, 529, 559, 559, 581], [583, 583, 615, 615, 636], [638, 638, 671, 671, 696], [698, 698, 732, 732, 780], [782, 782, 844, 844, 1428], [1430, 1430, 1452, 1452, 1583], [1585, 1585, 1629, 1629, 1730], [1732, 1732, 1751, 1751, 2790], [2793, 2793, 2818, 2818, 3033], [3035, 3035, 3059, 3059, 3551], [3553, 3553, 3579, 3579, 3814], [3815, 3815, 3872, 3872, 4061]], "test": "ok"}
{"id": "wltGR7", "name": "K^+ for HÃ©non maps (hopefully)", "author": "inou", "description": "Forward non-escaping set (K^+) for HÃ©non maps (x,y) -> (by+x^2+c, x).\n\nBased on (or, small modification of):\n \tJulia - Quaternion by inigo quilez\n \thttps://www.shadertoy.com/view/MsfGRr\n\nSee also https://www.shadertoy.com/view/3tc3DH", "tags": ["raymarching", "juliaset", "henonmap"], "likes": 7, "viewed": 146, "published": "Public", "date": "1575964659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// K^+ for HÃ©non maps by Hiroyuki Inou\n// Based on (or, small modification of):\n// \tJulia - Quaternion by inigo quilez\n// \thttps://www.shadertoy.com/view/MsfGRr\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// antialais level (1, 2, 3...)\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n// 0: numerical normals (central differences)\n// 1: analytic normals\n// 2: analytic normals optimized\n#define METHOD 1\n\nconst int numIterations = 11;\n\nfloat map( in vec3 p, out vec4 oTrap, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    mat4x4 J = mat4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n    \n    vec4 trap = vec4(abs(z.xyz),dot(z,z));\n\n    float n = 1.0;\n    for( int i=0; i<numIterations; i++ )\n    {\n        // (x,y) -> (by + x^2 + c, x)\n        // J = [[2x, b], [1, 0]]\n        // c = (b, c)\n        \n        // Jacobian (transposed because OpenGL is column major)\n\t\tJ = J*mat4x4(2.0*z.x, -2.0*z.y, c.x, -c.y,\n                     2.0*z.y,  2.0*z.x, c.y,  c.x,\n                     1, 0, 0, 0,\n                     0, 1, 0, 0);\n\n        z = vec4(c.x*z.z - c.y*z.w  +  z.x*z.x - z.y*z.y + c.z,\n                 c.y*z.z + c.x*z.w  +  2.0*z.x*z.y       + c.w,\n                 z.x,\n                 z.y);\n        \n        trap = min( trap, vec4(abs(z.xyz),dot(z,z)) );\n\n        mz2 = dot(z.xy,z.xy); // escape to x direction\n        if(mz2>50.0) break;\n        n += 1.0;\n    }\n    \n    oTrap = trap;\n    \n    md2 = J[0][0]*J[0][0]+J[0][1]*J[0][1];// + J[0][2]*J[0][2]+J[0][3]*J[0][3];\n\n    return 0.25*sqrt(mz2/md2)*exp2(-n)*log(mz2);  // d = 0.5Â·|z|Â·log|z| / |dz|\n}\n\n#if METHOD==0\nvec3 calcNormal( in vec3 pos, in vec4 c )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, kk, c ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk, c ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk, c ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk, c ) );\n}\n#endif\n\n#if METHOD==1\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    // identity derivative\n    mat4x4 J = mat4x4(1,0,0,0,  \n                      0,1,0,0,  \n                      0,0,1,0,  \n                      0,0,0,1 );\n\n  \tfor(int i=0; i<numIterations; i++)\n    {\n        // chain rule of jacobians (transposed because OpenGL is column major)        \n        J = J*mat4x4(2.0*z.x, -2.0*z.y, c.x, -c.y,\n                   2.0*z.y,  2.0*z.x, c.y,  c.x,\n                   1, 0, 0, 0,\n                   0, 1, 0, 0);\n\n        // z -> z2 + c\n        z = vec4(c.x*z.z - c.y*z.w + z.x*z.x - z.y*z.y + c.z,\n                 c.y*z.z + c.x*z.w + 2.0*z.x*z.y + c.w,\n                 z.x,\n                 z.y);\n        \n        if(dot(z.xy,z.xy)>50.0) break; // escape to x direction\n    }\n\n    return normalize( (J*z).xyz ); // direction of gradient vector\n}\n#endif\n/*\n#if METHOD==2\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    // identity derivative\n    vec4 J0 = vec4(1,0,0,0);\n    vec4 J1 = vec4(0,1,0,0);\n    vec4 J2 = vec4(0,0,1,0);\n    \n  \tfor(int i=0; i<numIterations; i++)\n    {\n        vec4 cz = qconj(z);\n        \n        // chain rule of jacobians (removed the 2 factor)\n        J0 = vec4( dot(J0,cz), dot(J0.xy,z.yx), dot(J0.xz,z.zx), dot(J0.xw,z.wx) );\n        J1 = vec4( dot(J1,cz), dot(J1.xy,z.yx), dot(J1.xz,z.zx), dot(J1.xw,z.wx) );\n        J2 = vec4( dot(J2,cz), dot(J2.xy,z.yx), dot(J2.xz,z.zx), dot(J2.xw,z.wx) );\n\n        // z -> z2 + c\n        z = qsqr(z) + c; \n        \n        if(dot(z,z)>4.0) break;\n    }\n    \n\tvec3 v = vec3( dot(J0,z), \n                   dot(J1,z), \n                   dot(J2,z) );\n\n    return normalize( v );\n}\n#endif\n\n// this method does not work, but in my mind, it should\n#if METHOD==3\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    vec4 dz = vec4(1,0,0,0);\n    \n  \tfor(int i=0; i<numIterations; i++)\n    {\n        // z' = 2z'z\n\t\tdz = 2.0*qmul( z, dz );\n        \n        // z -> z2 + c\n        z = qsqr(z) + c; \n        \n        if(dot(z,z)>4.0) break;\n    }\n    \n\tvec4 v = qconj(qmul( dz, qconj(z) ));\n    \n    return normalize( v.xyz );\n}\n#endif\n*/\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 res, in vec4 c )\n{\n    vec4 tmp;\n    float resT = -1.0;\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<300; i++ )\n    {\n        if( h<0.0001||t>maxd ) break;\n\t    h = map( ro+rd*t, tmp, c );\n        t += h;\n    }\n    if( t<maxd ) { resT=t; res = tmp; }\n\n\treturn resT;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k, in vec4 c )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk, c);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec4 c )\n{\n\tconst vec3 sun = vec3(  0.577, 0.577,  0.577 );\n    \n\tvec4 tra;\n\tvec3 col;\n    float t = intersect( ro, rd, tra, c );\n    if( t < 0.0 )\n    {\n     \tcol = vec3(0.7,0.9,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,sun),0.0,1.0), 48.0 );\n\t}\n\telse\n\t{\n        vec3 mate = vec3(1.0,0.8,0.7)*0.3;\n\t\t//mate.x = 1.0-10.0*tra.x;\n        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, c );\n        \n\t\tfloat occ = clamp(2.5*tra.w-0.15,0.0,1.0);\n\t\t\n\n        col = vec3(0.0);\n\n        // sky\n        {\n        float co = clamp( dot(-rd,nor), 0.0, 1.0 );\n        vec3 ref = reflect( rd, nor );\n        //float sha = softshadow( pos+0.0005*nor, ref, 0.001, 4.0, c );\n        float sha = occ;\n        sha *= smoothstep( -0.1, 0.1, ref.y );\n        float fre = 0.1 + 0.9*pow(1.0-co,5.0);\n            \n\t\tcol  = mate*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*occ;\n\t\tcol +=  2.0*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*sha*fre;\n        }\n\n        // sun\n        {\n        const vec3 lig = sun;\n        float dif = clamp( dot( lig, nor ), 0.0, 1.0 );\n        float sha = softshadow( pos, lig, 0.001, 64.0, c );\n        vec3 hal = normalize( -rd+lig );\n        float co = clamp( dot(hal,lig), 0.0, 1.0 );\n        float fre = 0.04 + 0.96*pow(1.0-co,5.0);\n        float spe = pow(clamp(dot(hal,nor), 0.0, 1.0 ), 32.0 );\n        col += mate*3.5*vec3(1.00,0.90,0.70)*dif*sha;\n        col +=  7.0*3.5*vec3(1.00,0.90,0.70)*spe*dif*sha*fre;\n        }\n\n        // extra fill\n        {\n        const vec3 lig = vec3( -0.707, 0.000, -0.707 );\n\t\tfloat dif = clamp(0.5+0.5*dot(lig,nor), 0.0, 1.0 );\n        col += mate* 1.5*vec3(0.14,0.14,0.14)*dif*occ;\n        }\n        \n        // fake SSS\n        {\n        float fre = clamp( 1.+dot(rd,nor), 0.0, 1.0 );\n        col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\n        }\n    }\n\n\treturn pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // anim\n    float time = iTime*.15;\n    vec4 c = vec4(1.5,1.5,0.7,0.7)*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.0,0.0,1.0,0.0);\n\n    // camera\n\tfloat r = 1.5+0.15*cos(0.0+0.29*time);\n    vec3 ro = vec3(           r*cos(0.3+0.37*time), \n\t\t\t\t\t5.3 + 0.8*r*cos(1.0+0.33*time), \n\t\t\t\t\t          r*cos(2.2+0.31*time) );\n    //ro = ro.yxz;\n \tvec3 ta = vec3(0.0,0.0,0.0);\n    float cr = 0.1*cos(0.1*time);\n    \n    \n    // render\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(float(i),float(j))/float(AA))) / iResolution.y;\n\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        col += render( ro, rd, c );\n    }\n    col /= float(AA*AA);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.25);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltGR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[543, 543, 594, 594, 1709], [4187, 4187, 4255, 4255, 4537], [4539, 4539, 4615, 4615, 4889], [4891, 4891, 4941, 4941, 6806], [6808, 6808, 6865, 6877, 7962]], "test": "ok"}
{"id": "WltGRH", "name": "AA is hard, notes", "author": "Carandiru", "description": "some first-hand trials and errors\nconcluding with some notes on usage of smoothstep\nmaybe helpful to some else whos trying to figure it out too.", "tags": ["antialiasing"], "likes": 2, "viewed": 79, "published": "Public", "date": "1575626839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// some (hopefully correct) observations on using smoothstep and comparing with aaStep\n\n\n//smooth version of step - https://www.ronja-tutorials.com/2019/11/29/fwidth.html\n// produces a harder cut off in conparison with smoothstep, if smoothstep can't be used use this\n// usage:\n// float aa = aaStep(0.25f, gradient); // harder cut off\n// -or-\n// float aa = smoothstep(0.24f, 1.0f, gradient); // smoother cut off\n//\n// gradient *= aa;  // applying cutoff (hardly)\n// -or-\n// gradient = (gradient - aa * 0.5f) * aa;  // applying cutoff (smoothly)\n//\n// **** to remember:\n// float aa = smoothstep(0.0f, gradient, gradient);  ** pretty much equals gradient** so the line below this does nothing\n//  gradient *= aa;\n// -however-\n// float aa = smoothstep(0.0f, 1.0f, gradient);\t**actually smooths and remaps the gradient to the smoothstep function\n//  gradient *= aa; // apply smoothstep to original grasdient\n// -and-\n// *** if the value of second parameter is smaller than first parameter into smoothstep\n// there will be an undesired \"inverse\" cutoff ***\n// if the value for the second parameter is larger than 1.0f, the result is no longer normalized in the range 0..1.0\n// ie.) smoothstep(0.0f, 1.5f, gradient) requires : smoothstep(0.0f, 1.5f, gradient) / (1.5f*1.5f)  to normalize again\n// I dunno about you but negative values are way outside the scope of smoothstep\n// #### use smoothstep rather than aaStep, only use aaStep in special cases where a smoother, but harder cutoff is needed (in comparison to step())\n// or if \"linearerity\" is critically important and smoothstep is introducing unsightly waves of discontuity ####\n\n//smooth version of step - https://www.ronja-tutorials.com/2019/11/29/fwidth.html\nfloat aaStep(in float compValue, in float gradient){\n  float halfChange = fwidth(gradient) * 0.5f;\n  //base the range of the inverse lerp on the change over one pixel\n  float lowerEdge = compValue - halfChange;\n  float upperEdge = compValue + halfChange;\n  //do the inverse interpolation\n  return( clamp((gradient - lowerEdge) / (upperEdge - lowerEdge), 0.0f, 1.0f) );\n}\n\nvec2 rotate( in vec2 p, in float angle )\n{\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(p.x * cossin.c_+ p.y * cossin.s, p.x * -cossin.s_+ p.y * cossin.c_) );\n\n\t#undef c_\n\t#undef s_\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv * 2.0f - 1.0f;\n    \n    uv = rotate(uv, (sin(iTime * 0.5f)));\n    \n    uv = uv * (1.0f/0.5f);\n    //uv = uv * 0.5f + 0.5f;\n    //uv = uv * 2.0f - 1.0f;\n    \n    float gradient = length(uv);// + 0.5f - uv.y;\n    gradient = (gradient*0.5f);\n    //gradient = fract(gradient) * 1.618f;\n    \n    // Time varying pixel color\n    //float aa = aaStep(0.05f, gradient);\n    float aa = smoothstep(0.0f, 1.0f, gradient);\n    gradient *= aa;\n\t//gradient = (gradient - aa * 0.5f) * aa;\n    \n    // Output to screen\n    fragColor = vec4(vec3(gradient),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1631, 1713, 1765, 1765, 2083], [2312, 2312, 2369, 2419, 3018]], "test": "ok"}
{"id": "wltGz7", "name": "infinite trax", "author": "StrangerintheQ", "description": "simple truchet pattern", "tags": ["truchet"], "likes": 4, "viewed": 126, "published": "Public", "date": "1575970600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 xy) {\n    return fract(sin(133.+xy.x*13.+xy.y*45.) * 43758.5453123);\n}\n\nfloat dist(float d) {\n    float size = 0.01;\n    vec2 s = vec2(0.5 + size, 0.5 - size);\n    return 1. - min( smoothstep(d, s.x, s.y), \n                     smoothstep(d, s.y, s.x) );\n}\n\nfloat ring(vec2 uv) {\n    return dist(sqrt(dot(uv, uv)));\n}\n\nvec3 hsl2rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(\n        c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat truchet(vec2 uv) {\n    float cellRand = rand(floor(uv));\n    vec2 cellUv = fract(uv)-0.5;\n    if (cellRand < 0.9) {      \n        float a = floor(cellRand*4.)*1.57075;\n        \n        if (cellRand < 0.1)\n        \ta += iTime;\n        \n        vec2 sc = vec2(sin(a), cos(a));\n        cellUv = mat2(sc.y, -sc.x, sc.x, sc.y) * cellUv;\n        \n        if (sqrt(dot(cellUv,cellUv)) > 0.5)\n    \t\treturn 0.;\n        else\n        \treturn ring(cellUv - 0.5) + ring(cellUv + 0.5);\n\n    } \n    return min(1., dist(cellUv.x + 0.5) + dist(cellUv.y + 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 shift = vec2(cos(iTime/3.)*3., sin(iTime/9.)*5.);\n    vec2 uv = fragCoord/66. + shift;\n    float result = truchet(fragCoord/66. + shift);\n    vec3 color = hsl2rgb(vec3( fract(uv).x +fract(uv).y ,0.9,0.7));\n    fragColor = vec4(color*result, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 86], [88, 88, 109, 109, 272], [274, 274, 295, 295, 333], [335, 335, 356, 356, 505], [507, 507, 531, 531, 1059], [1061, 1061, 1118, 1118, 1375]], "test": "ok"}
{"id": "Ws2GzV", "name": "_lines_", "author": "monada", "description": "  ", "tags": ["lines"], "likes": 5, "viewed": 110, "published": "Public", "date": "1576702203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate2( vec2 p, float a )\n{\n    float c = cos( a );\n    float s = sin( a );\n    \n    return mat2(\n        c, -s,\n        s,  c ) * p;\n}\n\nfloat hash( float x )\n{\n    return fract( sin( x * 1230000.0 ) );\n}\n\nfloat hash2( vec2 p )\n{\n    return fract(\n        sin( \n            dot( p, vec2(12.9898,78.233) )\n        ) * 1242424.0\n    );\n}\n\nfloat random(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    u = smoothstep(0.,1.,f);\n   \n //   u = f;\n    \n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noise2( vec2 st )\n{\n   vec2 p = texture( iChannel0, st ).xy;\n   return noise( st + p * 0.1 );\n}\n\n\n\nvec3 step1( vec2 p, vec2 uv, float iTime, float m )\n{\n      \n    float v = abs( p.y + 0.2 * noise2( p * m + vec2( iTime * 1.1, 0.0 ) ) );\n    v = pow( v, 0.1 );\n    \n   // v *= noise( p * 4.0 );\n    \n    v = 1.0 - v;\n //   \n    vec3 col = vec3( v );\n \n    col *=  vec3( 2.4, 2.1, 2.2 ); //( hsv2rgb( vec3(  sin( iTime ) / PI , 0.5, 0.5 ) ) );\n   // col *= 2.8;\n    \n   \n  //  col = col * col * col * 2.0 - col * col * 3.0;\n    col = smoothstep( vec3( 0.0 ), vec3( 1.0 ), col );\n    col = pow( col, vec3( 1.4 ) );\n    col *= hsv2rgb( vec3(  sin( iTime + uv.x ) / PI , 0.5, 0.5 ) );\n    col *= 2.0;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.0 * uv - 1.0;\n    \n    vec3 col = step1( p, uv, iTime, 2.0 );\n    col += step1( rotate2( p - vec2( 0.0, 0.1 ), 0.32 ), uv, iTime + 50.0, 2.0 );\n    col += step1( rotate2( p - vec2( 0.0, -0.1 ), -0.32 ), uv, iTime + 100.0, 2.0 );\n    \n  //  col = pow( col, vec3( 0.2  ) );\n  //  col *= 1.4;\n    \n    fragColor = vec4(col,1.0);\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.0 * uv - 1.0;\n    \n    p = rotate2( p, pow( length( p ), 2.0 ) * PI * sin( length( p ) ) );\n    p *= ( 0.5 + 0.5 * sin( iTime ) );\n    float v = abs( p.y * sin( p.y * p.x * ( iTime * 0.946 ) ) );\n    v = pow( v, 0.1 );\n\n    v = 1.0 - v;\n //   \n    vec3 col = vec3( v );\n    \n  //  col *=  ( hsv2rgb( vec3( ( uv.x + mod( iTime, 10.0 ) ) / 3.1415, 0.5, 0.5 ) ) );\n    col *=  ( hsv2rgb( vec3( length( p ), 0.5, 0.5 ) ) );\n    col *= 8.0;\n    \n    col = pow( col, vec3( 1.4 ) );\n  //  col = col * col * col - col * col;\n    \n    \n  //  col = hsv2rgb( vec3( sin( iTime ), 0.5, 0.5 ) );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2GzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 43, 43, 212], [214, 214, 247, 247, 355], [357, 357, 380, 380, 424], [426, 426, 449, 449, 555], [557, 557, 583, 583, 700], [702, 789, 815, 815, 1350], [1352, 1352, 1377, 1377, 1453], [1457, 1457, 1510, 1510, 2076], [2078, 2078, 2135, 2185, 2568]], "test": "error"}
{"id": "wsf3RN", "name": "cute little shader", "author": "julianlumia", "description": ":)", "tags": ["2d"], "likes": 12, "viewed": 276, "published": "Public", "date": "1575489875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tuv = sin(uv*5.);\n  //  uv *= abs(uv);\n    float r = max( 0.,  5. - length((uv)) );\n    float t = (iTime*0.5);\n    t = r * r * sin(r+t) * 2.;    \n    uv *= mat2( cos(t), sin(t), cos(t), cos(t));\n    vec3 col = 0.1 + cos(uv.y *(cos(iTime)*0.5+0.5) +iTime) *sin(iTime+uv.yxy)*0.5;\n    //col.xy = mix(uv.yx,col.yx,0.2);\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsf3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 467]], "test": "ok"}
{"id": "wsGSDc", "name": "Cuarto chico-color-v2", "author": "jorge2017a1", "description": "Cuarto chico-color-v2", "tags": ["cuartochicocolorv2"], "likes": 3, "viewed": 74, "published": "Public", "date": "1575164818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 30-nov-2019\n\n//const int nrofrays = 15;\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   \n    \n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,0.5));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,0.5));\n    float bxAtras = sdBox (p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.1));\n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.45,0.8,0.4));\n    \n    \n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    \n    \n    \n    float  spLuz = sdSphere (p-vec3(0.0), 0.5);\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    //res = opU(res, vec2(planeDist, cPlane));\n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n         } \n     } \n    \n         \n  \n    \n    res = opU(res, vec2(bxInf, CInf));\n    res = opU(res, vec2(bxDer, CDer));\n    res = opU(res, vec2(bxIzq, CIzq));\n        \n        \n    \n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n\n    \n    res = opU(res, vec2(dif1, CAtras));\n    \n    \n       \n    dif2=differenceSDF(bxSup,bxSupVentana);     \n    res = opU(res, vec2(dif2, CSup));\n    res = opU(res, vec2(spLuz, CLight));\n  \n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));\n\n    vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    float dif = GetLight(p);\n    float dif2 = abs(1.0- GetLight(pluz));\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2)/1.5;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 407, 440, 440, 505], [506, 524, 560, 560, 629], [630, 645, 676, 676, 826], [827, 847, 883, 883, 970], [971, 987, 1019, 1047, 1108], [1161, 1161, 1207, 1207, 1239], [1241, 1241, 1283, 1283, 1315], [1317, 1317, 1364, 1364, 1397], [1400, 1400, 1429, 1429, 1555], [1609, 1609, 1637, 1637, 2618], [2673, 2673, 2698, 2698, 4350], [4353, 4353, 4387, 4387, 4621], [4627, 4627, 4651, 4651, 4883], [4887, 4887, 4911, 4911, 5296], [5303, 5303, 5360, 5360, 6054]], "test": "error"}
{"id": "wsGSWd", "name": "isocahedron gift", "author": "antonOTI", "description": "Happy new year :love:", "tags": ["raymarching", "gift"], "likes": 2, "viewed": 322, "published": "Public API", "date": "1575312032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HG SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n//#define FIXED\n\n#ifdef FIXED\n#define TIME 138.6\n#else\n#define TIME iTime\n#endif\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n\tfloat q = (sqrt(5.)+3.)/2.;\n\n\tvec3 n1 = normalize(vec3(q,1,0));\n\tvec3 n2 = vec3(sqrt(3.)/3.);\n\n\tp = abs(p/r);\n\tfloat a = dot(p, n1.xyz);\n\tfloat b = dot(p, n1.zxy);\n\tfloat c = dot(p, n1.yzx);\n\tfloat d = dot(p, n2.xyz)-n1.x;\n\treturn max(max(max(a,b),c)-n1.x,d)*r;\n}\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    \n    return mat2(ca,-sa,sa,ca);\n}\n\nfloat sdCube(vec3 p)\n{\n    vec3 q = abs(p) - 1.;\n    return length(max(q, vec3(0.))) + min(max(max(q.x, q.y), q.z), 0.);\n}\n\nint m = 0;\n\nfloat map(vec3 p)\n{\n    float time = TIME * .2;\n\tvec3 cp = p;\n    \n    p.xy *= rot(time);\n    p.yz *= rot(time * .5);\n    p.xz *= rot(time * .25);\n    float dist  = sdIcosahedron(p, 1.7 );\n    if(dist < .01)\n        m = 1;\n    p = cp;\n    p.y = abs(p.y);\n    p.xy *= rot(PHI);\n    p.yz *= rot(PHI);\n    p.xz *= rot(PHI);\n    \n    float outer = sdIcosahedron(p , 10.);  \n    if(outer < .01 && m != 1)\n        m = 2;\n    \n    dist = min(dist, -outer);\n    \n    \n    return dist;\n}\n\nvec3 normal(vec3 p)\n{\n    float d = map(p);\n    vec2 e = vec2(.001,.0);\n    return normalize(\n    vec3(\n    \td - map(p + e.xyy),\n    \td - map(p + e.yxy),\n    \td - map(p + e.yyx)\n        )\n    );\n}\n\nfloat ray(inout vec3 cp, vec3 rd, out float st)\n{\n    float cd = 0.;\n    for(st = 0.; st < 1.; st += 1. / 512.)\n    {\n        cd = map(cp);\n        if(abs(cd) < .01)\n            break;\n        cp += rd * cd;\n    }\n    \n    return cd;\n}\n\n\nvec2 hash22(vec2 p) \n{\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    float zoom = 4.25;\n    uv *= zoom;\n    //float ratio = iResolution.x / 800.;\n    \n    float quantize = 160. / zoom;\n    vec2 uv2 = (fract(uv * quantize) - .5) * 2.;\n    \n    uv = floor(uv * quantize) / quantize;\n    \n    vec2 noise = hash22(uv) * 2. - 1.;\n//   \tnoise *= ratio;\n    \n//   uv += noise * .00125;\n //   uv2 += noise * .1;\n    \n    vec2 uv3 = abs(uv);\n    \n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv * .5, 1.));\n    vec3 cp = ro;\n    float st;\n    float cd = ray(cp, rd, st);\n    \n    int mat = m;\n    fragColor = vec4(1.);\n    float f = 0.;\n    if(cd < .01)\n    {\n        vec3 ld = normalize(vec3(.1,.5,.7));\n        \n        if(mat == 2)\n        {\n            ld = normalize(vec3(-1.,-3.,1.));\n        }\n        \n        vec3 norm = normal(cp);\n        float li = dot(ld, norm);\n        \n        \n        li = clamp(li, 0., 1.);\n        float d = length(cp - ro);\n        \n        float fog = exp(-d * .035);\n        \n        //f = 1. - exp(-li * 2.);\n    \n        f = li;\n        \n        if(mat == 1)\n        {\n            f = f * (.7 + .3 * pow(f, 16.));\n        \tfog = 1.8;\n        }\n        else if(mat == 2)\n        {\n            fog *= 3.85;\n              \n            f = (1. - f) * max(pow(length(uv) * .55, 2.), 0.85);\n        }\n\n        f *= .65;\n        \n        f = clamp(f, 0., 1.);\n        \n        f *= fog;\n        \n        f *= .8;\n        f = smoothstep(f, f + .1, length(uv2)) ;\n        \n       // f = (1. - f) * .9;\n        fragColor = mix(\n        \tvec4(.005,.0,.01,.0),\n            vec4(.93,.99,.91,.0),\n            f);\n        \n        float fade = length(uv3) * .75;\n        fade = fade * fade + 1.;\n        fade = 1. / (fade * fade);\n        \n        fragColor *= fade;\n        \n        fragColor = pow(fragColor, vec4(.4545));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGSWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 260, 260, 525], [527, 527, 546, 546, 630], [632, 632, 654, 654, 754], [768, 768, 787, 787, 1246], [1248, 1248, 1269, 1269, 1444], [1446, 1446, 1495, 1495, 1681], [1684, 1684, 1706, 1706, 1792], [1794, 1794, 1851, 1901, 3764]], "test": "ok"}
{"id": "WsK3zw", "name": "Grid Circles For Practice", "author": "specialsaucewc", "description": "Overlapping XOR circles in rotating grid.", "tags": ["circles", "grid", "kaleidoscope"], "likes": 4, "viewed": 116, "published": "Public", "date": "1575315724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GRIDSIZE 15.0\n#define SPEED 1.5\n#define MIN_SIZE .6\n#define MAX_SIZE 1.5\n#define RIPPLE 8.0\n#define ANGLE 45.0\n\nfloat Xor (float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime * SPEED;\n    vec3 col = vec3(0.);\n    \n    float rot = mix(0., 6.28318530718, t*.01);\n    float s = sin(rot);\n    float c = cos(rot);\n    uv *= mat2(c, -s, s, c);\n    \n    vec2 gv = fract(uv*GRIDSIZE)-.5;\n    \n    \n    float m = 0.;\n    \n    for (float y=-1.; y <= 1.; y++) {\n        for (float x=-1.; x <= 1.; x++) {\n            vec2 offs = vec2(x, y);\n            \n            float d = length(gv + offs);\n            float r = mix(MIN_SIZE, MAX_SIZE, sin(t-length(uv)*RIPPLE)*.5+.5);\n            \n            m = Xor(m, smoothstep(r, r*.9, d));\n        }\n    }\n    \n    //col.rg = gv;\n    col += m;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsK3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 150, 150, 184], [186, 186, 243, 243, 958]], "test": "ok"}
{"id": "WsKSDt", "name": "Glossy Blobs", "author": "blackle", "description": "figured out how to make fake glossy reflections! click to look around", "tags": ["blobs", "glossy"], "likes": 54, "viewed": 920, "published": "Public API", "date": "1575337121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 k) {\n  int x = FK(k.x);int y = FK(k.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat hash3(vec3 k) {\n  float h1 = hash(k.xy);\n  return hash(vec2(h1, k.z));\n}\n\nvec3 hash33(vec3 k) {\n  float h1 = hash3(k);\n  float h2 = hash3(k*h1);\n  float h3 = hash3(k*h2);\n  return vec3(h1, h2, h3);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 sphercoord(vec2 p) {\n  float l1 = acos(p.x);\n  float l2 = acos(-1.)*p.y;\n  return vec3(cos(l1), sin(l1)*sin(l2), sin(l1)*cos(l2));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(p,ax);\n}\n\nfloat comp(vec3 p, vec3 ro, float t) {\n  vec3 ax = sphercoord(ro.xy);\n  p.z -= t;\n  p = erot(p, ax, ro.z*acos(-1.));\n  float scale = 4. + hash(ro.xz)*0.5+0.5;\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - 0.8;\n}\n\nfloat scene(vec3 p) {\n  float rad = 3.+p.z+sin(p.y/2.+iTime)+cos(p.x/3.+iTime*0.9);\n  float dist = 10000.;\n  for (int i = 0; i < 4; i++) {\n    vec3 rot = hash33(vec3(float(i+1), cos(float(i)), sin(float(i))));\n    float d = comp(p, rot, iTime/2.*(float(i+1)));\n    dist = smin(dist, d, 1.);\n  }\n  return mix(dist, rad, mix(0.3,0.8+sin(iTime)*0.2, 0.1));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.1);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat drawdist = 50.;\nvec3 trace(vec3 init, vec3 cam, int itcout, inout bool hit) {\n  vec3 p = init;\n  hit = false;\n  float dist;\n  for (int i = 0; i < itcout; i++) {\n    dist = scene(p)*1.1;\n    if (dist*dist < 0.00001) { hit = true; p+= dist*cam; break;}\n    if (distance(p, init) > drawdist) { break; }\n    p += dist*cam*1.2;\n  }\n  return p;\n}\n\nfloat refcomp(vec3 p, vec3 cam, float n) {\n\tfloat dst = scene(p+cam*n);\n    float sharpness = 1.0; //higher values are more sharp\n    return smoothstep(-1., 1., (dst*sharpness));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  vec3 cam = normalize(vec3(0.8,uv));\n  bool hit = false;\n  vec3 col = vec3(1);\n  vec3 p; vec3 n;\n  vec3 init = vec3(-4,0,sin(iTime*0.37)*1.4);\n  vec2 m = iMouse.xy/iResolution.xy;\n  if (iMouse.z <= 0.) {\n    m = vec2(0.4);\n  }\n  cam = erot(cam, vec3(0,1,0), -m.y*2.+0.5);\n  init = erot(init, vec3(0,1,0), -m.y*2.+0.5);\n  cam = erot(cam, vec3(0,0,1), -m.x*6.);\n  init = erot(init, vec3(0,0,1), -m.x*6.);\n  vec3 origin = init;\n  p = trace(init, cam, 400, hit);\n  if (hit) {\n    n = norm(p);\n    float fresnel = pow(1.-abs(dot(cam, n))*0.5,2.);\n    col *= fresnel;\n    cam = reflect(cam, n);\n    hit = false;\n    init = p+n*.01;\n\tfloat comps = refcomp(init, cam, 5.) + refcomp(init, cam, 4.)*2. + refcomp(init, cam, 2.)*3. + refcomp(init, cam, 1.)*4.;\n    comps /= 10.;\n\tfloat dst2 = max(scene(p+n*2.)/2.*0.5+0.5,0.);\n    col = dst2*vec3(1.)*(pow(comps,2.))*fresnel;\n  }\n  float fog = pow(smoothstep(drawdist*.5,drawdist,distance(p,origin)),2.);\n\n  fragColor.xyz = mix(col*0.8+0.02, vec3(1),fog);\n  fragColor.xyz = pow(smoothstep(vec3(0),vec3(1),sqrt(fragColor.xyz)),vec3(1.7,1.6,1.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKSDt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[249, 249, 269, 269, 348], [350, 350, 371, 371, 428], [430, 430, 451, 451, 555], [557, 557, 598, 598, 684], [686, 686, 711, 711, 823], [825, 825, 863, 863, 927], [929, 929, 967, 967, 1149], [1508, 1508, 1527, 1527, 1637], [1661, 1661, 1722, 1722, 1985], [1987, 1987, 2029, 2029, 2167], [2169, 2169, 2226, 2226, 3454]], "test": "timeout"}
{"id": "WsKXW3", "name": "Anti-aliased step", "author": "liqwidice", "description": "Taken from https://www.ronja-tutorials.com/2019/11/29/fwidth.html", "tags": ["step"], "likes": 4, "viewed": 103, "published": "Public", "date": "1575189255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float aaStep(float edge, float gradient)\n{\n    float halfPix = fwidth(gradient) / 2.0;\n    float low = edge - halfPix;\n    float hi  = edge + halfPix;\n    return clamp((gradient - low) / (hi - low), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float theta = sin(iTime) * 25.0 * (3.14159 / 180.0);\n    uv = vec2(cos(theta) * uv.x - sin(theta) * uv.y,\n              sin(theta) * uv.x + cos(theta) * uv.y);\n\n\tvec3 col = vec3(aaStep(0.5, uv.x));\n\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 211], [213, 213, 268, 268, 548]], "test": "ok"}
{"id": "WstSWH", "name": "Ray marching 00", "author": "MaximeG", "description": "Awe", "tags": ["raymarching"], "likes": 0, "viewed": 147, "published": "Public API", "date": "1575537109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float D_MIN = 0.001;\nfloat D_MAX = 30.;\nint STEP_MAX = 512;\n\nfloat sMin(float a, float b, float t)\n{\n    float tt = max(t - abs(a-b), 0.);\n    return min(a, b) - tt * tt / t / 4.;\n}\n\nvec4 sMin(vec4 a, vec4 b, float t){\n    //https://www.iquilezles.org/apps/graphtoy/?f1(x)=4*sin(x)&f2(x)=x/3&f3(x)=0.2&f4(x)=max(f3(x)-abs(f1(x)-f2(x)),0)&f6(x)=1-max(min((0.5%20-%20(f1(x)-f2(x))/2/f3(x)),%201.),%200.)\n    float tt = max(t - abs(a.x-b.x), 0.);\n    float s = 1.-max(min(0.5-(a.x-b.x)/(2.*t),1.),0.);\n    return vec4(min(a.x, b.x) - tt * tt / t / 4., mix(a.yzw, b.yzw, s*s*(3.0-2.0*s)));\n}\n\nfloat sMax(float a, float b, float t){\n    float tt = max(t - abs(a-b), 0.);\n    return max(a, b) + tt * tt / t / 4.;\n}\n\nvec4 sMax(vec4 a, vec4 b, float t){\n    float tt = max(t - abs(a.x-b.x), 0.);\n    float s = 1.-max(min(0.5-(a.x-b.x)/(2.*t),1.),0.);\n    return vec4(max(a.x, b.x) + tt * tt / t / 4., mix(a.yzw, b.yzw, s*s*(3.0-2.0*s)));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s, float r){\n    return length(max(abs(p) - s, 0.)) - r;\n}\n\nfloat sdTorus(vec3 p, float r1, float r2){\n    return length(vec2(length(p.xz)-r2,p.y)) - r1;\n}\n\n\nvec4 dist(vec3 p){\n    float dplan = p.y;\n    vec4 plan = vec4(dplan, vec3(0.5,0.5,0.5));\n    \n    float dsphere = sdSphere(p-vec3(1.5,1.5,0), 1.);\n    vec4 sphere = vec4(dsphere, vec3(0.3, 0.2, 0.8));\n\n    dsphere = -sdSphere(p-vec3(-1.5,1.5,0), 1.);\n    vec4 sphere2 = vec4(dsphere, vec3(0.3, 0.8, 0.2));\n    \n    float dbox = sdBox(p-vec3(sin(iTime * 0.6) * 3., 0.5, 1), vec3(0.5, 1, 2), 0.);\n    vec4 box = vec4(dbox, vec3(0.8, 0.3, 0.2));\n\n    vec4 m = sMin(sMax(box, sphere2, 0.2), sphere, 0.8 + cos(iTime * 1.)*0.0);\n    \n    \n    vec3 pt = p;\n    pt.y -= 0.04*sin(p.x*11.);\n    dbox = abs(sdBox(pt-vec3(0,1,5), vec3(.8,.2,.2),0.) -0.4)-0.1;\n    box = vec4(dbox, vec3(.7,.7,.7));\n    \n    vec4 m2 = sMax(box, vec4(pt.y-1.-sin(iTime),vec3(0.8,0.2,0.3)),0.1);\n    \n    pt = vec3(mod(p.x,16.)-8.,p.y-1.,mod(p.z,16.)-8.);\n    float a = pt.y * .4 + iTime * .6;\n    mat2 mr = mat2(cos(a),-sin(a),sin(a),cos(a));\n    pt.xz *= mr;\n    dbox = sdBox(pt, vec3(.125,16.,0.5),0.);\n    box = vec4(dbox, vec3(0.2,.7,.5));\n    \n    vec4 m3 = sMin(box, plan, 4.);\n    \n    m2 = sMin(m2, m3, 0.1);\n    \n    pt = p;\n    pt.yz *= 1.;\n    \n    m2 = sMin(m2, vec4(sdTorus(pt-vec3(0.,0.,0.),.5,6.), .7,.3,.8), 0.2);\n    \n    return sMin(m, m2, 0.001);\n}\n\nvec4 RayMarch(in vec3 ro, vec3 dir)\n{\n    float td = 0.;\n    vec4 p;\n    for (int i=0; i<STEP_MAX; i++){\n        vec3 pos = ro + dir * td;\n        p = dist(pos);\n        if (p.x<D_MIN) break;\n        td += p.x * .9;\n        if (td>D_MAX) break;\n    }\n    return vec4(td, p.yzw);\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(dist(p + e.xyy).x - dist(p - e.xyy).x,\n                          dist(p + e.yxy).x - dist(p - e.yxy).x,\n                          dist(p + e.yyx).x - dist(p - e.yyx).x ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 ro = vec3(7.*sin(iTime*0.09),6,-7.*cos(iTime*0.09));\n    vec3 o = normalize(vec3(0,1,1)-ro);\n    vec3 x = cross(vec3(0,1.,0), o);\n    vec3 y = cross(o, x);\n    mat3 cd = mat3(x.x,y.x,o.x,x.y,y.y,o.y,x.z,y.z,o.z);\n    vec3 rd = normalize(vec3(uv.x,uv.y,0.9)*cd);\n    \n    vec4 rm = RayMarch(ro, rd);\n    float d = rm.x;\n    vec3 pos = ro + d * rd;\n    \n    vec3 col = vec3(0);\n    \n    if (d<D_MAX)\n    {\n        col = rm.yzw;\n        vec3 n = normal(pos);\n        vec3 lp = vec3(2,6,-3);\n        vec3 ld = normalize(pos-lp);\n        float ll = dot(n, -ld);\n        float pl = dot(n, vec3(0, -1, 0));\n        float sl = dot(n, vec3(0, 1, 0));\n        float c = ll*1.4 + pl*0.8 + sl*0.8;\n        //c = pow(c, 0.4545);\n        col *= c;\n        float ldist = length(pos - lp);\n        if (RayMarch(pos + n * 0.4, -ld).x < ldist) col *= 0.2;\n    }\n    else\n    {\n        col = vec3(0.5, 0.5, 0.75) * (1. - rd.y * 0.2);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 100, 100, 181], [183, 183, 218, 401, 587], [589, 589, 627, 627, 708], [710, 710, 745, 745, 931], [933, 933, 966, 966, 994], [996, 996, 1033, 1033, 1079], [1081, 1081, 1123, 1123, 1176], [1179, 1179, 1197, 1197, 2416], [2418, 2418, 2455, 2455, 2698], [2700, 2700, 2720, 2720, 2949], [2951, 2951, 3007, 3007, 4037]], "test": "timeout"}
{"id": "WsVXW3", "name": "Disco Floor", "author": "andremichelle", "description": "Diamond Plate derived from 2d.", "tags": ["normals"], "likes": 9, "viewed": 452, "published": "Public API", "date": "1575219653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash(vec2 P) {\n\treturn fract(cos(dot(P,vec2(91.52,-74.27)))*939.24);\n}\n\nfloat Value(vec2 P) {\n\tvec2 F = floor(P);\n\tvec2 S = P-F;\n\tvec4 M = (S*S*(3.-S-S)).xyxy;\n    M = M*vec4(-1,-1,1,1)+vec4(1,1,0,0);\n\treturn (Hash(F+vec2(0,0))*M.x+Hash(F+vec2(1,0))*M.z)*M.y+\n\t\t   (Hash(F+vec2(0,1))*M.x+Hash(F+vec2(1,1))*M.z)*M.w;\n}\n\nfloat Noise(vec2 P) {\n\treturn \n        .6*Value(P*8.)+\n        .4*Value(P*16.)+\n        .3*Value(P*32.)+\n        .2*Value(P*64.);\n}\n\nfloat mat(vec2 uv, vec2 offset) {\n\treturn Noise(uv*vec2(6., 20.)+offset);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) {\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdCircle( vec2 p, float r ) {\n  return length(p) - r;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdDiamond(vec2 p) {\n    return opSmoothUnion(sdRhombus(p, vec2(.2, 1.)), sdCircle(p, .2), .1);\n}\n\nvec4 over( in vec4 a, in vec4 b ) {\n    return mix(a, b, 1.-a.w);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 diamonds(vec2 uv, float angle) {\n    vec2 p = vec2(uv);\n    mat2 r = rot(angle);\n    p = fract(p)*2.-1.;\n    p *= r;\n    float d = sdDiamond(p);\n    float a = smoothstep(.01, .0, d);\n    float zp = smoothstep(.0, .1, -d);\n    float zh = smoothstep(.0, .1, -sdDiamond(p+vec2(.01, .0)));\n    float zv = smoothstep(.0, .1, -sdDiamond(p+vec2(.0, .01)));\n\treturn zp+zh+zv==0. \n        ? vec4(0,0,0,a)\n        : vec4(normalize( vec3(zp-zh, zp-zv, zp)), a);\t\n}\n\nvec3 light(vec3 lp, vec3 lc, vec3 n, vec2 uv) {\n    vec3 ld = vec3(lp.xy-uv, lp.z-n.z);\n    float l = length(ld);\n    return lc*pow(max(.0, dot(n, ld/l)), 4.)/l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y*2.;\n    \n    float n0 = mat(uv, vec2(.0));\n    float n1 = mat(uv, vec2(.001, .000));\n    float n2 = mat(uv, vec2(.000, .001));\n    \n    vec4 c = vec4(.0);\n\tvec4 d0 = diamonds(uv*3.+.0,  .78539);\n\tvec4 d1 = diamonds(uv*3.+.5, -.78539);\n\tfloat a = max(d0.w, d1.w);\n    vec3 n = (d0.xyz + d1.xyz)*a + vec3(n0-n1, n0-n2, n0)*.6*(1.-a*.6);\n    float t = iTime;\n    mat2 m0 = rot( t*1.4+.4)*sin(t*.4+.2);\n    mat2 m1 = rot(-t*1.4+.7)*sin(t*.6+.5);\n    mat2 m2 = rot( t*1.4+.9)*cos(t*.8+.9);\n\n    // light colors\n    vec3 l0c = vec3(1., .3, 1.);\n    vec3 l1c = vec3(.1, .3, 1.);\n    vec3 l2c = vec3(.1, 1., 1.);\n    // light positions\n    vec3 l0v = vec3(vec2(.99, 0.)* m0, 1.5);\n    vec3 l1v = vec3(vec2(.70, 0.)* m1, 1.5);\n    vec3 l2v = vec3(vec2(.00, 1.)* m2, 1.5);\n    // light intensity\n    float li0 = pow(distance(uv, l0v.xy), -1.4);\n    float li1 = pow(distance(uv, l1v.xy), -1.4);\n    float li2 = pow(distance(uv, l2v.xy), -1.4);\n\n    vec3 rc = vec3(.05+n0*n0*n0*n0*.1);\n    rc += pow(max(.0, n.z), 2.)*.12;\n    rc += light(l0v, l0c, n, uv);\n    rc += light(l1v, l1c, n, uv);\n    rc += light(l2v, l2c, n, uv);\n    c = over(vec4(rc, 1.), c);\n    \n    // light dots\n    c.rgb += l0c*li0*.004+li0*n0*.008;\n    c.rgb += l1c*li1*.004+li1*n0*.008;\n    c.rgb += l2c*li2*.004+li2*n0*.008;\n\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 76], [78, 78, 99, 99, 323], [325, 325, 346, 346, 456], [458, 458, 491, 491, 533], [535, 535, 564, 564, 592], [594, 594, 635, 635, 837], [839, 839, 874, 874, 900], [902, 902, 952, 952, 1051], [1053, 1053, 1078, 1078, 1155], [1157, 1157, 1192, 1192, 1224], [1226, 1226, 1245, 1245, 1315], [1317, 1317, 1354, 1354, 1775], [1777, 1777, 1824, 1824, 1940], [1942, 1942, 1998, 1998, 3362]], "test": "timeout"}
{"id": "WsySDd", "name": "dumb ocean", "author": "jimage", "description": "just a dumb wavy ocean", "tags": ["oceanwavesmalkovich"], "likes": 1, "viewed": 67, "published": "Public", "date": "1575293234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv += .5;\n    \n    //uv.x /=-1.0+cos(iTime)*3.;\n\n    // Time varying pixel color\n    float left = step(sin(uv.x*20.+cos(iTime))+5.+sin(iTime),uv.y*20.+cos(iTime/3.));\n    float left1 = step(sin((uv.x-sin(iTime))*sin(iTime/5.)*20.)+10.+cos(iTime+10.), (uv.y)*20.);\n    float left2 = step(sin(uv.x*30.+cos(iTime))+15.+sin(iTime/uv.y)*cos(iTime/10.),uv.y*20.+cos(iTime/3.));\n    float c = left - left1;\n \n   \n    fragColor = vec4(left2,left1,(left2+left)*0.9,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsySDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 617]], "test": "ok"}
{"id": "WsySWt", "name": "Float Limit Exceed", "author": "harry7557558", "description": "sawtooth effect produced by exceeding of float point accuracy limit", "tags": ["graph", "function"], "likes": 5, "viewed": 138, "published": "Public", "date": "1575254924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(in float x){\n    return 0.25*(pow(exp(x)+exp(-x),2.0)-pow(exp(x)-exp(-x),2.0)); \t// always equal to 1\n}\n\nfloat grad(in float x){\n    const float eps = 1e-2;\n    float a = (f(x+eps)-f(x-eps))/(2.0*eps);\n    return sqrt(a*a+1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.05*(sin(iTime)+2.0)*length(iResolution.xy);\n    vec2 p = (fragCoord-0.5*iResolution.xy)/s+vec2(10.0*sin(0.2*iTime),1.0);\n    float sd = 1.0-min(0.2*s*(abs(p.x)-0.008),1.0);\n    vec3 col = vec3(0,0,sd);\n    sd = min(s*(abs(p.y)-0.03),1.0);\n    col = mix(vec3(1,0,0),col,sd);\n\tsd = (f(p.x)-p.y)/grad(p.x);\n    sd = clamp(0.0,1.0,s*(abs(sd)-0.03));\n    col = mix(vec3(0,1,0),col,sd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsySWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 111], [113, 113, 136, 136, 237], [239, 239, 296, 296, 726]], "test": "ok"}
{"id": "Wt33D8", "name": "Corner Rect Fractal", "author": "HyperChromatica", "description": "An extension of the minimal fractal into 2D", "tags": ["fractal", "rectangular"], "likes": 0, "viewed": 52, "published": "Public", "date": "1576097955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 1.0f-uv;\n    \n    float boundary = 1.0f; //boundary is position of edge between fractals\n    float fract = 2.0f; //fract is the ratio of fractal n-1/n\n    float nx =  ceil(-log2(uv.x)/log2(fract)); //nx is the depth of the fractal (recursively) in x dir.\n    float ny = ceil(-log2(uv.y)/log2(fract));\n    float n = min(nx,ny);\n    boundary = 1.0f;\n    for(int i = 0 ; i < int(n); i++)\n    {\n        boundary /= fract;\n    }\n    \n    float L = (max( (uv.y-boundary) ,(uv.x - boundary) )*(.85f + .15 * sin(iTime) ))/(boundary-boundary/fract ) +.5f;\n    float r = float(int(n)%4) ;\n    float g = float(int(n+1.0f)%4);\n    float b = float(int(n+2.0f)%4);\n    vec3 col = vec3( r/4.0f, (g)/4.0f, (b)/4.0f)/L;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt33D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 918]], "test": "ok"}
{"id": "wt33Dn", "name": "SimpValNoise", "author": "foran", "description": "SimpValNoise", "tags": ["simpvalnoise"], "likes": 4, "viewed": 74, "published": "Public", "date": "1576007238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n//----------\nfloat Value2D(vec2 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value2D.glsl\n    \n    //\testablish our grid cell and unit position\n    vec2 Pi=floor(P);\n    vec2 Pf=P-Pi;\n    \n    //\tcalculate the hash.\n    vec4 Pt=vec4(Pi.xy,Pi.xy+1.);\n    Pt=Pt-floor(Pt*(1./71.))*71.;\n    Pt+=vec2(26.,161.).xyxy;\n    Pt*=Pt;\n    Pt=Pt.xzxz*Pt.yyww;\n    vec4 hash=fract(Pt*(1./951.135664));\n    \n    //\tblend the results and return\n    vec2 blend=Pf*Pf*Pf*(Pf*(Pf*6.-15.)+10.);\n    vec4 blend2=vec4(blend,vec2(1.-blend));\n    return dot(hash,blend2.zxzx*blend2.wwyy);\n}\nfloat SimplexPerlin2D(vec2 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin2D.glsl\n    \n    //  simplex math constants\n    const float SKEWFACTOR=.36602540378443864676372317075294;// 0.5*(sqrt(3.0)-1.0)\n    const float UNSKEWFACTOR=.21132486540518711774542560974902;// (3.0-sqrt(3.0))/6.0\n    const float SIMPLEX_TRI_HEIGHT=.70710678118654752440084436210485;// sqrt( 0.5 )\theight of simplex triangle\n    const vec3 SIMPLEX_POINTS=vec3(1.-UNSKEWFACTOR,-UNSKEWFACTOR,1.-2.*UNSKEWFACTOR);//  simplex triangle geo\n    \n    //  establish our grid cell.\n    P*=SIMPLEX_TRI_HEIGHT;// scale space so we can have an approx feature size of 1.0\n    vec2 Pi=floor(P+dot(P,vec2(SKEWFACTOR)));\n    \n    // calculate the hash\n    vec4 Pt=vec4(Pi.xy,Pi.xy+1.);\n    Pt=Pt-floor(Pt*(1./71.))*71.;\n    Pt+=vec2(26.,161.).xyxy;\n    Pt*=Pt;\n    Pt=Pt.xzxz*Pt.yyww;\n    vec4 hash_x=fract(Pt*(1./951.135664));\n    vec4 hash_y=fract(Pt*(1./642.949883));\n    \n    //  establish vectors to the 3 corners of our simplex triangle\n    vec2 v0=Pi-dot(Pi,vec2(UNSKEWFACTOR))-P;\n    vec4 v1pos_v1hash=(v0.x<v0.y)?vec4(SIMPLEX_POINTS.xy,hash_x.y,hash_y.y):vec4(SIMPLEX_POINTS.yx,hash_x.z,hash_y.z);\n    vec4 v12=vec4(v1pos_v1hash.xy,SIMPLEX_POINTS.zz)+v0.xyxy;\n    \n    //  calculate the dotproduct of our 3 corner vectors with 3 random normalized vectors\n    vec3 grad_x=vec3(hash_x.x,v1pos_v1hash.z,hash_x.w)-.49999;\n    vec3 grad_y=vec3(hash_y.x,v1pos_v1hash.w,hash_y.w)-.49999;\n    vec3 grad_results=inversesqrt(grad_x*grad_x+grad_y*grad_y)*(grad_x*vec3(v0.x,v12.xz)+grad_y*vec3(v0.y,v12.yw));\n    \n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION=99.204334582718712976990005025589;\n    \n    //\tevaluate and return\n    vec3 m=vec3(v0.x,v12.xz)*vec3(v0.x,v12.xz)+vec3(v0.y,v12.yw)*vec3(v0.y,v12.yw);\n    m=max(.5-m,0.);\n    m=m*m;\n    return dot(m*m,grad_results)*FINAL_NORMALIZATION;\n}\n\n//----------\nmat2 rotate (float t) {\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat fBm(vec2 st, float noisetype) {\n\n    float frequency = 1.0;\n    float amplitude = 0.5;\n    float value = 0.0;\n\n    for (float i = 0.; i <6.+7.*sin(iTime*.5)*sin(iTime*.95)+1.; i++) {\n        if (noisetype == 0.0)\n            value += amplitude * Value2D(frequency * st);\n        else\n            value += amplitude * SimplexPerlin2D(frequency * st);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n        st = rotate(0.4) * st;\n\n    }\n\n    return value;\n}\n\nfloat warp (vec2 st, float noise) {\n    // f(p) = f(p + h(p))\n    // h(p): vec2->vec2\n    float r = 0.0;\n    r = fBm(st, noise);\n    vec2 st1 = vec2(0.0);\n\n    st1.x = fBm(st, noise);\n    st1.y = fBm(st + vec2(1.0), noise);\n\n    st1.x = fBm(st + st1 + 0.15 * iTime, noise);\n    st1.y = fBm(st + st1 + 0.125 * iTime + vec2(100.0, 12323.0), noise);\n    return fBm(st + st1, noise);\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 st=gl_FragCoord.xy/iResolution.xy;\n    float yf = fract(st.y * 3.0);\n    float xf = st.x;\n\n    float scale = 5.0;\n    st *= scale;\n    float r = 0.0;\n\n    if (st.x < 0.5 * scale) {\n\n        \n            r = warp(st, 0.0);\n            vec3 co=vec3(r);\n            fragColor=vec4(co,1.);\n      \n\n    } else {\n        \n            r = warp(st, 1.0);\n            float t=iTime*.13;\nvec3 eye=vec3(st,-2.5);\nvec3 pos=eye;\nvec3 norm=normalize(pos);//  \nnorm.xy*=rot(t+pos.z);//  ÑÐ¸Ð½Ðµ-ÐºÑÐ°ÑÐ½ÑÐ¹\nnorm.xz*=rot(t+pos.y);//  Ð·ÐµÐ»ÑÐ½Ð¾-ÑÐ¸Ð¾Ð»ÐµÑÐ¾Ð²ÑÐ¹\nnorm.yz*=rot(t+pos.x);//  Ð¶ÐµÐ»ÑÐ¾-ÑÐ¸Ð½Ð¸Ð¹\nvec4 col=vec4(norm,0.);\nfragColor=col;\n        \n    }\n    \n    r*=smoothstep(0.,.005,abs(xf-.5));\n    \n    vec3 color = vec3(r);\n    fragColor*= vec4(color , 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt33Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 79, 102, 227, 652], [653, 653, 684, 799, 2683], [2685, 2698, 2721, 2721, 2773], [2775, 2775, 2812, 2812, 3241], [3243, 3243, 3278, 3328, 3625], [3627, 3627, 3681, 3681, 4456]], "test": "ok"}
{"id": "wt33DX", "name": "Beehive (Practice #5)", "author": "Coda_", "description": "Beehive (Practice #5)", "tags": ["torus", "yellow", "infinite"], "likes": 7, "viewed": 104, "published": "Public", "date": "1577727734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n\nfloat torus(vec3 p, vec2 r)\n{   p.yz *= mat2(cos(1.57),-sin(1.57),sin(1.57),cos(1.57)); \n    vec3 q = fract(p)*2.0 -1.0;\n    float x = length(q.xz)-r.x;\n\treturn length(vec2(x,q.y))-r.y;\n}\n\n\nfloat trace (vec3 o,vec3 r)\n{\n\tfloat t = 0.0;\n    for(int i=0;i<100;i++)\n    {\n    \tvec3 p = o+r*t;\n        float d = torus(p-vec3(0.0,0.0,0.0),vec2(1.1,mix(0.01,0.015,sin(time))));\n        t+=d*0.09;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv-= 0.5;\n    uv/= vec2(iResolution.y/iResolution.x,1.0);\n    \n    vec3 r = normalize(vec3(uv,1.0));\n    float tt = time*0.15;\n    r.xy *= mat2(cos(tt),-sin(tt),sin(tt),cos(tt)); \n    vec3 o = vec3(0,0,tt*2.0);\n\t\n    float t = trace(o,r);\n\n    vec3 col = vec3(1, 0.85, 0);\n\tfloat fog = 1.0/(1.0+t*t*0.2); \n    fragColor = vec4(vec3(col)*fog,1.0)*2.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt33DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 50, 50, 208], [211, 211, 240, 240, 433], [436, 436, 493, 493, 928]], "test": "ok"}
{"id": "wt33RN", "name": "[TWITCH] Refracted brutalism", "author": "evvvvil", "description": "\"Refracted brutalism\" result of a 2.5h improv live coding session on Twitch\nMAJOR THANKX go to: LJ, Crundle and Alkama for the hive mind and help with schlick-fresneled refracted reflections and size coded shadows.\nhttps://www.twitch.tv/evvvvil_", "tags": ["clouds", "refraction", "demoscene", "light", "shadows", "reflections", "fresnel", "point", "architecture", "brutalism", "twitch", "improv", "brutalist"], "likes": 61, "viewed": 1808, "published": "Public API", "date": "1575808904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Refracted brutalism\" - Result of a 2.5h improv live coding session on Twitch\n\n// MAJOR THANKX go to: LJ, Crundle and Alkama for the hive mind and\n// help with schlick-fresneled refracted reflections and size coded shadows\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"How you expect to run with wolves come night, when you spend all day sparring with puppies.\" Omar - The Wire\n\nvec2 z,v,e=vec2(0.01,0);float t,tt;vec3 np,bp,no,po,ld,al; //global variables\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //2d rotate function\nvec2 fb( vec3 p )// base geometry piece function\n{  \n  vec2 h,t=vec2(bo(p,vec3(2,5,2)),5); //basic raymarching modelling with primitives and material id\n  t.x=max(t.x,-bo(p,vec3(1.5,15,1.5))); //removing from blue box\n  t.x=min(t.x,bo(p,vec3(15,0.3,0.3))); //adding box to blue box\n  t.x=min(t.x,bo(p,vec3(0.4,15,0.4))); //adding more box to blue box\n  h=vec2(length(p.xz)-8.,3); // black structural cylinder\n  h.x=max(h.x,-(length(p.xz)-6.)); //remove from black cylinder\n  h.x=max(h.x,bo(p,vec3(15,0.5,15))); //intersection cut of black cylinder into flat cross\n  t=t.x<h.x?t:h; //merging blue and black materials\n  h=vec2(length(p.xz)-7.5,6); //white structural cylinder \n  h.x=max(h.x,-(length(p.xz)-6.5)); //removing from white cylinder\n  h.x=max(h.x,bo(p,vec3(15,0.8,15))); //intersection white cylinder into flat cross\n  h.x=min(h.x,bo(p,vec3(0.2,15,0.6))); //adding big white edges to blue. BRUTALISM MEANS BRUTALISM\n  t=t.x<h.x?t:h; //merge blue and black with white material\n  return t;\n}\nvec2 mp( vec3 p )\n{\n  p.xy*=r2(sin(1.57+p.z*.2)*.1); //overall wave\n  np=p; //setup new postion\n  np.z=mod(np.z+tt*2.,30.)-15.; //make it infiniote along z axis\n  for(int i=0;i<6;i++){ //basic kaleidoscopic function\n    np=abs(np)-vec3(8.5,0.0,4.5); //push geom out each iteration with symatery abs creating more geometry\n    np.xz*=r2(.785); //90 degree rotate each iteration\n  }  \n  vec2 h,t=fb(np); //make complex network based on simple basic geometry piece function by passing in the new more complex position np\n  bp=np+vec3(0,-12,0); bp.xy*=r2(1.57);  //derive new position 2 bp out of first new position np\n  h=fb(abs(bp*.5)-vec3(4,7.5,0)); //make more complex geom based on simple basic piece function by passing another new position 2 bp\n  h.x*=2.; t=t.x<h.x?t:h; //adapt size and merge both complex networks of geometry\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd,float _max,int iter ) //main trace  / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //0.1 is near plane\n  for(int i=0;i<iter;i++){ //march for iter amount of iterations\n    h=mp(ro+rd*t.x); //get distance to geom\n    if(h.x<.0001||t.x>_max) break; //conditional break we hit something or gone too far\n    t.x+=h.x;t.y=h.y; //huge step forward and remember material id\n  }\n  if(t.x>_max) t.y=0.;//if we hit far plane return material id = 0, we will use it later to check if we hit something\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}// We miss you on Twitch Luna... Sending some love.\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime,59.66)+4.72; //modulo time to avoid glitchy artifact and also nicely reset camera / scene\n  vec3 lp=vec3(3.+cos(tt*.2)*10.,6.+sin(tt*.4)*0.5,-10), //light position\n  ro=lp*mix(vec3(1),vec3(-1,2.2,1),ceil(cos(tt))), // ray origin = camera position\n  cw=normalize(vec3(sin(tt*.4)*2.,cos(tt*.2)*10.,0)-ro), //camera forward vector\n  cu=normalize(cross(cw,vec3(0,1,0))), //camera left vector ?\n  cv=normalize(cross(cu,cw)), //camera up vector ?\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo; //ray direction \n  lp+=vec3(0,5.+sin(tt)*.5,5); // light position offset animation\n  v=vec2(abs(atan(rd.x,rd.z)),rd.y); //polar uv for pseudo clouds\n  co=fo=clamp(vec3(.1)+(1.-length(uv))+0.5*texNoise(v).r,0.,1.); // background with pseudo clouds made from noise\n  z=tr(ro,rd,50.,128);t=z.x; // let's trace and get result\n  if(z.y>0.){ // we hit something \n    po=ro+rd*t; // get position where we hit\n    ld=normalize(lp-po); //get light direction from light pos\n    no=normalize(mp(po).x-vec3(mp(po-e.xyy).x,mp(po-e.yxy).x,mp(po-e.yyx).x)); //LJ's \"fit in da pocket\" normals calculation \n    float line=ceil(cos(np.x*2.1))-ceil(cos(np.x*2.1+.1)); // lines on blue geometry\n    al=clamp(line+mix(vec3(0.0,.3,.7),vec3(.1,.5,.7),sin(1.57+np)*.5+.5),0.,1.); //blue geomtry albedo colour: subtle gradient with lines\n    if(z.y<5.) al=vec3(0); if(z.y>5.) al=vec3(1); //material id < 5 -> black; material id > 5 -> white \n    float dif=max(0.,dot(no,ld)), // diffuse lighting\n    fr=pow(1.-abs(dot(rd,no)),4.), // Get schlick fresnel for reflections before we refract. Major thankx to LJ for this\n    spo=exp2(15.*texNoise(0.3*vec2(.05,.1)*vec2(np.x,dot(np.yz,vec2(.5)))).r), // Gloss specular map made from noise\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo), //Specular lighting\n    ldd=length(lp-po), attn=1.0-pow(min(1.0,ldd/15.),4.0); //point light attenuation\n    attn*=ldd>tr(po,ld,min(15.,ldd),50).x?.5:1.; // Size coded shadows. Major thankx to crundle and alkama for this\n    co=(sp+al*(a(.05)*a(1.))*(dif+s(.1)))*attn; // mix all lighting into final lighting result\n    if(z.y==5.){ //REFLECTIONS If we hit material ID of 5 (blue geometry)\n      rd=refract(rd,-no,1.+(spo*.002-.05)); // Gloss specular map reused to refract ray for the reflections \n      z=tr(po+rd*0.01,rd,50.,80); //Shoot ray again from surface to refracted reflected ray - Major thankx to shane for +rd*0.01 offset\n      po=po+rd*z.x; ld=normalize(lp-po); // get reflection pos we hit and light direction\n      no=normalize(mp(po).x-vec3(mp(po-e.xyy).x,mp(po-e.yxy).x,mp(po-e.yyx).x)); //LJ's \"fit in da pocket\" normals calculation      \n      al=mix(vec3(0.0,.3,.7),vec3(.1,.5,.7),sin(1.57+np)*.5+.5);//reflected albedo is more simple without lines to simplify & optimize\n      attn=1.0-pow(min(1.0,ldd/20.),4.0);//attenuate reflections lighting bit less than before to fake ambient lighting reflections\n      if(z.y<5.) al=vec3(0); if(z.y>5.) al=vec3(1); //material id < 5 -> black; material id > 5 -> white \n      float dif=max(0.,dot(no,ld));//naive reflections lighting. Just diffuse*albedo. No ao, no sss, no specular to optmize & make reflections more homogenous\n      co+=dif*al*fr*attn;// add reflections lighting to final colour with schlick fresneled and gloss map refractions (line 86-87)\n    }    \n  }\n  co=mix(fo,co,exp(-.00003*t*t*t)); // fog\n  fragColor = vec4( pow(co,vec3(.45)),1); // naive gamma correction\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt33RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 530, 554, 554, 595], [596, 612, 629, 629, 672], [673, 694, 744, 744, 1692], [1693, 1693, 1712, 1712, 2537], [2538, 2538, 2640, 2640, 3082], [3083, 3194, 3217, 3217, 3421], [3562, 3562, 3691, 3691, 7195]], "test": "error"}
{"id": "Wt33WS", "name": "cube (I)", "author": "omis", "description": "simple raymarching cube", "tags": ["raymarching"], "likes": 2, "viewed": 80, "published": "Public", "date": "1577354913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat rep(float x, float r)\n{\n\treturn mod(x, r) - r / 2.0;\n}\n\nfloat sdCube(vec3 p, vec3 b) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    float rp = .75;\n    p.x = rep(p.x, rp);\n    p.y = rep(p.y, rp);\n    p.z = rep(p.z, rp);\n    p.yz *= rot(iTime*0.5);\n    p.xz *= rot(iTime*0.5);\n\treturn sdCube(p, vec3(0.1));\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float tmin)\n{\n\tfloat t = tmin;\n    \n    for (int i = 0; i < 128; i++) \n    {\n    \tfloat d = map(ro + rd * t);\n        if (d < 0.0001*t) {\n        \tbreak;\n        }\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 raydir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = -2.0;\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n}\n\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = map(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( map(pos + eps_zero.xyy), map(pos + eps_zero.yxy), map(pos + eps_zero.yyx) ) - c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // camera\n    vec3 ro = vec3(sin(iTime), 0.0, -iTime);\n    vec3 ta = vec3(.0);\n    \n    // ray\n    vec3 rd = raydir(uv, ro, ta);\n    \n    \n    // render\n    float d = raymarch(ro, rd, 0.0);\n    vec3 p = ro + rd * d;\n    vec3 norm = calcNormal(p);\n    vec3 col = vec3(1.0-exp(d*0.25)) + norm;\n    \n\tcol = pow(col, vec3(2.0));    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt33WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 68], [70, 70, 99, 99, 130], [132, 132, 163, 163, 250], [252, 252, 271, 271, 451], [453, 453, 499, 499, 692], [694, 694, 745, 829, 1121], [1124, 1124, 1151, 1172, 1400], [1402, 1402, 1459, 1497, 1974]], "test": "ok"}
{"id": "wt3GDf", "name": "aquaColor", "author": "foran", "description": "aquaColor", "tags": ["aquacolor"], "likes": 6, "viewed": 113, "published": "Public", "date": "1577735452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nmat2 rot2d(float a )\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat map(vec3  p)\n{\n  p.xy = p.xy * rot2d(p.z * 0.2);\n  return cos(p.x) + \n  sin(p.y + 1.0) + \n  cos(p.z) + \n  (.05 + 0.42 * \n  sin(iTime)) * \n  cos(p.y + \n  p.z * \n  2.0) + \n  0.1 * \n  cos(p.y);\n}\n\nvec3 grad(vec3 p)\n{\n  vec2 eps = vec2(0.001, 0.0);\n  return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                   map(p + eps.yxy) - map(p - eps.yxy),\n                   map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\nvec3 rm(vec3 ro, vec3 rd, out float st)\n{\n    vec3 p = ro;\n  for (float i = 0.; i < 64.; ++i)\n  {\n    float d = map(p);\n    if (abs(d) < 0.001)\n    {\n      st = i;\n      break;\n    }\n    p += d * rd * 0.8;\n  }\nreturn p;\n}\n\nvec3 shade(vec3 p, vec3 ro, float st, vec3 n)\n{\n  vec3 color = exp(-distance(p, ro)* 0.1) * (n * 1.1 + 0.5) * pow((float(st) / 4.0), 0.5);\n  color = mix(vec3(0.1, 0.7, 1.0), color, exp(-distance(p, ro)* 0.1));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n  vec3 ro = vec3(0.0, 0.0, (iTime*.1) * 8.0);\n  vec3 rd = normalize(vec3(uv, 0.7 - length(uv)));\n  rd.xy *= rot2d((iTime*.1));\n  float st = 0.0;\n  vec3 p = rm(ro, rd, st);\n  vec3 n = grad(p);\n  vec3 color = shade(p, ro, st, n);\n  vec3 rd2 = reflect(rd, n);\n  vec3 ro2 = p + 0.1 * rd2;\n  vec3 p2 = rm(ro2, rd2, st);\n  vec3 n2 =  grad(p2);\n  vec3 color2 =  shade(p2, ro, st, n2);\n  color = mix(color, color2, 0.65);\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3GDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 24, 24, 94], [96, 96, 116, 116, 294], [296, 296, 315, 315, 523], [525, 525, 566, 566, 746], [977, 977, 1031, 1031, 1601]], "test": "timeout"}
{"id": "wt3GRj", "name": "Find Smile", "author": "lzjseed", "description": "Find Smile", "tags": ["cartoon", "smile", "funny"], "likes": 4, "viewed": 117, "published": "Public", "date": "1576834957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat line(vec2 p,vec2 a,vec2 b,float r,float k)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float lba = length(ba);\n    vec2  nba = normalize(ba);\n    \n    float t = dot(pa,nba);\n   \n    float tt = t / lba * 2.0 - 1.0;\n\n    tt = cos(tt * 3.1415926 * k);\n\n    vec2 projd = a + t * nba;\n\n    vec2 hd = normalize(p - projd);\n\n    vec2 npa = normalize(pa);\n\n    float cro = sign(nba.x * npa.y - nba.y * npa.x);\n\n    vec2 curp = projd - hd * tt * r*cro;\n\n    float h = length(curp - p);\n\n    return ((t >= 0.0 && t <= lba)) ? smoothstep(r - 4./iResolution.y,r , h) : 1.0;\n}\n\nvoid calcAnchorInfo(vec2 p,vec2 a,float r,float b,float t,out vec2 c,out vec2 d,out float fb,out float h)\n{\n\tvec2 pa = p - a;\n    vec2 up = normalize(vec2(0.0,1.0));\n    vec2 right = normalize(vec2(1.0,0.0));\n\n    if(abs(t) < 1.1e-3)\n    {\n        d = a - up * b,\n    \tc = a + up * b;\n    \n        h = abs(pa.x);\n        float l = abs(pa.y);\n\n        fb = l - b;\n    }\n    else\n    {\n        t = clamp(t,-3.1415 / 2.0,3.1415 / 2.0);\n        vec2 up0 = vec2(sin(t),cos(t));\n        right = t >= 0.0 ? right : -right;\n        t = abs(t);\n\n        float e = b * sin(t) / t;\n        d = a - up * b;\n        c = d + up0 * 2.0 * e;\n        vec2 m = d + up0 * e;\n        vec2 pm = p - m;\n\n        vec2 s0 = d + right * (b / t);\n\n        vec2 ps0 = p - s0;\n        \n        ps0 = ps0 - 2.0 * max(dot(ps0,up0),0.0) * up0;\n        \n        float lps0 = length(ps0);\n\n        h = abs(lps0 - (b / t));\n        fb = -ps0.y;\n    }\n}\n\nfloat[] offset1 = float[](0.0,0.01,-0.01,0.03,-0.03);\nfloat[] offset2 = float[](0.0,0.05,-0.05,0.07,-0.07);\nfloat[] offset3 = float[](0.06,0.04,0.04,0.03,0.03);\nfloat[] kt = float[](3.3,2.4,2.0,3.5,4.2);\n\nfloat hair(vec2 p,vec2 c,vec2 d,float r,mat2 rot,int k)\n{\n    float t1 = 1.0;\n    \n    \n    for(int i = 0;i < 5;i ++)\n    {\n        if(i >= k) break;\n        vec2 o1 = rot * vec2(offset1[i],r) + c;\n    \tvec2 o2 = rot * vec2(offset2[i],r + offset3[i]) + c;\n    \n    \tt1 *= line(p,o1,o2,0.005,kt[i]);\n    }\n    \n    return t1;\n}\n\nfloat smileface(vec2 p,vec2 c,vec2 d,float r,float t,float size,float k)\n{\n    float oldt = clamp(t,-3.1415 / 2.0,3.1415 / 2.0);\n    float h = -0.07;\n    float ml = 0.01;\n    float t2 = oldt * 2.0;\n    float cs = cos(t2);\n    float ss = sin(t2);\n    mat2 rot = mat2(cs,-ss,ss,cs);\n\n    vec2 reye = rot * vec2(r * 0.5,0.0) + c;\n    vec2 leye = rot * vec2(-r * 0.5,0.0) + c;\n\n    vec2 rmo = rot * vec2(-r * 0.5,h) + c;\n    vec2 lmo = rot * vec2(r * 0.5,h) + c;\n\n    return hair(p,c,d,r,rot,int(mod(k,6.0)*2.0 - 1.0)) * line(p,rmo,lmo,ml,k) * smoothstep(0.0,r*size,length(reye - p)) * smoothstep(0.0,r*size,length(leye - p));\n}\n\n\nfloat body(vec2 p,vec2 c,vec2 d,float fb,float h,float r,float size)\n{\n    return smoothstep(r - 4./iResolution.y,r + size,(fb >= 0.0 ? min(length(p - c),length(p - d)) : h));\n}\n    \nmat2 rot2(float r)\n{\n    float s = sin(r),c = cos(r);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ncd = fragCoord / iResolution.y;\n    \n    vec2 inc = floor(ncd * 4.0);\n    \n    vec2 nc = fract(ncd * 4.0);\n    \n    float r = 0.02 + nc.y*0.1;\n    float b = 0.27;\n    vec2  a = vec2(0.5,0.1 + b);\n    float t = sin(iTime+inc.x+inc.y) * 3.1415 * (0.1 + 0.05 * inc.x);\n    \n    vec2 c,d;\n    float fb,h;\n    \n    calcAnchorInfo(nc,a,r,b,t,c,d,fb,h);\n    \n    vec3 bgcolor = mix(vec3(0.25,0.22,0.6),vec3(0.0,0.82,0.6),(sin(ncd.x*ncd.y+iTime) * 0.5 + 0.5));\n   \n    vec3 outline = mix(vec3(0.0),bgcolor,body(nc,c,d,fb,h,r,0.03));\n    \n    vec3 color = mix(vec3((inc.x + 1.5) / 4.0,(inc.y + 1.5) / 4.0,0.0),outline,body(nc,c,d,fb,h,r,0.0));\n    \n    color = mix(vec3(0.),color,smileface(nc,c,d,r,t,0.3,mod(inc.x+inc.y,5.0)));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3GRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 51, 51, 579], [581, 581, 688, 688, 1499], [1706, 1706, 1763, 1763, 2032], [2034, 2034, 2108, 2108, 2658], [2661, 2661, 2731, 2731, 2838], [2844, 2844, 2864, 2864, 2926], [2928, 2928, 2985, 2985, 3756]], "test": "error"}
{"id": "Wt3GW4", "name": "grid noises", "author": "aodnawg", "description": "noise", "tags": ["noise"], "likes": 4, "viewed": 138, "published": "Public", "date": "1576250761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat N11(float i) {\n\treturn fract(sin(i + 93741.369) * 31934.123);\n}\n\nfloat N21(vec2 i) {\n\treturn N11(N11(i.x) + i.y);\n}\n\nfloat smoothNoise(vec2 uv, float z) {\n    vec2 id = floor(uv * z);\n    vec2 gv = fract(uv * z);\n\n    float tl = N21(id);\n    float tr = N21(id + vec2(1., 0.));\n    float bl = N21(id + vec2(0., 1.));\n    float br = N21(id + vec2(1., 1.));\n\n    float t = mix(tl, tr, smoothstep(0., 1., gv.x));\n    float b = mix(bl, br, smoothstep(0., 1., gv.x));\n    return  mix(t, b, smoothstep(0., 1., gv.y));\n}\n\nfloat graph(vec2 uv, float n) {\n    float t = iTime * .01;\n    uv -= vec2(.5);\n    float a = atan(uv.y, uv.x) / PI * .5 + .5;\n    float r = distance(uv, vec2(0.));\n    float noise = smoothNoise(vec2(a, r + t) + vec2(N11(n), N11(N11(n))), 10.) * 10. * PI;\n    return smoothstep(.9, .8, sin(r * 128. + noise + n) *.5 + .5);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.5;\n\n    // Time varying pixel color\n\tvec3 col = vec3(uv.rg, 0.);\n    float m = 0.;\n    \n    float z = 2.;\n    vec2 id = floor(uv * z);\n    vec2 gv = fract(uv * z);\n  \n    m = graph(gv, N21(id));\n    if (gv.x >= 0.98 || gv.y >=.98) m = 0.;\n   \n    \n    // m = smoothNoise(uv, z);\n    \n\tcol = vec3(m);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3GW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 95], [97, 97, 116, 116, 147], [149, 149, 186, 186, 544], [546, 546, 577, 577, 870], [872, 872, 929, 979, 1442]], "test": "ok"}
{"id": "wt3GWH", "name": "snow_1212", "author": "aodnawg", "description": "snow", "tags": ["snow"], "likes": 7, "viewed": 249, "published": "Public", "date": "1576154764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat ball(vec2 p) {\n    float size = .05;\n    float d = distance(vec2(.5), p);\n\treturn smoothstep(size,size - .05, d);\n}\n\n\nfloat N11(float n) {\n\treturn fract(sin(n * 871.213) * 3134.422);\n}\n\nfloat N21(vec2 uv) {\n\treturn N11(N11(uv.x) + uv.y);\n}\n\nfloat snow(vec2 uv, float t) {\n    vec2 org_uv = vec2(uv.x, uv.y);\n    float z = 10.;\n    uv.y += t * .5;\n    vec2 gv = fract(uv*z);\n    vec2 id = floor(uv*z); \n\tgv.x += (sin(N21(id) * 128. + t) * .4);\n    gv.y += (sin(N11(N21(id)) * 128. + t) * .4);\n    // float size = graph(org_uv);\n    float dots = ball(gv);\n    return dots;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    float t = iTime * .3;\n    \n    vec2 gh_uv = uv;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float m = 0.;\n    \n    for(float i =0.; i <= 1.; i += 1. / 32.) {\n        float z = mix(1., .5 , i);\n        vec2 offset = vec2(N11(i), N11(N11(i)));\n    \tm += snow((uv + offset) * z, t) * .3;\n    }\n    \n    \n    col = vec3(m);\n    col += vec3(.85, .90, 1.) *.8 * mix(.5, 1., uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3GWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 147], [150, 150, 170, 170, 216], [218, 218, 238, 238, 271], [273, 273, 303, 303, 604], [606, 606, 663, 713, 1257]], "test": "ok"}
{"id": "Wt3GWS", "name": "PolarRainbow", "author": "cRocANSTRaphAYOu", "description": "This is a clean polar coordinate system template.", "tags": ["polarcoordinates", "polar"], "likes": 3, "viewed": 125, "published": "Public", "date": "1577351568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------------------------------------------------\n    // Center cardinal coordinate system with square resolution:\n    vec2 uv =  ( fragCoord -0.5 * iResolution.xy )/ iResolution.y;\n    \n    //-------------------------------\n    // Set up polar coordinate system:\n    float r = length(uv)*2.0; // *2 so top/bottom of screen is +-1, not +-1/2\n    float t = atan(uv.y,uv.x);\n    vec2 polar = vec2(r,t);\n\n    //-------------------------\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+polar.xyx+vec3(0,2,4));\n\n    //-----------------\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3GWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 179, 671]], "test": "ok"}
{"id": "wt3GzS", "name": "const-density triangle sampling", "author": "FabriceNeyret2", "description": "Sample a triangle uniformly with no rejected random point, with const density ( i.e. prop to area ).\nIllustrating tech Report [url]https://eheitzresearch.wordpress.com/749-2/[/url]\nAlternate white vs blue boise, dots vs splats.   Mouse control top vertex.", "tags": ["sampling", "bluenoise"], "likes": 13, "viewed": 327, "published": "Public API", "date": "1576680631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// implementing a subset of \"A Low-Distortion Map Between Triangle and Square\"\n// techreport: https://eheitzresearch.wordpress.com/749-2/\n\n#define D 2000.                               // density\n#define HUE 0                                 // 1: display Voronoi / colored splats\n\n#define hash2(i)  fract(sin( i * vec2(12.9898, 78.233) ) * 43758.5453)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = 1.*iTime;           \n    bool  blue  = fract(t/12.) > .5 ,         // sample white vs blue noise\n          splat = fract(t/12.+.25) > .5;      // display dots vs splats\n\n    vec2  R = iResolution.xy,\n          m = iMouse.xy,\n          U = ( 2.* u - R ) / R.y, P,\n         P0 = vec2(-1), P0U = P0-U,           // triangle 3 vertices\n         P1 = vec2(.5,0) +.5*cos(t+vec2(0,11)), \n         P2 = length(m)<20. ? vec2(0,.5) : (2.*m-R)/R.y;\n    \n    mat2  M = mat2( P1-P0, P2-P0 );           // triangle frame\n    float s = abs(determinant(M))/2.,         // triangle area\n          d = 1e5, v,k, N = D*s, l = sqrt(N);\n    \n    for( float i = 1.; i <= N; i++) {\n        P = hash2(i);                         // uniform hash on canonical square\n        if (blue) P = vec2(fract(i/l),i/N) + (P-.5)/l; // blue noise case\n        if (P.y > P.x) P.y -= P.x *= .5;      // square-triangle iso-mapping\n        else           P.x -= P.y *= .5;\n      //int c = int(P.y > P.x); P[c] -= P[1-c] *= .5; // more expensive\n      //if (P.x+P.y > 1.) P = 1.-P;           // simpler but not bijective (required for bluenoise or stratified)\n\n      //P = P0 + P.x*(P1-P0) + P.y*(P2-P0);   // barycentric coordinates\n      //d = min(d, dot(P-U,P-U) );            // get sample closest to cur pixel\n      //                                      Optimized version:\n        P = P0U + M*P;                        // barycentric coordinates\n#if !HUE\n        if (!splat) d = min(d, dot(P,P) );    // get sample closest to cur pixel\n        else    O += max( 0., 1. -.3*sqrt(D)*length(P) ) / 16.; // splats\n#else\n        if (!splat) { v = dot(P,P); if (v<d) d=v,k=i; }         // closest id (for Voronoi)\n        else    O += max( 0., 1. -.3*sqrt(D)*length(P) ) / 16.  // splats (colored)\n                    *hue(i*331.7)*1.5; \n#endif\n    }\n    \n    if (!splat) O += smoothstep(3./R.y,0.,sqrt(d)-.002); // draw dot\n#if HUE\n    if (!splat && d<2./D) O = hue(hash2(k+.5).x);        // draw Voronoi\n#else\n    O = pow(O, vec4(1./2.2));                            // to sRGB\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3GzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 419, 457, 457, 2520]], "test": "ok"}
{"id": "Wtc3D8", "name": "Abstract Squircles", "author": "piyushslayer", "description": "Just doodling around and experimenting with some overlapping uv grid patterns and alpha blending.\n\nupdate v 1.1 - improved the color contrast a bit and improved blending with the background color.", "tags": ["2d", "circle", "abstract", "square", "pattern"], "likes": 19, "viewed": 520, "published": "Public API", "date": "1576116501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define SCALE 12.\n#define PURPLE (vec3(92., 25., 226.)/255.)\n\nconst vec3[3] colors = vec3[](\n\t\t\t\t\t\tvec3(92., 197., 187.)/255., // cyan\n    \t\t\t\t\tvec3(240., 221., 55.)/255., // yellow\n    \t\t\t\t\tvec3(253., 87., 59.)/255.); // red\n    \n// Hash by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n// Distance function by iq\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n    // first set of grid uv\n    vec2 auv = uv * SCALE;\n    vec2 _auv = fract(auv);\n    // second set of grid uv offset by first grid uv center\n    vec2 buv = uv * SCALE - .5;\n    vec2 _buv = fract(buv);\n    // time factor\n    float t = iTime;\n\n    vec3 col = vec3(0.);\n    \n    // random color index for each cell in the grid\n    float ah = hash12(floor(auv + 647.));\n    // rounded box for first grid uv\n    float abox = smoothstep(.1, .05, sdBox(_auv - .5, vec2(.305)) - .12)\n\t\t* (.75 + .25 * sin(t + 588. * ah)) * 1.1 + .1;\n    // box color oscillating between light and dark\n    vec3 aboxCol = colors[int(3. * hash12(floor(auv) + 378. + t * .4))];\n    // random number for each second grid cell\n    float bh = hash12(floor(buv + 879.));\n    // rounded box for the second offset grid\n    float bbox = smoothstep(.1, .05, sdBox(_buv - .5, vec2(.305)) - .12)\n        * (.75 + .25 * sin(t + 261. * bh)) * 1.1 + .1;\n    // oscillate the color, but give it a darker shade than the first grid,\n    // which in turn offsets the color in the first grid\n    vec3 bboxCol = colors[int(3. * hash12(floor(buv) + 117. - t * .8))];\n    \n    // mix grid box colors based on their respective alpha\n    col = mix(col, vec3(abox) * aboxCol, abox);\n    col = mix(col, vec3(bbox) * bboxCol, .5 * bbox);\n    col = mix(col * 1.25, PURPLE, 1. - (abox + bbox) * .5); // purple bg\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtc3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 412, 434, 434, 523], [525, 552, 589, 589, 673], [675, 675, 732, 782, 2217]], "test": "ok"}
{"id": "Wtc3DM", "name": "Marble Material", "author": "bluebean", "description": "ç¨åºæ§çå¤§çç³æè´¨ï¼çèµ·æ¥æ´åæ¼åæ¿", "tags": ["marble", "fractalnoise"], "likes": 2, "viewed": 85, "published": "Public", "date": "1576576570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//æ ¹æ®må¨colors[1]å°colors[n-1]ä¹é´è¿è¡æ ·æ¡çº¿æå¼\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float m = marble(pos*2.0);\n        m = 0.5*m;\n        col = marbleColor(m);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtc3DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 519, 541, 541, 636], [638, 638, 666, 666, 1167], [1169, 1169, 1190, 1190, 1339], [1341, 1404, 1430, 1430, 2487], [2489, 2489, 2514, 2514, 2529], [2531, 2531, 2566, 2566, 2592], [2594, 2594, 2625, 2625, 2716], [2718, 2718, 2748, 2748, 2781], [2783, 2783, 2808, 2808, 2982], [2984, 2984, 3024, 3024, 3361], [3363, 3363, 3400, 3400, 3735], [3737, 3737, 3795, 3795, 3969], [3971, 3971, 4028, 4028, 4912]], "test": "ok"}
{"id": "Wtc3R2", "name": "[twitch] Train strike", "author": "NuSan", "description": "Shader coded live on Recondustream twitch (https://www.twitch.tv/recondustream)\nThis twitch channel is a caritative initiative to support the current french strike.\nOriginal shader (Bonzomatic) is here: http://lezanu.fr/LiveCode/Recondustream_Nusan.glsl", "tags": ["3d", "raymarching", "twitch"], "likes": 7, "viewed": 155, "published": "Public", "date": "1576812594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\nShader coded live on Recondustream twitch (https://www.twitch.tv/recondustream)\nThis twitch channel is a caritative initiative to support the current french strike.\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/Recondustream_Nusan.glsl\nThis version is tweaked to better fit to avalaible textures on shadertoy\n*/\n    \nfloat time=0.0;\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define rep(v,s) (fract((v)/s-0.5)-0.5)*s\n\nfloat box(vec2 p, vec2 s) {\n  p=abs(p)-s;\n  return length(max(vec2(0),p)) + min(0.0,max(p.x, p.y));\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return length(max(vec3(0),p)) + min(0.0,max(p.x, max(p.y,p.z)));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat prog=0.0;\nfloat voiture(vec3 p) {\n  \n  vec3 p2=p;\n  vec3 p3=p;\n  \n  float d = box(p, vec3(1.5,2.5,4));\n  \n  p.y += 2.5;\n  d = min(d, max(cyl(p.xy, 1.5), abs(p.z)-4.0));\n  \n  p.y = abs(p.y-1.5)-1.5;\n  d = min(d, box(p, vec3(1.6,0.1,4.1)));\n  \n  p2.x = abs(p.x)-1.6;\n  p2.z = rep(p.z, 1.6);\n  p2.y += 1.4;\n  d = max(d, -box(p2, vec3(0.2,0.7,0.7)));\n  \n  p3.z = abs(p3.z)-4.0;\n  p3.y += 1.0;\n  d = max(d, -box(p3, vec3(0.6,1.2,0.2)));\n  \n  \n  return d;\n}\n\nfloat roues(vec3 p) {\n  \n\n  p.y -= 3.0;\n  p.x = abs(p.x)-1.8;\n  p.z = min(3.0+p.z,max(p.z-3.0,rep(p.z, 1.5)));\n  float d = abs(cyl(p.yz, 0.65))-0.1;\n  d = max(d, abs(p.x)-0.2);\n  \n  p.yz *= rot(time * 4.0);\n  \n  p.y=abs(p.y);\n  p.z=-abs(p.z);\n  p.yz *= rot(0.7);\n  p.y=abs(p.y);\n  p.z=-abs(p.z);\n  p.yz *= rot(0.4);\n  d = min(d, box(p, vec3(0.05,0.05,0.7)));\n\n  \n  return d;\n}\n\nfloat rails(vec3 p) {\n  \n  p.y += 0.2;\n  p.x=abs(p.x)-1.6;\n  float d=box(p.xy, vec2(0.1,0.2));\n  \n  p.z = rep(p.z, 1.5);\n  d=min(d, box(p, vec3(2.0,0.1, 0.3)));\n  \n  return d;\n}\n\nvec3 chemin(vec3 p) {\n  vec3 off=vec3(0);\n  off.x += sin(p.z * 0.04)*10.0;\n  off.x += sin(p.z * 0.023)*22.0;\n  off.y += sin(p.z * 0.03)*10.0;\n  return off;\n}\n\n// distance fonction\nfloat voit = 0.0;\nfloat sol=0.0;\nfloat wat=0.0;\nfloat map(vec3 p) {\n  \n  vec3 p3=p;\n  \n  p += chemin(p);\n  \n  float h = texture(iChannel0, p.xz * 0.001).x;\n  h *= 7.0 * clamp(abs(p.x)/20.0,0.0,1.0);\n  \n  vec3 p2 = p;\n  \n  p.y += 4.2;\n  float tt=time*0.5;\n  float t2 = fract(tt);\n  t2 = smoothstep(0.0,1.0,t2);\n  t2 = smoothstep(0.0,1.0,t2);\n  t2 = pow(t2, 10.0);\n  p.z += (floor(tt) + t2) * 30.0 + time*3.0; \n  prog = p.z;\n  p.z = rep(p.z, 9.5);\n  \n  \n  \n  \n  voit=voiture(p);\n  float d = voit;\n  \n  d=min(d, roues(p));\n  \n  d=min(d, rails(p2));\n  \n  sol=(-p2.y - h + 0.7)*0.7;\n  d=min(d, sol);\n  \n  wat=-p3.y+5.0;\n  d=min(d, wat);\n  \n  return d;\n}\n\nvec3 camera(vec2 uv, vec3 s, vec3 t, float fov) {\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(0,1,0)));\n  vec3 cy=normalize(cross(cx, cz));\n  \n  return normalize(uv.x*cx - uv.y*cy + fov*cz);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off = vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat shadow(vec3 p, vec3 r) {\n  float shad=1.0;\n  for(int i=0; i<30; ++i) {\n    float d=map(p);\n    shad=min(shad, d*10.0);\n    p+=d*r;\n  }\n  return clamp(shad,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  time=mod(iTime,300.0);\n  \n  // camera position\n  vec3 s=vec3(0,0,-30);\n  s.yz *= rot(0.5);\n  s.xz *= rot(0.7+time*0.2);\n  \n  // camera target\n  vec3 t=vec3(0,-7,10);\n  t.xz *= rot(time*0.3);\n  \n  s.z += time * 8.0;\n  t.z += time * 8.0;\n  \n  s -= chemin(s);\n  t -= chemin(t);\n  \n  //float fov = 0.5 + pow(smoothstep(-1.0,1.0,sin(time*10.0)),10.0)*0.2;\n  float fov = 0.7;\n  vec3 r = camera(uv, s, t, fov);\n    \n  vec3 p=s;\n  float at=0.0;\n  float dd=0.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p) * 0.7;\n    if(d<0.001) {\n      if(wat>0.01) {\n        break;\n      }\n      d = 0.1;\n      r.y = -r.y;\n      r.x += (texture(iChannel0, p.xz*0.008 + time*0.03).x-0.4)*0.5;\n      r=normalize(r);\n    }\n    if(dd>200.0) {\n      break;\n    }\n    \n    p+=r*d;\n    dd+=d;\n    at += 0.1/(0.1+abs(d));\n  }\n    \n  float issol=step(sol,0.01);\n  float isvoit=step(voit,0.01);\n  float iswat=step(wat,0.01);\n  float pp=floor(prog/9.5-0.5);\n  vec3 n=norm(p);\n  \n  float fog = 1.0-clamp(dd/200.0,0.0,1.0);\n  \n  vec3 col=vec3(0);\n    \n  //col += at * 0.03 * vec3(1,0.5,0.3);\n  \n  vec3 l=normalize(-vec3(1,2,3));\n  \n  float shad=shadow(p + n * 0.2, l);\n  \n  float ao = clamp(map(p+n*0.2)/0.2,0.0,1.0) * (clamp(map(p+n*2.0)/2.0,0.0,1.0)*0.5+0.5);\n  \n  vec3 diff=vec3(0.7);\n  diff=mix(diff, vec3(0.5,1.0,0.5), issol);\n  vec3 cc=vec3(1,0.5,0.2);\n  float g=floor(pp);\n  cc.xy *= rot(g);\n  cc.xz *= rot(g*0.7);\n  cc=abs(cc);\n  diff=mix(diff, cc, isvoit);\n  col += max(0.0, dot(n,l)) * diff * shad * ao;\n  \n  vec3 sky = mix(vec3(0.5,0.6,1)*0.8, vec3(1.0,0.5,0.2)*10.0 , pow(max(0.0,dot(l,r)), 3.0));\n  col += (-n.y*0.5+0.5) * diff * 1.2 * ao;\n  \n  col *= fog;\n  \n  col += pow(1.0-fog,3.0) * 1.1 * sky;\n      \n  col *= 1.2-length(uv);\n  \n  col = smoothstep(0.0,1.0,col*1.2);\n  col = pow(col, vec3(0.4545));\n\n  col *= 1.0;\n  fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtc3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 515, 515, 589], [591, 591, 618, 618, 701], [703, 703, 731, 731, 755], [757, 757, 785, 785, 809], [827, 827, 850, 850, 1268], [1270, 1270, 1291, 1291, 1646], [1648, 1648, 1669, 1669, 1825], [1827, 1827, 1848, 1848, 1984], [2055, 2055, 2074, 2074, 2655], [2657, 2657, 2706, 2706, 2869], [2871, 2871, 2890, 2890, 3002], [3004, 3004, 3034, 3034, 3176], [3179, 3179, 3236, 3236, 5208]], "test": "error"}
{"id": "Wtc3Rf", "name": "Planet Reboot 2", "author": "dr2", "description": "After the apocalypse, next stage ... (mouseable)", "tags": ["water", "life", "tube", "symmetry", "kinematics", "flexible"], "likes": 14, "viewed": 318, "published": "Public API", "date": "1577010456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Planet Reboot 2\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nvec2 gId, slcLim;\nfloat dstFar, tCur, tLoc, rBase, rTube, sLoopV[2], rLoop, nArm, armUp, armId,\n   hgSize, bbHt, bbRad, bRot, szFac, hVal;\nint idObj;\nconst int idArm = 1, idArmE = 2, idCylL = 3, idCylU = 4, idBub = 5;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvoid SetObjConf ()\n{\n  float tCyc;\n  hVal = Hashfv2 (37. * gId + 11.11);\n  tCyc = 6. + 4. * hVal;\n  bRot = 2. * pi * hVal;\n  tLoc = tCur + tCyc * hVal;\n  nArm = 5. + floor (4. * hVal);\n  szFac = (6. + 4. * hVal) / 10.;\n  armUp = floor (mod (tLoc / tCyc, nArm));\n  sLoopV[0] = 0.35 + 20. * pow (1. - SmoothBump (0.25, 0.75, 0.22, mod (tLoc / tCyc, 1.)), 8.);\n  sLoopV[1] = 0.35 + 20.;\n  slcLim = - sin (pi / nArm + vec2 (0.5 * pi, 0.));\n  bbHt = 1. + mod (3. * tCur + 0.5 * hVal * dstFar, 0.5 * dstFar);\n  bbRad = 0.03 * (1. + hVal);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 arcLim;\n  float dMin, d, db, s, r, aLoop, dLoop;\n  dMin = dstFar;\n  if (hVal > 0.03) {\n    dMin /= szFac;\n    p.xz -= HexToPix (gId * hgSize);\n    p /= szFac;\n    p.y -= rTube + 0.15;\n    p.xz = Rot2D (p.xz, bRot);\n    q = p;\n    q.xz = Rot2D (q.xz, (2. * pi / nArm) * armUp);\n    db = dot (vec2 (abs (q.z), - q.x), slcLim);\n    dLoop = rLoop * sLoopV[0];\n    aLoop = 0.25 * pi / sLoopV[0];\n    arcLim = sin (0.25 * pi / sLoopV[0] + vec2 (0., 0.5 * pi));\n    q = p;\n    q.xz = Rot2D (q.xz, (2. * pi / nArm) * armUp);\n    q.xy = Rot2D (vec2 (rBase - q.x, q.y - dLoop), aLoop - 0.5 * pi);\n    s = mod ((32. / aLoop) * atan (q.y, - q.x) / pi + 0.5 - 2. * tLoc, 1.);\n    r = length (vec2 (length (q.xy) - dLoop, q.z)) - rTube;\n    d = max (r - 0.03 * SmoothBump (0.25, 0.75, 0.15, s), - r - 0.15);\n    d = max (d, dot (vec2 (q.x, abs (q.y)), arcLim));\n    if (d < dMin) armId = armUp;\n    DMIN (idArm);\n    q.xy = Rot2D (q.xy, aLoop) - vec2 (- dLoop, 0.27);\n    d = max (PrRoundCylDf (q.xzy, rTube + 0.03, 0.1, 0.3), rTube - 0.15 - length (q.xz));\n    if (d < dMin) armId = armUp;\n    DMIN (idArmE);\n    dLoop = rLoop * sLoopV[1];\n    aLoop = 0.25 * pi / sLoopV[1];\n    arcLim = sin (0.25 * pi / sLoopV[1] + vec2 (0., 0.5 * pi));\n    q = p;\n    if (mod (nArm, 2.) != 0.) q.xz = Rot2D (q.xz, pi / nArm);\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (nArm * atan (q.z, - q.x) / (2. * pi) + 0.5) / nArm));\n    q.xy = Rot2D (vec2 (rBase + q.x, q.y - dLoop), aLoop - 0.5 * pi);\n    s = mod ((32. / aLoop) * atan (q.y, - q.x) / pi + 0.5 + 0.5 * tLoc, 1.);\n    r = length (vec2 (length (q.xy) - dLoop, q.z)) - rTube;\n    d = max (r - 0.03 * SmoothBump (0.25, 0.75, 0.15, s), - r - 0.15);\n    d = max (max (d, dot (vec2 (q.x, abs (q.y)), arcLim)), db);\n    if (d < dMin) armId = -1.;\n    DMIN (idArm);\n    q.xy = Rot2D (q.xy, aLoop) - vec2 (- dLoop, 0.27);\n    d = max (max (PrRoundCylDf (q.xzy, rTube + 0.03, 0.1, 0.3),\n       rTube - 0.15 - length (q.xz)), db);\n    if (d < dMin) armId = -1.;\n    DMIN (idArmE);\n    q = p;\n    d = PrRoundCylDf (q.xzy, rBase + 0.05, 0.15, rTube + 0.1);\n    DMIN (idCylL);\n    q = p;\n    q.y -= 3. * rTube;\n    d = SmoothMin (d, PrRoundCylDf (q.xzy, (0.7 - 0.2 * (q.y / (3. * rTube))) * rBase,\n       0.1, 3. * rTube), 0.1);\n    DMIN (idCylU);\n    q = p;\n    q.y -= bbHt;\n    d = PrSphDf (q, bbRad);\n    DMIN (idBub);\n    dMin *= 0.8 * szFac;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.03;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 2. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.1, 0.7, 0.6), vec3 (0.3, 0.5, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.1 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 p, col, c, bgCol, vn;\n  float dstObj, s, sh;\n  bool isBg, isLit;\n  rTube = 0.3;\n  rBase = 1.8;\n  rLoop = 5.;\n  dstObj = ObjRay (ro, rd);\n  isBg = false;\n  isLit = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    p = ro;\n    gId = PixToHex (p.xz / hgSize);\n    SetObjConf ();\n    p.xz -= HexToPix (gId * hgSize);\n    c = HsvToRgb (vec3 (mod (37.3 * hVal, 1.), 0.2, 1.));\n    if (idObj == idArm) {\n      col4 = vec4 (0.9, 0.9, 1., 0.);\n    } else if (idObj == idArmE) {\n      if (armId == armUp) col4 = vec4 (0.7 + 0.3 * sin (5. * tLoc), 0., 0., -1.);\n      else col4 = vec4 (c, 0.);\n    } else if (idObj == idCylL) {\n      col4 = vec4 (0.8 * c, 0.);\n    } else if (idObj == idCylU) {\n      col4 = vec4 (c, 0.);\n      s = length (p.xz) - rTube - 0.2;\n      if (s < 0.) {\n        if (s < -0.1) col4 = vec4 (vec3 (0.6 + 0.4 * sin (5. * tLoc), 0., 0.), -1.);\n        else col4.rgb *= 0.7;\n      }\n    } else if (idObj == idBub) {\n      col4 = vec4 (mix (vec3 (1.2), BgCol (reflect (rd, vn)), 0.5), -1.);\n    }\n    if (col4.a >= 0.) isLit = true;\n  } else if (rd.y < 0. && (- ro.y / rd.y) < dstFar) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    col4 = mix (vec4 (0.3, 0.4, 0.3, 0.), vec4 (0.2, 0.3, 0.3, 0.),\n       0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (4. * ro.xz))) * (1. +\n       0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n    vn4 = RippleNorm (0.1 * ro.xz, vec3 (0., 1., 0.), 6.);\n    vn = VaryNf (2. * ro, vn4.xyz, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n    col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n    isLit = true;\n  } else isBg = true;\n  bgCol = BgCol (rd);\n  if (isBg) {\n    col = bgCol;\n  } else {\n    if (isLit) {\n      sh = min (ObjSShadow (ro, ltDir), 1. - 0.2 * smoothstep (0.4, 0.6,\n         Fbm2 (0.1 * ro.xz + 0.2 * tCur)));\n      col = col4.rgb * (0.3 * bgCol + 0.7 * sh * max (dot (vn, ltDir), 0.));\n    } else {\n      col = col4.rgb * (0.3 + 0.7 * max (- dot (vn, rd), 0.));\n    }\n    col = mix (col, bgCol, smoothstep (0.3, 1., dstObj / dstFar));\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (1.1, 1.1, 0.9));\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  hgSize = 12.;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az += 0.4 * pi * (2. * mod (floor (0.015 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.015 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.017 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 20., 5. + 1.5 * tCur);\n  zmFac = 3.;\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtc3Rf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[895, 895, 915, 915, 1429], [1431, 1431, 1453, 1453, 3852], [3854, 3854, 3887, 3887, 4988], [4990, 4990, 5011, 5011, 5208], [5210, 5210, 5247, 5247, 5671], [5673, 5673, 5698, 5698, 6077], [6079, 6079, 6123, 6123, 6317], [6319, 6319, 6341, 6341, 6760], [6762, 6762, 6797, 6797, 8950], [8994, 8994, 9050, 9050, 10205], [10207, 10207, 10240, 10240, 10267], [10269, 10269, 10326, 10326, 10490], [10492, 10492, 10516, 10516, 10746], [10748, 10748, 10772, 10772, 10832], [10834, 10834, 10858, 10858, 10975], [10977, 10977, 11013, 11013, 11219], [11221, 11221, 11243, 11243, 11281], [11283, 11283, 11328, 11328, 11431], [11433, 11433, 11490, 11490, 11573], [11575, 11575, 11605, 11605, 11718], [11752, 11752, 11776, 11776, 11836], [11838, 11838, 11862, 11862, 11992], [11994, 11994, 12019, 12019, 12205], [12207, 12207, 12228, 12228, 12383], [12385, 12385, 12414, 12414, 12626], [12628, 12628, 12667, 12667, 12852]], "test": "error"}
{"id": "wtc3Wj", "name": "Ecosphere", "author": "psandahl", "description": "My first serious attempt in making a shader demo. Enjoy the Ecosphere!", "tags": ["procedural", "raymarching", "distancefields", "planet"], "likes": 5, "viewed": 154, "published": "Public", "date": "1577786831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ecosphere - the procedural creation of a planet like sphere.\n//\n// Patrik Sandahl, 2019 - patrik.sandahl@gmail.com\n//\n// 3D noise algorithm by Ian McEwan, Ashima Arts.\n\n#define EPSILON 0.001\n#define DEFAULT_ZOOM 1.0\n\n#define PI 3.141592653589\n\n#define MAX_OCTAVES 9.0\n\n// Material for nothing. I.e. the empty space.\n#define MAT_NOTHING 0\n\n// Material for the colored sphere.\n#define MAT_COLOR_SPHERE 1\n\n// Material for the sea water.\n#define MAT_WATER_SPHERE 2\n\n// World seed - skew the input for the noise.\n#define WORLD_SEED 47.159\n\n// Initial scene - base sphere goes from dark to light and\n// gradually morphs into the naked ecosphere.\n#define SCENE0 0\n\n// Second scene - the colored ecosphere.\n#define SCENE1 1\n\n// Third scene - sea level rises.\n#define SCENE2 2\n\n// Forth scene - one day and night cycle.\n#define SCENE3 3\n\n// A ray object with origin and direction.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Force normalization of direction when creating a ray.\nRay ray(vec3 origin, vec3 direction);\n\n// Calculate a point at distance d along the ray.\nvec3 point(Ray r, float d);\n\n// Generate a primary camera ray given:\n// eye - the camera position.\n// at - the position where the camera is looking.\n// up - the world up position.\n// focalLength - the zoom value for the camera. A greater value zoom in.\n// uv - the uv coordinate for which the ray is produced. It is assumed\n// that uv zero is in the middle of the projection.\n// The camera is assuming an OpenGL like coordinate system.\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv);\n\n// An intersection object with distance along the ray, an displacement\n// offset for the object and the material id for the object.\nstruct Intersection {\n    float dist;\n    float offset;\n    int material;\n};\n\n// Produce the closest intersection from the scene given the position.\nIntersection intersectScene(int sceneId, vec3 pos);\n\n// March the ray for an intersection with the scene.\nIntersection march(int sceneId, Ray r, float far);\n    \n// Calculate a normal through central difference. It's very expensive\n// though. Consider a noise function with analytical derivatives as\n// future improvement.\nvec3 calcNormal(int sceneId, vec3 pos);\n\n// Calculate a 2D rotations matrix.\nmat2 calcRotate2d(float theta);\n\n// Distance function for the base sphere.\nfloat baseSphere(vec3 pos);\n\n// Distance function for a shere. The position - relative origin - and\n// the radius for the sphere.\nfloat sphere(vec3 pos, float radius);\n\n// Get the sun's position.\nvec3 sunPosition(int sceneId);\n\n// Normalize the height offset from ~[-1 : 1] to ~[0 : 1].\nfloat normalizeOffset(float offset);\n\n// Get the terrain color the given height offset.\nvec3 terrainColor(float offset);\n\n// Estimate the needed number of octaves from screen with.\nint estimateOctaves(float width);\n\n// Noise functions.\nfloat fbm(vec3 pos, int numOctaves);\nfloat snoise(vec3 v);\n\n// Entry point for generating the image.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinate where origo is in the\n    // middle and compensation is made for aspect ratio.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Make a primary ray for the uv position.\n    vec3 eye = vec3(0.0, 0.0, 25.0);\n    vec3 at = vec3(0.0);\n    vec3 up = normalize(vec3(0.5, 1.0, 0.0)); // Tilt the view a little.\n    \n    Ray primaryRay = cameraRay(eye, at, up, DEFAULT_ZOOM, uv);\n            \n    // Determine scene id from time.   \n    int sceneId = SCENE0;\n    if (iTime >= 24.0) {\n      \tsceneId = SCENE3;\n    } else if (iTime >= 16.0) {\n        sceneId = SCENE2;\n    } else if (iTime >= 12.0) {\n        sceneId = SCENE1;\n    }\n    \n    // Perform the ray marching, keep the far plane near ;-)\n    Intersection intersection = march(sceneId, primaryRay, 45.0);\n    \n    // Create a default color for the current pixel.\n    vec3 color = vec3(0.0);\n    \n    switch (intersection.material) {\n        // A sphere colored using its height offset.\n        case MAT_COLOR_SPHERE:\n        {\n         \tvec3 pos = point(primaryRay, intersection.dist);\n    \t\tvec3 lightDirection = normalize(sunPosition(sceneId) - pos);\n    \t\tvec3 normal = calcNormal(sceneId, pos);                \n    \t\tfloat light = max(0.0, dot(normal, lightDirection));            \n                            \n            vec3 graySphere = vec3(normalizeOffset(intersection.offset));\n            vec3 colorSphere = terrainColor(intersection.offset);\n            color = mix(graySphere, colorSphere, smoothstep(12.0, 16.0, iTime));\n                \n        \tcolor = color * light;\n        }\n       \tbreak;\n        \n        // A sphere with ocean color.\n        case MAT_WATER_SPHERE:\n        {\n            vec3 pos = point(primaryRay, intersection.dist);\n    \t\tvec3 lightDirection = normalize(sunPosition(sceneId) - pos);\n    \t\tvec3 normal = calcNormal(sceneId, pos);                \n    \t\tfloat light = max(0.0, dot(normal, lightDirection));\n            \n            vec3 ocean = vec3(0.0, 67.0 / 255.0, 123.0 / 255.0);\n            color = ocean * light;\n        }\n        break;\n        \n        default:\n        \t// Just rendering the black void with default color.\n        \tbreak;\n    }\n\n    // Output to screen.\n    fragColor = vec4(color, 1.0);\n}\n\nRay ray(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 point(Ray r, float d)\n{\n    return r.origin + r.direction * d;\n}\n\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv)\n{\n    vec3 z = normalize(at - eye);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n    \n    vec3 center = eye + z * focalLength;\n    vec3 xy = center + uv.x * x + uv.y * y;\n    \n    return ray(eye, xy - eye);\n}\n\nIntersection intersectScene(int sceneId, vec3 pos)\n{\n    // The sphere shall be rotated in all scenes.\n    pos.xz = calcRotate2d(iTime * 0.05) * pos.xz;\n    \n    // And there always be a base sphere.\n    float sphereDist = baseSphere(pos - vec3(0.0));\n    \n    // There shall always be height offset.\n    float offset = fbm((pos + WORLD_SEED) * 0.13, estimateOctaves(iResolution.y));\n    \n    if (sceneId == SCENE0) {\n        \n        // Mix between the base sphere and the ecosphere.\n        float factor = smoothstep(4.0, 10.0, iTime);\n        float dist = mix(sphereDist, sphereDist - offset, factor);\n        \n        return Intersection(dist, offset, MAT_COLOR_SPHERE);      \n    }  else if (sceneId == SCENE1) {\n        \n        // Just the ecosphere.\n        return Intersection(sphereDist - offset, offset, MAT_COLOR_SPHERE);      \n    } else {\n        \n        // The ecosphere and sea.\n        float seaDist = sphere(pos - vec3(0.0), mix(9.00, 9.88, smoothstep(16.0, 24.0, iTime)));        \n        if (seaDist < sphereDist - offset) {\n            return Intersection(seaDist, 0.0, MAT_WATER_SPHERE);\n        } else {\n            return Intersection(sphereDist - offset, offset, MAT_COLOR_SPHERE);\n        }\n    }\n}\n\nIntersection march(int sceneId, Ray r, float far)\n{\n    float rayDistance = 0.0;\n    Intersection intersection = Intersection(0.0, 0.0, MAT_NOTHING);\n    \n    for (int i = 0; i < 100; ++i) {       \n        intersection = intersectScene(sceneId, point(r, rayDistance));\n        \n        rayDistance += intersection.dist;\n        if (intersection.dist < EPSILON) break;\n        if (rayDistance > far) {\n            intersection.material = MAT_NOTHING;\n            break;\n        }\n    }\n    \n    intersection.dist = rayDistance;\n    return intersection;\n}\n\nvec3 calcNormal(int sceneId, vec3 pos)\n{\n    float d = intersectScene(sceneId, pos).dist;\n    vec2 e = vec2(EPSILON, 0.0);\n    \n    vec3 n = d - vec3(\n        intersectScene(sceneId, pos - e.xyy).dist,\n        intersectScene(sceneId, pos - e.yxy).dist,\n        intersectScene(sceneId, pos - e.yyx).dist\n    );\n    \n    return normalize(n);\n}\n\nmat2 calcRotate2d(float theta)\n{\n    return mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));\n}\n\nfloat baseSphere(vec3 pos)\n{\n    return sphere(pos, 10.0);\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nvec3 sunPosition(int sceneId)\n{\n    // The base position for the sun.\n    vec3 basePosition = vec3(100.0, 0.0, 100.0);\n    \n    if (sceneId == SCENE0) {\n        // Let the sun travel one half orbit from back of sphere to base.\n        float theta = mix(-PI, 0.0, smoothstep(0.0, 10.0, iTime));\n        basePosition.xz = calcRotate2d(theta) * basePosition.xz;\n    } else if (sceneId == SCENE3) {\n        // Let the sun orbit. 20 seconds for a full circle.\n        float theta = mix(0.0, PI * 2.0, smoothstep(24.0, 34.0, iTime));\n        basePosition.xz = calcRotate2d(theta) * basePosition.xz;\n    }\n    \n    return basePosition;\n}\n\nfloat normalizeOffset(float offset)\n{\n    return offset * 0.75 + 0.5;\n}\n\nvec3 terrainColor(float offset)\n{\n    offset = normalizeOffset(offset);\n    \n    vec3 clay = vec3(127.0 / 255.0, 95.0 / 255.0, 63.0 / 255.0);\n    vec3 fern = vec3(79.0 / 255.0, 121.0 / 255.0, 66.0 / 255.0);\n    vec3 forest = vec3(11.0 / 255.0, 102.0 / 255.0, 35.0 / 255.0);\n    vec3 granite = vec3(97.0 / 255.0, 97.0 / 255.0, 97.0 / 255.0);\n    vec3 snow = vec3(1.0, 250.0 / 255.0, 250.0 / 255.0);\n    \n    vec3 color = mix(clay, fern, smoothstep(0.0, 0.4, offset));\n    color = mix(color, forest, smoothstep(0.4, 0.55, offset));\n    color = mix(color, granite, smoothstep(0.55, 0.65, offset));\n    color = mix(color, snow, smoothstep(0.65, 1.0, offset));\n    \n    return vec3(color);\n}\n\nint estimateOctaves(float height)\n{\n    // Ad hoc heuristics for the selection of octaves. Made from what's looking good.\n    if (height <= 450.0) {\n        return 7;\n    } else if (height <= 675.0) {\n        return 8;\n    } else {\n        return 9;\n    }\n}\n\nfloat fbm(vec3 pos, int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * snoise(pos);\n\t\tpos = pos * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x) {return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v)\n{ \n  \tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  \tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n  \tvec3 i = floor(v + dot(v, C.yyy) );\n  \tvec3 x0 = v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n  \tvec3 g = step(x0.yzx, x0.xyz);\n  \tvec3 l = 1.0 - g;\n  \tvec3 i1 = min( g.xyz, l.zxy );\n  \tvec3 i2 = max( g.xyz, l.zxy );\n\n  \t//  x0 = x0 - 0. + 0.0 * C \n  \tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  \tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  \tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\t// Permutations\n  \ti = mod(i, 289.0 ); \n  \tvec4 p = permute( permute( permute( \n    \t              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        \t   \t\t  + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  \tfloat n_ = 1.0/7.0; // N=7\n  \tvec3  ns = n_ * D.wyz - D.xzx;\n\n  \tvec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  \tvec4 x_ = floor(j * ns.z);\n  \tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  \tvec4 x = x_ *ns.x + ns.yyyy;\n  \tvec4 y = y_ *ns.x + ns.yyyy;\n  \tvec4 h = 1.0 - abs(x) - abs(y);\n\n  \tvec4 b0 = vec4( x.xy, y.xy );\n  \tvec4 b1 = vec4( x.zw, y.zw );\n\n  \tvec4 s0 = floor(b0)*2.0 + 1.0;\n  \tvec4 s1 = floor(b1)*2.0 + 1.0;\n  \tvec4 sh = -step(h, vec4(0.0));\n\n  \tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  \tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  \tvec3 p0 = vec3(a0.xy,h.x);\n  \tvec3 p1 = vec3(a0.zw,h.y);\n  \tvec3 p2 = vec3(a1.xy,h.z);\n  \tvec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n  \tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  \tp0 *= norm.x;\n  \tp1 *= norm.y;\n  \tp2 *= norm.z;\n  \tp3 *= norm.w;\n\n\t// Mix final noise value\n  \tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  \tm = m * m;\n  \treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                  dot(p2,x2), dot(p3,x3) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtc3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2926, 2967, 3022, 3136, 5292], [5294, 5294, 5332, 5332, 5380], [5382, 5382, 5410, 5410, 5451], [5453, 5453, 5524, 5524, 5750], [5752, 5752, 5804, 5854, 6977], [6979, 6979, 7030, 7030, 7532], [7534, 7534, 7574, 7574, 7875], [7877, 7877, 7909, 7909, 7989], [7991, 7991, 8019, 8019, 8051], [8053, 8053, 8091, 8091, 8126], [8128, 8128, 8159, 8197, 8758], [8760, 8760, 8797, 8797, 8831], [8833, 8833, 8866, 8866, 9519], [9521, 9521, 9556, 9642, 9778], [9780, 9780, 9817, 9817, 9993], [9995, 10049, 10071, 10071, 10108], [10109, 10109, 10137, 10137, 10185], [10187, 10187, 10209, 10209, 12112]], "test": "error"}
{"id": "WtcGD7", "name": "Sake shader ï¼blend colorï¼", "author": "ligaobo", "description": "å­¦ä¹ ä¸ä¸Pheemaçé¢è²èåæ¹æ³ï¼åæ¶å¯¹æºä»£ç åäºä¸äºä¿®æ¹åæ³¨é", "tags": ["blenddifferrentcolor"], "likes": 14, "viewed": 170, "published": "Public", "date": "1576485366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ref: https://www.shadertoy.com/view/XtVfzd\n\nconst float eps = 1e-3;\nconst float pi = 3.1415926535;\nconst vec3 z_up = vec3(0.0, 0.0, 1.0);\n\nfloat rand(vec2 p) { \n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat mod2(float p, float a) {\n    return p - a * floor(p / a);\n}\n\nvec2 mod2(vec2 p, vec2 a) {\n    return vec2(mod2(p.x, a.x), mod2(p.y, a.y));\n}\n\nfloat sdf_circle(vec2 p, vec2 o, float r) {\n    return length(p - o) - r;\n}\n\nfloat sdf_ring(vec2 p, float r, float lineWidth) {\n    float outer = sdf_circle(p, vec2(0, 0), r + 0.5 * lineWidth);\n    float inner = sdf_circle(p, vec2(0, 0), r - 0.5 * lineWidth);\n    \n    return max(-inner, outer);\n}\n\nfloat sdf(vec2 p) {\n    return min(sdf_ring(p, 0.75, 0.175), sdf_ring(p, 0.35, 0.175));\n}\n\nfloat sake_displacement(vec2 p, vec2 p0) {\n    float dist = length(p - p0);\n    vec2 dir = normalize(p - p0);\n     \n    float k = 5.0;\n    float omega = 20.0;\n    float basewave = 0.5 * sin(k * dist - mod2(omega * iTime, 2.0 * pi)) + 0.5;\n    float k2 = 22.0;\n    float omega2 = 44.0;\n    float subwave = 0.5 * sin(k2 * dist - mod2(omega2 * iTime, 2.0 * pi)) + 0.5;\n    float k3 = 45.0;\n    float omega3 = 90.0;\n    float subwave2 = 0.5 * sin(k3 * dist - mod2(omega3 * iTime, 2.0 * pi)) + 0.5;\n    \n    basewave = 2.0 * pow(basewave, 4.0) + 0.3 * pow(subwave, 2.0) + 0.09 * subwave2;\n        \n    float amp = min(1.0 / sqrt(eps + dist), 1.0);\n    amp *= basewave;\n    \n    float outer_r = 0.82;\n    amp += 100.0 * step(outer_r, length(p)) * (length(p) - outer_r) * (length(p) - outer_r);\n    \n    amp = 1.0 - exp(-amp);\n    \n    amp *= step(length(p0), 0.85);\n    \n    return -0.1 * amp;\n}\n\nvec3 sake_normal(vec2 p, vec2 p0) {\n    float dfx = sake_displacement(p + vec2(1.0, 0.0) * eps, p0) - sake_displacement(p - vec2(1.0, 0.0) * eps, p0);\n    float dfy = sake_displacement(p + vec2(0.0, 1.0) * eps, p0) - sake_displacement(p - vec2(0.0, 1.0) * eps, p0);\n    return normalize(vec3(dfx, dfy, 2.0 * eps));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xy;\n    vec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 displaced_pos = pos;\n    float sake_depth = 0.0;\n    vec3 normal;\n    {\n        vec2 mouse_pos = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n        if (iMouse.x == 0.0 && iMouse.y == 0.0) {\n            mouse_pos = vec2(-0.5, -0.5) + 0.1 * vec2(2.0 * noise(iTime) - 1.0, 2.0 * noise(iTime + 11.52) - 1.0);\n        }\n\n        const float max_sake_depth = 0.4;\n        sake_depth = mod2(0.05 * iTime, max_sake_depth) * step(length(mouse_pos), 0.85);\n\n        normal = sake_normal(pos, mouse_pos);   \n        vec3 refract_dir = refract(-z_up, normal, 1.4);\n\n        vec2 displacement = refract_dir.xy / refract_dir.z * sake_depth;\n\n        displaced_pos += displacement;\n    }\n\n    vec3 ring_color = vec3(0.1, 0.1, 0.6);\n    vec3 ring_edge_color = vec3(0.3, 0.6, 0.9);\n    ring_color = mix(ring_edge_color, ring_color, smoothstep(-0.02, 0.02, -sdf(displaced_pos)));\n    \n    vec3 cup_color = vec3(0.98, 0.98, 0.98);  \n    vec3 color = mix(ring_color, cup_color, smoothstep(0.0, 0.02, sdf(displaced_pos)));\n    \n    //æ±åçå½¢é«åº¦ï¼å°ç¢è§ä¸ºåçå½¢ï¼\n    float h = sqrt(max(0.0, 1.0 - dot(pos, pos)));\n    vec3 N = normalize(vec3(-pos, h));\n    color *= mix(0.8, 1.0, dot(N, vec3(0.0, 0.0, 1.0)));\n    \n    //æ¸éé¢è²\n    const float max_sake_h = 0.8;\n    float sake_h = h - (1.0 - max_sake_h);\n    color *= mix(vec3(1.0), vec3(0.8, 0.8, 0.0), 1.0 - exp(-0.3 * sake_h)); \n    \n    // reflection\n    vec3 light_dir = normalize(vec3(3.0, 2.0, 1.0));\n    vec3 ref_dir = reflect(-z_up, normal);\n    vec3 ref_color = 3.0 * vec3(1.0, 1.0, 1.0) * smoothstep(0.8, 0.9, dot(ref_dir, light_dir));\n    ref_color += 0.5 * noise(2.0 * ref_dir.xy);\n    ref_color *= 1.0 - exp(-2.0 * sake_depth);\n    \n    color += 1.0 * ref_color;\n    \n    //ç¢æ²¿\n    color = mix(color, cup_color * 0.6, smoothstep(0.86, 0.87, length(pos)));\n    //âç¢çååº¦â\n    color = mix(color, cup_color * 0.1, smoothstep(0.91, 0.92, length(pos)));\n    //åç´ç¹åæºè¡°åè¿ä¼¼æ¨¡æ\n    color *= 1.0 - 0.5 * length(uv) * length(uv);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 162, 162, 232], [234, 234, 254, 254, 292], [294, 294, 315, 315, 406], [408, 408, 429, 429, 628], [630, 630, 660, 660, 695], [697, 697, 724, 724, 775], [777, 777, 820, 820, 852], [854, 854, 904, 904, 1074], [1076, 1076, 1095, 1095, 1165], [1167, 1167, 1209, 1209, 2056], [2058, 2058, 2093, 2093, 2374], [2376, 2376, 2433, 2433, 4700]], "test": "ok"}
{"id": "wtcGRH", "name": "Moebius Spiral field", "author": "FabriceNeyret2", "description": "For once, backward evolution: from continuous spiral, now looking for the field on grid ;-)", "tags": ["spiral", "mobius", "field", "complex", "screenspace"], "likes": 8, "viewed": 418, "published": "Public API", "date": "1575639909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reusing bits of https://shadertoy.com/view/llsfRj\n// ( watch there and upstream for contiuous lines ).\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1, z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283  + iTime/32.,\n\t      d = length(p);\n\treturn mat2(n,1, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),\n     Z2 = vec2( .375, -.125);\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{                              // ( for reverse, see https://shadertoy.com/view/llsfRj )\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n}\n\n// #define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage(out vec4 O, vec2 u) // --- Draw Moebius Spiral field\n{\n#define scale (R.y/15.) // 30.                           // number of cells\n\tvec2 R = iResolution.xy,\n         U = (u -.5*R) / R.y,\n      // ofs = hash(floor(scale*U)),  // U -= ofs/scale; // jittering\n         V = MobiusSpiral(U);\n    O = .7+.3*vec4(.5+.5*sin(3.*6.28*V),0,1);        // display continuous field\n    U = 2.*fract(U*scale+.5)-1.; \n   \n #define f(v) fract(v+.5)-.5                         // suppress the wrapping glitch\n    mat2 M = inverse( mat2(f(dFdx(V)),f(dFdy(V))) ); // measure compression, for LOD\n    M /= length(vec4(M));   // / max(360.,R.y);      // normalize\n  //float v = 2.*length(U*M) - .5;                   // draw ellipse\n    float v = abs(dot(U,M[1]));                      // draw main direction\n    v = smoothstep(2.*scale/R.y, 0., v);\n    O *= vec4( pow(v, 1./2.2 ) );                    // to sRGB\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 132, 171, 171, 242], [244, 244, 327, 327, 468], [558, 558, 616, 703, 812], [896, 896, 965, 965, 1804]], "test": "error"}
{"id": "WtcGRX", "name": "Movement on simple Sphere", "author": "Gilga", "description": "Movement on a simple Sphere", "tags": ["simple", "sphere", "snake", "moving", "axis", "move", "movement"], "likes": 6, "viewed": 264, "published": "Public API", "date": "1577031947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// References\n// https://www.shadertoy.com/view/XdfczH\n// https://www.shadertoy.com/view/wtfSWH\n// https://www.shadertoy.com/view/tslXRj\n// http://www.sousakuba.com/Programming/gs_two_lines_intersect.html\n\n#define pi 3.14159265358979323846264338327950288419716\n\nvec3 moveOnSphereThetaPhi(float radius, float theta, float phi) {\n    //theta = (mod(lon,360.0) / 360.0)*pi * 2.0;\n    //phi = (mod(lat,360.0) / 360.0)*pi * 2.0;\n    theta = theta * pi;\n    phi = phi * pi;\n    float tsin = sin(theta);\n    return radius * vec3(tsin*cos(phi),tsin*sin(phi),cos(theta));\n}\n\nvec3 moveOnSphereLonLat(float radius, float lon, float lat) {\n    //vec3 pos = vec3(0.0,0.0,0.0);\n    //float lat = asin(pos.z / radius);\n    //float lon = atan(pos.y,pos.x);\n  \n    float x = cos(lat) * cos(lon);\n    float y = cos(lat) * sin(lon);\n    float z = sin(lat);\n\n    vec3 move = radius * vec3(x,y,z);\n            \n    return move;\n}\n\nfloat circle(vec2 fragCoord, float radius)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cUv = uv;\n    cUv.x -= 0.5;\n    cUv.y -= 0.5;\n    cUv.y *= iResolution.y/iResolution.x;\n    \n    float circleOuter = smoothstep(0.101,0.103,length(cUv*0.5)/radius);\n    float circleInner = smoothstep(0.099,0.097,length(cUv*0.5)/radius);\n    float circle = circleInner + circleOuter;\n\n    float c = 1.0 - circle;\n\n    return c;\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    float z = p.z > 0.0 ? 0.125 : 1.0;\n        \n    return d*z;\n}\n\n\nfloat DrawLine(vec3 ro, vec3 rd, vec3 a, in vec3 b)\n{\n    vec3 ab =normalize(b-a),ao = a-ro;\n\tfloat d0 = dot(rd, ab), d1 = dot(rd, ao), d2 = dot(ab, ao);\n\tfloat len = (d0*d1-d2)/(1.0-d0*d0);\n    len= clamp(len,0.0,length(b-a));\n    vec3 p = a+ab*len;\n    float z = p.z > 0.0 ? 0.0 : 1.0;\n    \n \t//float d = DistLine(ro, rd, p);\n    //d = smoothstep(.06, .05, d);\n    //float z = p.z > 0.0 ? 0.125 : 1.0;\n    \n    return length(cross(p-ro, rd))/(1.-p.z);\n}\n\n\nvec3 lookat(vec3 p, vec3 eye, vec3 target, vec3 up)\n{\n\tvec3 w = normalize(target-eye), u = normalize(cross(w,up));\n\treturn vec3(dot(p,u), dot(p,cross(u,w)), dot(p,w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = uv;\n    \n\tmuv -= 0.5;\n    muv.x *= iResolution.x/iResolution.y;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 ro = vec3(3. * cos(t)*0.0, 2. * sin(t)*0.0, -3.); // camera position\n    \n    float zoom = 1.0;\n    \n    vec3 up = vec3(0., 1., 0.);\n    vec3 f = normalize(target - ro);\n    vec3 r = cross(up, f);\n    vec3 u = cross(f, r);\n    \n    vec3 z = ro + f * zoom;\n    vec3 i = z + muv.x*r + muv.y*u;\n    vec3 rd = normalize(i - ro); // camera direction\n    vec3 rd2 = lookat(rd,ro,target,up);\n    //rd=vec3(muv, 1.0);\n    \n    vec3 p = vec3(0);\n    \n    vec3 mover = vec3(0);\n    \n    vec3 o = moveOnSphereLonLat(1.,t,t*2.);\n    vec3 du = o+normalize(o)*.2;\n    vec3 df = moveOnSphereLonLat(1.,(t+.1)*1.0,(t+.1)*2.);\n    vec3 dr = o+cross(du,df);\n    \n    float lu = .01/DrawLine(ro, rd, o, du);\n    float lf = .01/DrawLine(ro, rd, o, df);\n    float lr = .01/DrawLine(ro, rd, o, dr);\n    \n    mover += vec3(DrawPoint(ro, rd, o));\n    mover += mix(mover,vec3(0.,0.,1.),lu);\n    mover += vec3(1.,0.,0)*lf;\n    mover += vec3(0.,1.,0.)*lr;\n    \n    for(int i=0; i<50; i++) {\n        float j = float(i)*.04;\n    \tmover += DrawPoint(ro, rd,  moveOnSphereLonLat(1.,(t-j),(t-j)*2.));\n    }\n    \n    vec3 col = vec3(0);\n    col = vec3(circle(fragCoord,0.9))*.35 + mover;\n    \n\tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 327, 423, 564], [566, 566, 627, 740, 908], [910, 910, 954, 954, 1337], [1339, 1339, 1381, 1381, 1427], [1429, 1429, 1472, 1472, 1603], [1606, 1606, 1659, 1659, 2061], [2064, 2064, 2117, 2117, 2233], [2235, 2235, 2292, 2292, 3678]], "test": "ok"}
{"id": "wtcGW7", "name": "Infinite Climbing Frame", "author": "julianlumia", "description": "test with SDF color ID's\nIf anybody has any optimisation/ tips on the way I implemented the SDF ID system that would be very welcome:)", "tags": ["coloringboxes"], "likes": 13, "viewed": 194, "published": "Public", "date": "1576512930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k ) {\nfloat h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\np = abs(p)-s;\nreturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec2 path(float z){\nfloat x = sin(z) + 3.0 * cos(z * 0.5) - 1.5 * sin(z * 1.12345);\nfloat y = cos(z) + 1.5 * sin(z * 0.3) + .2 * cos(z * 1.12345);\nreturn vec2(x,y)*0.5 ;\n}\n\nvec2 GetDist (vec3 p) \n{\nvec2 o = path(p.z) / 5.0;\np = vec3(p.x,p.y,p.z)-vec3(o.x,o.y,0.); \nfloat r = 3.14159*sin(p.z*0.15)+(iTime*0.25*1.);\nmat2 R = mat2(cos(r), sin(r), -sin(r), cos(r));\np.xy *= R ; \n    \np.xy *= (sin(p.z*0.2+iTime*0.3)*1.2+0.1)/1.5;\n    \np = fract(p) * 2. - 1.; \nvec2 box = vec2(sdBox(p-vec3(0,0.0,0), vec3(0.3)),1);\nvec2 box2 = vec2(sdBox(p-vec3(0,0.0,0), vec3(0.1,1.1,0.1)),0);\nvec2 box3 = vec2(sdBox(p-vec3(0,0.0,0), vec3(1.1, 0.1,0.1)),2);\nvec2 box4 = vec2(sdBox(p-vec3(0,0.0,0), vec3(0.1, 0.1,1.1)),3);\nvec2 d = (box.x<box2.x)?box:box2;\nd=(d.x<box3.x)?d:box3;\nd=(d.x<box4.x)?d:box4;\nd.x =  smin(d.x,box.x,0.2);\nd.x *= 0.4;        \nreturn  d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n{\nvec2 h, t=vec2( 0.);\nfor (int i=0; i<64; i++) \n{\nh = GetDist(ro + t.x * rd);\nif(h.x<.001||t.x>100.) break;\nt.x+=h.x;t.y=h.y;\n}\nif(t.x>100.) t.x=0.;\nreturn t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 d = GetDist(p);\nvec2 e = vec2(0.001,0);\nvec3 n = d.x - vec3(\nGetDist(p-e.xyy).x,\nGetDist(p-e.yxy).x,\nGetDist(p-e.yyx).x);\nreturn normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\nvec2 a = path(iTime * 1.0)*1.0;\nvec3 o = vec3(a / 5.0,iTime-0.5);\nvec3 lightPos =  o;\nvec3 l = normalize(lightPos-p);\nvec3 n = GetNormal(p);\nfloat dif = clamp(dot(n, l)*.5+.5, 0., 1.);\nvec2 d = RayMarch(p+n*.001*20., l);\nif (d.x<length(lightPos-p)) dif *= 0.5;\nreturn dif;       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\nvec3 col = vec3(0);\nvec2 a = path(iTime * 1.0)*1.0;\nvec3 o = vec3(a / 5.0,iTime);\nvec3 rd = normalize(vec3(uv.x,uv.y-.2,0.5));\nfloat the = iTime*0.3;\nvec2 d = RayMarch (o,rd);\nfloat t =d.x *1.;   \nif(t>0.){\nvec3 p = o + rd *t;\nvec3 baseColor = vec3(0.,0.,0.5);\nif(d.y==0.) baseColor=vec3(sin(p.z+iTime*2.),1.,0);\n//if(d.y==0.) baseColor=vec3(sin(p.z+iTime*1.)-0.4,1.,0.5);\nif(d.y==1.) baseColor=vec3(0,cos(p.z+iTime*4.),1.);\nif(d.y==2.) baseColor=vec3(sin(p.z+iTime*1.)-0.4,1.,0.5);\nif(d.y==3.) baseColor=vec3(1,.1,sin(iTime));\nfloat dif = GetLight (p); \ncol = vec3(dif);       \ncol+=baseColor;\nfloat fog = 1. / (2. + t * t * 0.25);\ncol *= vec3(fog);   \nvec3 sky = vec3(1., 1., 1.);\ncol = mix(sky, col, 1./(d.x*d.x/1./1.*.05+1.1)); \n}\nfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 124], [126, 126, 155, 155, 231], [233, 233, 252, 252, 404], [406, 406, 430, 430, 1074], [1076, 1076, 1111, 1111, 1271], [1273, 1273, 1296, 1296, 1446], [1448, 1448, 1472, 1472, 1754], [1756, 1756, 1813, 1813, 2635]], "test": "timeout"}
{"id": "Wtd3Df", "name": "Chateaux...", "author": "dr2", "description": "Chenonceau perhaps; summer/winter, day/night, rotating/traveling viewer; vertical mouse selects page (different views), horizontal pans.", "tags": ["raymarch", "tree", "river", "architecture", "book", "building"], "likes": 24, "viewed": 439, "published": "Public API", "date": "1577794626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Chateaux...\"  by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat SmootherStep (float a, float b, float x);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec4 snowCol;\nvec3 sunDir, trkA, trkF, bldSize, ltDirEx, qHit, pgSize;\nvec2 gId, trOff, trkA2, trkF2;\nfloat tCur, dstFar, hgSize, szFac, trSym, grHt, trRot, snowFac, zRep, bldSzFac,\n   dstFarEx, tpBook, phsTurn, idPage, msAz, msEl;\nint idObj, vuMode;\nbool isNt, isFlsh;\nconst int idFnd = 1, idWal = 2, idWin = 3, idTwr = 4, idRf = 5, idFlr = 6, idRmp = 7, \n   idPil = 8, idRod = 9, idFlag = 10, idTrnk = 21, idLv = 22, idRk = 23;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\nconst int nPage = 6;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 TrackPathS (float t)\n{\n  return vec2 (dot (trkA, cos (2. * pi * trkF * t)), t);\n}\n\nvec2 TrackPath (float t)\n{\n  return TrackPathS (t) + vec2 (dot (trkA2, cos (2. * pi * trkF2 * t)), 0.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, w;\n  h = 0.5 + 0.17 * (sin (dot (p, vec2 (1., 1.4))) + sin (dot (p, vec2 (-1.2, 0.8)))) *\n     smoothstep (1., 2., abs (mod (p.y + zRep, 2. * zRep) - zRep));\n  w = abs (p.x - TrackPath (p.y).x) * (1.1 + 0.3 * sin (0.5 * p.y));\n  h = h * SmootherStep (4.35, 5., w) - 0.05 * (1. - w * w / (4.3 * 4.3)) * step (w, 4.3);\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.05, 0.5 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjCdf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, ht;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId) * hgSize + trOff;\n  if (szFac > 0.) {\n    dMin /= szFac;\n    p.xz = Rot2D (p.xz, trRot);\n    p.y -= grHt - 0.1;\n    p /= szFac;\n    ht = 2.2;\n    q = p;\n    q.y -= ht;\n    d = PrCylDf (q.xzy, 0.12 - 0.03 * q.y / ht, ht);\n    qq = p;\n    qq.xz = Rot2D (qq.xz, 2. * pi * (floor (trSym * atan (qq.z, - qq.x) / (2. * pi) +\n       0.5) / trSym));\n    q = qq;\n    q.xy = Rot2D (q.xy - vec2 (-0.2, 0.3), -0.3 * pi);\n    d = SmoothMin (d, PrCylDf (q.yzx, 0.09 + 0.02 * q.x / 0.6, 0.6), 0.2);\n    q = qq;\n    q.xy = Rot2D (q.xy - vec2 (-0.2, 1.2 * ht), 0.3 * pi);\n    d = SmoothMin (d, PrCylDf (q.yzx, 0.05 + 0.02 * q.x / 0.5, 0.5), 0.1);\n    DMIN (idTrnk);\n    q = p;\n    q.y -= 2. * ht;\n    d = SmoothMin (min (PrSphDf (q + vec3 (0, -1., 0.), 0.6),\n       PrSphDf (vec3 (qq.x + 0.4, q.y + 1., qq.z), 0.6)), PrSphDf (q, 1.), 0.5);\n    DMIN (idLv);\n    dMin *= szFac;\n  } else  if (szFac < 0.) {\n    q = p;\n    d = PrSphDf (q, - szFac * 0.25);\n    DMIN (idRk);\n  }\n  return dMin;\n}\n\nvoid SetTrParms ()\n{\n  vec2 g, w, v;\n  float s;\n  szFac = 0.3 + 0.4 * Hashfv2 (17. * gId + 99.);\n  trSym = floor (3. + 2.9 * Hashfv2 (19. * gId + 99.));\n  w = Hashv2v2 (33. * gId);\n  g = HexToPix (gId) * hgSize;\n  s = abs (g.x - TrackPath (g.y).x);\n  if (length (vec2 (max (s, 10.), mod (g.y + zRep, 2. * zRep) - zRep)) < 10.5) {\n    szFac = 0.;\n  } else {\n    v = w.x * sin (2. * pi * w.y + vec2 (0.5 * pi, 0.));\n    if (s < 1.5) {\n      trOff = hgSize * 0.5 * sqrt3 * v;\n      szFac *= -1.;\n    } else if (s < 6.5) {\n      szFac = 0.;\n    } else {\n      trOff = max (0., hgSize * 0.5 * sqrt3 - szFac) * v;\n      trRot = 0.6 * pi * (Hashfv2 (23. * gId + 99.) - 0.5);\n      grHt = GrndHt (g + trOff);\n    }\n  }\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrParms ();\n    }\n    d = ObjCdf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  v = vec4 (- ObjCdf (p + e.xxx), ObjCdf (p + e.xyy), ObjCdf (p + e.yxy), ObjCdf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjCSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrParms ();\n    }\n    h = ObjCdf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 vb, vc;\n  float dMin, d, dd, t;\n  dMin = dstFar;\n  dMin /= bldSzFac;\n  p.z = mod (p.z + zRep, 2. * zRep) - zRep;\n  p.x -= TrackPath (0.).x;\n  p /= bldSzFac;\n  p.y -= 1.;\n  q = p;\n  q.x = abs (q.x) - bldSize.x - 3.;\n  q.y -= 0.6 - 0.2 * q.x;\n  d = max (PrBoxDf (q, vec3 (2.64, 0.3, 0.7)),\n     - PrBox2Df (q.yz - vec2 (0.2, 0.), vec2 (0.3, 0.6)));\n  DMIN (idRmp);\n  q.xz = abs (q.xz) - vec2 (2.7, 0.65);\n  d = PrCylDf (q.xzy, 0.08, 0.33);\n  DMIN (idPil);\n  q = p;\n  d = abs (q.x) - 5.;\n  q.x = mod (q.x + 1., 2.) - 1.;\n  d = max (PrFlatCylDf (q.zxy, bldSize.z + 0.3, 0.4, 1.), d);\n  DMIN (idFnd);\n  q = p;\n  q.y -= 0.5;\n  d = max (PrBoxDf (q, vec3 (bldSize.x + 0.4, 0.5, bldSize.z + 0.3)),\n     0.6 - length (vec2 (mod (q.x, 2.) - 1., q.y + 0.5)));\n  DMIN (idFnd);\n  q = p;\n  q.y -= 1. + bldSize.y;\n  vb = mod (q.xz + 0.5, 1.) - 0.5;\n  vc = abs (q.xz) - bldSize.xz + 0.15;\n  d = max (max (max (PrBoxDf (q, bldSize), - PrBox2Df (q.xz, bldSize.xz - 0.14)),\n     - min (max (PrBox2Df (vec2 (vb.x, abs (q.y) - 0.7), vec2 (0.2, 0.45)), vc.x),\n     max (PrBox2Df (vec2 (vb.y, abs (q.y) - 0.7), vec2 (0.2, 0.45)), vc.y))),\n     0.3 - length (vc - 0.15));\n  dd = PrBox2Df (vec2 (q.y + 0.85, q.z), vec2 (0.6, 0.35));\n  d = max (d, - dd);\n  DMIN (idWal);\n  q = p;\n  q.y -= 1. + 2. * bldSize.y + 0.15;\n  vb = abs (mod (q.xz + 0.25, 0.5) - 0.25);\n  d = max (max (PrBoxDf (q, vec3 (bldSize.x, 0.15, bldSize.z)), - PrBox2Df (q.xz, bldSize.xz - 0.1)),\n     -0.125 + max (vb.x, vb.y));\n  DMIN (idWal);\n  q = p;\n  q.y -= 1. + bldSize.y - 0.1;\n  d = PrBoxDf (q, vec3 (bldSize.x, 0.05, bldSize.z));\n  DMIN (idFlr);\n  q = p;\n  t = abs (q.z) - bldSize.z + 0.05;\n  q.yz = vec2 (abs (q.y - (1. + bldSize.y) - 0.1) - 0.7, t);\n  d = PrCylDf (q.yzx, 0.025, bldSize.x);\n  q = vec3 (mod (p.x + 0.5, 1.) - 0.5, p.y - (1. + bldSize.y), t);\n  d = min (d, max (PrCylDf (q.xzy, 0.025, bldSize.y), vc.x));\n  DMIN (idWin);\n  q = p;\n  t = abs (q.x) - bldSize.x + 0.05;\n  q.xy = vec2 (t, abs (q.y - (1. + bldSize.y) - 0.1) - 0.7);\n  d = PrCylDf (q, 0.025, bldSize.z);\n  q = vec3 (t, p.y - (1. + bldSize.y), mod (p.z + 0.5, 1.) - 0.5);\n  d = min (d, max (PrCylDf (q.xzy, 0.025, bldSize.y), vc.y));\n  d = max (d, - dd);\n  DMIN (idWin);\n  q = p;\n  q.y -= 2. * bldSize.y + 2.15;\n  d = 0.7 * max (max (q.y + max (abs (q.x) - 2.75, 0.6 * abs (q.z)), - q.y - 1.2),\n     PrBox2Df (q.xz, bldSize.xz - 0.1));\n  DMIN (idRf);\n  q = vec3 (vc - 0.15, p.y - (1.2 + bldSize.y)).xzy;\n  d = PrCylDf (q.xzy, 0.3, bldSize.y + 0.2);\n  DMIN (idTwr);\n  q.y -= 1. + bldSize.y;\n  d = 0.9 * PrConeDf (q.xzy, vec3 (1., 0.3, 0.8));\n  DMIN (idRf);\n  q.y -= 0.15;\n  d = PrCylDf (q.xzy, 0.03, 0.3);\n  DMIN (idRod);\n  q.xy -= vec2 (0.2 * sign (p.x), 0.15);\n  d = PrRoundBoxDf (q, vec3 (0.2, 0.1, 0.005), 0.005);\n  DMIN (idFlag);\n  return bldSzFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, clCol, skCol;\n  vec2 q;\n  float f, ff, fd;\n  rd.y = abs (rd.y) + 0.0001;\n  q = 0.01 * (ro.xz + 4. * tCur + ((50. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  skCol = isNt ? vec3 (0.2, 0.2, 0.2) : vec3 (0.4, 0.5, 0.8);\n  skCol = mix ((vec3 (0.7, 0.7, 0.75)), skCol, 0.3 + 0.7 * fd);\n  col = mix (skCol, (isNt ? 0.8 : 1.) * clCol, 0.1 + 0.9 * f * fd);\n  return col;\n}\n\nvoid BldCol (vec3 p, vec3 vn, out vec4 col4, out vec2 vf)\n{\n  vec4 snCol, wallCol;\n  vec3 u, uu;\n  float zColr;\n  snCol = snowCol;\n  u = p;\n  u.x -= TrackPath (0.).x;\n  zColr = mod (floor (u.z / (2. * zRep) + 0.5), 4.);\n  u.z = mod (u.z + zRep, 2. * zRep) - zRep;\n  u /= bldSzFac;\n  u.y -= 1.;\n  wallCol = vec4 (HsvToRgb (vec3 (0.05 + 0.06 * zColr / 3., 0.7, 1.)), 0.1);\n  col4 = vec4 (0.);\n  vf = vec2 (0.);\n  if (idObj == idWal) {\n    uu.xz = mod (u.xz + 0.5, 1.) - 0.5;\n    u.xz = abs (u.xz);\n    uu.y = u.y - 1. - bldSize.y;\n    if (abs (uu.y + 0.85) < 0.7 && u.x > bldSize.x - 0.2 && u.z < 0.45) {\n      col4 = vec4 (0.3, 0.5, 0.4, 0.1);\n    } else if (abs (abs (uu.y) - 0.7) < 0.5 && (u.z > bldSize.z - 0.2 &&\n       abs (uu.x) < 0.25 || u.x > bldSize.x - 0.2 && abs (uu.z) < 0.25)) {\n       col4 = vec4 (0.7, 0.6, 0.5, 0.1);\n    } else {\n      col4 = wallCol;\n      if (abs (u.x) > bldSize.x - 0.01 || abs (u.z) > bldSize.z - 0.01)\n         col4.rgb *= 0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.02, mod (10. * u.y + 0.5, 1.));\n    }\n    if (u.y < 2. * bldSize.y + 1.) snCol.r = -1.;\n    vf = vec2 (32., 0.2);\n  } else if (idObj == idTwr) {\n    col4 = wallCol;\n    vf = vec2 (32., 0.2);\n  } else if (idObj == idRf) {\n    col4 = vec4 (0.55, 0.6, 0.55, 0.1) * (0.93 +\n       0.07 * SmoothBump (0.05, 0.95, 0.02, mod (8. * u.y, 1.)));\n  } else if (idObj == idFnd) {\n    if (vn.y > 0.99) {\n      if (abs (u.x) < bldSize.x && abs (u.z) < bldSize.z) {\n        col4 = (isNt ? 0.6 : 1.) * vec4 (0.5, 0.2, 0., 0.1);\n        snCol.r = -1.;\n      } else {\n        if (vuMode == 0) {\n          col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n        } else {\n          col4 = 0.4 * wallCol;\n          snCol.r = -1.;\n        }\n        vf = vec2 (32., 0.2);\n      }\n    } else {\n      col4 = 0.7 * wallCol;\n      if (u.y < -0.6) col4.rgb *= 0.8 * (0.8 +\n         0.2 * SmoothBump (0.1, 0.9, 0.02, mod (8. * u.y, 1.)));\n      if (u.y < 0.6 && abs (u.z) < bldSize.z) col4.rgb *= (0.8 +\n         0.2 * SmoothBump (0.08, 0.92, 0.02, mod (4. * u.z, 1.)));\n      vf = vec2 (32., 0.5);\n    }\n  } else if (idObj == idRmp) {\n    if (abs (vn.z) > 0.99) col4 = wallCol;\n    else col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n    vf = vec2 (32., 0.2);\n  } else if (idObj == idPil) {\n    col4 = wallCol;\n    vf = vec2 (32., 0.1);\n  } else if (idObj == idFlr) {\n    col4 = (isNt ? 0.6 : 1.) * vec4 (0.5, 0.2, 0., 0.1);\n    snCol.r = -1.;\n  } else if (idObj == idWin) {\n    col4 = vec4 (0.4, 0.4, 0.3, 0.3);\n    vf = vec2 (16., 0.3);\n  } else if (idObj == idRod) {\n    col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n  } else if (idObj == idFlag) {\n    col4 = vec4 (mix (HsvToRgb (vec3 (zColr / 4., 1., 1.)), vec3 (1.2),\n       step (u.y, 2. * bldSize.y + 2.5)), 0.2);\n  }\n  if (snCol.r > 0.) {\n    col4 = mix (col4, snCol, snowFac * smoothstep (0.3, 0.8, vn.y));\n    if (snowFac > 0.5) vf = vec2 (32., 2. * smoothstep (0.5, 0.7, snowFac)) *\n       smoothstep (0.3, 0.8, vn.y);\n  }\n}\n\nvoid TrStCol (vec3 p, vec3 vn, out vec4 col4, out vec2 vf)\n{\n  vec4 snCol;\n  float h1, h2;\n  col4 = vec4 (0.);\n  vf = vec2 (0.);\n  gId = PixToHex (p.xz / hgSize);\n  h1 = Hashfv2 (gId * vec2 (17., 27.) + 0.5);\n  h2 = Hashfv2 (gId * vec2 (19., 29.) + 0.5);\n  if (idObj == idTrnk) {\n    col4 = vec4 (HsvToRgb (vec3 (0.1 * h1, 0.5, 0.4 - 0.2 * h2)), 0.);\n    snCol = mix (snowCol, mix (col4, snowCol, smoothstep (0.01, 0.2, vn.y)),\n       smoothstep (0.1 * szFac, 0.3 * szFac, p.y - GrndHt (HexToPix (gId) * hgSize)));\n    vf = vec2 (32., 2.);\n  } else if (idObj == idLv) {\n    col4 = vec4 (HsvToRgb (vec3 (0.2 + 0.2 * h1, 0.7, 0.8 - 0.4 * h2)) *\n       (1. - 0.2 * Noisefv3 (64. * p)), 0.05);\n    snCol = mix (0.6 * col4, snowCol, 0.2 + 0.8 * smoothstep (-0.8, -0.6, vn.y));\n    vf = vec2 (16., mix (2., 8., 1. - snowFac));\n  } else if (idObj == idRk) {\n    col4 = vec4 (mix (vec3 (0.4, 0.3, 0.3), vec3 (0.3, 0.4, 0.5), Fbm2 (16. * p.xz)), 0.1);\n    snCol = mix (col4, snowCol, 0.2 + 0.8 * smoothstep (0.1, 0.3, vn.y));\n    vf = vec2 (8., 8.);\n  }\n  col4 = mix (col4, snCol, snowFac);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c1, c2, vn, vnw, rog, roo, rdo;\n  vec2 vf;\n  float dstObjC, dstObjM, dstObj, dstGrnd, dstWat, sh, spec, s, glit;\n  int idObjC;\n  bool isRefl, isSky, isGlit;\n  hgSize = 1.5;\n  bldSize = vec3 (4., 1.5, 2.);\n  bldSzFac = 0.5;\n  isRefl = false;\n  isSky = false;\n  isGlit = false;\n  snowCol = vec4 (0.9, 0.9, 0.95, 0.2);\n  spec = 0.;\n  roo = ro;\n  rdo = rd;\n  dstGrnd = GrndRay (ro, rd);\n  dstObjC = ObjCRay (ro, rd);\n  idObjC = idObj;\n  dstObjM = ObjRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  rog = ro + dstGrnd * rd;\n  dstObj = min (dstObjM, dstObjC);\n  if (dstWat < min (min (dstGrnd, dstObj), dstFar)) {\n    ro += dstWat * rd;\n    vnw = VaryNf (ro + vec3 (0., 0., 0.2 * tCur), vec3 (0., 1., 0.),\n       0.2 - 0.18 * smoothstep (0.1, 0.15, dstWat / dstFar));\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstGrnd = GrndRay (ro, rd);\n    dstObjC = ObjCRay (ro, rd);\n    idObjC = idObj;\n    dstObjM = ObjRay (ro, rd);\n    dstObj = min (dstObjM, dstObjC);\n    isRefl = true;\n  }\n  vf = vec2 (0.);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstObj < dstGrnd) {\n      if (dstObjM < dstObjC) {\n        ro += dstObjM * rd;\n        vn = ObjNf (ro);\n        BldCol (ro, vn, col4, vf);\n        col = col4.rgb;\n        spec = col4.a;\n        if (vn.y > 0.8) isGlit = true;\n      } else {\n        ro += dstObjC * rd;\n        vn = ObjCNf (ro);\n        idObj = idObjC;\n        TrStCol (ro, vn, col4, vf);\n        col = col4.rgb;\n        spec = col4.a;\n      }\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      gId = PixToHex (ro.xz / hgSize);\n      SetTrParms ();\n      vn = GrndNf (ro);\n      vf = vec2 (8., 4.);\n      if (snowFac < 1.) {\n        c1 = mix (vec3 (0.1, 0.2, 0.15), vec3 (0.2, 0.4, 0.2),\n           smoothstep (0.3, 0.5, Fbm2 (8. * ro.xz)));\n        if (szFac > 0.) c1 = mix (vec3 (0.15, 0.05, 0.1), c1, 0.2 + 0.8 *\n           smoothstep (0.4 * szFac, 0.7 * szFac, length (ro.xz - HexToPix (gId) * hgSize - trOff)));\n        c1 *= (1. - 0.2 * Noisefv2 (128. * ro.xz));\n        c2 = vec3 (0.3, 0.3, 0.35) * (1. - 0.2 * Noisefv2 (256. * ro.zy));\n        col = mix (c2, mix (c2, c1, smoothstep (0.4, 0.7, vn.y)),\n           smoothstep (0., 0.005 * Noisefv2 (128. * ro.xz), ro.y));\n      } else col = vec3 (0.);\n      col = mix (col, snowCol.rgb, snowFac);\n      isGlit = true;\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = (! isNt) ? min (ObjCSShadow (ro, sunDir), ObjSShadow (ro, sunDir)) : 1.;\n    col = col * (0.2 + 0.2 * max (dot (normalize (- sunDir.xz), vn.xz), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    if (! isNt) col += step (0.95, sh) * spec * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else {\n    if (! isRefl) {\n      ro = roo;\n      rd = rdo;\n    }\n    col = SkyCol (ro, rd);\n    isSky = true;\n  }\n  if (! isNt && isGlit && snowFac > 0.) {\n    glit = 64. * step (0.01, max (0., dot (vn, sunDir))) *\n       pow (max (0., dot (sunDir, reflect (rd, vn))), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (512. * ro, vn, 8.))), 8.);\n    col += vec3 (1., 1., 0.8) * smoothstep (0.6, 0.9, snowFac) * step (0.95, sh) * glit;\n  }\n  if (isRefl) col = mix (mix (vec3 (0., 0.1, 0.), vec3 (0.08, 0.08, 0.1),\n     smoothstep (0.45, 0.55, Noisefv2 (128. * rog.xz))), 0.95 * col,\n     1. - 0.9 * pow (dot (- rdo, vnw), 2.));\n  if (! isSky) col = mix (col, vec3 (0.65, 0.65, 0.7), smoothstep (0.7, 1.,\n     (min (dstGrnd, dstObj) + (isRefl ? dstWat : 0.)) / dstFar));\n  if (isNt) col = mix (col, vec3 (pow (max (max (col.r, col.g), col.b), 1.5)), 0.8) *\n     (isFlsh ? 1.5 * vec3 (1., 1., 0.8) : vec3 (0.3));\n  return col;\n}\n\n#define ISBOOK  1\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vd;\n  float el, az, zmFac, t, vel, f;\n  zRep = 64.;\n  trkF = vec3 (1., 2., 3.) / zRep;\n  trkA = vec3 (1.5, -1.2, 0.8);\n  trkF2 = vec2 (1., 2.) * 16. / zRep;\n  trkA2 = vec2 (-0.1, 0.05);\n#if ISBOOK\n  if (idPage <= 3.) {\n    vuMode = 0;\n  } else {\n    vuMode = 1;\n  }\n  msEl = -99.;\n  t = (mod (idPage - 1., 3.) == 1.) ? 0. : 0.5;\n  isNt = (mod (idPage - 1., 3.) == 2.);\n  isFlsh = (Fbm1 (10. * tCur) > 0.7);\n#else\n  t = 0.;\n  vuMode = 0;\n  isNt = false;\n  isFlsh = false;\n#endif\n  snowFac = SmoothBump (0.4, 0.9, 0.03, mod (tCur / 120. + t, 1.));\n  if (vuMode == 0) {\n    ro = vec3 (0., 1., -15.);\n    az = mod (((msAz >= 0.) ? - msAz : 0.03 * pi * tCur),  2. * pi);\n    el = (msEl >= -0.5 * pi) ? min (- msEl, 0.) : -0.023 * pi * (5. - cos (2. * az));\n    zmFac = 4.;\n  } else {\n    vel = 3.;\n    t = vel * tCur + 0.3 * zRep;\n    ro.xz = TrackPathS (t);\n    vd = TrackPathS (t + zRep / 32.) - ro.xz;\n    t = ro.z / (2. * zRep);\n    f = SmoothBump (0.2, 0.8, 0.1, mod (t, 1.));\n    ro.x += 0.5 * (1. - f) * (2. * mod (floor (t + 0.5), 2.) - 1.);\n    ro.y = 0.6 + 1.4 * (1. + 0.5 * mod (floor (t), 2.)) * f;\n    az = 0.5 * atan (vd.x, vd.y);\n    az += (msAz >= 0.) ? msAz : pi * SmoothBump (0.15, 0.55, 0.15, mod (t, 1.)) * (mod (floor (t), 3.) - 1.);\n    el = (msEl >= 0.) ? msEl : 0.;\n    zmFac = 3.;\n  }\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 1.5, 0.3));\n  vuMat = StdVuMat (el, az);\n  if (vuMode == 0) ro = vuMat * ro;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  fCol = ShowScene (ro, rd);\n  fCol = clamp (fCol, 0., 1.);\n}\n\n#if ISBOOK\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 5.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.x / nRing;\n  bc = q.x;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.zy = Rot2D (vec2 (q.z, y), 2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.z + rRad, bc));\n    q.z -= - (pgSize.z - hOff + rRad);\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.x) - pgSize.x;\n  q.x = bc;\n  q = q.zyx;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      s = pgSize.xz - abs (qHit.xz);\n      col4 = vec4 (0.9, 0.9, 0.8, 0.1);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 *= 0.3;\n        } else {\n          col4 *= 0.6;\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = tCur;\n  msAz = -99.;\n  msEl = -99.;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    msAz = mod (2. * pi * mPtr.x, 2. * pi);\n#if ISBOOK\n    tpBook = - clamp (1.05 * mPtr.y + 0.45, 0., 1.);\n#else\n    msEl = pi * mPtr.y;\n#endif\n}\n#if ISBOOK\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., -2., -20.);\n  zmFac = 9.;\n  ro = vuMat * ro;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (0.3, 1., 0.3));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n#else\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat SmootherStep (float a, float b, float x)\n{\n  x = clamp ((x - a) / (b - a), 0., 1.); \n  return ((6. * x - 15.) * x + 10.) * x * x * x;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtd3Df.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1655, 1655, 1682, 1682, 1741], [1743, 1743, 1769, 1769, 1848], [1850, 1850, 1873, 1873, 2215], [2217, 2217, 2251, 2251, 2745], [2747, 2747, 2769, 2769, 2913], [2915, 2915, 2938, 2938, 3988], [3990, 3990, 4010, 4010, 4702], [4704, 4704, 4738, 4738, 5842], [5844, 5844, 5866, 5866, 6067], [6069, 6069, 6107, 6107, 6515], [6517, 6517, 6539, 6539, 9343], [9345, 9345, 9378, 9378, 9561], [9563, 9563, 9584, 9584, 9774], [9776, 9776, 9813, 9813, 10060], [10062, 10062, 10094, 10094, 10732], [10734, 10734, 10793, 10793, 13650], [13652, 13652, 13712, 13712, 14735], [14737, 14737, 14772, 14772, 18468], [18489, 18489, 18534, 18534, 20112], [23311, 23311, 23367, 23367, 24568], [24570, 24570, 24602, 24602, 24702], [24704, 24704, 24737, 24737, 24826], [24828, 24828, 24874, 24874, 24921], [24923, 24923, 24956, 24956, 24983], [24985, 24985, 25027, 25027, 25078], [25080, 25080, 25139, 25139, 25270], [25272, 25272, 25318, 25318, 25375], [25377, 25377, 25410, 25410, 25483], [25485, 25485, 25530, 25530, 25633], [25635, 25635, 25692, 25692, 25775], [25777, 25777, 25825, 25825, 25918], [25920, 25920, 25956, 25956, 26162], [26164, 26164, 26194, 26194, 26307], [26309, 26309, 26333, 26333, 26563], [26565, 26565, 26589, 26589, 26649], [26651, 26651, 26675, 26675, 26792], [26826, 26826, 26850, 26850, 26910], [26912, 26912, 26936, 26936, 26989], [26991, 26991, 27015, 27015, 27145], [27147, 27147, 27171, 27171, 27391], [27393, 27393, 27418, 27418, 27564], [27566, 27566, 27591, 27591, 27777], [27779, 27779, 27804, 27804, 28029], [28031, 28031, 28053, 28053, 28207], [28209, 28209, 28230, 28230, 28385], [28387, 28387, 28416, 28416, 28628], [28630, 28630, 28669, 28669, 28849]], "test": "error"}
{"id": "Wtd3DN", "name": "Cathodique noise", "author": "Hatokuro", "description": "Shader Noise + Border \ninspired by https://www.shadertoy.com/view/MdcfzH", "tags": ["noisecathodiquecrt"], "likes": 1, "viewed": 153, "published": "Public", "date": "1576406388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BORDERSIZE .01\n#define DEFRAND 320.\n\nfloat rand(vec2 valeur)\n{\n    return fract(cos(dot(valeur.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 centre = vec2(.5,.5);\n    \n    // Time varying pixel color\n    // Noise\n    vec2 uvm = uv*DEFRAND;\n    vec2 randseed = floor(uvm)*iTime/DEFRAND;\n    vec3 col = vec3(rand(randseed));\n    \n    \n    // Border\n    vec2 degrad = 2.0 * abs(uv-centre);\n    float coldegrad = (1.-degrad.x) * (1.-degrad.y);\n    \n    coldegrad = smoothstep(0.0,BORDERSIZE+0.1,sqrt(coldegrad));\n\n    col *= coldegrad;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtd3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 70, 70, 146], [148, 148, 205, 255, 751]], "test": "ok"}
{"id": "Wtd3zj", "name": "Text Demo 2", "author": "gigatron", "description": "Quick font unfinised demo; seq issue ...", "tags": ["font"], "likes": 2, "viewed": 287, "published": "Public", "date": "1576881566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- access to the image of ascii code c // from Fabrice ;\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel0, U/16. + fract( floor(vec2(c, 15.999-float(c/16))) / 16.))/1.5\n\n\n\nfloat shtoy(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0); \n    C(83);C(72);C(65);C(68);C(69);C(82);C(84);C(79);C(89);\n    \n    C(32);C(84);C(69);C(88);C(84);C(32);C(68);C(69);C(77);C(79);\n  \n    return length(T.yz)==0. ? 0. : T.x;\n}\n\n\n \n\n\n#define dir 2    // define direction 0,1,2,3  up/down/left/right\n#define time iTime\n#define speed 0.4\n\nvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 // 1/7\n\t\t\t\t#define K2 0.0714285714285 // K/2\n\t\t\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t// Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; // F1 duplicated, F2 not computed\n\t\t}\n\n\n#define PI 3.14159265358979\n\nconst float pi = 3.14159;\nmat3 xrot(float t)\n{    return mat3(1.0, 0.0, 0.0,\n    0.0, cos(t), -sin(t),\n    0.0, sin(t), cos(t));\n}\nmat3 yrot(float t)\n{    return mat3(cos(t), 0.0, -sin(t),\n    0.0, 1.0, 0.0,\n    sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{    return mat3(cos(t), -sin(t), 0.0,\n    sin(t), cos(t), 0.0,\n    0.0, 0.0, 1.0);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 uv (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * PI) + .5;\n    float v = asin(y) / (PI) + .5;\n    return vec2(u,v);\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 map(vec3 p)\n{\n    vec2 f=(fract(p.xy) * 2.0 - 1.0) ;\n    vec3 q = vec3(f.x-0.5, f.y, p.z);\n    float br = 0.4;\n    float c = sdCylinder(  p+vec3( 0.0,0.60,-1.0), vec2(3.0,3.0)  );\n   // float b = sdCylinder(p, vec2(1.1,1.3))*br;\n    \n  //  float b= sdBox(p-vec3( 0.0,0.25, 0.0), vec3(0.65) );\n \n    float  ss = sdSphere(    p-vec3( 0.0,0.00, 0.0),1.00 )  ;\n  \n    return vec2(ss, ss);\n    \n}\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.02, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n    map(p+o.yxy).x - map(p-o.yxy).x,\n    map(p+o.yyx).x - map(p-o.yyx).x));\n}\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n    vec3 p = o + r * t;\n    float d = map(p).x;\n    t += d;\n\t}\nreturn t;\n}\n\nvec4 tex(vec3 p)\n{\n    \n    \n    vec4 tx= texture(iChannel1,uv(normalize(p)));\n    \n    return (tx ) ;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    \n    float t=iTime*3.0;\n    \n     \n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n   \t\t uv3 = uv3 * 2.0 - 1.0;\n   \t\t uv3.x *=iResolution.x/iResolution.y;    \n \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy ;\n\t\t\t\n\t\tuv.x*=(iResolution.x/iResolution.y);\n    \n    vec2 uvs = uv*2.-1.0;\n    \n    float rot = radians(iTime * 360.0)/30.0;\n    \n     \n    \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \t\n    float gtimer = iTime;\n    \n    uv = uv -0.5;\n    if (gtimer>30.0) {  uv  = m * uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n    if (gtimer>60.0) {  uv  = m * -uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n\t\t\t\t\t\n\t\tvec2 GA=vec2(0);\n\t\t\t\t\n        #if dir==0 \n        GA.y +=time*speed;\n        #elif dir==1\n        GA.y -=time*speed;\n        #elif dir==2\n        GA.x +=time*speed;\n        #elif dir==3\n        GA.x -=time*speed;\n        #endif\n\t\t\n    \t// multi declaration \n        float   F1,F2,F3,F4,F5,F6,F7,F8=0.0;\n\t\tfloat   N1,N2,N3,N4,N5,N6,N7,N8=0.0;\n\t\tfloat A,A1,A2,A3,A4,A5,A6,A7,A8=0.0;\n\t\n\n\n\t// Snow layers, somewhat like an fbm with worley layers.\n\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\tA1 = 1.0-(A*0.8);\n\tN1 = smoothstep(0.9998,1.0,F1)*0.2*A1;\t\n\n\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*7.0);\t\n\tA2 = 1.0-(A*0.8);\n\tN2 = smoothstep(0.9998,1.0,F2)*0.3*A2;\t\t\t\t\n\n\tF3 = 1.0-cellular2x2((uv+(GA*0.3))*6.0);\t\n\tA3 = 1.0-(A*0.8);\n\tN3 = smoothstep(0.9998,1.0,F3)*0.4*A3;\t\t\t\n            \n    F4 = 1.0-cellular2x2((uv+(GA*0.4))*5.0);\t\n\tA4 = 1.0-(A*0.8);\n\tN4 = smoothstep(0.9998,1.0,F4)*0.5*A4;\t\n            \n    F5 = 1.0-cellular2x2((uv+(GA*0.5))*4.0);\t\n\tA5 = 1.0-(A*0.8);\n\tN5 = smoothstep(0.9998,1.0,F5)*0.6*A5;\t\n\t\t\t\t\t\t\t\t\n    F6 = 1.0-cellular2x2((uv+(GA*0.8))*3.0);\t\n\tA6 = 1.0-(A*0.8);\n\tN6 = smoothstep(0.9999,1.0,F6)*0.59*A6;\n    \n    F7 = 1.0-cellular2x2((uv+(GA*1.2))*2.9);\t\n\tA7 = 1.0-(A*0.8);\n\tN7 = smoothstep(0.9999,1.0,F7)*0.58*A7;\n    \n    F8 = 1.0-cellular2x2((uv+(GA*1.8))*2.8);\t\n\tA8 = 1.0-(A*0.8);\n\tN8 = smoothstep(0.9999,1.0,F8)*0.57*A8;\n   \n    \n    \n\t float cl= (N8+N7+N6+N5+N4+N3+N2+N1)*2.0;\n \n   \n    float tm=iTime/5.0;\n    \n   \n    \n    vec3 r = normalize(vec3(uv3, 1.3));//1.5\n    vec3 o = vec3(0.0, 0.0, -2.5);\n \n    mat3 xfm = yrot(-iMouse.x*0.01)*xrot(iMouse.y*0.01)*zrot(0.);\n    xfm *= xrot(0.4*tm*3.5);// unused !\n    o *= xfm;\n    r *= xfm;\n    float tt = trace(o, r);\n    vec3 w = o + r * tt;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    vec3 lpos = o-1.8*sin(tm)  ;// remove  \n    vec3 ldel = lpos - w;\n    float llen = length(ldel);\n    ldel /= llen;\n    vec3 refl = reflect(ldel, sn);\n    float prod = max(dot(ldel,sn), 1.5)*1.5;\n    float spow = max(dot(refl,r), 0.1);\n    vec4 diff = tex(w*0.4);//0.4\n    vec4 spec = vec4(0.0);\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 500.0);\n    vec4 fc = (diff * prod + spec * spow) * fog;\n    \n    //uv3.x = uv3.x+0.2*iTime;\n   \n      \n     \n    \n    \n     vec3 tx   = 2.*texture(iChannel2,uv).xyz;\n        \n     float txty = 2.0;\n     float txtx = -4.0;           \n       \n     float intensity =1.0;\n    \n    \n     uvs = uvs -0.5;\n    if (gtimer>=32.0) {intensity =0.1+abs(2.*sin(gtimer)*2.0);}\n   \n    if (gtimer>=34.0) {uvs.y += 0.5+2.2*sin(gtimer)*0.5;}\n    if (gtimer>=44.0) {uvs.x += 0.5+2.2*sin(gtimer)*0.8;}\n    if (gtimer>=64.0) {uvs.x -= 0.5+2.2*sin(-gtimer)*0.8;}\n    \n      \n      \n  float a  = shtoy((uvs*0.9*5.*abs(sin(iTime*0.8)))-vec2(txtx,txty-4.8));\n        a += shtoy((uvs*1.1*5.*abs(sin(iTime*0.7)))-vec2(txtx,txty-4.2));\n        a += shtoy((uvs*1.2*5.*abs(sin(iTime*0.6)))-vec2(txtx,txty-3.6));\n        a += shtoy((uvs*1.3*5.*abs(sin(iTime*0.5)))-vec2(txtx,txty-3.0));\n        a += shtoy((uvs*1.4*5.*abs(sin(iTime*0.4)))-vec2(txtx,txty-2.4));\n        a += shtoy((uvs*1.5*5.*abs(sin(iTime*0.3)))-vec2(txtx,txty-1.8));\n        a += shtoy((uvs*1.6*5.*abs(sin(iTime*0.2)))-vec2(txtx,txty-1.2));\n\n     \n    \n     \n     \n                      \n     float final = a ;\n        \n     fragColor    = vec4(mix(vec3(final*tx.r,final*tx.g,final*tx.b)*intensity,\n                             \n                             \n                             vec3(cl,cl,cl),cl),1.0); \n      \n     \n   // *** bar layer\n    \n    vec2 bl = fragCoord.xy / iResolution.xy;\n    \n    if(bl.y>.50-min(t/8.,0.4) ^^ bl.y<0.50+min(t/8.0,.4))  fragColor  = vec4(0.2,0.2,0.2,1.0);\n    \n     \n    \n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "4tjGRR", "previewfilepath": "https://soundcloud.com/mazstudios/maz-goa-dreams", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mazstudios/maz-goa-dreams", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtd3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 234, 281, 478], [588, 588, 609, 609, 662], [666, 666, 687, 687, 741], [747, 747, 768, 768, 822], [828, 828, 850, 850, 891], [895, 895, 917, 917, 966], [970, 970, 1000, 1000, 1057], [1063, 1063, 1087, 1087, 2008], [2014, 2014, 2043, 2043, 2843], [2901, 2901, 2921, 2921, 3005], [3006, 3006, 3026, 3026, 3110], [3112, 3112, 3132, 3132, 3216], [3219, 3219, 3254, 3254, 3280], [3282, 3282, 3300, 3300, 3456], [3460, 3460, 3491, 3491, 3586], [3588, 3588, 3628, 3628, 3667], [3668, 3668, 3704, 3704, 3807], [3808, 3808, 3826, 3826, 4204], [4205, 4205, 4226, 4226, 4398], [4399, 4399, 4428, 4428, 4557], [4559, 4559, 4577, 4577, 4663]], "test": "error"}
{"id": "wtd3zM", "name": "Hyperspace Tunnel, Simplex Noise", "author": "blue_max", "description": "Hyperspace Tunnel, v2.0. Using simplex noise to add more variety to the tunnel texture. See also: https://www.shadertoy.com/view/Wtd3Wr", "tags": ["tunnel", "hyperspace", "starwars"], "likes": 9, "viewed": 742, "published": "Public", "date": "1575957237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on theGiallo's https://www.shadertoy.com/view/MttSz2\n// MIT License. Use freely; but attribution is expected.\n#define TAU 6.28318\n#define PI 3.141592\nconst float period = 1.0;\nconst float speed  = 2.0;\nconst float rotation_speed = 0.3;\nconst float t2 = 4.0; // Length in seconds of the effect\n\n// This effect fades in and out of white every t2 seconds\n// Remove the next def to get an infinite tunnel instead.\n//#define WHITEOUT 1\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat fBm3(in vec3 p)\n{\n    //p += vec2(sin(iTime * .7), cos(iTime * .45))*(.1) + iMouse.xy*.1/iResolution.xy;\n\tfloat f = 0.0;\n\t// Change starting scale to any integer value...\n\tfloat scale = 5.0;\n    p = mod(p, scale);\n\tfloat amp   = 0.75;\n\t\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += simplexNoise(p * scale) * amp;\n\t\tamp *= 0.5;\n\t\t// Scale must be multiplied by an integer value...\n\t\tscale *= 2.0;\n\t}\n\t// Clamp it just in case....\n\treturn min(f, 1.0);\n}\n\n// From: https://www.shadertoy.com/view/4dBcWy\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(0.1666666666666667, 0.3333333333333333) ; // 1.0/6.0, 1.0/3.0\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// Original code ends here.\n\n\nfloat getnoise(int octaves, float persistence, float freq, vec3 coords) {\n\n    float amp= 1.; \n    float maxamp = 0.;\n    float sum = 0.;\n\n    for (int i=0; i < octaves; ++i) {\n\n        sum += amp * snoise(coords*freq); \n        freq *= 2.;\n        maxamp += amp;\n        amp *= persistence;\n    }\n    \n    return (sum / maxamp) * .5 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, t2);\n    t = t / t2; // Normalized time\n    \n    vec4 col = vec4(0.0);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p += vec2(0.0, -0.1);\n    \n    //float ay = TAU * mod(iTime, 8.0) / 8.0;\n    //ay = 45.0 * 0.01745;\n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    mat3 m = mX * mY;\n    \n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    float v_xy = length(v.xy);\n    float z = v.z / v_xy;\n    \n    // The focal_depth controls how \"deep\" the tunnel looks. Lower values\n\t// provide more depth.\n\tfloat focal_depth = 0.15;\n    #ifdef WHITEOUT\n    focal_depth = mix(0.15, 0.015, smoothstep(0.65, 0.9, t));\n    #endif\n    \n    vec2 polar;\n    //float p_len = length(p);\n    float p_len = length(v.xy);\n    //polar.y = focal_depth / p_len + iTime * speed;\n    polar.y = z * focal_depth + iTime * speed;\n    //polar.y = z;\n    float a = atan(v.y, v.x);\n    //float a = atan(q.y, q.x);\n    // atan returns a value in the range -PI to PI, let's normalize\n    // that into the range [0..1]\n    a = 0.5 + 0.5 * a / (1.0 * PI);\n    a -= iTime * rotation_speed;\n    float x = fract(a);\n    // Remove the seam by reflecting the u coordinate around 0.5:\n    if (x >= 0.5) x = 1.0 - x;\n    polar.x = x;\n    \n    // Colorize blue\n    float val = 0.45 + 0.55 * fBm3(\n        vec3(vec2(2.0, 0.5) * polar, 0.15 * iTime));\n    //float val = getnoise(8, 0.65, 1.0, vec3(polar, 0));\n    val = clamp(val, 0.0, 1.0);\n    col.rgb = vec3(0.15, 0.4, 0.9) * vec3(val);\n    \n    // Add white spots\n    vec3 white = 0.35 * vec3(smoothstep(0.55, 1.0, val));\n    col.rgb += white;\n    col.rgb = clamp(col.rgb, 0.0, 1.0);\n    \n    float w_total = 0.0, w_out = 0.0;\n    #ifdef WHITEOUT\n    // Fade in and out from white every t2 seconds\n    float w_in = 0.0;\n    w_in = abs(1.0 - 1.0 * smoothstep(0.0, 0.25, t));\n    w_out = abs(1.0 * smoothstep(0.8, 1.0, t));\n    w_total = max(w_in, w_out);\n    #endif\n    \n    \n    // Add the white disk at the center\n    float disk_size = max(0.025, 1.5 * w_out);\n    //disk_size = 0.001;\n    float disk_col = exp(-(p_len - disk_size) * 4.0);\n    //col.rgb += mix(col.xyz, vec3(1,1,1), disk_col);\n    col.rgb += clamp(vec3(disk_col), 0.0, 1.0);\n    \n    \n    #ifdef WHITEOUT\n    col.rgb = mix(col.rgb, vec3(1.0), w_total);\n    #endif\n    \n    fragColor = vec4(col.rgb,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtd3zM.jpg", "access": "shaders20k", "license": "mit", "functions": [[571, 571, 593, 593, 745], [747, 747, 775, 775, 1435], [1437, 1437, 1460, 1547, 1888], [1938, 1938, 1959, 1959, 2008], [2010, 2010, 2031, 2031, 2080], [2082, 2082, 2104, 2104, 2144], [2146, 2146, 2174, 2174, 2226], [2228, 2228, 2252, 2252, 4296], [4328, 4328, 4401, 4401, 4669], [4671, 4671, 4728, 4728, 7530]], "test": "ok"}
{"id": "wtdGDn", "name": "perspective renderer (WIP)", "author": "julianlumia", "description": "playing around with ways to use shaders for 3d projection mapping, The idea was to use this renderer to create immersive environments by projecting the POV points on different walls in a square room. \nGood feedback, tips are welcome for this project!:)", "tags": ["3d"], "likes": 6, "viewed": 117, "published": "Public", "date": "1576064579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat2 Rot (float a)\n\t\t{\n    \t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n            return mat2(c,-s,s,c);\n            \n\t\t}\n\n\nmat2 R;\nfloat T;\n\n\n\nfloat SceneSDF(vec3 p){\n\n    p.xz *= (Rot (cos(iTime)*1.));\n\n    float gap = 2.;\n    p.x = mod(p.x + gap,2.0 * gap) - gap;\n    p.y = mod(p.y + gap,2.0 * gap) - gap;\n    p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n    p *= vec3(1.,1.0,1.);\n    \n    float sphere = SphereSDF( p, .7);\n    \n    float cube = CubeSDF(p, vec3 (0.5));\n    \n\tfloat torus = TorusSDF(p, vec2(1.,.04));\n    \n    float cub = max(-sphere,cube);\n     cub = min(cub,torus);\n    \n    return cub;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 95; i++){\n        vec3 pos = eye + depth * marchingDirection;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\nmat4 viewMatrixRIGHT() {\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0,0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 viewMatrixDOWN() {\n    return mat4(\n        vec4(0, 0, 1, 0),\n        vec4(1,0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0)\n    );\n}\n\nmat4 viewMatrixLEFT() {\n    return mat4(\n         vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0,0, -1, 0),\n        vec4(0, 0, 0, -1)\n    );\n}\n\nmat4 viewMatrixUP() {\n    return mat4(\n          vec4(0,1, 0, 0),\n        vec4(0, 0, 1,0),\n        vec4(-1,0, 0,0),\n        vec4(0, 0,0,1)\n\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.3;\n    vec2 res = iResolution.xy;\n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag / res;\n    \n    vec3 rayDir;\n    vec3 worldDir;    \n    vec3 eye;\n    vec4 shortDist = vec4(0);\n\n    float movement;\n    movement = iTime *.1;\n    \n    \n    // the screen is cut up into different POV points here:\n    if( uv.x < 0.25){\n        \n        frag = fragCoord.xy;\n        res = vec2(res.x *  0.25, res.y);\n        rayDir = RayDirection(100.0, frag, res );\n\t\tworldDir = ( viewMatrixRIGHT() * vec4(rayDir,0.) ).xyz;\n       eye = vec3(0.0 + 0.0 * cos(t),\n                   movement*5. +0.0 * cos(t),\n                   0. + 0.0 * sin(t));\n        \n\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n   \n    \n    else if(  uv.x > 0.25 && uv.x < 0.5 ){\n        frag = fragCoord.xy;\n        res = vec2(res.x * .75, res.y);\n        rayDir = RayDirection(100.0, frag, res);\n\t\tworldDir = ( viewMatrixDOWN() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0. + 0.0 * cos(t),\n                (movement *5.)-3.5 + 0.0 * cos(t),\n                   0.0 + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n    \n       else if(  uv.x > 0.5 && uv.x < .75 ){\n        frag = fragCoord.xy;\n        res = vec2(res.x * 1.25, res.y);\n        rayDir = RayDirection(100.0, frag, res);\n\t\tworldDir = ( viewMatrixLEFT() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0. + 0.0 * cos(t),\n                movement *5. + 0.0 * cos(t),\n                   0.0 + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n\n     else if(  uv.x > 0.75 && uv.x < 1. ){\n        frag = fragCoord.xy ;\n        res = vec2(res.x *1.75, res.y);\n        rayDir = RayDirection(100.0, frag, res);\n\t\tworldDir = ( viewMatrixUP() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0. + 0.0 * cos(t),\n                movement *5. + 0.0 * cos(t),\n                 0. + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(130.0, 84.0, 72.0) / 255.0;\n    \n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n        finalColor = color;\n        \n        finalColor = finalColor * (diffuse + ambientColor);\n        \n        float distToEye = length(eye - pos);\n        finalColor = finalColor * remap(70.0, 20.0, 0.0, 1.0, distToEye);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 135, 135, 205], [208, 208, 235, 235, 382], [386, 386, 422, 422, 450], [452, 452, 485, 485, 688], [690, 690, 724, 724, 789], [791, 791, 813, 813, 910], [933, 933, 956, 956, 1397], [1399, 1399, 1428, 1428, 1738], [1740, 1740, 1804, 1804, 1932], [1934, 1934, 2023, 2023, 2431], [2433, 2433, 2457, 2457, 2585], [2587, 2587, 2610, 2610, 2738], [2740, 2740, 2763, 2763, 2894], [2896, 2896, 2917, 2917, 3044], [3048, 3048, 3105, 3105, 5968]], "test": "ok"}
{"id": "wtdGR4", "name": "Parallelograms", "author": "tombla", "description": "independent R-G-B functions", "tags": ["colors", "parallel"], "likes": 2, "viewed": 183, "published": "Public API", "date": "1576229549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= vec2(2000.0, 2000.0/iResolution.x*iResolution.y);\n    \n    float step = iTime * 100.0;\n    float blue = uv.x + uv.y + 1.25 * step;\n    blue = mod(blue, 256.0) / 256.0;\n    \n    float green = uv.y/2.0 + (1.0 + sin(step*3.0/8.0/60.0)) * uv.x / 2.0;\n    green = mod(green, 256.0) / 256.0;\n    \n    float red = 480.0 + (1.0+cos(step*0.75/90.0))*uv.x/2.0 - uv.y/2.0;\n    red = mod(red, 256.0) / 256.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(red, green, blue);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 682]], "test": "ok"}
{"id": "WtdGWB", "name": "Terrain Day/Night Cycle", "author": "Tara", "description": "My first shader here on shadertoy. It's not finished.", "tags": ["procedural", "3d", "raymarching", "raymarching", "terrain", "lighting", "cycle", "night", "day"], "likes": 7, "viewed": 211, "published": "Public", "date": "1577454019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO: Add linear space lighting!\n// TODO: Add little trees everywhere.\n// TODO: Maybe animate day/night cycle.\n// TODO: Add a moon with light.\n// Could we place the camera on the mountains and make it look into the sky?\n// TODO: Implement a mode that shows the different effects side by side.\n// TODO: Implement max view distance (used for fog and ray marching).\n// TODO: Step out of terrain using binary search.\n// TODO: Use a more detailed height function only for shading (like for computing normals)! Ray march simpler geometry.\n// TODO: Don't fade to black! Just use some ambient lighting.\n\n// Settings:\nconst float gamma = 2.2;\n\nconst float max_view_distance = 10.0;\n\n//const vec3 light_direction = normalize(vec3(0.5, 0.25, 0.25));\nconst float time_scale = 0.25;\n\n//const vec3 sky_color = vec3(0.3, 0.7, 0.9);\nconst vec3 sky_color_noon = vec3(0.3, 0.7, 0.9);\nconst vec3 sky_color_evening = vec3(0.5, 0.3, 0.1);\nconst vec3 sky_color_night = vec3(0.1, 0.05, 0.15) * 2.0;\n\n//vec3 light_color = vec3(1.0, 0.5, 0.2) * light_color_blend_factor;\nconst vec3 light_color_noon = vec3(1.0, 0.5, 0.2);\nconst vec3 light_color_evening = vec3(0.8, 0.1, 0.05);\nconst vec3 light_color_night = vec3(0.0);\n\nconst vec3 moon_color = vec3(0.05, 0.1, 0.1);\n\n\nconst float fog_strength = 0.11;\nconst float fog_exponent = 2.5;\n\nconst float water_height = 0.8;\n\nconst float terrain_height_multiplicator = 6.0;\n\n\n\nfloat adjusted_time;\nfloat adjusted_time_for_sun;\n\nvec3 light_direction;\nfloat light_exponent;\n\nfloat is_day;\n\nfloat noon_night_factor;\t// 1.0 = noon, 0.0 = night\nfloat noon_evening_factor;\t// 1.0 = noon, 0.0 = evening\n\nvec3 light_color;\nvec3 sky_color;\n\nvec2 fragCoord;\n\nconst int coordinate_count =  64;\nvec3 coordinates[coordinate_count];\n\n\nvoid initialize_global_variables(vec2 pFragCoord)\n{\n    // Initialize the array (since WebGL doesn't allow array initializers):\n    coordinates[ 0 ] = vec3( -0.435885996181 , 0.79720633541 , 0.0972253052385 );\n    coordinates[ 1 ] = vec3( -0.32218308746 , 0.100646505563 , 0.582645225292 );\n    coordinates[ 2 ] = vec3( 0.587014777685 , 0.41111934478 , 0.547503737761 );\n    coordinates[ 3 ] = vec3( -0.192455452266 , 0.321063732913 , 0.668652567224 );\n    coordinates[ 4 ] = vec3( -0.259779617945 , 0.909626864008 , 0.0836824717262 );\n    coordinates[ 5 ] = vec3( 0.348649506252 , 0.103790885936 , 0.904378113197 );\n    coordinates[ 6 ] = vec3( -0.542650115811 , 0.0736718130349 , 0.397151757271 );\n    coordinates[ 7 ] = vec3( -0.474716167394 , 0.118343120088 , 0.570445920116 );\n    coordinates[ 8 ] = vec3( -0.836441325058 , 0.171629770526 , 0.0597544063084 );\n    coordinates[ 9 ] = vec3( 0.0824315685125 , 0.505680845825 , 0.662611320344 );\n    coordinates[ 10 ] = vec3( 0.516123186703 , 0.55815762739 , 0.411018332295 );\n    coordinates[ 11 ] = vec3( -0.724799879376 , 0.423272250814 , 0.448164544035 );\n    coordinates[ 12 ] = vec3( -0.0110437238687 , 0.0904558337167 , 0.231594212451 );\n    coordinates[ 13 ] = vec3( 0.546531423419 , 0.321583514112 , 0.512659552736 );\n    coordinates[ 14 ] = vec3( 0.368589954248 , 0.0182021895091 , 0.880833172129 );\n    coordinates[ 15 ] = vec3( 0.47525253334 , 0.271287592025 , 0.000334496440065 );\n    coordinates[ 16 ] = vec3( 0.44673660601 , 0.132552497011 , 0.340585192841 );\n    coordinates[ 17 ] = vec3( -0.403804494418 , 0.0104325320551 , 0.159902664933 );\n    coordinates[ 18 ] = vec3( -0.338579360521 , 0.716322524047 , 0.542091484806 );\n    coordinates[ 19 ] = vec3( 0.308210916814 , 0.743567127819 , 0.472326208485 );\n    coordinates[ 20 ] = vec3( 0.814788310063 , 0.449353375014 , 0.340846719572 );\n    coordinates[ 21 ] = vec3( -0.544006155176 , 0.711118594385 , 0.132489899091 );\n    coordinates[ 22 ] = vec3( -0.114345207769 , 0.0808582423255 , 0.0592533221037 );\n    coordinates[ 23 ] = vec3( -0.0956105901715 , 0.886967062617 , 0.296750041926 );\n    coordinates[ 24 ] = vec3( 0.125465786235 , 0.249375761939 , 0.39086839732 );\n    coordinates[ 25 ] = vec3( -0.507001597684 , 0.478280151596 , 0.442128006659 );\n    coordinates[ 26 ] = vec3( 0.767372362554 , 0.34981180972 , 0.216480512037 );\n    coordinates[ 27 ] = vec3( 0.729037025717 , 0.488650315003 , 0.0447790563882 );\n    coordinates[ 28 ] = vec3( 0.545055293632 , 0.328506679918 , 0.0161990255662 );\n    coordinates[ 29 ] = vec3( 0.0613031135758 , 0.891064511104 , 0.391832390956 );\n    coordinates[ 30 ] = vec3( 0.490558372066 , 0.237016279151 , 0.0603644616935 );\n    coordinates[ 31 ] = vec3( 0.0670590641368 , 0.150548596978 , 0.496247392186 );\n    coordinates[ 32 ] = vec3( 0.342684862582 , 0.682876750055 , 0.151397259036 );\n    coordinates[ 33 ] = vec3( -0.651487774333 , 0.201712081807 , 0.246829681649 );\n    coordinates[ 34 ] = vec3( 0.561837936205 , 0.251550371306 , 0.355580475726 );\n    coordinates[ 35 ] = vec3( 0.192999232894 , 0.392428615732 , 0.0121078124268 );\n    coordinates[ 36 ] = vec3( -0.105851736143 , 0.163824018243 , 0.236916795307 );\n    coordinates[ 37 ] = vec3( -0.0611750509214 , 0.224873171348 , 0.617895466387 );\n    coordinates[ 38 ] = vec3( -0.109924322491 , 0.508071654989 , 0.505581327183 );\n    coordinates[ 39 ] = vec3( -0.706387045519 , 0.0671452123745 , 0.459796670999 );\n    coordinates[ 40 ] = vec3( -0.278160406844 , 0.289551453062 , 0.160872443354 );\n    coordinates[ 41 ] = vec3( 0.516576843643 , 0.817085834323 , 0.190027033479 );\n    coordinates[ 42 ] = vec3( -0.0942554687146 , 0.878813661213 , 0.214972046973 );\n    coordinates[ 43 ] = vec3( -0.221374373075 , 0.803633365667 , 0.299755346538 );\n    coordinates[ 44 ] = vec3( -0.299462216003 , 0.0720235031843 , 0.36211897975 );\n    coordinates[ 45 ] = vec3( 0.553343181571 , 0.493244437329 , 0.164447492472 );\n    coordinates[ 46 ] = vec3( -0.20136124794 , 0.0760260274291 , 0.534534862455 );\n    coordinates[ 47 ] = vec3( 0.905190222495 , 0.0807321460953 , 0.39235689531 );\n    coordinates[ 48 ] = vec3( -0.728666867176 , 0.38048529455 , 0.226800106991 );\n    coordinates[ 49 ] = vec3( -0.527457489355 , 0.367359870805 , 0.286014828375 );\n    coordinates[ 50 ] = vec3( 0.325761364504 , 0.470935422995 , 0.770885656739 );\n    coordinates[ 51 ] = vec3( -0.511384831071 , 0.50189485858 , 0.565409920223 );\n    coordinates[ 52 ] = vec3( -0.518815864857 , 0.0632066994837 , 0.405086346674 );\n    coordinates[ 53 ] = vec3( 0.115312716748 , 0.105398362421 , 0.954708709816 );\n    coordinates[ 54 ] = vec3( -0.285700995513 , 0.0113348478119 , 0.4620339652 );\n    coordinates[ 55 ] = vec3( -0.0374130136703 , 0.630623418764 , 0.577124020836 );\n    coordinates[ 56 ] = vec3( 0.193453243995 , 0.355055361228 , 0.123825538219 );\n    coordinates[ 57 ] = vec3( 0.681642806219 , 0.522843493246 , 0.489964036509 );\n    coordinates[ 58 ] = vec3( -0.294839413327 , 0.557820363593 , 0.351222001041 );\n    coordinates[ 59 ] = vec3( 0.577147207709 , 0.463873007553 , 0.356984090391 );\n    coordinates[ 60 ] = vec3( -0.700910394348 , 0.213528376537 , 0.0842103964106 );\n    coordinates[ 61 ] = vec3( -0.62990341948 , 0.559561713285 , 0.460576905302 );\n    coordinates[ 62 ] = vec3( -0.097357826252 , 0.707750175458 , 0.258790836913 );\n    coordinates[ 63 ] = vec3( -0.638795681624 , 0.467053715637 , 0.308126560401 );\n    \n    // Initialize the other variables:\n    fragCoord = pFragCoord;\n    \n\tadjusted_time = iTime * time_scale;\n    //adjusted_time = 1.2;\t// Static value for debugging purposes.\n    \n\tadjusted_time_for_sun = mod(adjusted_time, 3.1415926535897932384626433832795);\n\n\tlight_direction = normalize(vec3(cos(adjusted_time_for_sun) * 2.0, sin(adjusted_time_for_sun) * 2.0, 1.5));\n\tlight_exponent = 2.0;\n\n\tis_day = step(0.0, sin(adjusted_time));\n\t\n\t\n\t\t\n\t//noon_night_factor = sin(adjusted_time) * 0.5 + 0.5;\t// 1.0 = noon, 0.0 = night\n\t\n\tnoon_evening_factor = max(sin(adjusted_time), 0.0);\t// 1.0 = noon, 0.0 = evening\n\tnoon_night_factor = noon_evening_factor * noon_evening_factor;\t// 1.0 = noon, 0.0 = night\n\n\tlight_color = mix(light_color_night, mix(light_color_evening, light_color_noon, noon_evening_factor), noon_night_factor);\n\tsky_color = mix(sky_color_night, mix(sky_color_evening, sky_color_noon, noon_evening_factor), noon_night_factor);\n\n\t// Turn the sun into a moon:\n\tlight_color = mix(moon_color, light_color, is_day);\n\t//sky_color = mix(moon_color, sky_color, is_day);\n    \n    // This is used to darken the light at sunset and sunrise to\n    // make the transition between sun and moon less obvious.\n    //const float threshold = 0.2;\n    float light_brightness = pow(abs(sin(adjusted_time_for_sun)), 0.5);\n    \n\t//sky_color *= light_brightness;\n\tlight_color *= light_brightness;\n}\n\n\n\n//vec3 light_color = mix(light_color_evening, light_color_day, light_color_blend_factor);\n\n\n\nmat3 construct_around_vector(vec3 vector)\n{\n\tvec3 smallest_component_vector;\n\n\tif((abs(vector.x) < abs(vector.y))&&(abs(vector.x) < abs(vector.z)))\t// TODO: PERFORMANCE: The \"abs()\" calls could be pretty slow! Use squared values instead? Or do two checks per value?\n\t{\n\t\tsmallest_component_vector = vec3(1.0, 0.0, 0.0);\n\t}\n\telse if(abs(vector.y) < abs(vector.z))\n\t{\n\t\tsmallest_component_vector = vec3(0.0, 1.0, 0.0);\n\t}\n\telse\n\t{\n\t\tsmallest_component_vector = vec3(0.0, 0.0, 1.0);\n\t}\n\n\t// TODO: PERFORMANCE: Is this a way to avoid computing two cross products? http://stackoverflow.com/questions/19337314/generate-random-point-on-a-2d-disk-in-3d-space-given-normal-vector\n\t// TODO: PERFORMANCE: The cross product with \"smallest_component_vector\" can be simplified, because two components are always zero.\n\n\tvec3 vector_x = normalize(cross(vector, smallest_component_vector));\t// We must to normalize the result here, because the two vectors are not orthogonal.\n\tvec3 vector_z = cross(vector_x, vector);\t// The two vectors are orthogonal unit vectors, that's why no normalization is required.\n\n\treturn(mat3(vector_x, vector, vector_z));\n}\n\n\nvec3 to_linear_space(vec3 color)\n{\n\treturn(pow(color, vec3(gamma)));  \n}\n\nvec3 to_gamma_space(vec3 color)\n{\n\treturn(pow(color, vec3(1.0 / gamma)));\n}\n\nfloat hash(vec2 P)\n{\n\t// gridcell is assumed to be an integer coordinate\n\t\n\t//const vec2 OFFSET = vec2(16.0, 19.0);\n\t\n\t//const vec2 OFFSET = vec2(166.0, 19.0);\n\t//const float DOMAIN = 4.0;\n\t\n\tconst vec2 OFFSET = vec2(131.0, 149.0);\n\tconst float DOMAIN = 16.0;\n\t\n\t/*\n\tconst vec2 OFFSET = vec2(124.0, 326.0);\n\tconst float DOMAIN = 8.0;\n\t*/\n\tconst float DOMAIN_SQUARED = DOMAIN * DOMAIN;\n\tconst float SOMELARGEFLOAT = 1.0 / 951.135664;\n\n\tP = mod(P, DOMAIN);\t// truncate the domain (same as the above)\n\tP += OFFSET.xy;\t// offset to interesting part of the noise\n\tP *= P;\t// calculate and return the hash\n\t\n\treturn(fract(P.x * P.y * SOMELARGEFLOAT));\n}\n\n\nfloat mod289(float x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod289(vec4 x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 perm(vec4 x)\n{\n\treturn(mod289(((x * 34.0) + 1.0) * x));\n}\n\nfloat noise_3d(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return(o4.y * d.y + o4.x * (1.0 - d.y));\n}\n\nfloat noise(vec3 p)\n{\n    p.y = 0.0;\n    \n    return(noise_3d(p));\n}\n\nfloat detailed_noise_flat(vec2 p)\n{\n\t//return(noise(p));\n    p *= 0.3;\n\t\n\tvec3 p3 = vec3(p.x, 0.0, p.y);\n    \n\t/*\n\tfloat n = (//noise(p3) +\n\t\t\t0.5 * noise(p3 * 2.0) +\n\t\t\t0.25 * noise(p3 * 4.0) +\n\t\t\t0.125 * noise(p3 * 8.0) +\n\t\t\t0.0625 * noise(p3 * 16.0) +\n\t\t\t0.03125 * noise(p3 * 32.0)\n\t\t\t//+ 0.015625 * noise(p3 * 64.0)\n    \t\t);\n    \n    */\n    /*\n\tfloat n = (//noise(p3) +\n       \t\t//-0.8 * noise(p3 * 0.5) + \t// Large scale variation.\n\t\t\t0.2 * pow(1.0 + noise(p3 * 2.0), 1.5) +\n\t\t\t0.1 * pow(1.0 + noise(p3 * 4.0), 1.5) +\n\t\t\t0.125 * noise(p3 * 8.0) +\n\t\t\t0.0625 * noise(p3 * 16.0) +\n\t\t\t0.03125 * noise(p3 * 32.0)\n\t\t\t//+ 0.015625 * noise(p3 * 64.0)\n    \t\t);\n    */\n    \n    float val1 = noise(p3 * 1.0);\n        \n\tfloat n = (\n       \t\t -0.2 * noise(p3 * 0.25) + \t// Large scale variation.\n\t\t\t0.5 * pow(noise(p3 * 1.0), 2.0) +\n\t\t\t+ 0.5 * pow(noise(p3 * 0.5 + 0.25), 2.0)+\n\t\t\t0.25 * noise(p3 * 4.0) +\n\t\t\t0.125 * noise(p3 * 8.0)*val1 +\n\t\t\t0.0625 * noise(p3 * 16.0)* (1.0 - val1) +\n\t\t\t0.03125 * noise(p3 * 32.0) * (1.0 - val1) +\n\t\t\t0.015 * noise(p3 * 64.0) * pow(1.0 - val1, 1.5)\t/// Only add this to the lower layers.\n    \t\t);\n    \n    \n    return(n);\n}\n\nfloat detailed_noise_3d(vec3 p)\n{\n    p *= 0.3;\n    \n    float val1 = noise_3d(p);\n        \n\tfloat n = (\n       \t\t -0.2 * noise_3d(p * 0.25) + \t// Large scale variation.\n\t\t\t0.5 * pow(noise_3d(p * 1.0), 2.0) +\n\t\t\t+ 0.5 * pow(noise_3d(p * 0.5 + 0.25), 2.0)+\n\t\t\t0.25 * noise_3d(p * 4.0) +\n\t\t\t0.125 * noise_3d(p * 8.0)*val1 +\n\t\t\t0.0625 * noise_3d(p * 16.0)* (1.0 - val1) +\n\t\t\t0.03125 * noise_3d(p * 32.0) * (1.0 - val1) +\n\t\t\t0.015 * noise_3d(p * 64.0) * pow(1.0 - val1, 1.5)\t/// Only add this to the lower layers.\n    \t\t);\n    \n    \n    return(n);\n}\n\nfloat detailed_noise(vec3 p)\n{\n\treturn(detailed_noise_flat(p.xz));\n}\n\nfloat camera_noise(vec3 p)\n{\n\t//return(noise(p));\n    p *= 0.3;\n    \n\t\n\tfloat n = (\n\t\t\t0.5 * noise(p * 2.0) +\n\t\t\t0.25 * noise(p * 4.0) +\n\t\t\t0.125 * noise(p * 8.0)\n    \t\t);\n    \n    return(n);\n}\n/*\nfloat noise1(vec3 p)\n{\n\t//return(noise(p));\n    p *= 0.01;\n    \n\t\n\tfloat n = 0.5 * noise(p * 2.0);\n    \n    return(n * n * n * n * 4.0);\n}\n*/\nfloat calculate_shadow(vec3 start_position, vec3 light_direction, float max_distance)\n{\n    const float step_size = 0.15;\n    light_direction *= step_size;\n    \n    float occlusion_factor = 1.0;\n    float travelled_distance = 0.0;\n\tconst float k = 4.0;\t// Higher value = harder shadows\n    \n    for(int i=0; i<32; ++i)\n    {\n\t\tstart_position += light_direction;\n        travelled_distance += step_size;\n\t\t\n        float sample_height = detailed_noise_flat(start_position.xz) * terrain_height_multiplicator;\n        \n        float distance_to_surface = start_position.y - sample_height;\t// This is just an approximation!\n\n\t\tocclusion_factor = min(occlusion_factor, k * distance_to_surface / travelled_distance);\n        \n        // Early exit:\n        if(distance_to_surface < 0.0)\n        {\n        \tbreak;   \n        }\n    }\n    \n    return(max(occlusion_factor, 0.0));\n}\n\nvec3 generate_random_coordinate_in_hemisphere(float random1, float random2, float random3)\n{\n\t// TODO: Use my approach from the path tracer instead?\n\t\n    float phi = 6.283185307179586476925286766559 * random1;\n\tfloat costheta = random2;\n\tfloat theta = acos(costheta);\n\t\n\tvec3 p;\n\t\n\tp.x = sin(theta) * cos(phi);\n\tp.y = sin(theta) * sin(phi);\n\tp.z = cos(theta);\n\n\tp.y = abs(p.y);\t// Mirror along Y so we sample a hemisphere instead of a sphere.\n\n\tfloat r = pow(random3, 1.0 / 3.0);\n\t\n\tp *= r;\n        \n    return(p);\n}\n\n\nvec3 get_next_on_sphere2(float random1, float random2, float random3)\n{\n    float phi = 6.283185307179586476925286766559 * random1;\n\tfloat costheta = random2;\n\tfloat theta = acos(costheta);\n\t\n\tvec3 p;\n\tp.x = sin(theta) * cos(phi);\n\tp.y = sin(theta) * sin(phi);\n\tp.z = cos(theta);\n\n\tfloat r = pow(random3, 1.0 / 3.0);\n\t\n\tp *= r;\n        \n    return(p);\n}\n\t\nvec3 get_next_on_sphere(float random1, float random2)\n{\n    vec3 vector;\n\n    vector.z = random1 * 2.0 - 1.0;\n    float theta = random2 * 6.283185307179586476925286766559;\n    float temp = sqrt(1.0 - vector.z * vector.z);\n\n    vector.x = temp * cos(theta);\n    vector.y = temp * sin(theta);\n\n    //return(normalize(vector));\t// TODO: PERFORMANCE: Does this vector need to be normalized?\n    return(vector);\t// TODO: PERFORMANCE: Does this vector need to be normalized?\n}\n\nvec3 generate_random_coordinate_in_hemisphere2(vec3 normal, float random1, float random2, float random3)\n{\n    //vec3 vector = get_next_on_sphere(random1, random2);\n    vec3 vector = get_next_on_sphere2(random1, random2, random3);\n    \n    //vector.y = abs(vector.y);\n    \n   // vector *= pow(random3, 1.0 / 3.0)\n        \n    float sign_multiplicator = 1.0 - 2.0 * step(dot(normal, vector), 0.0);\t// Compute the sign of the dot product (without branching). Results in either \"-1.0f\" or \"1.0f\".\n    \n    // TODO: Theoretically this needs a fourth random number!\n    sign_multiplicator *= pow(random3, 1.0 / 3.0);\t// This makes the distribution uniform inside the hemisphere.\n    \n    vector *= sign_multiplicator;\t// Flip the sign if neccessary, so we sample the hemisphere instead.\n   \n            \n    return(vector);\n}\n\n\nvec3 calculate_colored_ambient_occlusion3(vec3 start_position, vec3 normal, float max_distance,\n                                          vec3 light_direction, vec3 light_color, vec3 sky_color)\n{\n    const float radius = 1.5;\n    const float step_size = 0.1;\n   \n\t\n    float random = hash(fragCoord.xy);\n    \n    /*\n    // Add a random offset per pixel, so the AO banding disappears.\n    vec3 hash_coordinate = floor(start_position * 1024.0);\n    start_position.x += (hash(hash_coordinate.yx) - 0.5) * radius * 0.5;\n    start_position.y += (hash(hash_coordinate.xz) - 0.5) * radius * 0.5;\n    start_position.z += (hash(hash_coordinate.zy) - 0.5) * radius * 0.5;\n    */\n    \n    // TODO: We could take the sky color and light direction into account to calculate colored AO.\n    \n\n        \n    //float center_height = detailed_noise_flat(start_position.xz);\n    \n\tvec3 occlusion_sum = vec3(0.0);\n\tfloat sample_count = 0.0;\n    \n\t\n    /*\n    for(int x=-radius; x<=radius; ++x)\n    for(int y=0; y<=radius; ++y)\n    for(int z=-radius; z<=radius; ++z)\n        */\n    \n    vec3 unoccluded_direction = vec3(0.0);\n    \n    //const int samples = 5;\n    \n    float blend_factor_sum = 0.0;\n    float sky_visibility = 0.0;\n    float horizon_occlusion_sum = 0.0;\n    \n    float smallest_horizon = 9999.9;\n    \n    //const int samples = coordinate_count;\n    const int samples = 1;\n    \n    for(int x=-samples; x<=samples; ++x)\n    for(int z=-samples; z<=samples; ++z)\n    {\n        if((z == 0)&&(x == 0))\n        {\n            continue;\n        }\n        \n      \t// TODO: Exclude center sample!\n        \n        float normalized_hash_offset = float(x) / float(samples);\n        float random1 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 7.0);\n        float random2 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 13.0);\n        float random3 = fract(random + (normalized_hash_offset + 0.7692307692307692307692307692308) * 19.0);\n        \n        //random1 = random2 = random3;\n        \n        \n        vec3 sample_offset = vec3(float(x) * step_size, 0.0, float(z) * step_size);\n        \n        \n        \n        float angle = random * 1.5707963267948966192313216916398;\t// Rotate only by 180ÃÂ° because that's enough since we're sampling using a symmetric.\n        float cs = cos(angle);\n        float sn = sin(angle);\n        \n        float rotated_x = sample_offset.x * cs - sample_offset.z * sn; // now x is something different than original vector x\n\t\tfloat rotated_z = sample_offset.x * sn + sample_offset.z * cs;\n        \n        sample_offset.x = rotated_x;\n        sample_offset.z = rotated_z;\n        \n        \n        \n        \n        \n        vec3 sample_coordinate = start_position + sample_offset;\n        sample_coordinate.y = detailed_noise_flat(sample_coordinate.xz) * terrain_height_multiplicator;\n        \n        vec3 sample_coordinate2 = start_position - sample_offset;\n        sample_coordinate2.y = detailed_noise_flat(sample_coordinate2.xz) * terrain_height_multiplicator;\n        \n        \n        \n        vec3 center_to_sample = sample_coordinate - start_position;\n        \n        vec3 n_center_to_sample = normalize(center_to_sample);\n        float cosine = dot(n_center_to_sample, normal);\t// max() not required since we're sampling a hemisphere.\n        \n        float color_blend_factor = max(dot(n_center_to_sample, light_direction), 0.0);\n        color_blend_factor = pow(color_blend_factor, light_exponent);\n        \n        vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n                \n        float sample_weight = cosine;\n        sample_weight = 1.0;\n        \n        float squared_radius = radius * radius;\n\t\tfloat squared_distance = dot(center_to_sample, center_to_sample);\n        sample_weight = max(0.0, 1.0 - squared_distance / squared_radius);\t// Falloff to zero towards \"radius\".\n        \n        sample_weight *= cosine;\t// max() not required since we're sampling a hemisphere.\n        \n        sample_weight = 1.0;\n        \n        // Crytek's method:\n        float sample_unoccluded = step(sample_coordinate.y, start_position.y);\t// 1.0 if unoccluded, 0.0 if occluded.\n       \tvec3 sample_occlusion = sample_color * sample_unoccluded;\n        \n        \n        sample_weight = sample_unoccluded;\n        unoccluded_direction += n_center_to_sample * sample_weight;\n        \n\n        \n        color_blend_factor *= sample_unoccluded;\t// No sun in occluded areas!\n        \n        \n        blend_factor_sum += color_blend_factor * sample_weight;\n        sky_visibility += sample_unoccluded * sample_weight;\n        \n        \n\t\tocclusion_sum += sample_color * sample_unoccluded * sample_weight;\n\t\t//occlusion_sum += sample_occlusion * sample_weight;\n\t\t\n        \n        \n        ////////////////////////////////////////////\n        sample_weight = 1.0;\n        //sample_weight = sample_unoccluded;\n        \n        //vec3 n_center_to_sample = normalize(center_to_sample);\n        vec3 center_to_sample2 = sample_coordinate2 - start_position;\n        vec3 n_center_to_sample2 = normalize(center_to_sample2);\n        \n        float horizon = dot(n_center_to_sample, n_center_to_sample2) * 0.5 + 0.5;\n        horizon = max(dot(n_center_to_sample, -n_center_to_sample2), 0.0);\n        \n        horizon_occlusion_sum += horizon;\n        \n        smallest_horizon = min(smallest_horizon, horizon);\n        ////////////////////////////////////////////\n        \n        \n        \n        sample_count += sample_weight;\n    }\n\t\n    horizon_occlusion_sum /= sample_count;\n    \n\tocclusion_sum /= sample_count;\n\tsky_visibility /= sample_count;\n    blend_factor_sum /= sample_count;\n    \n    \n    //return(vec3(smallest_horizon));\n    return(vec3(horizon_occlusion_sum));\n    \n   \n    unoccluded_direction = normalize(unoccluded_direction / sample_count);\n    \n    return(vec3(max(dot(unoccluded_direction, -light_direction), 0.0)));\n    \n    //return(vec3(max(dot(unoccluded_direction, normal), 0.0)));\n    return(unoccluded_direction * 0.5 + vec3(0.5));\n    \n    /*\n    float color_blend_factor = max(dot(unoccluded_direction, light_direction), 0.0);\n    color_blend_factor = pow(color_blend_factor, light_exponent);\n    vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n\n    occlusion_sum = sample_color;\n    */\n    \n    //occlusion_sum = normal * 0.5 + vec3(0.5);\n    //occlusion_sum = vec3(normal.y);\n    \n   \t//blend_factor_sum = pow(blend_factor_sum, light_exponent);\n    \n    //return(occlusion_sum);\n    \n    \n    return(vec3(sky_visibility));\n    //return(vec3(blend_factor_sum));\n    \n    vec3 indirect_light = mix(sky_color, light_color, blend_factor_sum);\t// Calculate light color\n   \tindirect_light *= sky_visibility;\t// Add sky occlusion\n    \n    return(indirect_light);\n    \n    \n    return(vec3(occlusion_sum));\n}\n\nvec3 calculate_colored_ambient_occlusion(vec3 start_position, vec3 normal, float max_distance,\n                                          vec3 light_direction, vec3 light_color, vec3 sky_color)\n{\n    const float radius = 1.5;\n    \n\tmat3 normal_matrix = construct_around_vector(normal);\n\t\n\tmat4 hemisphere_matrix = mat4(vec4(normal_matrix[0], 0.0),\n                                  vec4(normal_matrix[1], 0.0),\n                                  vec4(normal_matrix[2], 0.0),\n                                  vec4(start_position, 1.0));\n    // TODO: Improve this randomization!\n\t\n    float random = hash(fragCoord.xy);\n    float random1 = random;\n    float random2 = hash(fragCoord.xy * 16.0 + 16.0);\n    float random3 = hash(fragCoord.xy * 32.0 + 32.0);\n    \n    /*\n    // Add a random offset per pixel, so the AO banding disappears.\n    vec3 hash_coordinate = floor(start_position * 1024.0);\n    start_position.x += (hash(hash_coordinate.yx) - 0.5) * radius * 0.5;\n    start_position.y += (hash(hash_coordinate.xz) - 0.5) * radius * 0.5;\n    start_position.z += (hash(hash_coordinate.zy) - 0.5) * radius * 0.5;\n    */\n    \n    // TODO: We could take the sky color and light direction into account to calculate colored AO.\n    \n\n        \n    //float center_height = detailed_noise_flat(start_position.xz);\n    \n\tvec3 occlusion_sum = vec3(0.0);\n\tfloat sample_count = 0.0;\n    \n\t\n    /*\n    for(int x=-radius; x<=radius; ++x)\n    for(int y=0; y<=radius; ++y)\n    for(int z=-radius; z<=radius; ++z)\n        */\n    \n    vec3 unoccluded_direction = vec3(0.0);\n    \n    //const int samples = 5;\n    \n    float blend_factor_sum = 0.0;\n    float sky_visibility = 0.0;\n    \n    //const int samples = coordinate_count;\n    const int samples = 16;\n    for(int i=0; i<samples; ++i)\n    {\n        /*\n        float x = 1.0 - 2.0 / float(samples) * float(i);\n        float y = mod(1.0 - 2.0 / float(samples) * float(i * 2), 1.0);\n        float z = mod(1.0 - 2.0 / float(samples) * float(i * 4), 1.0);\n        */\n        \n       \n        /*\n        const float pi = 3.1415926535897932384626433832795;\n        const float _2pi = 6.283185307179586476925286766559;\n        \n        float factor = 1.0 / float(samples) * float(i);\n        \n        vec3 random_coordinate;\n        random_coordinate.x = sin((random1 + factor) * _2pi);\n        random_coordinate.y = abs(sin((random2 + factor) * _2pi));\n        random_coordinate.z = cos((random1 + factor) * _2pi);\n        \n        random_coordinate *= random3 * radius;\n        \n\t\tvec3 sample_coordinate = (hemisphere_matrix * vec4(random_coordinate, 1.0)).xyz;\n        */\n        \n        \n        /*\n        vec3 random_coordinate = coordinates[i];\n        \n        \n        float angle = random1 * 6.283185307179586476925286766559 + float(i) * float(samples);\n        float cs = cos(angle);\n        float sn = sin(angle);\n        \n        float x = random_coordinate.x * cs - random_coordinate.z * sn; // now x is something different than original vector x\n\t\tfloat z = random_coordinate.x * sn + random_coordinate.z * cs;\n        \n        random_coordinate.x = x;\n        random_coordinate.z = z;\n\n        random_coordinate *= radius;\n       \n\t\tvec3 sample_coordinate = (hemisphere_matrix * vec4(random_coordinate, 1.0)).xyz;\n        */\n        \n        \n        /*\n        float hash_offset = float(i);\n        float normalized_hash_offset = float(i) / float(samples);\n        float random1 = hash(fragCoord.xy + hash_offset * 3.0);\n        float random2 = hash(fragCoord.xy * 7.0 + hash_offset * 13.0);\n        float random3 = hash(fragCoord.xy * 13.0 + hash_offset * 21.0);\n        \n        random1 = fract(random1 + normalized_hash_offset);\n        random2 = fract(random2 + normalized_hash_offset);\n        random3 = fract(random3 + normalized_hash_offset);\n        */\n        \n        float normalized_hash_offset = float(i) / float(samples);\n        float random1 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 7.0);\n        float random2 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 13.0);\n        float random3 = fract(random + (normalized_hash_offset + 0.7692307692307692307692307692308) * 19.0);\n        \n        //random1 = random2 = random3;\n        \n        vec3 sample_coordinate = start_position + generate_random_coordinate_in_hemisphere2(normal, random1, random2, random3) * radius;\n        \n        \n        \n        \n        float sample_height = detailed_noise_flat(sample_coordinate.xz) * terrain_height_multiplicator;\n        \n        //vec3 sample_position = vec3(sample_coordinate.x, sample_height, sample_coordinate.z);\n      \n        //float color_blend_factor = dot(normal, light_direction) * 0.5 + 0.5;\n        \n        //float color_blend_factor = max(dot(normal, light_direction), 0.0);\n        \n        vec3 center_to_sample = sample_coordinate - start_position;\n        \n        vec3 random_direction = normalize(center_to_sample);\n        float cosine = dot(random_direction, normal);\t// max() not required since we're sampling a hemisphere.\n        \n        float color_blend_factor = max(dot(random_direction, light_direction), 0.0);\n        color_blend_factor = pow(color_blend_factor, light_exponent);\n        \n        vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n                \n        float sample_weight = cosine;\n        sample_weight = 1.0;\n        \n        float squared_radius = radius * radius;\n\t\tfloat squared_distance = dot(center_to_sample, center_to_sample);\n        sample_weight = max(0.0, 1.0 - squared_distance / squared_radius);\t// Falloff to zero towards \"radius\".\n        \n        sample_weight *= cosine;\t// max() not required since we're sampling a hemisphere.\n        \n        // Crytek's method:\n        float sample_unoccluded = step(sample_height, sample_coordinate.y);\t// 1.0 if unoccluded, 0.0 if occluded.\n       \tvec3 sample_occlusion = sample_color * sample_unoccluded;\n        \n        /*\n        sample_weight = sample_unoccluded;\n        unoccluded_direction += random_direction * sample_unoccluded;\n        */\n\n        \n        color_blend_factor *= sample_unoccluded;\t// No sun in occluded areas!\n        \n        \n        blend_factor_sum += color_blend_factor * sample_weight;\n        sky_visibility += sample_unoccluded * sample_weight;\n        \n        \n\t\tocclusion_sum += sample_color * sample_unoccluded * sample_weight;\n\t\t//occlusion_sum += sample_occlusion * sample_weight;\n\t\tsample_count += sample_weight;\n    }\n\t\n\tocclusion_sum /= sample_count;\n\tsky_visibility /= sample_count;\n    blend_factor_sum /= sample_count;\n    \n    \n    /*\n    unoccluded_direction = normalize(unoccluded_direction / sample_count);\n    \n    float color_blend_factor = max(dot(unoccluded_direction, light_direction), 0.0);\n    color_blend_factor = pow(color_blend_factor, light_exponent);\n    vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n\n    occlusion_sum = sample_color;\n    */\n    \n    //occlusion_sum = normal * 0.5 + vec3(0.5);\n    //occlusion_sum = vec3(normal.y);\n    \n   \t//blend_factor_sum = pow(blend_factor_sum, light_exponent);\n    \n    //return(occlusion_sum);\n    \n    \n    //return(vec3(occlusion_sum2));\n    //return(vec3(blend_factor_sum));\n    \n    vec3 indirect_light = mix(sky_color, light_color, blend_factor_sum);\t// Calculate light color\n   \tindirect_light *= sky_visibility;\t// Add sky occlusion\n    \n    return(indirect_light);\n    \n    \n    return(vec3(occlusion_sum));\n}\n\nvec3 calculate_normal(vec3 p_center, float step_size)\n{\n    step_size *= 0.2;\n\n    p_center.y = detailed_noise_flat(p_center.xz) * terrain_height_multiplicator;\n\n    vec3 p_x = p_center + vec3(step_size, 0.0, 0.0);\n    p_x.y = detailed_noise_flat(p_x.xz) * terrain_height_multiplicator;\n\n    vec3 p_z = p_center + vec3(0.0, 0.0, step_size);\n    p_z.y = detailed_noise_flat(p_z.xz) * terrain_height_multiplicator;\n\n    vec3 normal = cross(p_center - p_z,\n                        p_center - p_x);\n    \n    return(normalize(normal));\n}\n\nvec3 shade_pixel(vec3 intersection_point, vec3 ray_direction, float step_size)\n{\n    //vec3 normal = calculate_normal(intersection_point, step_size);\n    \n    vec3 normal;\n    if(intersection_point.y < water_height)\t// If water was hit:\t// TODO: Integrate this into the height function!\n    {\n        // TODO: Calculate correct intersection point!\n    \tintersection_point.y = water_height - step_size * 0.05;\n        \n    \tnormal = vec3(0.0, 1.0, 0.0);\n        // TODO: Calculate proper water normal!\n        // TODO: We could actually just trace from the eye to the water instead.\n        \n        // TODO: Move the noise based on time and on the Y axis.\n        vec3 noise_sample_position;\n        noise_sample_position.x = intersection_point.x * 250.0 + adjusted_time * 50.0;\n        noise_sample_position.y = adjusted_time * 50.0;\n        noise_sample_position.z = intersection_point.z * 250.0 + adjusted_time * 50.0;\n        \n        vec3 normal_offset;\n        normal_offset.x = detailed_noise_3d(noise_sample_position) - 0.5;\n        normal_offset.z = detailed_noise_3d(noise_sample_position + vec3(0.0, 13.0, 0.0)) - 0.5;\n        normal_offset.xz *= 0.05;\n        \n        //normal_offset.y = max(1.0 - dot(normal_offset.xz, normal_offset.xz), 0.0);\n        normal_offset.y = 0.5;\n        \n        normal = normalize(normal_offset);\n    }\n    else\n    {\n    \tnormal = calculate_normal(intersection_point, step_size);\n    }\n    \n \tfloat noise_for_rock_color = detailed_noise(intersection_point * 36.0 + vec3(10.0));\n    float noise_for_grass_color = detailed_noise(intersection_point * 40.0 + vec3(10.0));\n\n    float noise_for_rock = detailed_noise(intersection_point * 5.0 + vec3(40.0));\n    float noise_for_snow = detailed_noise(intersection_point * 10.0 + vec3(20.0));\n\n    //noise_for_snow += (texture(iChannel0, intersection_point.xz * 0.5).r * 0.5 - 0.5);\n    //noise_for_snow *= smoothstep(0.0, 0.4, texture(iChannel1, intersection_point.xz * 0.05).r);\n\n\n    vec3 grass_color = vec3(0.6 * intersection_point.y * 0.4, 0.5 * intersection_point.y * 0.4 + 0.15, 0.1);\n   // grass_color = mix(grass_color * 0.7,\n   //                   grass_color,\n   //                   smoothstep(0.2, 0.9, noise_for_grass_color * intersection_point.y));\n    \n    grass_color = 1.2 * grass_color * texture(iChannel1, intersection_point.xz).r;\n\t/*\n    vec3 rock_color = vec3(0.55, 0.55, 0.5) * 0.7;\n    vec3 rock_color2 = vec3(0.55, 0.52, 0.45) * 0.85;\n    rock_color = mix(rock_color,\n                     rock_color2,\n                     smoothstep(0.3, 0.7, noise_for_rock_color * intersection_point.y * 0.5));\n    */\n    vec3 rock_color = vec3(0.55, 0.55, 0.5) * (texture(iChannel0, intersection_point.xz).r * 0.75 + 0.25);\n\n\n    vec3 albedo = mix(grass_color,\t// Grass\n                      rock_color,\t// Rock\n                      min(max(intersection_point.y * 0.28 - 0.35 + (noise_for_rock * 0.4 - 0.2), 0.0) * 15.0, 1.0));\n\n    float snow_strength = min(max(intersection_point.y * 0.3 - 0.5 + (noise_for_snow * 0.4 - 0.2), 0.0) * 20.0, 1.0);\n    \n    //snow_strength -= pow(max(dot(normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5, 0.0), 8.0) * 200.0;\t// Surfaces that don't point up shouldn't get snow.\n    snow_strength *= smoothstep(0.35, 0.45, max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0));\t// Surfaces that don't point up don't get snow.\n    \n    snow_strength = clamp(snow_strength, 0.0, 1.0);\n    \n    albedo = mix(albedo,\n                 vec3(0.75, 0.95, 1.0),\t// Snow\n                 snow_strength);\n\n\n   \n\n\n    float lambert = max(dot(normal, light_direction), 0.0);\n\n\n    vec3 ambient = calculate_colored_ambient_occlusion(intersection_point, normal, 1.0,\n                                                       light_direction, light_color, sky_color);\n   \n\n    float direct_occlusion = calculate_shadow(intersection_point, light_direction, 10.0);\n    lambert *= direct_occlusion;\n\n    vec3 half_vector = normalize(-ray_direction + light_direction);\n\n    float specular_exponent = 2.0;\n    float specular_mask = direct_occlusion * 4.0;\n    \n    if(intersection_point.y < water_height)\t// If water was hit:\t// TODO: Integrate this into the height function!\n    {\n        lambert = max(lambert - 0.75, 0.0) * 4.0;\n        specular_exponent = 640.0;\n        albedo = mix(vec3(0.1, 0.8, 1.0), albedo, 0.25);\n        \n        const float shore_threshold = 0.125;\n        \n        float adjusted_water_height = water_height;\n        adjusted_water_height += sin(detailed_noise_flat(intersection_point.xz * 16.0 + vec2(adjusted_time * 16.0, adjusted_time * 8.0)) * 3.142) * shore_threshold * 0.5;\n        \n        \n        float water_surface_to_ground_distance = adjusted_water_height - detailed_noise_flat(intersection_point.xz) * terrain_height_multiplicator;\n        \n       \n        float shore_factor = 1.0 - smoothstep(0.0, shore_threshold, water_surface_to_ground_distance);\n        albedo = mix(albedo, vec3(1.0), shore_factor);\n    }\n    else\n    {\n        specular_mask *= snow_strength;\n    }\n    \n    float specular = pow(max(dot(half_vector, normal), 0.0), specular_exponent);\n    specular *= specular_mask;\n\n    vec3 result = albedo * (light_color * lambert + ambient);\n\n    //fragColor.rgb += to_linear_space(light_color * specular);\n    result += light_color * specular;\n    \n\n    //fragColor.rgb = vec3(direct_occlusion);\n    //fragColor.rgb = vec3(specular);\n    //fragColor.rgb = vec3(normal.x);\n\n\n    //result = ambient;\n\n    //fragColor.rgb = vec3(normal.x);\n    //fragColor.rgb = vec3(normal.x);\n    //fragColor.rgb = vec3(normal.z);\n\n\n\n    /*\n    fragColor = mix(vec4(0.1, 0.3, 0.0, 1.0),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    fragColor.y);\n    */\n    \n    //return(vec3(lambert));\n    return(result);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\tinitialize_global_variables(fragCoord);\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t//fragColor = vec4(detailed_noise(vec3(uv * 10.0, 0.0)));\n\tfragColor.rgb = sky_color;\n    \n\t//vec3 eye_offset = vec3(10.0, 6.0, sin(iTime * 0.1) * 10.0);\n\t//vec3 eye_offset = vec3(5.0, 3.0, 0.0);\n\tvec3 eye_offset = vec3(5.0, 6.0, 0.0);\n    \n    float angle = iTime * 0.03;\n    vec3 look_direction_on_ground = vec3(sin(angle), 0.0, cos(angle));\n    vec3 look_direction_on_ground_perpendicular = vec3(-look_direction_on_ground.z, 0.0, look_direction_on_ground.x);\n    //vec3 up_vector = cross(look_direction_on_ground, look_direction_on_ground_perpendicular);\n    vec3 up_vector = vec3(0.0, 1.0, 0.0);\n    \n    \n    mat3 rotation_matrix = mat3(look_direction_on_ground_perpendicular,\n                                up_vector,\n                                look_direction_on_ground);\n    \n    \n    //eye_offset.xz = vec2(-cos(angle), sin(angle)) * 4.0;\t// Go around in circle.\n    eye_offset.xz = vec2(cos(angle), sin(angle)) * 10.0;\t// Rotate around weirdly.\n\n    //eye_offset += vec3(0.0, camera_noise(vec3(eye_offset.x, 0.0, eye_offset.z)), 0.0);\n    \n    \n    vec3 eye_position = eye_offset;\n   \n    vec3 ray_start = eye_position;\n\t/*\n\tvec3 look_direction = vec3(0.0, -1.25, 0.0);\n    vec3 ray_direction = normalize(vec3(uv * 2.0 - vec2(1.0), 1.0) + look_direction);\n    */\n    vec3 look_direction = rotation_matrix * vec3(vec3(uv * 2.0 - vec2(1.0), 1.0));\n    look_direction.y -= 0.95;\n    vec3 ray_direction = normalize(look_direction);\n   \n    \n    const int raymarch_samples = 64;\n    const int inverse_raymarch_samples = 10;\n    \n    const float step_size = max_view_distance / float(raymarch_samples);\n        \n    vec3 ray_increment = ray_direction * step_size;\n    vec3 inverse_ray_increment = -ray_increment / float(inverse_raymarch_samples);\n    \n    // Add a random offset to fight precision issues (dithering):\n    //ray_start += ray_increment * hash(fragCoord.xy);\n    \n    float terrain_height;\n    vec3 intersection_point = vec3(9999.9);\n    \n    float accumulated_cloud_density = 0.0;\n    \n    for(int i=0; i<raymarch_samples; ++i)\n    {\n\t\tray_start += ray_increment;\n                \n        // TODO: Randomize colors by applying the noise function!\n\n        /*\n        float cloud_density = max((noise_3d(ray_start * 1.1) - 0.25) * 1.33333, 0.0);\t// Large scale to vary where clouds are.\n        cloud_density *= noise_3d(ray_start * 2.0);\t// Rough cloud shape.\n        cloud_density *= noise_3d(ray_start * 5.0);\t// Detailed cloud shape.\n        \n        \n        float eye_to_sample_distance = distance(eye_position, ray_start);\n        float blend_factor = eye_to_sample_distance / max_view_distance;\n        blend_factor = pow(blend_factor, fog_exponent);\n\t\tcloud_density *= 1.0 - blend_factor;\n        \n        accumulated_cloud_density += cloud_density * 0.15;\n        */\n\n\t\t\n        terrain_height = detailed_noise_flat(ray_start.xz) * terrain_height_multiplicator;\n        \t\t\n       \t// float sample_height = noise1(ray_start);\n\t\tif(ray_start.y < terrain_height)\n\t\t{\n            // Step backwards and out of the surface:\n            for(int j=0; j<inverse_raymarch_samples; ++j)\n            {\n\t\t\t\tray_start += inverse_ray_increment;\n\t\t\t\tterrain_height = detailed_noise_flat(ray_start.xz) * terrain_height_multiplicator;\n                if(ray_start.y >= terrain_height)\n                {\n                \tbreak;   \n                }\n            }\n            \n       \t\tintersection_point = vec3(ray_start.x, terrain_height, ray_start.z);\n\t\t\tbreak;\n\t\t}\n    }\n    \n    if(intersection_point.x < 9000.0)\t// This avoids calling \"shade_pixel()\" for sky pixels.\n    {\n        fragColor.rgb = shade_pixel(intersection_point, ray_direction, step_size);\n    }\n\n    // Now add some fog:    \n    float eye_to_sample_distance = distance(eye_position, ray_start);\n    \n    //float blend_factor = min(eye_to_sample_distance * fog_strength, 1.0);\n    float blend_factor = eye_to_sample_distance / max_view_distance;\n    blend_factor = pow(blend_factor, fog_exponent);\n    fragColor.rgb = mix(fragColor.rgb, sky_color, blend_factor);\n                        \n    // TODO: Properly blend sun color with sky!\n    \n    // Add some sun to the fog:\n    float sun_brightness = dot(light_direction, ray_direction) * 0.5 + 0.5;\n    fragColor.rgb += light_color * pow(sun_brightness, light_exponent);\n    \n    // Apply fake exposure control, to make the snow less blown out:\n    float brightness = (light_color.r + light_color.g + light_color.b) / 3.0;\n    fragColor.rgb = fragColor.rgb / (0.5 + 1.5 * brightness);\n   \n    /*\n    // Add clouds:\n    accumulated_cloud_density = pow(accumulated_cloud_density, 2.0);\n    //fragColor.rgb = mix(vec3(1.0), fragColor.rgb, 1.0 / (1.0 + accumulated_cloud_density));\n    \n    float cloud_blend_factor = min(accumulated_cloud_density * 10.0, 1.0) * (1.0 - blend_factor);\n    vec3 cloud_color = mix(vec3(1.0), sky_color, blend_factor);\n    fragColor.rgb = mix(fragColor.rgb, cloud_color, cloud_blend_factor);\n    */\n    \n    // Crappy tonemapping to make it look more realistic:\n    //fragColor.rgb = pow(fragColor.rgb, vec3(1.0 + fragColor.rgb));\n    \n    //fragColor.rgb = vec3(accumulated_cloud_density);\n    \n    // TODO: How does shadertoy treat gamma?\n    //fragColor.rgb = to_gamma_space(fragColor.rgb);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1740, 1740, 1791, 1867, 8549], [8646, 8646, 8689, 8689, 9782], [9785, 9785, 9819, 9819, 9857], [9859, 9859, 9892, 9892, 9934], [9936, 9936, 9956, 10124, 10583], [10586, 10586, 10609, 10609, 10658], [10660, 10660, 10681, 10681, 10730], [10732, 10732, 10751, 10751, 10794], [10796, 10796, 10820, 10820, 11312], [11314, 11314, 11335, 11335, 11382], [11384, 11384, 11419, 11440, 12533], [12535, 12535, 12568, 12568, 13080], [13082, 13082, 13112, 13112, 13150], [13152, 13152, 13180, 13201, 13345], [13346, 13491, 13578, 13578, 14363], [14365, 14365, 14457, 14513, 14882], [14885, 14885, 14956, 14956, 15238], [15241, 15241, 15296, 15296, 15711], [15713, 15713, 15819, 15877, 16533], [16536, 16536, 16731, 16731, 23397], [23399, 23399, 23593, 23593, 30903], [30905, 30905, 30960, 30960, 31437], [31439, 31439, 31519, 31588, 37165], [37167, 37167, 37222, 37222, 42574]], "test": "error"}
{"id": "wtdGWn", "name": "Minumum Recursionless Fractal", "author": "HyperChromatica", "description": "I wanted to make a fractal but the obvious approach uses recursion and if statements. This doesn't. ", "tags": ["fractal", "first", "minimal", "recusionless"], "likes": 2, "viewed": 67, "published": "Public", "date": "1576059018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t//vec3 col = vec3(.5f + (fragCoord.x - iResolution.x/2.0f )/float(iResolution.x),\n    //                .5f + (fragCoord.y-iResolution.y/2.0f)/float(iResolution.y) ,\n    //                .2f);\n    \n    float boundary = 1.0f;\n    float n = 0.0f;\n    float fract = 1.5f;\n    n =  ceil(-log2(uv.x)/log2(fract));\n    boundary = 1.0f;\n    for(int i = 0 ; i < int(n); i++)\n    {\n        boundary /= fract;\n    }\n    \n    float L = ((uv.x - boundary)*(.85f + .15 * sin(iTime) ))/(boundary-boundary/fract ) +.5f;\n    float r = float(int(n)%4) ;\n    float g = float(int(n+1.0f)%4);\n    float b = float(int(n+2.0f)%4);\n    vec3 col = vec3( r/4.0f, (g)/4.0f, (b)/4.0f)/L;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 963]], "test": "ok"}
{"id": "wtdGWS", "name": "A golden heart with color flow", "author": "pik33", "description": "A golden heart with color flow", "tags": ["heart"], "likes": 0, "viewed": 71, "published": "Public", "date": "1577465037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"A golden heart\" by pik33. https://shadertoy.com/view/3tdGDB\n// 2019-12-27 16:39:40\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv =2.* (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 ab=-uv;\n    \n    ab.x=ab.x*0.6;\n    ab.y+=-0.1+0.6*sqrt(abs(ab.x));\n\n    float f=1.+0.05*sin(0.25*7.83*3.14159*iTime);\n    float l=length(ab);\n    float s=smoothstep(f*0.35,f*0.31,l);//-smoothstep(f*0.15,0.,l);\n\n    vec2 p=vec2(s)+(1./f)*ab;\n    p.x=abs(p.x);\n\n\tfor(int i=1;i<55;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=(0.5/(1.0*float(i)))*cos(float(i)*p.y+iTime*11.0/37.0+0.03*float(i));\t\t\n\t\tnewp.y+=(0.5/(1.0*float(i)))*cos(float(i)*p.x+iTime*17.0/41.0+0.03*float(i));\n\t\tp=newp;\n\t}\n    \tvec3 col=vec3(fract(p.x),fract(p.y),fract(0.3*p.x+0.7*p.y));\n    col.x=smoothstep(0.90,1.0,col.x);   \n    col.y=smoothstep(0.90,1.0,col.y);\n    col.z=smoothstep(0.90,1.0,col.z);\n\n     if (s>0.1) col = vec3(s,s*0.63,s*0.2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 153, 153, 965]], "test": "ok"}
{"id": "Wtt3DN", "name": "firstShadertoy", "author": "changlongLi", "description": "this is my first shadertoy demo , I will continue to learn, continue to work hard", "tags": ["2d", "color", "cool"], "likes": 0, "viewed": 35, "published": "Public", "date": "1576400564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is my first shadertoy demo\n//creaty by changlongLi\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     uv = tile(uv,4.);\n    //width height ratio\n    float ratio = iResolution.x/iResolution.y;\n \t//\n\tuv.x = uv.x*ratio - 0.4;\n  \n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-uv;\n    float radius = length(pos)*2.0;\n    float angle = atan(pos.y,pos.x);\n\n    float f = cos(angle*3.);\n    float f1 = cos(angle*3.);\n    float f2 = cos(angle*3.);\n\n    f1 = fract(angle*1.376+iTime)*0.8;\n\t f2 = fract(angle*2.408+iTime)*0.8;\n\t f = f1*f2;\n\n    color = vec3( 1.-smoothstep(f,f+0.02,radius) );\n      \n    color = color * hsb2rgb(vec3((f+iTime),1.,1.000));\n      \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 85, 85, 244], [246, 246, 279, 279, 322], [324, 324, 381, 431, 1069]], "test": "ok"}
{"id": "Wtt3R8", "name": "Hue-correct saturation", "author": "ttg", "description": "Right side: Saturation of all channels to white without color distortion or banding.\nMouse to control brightness.", "tags": ["color", "postprocess", "hdr"], "likes": 5, "viewed": 328, "published": "Public API", "date": "1575598579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define SHOWCLIPPING\n\n/*const vec3 msat = vec3(.3,.2,.5); // how much each channel contributes to saturation\nconst float msdiv = .12;\n\nvec3 saturate( vec3 v ) {\n  float sv = dot(v,msat);\n  vec3 hs = v/sv*msdiv;\n  float ls = tanh(sv);\n  float s = tanh(sv*sv/5.);\n  vec3 hs2 = mix(hs,vec3(1),s);\n  return ls*hs2/mix(msdiv,1.,pow(s,.5));\n}*/\n\nconst vec3 msat = vec3(.3,.3,.3);\nconst float msdiv = .12;\nvec3 saturate( vec3 v ) {\n  // https://www.shadertoy.com/view/Wtt3R8\n  float sv = dot(v,msat);\n  vec3 hs = v/sv*msdiv;\n  float ls = (1.-exp(-sv))*.9;\n  float s = 1.-exp(-sv*sv/10.);\n  vec3 hs2 = mix(hs,vec3(1),s);\n  return ls*hs2/mix(msdiv,1.,s);\n}\n\nvec3 image( sampler2D chan, vec2 uv, vec3 gain )\n{\n  vec3 v = 1.*pow(texture(chan, uv).rgb,vec3(2.2));\n  v+= .1*pow(textureLod(chan, uv, 5.).rgb,vec3(2.2));\n  v*=gain;\n  return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy*vec2(2,2);\n  vec3 v = vec3(0);\n  float gain = exp2(iMouse.x/100.);\n  if (iMouse.x<2.) gain = (4.+2.*cos(iTime))*(1.+pow(.6+.2*sin(iTime*5.)+.1*sin(iTime*7.),2.));\n  if      (uv.y>6./3.5) v = (vec3(1.,.2,.04)*fract(uv.x)*gain);\n  else if (uv.y>5./3.5) v = image(iChannel0, uv, gain*vec3(1));\n  else if (uv.y>4./3.5) v = image(iChannel1, uv, gain*vec3(1));\n  else if (uv.y>3./3.5) v = image(iChannel2, uv, gain*vec3(1));\n  else if (uv.y>2./3.5) v = image(iChannel1, uv, gain*vec3(0.4,1,0.01));\n  else if (uv.y>1./3.5) v = image(iChannel3, uv, gain*vec3(0.04,0.04,2));\n  else                  v = image(iChannel3, uv, gain*vec3(1));\n  if (uv.x>=1.) v = saturate(v);\n\n#ifdef SHOWCLIPPING\n  float clipdet = float(any(greaterThan(v,vec3(1.))));\n  if (fwidth(clipdet)>0.) { fragColor = vec4(1.-vec3(greaterThan(v,vec3(1))),0); return; }\n  if (clipdet>0. && (int(dot(fragCoord/2.,vec2(1)))%2)==0) v = vec3(0);\n#endif\n  if (uv.x<1.) v = mix(1.,.6,uv.x)*clamp(v,0.,1.);\n  fragColor = pow(vec4(v*255./256.,1.),vec4(1./2.2));\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 426, 469, 649], [651, 651, 701, 701, 832]], "test": "error"}
{"id": "wtt3Rf", "name": "Snow_On_Black", "author": "Testamentum", "description": "Snow", "tags": ["snow"], "likes": 4, "viewed": 321, "published": "Public API", "date": "1577112594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nprecision highp float;\n\n\n// Convention:\n// vec2s ending with 'c'\n// are in circular coords\n// ex: pc = vec2(angle of p, length of p)\n\n\n\n#define time (iTime / 3.0)\n\n#define PI2 6.28\n#define PI 3.1416\n\n\n// Point to polar coord\nvec2 p_to_pc(vec2 p){\n    return vec2(atan(p.y, p.x), length(p));\n}\n\n// Polar coord to point\nvec2 pc_to_p(vec2 pc){\n    return vec2(pc.y * cos(pc.x), pc.y * sin(pc.x));\n}\n\n// I use these fields to create and tweak the snowflakes\nvec2 fieldA(vec2 pc){\n    // Modify angle and distance\n    pc.y += 0.02 * floor(cos(pc.x * 6.0 ) * 5.0);\n    pc.y += 0.01 * floor(10.0 * cos(pc.x * 30.0));\n    pc.y += 0.5 * cos(pc.y * 10.0);\n    \n    // Take back to position\n    return pc;\n}\n\n\n// Different values of f happen to give quite different\n// snowflake shapes. Interesting...\nvec2 fieldB(vec2 pc, float f){\n    // Modify angle and distance\n    pc.y += 0.1 * cos(pc.y * 100.0 + 10.0);\n    pc.y += 0.1 * cos(pc.y * 20.0 + f);\n    pc.y += 0.04 * cos(pc.y * 10.0 + 10.0);\n    \n    return pc;\n} \n\nvec4 snow_flake(vec2 p, float f){\n    \n    vec4 col = vec4(0.0);\n\n\tvec2 pc = p_to_pc(p * 10.0);\n    \n    \n    pc = fieldA(fieldB(pc, f));\n    \n    p = pc_to_p(pc);\n    \n    float d = length(p);\n    \n    if(d < 0.3){\n        col.rgba += vec4(1.0);\n    }\n    \n    return col;\n}\n\nvec4 snow(vec2 p){\n   \n    vec4 col = vec4(0.0);\n\n\tp.y += 1.5 * time;\n    \n    p = fract(p + 0.05) - 0.5;\n    \n    p *= 1.0;\n    \n    \n    p.x += 0.01 * cos(p.y * 3.0 + p.x * 3.0 + time * PI2);\n    \n    \n    // Just me pseudo randomly adding snowflakes\n    // Could be optimized by not calling the function 8 times\n    // (using some field distortion )\n    col += snow_flake(p, 1.0);\n    col += snow_flake(p + vec2(0.2, -0.1), 4.0);\n    col += snow_flake(p * 2.0 + vec2(-0.4, -0.5), 5.0);\n    col += snow_flake(p * 1.0 + vec2(-0.2, 0.4), 9.0);\n    col += 2.0 * snow_flake(p * 1.0 + vec2(0.4, -0.4), 5.0);\n    col += snow_flake(p * 1.0 + vec2(-1.2, 1.2), 9.0);\n    col += snow_flake(p * 1.0 + vec2(2.4, -1.2), 5.0);\n    col += snow_flake(p * 1.0 + vec2(-1.2, 1.1), 9.0);\n   \n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float x = uv.x;\n    float y = uv.y;\n    \n    vec2 p = vec2(x, y) - vec2(0.5);\n   \t\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    col += 0.3 * snow(p * 2.0);\n    col += 0.2 * snow(p * 4.0 + vec2(time, 10.0));\n    col += 0.1 * snow(p * 8.0);\n    \n    col.a = 0.1;\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtt3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 226, 247, 247, 293], [295, 319, 341, 341, 396], [398, 455, 476, 509, 697], [700, 792, 822, 855, 1005], [1008, 1008, 1041, 1041, 1283], [1285, 1285, 1303, 1303, 2081], [2083, 2083, 2137, 2137, 2481]], "test": "timeout"}
{"id": "Wtt3WM", "name": "Reticolo", "author": "lucasassone", "description": "Geometric grid", "tags": ["raymarching"], "likes": 12, "viewed": 366, "published": "Public API", "date": "1576531567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// restituisce le coordinate di p modulari tra -interval/2 e +interval/2 \nvec2 onRep(vec2 p, float interval) {\n\treturn mod(p, interval) - interval * 0.5;\n}\n\nfloat barDist(vec2 p, float interval, float width) {\n\treturn length(max(abs(onRep(p, interval)) - width, 0.0));\n}\n\nfloat cubeDist(vec3 p, float interval, float width) {\n\treturn length(max(abs(mod(p, interval) - interval * 0.5) - width, 0.0));\n}\n\nfloat sphereDist(vec3 p, float interval, float width) {\n\treturn length(0.5 * interval - abs(mod(p + vec3(0, 0, 3.0 * iTime), interval) - interval * 0.5)) - width;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\n// distance estimator\nfloat sceneDist(vec3 p) {\n\tfloat bar_x = barDist(p.yz, 0.5, 0.0125);\n\tfloat bar_y = barDist(p.xz, 0.5, 0.0125);\n\tfloat bar_z = barDist(p.xy, 0.5, 0.0125);\n\treturn min(min(min(bar_x, bar_y), bar_z), min(cubeDist(p, 0.5, 0.0375), sphereDist(p, 1.0, 0.05)));\n}\n\nvec3 lerp(vec3 a, vec3 b, float f) {\n\treturn a + f * (b - a);\n}\n\n// ----------------------------------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = ( fragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec3 cameraPos = vec3(0.25 * iTime + 0.5, 0.125 * iTime, 0.25 * iTime + 0.125);\n\n\tvec2 a = 0.8 * p;\n\tvec3 rayDirection = normalize(vec3(sin(a.x) * cos(a.y), sin(a.y), cos(a.x) * cos(a.y)));\n\n\trayDirection = rotate(rayDirection, 0.5 * iTime, vec3(0., 0., 1.));\n\trayDirection = rotate(rayDirection, 0.5 * iTime, vec3(0., 1., 0.));\n\n\tfloat depth = 0.0;\n   \n\tvec3 col = vec3(0.8, 0.9, 1.0);\n\n\t// ray marching\n\tfor (int i = 0; i < 99; i++) {\n\t\tvec3 rayPos = cameraPos + rayDirection * depth;\n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < 0.0001) {\n\t\t\tcol = vec3(1.0, 0.9, 0.7) * (0.2 + 0.01 * float(i));\n\t\t\tcol = lerp(col, vec3(0.8, 0.9, 1.0), 0.01 * float(i));\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist;\n\t}\n    \n\t// effetto vignette\n\tvec2 sv = sin(fragCoord.xy / iResolution.xy * 3.141592);\n\tcol = col * (0.5 + 0.5 * sv.x * sv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 75, 111, 111, 156], [158, 158, 210, 210, 271], [273, 273, 326, 326, 402], [404, 404, 459, 459, 568], [570, 570, 614, 614, 968], [970, 992, 1017, 1017, 1249], [1251, 1251, 1287, 1287, 1314], [1445, 1445, 1502, 1594, 2555]], "test": "ok"}
{"id": "wttGD2", "name": "Vlams' 3D Voronoi", "author": "vlams1", "description": "Raymarcher with 3 dimensional voronoi noise with smooth minimum as distance field.\nCurrently very unoptimized.", "tags": ["raymarcher"], "likes": 2, "viewed": 144, "published": "Public", "date": "1577663165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IT 32.\n#define SD .02\n#define MD 20.\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec3 h33(vec3 p) {\n    p = fract(p*365.8193+95.);\n\tp *= 17.;\n    return fract(vec3(p.x*p.y,p.y*p.z,p.z*p.x)+(p.x+p.y+p.z));\n}\n\nfloat voronoi(vec3 p) {\n    vec3 c = floor(p);\n    float d = 10.;\n    vec3 s;\n    for (s.x = -1.; s.x < 2.; s.x++)\n        for (s.y = -1.; s.y < 2.; s.y++)\n            for (s.z = -1.; s.z < 2.; s.z++)\n            \td = smin(d,length(p-c-.5-s+sin(h33(c+s)*(iTime*.5+10.))*.5),.1);\n    return d;\n}\n\n\nfloat dist(vec3 p) {\n    return .7-voronoi(p*.5)+2.-min(length(p),2.);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float td;\n    for (float i; i < IT; i++) {\n        float d = dist(p);\n        td += d;\n        p += rd*d;\n        if (d < SD || td > MD) break;\n    }\n    return p;\n}\n\nvec3 normal(vec3 p) {\n    vec2 o = vec2(SD,0);\n    return normalize(vec3(\n    dist(p+o.xyy)-dist(p-o.xyy),\n    dist(p+o.yxy)-dist(p-o.yxy),\n    dist(p+o.yyx)-dist(p-o.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 p = raymarch(ro,rd);\n    float l = max(0.,dot(normal(p),normalize(vec3(1,3,-2))));\n    vec3 col = dist(p) < SD * 2. ? mix(vec3(1.),vec3(0.3,0.1,0.6),pow(length(p-ro)/MD,.2)) * l : vec3(0);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 85, 85, 165], [167, 167, 185, 185, 292], [294, 294, 317, 317, 588], [591, 591, 611, 611, 663], [665, 665, 698, 698, 885], [887, 887, 908, 908, 1063], [1065, 1065, 1120, 1120, 1474]], "test": "timeout"}
{"id": "WttGDB", "name": "Sliding dots", "author": "tb", "description": "This is my first GLSL shader.\nI'm starting by trying to recreate other shaders that I have seen as a learning exercise.\nPlease offer tips if you have any.\n\nEdit: added antialiasing.", "tags": ["blackandwhite", "dots"], "likes": 7, "viewed": 87, "published": "Public", "date": "1577455771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// antialiasing, adapted from https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define S(v, v0, r) smoothstep(6.0 / R.y, -6.0 / R.y, length(v - (v0)) - (r))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalise the coordinates\n    vec2 R = iResolution.xy, U = ((2.0 * fragCoord.xy) - R) / min(R.x, R.y);\n    // grid\n    vec2 grid = (fract(U * 2.0) * 2.0) - 1.0;\n    // 2 phase offset square waves\n    vec2 offset = step(fract(vec2(iTime, iTime + 1.0) / 2.0), vec2(0.5));\n    // translation\n    grid -= fract(iTime) * sign(grid.yx) * offset;\n    // render dots\n    vec3 c = vec3(S(fract(grid), vec2(0.5), 0.3));\n    fragColor = vec4(c, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 257, 290, 706]], "test": "ok"}
{"id": "wttGW4", "name": "RS-X Mixtape", "author": "yasuo", "description": "Here is the references:\nhttps://us.puma.com/en/us/pd/puma-x-mixtape-mens-tee/598850.html?dwvar_598850_color=01\nhttps://us.puma.com/en/us/pd/rs-x-mixtape-sneakers/928583.html?dwvar_928583_color=01", "tags": ["reproduction", "puma", "mixtape"], "likes": 12, "viewed": 366, "published": "Public API", "date": "1576410425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing 3./min(iResolution.y,iResolution.x)\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat recycleLogo(vec2 p) {\n    vec2 pref = p;\n    vec2 scale = vec2(3.0);\n    \n    p *= scale;\n    mat2 rot1 = Rot(radians(30.0));\n    mat2 rot2 = Rot(radians(-30.0));\n    mat2 rot3 = Rot(radians(150.0));\n    float recycleRectA1 = dBox2d((p+vec2(0.1,0.0))*rot1,vec2(0.08,0.15));\n    float recycleRectA2 = dBox2d((p+vec2(-0.1,0.0))*rot2,vec2(0.08,0.15));\n    float arrowA = sdTriangle(vec2(0.15,0.0),vec2(-0.15,0.0),vec2(0.0,0.11),(p+vec2(-0.18,0.13))*rot3);\n    float recycleRectA = min(arrowA,max((p.y-0.1),min(recycleRectA1,recycleRectA2)));\n    \n    p += vec2(0.28,0.5);\n    p *= Rot(radians(-120.0));\n    float recycleRectB1 = dBox2d((p+vec2(0.1,0.0))*rot1,vec2(0.08,0.15));\n    float recycleRectB2 = dBox2d((p+vec2(-0.1,0.0))*rot2,vec2(0.08,0.15));\n    float arrowB = sdTriangle(vec2(0.15,0.0),vec2(-0.15,0.0),vec2(0.0,0.11),(p+vec2(-0.18,0.13))*rot3);\n    float recycleRectB = min(arrowB,max((p.y-0.1),min(recycleRectB1,recycleRectB2)));\n    p = pref;\n    \n    p *= scale;\n    p += vec2(-0.28,0.5);\n    p *= Rot(radians(120.0));\n    float recycleRectC1 = dBox2d((p+vec2(0.1,0.0))*rot1,vec2(0.08,0.15));\n    float recycleRectC2 = dBox2d((p+vec2(-0.1,0.0))*rot2,vec2(0.08,0.15));\n    float arrowC = sdTriangle(vec2(0.15,0.0),vec2(-0.15,0.0),vec2(0.0,0.11),(p+vec2(-0.18,0.13))*rot3);\n    float recycleRectC = min(arrowC,max((p.y-0.1),min(recycleRectC1,recycleRectC2)));\n    p = pref;\n    \n    return min(min(recycleRectA,recycleRectB),recycleRectC);\n}\n\nfloat plasticLogo(vec2 p) {\n    vec2 pref = p;\n    vec2 scale = vec2(2.4);\n    \n    p *= scale;\n    \n    mat2 rot1 = Rot(radians(180.0));\n    float rectA1 = dBox2d((p+vec2(0.25,0.0)),vec2(0.05,0.1));\n    float rectA2 = dBox2d((p+vec2(0.0,-0.05)),vec2(0.2,0.05));\n    float rectA3 = dBox2d((p+vec2(-0.25,-0.03)),vec2(0.05,0.07));\n    float arrowA = sdTriangle(vec2(0.09,0.0),vec2(-0.09,0.0),vec2(0.0,0.1),(p+vec2(-0.25,0.03))*rot1);\n    float prectA = min(arrowA,min(min(rectA1,rectA2),rectA3));\n    \n    float rectB1 = dBox2d((p+vec2(0.25,0.4)),vec2(0.05,0.15));\n    float rectB2 = dBox2d((p+vec2(0.0,0.5)),vec2(0.2,0.05));\n    float rectB3 = dBox2d((p+vec2(-0.25,0.48)),vec2(0.05,0.07));\n    float arrowB = sdTriangle(vec2(0.09,0.0),vec2(-0.09,0.0),vec2(0.0,0.1),(p+vec2(0.25,0.25)));\n    float prectB = min(arrowB,min(min(rectB1,rectB2),rectB3));\n    \n    mat2 rot2 = Rot(radians(30.0));\n    float r1 = length(p+vec2(-0.05,0.2))-0.03;\n    float r2 = length(p+vec2(-0.05,0.2))-0.07;\n    float r = max(-r1,r2);\n    float b =  dBox2d((p+vec2(0.0,0.25)),vec2(0.08,0.025));\n    float b1 =  dBox2d((p+vec2(-0.04,0.31))*rot2,vec2(0.025,0.08));\n    float charA = min(min(r,b),b1);\n    \n    float b2 =  dBox2d((p+vec2(-0.25,0.18)),vec2(0.06,0.02));\n    float b3 =  dBox2d((p+vec2(-0.29,0.31))*rot2,vec2(0.025,0.08));\n    float b4 =  dBox2d((p+vec2(-0.26,0.25)),vec2(0.09,0.025));\n    float charB = max(p.x-0.34,min(min(b2,b3),b4));\n    \n    return min(min(min(prectA,prectB),charA),charB);\n}\n\nfloat paperLogo(vec2 p) {\n    vec2 pref = p;\n    vec2 scale = vec2(1.6);\n    \n    p *= scale;\n    \n    p *= Rot(radians(45.0)+iTime*0.5);\n    mat2 rot1 = Rot(radians(90.0));\n    float e = sdEllipse(p,vec2(0.27,0.32));\n    float e2 = sdEllipse(p,vec2(0.22,0.27));\n    float b =  dBox2d((p),vec2(0.06,0.5));\n    float arrowA = sdTriangle(vec2(0.09,0.0),vec2(-0.09,0.0),vec2(0.0,0.1),(p+vec2(0.08,-0.28))*rot1);\n    float arrowB = sdTriangle(vec2(0.09,0.0),vec2(-0.09,0.0),vec2(0.0,0.1),(p+vec2(-0.08,0.28))*rot1*-1.0);\n    float res = min(min(max(-b,max(-e2,e)),arrowA),arrowB);\n    p = pref;\n    \n    p *= scale;\n    vec2 pos = vec2(0.02,0.0);\n    float b1 = dBox2d((p+vec2(0.07,-0.095)+pos)*Rot(radians(35.0)),vec2(0.015,0.05));\n    float b2 = dBox2d((p+vec2(0.03,-0.04)+pos)*Rot(radians(35.0)),vec2(0.015,0.05));\n    float b3 = dBox2d((p+vec2(0.07,-0.02)+pos)*Rot(radians(-30.0)),vec2(0.015,0.05));\n    float b4 = dBox2d((p+vec2(0.055,0.02)+pos),vec2(0.06,0.015));\n    float b5 = dBox2d((p+vec2(0.055,0.07)+pos),vec2(0.015,0.06));\n    float b6 = dBox2d((p+vec2(0.11,0.09)+pos)*Rot(radians(20.0)),vec2(0.012,0.03));\n    float b7 = dBox2d((p+vec2(0.00,0.09)+pos)*Rot(radians(-20.0)),vec2(0.012,0.03));\n    res = min(res,min(b1,min(b2,min(b3,min(b4,min(b5,min(b6,b7)))))));\n    \n    float b8 = dBox2d((p+vec2(-0.10,-0.12)+pos)*Rot(radians(70.0)),vec2(0.012,0.06));\n    float b9 = dBox2d((p+vec2(-0.05,0.01)+pos),vec2(0.012,0.11));\n    float b10 = dBox2d((p+vec2(-0.10,0.0)+pos),vec2(0.06,0.012));\n    float b11 = dBox2d((p+vec2(-0.13,-0.01)+pos),vec2(0.012,0.13));\n    float b12 = dBox2d((p+vec2(-0.06,0.11)+pos)*Rot(radians(-5.0)),vec2(0.038,0.012));\n    float b13 = dBox2d((p+vec2(-0.15,0.10)+pos)*Rot(radians(-45.0)),vec2(0.03,0.013));\n    \n    res = min(res,min(b8,min(b9,min(b10,min(b11,min(b12,b13))))));\n    \n    return res;\n}\n\nfloat pvcLogo(vec2 p) {\n    vec2 pref = p;\n    vec2 scale = vec2(2.2);\n    \n    p *= scale;\n    p *= Rot(iTime*-0.6);\n    float c1 = length(p)-0.3;\n    float c2 = length(p)-0.27;\n    float b = dBox2d((p)*Rot(radians(45.0)),vec2(0.02,0.3));\n    float res = min(max(-c2,c1),b);\n    return res;\n}\n\nfloat outLine(vec2 p) {\n    vec2 pref = p;\n    float b =  sdBox(p,vec2(1.4,0.8));\n    float b2 =  sdBox(p,vec2(1.5,0.9));\n    float res = max(-b2,b);\n    return res-0.11;\n}\n\nfloat outLine2(vec2 p){\n    vec2 pref = p;\n    float l0 = sdLine(p,vec2(-0.65,-0.3),vec2(-0.5,0.15));\n    float l1 = sdLine(p,vec2(0.65,-0.3),vec2(0.5,0.15));\n    float l2 = sdLine(p,vec2(0.5,0.15),vec2(-0.5,0.15));\n    float res = min(min(l0,l1),l2);\n    return res-0.03;\n}\n\nfloat mixTape(vec2 p) {\n    vec2 pref = p;\n    \n    float mrgX = 0.3;\n    \n    // M\n    vec2 apos = vec2(0.0,sin(iTime*2.0)*0.02);\n    float m0 =  sdLine(p+apos,vec2(-1.15+mrgX,0.1),vec2(-1.1+mrgX,0.35));\n    float m1 =  sdLine(p+apos,vec2(-1.05+mrgX,0.15),vec2(-1.1+mrgX,0.35));\n    float m2 =  sdLine(p+apos,vec2(-1.0+mrgX,0.35),vec2(-1.05+mrgX,0.15));\n    float m3 =  sdLine(p+apos,vec2(-0.93+mrgX,-0.05),vec2(-1.0+mrgX,0.35));\n    float m = min(min(min(m0,m1),m2),m3);\n    \n    // I\n    apos = vec2(0.0,sin(iTime*3.0)*0.02);\n    float i = sdLine(p+apos,vec2(-0.85+mrgX,0.15),vec2(-0.86+mrgX,0.3));\n    \n    // X\n    apos = vec2(0.0,sin(iTime*3.5)*0.02);\n    float x0 = sdLine(p+apos,vec2(-0.73+mrgX,0.15),vec2(-0.6+mrgX,0.35));\n    float x1 = sdLine(p+apos,vec2(-0.73+mrgX,0.3),vec2(-0.6+mrgX,0.15));\n    float x = min(x0,x1);\n    \n    // T\n    apos = vec2(0.0,sin(iTime*3.2)*0.02);\n    float t0 = sdLine(p+apos,vec2(-0.53+mrgX,0.25),vec2(-0.32+mrgX,0.3));\n    float t1 = sdLine(p+apos,vec2(-0.45+mrgX,0.35),vec2(-0.43+mrgX,0.1));\n    float t = min(t0,t1);\n    \n    // A\n    apos = vec2(0.0,sin(iTime*2.9)*0.02);\n    float a0 = sdLine(p+apos,vec2(-0.3+mrgX,0.05),vec2(-0.2+mrgX,0.37));\n    float a1 = sdLine(p+apos,vec2(-0.1+mrgX,0.05),vec2(-0.2+mrgX,0.37));\n    float a2 = sdLine(p+apos,vec2(-0.15+mrgX,0.17),vec2(-0.25+mrgX,0.15));\n    float a = min(min(a0,a1),a2);\n    \n    // P\n    apos = vec2(0.0,sin(iTime*3.1)*0.02);\n    mat2 rot = Rot(radians(-10.0));\n    float pp0 = sdLine(p+apos,vec2(0.02+mrgX,0.1),vec2(0.0+mrgX,0.37));\n    float pp1 = sdEllipse((p+apos+vec2(-0.05-mrgX,-0.27))*rot,vec2(0.15,0.06));\n    float pp2 = sdEllipse((p+apos+vec2(-0.05-mrgX,-0.27))*rot,vec2(0.14,0.05));\n    float pp3 = sdEllipse((p+apos+vec2(0.15-mrgX,-0.27))*Rot(radians(-40.0)),vec2(0.13,0.3));\n    float pp = min(pp0,max(-pp3,max(-pp2,pp1)));\n    \n    // E\n    apos = vec2(0.0,sin(iTime*3.5)*0.02);\n    float e0 = sdLine(p+apos,vec2(0.3+mrgX,0.33),vec2(0.45+mrgX,0.37));\n    float e1 = sdLine(p+apos,vec2(0.27+mrgX,0.22),vec2(0.45+mrgX,0.27));\n    float e2 = sdLine(p+apos,vec2(0.2+mrgX,0.1),vec2(0.45+mrgX,0.17));\n    float e = min(min(e0,e1),e2);\n    \n    vec2 scale = vec2(1.0-(sin(iTime*2.3)*cos(iTime*2.3))*0.05);\n    p*= scale;\n    \n    // //1\n    float bsl0 = sdLine(p,vec2(-1.25+mrgX,0.3),vec2(-1.27+mrgX,0.4));\n    float bsl1 = sdLine(p,vec2(-1.19+mrgX,0.33),vec2(-1.21+mrgX,0.4));\n    float bsl = min(bsl0,bsl1)+0.009;\n    \n    // //2\n    float bsr0 = sdLine(p,vec2(1.25+mrgX-0.68,0.27),vec2(1.25+mrgX-0.6,0.35));\n    float bsr1 = sdLine(p,vec2(1.19+mrgX-0.65,0.33),vec2(1.21+mrgX-0.6,0.4));\n    float bsr = min(bsr0,bsr1)+0.009;\n    \n    float res = min(min(min(min(min(min(min(min(m,i),x),t),a),pp),e),bsl),bsr);\n    \n    return res-0.025;\n}\n\nfloat yellowCircle(vec2 p) {\n    vec2 pref = p;\n    \n    mat2 r = Rot(radians(45.0)+iTime*0.8);\n    vec2 left = vec2(0.78,0.0);\n    float cl0 = length((p+left)*r)-0.2;\n    float cl1 = length((p+left)*r)-0.15;\n    float cl2 = sdLine((p+left)*r,vec2(-0.18,0.17),vec2(-0.05,0.17))-0.026;\n    float cl = min(max(-cl1,cl0),cl2);\n    \n    vec2 right = vec2(-0.78,0.0);\n    float cr0 = length((p+right)*r)-0.2;\n    float cr1 = length((p+right)*r)-0.15;\n    float cr2 = sdLine((p+right)*r,vec2(-0.15,0.17),vec2(-0.05,0.17))-0.026;\n    float cr = min(max(-cr1,cr0),cr2);\n    \n    float c = min(cl,cr);\n    return c;\n}\n\nfloat rsx(vec2 p) {\n    vec2 pref = p;\n    \n    p.y = abs(p.y);\n    p.y -= 0.17+sin(iTime*5.0)*0.01;\n    \n    float outl0 = sdLine(p,vec2(-0.4,0.0),vec2(0.4,0.0))-0.026;\n    p = pref;\n    \n    p.x = abs(p.x);\n    p.x -= 0.35+sin(iTime*5.0)*0.01;\n    float outl1 = sdLine(p,vec2(0.0,-0.22),vec2(0.0,0.22))-0.026;\n    p = pref;\n    float outl = min(outl0,outl1);\n    \n    // R\n    float r0 =  sdLine(p,vec2(-0.25,-0.08),vec2(-0.25,0.08))-0.02;\n    float r1 =  sdEllipse(p+vec2(0.24,-0.04),vec2(0.1,0.06));\n    float r2 =  sdEllipse(p+vec2(0.24,-0.04),vec2(0.07,0.03));\n    float r3 =  sdLine(p,vec2(-0.25,0.0),vec2(-0.15,-0.08))-0.02;\n    float r = min(min(r0,max(-p.x-0.24,max(-r2,r1))),r3);\n    \n    // S\n    mat2 rot = Rot(radians(30.0));\n    p*=rot;\n    p.y+=0.025;\n    float s0 = sdEllipse(p+vec2(0.04,-0.038),vec2(0.09,0.055));\n    float s1 = sdEllipse(p+vec2(0.04,-0.038),vec2(0.05,0.025));\n    float s2 = sdEllipse(p+vec2(0.05,0.042),vec2(0.09,0.055));\n    float s3 = sdEllipse(p+vec2(0.05,0.042),vec2(0.05,0.025));\n    float s = min(max(p.x+0.05,max(-s1,s0)),max(-p.x-0.05,max(-s3,s2)));\n    p = pref;\n    \n    // -\n    float bar = sdLine(p,vec2(0.06,0.00),vec2(0.09,0.00))-0.02;\n    \n    // X\n    float x0 = sdLine(p,vec2(0.15,-0.06),vec2(0.25,0.06))-0.02;\n    float x1 = sdLine(p,vec2(0.25,-0.08),vec2(0.15,0.08))-0.02;\n    float x = min(x0,x1);\n    \n    vec2 scale = vec2(1.0-(sin(iTime*2.0)*cos(iTime*2.0))*0.03);\n    p*= scale;\n    \n    // //1\n    float bsl0 = sdLine(p,vec2(-1.02,0.2),vec2(-1.07,0.1))-0.015;\n    float bsl1 = sdLine(p,vec2(-1.09,0.2),vec2(-1.12,0.15))-0.015;\n    float bsl = min(bsl0,bsl1);\n    \n    // //2\n    float bsr0 = sdLine(p,vec2(0.92,0.21),vec2(1.0,0.16))-0.015;\n    float bsr1 = sdLine(p,vec2(0.96,0.26),vec2(1.01,0.23))-0.015;\n    float bsr = min(bsr0,bsr1);\n    \n    // //3 \n    float bsr2 = sdLine(p,vec2(0.9,-0.3),vec2(1.02,-0.24))-0.015;\n    \n    float res = min(min(min(min(min(min(min(outl,r),s),bar),x),bsl),bsr),bsr2);\n    \n    return res;\n}\n\nfloat sideA(vec2 p) {\n    vec2 pref = p;\n    \n    vec2 scale = vec2(0.5);\n    \n    p*=scale;\n    \n    float b0 =  dBox2d(p+vec2(0.0,-0.05),vec2(0.05,0.02));\n    float b1 =  dBox2d(p+vec2(0.0,0.05),vec2(0.08,0.02));\n    \n    p.x = abs(p.x);\n    p.x -= 0.12;\n    mat2 rot = Rot(radians(-20.0));\n    float b2 =  dBox2d((p+vec2(0.06,0.02))*rot,vec2(0.02,0.12));\n    p = pref;\n    \n    p*=scale;\n    float res = max(p.y-0.07,max(-p.y-0.12,min(min(b0,b1),b2)));\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 pref = p;\n    \n    // bg color\n    vec3 col = vec3(0.0);\n    \n    float doutLine = outLine(p);\n    float doutLine2 = outLine2(p+vec2(0.0,0.55));\n    float dmixTape = mixTape(p+vec2(-0.03,-0.3));\n    float dyellowCircle = yellowCircle(p+vec2(0.0,0.05));\n    float drsx = rsx(p);\n    float dsideA = sideA(p+vec2(1.01,0.5));\n    float dsideAMask = max(p.y+0.3+abs(sin(iTime*0.7)*0.5),sideA(p+vec2(1.01,0.5)));\n    float drLogo = recycleLogo(p+vec2(-0.35,0.51));\n    float dpLogo = plasticLogo(p+vec2(0.0,0.52));\n    float dpaLogo = paperLogo(p+vec2(-1.0,0.55));\n    float dpvcLogo = pvcLogo(p+vec2(0.33,0.61));\n    \n    // outline\n    col = mix( col, vec3(0.8,0.2,0.2), 1.0-smoothstep(0.0,0.007,doutLine) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.007,doutLine2) );\n    \n    // mixtape\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.007,dmixTape) );\n    \n    // yellow circle\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0,0.007,dyellowCircle) );\n    \n    // rs-x\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.007,drsx) );\n    \n    // side A\n    col = mix( col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0,0.007,dsideA) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.007,dsideAMask) );\n    \n    // informations\n    col = mix( col, vec3(0.0,0.5,0.3), 1.0-smoothstep(0.0,antialiasing,drLogo) );\n    col = mix( col, vec3(0.0,0.5,0.3), 1.0-smoothstep(0.0,antialiasing,dpLogo) );\n    col = mix( col, vec3(0.0,0.5,0.3), 1.0-smoothstep(0.0,antialiasing,dpaLogo) );\n    col = mix( col, vec3(0.0,0.5,0.3), 1.0-smoothstep(0.0,antialiasing,dpvcLogo) );\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 138, 138, 188], [190, 190, 227, 227, 311], [313, 313, 362, 362, 481], [483, 483, 550, 550, 1189], [1191, 1191, 1233, 1233, 2255], [2257, 2257, 2284, 2284, 3713], [3715, 3715, 3742, 3742, 5199], [5201, 5201, 5226, 5226, 7032], [7034, 7034, 7057, 7057, 7327], [7329, 7329, 7352, 7352, 7501], [7503, 7503, 7526, 7526, 7777], [7779, 7779, 7802, 7802, 10528], [10530, 10530, 10558, 10558, 11138], [11140, 11140, 11159, 11159, 13130], [13132, 13132, 13153, 13153, 13605], [13607, 13607, 13664, 13664, 15395]], "test": "timeout"}
{"id": "wttGzr", "name": "Twitch: Cute Pistons", "author": "blackle", "description": "another lovely shader for a wednesday stream.  don't ask about the \"PAW\" and \"blackles_correction\" it was for the memes\n\nwatch the recording here: https://www.twitch.tv/videos/517246716", "tags": ["cylinders", "liveshader", "livecode", "twitchstream", "pistons"], "likes": 4, "viewed": 318, "published": "Public API", "date": "1575514710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//see updated version here: https://www.shadertoy.com/view/3lc3R8\n\nfloat corner(vec2 p){\n  bool t = sign(p.y)+sign(p.x) == 2.;\n  return t ? length(p) : max(p.x,p.y);\n}\n\nfloat cylinf(vec3 p, vec2 dim){\n  vec2 crds = vec2(length(p.xy), p.z);\n  return corner(crds-dim);\n}\n\nfloat cyl(vec3 p, vec2 dim) {\n  vec2 crds = vec2(length(p.xy), abs(p.z));\n  return corner(crds-dim);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x);int y = FK(p.y);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat PAW = acos(-1.)*1.5;\nfloat blackles_correction = 2./1.5;\n\nvec2 piston(vec3 p, vec2 id, float scale) {\n  vec2 center = id/scale;\n  \n  vec2 offset = vec2(hash(id*vec2(0.5,0.69)),hash(id*vec2(0.85,0.19)));\n  center += offset;\n  \n  float off1 = hash(id)*PAW*blackles_correction;\n  float off2 = hash(id+vec2(off1,cos(off1)))*PAW*blackles_correction;\n  float off3 = hash(id+vec2(off2,cos(off2)))*PAW*blackles_correction;\n  float height = sin(iTime + off1) + sin(iTime*1.9 + off2)*0.9 + sin(iTime*2.9 + off3)*0.7;\n  \n  float rod = cylinf(p-vec3(center,0), vec2(0.6,height));\n  float scop = cylinf(p-vec3(center,0.), vec2(1.,(10.+height)/2.-10.));\n  float best = min(rod, scop);\n  float cap = cyl(p-vec3(center,height), vec2(1.2,0.1));\n  if (cap < best) {\n    return vec2(cap-0.05,1);\n  }\n  return vec2(best-0.1,0);\n}\n\nfloat mat = 0.;\nvec2 bestid = vec2(0);\nfloat scene(vec3 p) {\n  float scale =0.2;\n  \n  vec2 id = floor(p.xy*scale);\n  float dist = 10000.;\n  for (int i = -1; i < 2; i++) {\n    for (int j = -1; j < 2; j++) {\n      vec2 currid = vec2(id)+vec2(i,j);\n      vec2 pi = piston(p, currid, scale);\n      if (pi.x < dist) {\n        dist = pi.x;\n        mat = pi.y;\n        bestid = currid;\n      }\n    }\n  }\n  return dist;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid erot(inout vec3 p, vec3 ax, float ro) {\n  p = mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat samp(vec3 p, vec3 i, float dist) {\n  return tanh(2.*scene(p + i*dist)/dist)*0.5+0.5;\n}\n\nvec3 planeinterp(vec3 a, vec3 b, vec3 c, vec3 d, vec2 k) {\n  a*=a;\n  b*=b;\n  c*=c;\n  d*=d;\n  return sqrt(mix(mix(a, b, k.x), mix(c, d, k.x),k.y));\n}\n\nvec3 prettycol(vec2 k) {\n  return planeinterp(vec3(1,0,0), vec3(1,0.1,0.5), vec3(0.1,0.6,0.9), vec3(0.5,0.5,1), k*0.5+0.5);\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n  vec2 localbest = bestid;\n  vec3 col = vec3(0.8);\n  vec2 colr = vec2(hash(localbest*vec2(0.75,0.19)),hash(localbest*vec2(0.35,0.59)));\n  if (mat == 1.) {\n    col = mix(vec3(0.8),prettycol(colr),0.6);\n  } else {\n    col *= 0.9+colr.x*0.2;\n  }\n  vec3 n = norm(p);\n  vec3 i = reflect(cam, n);\n  float frensel = 1.-pow(abs(dot(n, cam)),2.)*0.5;\n  float s = (samp(p, i, 0.5)+samp(p, i, 2.)+samp(p, i, 4.))/3.;\n  return col*frensel*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(1.4, uv));\n  vec3 init = vec3(-9,0,5);\n  float ang1 = 0.6;\n  float ang2 = 0.6;\n  erot(cam, vec3(0,1,0), ang1);\n  erot(init, vec3(0,1,0), ang1);\n  init += vec3(iTime*5.,0,0);\n  erot(cam, vec3(0,0,1), ang2);\n  erot(init, vec3(0,0,1), ang2);\n\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 100; i++) {\n    float dist = scene(p);\n    if (abs(dist) < 0.001) { hit = true; break; }\n    if (distance(init, p) > 100.) break;\n    p += dist*cam;\n  }\n  fragColor.xyz = hit ? shade(p,cam) : vec3(0.5);\n  fragColor.xyz = smoothstep(vec3(0.1,0.1,0.05),vec3(0.9),fragColor.xyz) + hash(uv*iTime)*0.025;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttGzr.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[261, 261, 282, 282, 361], [363, 363, 394, 394, 462], [464, 464, 493, 493, 566], [623, 623, 643, 643, 722], [788, 788, 831, 831, 1539], [1580, 1580, 1601, 1601, 1954], [1956, 1956, 1975, 1975, 2089], [2091, 2091, 2135, 2135, 2194], [2196, 2196, 2236, 2236, 2288], [2290, 2290, 2348, 2348, 2438], [2440, 2440, 2464, 2464, 2565], [2567, 2567, 2597, 2597, 3029], [3031, 3031, 3088, 3088, 3855]], "test": "timeout"}
{"id": "XdK3zy", "name": "Rayleigh Scattering", "author": "EvilTak", "description": "Basic atmospheric scattering in a shader.", "tags": ["sky", "scattering", "rayleigh", "mie"], "likes": 9, "viewed": 513, "published": "Public API", "date": "1575957679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// constants\n\n#define PI (3.14159265)\n#define EARTH_RADIUS (6370997.0)\n\nconst float kOuterRadius = EARTH_RADIUS * 1.025;\nconst float kOuterRadius2 = kOuterRadius * kOuterRadius;\nconst float kInnerRadius = EARTH_RADIUS;\nconst float kInnerRadius2 = kInnerRadius * kInnerRadius;\n\nconst float kScale = 1.0 / (kOuterRadius - kInnerRadius);\nconst float kScaleDepth = 0.25;\nconst float kScaleOverScaleDepth = kScale / kScaleDepth;\nconst float kCameraHeight = 0.0001;\n\nconst float kRAYLEIGH = 0.005;\nconst float kMIE = 0.01;\n\nconst float kR4PI = kRAYLEIGH * 4.0 * PI;\n\n// Wavelength factors for scattering\nconst vec3 k_lambda_variance = vec3(0.0, 0., 0.);\nconst vec3 k_lambda = vec3(0.65, .57, 0.475) - k_lambda_variance;\n\nconst float kM4PI = kMIE * 4.0 * PI;\n\nconst float mie_g = -0.99;\nconst float mie_g2 = mie_g * mie_g;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat rayleigh_phase(float cos2) {\n    return 0.75 * (1.0 + cos2);\n}\n\nfloat mie_phase(float c, float cos2) {\n    float temp = 1.0 + mie_g2 - 2.0 * mie_g * c;\n    temp = smoothstep(0.0, 0.01, temp) * temp;\n    //temp = pow(temp, 1.5);\n    temp = max(temp, 0.0001);\n    return 1.5 * ((1.0 - mie_g2) / (2.0 + mie_g2)) * (1.0 + cos2) / temp;\n}\n\nfloat scale(float inCos) {\n    float x = 1.0 - inCos;\n    return 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvec3 renderSky(in vec3 viewDir, in vec3 lightDir) {\n    \n    //lightDir = normalize(vec3(0., 0., 1.0));\n    viewDir = normalize(viewDir);\n    //viewDir = lightDir;\n    \n    float height = kInnerRadius + kCameraHeight;\n    vec3 cameraPos = vec3(0.0, height, 0.0);\n    \n    float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));\n    // angle between eye ray and camera height\n    float startAngle = dot(viewDir, cameraPos) / height;\n    float startAngleScale = scale(startAngle);\n    float startOffset = depth * startAngleScale;\n    \n\t// Calculate the length of the \"atmosphere\"\n\tfloat far = sqrt(kOuterRadius2 + kInnerRadius2 * viewDir.y * viewDir.y - kInnerRadius2) - kInnerRadius * viewDir.y;\n\n\tvec3 pos = cameraPos + far * viewDir;\n    \n    // Initialize the scattering loop variables\n\tfloat sampleLength = far / 2.0;\n\tfloat scaledLength = sampleLength * kScale;\n\tvec3 sampleRay = viewDir * sampleLength;\n\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n    \n    vec3 invLambda = pow(k_lambda, vec3(-4.0));\n    vec3 front = vec3(0.0);\n    \n    float brightness = 20.0;// = lightDir.y <= 0.0 ? 1.0 : 20.0;\n    const float range = 0.1;\n    /*\n    if(lightDir.y >= 0.0) {\n        brightness = 20.0;\n    \tif(lightDir.y <= range)\n        \tbrightness = mix(10.0, 20.0, saturate(lightDir.y / range));\n    }\n    else {\n        brightness = 1.0;\n        if(lightDir.y >= -range)\n            brightness = mix(10.0, 1.0, saturate(-lightDir.y / range));\n    }\n    \n    lightDir.y = abs(lightDir.y);\n    */\n    for (int i = 0; i < 1; ++i) {\n        float height = length(samplePoint);\n\t\tfloat depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));\n        float lightAngle = dot(lightDir, samplePoint) / height;\n\t\tfloat cameraAngle = dot(viewDir, samplePoint) / height;\n\t\tfloat scatter = (startOffset + depth*(scale(lightAngle) - scale(cameraAngle)));\n        vec3 atten = exp(-clamp(scatter, 0.0, 50.0) * (invLambda * kR4PI + kM4PI));\n        \n        front += atten * (depth * scaledLength);\n        samplePoint += sampleRay;\n    }\n        \n    vec3 c1 = front * invLambda * kRAYLEIGH * brightness;\n    \n    vec3 c2 = front * kMIE * brightness;\n    \n    float eyeCos = -dot(viewDir, lightDir);\n    float eyeCos2 = eyeCos * eyeCos;\n    \n    float rayleigh = rayleigh_phase(eyeCos2);\n    float mie = mie_phase(eyeCos, eyeCos2);\n    \n    // mie = 0\n    \n    vec3 col = step(0.0, viewDir.y) * sqrt(rayleigh * c1 + mie * c2);\n    \n    return col;\n}\n\nvec3 rotateX(in vec3 v, in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    mat3 m = mat3(1., 0., 0.,\n                0., c, s,\n                0., -s, c);\n    \n    return m * v;\n}\n\nfloat sunAngle = 4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tvec3 dir = normalize(vec3(v.x, v.y+.5, -1.5));\n    \n    //dir = cross(dir, vec3(1.0, 0.0, 0.0));\n    //dir = vec3(0.0, 0.8, 1.);\n    \n    sunAngle = -iTime * .3;\n    \n    //dir = rotateX(dir, PI * 1.9);\n    \n    vec3 sun = normalize(rotateX(vec3(0.0, 0.0, 1.0), sunAngle));\n    \n    vec3 sky = renderSky(dir, sun);\n    fragColor = vec4(sky, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdK3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[818, 818, 843, 843, 876], [878, 878, 901, 901, 946], [948, 948, 982, 982, 1016], [1018, 1018, 1056, 1056, 1287], [1289, 1289, 1315, 1315, 1421], [1423, 1423, 1474, 1526, 3868], [3870, 3870, 3911, 3911, 4077], [4102, 4102, 4159, 4179, 4643]], "test": "ok"}
{"id": "XsfXzN", "name": "Dumb plasma", "author": "Impossible", "description": "stuff", "tags": ["plasma"], "likes": 3, "viewed": 241, "published": "Public API", "date": "1576221230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4( cos(fragCoord.y + iTime * 0.25) , 0.5, sin( length((fragCoord.xy - iResolution.xy*0.5)) * mod(iTime*0.15,0.25)) , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 198]], "test": "ok"}
