{"id": "4l2Szd", "name": "Dark corridors", "author": "Nrx", "description": "Simple 2D lighting in a procedural tile map. (Click to move the light freely.)", "tags": ["2d", "light"], "likes": 24, "viewed": 896, "published": "Public API", "date": "1445940743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rendering parameters\n#define MAZE_DENSITY\t0.5\n#define MAZE_ZOOM\t\t5.0\n#define TEXTURE_ZOOM\t0.25\n#define RAY_LENGTH\t\t5.0\n#define FADE_POWER\t\t1.5\n#define AMBIENT\t\t\t0.0\n\n// Animation parameters\n#define LIGHT_SPEED_X\t\t1.7\n#define LIGHT_MOVE_X\t\t3.0\n#define LIGHT_MOVE_Y\t\t4.3\n#define LIGHT_FREQUENCY_X\t0.2\n#define LIGHT_FREQUENCY_Y1\t0.3\n#define LIGHT_FREQUENCY_Y2\t0.5\n#define FADE_VARIATION\t\t0.2\n#define FADE_FREQUENCY\t\t3.0\n\n// Math constants\n#define SQRT2\t1.41421356237\n#define DELTA\t0.001\n\n// Animation formulas\n#define LIGHT_Y(t) LIGHT_MOVE_Y * cos (LIGHT_FREQUENCY_Y1 * (t)) * cos (LIGHT_FREQUENCY_Y2 * (t))\n#define LIGHT_DY(t) LIGHT_MOVE_Y * (LIGHT_FREQUENCY_Y1 * sin (LIGHT_FREQUENCY_Y1 * (t)) * cos (LIGHT_FREQUENCY_Y2 * (t)) + LIGHT_FREQUENCY_Y2 * cos (LIGHT_FREQUENCY_Y1 * (t)) * sin (LIGHT_FREQUENCY_Y2 *(t)))\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y));\n}\n\n// Check whether there is a wall on a given tile edge\nfloat wallCheck (in vec2 p) {\n\tvec2 tile = floor (p + 0.5);\n\tfloat wall = step (1.0 - MAZE_DENSITY, rand (tile));\n\twall *= step (max (1.0, abs (LIGHT_DY (tile.x))), abs (LIGHT_Y (tile.x) - tile.y));\n\treturn wall;\n}\n\n// Return the distance to the nearest wall\nfloat wallDistance (in vec2 rayOrigin, in vec2 rayDirection) {\n\n\t// Launch the ray\n\tvec2 raySign = sign (rayDirection);\n\tvec2 rayInv = 1.0 / rayDirection;\n\tfloat rayLength = 0.0;\n\tvec2 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_LENGTH * SQRT2; ++rayStep) {\n\n\t\t// Reach the edge of the tile\n\t\trayLength = min (rayLengthNext.x, rayLengthNext.y);\n\t\tvec2 hitNormal = step (rayLengthNext.xy, rayLengthNext.yx) * raySign;\n\n\t\t// Check whether we hit a wall\n\t\tif (wallCheck (rayOrigin + rayLength * rayDirection + hitNormal * 0.5) > 0.5) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next tile\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the distance to the hit point\n\treturn rayLength;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the coordinates\n\tfloat cameraX = LIGHT_SPEED_X * iTime;\n\tvec2 rayOrigin = MAZE_ZOOM * (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\trayOrigin.x += cameraX;\n\n\t// Lighting\n\tvec2 lightPosition;\n\tif (iMouse.z < 0.5) {\n\t\tlightPosition.x = cameraX + LIGHT_MOVE_X * cos (LIGHT_FREQUENCY_X * iTime);\n\t\tlightPosition.y = LIGHT_Y (lightPosition.x);\n\t} else {\n\t\tlightPosition = MAZE_ZOOM * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\t\tlightPosition.x += cameraX;\n\t}\n\tvec2 lightDirection = lightPosition - rayOrigin;\n\tfloat lightDistance = length (lightDirection);\n\tfloat lightIntensity = pow (max (0.0, 1.0 - lightDistance / RAY_LENGTH), FADE_POWER + FADE_VARIATION * cos (FADE_FREQUENCY * iTime));\n\tif (wallCheck (rayOrigin) < 0.5) {\n\n\t\t// Corridor\n\t\tif (lightDistance < RAY_LENGTH) {\n\t\t\tlightIntensity *= step (lightDistance + DELTA, wallDistance (rayOrigin, lightDirection / lightDistance));\n\t\t}\n\t\tfragColor = texture (iChannel0, rayOrigin * TEXTURE_ZOOM);\n\t} else {\n\n\t\t// Wall\n\t\tfragColor = texture (iChannel1, rayOrigin * TEXTURE_ZOOM);\n\t}\n\tfragColor *= mix (lightIntensity, 1.0, AMBIENT);\n\tfragColor += smoothstep (0.2, 0.0, lightDistance) * step (0.2, rand (vec2 (iTime)));\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Szd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[817, 825, 852, 852, 912], [914, 968, 997, 997, 1182], [1184, 1227, 1289, 1309, 1965], [1967, 1984, 2040, 2068, 3240]], "test": "error"}
{"id": "4l2Szy", "name": "gdp_3D", "author": "plancien", "description": "micro 3D engine", "tags": ["teaching"], "likes": 3, "viewed": 152, "published": "Public", "date": "1444660147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\n\n\nvec4 pixelColor(float pixCoordsX, float pixCoordsY) {\n    \n    vec4 color;\n    float cameraX = iResolution.x * 0.5;\n    float cameraY = iResolution.y * 0.5;\n    float zoom = (iResolution.x / 10.0);\n    \n    \n    \n    float x = (pixCoordsX - cameraX) / zoom;\n    float y = (pixCoordsY - cameraY) / zoom;\n    \n        \n    \n    /*vec3 eye = vec3(0.0, 0.0, -10.0);\n    vec3 pixel = vec3(x, y, 0.0);\n    \n    vec3 eye2pixel = pixel - eye;*/\n    \n    float groundY = 10.0;\n    \n    float k = groundY / (groundY + y);\n    \n    float yInter = 10.0 * k / (k - 1.0);\n\n    float xInter = x * yInter / 10.0;\n    \n    float oldYInter = yInter;\n    \n    yInter += 4.0 * iTime;\n\n    vec3 groundColor = vec3(1.0, 1.0, 1.0);\n    \n    float distCercle = distanceTo(mod(xInter, 50.0), mod(yInter, 100.0), 20.0, 70.0);\n    \n    if (distCercle < 20.0) {\n        groundColor = vec3(1.0, 1.0, 0.0);\n    } else if (mod(yInter, 10.0) < 5.0) {\n        if (mod(xInter, 10.0) < 5.0) {\n            groundColor = vec3(0.0, 0.0, 1.0);\n        } else {\n        \tgroundColor = vec3(1.0, 0.0, 0.0);\n        }\n    }\n    \n    \n    \n    if (oldYInter > 1000.0 || y > 0.0) {\n        color = vec4(0.3, 0.3, 0.8, 1.0);\n        return color;\n    }\n    \n    \n    float distance = sqrt(oldYInter * oldYInter + xInter * xInter);\n    \n    float light = 0.3 + 0.7 * (30.0 / distance);\n    \n    color = vec4(groundColor * light, 1.0);\n    return color;\n}\n\n\n\n\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n\n\tvec4 color1 = pixelColor(pixCoords.x, pixCoords.y);\n    vec4 color2 = pixelColor(pixCoords.x + 0.6, pixCoords.y);\n    vec4 color3 = pixelColor(pixCoords.x + 0.4, pixCoords.y + 0.5);\n    vec4 color4 = pixelColor(pixCoords.x, pixCoords.y + 0.7);\n    \n    if (pixCoords.x < 200.0) {\n        color = color1;\n    } else {\n\t    color = (color1 + color2 + color3 + color4) / 4.0;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Szy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 181], [185, 185, 238, 238, 1593], [1599, 1599, 1652, 1652, 2040]], "test": "valid"}
{"id": "4l2XDW", "name": "rainbow disk - 3", "author": "FabriceNeyret2", "description": "a variant of https://www.shadertoy.com/view/Xl2XDW\nYou can try the various commented versions,   or suppressing  \"ceil\"", "tags": ["rainbow", "short"], "likes": 4, "viewed": 1317, "published": "Public API", "date": "1443738104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(C=cos(a),S=-sin(a),-S,C)\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    float C,S, t=(iTime+15.)/1e3;\n    o -= o;\n    vec2 R = iResolution.xy, p;\n\tu = 16.3*(u+u-R)/R.y;\n    \n// #define B(k) ceil( (p=cos(u*=rot(t))).x * p.y )  * (.5+.5*cos(k)) / 31.\n// #define B(k) ceil( (p=cos(u*=rot(t))).x )        * (.5+.5*cos(k)) / 31.\n   #define B(k) ceil( (p=cos(u*=rot(t))).x )        *     cos(k)     / 4.\n// #define B(k) ceil( (p=cos(u=u*rot(t)+k)).x )     *     cos(k)     / 6.\n   \n    for (float a=0.; a<6.3; a+=.1)\n        o += vec4( B(a), B(a+2.1), B(a-2.1), 1) ;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 87, 87, 583]], "test": "valid"}
{"id": "4l2XRG", "name": "Lava Lamp - F. A.", "author": "Bosphoros", "description": "Surfaces implicites, TP avec Eric Galin", "tags": ["is"], "likes": 4, "viewed": 378, "published": "Public", "date": "1444637635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float lipschitzFallOff = 1.71730020672; // http://liris.cnrs.fr/~egfr/BestPapers/Deuxieme2014_Genevaux.pdf\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 blue=vec3(0,0.0,1.0);\nconst vec3 green=vec3(0.0,1.0,0.0);\nconst vec3 pink=vec3(0.8,0.6,0.6);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 fonce=vec3(0.141,0.117,0.078);\nconst vec3 clair=vec3(0.407,0.329,0.211);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 orangeFonce = vec3(0.3,0.0,0.0);\nconst vec3 blanc = vec3(0.9,0.9,0.9);\nconst vec3 noir = vec3(0.1,0.1,0.1);\nconst vec3 tenebres = vec3(0.0,0.0,0.0);\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nfloat bruit(in vec3 p, float frequence)\n{\n    float b = 0.0;\n    vec3 q = frequence*p;\n    b += 0.7*noise(q); q = m*q*2.01;\n    b += 0.25*noise(q); q = m*q*2.02;\n    b/= 0.7+0.25;\n    \n    return b;\n}\n\nvec3 warp(in vec3 p)\n{\n float b = bruit(p, .25);\n    vec3 pprime = p;\n    pprime.x += b;\n    pprime.y += cos(b)*b;\n    pprime.z += sin(b)*b;\n    return pprime;\n}\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment skeleton\n// p : point\n// a : first point of the segment\n// b : last point of the segment\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = length(a-b);\n    float n = dot(p-a,dir);\n    float d = 0.0;\n    // p' est avant a\n    if(n <= 0.0) {\n        d = length(p-a);\n    }\n    else {\n        // p' est aprÃ¨s b\n        if(n >= dist) {\n            d = length(p-b);\n        }\n        else {\n            d = length(p-(a+dir*n));\n        }\n    }\n    return e*falloff(d, R);   \n}\n\n// Segment skeleton\n// p : point\n// c : center of the circle\n// n : normal to the plan of the circle\n// e : energy associated to skeleton\n// r : radius of the circle\n// R : large radius \nfloat cercle(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    return e*falloff(length(p-h), R);\n    \n}\n\n// Segment skeleton\n// p : point\n// c : center of the disc\n// n : normal to the plan of the disc\n// r : radius of the disc\n// e : energy associated to skeleton\n// R : large radius \nfloat disque(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    float projhc = dot(pc, cnp);\n    vec3 pprime = c + projhc * cnp;\n    float d = 0.0;\n    if(length(c-pprime) > r)\n    {\n    \td = length(p-h);   \n    }\n    else\n    {\n        d = length(p - pprime);\n        \n    }\n    return e*falloff(d, R);\n    \n}\n\n// Box skeleton\n// p : point\n// a : bottom front left point of the box\n// b : top back right point of the box\nfloat boite(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tfloat d = 0.0;\n    \n    if(p.x < a.x) \n        d += (a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d += (b.x-p.x)*(b.x-p.x);\n\n        \n    if(p.y < a.y) \n        d += (a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d += (b.y-p.y)*(b.y-p.y);\n\n    \n    if(p.z < a.z) \n        d += (a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d += (b.z-p.z)*(b.z-p.z);\n\n    return e*falloff(d,R);\n}\n\nfloat cylindre(vec3 p, vec3 a, vec3 b, float r, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = dot(p-a, dir);\n    if(dist < 0.0)\n        return disque(p, a, dir, r, e, R);\n    else\n        if (dist > length(b-a))\n            return disque(p, b, dir, r, e, R);\n        else\n            return disque(p, a+dist*dir, dir, r, e, R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    colOut = (a*colA + b*colB) / (a+b);\n    lipsOut = lipsA + lipsB;\n    return a+b;\n}\n\nfloat Diff(float a,float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = lipsA + lipsB;\n    colOut = colA;\n    return a-b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    if( a > b)\n        colOut = colA;\n    else\n        colOut = colB;\n    return max(a,b);\n}\n\nfloat Intersection(float a, float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    if(a < b)\n        colOut = colA;\n    else\n        colOut = colB;\n \treturn min(a,b);   \n}\n\nfloat Cut(float a, float b, float t, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    colOut = colA;\n \treturn min(a, 2.0*t-b);   \n}\n\nfloat Metamorph(float a, float b, float c, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    colOut = (1.0-c)*colA+c*colB;\n   return (1.0-c)*a+c*b;\n}\n\nfloat klipschitz(float e, float R) {\n \treturn e * lipschitzFallOff / R;   \n}\n\nfloat atom(vec3 p, out float lip, out vec3 colorOut)\n{\n    lip = 0.0;\n    float lipTemp = 0.0;\n    vec3 centreSphr = vec3(0.0,0.0,0.0);\n    vec3 centreSphr1 = vec3(cos(iTime*0.25)*2.0,sin(iTime*0.4)*2.0,cos(iTime*0.1)*2.0);\n    vec3 centreSphr2 = vec3(0.5,0.0,0.0);\n    vec3 centreSphr3 = vec3(-0.5,0.0,0.0);\n    vec3 aCube = centreSphr2+vec3(-0.5,-0.5,-0.5)+vec3(0.0,3.0,2.0)*cos(iTime);\n    vec3 bCube = centreSphr2+vec3(0.5,0.5,0.5)+vec3(0.0,3.0,2.0)*cos(iTime);\n    float v = point(p,centreSphr,1.0,1.5);\n    float cube = boite(p, aCube, bCube, 0.6, 0.8);\n    float sphr1 = point(p, centreSphr2+vec3(0.0,3.0,2.0)*cos(iTime), 1.0,1.5);\n    vec3 sphrColor;\n    vec3 color;\n    sphr1 = Metamorph(sphr1, cube, abs(cos(iTime)), klipschitz(1.0,1.5), klipschitz(0.6,0.8), lipTemp, red, red, sphrColor);\n    \n    \n    v = Diff(v, point(p,centreSphr1, 1.0+abs(sin(iTime*0.8)),2.1), klipschitz(1.0, 1.5), klipschitz(1.0+abs(sin(iTime*0.8)), 2.1), lip, blue, blue, color);\n    v = Blend(v, sphr1, lip, lipTemp, lip, color, sphrColor, color);\n    v = Blend(v, point(p, centreSphr3-vec3(4.0,3.0,0.0)*cos(iTime*1.1), 1.0, 1.5), lip, klipschitz(1.0,1.5), lip, color, red, color);\n    v = Blend(v, point(p, centreSphr+vec3(2.0,0.0,2.0)*sin(iTime*0.8), 1.0, 1.5), lip, klipschitz(1.0,1.5), lip, color, red, color);\n    v = Union(v, cercle(p, centreSphr, rotateX(vec3(0.0,1.0,0.0),iTime*0.25), 1.4, 0.6,0.6), lip, klipschitz(0.6,0.6), lip, color, noir, color);\n    v = Union(v, cercle(p, centreSphr, rotateZ(vec3(0.0,1.0,0.0),iTime), 2.1, 0.6, 0.6), lip, klipschitz(0.6,0.6), lip, color, grey2, color);\n    v = Union(v, cercle(p, centreSphr, rotateX(vec3(1.0,0.0,1.0), iTime*1.2), 2.8, 0.55, 0.8), lip, klipschitz(0.55,0.8), lip, color, grey, color);\n    colorOut = color;\n    return v;\n}\n\nfloat lavaLamp(vec3 p, out float lip, out vec3 colorOut)\n{\n    lip = klipschitz(1.0,1.5);\n    vec3 cntrBulle1 = vec3(0.4*cos(iTime), ((1.0+cos(iTime*0.4))/2.0)*4.-2., 0.4*sin(iTime));\n \tfloat bulle1 = point(warp(p), cntrBulle1, 1.0, 1.5);\n    vec3 cntrBulle2 = vec3(0.2*sin(iTime), ((1.0+cos(iTime*0.2))/2.0)*3.5-1.75, 0.2*cos(iTime));\n \tfloat bulle2 = point(warp(p), cntrBulle2, 1.5, 2.0);\n    vec3 cntrBulle3 = vec3(0.5*sin(iTime+3546.), ((1.0+cos(iTime*0.3))/2.0)*4.5-2.25, 0.5*cos(iTime+3546.));\n \tfloat bulle3 = point(warp(p), cntrBulle3, 1.25, 1.75);\n    float v = Blend(bulle1, bulle2, lip, klipschitz(2.0,1.5), lip, red, orange, colorOut);\n    v = Blend(v, bulle3, lip, klipschitz(1.25,1.75), lip, colorOut, red, colorOut);\n    \n    vec3 colorLamp;\n    float hsphere = point(p, vec3(0.0, -3.5, 0.0), 4.,4.);\n    float lipH;\n    hsphere = Cut(hsphere, cylindre(p, vec3(0.,0.,0.), vec3(0.,-3.5,0.), 4., 1.0, 1.0), 0.5, klipschitz(4.,4.), klipschitz(1.,1.),lipH, mix(grey, grey2, 0.5), mix(grey, grey2, 0.5), colorLamp);\n    float bsphere = point(p, vec3(0.0, 3.0, 0.0), 2.5,2.5);\n    float lipB;\n    bsphere = Cut(bsphere, cylindre(p, vec3(0.,0.,0.), vec3(0.,3.,0.), 4., 1.0, 1.0), 0.5, klipschitz(2.,2.), klipschitz(1.,1.), lipB, mix(grey, grey2, 0.5), mix(grey, grey2, 0.5), colorLamp);\n    v = Union(v, hsphere, lip, lipH, lip, colorOut, colorLamp, colorOut);\n    v = Union(v, bsphere, lip, lipB, lip, colorOut, colorLamp, colorOut);\n    \n    \n    return v;\n    \n}\n\n// Potential field of the object\n// p : point\n// lip : lipschitz's constant\n// color : color of the point\nfloat object(vec3 p, out float lip, out vec3 color)\n{\n  p.z=-p.z;\n    \n    \n    vec3 aCube = vec3(-1.5,-1.5,-1.5);\n    vec3 bCube = vec3(1.5,1.5,1.5);\n    vec3 sphr1 = vec3(1.,0.0,0.0);\n    vec3 sphr2 = vec3(-1.,0.0,0.0);\n\n  \tfloat v = lavaLamp(p, lip, color);\n    \n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    float lip = 0.0;\n    vec3 color;\n  float v = object(p, lip, color);\n  n.x = object( vec3(p.x+eps, p.y, p.z) , lip, color) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) , lip, color) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) , lip, color) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip = 0.0;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\tfloat lip = 0.0;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lip);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\n// color : color of the point\nvec3 Shade(vec3 p, vec3 n, in vec3 color)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.5*color;\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\tvec3 color;\n  float t = SphereTrace(ro, rd, hit,s, color);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n, color);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1054, 1054, 1077, 1077, 1115], [1116, 1116, 1142, 1142, 1511], [1514, 1514, 1555, 1555, 1714], [1716, 1716, 1738, 1738, 1877], [1879, 1893, 1924, 1924, 2022], [2024, 2024, 2055, 2055, 2154], [2156, 2156, 2187, 2187, 2286], [2289, 2356, 2391, 2391, 2464], [2490, 2604, 2650, 2650, 2687], [2689, 2846, 2903, 2903, 3287], [3289, 3476, 3541, 3541, 3734], [3736, 3917, 3982, 3982, 4381], [4383, 4493, 4548, 4548, 4945], [4947, 4947, 5014, 5014, 5298], [5300, 5391, 5517, 5517, 5604], [5606, 5606, 5731, 5731, 5797], [5799, 5887, 6013, 6013, 6139], [6141, 6141, 6275, 6275, 6401], [6403, 6403, 6537, 6537, 6620], [6622, 6622, 6762, 6762, 6856], [6858, 6858, 6894, 6894, 6934], [6936, 6936, 6990, 6990, 8710], [8712, 8712, 8770, 8770, 10185], [10187, 10293, 10346, 10346, 10574], [10576, 10616, 10647, 10647, 10953], [10955, 11090, 11157, 11157, 11627], [11629, 11764, 11837, 11837, 12317], [12320, 12340, 12366, 12366, 12438], [12440, 12531, 12574, 12591, 12899], [13041, 13041, 13098, 13098, 13921]], "test": "valid"}
{"id": "4l2Xzd", "name": "Cyclotomic Trapezoids", "author": "tomkh", "description": "Non-periodic tiling based on cyclomatic trapezoids, derivation: [url]http://polycu.be/edit/?h=6j5zt6[/url]", "tags": ["tiling", "hierarchical", "aperiodic", "cyclotomic", "trapezoids"], "likes": 33, "viewed": 711, "published": "Public", "date": "1445956359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Non-periodic tiling based on cyclomatic trapezoids\n// (procedural texture and distance field)\n// by Tom @2015\n\n// Derivation: \n//    http://polycu.be/edit/?h=6j5zt6\n\n// Original shader:\n//    http://polycu.be/edit/?h=o8VzY5\n\n// Background:\n//   The tiling is derived from volume-preserving\n//   substitution rules able to produce non-periodic\n//   tilings.\n\n// For more info visit tilings encyclopedia:\n//   https://tilings.math.uni-bielefeld.de/substitution/cyclotomic-trapezoids-7-fold/\n\n#define REC0(nx,ny,nd) n=vec3(nx,ny,nd);d=dot(n.xy,q)-n.z;if(d<0.){\n#define REC1 }else{\n#define END }\n#define LEAF0(nx,ny,nd,type,tile) REC0(nx,ny,nd) c=type; c2=tile; m=u2t[tile];\n#define LEAF1(type,tile) REC1 c=type; c2=tile; m=u2t[tile];\n\n#define P 6\n#define N 5\n#define DIST(type,size) for(int i=0; i<size; ++i) { vec3 n = edge[type*N+i]; sd = min(sd, dot(n.xy,q)-n.z); }\n\nmat3 u2t[53];\nvec3 edge[P*N];\n\nvoid init()\n{\n// Prototile transformation tables\nu2t[0] = mat3(2.801937736,0,0,0,2.801937736,0,0,0,1);\nu2t[1] = mat3(-2.801937736,1e-9,0,-1e-9,-2.801937736,0,1.900968867,-3.947402529,1);\nu2t[2] = mat3(2.801937735,-1e-9,0,1e-9,2.801937735,0,-0.900968867,3.947402527,1);\nu2t[3] = mat3(-2.801937736,0,0,0,2.801937736,0,2.801937735,0,1);\nu2t[4] = mat3(2.801937736,0,0,0,2.801937736,0,0,0,1);\nu2t[5] = mat3(2.52445867,-1.215715222,0,1.215715222,2.52445867,0,0.500000001,2.190643134,1);\nu2t[6] = mat3(2.52445867,1.215715223,0,1.215715223,-2.52445867,0,1.400968869,-6.138045662,1);\nu2t[7] = mat3(-2.52445867,1.215715222,0,-1.215715222,-2.52445867,0,1.400968868,-6.138045662,1);\nu2t[8] = mat3(-0.623489802,-2.731687307,0,2.731687307,-0.623489802,0,2.024458669,0.974927912,1);\nu2t[9] = mat3(-2.524458669,-1.215715221,0,-1.215715221,2.524458669,0,2.301937736,2.190643133,1);\nu2t[10] = mat3(-2.524458669,-1.215715221,0,-1.215715221,2.524458669,0,1.900968868,3.947402527,1);\nu2t[11] = mat3(-0.623489802,2.731687307,0,-2.731687307,-0.623489802,0,0.5,-2.190643134,1);\nu2t[12] = mat3(2.801937736,1e-9,0,-1e-9,2.801937736,0,-0.222520934,0.974927911,1);\nu2t[13] = mat3(2.801937735,1e-9,0,-1e-9,2.801937735,0,-0.623489802,2.731687306,1);\nu2t[14] = mat3(-0.623489802,2.731687307,0,-2.731687307,-0.623489802,0,0.900968868,-3.947402529,1);\nu2t[15] = mat3(-2.52445867,-1.215715222,0,1.215715222,-2.52445867,0,5.04891734,0,1);\nu2t[16] = mat3(-2.524458669,1.215715222,0,1.215715222,2.524458669,0,4.048917339,-1e-9,1);\nu2t[17] = mat3(-2.524458669,-1.215715222,0,1.215715222,-2.524458669,0,5.449886207,-1.756759394,1);\nu2t[18] = mat3(2.801937735,-1e-9,0,-1e-9,-2.801937735,0,-1.123489802,-4.922330439,1);\nu2t[19] = mat3(-0.623489802,-2.731687306,0,-2.731687306,0.623489802,0,-2.524458669,3.165571045,1);\nu2t[20] = mat3(2.52445867,1.215715221,0,1.215715221,-2.52445867,0,0.5,-2.190643134,1);\nu2t[21] = mat3(-2.52445867,-1.215715222,0,-1.215715222,2.52445867,0,0.5,2.190643134,1);\nu2t[22] = mat3(2.52445867,1.215715223,0,1.215715223,-2.52445867,0,1.400968869,-6.138045662,1);\nu2t[23] = mat3(-2.52445867,1.215715222,0,-1.215715222,-2.52445867,0,1.400968868,-6.138045662,1);\nu2t[24] = mat3(0.623489802,-2.731687307,0,-2.731687307,-0.623489802,0,-0.222520934,0.974927912,1);\nu2t[25] = mat3(0.623489802,-2.731687306,0,-2.731687306,-0.623489802,0,-0.623489802,2.731687306,1);\nu2t[26] = mat3(2.52445867,-1.215715222,0,1.215715222,2.52445867,0,-0.5,2.190643134,1);\nu2t[27] = mat3(-2.801937736,-1e-9,0,-1e-9,2.801937736,0,4.826396405,0.974927913,1);\nu2t[28] = mat3(2.52445867,-1.215715222,0,1.215715222,2.52445867,0,-0.900968868,3.947402529,1);\nu2t[29] = mat3(-2.801937736,0,0,0,2.801937736,0,4.425427538,2.731687307,1);\nu2t[30] = mat3(0.623489802,2.731687307,0,2.731687307,-0.623489802,0,1.400968868,-1.756759395,1);\nu2t[31] = mat3(-2.801937736,-1e-9,0,-1e-9,2.801937736,0,2.801937736,1e-9,1);\nu2t[32] = mat3(-2.801937736,1e-9,0,-1e-9,-2.801937736,0,3.301937736,-2.190643134,1);\nu2t[33] = mat3(2.52445867,1.215715221,0,-1.215715221,2.52445867,0,-0.222520934,0.974927913,1);\nu2t[34] = mat3(-2.52445867,1.215715221,0,1.215715221,2.52445867,0,3.02445867,0.974927913,1);\nu2t[35] = mat3(-2.801937736,1e-9,0,-1e-9,-2.801937736,0,3.702906604,-3.947402529,1);\nu2t[36] = mat3(2.52445867,1.21571522,0,-1.21571522,2.52445867,0,-0.623489802,2.731687307,1);\nu2t[37] = mat3(2.52445867,-1.21571522,0,-1.21571522,-2.52445867,0,-1.123489802,-4.922330441,1);\nu2t[38] = mat3(2.801937735,-1e-9,0,1e-9,2.801937735,0,-0.900968868,3.947402528,1);\nu2t[39] = mat3(0.623489802,-2.731687306,0,-2.731687306,-0.623489802,0,-4.271438273,0.974927913,1);\nu2t[40] = mat3(-2.801937736,0,0,0,-2.801937736,0,0.5,-2.190643134,1);\nu2t[41] = mat3(2.52445867,-1.215715221,0,-1.215715221,-2.52445867,0,0.5,-2.190643134,1);\nu2t[42] = mat3(2.801937736,0,0,0,2.801937736,0,0,0,1);\nu2t[43] = mat3(-2.801937736,0,0,0,2.801937736,0,2.801937735,0,1);\nu2t[44] = mat3(-2.801937736,0,0,0,-2.801937736,0,3.301937735,-2.190643134,1);\nu2t[45] = mat3(-2.801937736,0,0,0,-2.801937736,0,0.900968868,-3.947402529,1);\nu2t[46] = mat3(2.52445867,-1.215715222,0,-1.215715222,-2.52445867,0,0.900968868,-3.947402529,1);\nu2t[47] = mat3(2.801937736,0,0,0,-2.801937736,0,-0.900968868,-3.947402529,1);\nu2t[48] = mat3(-2.801937736,0,0,0,-2.801937736,0,3.702906604,-3.947402529,1);\nu2t[49] = mat3(0.623489802,2.731687308,0,2.731687308,-0.623489802,0,5.449886208,-1.756759395,1);\nu2t[50] = mat3(0.623489801,2.731687307,0,2.731687307,-0.623489801,0,5.04891734,1e-9,1);\nu2t[51] = mat3(2.801937737,0,0,0,2.801937737,0,-0.900968868,3.947402529,1);\nu2t[52] = mat3(0.623489802,-2.731687308,0,-2.731687308,-0.623489802,0,-4.271438274,0.974927912,1);\nedge[0] = vec3(0,-1,0);\nedge[1] = vec3(0.974927912,0.222520934,0);\nedge[2] = vec3(-0.974927912,0.222520934,-0.974927912);\nedge[5] = vec3(0,-1,0);\nedge[6] = vec3(0.974927912,0.222520934,0);\nedge[7] = vec3(-0.433883739,0.900968868,-2.190643134);\nedge[8] = vec3(-0.974927912,-0.222520934,-0.974927912);\nedge[10] = vec3(0,-1,0);\nedge[11] = vec3(0.974927912,0.222520934,0);\nedge[12] = vec3(0,1,-1.756759395);\nedge[13] = vec3(-0.974927912,0.222520934,-1.756759395);\nedge[15] = vec3(0,-1,0);\nedge[16] = vec3(0.974927912,0.222520934,0);\nedge[17] = vec3(-0.433883739,0.900968868,-2.190643134);\nedge[18] = vec3(-0.974927912,0.222520934,-1.756759394);\nedge[20] = vec3(0,-1,0);\nedge[21] = vec3(0.974927912,-0.222520934,0);\nedge[22] = vec3(0.433883739,0.900968868,-1.756759395);\nedge[23] = vec3(-0.433883739,0.900968868,-2.190643134);\nedge[24] = vec3(-0.974927912,-0.222520934,-0.974927912);\nedge[25] = vec3(0,-1,0);\nedge[26] = vec3(0.781831483,-0.623489802,0);\nedge[27] = vec3(0.433883739,0.900968868,-1.756759395);\nedge[28] = vec3(-0.433883739,0.900968868,-2.190643134);\nedge[29] = vec3(-0.974927912,-0.222520934,-0.974927912);\n}\n\nfloat get_dist(int c,vec2 q) \n{\n   float sd = 1.;\n   if (c<4) {\n      if (c<2) {\n         if (c==0) { DIST(0,3) }\n         else { DIST(1,4) }\n      } else {\n         if (c==2) { DIST(2,4) }\n         else { DIST(3,4) }\n      }\n   } else {\n      if (c==4) { DIST(4,5) }\n      else { DIST(5,5) }\n   }\n   return sd;\n}\n\nfloat get_dist2(int c,vec2 q)\n{\n   float sd = get_dist(c,q);\n   return min(sd,.05)*2.+min(sd,.2)*4.; //smoothstep(0.,1.,sd);\n}\n\nvec3 rgb(int r,int g,int b) {\n   const float f = 1./255.;\n   return vec3(float(r)*f,float(g)*f,float(b)*f);\n}\n\nvec3 get_color(int c)\n{\n   // TODO: auto-generate this\n   float sd = 1.;\n   if (c<4) {\n      if (c<2) {\n         if (c==0) return rgb(252,145,43);\n         else return rgb(255,205,102);\n      } else {\n         if (c==2) return rgb(56,56,108);\n         else return rgb(189,201,228);\n      }\n   } else {\n      if (c==4) return rgb(107,115,163);\n      else return rgb(106,106,106);\n   }\n   return vec3(0);\n}\n\nvec3 shade(int c,vec2 q,vec2 q0,mat3 m2)\n{\n   float sd = get_dist2(c,q);\n   vec3 base = get_color(c);\n   base -= texture(iChannel0,q0*.01*iResolution.y).xyz*.1; //add some grain-effect\n\n   base *= sd; //min(1.,sd*1.4);\n   const float eps = .0001;\n   vec3 norm = normalize(vec3(\n       get_dist2(c,vec2(m2*vec3(q0.x+eps,q0.y,1)))\n      - get_dist2(c,vec2(m2*vec3(q0.x-eps,q0.y,1))),\n       eps*2.,\n       get_dist2(c,vec2(m2*vec3(q0.x,q0.y+eps,1)))\n      - get_dist2(c,vec2(m2*vec3(q0.x,q0.y-eps,1)))));\n   base += max(0.,dot(norm,normalize(vec3(.1,.1,.5))))*.2;\n   return base;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   init();\n\n   vec2 q, q0;\n\n   vec3 n;\n   int c2;\n   float d;\n   vec3 last_iter_color;\n   mat3 m, m2 = mat3(1);\n    \n   int c = 2; // starting prototile\n   \n   float f_iterations = (iMouse.z > 0.0) ? iMouse.y*6./iResolution.y+1. : 4.;\n   int iterations = int(ceil(f_iterations));\n   f_iterations = fract(f_iterations);\n   if (f_iterations==0.) f_iterations=1.;\n\n   // Transform to tile space\n   float scale = .5/iResolution.y;\n   q0 = (fragCoord - iResolution.xy*.5)*vec2(scale,-scale);\n   q0 += vec2(.9,-.7);\n\n   // Animate panning:\n   float anim = (iMouse.z > 0.0) ? 0. : iTime;\n   q0 += vec2(cos(anim*.4),sin(anim*.3))*.1;\n   \n   q = q0;\n\n//-----------------------------------------------------------\n// Tiling code automatically (partially) generated\n\nfor(int it=0; it<6; ++it) {\nif (it >= iterations) break;\nif (c < 4) {\nif (c < 2) {\nif (c == 0) {\n// prototile 0\nREC0(0.974927912,0.222520934,0.347947743)\n LEAF0(0.433883739,-0.900968868,0.781831482,1,0)\n REC1\n  LEAF0(0,-1,1.408811651,4,1)\n  LEAF1(0,2)\n  END\n END\nREC1\n LEAF0(0.433883739,0.900968868,-0.347947744,4,1)\n LEAF1(3,3)\n END\nEND\n} else {\n// prototile 1\nREC0(0.781831482,0.623489802,0)\n REC0(0.781831482,0.623489802,-0.347947744)\n  LEAF0(0,-1,1.408811651,4,5)\n  LEAF1(3,6)\n  END\n REC1\n  LEAF0(0.433883739,-0.900968868,0.781831482,1,4)\n  REC1\n   LEAF0(0.781831483,-0.623489802,1.408811651,4,5)\n   LEAF1(1,7)\n   END\n  END\n END\nREC1\n REC0(0.433883739,-0.900968868,0.781831482)\n  LEAF0(0.974927912,0.222520934,0.347947743,1,4)\n  LEAF1(2,8)\n  END\n REC1\n  LEAF0(0.433883739,-0.900968868,1.408811651,2,9)\n  LEAF1(0,10)\n  END\n END\nEND\n}\n} else {\nif (c == 2) {\n// prototile 2\nREC0(0,-1,0.974927912)\n REC0(-0.433883739,-0.900968868,0)\n  LEAF0(0.974927912,-0.222520934,0.781831482,1,11)\n  REC1\n   LEAF0(0.974927912,-0.222520934,1.408811651,2,14)\n   LEAF1(1,15)\n   END\n  END\n REC1\n  REC0(0.974927912,-0.222520934,0.781831482)\n   LEAF0(0,-1,0.347947743,1,11)\n   LEAF1(2,12)\n   END\n  REC1\n   LEAF0(0.781831482,-0.623489802,1.408811651,2,16)\n   LEAF1(2,17)\n   END\n  END\n END\nREC1\n REC0(-0.433883739,-0.900968868,0.626980169)\n  LEAF0(0.781831482,-0.623489802,1.408811651,2,16)\n  LEAF1(2,17)\n  END\n REC1\n  LEAF0(0.974927912,-0.222520934,0.781831482,0,13)\n  REC1\n   LEAF0(0.974927912,-0.222520934,1.129779226,1,18)\n   LEAF1(2,19)\n   END\n  END\n END\nEND\n} else {\n// prototile 3\nREC0(0.433883739,-0.900968868,1.408811651)\n REC0(0.433883739,-0.900968868,0.781831482)\n  LEAF0(0.974927912,0.222520934,0.347947743,1,20)\n  REC1\n   LEAF0(0.974927912,0.222520934,0.974927912,2,24)\n   LEAF1(1,25)\n   END\n  END\n REC1\n  REC0(0.974927912,0.222520934,0.974927912)\n   LEAF0(0.781831482,0.623489802,0,4,21)\n   LEAF1(2,26)\n   END\n  REC1\n   LEAF0(0,-1,0.347947743,1,25)\n   LEAF1(2,27)\n   END\n  END\n END\nREC1\n REC0(0.781831483,0.623489802,0)\n  REC0(0.781831483,-0.623489802,1.408811651)\n   LEAF0(0,-1,1.408811651,4,21)\n   LEAF1(1,22)\n   END\n  REC1\n   LEAF0(0.974927912,0.222520934,0.347947743,1,22)\n   LEAF1(3,23)\n   END\n  END\n REC1\n  LEAF0(0,-1,0.974927912,2,27)\n  REC1\n   LEAF0(0.974927912,0.222520934,0.974927912,0,28)\n   LEAF1(0,29)\n   END\n  END\n END\nEND\n}\n}\n} else {\nif (c == 4) {\n// prototile 4\nREC0(-0.433883739,-0.900968868,0.974927912)\n REC0(-0.433883739,-0.900968868,0.347947743)\n  REC0(0.974927912,-0.222520934,0.974927912)\n   LEAF0(0.974927912,-0.222520934,0.626980169,2,30)\n   LEAF1(1,31)\n   END\n  REC1\n   LEAF0(0,-1,0.781831483,0,32)\n   LEAF1(2,35)\n   END\n  END\n REC1\n  REC0(0.974927912,-0.222520934,0.974927912)\n   LEAF0(0.781831483,-0.623489802,0.781831483,2,33)\n   LEAF1(4,34)\n   END\n  REC1\n   LEAF0(0,-1,1.408811651,2,35)\n   LEAF1(2,39)\n   END\n  END\n END\nREC1\n REC0(-0.781831482,-0.623489802,0.626980169)\n  LEAF0(0,-1,1.408811651,4,34)\n  REC1\n   LEAF0(0.974927912,0.222520934,0.347947744,5,38)\n   LEAF1(2,39)\n   END\n  END\n REC1\n  LEAF0(0.781831483,-0.623489802,0.781831483,0,36)\n  REC1\n   LEAF0(0.781831483,-0.623489802,1.129779226,1,37)\n   LEAF1(5,38)\n   END\n  END\n END\nEND\n} else {\n// prototile 5\nREC0(0,-1,0.781831482)\n REC0(-0.433883739,-0.900968868,0.347947743)\n  REC0(0.974927912,0.222520934,0)\n   LEAF0(-0.974927912,0.222520934,0,0,40)\n   LEAF1(0,41)\n   END\n  REC1\n   LEAF0(0.974927912,-0.222520934,0.626980169,3,42)\n   REC1\n    LEAF0(0.974927912,-0.222520934,0.974927912,1,43)\n    LEAF1(0,44)\n    END\n   END\n  END\n REC1\n  REC0(0.974927912,0.222520934,0)\n   LEAF0(-0.974927912,0.222520934,0,0,40)\n   REC1\n    LEAF0(-0.433883739,-0.900968868,0.781831482,0,41)\n    LEAF1(2,46)\n    END\n   END\n  REC1\n   LEAF0(0.433883739,-0.900968868,0.781831482,3,42)\n   LEAF1(4,47)\n   END\n  END\n END\nREC1\n REC0(0,-1,1.408811651)\n  REC0(0.974927912,0.222520934,0)\n   LEAF0(-0.974927912,0.222520934,0,2,45)\n   REC1\n    LEAF0(-0.433883739,-0.900968868,1.408811651,2,46)\n    LEAF1(1,50)\n    END\n   END\n  REC1\n   LEAF0(0.974927912,-0.222520934,0.974927912,4,47)\n   LEAF1(2,48)\n   END\n  END\n REC1\n  REC0(0.974927912,-0.222520934,0.626980169)\n   LEAF0(-0.974927912,0.222520934,0,2,49)\n   LEAF1(1,50)\n   END\n  REC1\n   LEAF0(0.974927912,0.222520934,0.347947743,4,51)\n   LEAF1(2,52)\n   END\n  END\n END\nEND\n}\n}\n// Transform to prototile\nm2 = m * m2;\nq = vec2(m * vec3(q,1));\nif (it == iterations-2 && f_iterations < .997) {\n   last_iter_color = shade(c,q,q0,m2);\n}\n}\n//-----------------------------------------------------------\n\n   vec3 base = shade(c,q,q0,m2);\n   base = mix(last_iter_color, base, f_iterations);\n   base = pow(base,vec3(.7));\n   fragColor = vec4(base,1.);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Xzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[901, 901, 914, 949, 6656], [6973, 6973, 7004, 7004, 7099], [7101, 7101, 7130, 7130, 7210], [7212, 7212, 7235, 7266, 7616], [7618, 7618, 7660, 7660, 8197]], "test": "error"}
{"id": "4l2XzG", "name": "Surface implicite", "author": "Tsubaki", "description": "projet surface implicite", "tags": ["surface"], "likes": 2, "viewed": 163, "published": "Public", "date": "1444644005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs\n// Eric Galin\n\nconst float lambda = 1.717300206719838;\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// Noise ------------------------------------------------------------\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  \treturn e*falloff(length(p-c),R);\n}\n\nfloat distLine(in vec3 p,in vec3 a, in vec3 b)\n{\n    vec3 u = normalize(b-a);\n    float dist = dot(u, (p-a));\n    \n    if(dist <0.0)\n        return length(p-a);\n        \n    if(dist > length(b-a))\n        return length(p-b);\n    \n    return length(p-(a+dist*u));\n}\n\nfloat distCircle(vec3 p, vec3 c, vec3 n, float r){\n    n= normalize(n);\n    vec3 cp=p-c;\n    float scal = dot(cp,n);\n    float dicarre=dot(cp,cp)-scal*scal;\n    float dist=abs(sqrt(dicarre)-r);\n    return sqrt(dist*dist+scal*scal);\n}\nfloat distDisk(vec3 p, vec3 c, vec3 n, float r){\n    n= normalize(n);\n    vec3 cp=p-c;\n    float scal = dot(cp,n);\n    float dicarre=dot(cp,cp)-scal*scal;\n    float dist=max(sqrt(dicarre)-r,0.0);\n    return sqrt(dist*dist+scal*scal);\n}\n\nfloat circle(vec3 p, vec3 c, vec3 n,float rad, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  return e*falloff(distCircle(p,c,n,rad),R);\n}\n\nfloat disk(vec3 p, vec3 c, vec3 n,float rad, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  return e*falloff(distDisk(p,c,n,rad),R);\n}\n\n\nfloat seg(in vec3 p,in vec3 a, in vec3 b, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  return e*falloff(distLine(p,a,b) ,R);\n}\n\nfloat distCylindre(in vec3 p,in vec3 a, in vec3 b, in float rayon)\n{\n    vec3 u = normalize(b-a);\n    float ha = dot((p-a),u);\n    float hb = dot((p-b),u);\n    \n   \n    if(ha < 0.0)\n   \t\treturn  distDisk(p, a, b-a, rayon);\n    if(hb > 0.0)\n        return  distDisk(p, b, b-a, rayon);\n  \n    return max(distLine(p,a,b)-rayon,0.0);\n}\n\nfloat cylindre(in vec3 p,in vec3 a, in vec3 b, float rayon, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n    return e*falloff(distCylindre(p,a,b, rayon) ,R);\n}\n\nfloat distTube(in vec3 p,in vec3 a, in vec3 b, in float rayon)\n{\n    vec3 u = normalize(b-a);\n    float ha = dot((p-a),u);\n    float hb = dot((p-b),u);\n    \n   \n    if(ha < 0.0)\n   \t\treturn  distDisk(p, a, b-a, rayon);\n    if(hb > 0.0)\n        return  distDisk(p, b, b-a, rayon);\n  \n    return abs(distLine(p,a,b)-rayon);\n}\n\nfloat tube(in vec3 p,in vec3 a, in vec3 b, float rayon, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n    return e*falloff(distTube(p,a,b, rayon) ,R);\n}\n\nfloat distCube(in vec3 p,in vec3 a, in vec3 b)\n{\n    float d = 0.0;\n    \n    if(p.x < a.x)\n        d+=(a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d+=(b.x-p.x)*(b.x-p.x);\n        else\n            d+=0.0;\n        \n    if(p.y < a.y)\n        d+=(a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d+=(b.y-p.y)*(b.y-p.y);\n        else\n            d+=0.0;\n        \n    if(p.z < a.z)\n        d+=(a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d+=(b.z-p.z)*(b.z-p.z);\n        else\n            d+=0.0;\n        \n        \n    return sqrt(d);\n}\n\nfloat cube(in vec3 p,in vec3 a, in vec3 b, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n    return e*falloff(distCube(p,a,b) ,R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = lipA + lipB;\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = max(lipA, lipB);\n    return max(a,b);\n}\n\nfloat Intersection(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = max(lipA, lipB);\n    return min(a,b);\n}\n\nfloat Difference(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = max(lipA, lipB);\n    return min(a,2.0*T-b);\n}\n\nfloat DemandeAFlo(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = lipA + lipB;\n    return a-b;\n}\n\nfloat Minion(in vec3 p, out float lip)\n{\n    vec3 a = vec3(-0.9, 2.0, -2.0);\n    vec3 b = vec3(0.9, 2.0, -2.0);\n    vec3 directionZ = vec3(0.0, 0.0, 1.0);\n    float lip2;\n    \n  \tfloat v = seg(p,vec3( 0.0, -1.5, 0.0), vec3( 0.0, 2.0, 0.0), 1.0,4.5, lip);\n    //bandeau\n    v = Union(v, circle(p,vec3( 0.0, 2.0, 0.0), vec3( 0.0, 2.2, 0.0), 2.0, 1.0,0.5,lip2),lip,lip2,lip);\n    v =  Difference(v,cube(p,vec3( -0.7, 2.0, -2.0), vec3( 0.7, 2.0, -1.0), 0.7, 1.0,lip2),lip,lip2,lip); \n    //yeux\n   \tv = Union(v,cylindre(p,a, vec3( -0.9, 2.0,1.0), 0.25, 1.0,1.0,lip2),lip,lip2,lip);\n    v= Union(v,cylindre(p,b, vec3( 0.9, 2.0,1.0), 0.25, 1.0,1.0,lip2),lip,lip2,lip);\n    //lunettes\n    v =  Union(v,circle(p, a, directionZ , 0.6, 0.8,1.0,lip2),lip,lip2,lip);\n    v =  Union(v,circle(p, b, directionZ , 0.6, 0.8,1.0,lip2),lip,lip2,lip);\n    \n    //bras gauche\n    v = Blend(v,cylindre(p,vec3( 2.0, 0.25, 0.0), vec3( 3.0, -0.5, 0.0), 0.01, 1.0,0.6,lip2),lip,lip2,lip);\n    v = Blend(v,cylindre(p,vec3( 3.0, -0.5, 0.0), vec3( 3.0, -2.0, 0.0), 0.01, 1.0,0.5,lip2),lip,lip2,lip);\n    \n    vec3 couded= vec3( -4.2, 0.5, 0.0);\n    vec3 maind= vec3(-3.0, -0.5, 0.0);\n    float angle=cos(iTime*10.0);\n    maind= rotateZ(maind-couded,angle*3.14/4.0+3.5)+couded;\n    \n    //bras droit\n    v = Blend(v,cylindre(p,vec3(-2.0, 0.25, 0.0), vec3( -4.0, 0.5, 0.0), 0.01, 1.0,0.6,lip2),lip,lip2,lip);\n    v = Blend(v,cylindre(p,couded,maind, 0.01, 1.0,0.5,lip2),lip,lip2,lip);\n\n    //jambe droite\n    v = Blend(v, cylindre(p, vec3(-0.9, -3.0, 0.0), vec3(-0.9, -4.0, 0.0), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    v = Blend(v, cylindre(p, vec3(-0.9, -4.25, 0.25), vec3(-1.1, -4.25, -0.75), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    \n    \n    //jambe gauche\n    v = Blend(v, cylindre(p, vec3(0.9, -3.0, 0.0), vec3(0.9, -4.0, 0.0), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    v = Blend(v, cylindre(p, vec3(0.9, -4.25, 0.25), vec3(1.1, -4.25, -0.75), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    \n    v =  Difference(v,cube(p,vec3( -1.5, -5, -3.0), vec3( 1.5, -4.7, 1), 0.7, 1.0,lip2),lip,lip2,lip);;\n    \n    //bouche\n    float bouche=(cos(iTime)+1.0)/4.0;\n    v =  Difference(v,seg(p,vec3( -0.5, -0.5, -2), vec3( 0.5, -0.5, -2), 1.0,1.0-bouche,lip2),lip,lip2,lip); \n    \n    float nez=(cos(iTime*2.0)+1.0)*4.0;\n    v = Union(v, cylindre(p, vec3(0.0, 0.75, -2.0), vec3(0.0, 0.75, -2.0-nez), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n\treturn v;\n}\n\n// Potential field of the object\n// p : point\nfloat object(in vec3 p, out float lip)\n{\n  p.z=-p.z;\n    float v;\n  //float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n   //               point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  //v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  //v=Union(v,point(p,vec3(-1.0, -1.0, 0.0),1.0,4.5));\n    \n   \t/*vec3 temp=p*0.5;\n    float xw=noise(temp);\n    temp=temp*m;\n    float yw=noise(temp);\n    temp=temp*m;\n    float zw=noise(temp);\n    \n    vec3 pp=p;\n    pp.x+=xw;\n    pp.y+=yw;\n    pp.z+=zw;*/\n    \n    //v = point(p, vec3(0.0, 0.0, 0.0), 1.0,4.5, lip);\n    \n\t//v = seg(p,vec3(-2.5, 0.0, 0.0), vec3(2.5, 0.0, 0.0), 1.0,4.5, lip);\n    //v = circle(pp, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0),3.5, 1.0,1.0);\n    //v = disk(pp, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0),2.5, 1.0,1.0);\n    //v = cylindre(pp,vec3(-3.5, 0.0, 0.0), vec3(3.5, 0.0, 0.0), 2.5, 1.0,1.0);\n    //v = cube(pp,vec3(-1.5, -1.5, -1.5), vec3(1.5, 1.5, 1.5), 1.0,4.5);\n    \n    //v=DemandeAFlo(point(p,vec3(-1.5, 0.0, 0.0),1.0,4.5),\n    //        point(p,vec3( 1.0, 0.0,0.0),1.0,3.5));\n  \n    \n  v= Minion(p, lip);\n    \n  return v-T;\n}\n\n                 \n                  \n                   \n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    float lip;\n  float v = object(p, lip);\n    \n  n.x = object( vec3(p.x+eps, p.y, p.z), lip) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z), lip ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps), lip ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip;\n    float v = object(p, lip);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip;\n    float v = object(p, lip);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lip);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 469, 492, 492, 530], [531, 531, 557, 557, 926], [929, 943, 974, 974, 1072], [1074, 1074, 1105, 1105, 1204], [1206, 1206, 1237, 1237, 1336], [1339, 1406, 1441, 1441, 1514], [1540, 1654, 1715, 1715, 1773], [1775, 1775, 1823, 1823, 2039], [2041, 2041, 2091, 2091, 2274], [2275, 2275, 2323, 2323, 2510], [2512, 2512, 2592, 2592, 2659], [2661, 2661, 2739, 2739, 2804], [2807, 2807, 2882, 2882, 2944], [2946, 2946, 3014, 3014, 3277], [3279, 3279, 3372, 3372, 3447], [3449, 3449, 3513, 3513, 3772], [3774, 3774, 3863, 3863, 3934], [3936, 3936, 3984, 3984, 4480], [4482, 4482, 4558, 4558, 4622], [4625, 4716, 4791, 4791, 4832], [4834, 4922, 4997, 4997, 5047], [5049, 5049, 5131, 5131, 5181], [5183, 5183, 5263, 5263, 5319], [5321, 5321, 5402, 5402, 5443], [5445, 5445, 5485, 5485, 7851], [7853, 7899, 7939, 7939, 9005], [9064, 9104, 9135, 9135, 9395], [9397, 9502, 9553, 9553, 10010], [10012, 10117, 10174, 10174, 10647], [10650, 10670, 10696, 10696, 10768], [10770, 10831, 10859, 10876, 11193], [11335, 11335, 11392, 11392, 12195]], "test": "valid"}
{"id": "4l2XzV", "name": "Scale-invariant dots", "author": "blair1618", "description": "A dot pattern that adjusts itself to remain nearly invariant under scaling", "tags": ["2d", "fractal"], "likes": 5, "viewed": 185, "published": "Public", "date": "1445062928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 c, float r)\n{\n    return 1. - smoothstep(r * 0.975, r * 1.025, length(uv - c));\n}\n\n// Replace this with a signed distance field sampler for more flexibility\nfloat dots_base(vec2 uv, float scale, float weight)\n{\n    uv = mod(uv, scale);\n    float r = 0.2 * scale * weight;\n    return circle(uv, vec2(0.25 * scale), r) + circle(uv, vec2(0.75 * scale), r);\n}\n\nfloat dots_blended(vec2 uv, float scale)\n{\n    float f = fract(log2(scale));\n    float scale0 = .5 * exp2(f);\n    float scale1 = .5 * scale0;\n    float blend = smoothstep(.35, .65, f);\n    return dots_base(uv, scale0, 1. - blend) + dots_base(uv, scale1, blend);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    float scale = abs(.55 + .45 * sin(iTime / 1.2));\n    fragColor = vec4(uv, .5 + .5 * sin(iTime), 1.0);\n    fragColor *= dots_blended(uv - vec2(.5), scale);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 108], [110, 184, 237, 237, 382], [384, 384, 426, 426, 647], [649, 649, 706, 706, 931]], "test": "valid"}
{"id": "4lBGDh", "name": "Tetris FX", "author": "praxlor", "description": "A collection of old projects modified being inspired by Tetris Effect: Connected. - PolicyChanges", "tags": ["space", "stars", "blackhole"], "likes": 1, "viewed": 202, "published": "Public", "date": "1445871821", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define JETS_ON\n\n// My edit of https://www.shadertoy.com/view/XdjXDy\n// So yeah, thank bloodnok for this brilliant shader, not me\n// The original one just had some visual problems which I corrected\n// Or I should probably say; 'corrected' to fit my own taste\n// So don't praise me, praise bloodnok\n\n//edit: edit: more acurate illumination, color, and spin-policychanges\n#define GLOW 0.0013 \n// To play music and fx press the pause/play button next to iChannel3 at the bottom right\n\n// also, the nebualae noise generation incidentally creates \n// an O-piece top right of the blackhole around 343 seconds XD\n// MIT License\n\n#define brightness 0.0029\n#define darkmatter 0.300\n#define distfading 0.750\n#define saturation 0.850\n\n#define iterations 15\n#define magicnum 0.53\n\n#define volsteps 30\n#define stepsize 0.13\n//#define stepsize 0.1\n\n#define zoom 0.800\n#define tile 0.850\n#define speed 0.0002\n\n#define PI 3.14159\n\n#define FREQ_CHANNEL iChannel3\n\nconst float pi = 3.1415927;\n\n// distance map functions\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// blackhole ps color\nvec4 bh(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float freqs[4];\n\n    freqs[0] = texture(FREQ_CHANNEL, vec2(0.01, 0.25)).x;\n    freqs[1] = texture(FREQ_CHANNEL, vec2(0.07, 0.25)).x;\n    freqs[2] = texture(FREQ_CHANNEL, vec2(0.15, 0.25)).x;\n    freqs[3] = texture(FREQ_CHANNEL, vec2(0.30, 0.25)).x;\n\n    float glow_mul = freqs[0] + freqs[1] * 0.15 + freqs[2] * 0.25;\n    glow_mul = pow(glow_mul, 1.7);\n\n    vec4 ret = vec4(0.);\n    vec2 pp = fragCoord.xy / iResolution.xy;\n    pp = -1.0 + 2.0 * pp;\n    pp.x *= iResolution.x / iResolution.y;\n\n    vec3 lookAt = vec3(1., .0, 0.0);\n\n    float eyer = 1.3;\n    float eyea = (iMouse.x / iResolution.x) * pi * 2.0;\n    float eyea2 = ((iMouse.y / iResolution.y) - 0.21) * pi * 2.0;\n\n    vec3 ro = vec3(\n        eyer * cos(eyea) * sin(eyea2),\n        eyer * cos(eyea2),\n        eyer * sin(eyea) * sin(eyea2)); //camera position\n\n    // todo: unify spacial coordinates\n    vec3 front = normalize(lookAt - ro);\n    vec3 left = normalize(cross(normalize(vec3(0.0, 1, -0.13)), front));\n    vec3 up = normalize(cross(front, left));\n    vec3 rd = normalize(front * 1.115 + left * pp.x + up * pp.y); // rect vector\n\n    vec3 bh = vec3(1.3, 0.0, 1.); // blackhole position\n    float bhr = 0.1; // radius\n    float bhmass = 5.0; // mass\n    bhmass *= 0.001; // premul G\n\n    vec3 p = ro; // camera pos\n    vec3 pv = rd;\n    float dt = 0.02; // step\n\n    vec3 col = vec3(0.0);\n\n    float noncaptured = 1.0;\n\n    vec3 c1 = vec3(0.3, 0.3, 0.35); // accretion disc color mix 1\n    vec3 c2 = vec3(0.7, 0.8, 0.83); // accretion disc color mix 2\n\n    float glow = 0.0019; // glow\n\n    float radius = 0.17;\n\n    vec3 bhv;\n    vec3 dcol = vec3(0.);\n    float sd_disc = 0.;\n\n    for (float t = 0.0; t < 1.0; t += 0.005) {\n        p += pv * dt * noncaptured;\n\n        // gravity\n        bhv = bh - p;\n        float r = dot(bhv, bhv);\n        pv += normalize(bhv) * ((bhmass) / r);\n\n        noncaptured = smoothstep(0.0, 0.566, sdSphere(p - bh, bhr));\n\n        // Texture for the accretion disc\n        float dr = length(bhv.xz);\n        float da = atan(bhv.x, bhv.z);\n        \n        vec2 ra = vec2(dr, \n        da * (0.01 + (dr - bhr) * 0.002) + 2.0 * pi + iTime * 0.003 + abs(pow(glow_mul / 300., 1.2)));\n        \n        ra *= vec2(10.0, 20.0);\n\n        // Accretion disc color\n        dcol = mix(c2, c1, pow(length(bhv) - bhr, 4.0)) * max(0.0, texture(iChannel1, ra * vec2(0.1, 0.5)).r + 0.05) * (4.0 / ((0.001 + (length(bhv) - bhr) * 50.0)));\n\n        sd_disc = smoothstep(0.0, 1.0, -sdTorus((p * vec3(1.0, 25.0, 1.0)) - bh, vec2(0.8, 0.99)));\n\n        col += max(vec3(0.0), dcol * sd_disc * noncaptured);\n\n#ifdef JETS_ON\n        col += dcol * (1.0 / dr) * noncaptured * 0.01;\n#endif\n        // Glow\n        col += vec3(1.0, 0.9, 0.85) * (1.0 / vec3(dot(bhv, bhv))) * glow * glow_mul * noncaptured;\n    }\n\n    col *= vec3(0.72, 0.8, 1.0) * 1.2;\n\n    ret = vec4(length(bhv) - bhr);\n    ret.y = length(bhv);\n    ret.z = bhr;\n    ret.w = glow_mul;\n\n    // blackhole color\n    fragColor = vec4(col, 1.0);\n\n    return ret;\n}\n\nfloat SCurve(float value)\n{\n\n    if (value < 0.5) {\n        return value * value * value * value * value * 16.0;\n    }\n\n    value -= 1.0;\n\n    return value * value * value * value * value * 16.0 + 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec4 bhb = bh(fragColor, fragCoord);\n\n    float ruv = length((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.) * exp(-ruv * 1.1) * 1.15;\n\n    vec3 p1, p2;\n\n    float resolution = max(iResolution.y, iResolution.y);\n\n    // starfield\n    vec4 L, C;\n\n    // get coords and direction\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 dir = vec3(uv * zoom, 1.);\n    float time = iTime * speed + .2;\n\n\tfloat a1 = .5 + iMouse.x / iResolution.x * 2.;\n\tfloat a2 = .8 + iMouse.y / iResolution.y * 2.;\n\n    mat2 rot1 = mat2(cos(a1), sin(a1), -sin(a1), cos(a1));\n    mat2 rot2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));\n    \n    dir.xz *= rot1;\n    dir.xy *= rot2;\n    \n    vec3 from = vec3(1., .5, 0.5);\n    \n    from += vec3(time * 2., time, -2.);\n    from.xz *= rot1;\n    from.xy *= rot2;\n\n    // volumetric rendering\n    float s = 0.1, fade = 1.;\n    vec3 v = vec3(0.);\n    \n    for (int r = 0; r < volsteps; r++) {\n        vec3 p = from + s * dir * .5;\n        \n        p = abs(vec3(tile) - mod(p, vec3(tile * 2.))); // tiling fold\n        \n        float pa, a = pa = 0.;\n        \n        for (int i = 0; i < iterations; i++) {\n            p = abs(p) / dot(p, p) - magicnum;\n            a += abs(length(p) - pa); // absolute sum of average change\n            pa = length(p);\n        }\n        float dm = max(0., darkmatter - a * a * .001); //dark matter\n        a = pow(a, 2.5); // add contrast\n        if (r > 6)\n            fade *= 1. - dm; // dark matter, don't render near\n        //v+=vec3(dm,dm*.5,0.);\n        v += fade;\n        v += vec3(s, s * s, s * s * s * s) * a * brightness * fade; // coloring based on distance\n        fade *= distfading; // distance fading\n        s += stepsize;\n    }\n\n    v = mix(vec3(length(v)), v, saturation); //color adjust\n\n    C = vec4(v * .01, 1.);\n\n    C.r = pow(C.r, 0.35);\n    C.g = pow(C.g, 0.36);\n    C.b = pow(C.b, 0.4);\n\n    L = C;\n\n    C.r = mix(L.r, SCurve(C.r), 1.0);\n    C.g = mix(L.g, SCurve(C.g), 0.9);\n    C.b = mix(L.b, SCurve(C.b), 0.6);\n\n\n    // Occlusion\n    C *= clamp(pow(vec4((bhb.x / 1.5)), vec4(5.)), vec4(0.), vec4(1.));\n\n    fragColor = fragColor + pow(vec4(C.xyz, 1.0), vec4(1.08));\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[978, 1004, 1037, 1037, 1065], [1067, 1067, 1107, 1107, 1214], [1216, 1216, 1247, 1247, 1321], [1323, 1345, 1393, 1393, 4396], [4398, 4398, 4425, 4425, 4601], [4603, 4603, 4658, 4658, 6920]], "test": "error"}
{"id": "4lBSz3", "name": "Ray Marched Pacman", "author": "sanchitgarg", "description": "pacman", "tags": ["pacman"], "likes": 1, "viewed": 124, "published": "Public", "date": "1445287392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference : https://www.shadertoy.com/view/Xds3zN\n\n#define MAX_DIS 100.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n\n//Comment SHADOW_SCALE to remove shadow\n//#define SHADOW_SCALE 30.0\n\n//----------------------Color Modes----------------------\n//Uncomment the coloring mode you want to view and comment the rest\n\n//#define DEPTH_COLOR\n//#define STEP_COUNT_COLOR\n//#define NORMAL_COLOR\n#define LAMBERT_COLOR\n//-------------------------------------------------------\n\n#define DISPLACEMENT 5.0\n\n//------------------Ray Casting Modes--------------------\n//#define NAIVE_RAY_CAST\n#define SPHERICAL_RAY_CAST\n//-------------------------------------------------------\n\n\n\n//-------------------------------------------------------\n//\t\t\t\t\tDistance Estimators\n//-------------------------------------------------------\n\n\n//--------Distance functions for various objects---------\nfloat sdPlane (vec3 p, float y)\n{\n\treturn p.y - y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//--------------------CSG Operations---------------------\nfloat opDifference( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat opIntersect( float d1, float d2 )\n{\n    return max(d2,d1);\n}\n\nfloat opBlend(float a, float b, float blendRadius) {\n    float c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return ((c) * a + (1.0-c) * b) - blendRadius * c * (1.0 - c);\n}\n\nfloat opDisplacement(vec3 pt)\n{\n    float factor = DISPLACEMENT;\n    return sin(factor * pt.x) * sin(factor * pt.y) * sin(factor * pt.z);\n}\n\n//vec3 opTx( vec3 p, mat4 m )\n//{\n//    vec3 q = invert(m)*p;\n    \n//}\n\n//Function to create the actual scene\nfloat disEstimator(vec3 pt)\n{\n   \tfloat dis = sdSphere(pt, 1.0);\n    \tdis = opDifference(dis, sdSphere(pt, 0.9));\n\n    float y = radians(25.0);\n    float x = sin(y);\n    float z = cos(y);\n    y = radians(90.0);\n    \n    dis = opDifference(dis, sdSphere(pt - vec3(x, 0.4, z-0.2), 0.2)); \n\tdis = opDifference(dis, sdSphere(pt - vec3(-x, 0.4, z-0.2), 0.2)); \n    \n    float size = 0.22 * sin(iTime*3.0) + 0.82;\n    dis = opDifference(dis, sdBox(pt - vec3(1.0, -1.0, 1.5), vec3(5.0,size, size)));\n    \n\n    float time = iTime * 0.8;\n    float pointPos = 3.0 * (cos(mod(time, radians(90.0)))) - 0.5;\n    \n    for(int i=0; i<4; ++i)\n    {\n    \tdis = opUnion(dis, sdSphere(pt - vec3(0.0,-0.4,pointPos + float(i) * 3.0), 0.2));\n    }\n    \n    return dis;\n}\n\n\n\n//-------------------------------------------------------\n//\t\t\t\tColor calculation functions\n//-------------------------------------------------------\n\n//Function to calculate the normal\nvec3 getNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    disEstimator(pos+eps.xyy) - disEstimator(pos-eps.xyy),\n\t    disEstimator(pos+eps.yxy) - disEstimator(pos-eps.yxy),\n\t    disEstimator(pos+eps.yyx) - disEstimator(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n#ifdef SHADOW_SCALE\n//Function to calculate the soft shadow\nfloat getSoftShadow(vec3 pt, vec3 lightPos)\n{\n    float t = 2.0;\n    float minT = 2.0;\n    \n    vec3 rd = normalize(lightPos - pt);\n    vec3 ro = pt;\n    float maxT = (lightPos.x - ro.x) / rd.x;\n\tfloat shadow = 1.0;\n    \n\tfor(int i=0; i<MAX_STEPS; ++i )\n    {\n\t\tpt = ro + t * rd;\n\n        float dt = disEstimator(pt);\n        \n        if(dt < EPSILON)\n        {\n\t\t\treturn 0.0;\n        }\n\n        t += dt;\n        shadow = min(shadow, SHADOW_SCALE * (dt / t));\t\t\n        \n        if(t > maxT)\n        {\n          \treturn shadow;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n#endif\n\n//Function to calculate lambert color\nvec3 getLambertColor(vec3 pt, vec3 ro)\n{\n \tvec3 lightPos = vec3(0.0,5.0,5.0);\n    vec3 lightCol = vec3(1.0);\n    vec3 lightVector = normalize(lightPos - pt);\n    \n    vec3 normal = getNormal(pt);\n    \n    #ifdef SHADOW_SCALE\n\t\tfloat shadow = getSoftShadow(pt, lightPos);\n\t\treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * (shadow) + 0.05;\n    #else\n\t    return clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * vec3(1.0,1.0,0.0) + 0.05;\n    #endif\n}\n\n//Function to calculate color based on number of steps\nvec3 getStepCountColor(vec2 steps)\n{\n    float t = (steps.y - steps.x) / steps.y;\n\tvec2 c = vec2(t, 0.0);\n    return vec3(1.0-t, t, 0);\n}\n\n//Function to calculate colors\nvec3 colorCalculation(vec3 pt, vec2 dis, vec3 ro, vec2 steps)\n{\n    #ifdef DEPTH_COLOR\n\t\treturn vec3(abs((dis.y - dis.x) / dis.y));\n    #endif\n    \n    #ifdef STEP_COUNT_COLOR\n\t\treturn getStepCountColor(steps);\n\t#endif\n    \n    #ifdef NORMAL_COLOR\n        return abs(getNormal(pt));\n\t#endif\n    \n    #ifdef LAMBERT_COLOR\n        return getLambertColor(pt, ro);\n\t#endif\n    \n\treturn vec3(0.0);\n}\n\n//-------------------------------------------------------\n//\t\t\t\tRay Cast Functions\n//-------------------------------------------------------\n\nvec3 naiveRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n    float i = 0.0;\n    int maxSteps = 500;\n\tfor(float t = 0.00; t < MAX_DIS; t+=0.01)\n\t{\n        ++i;\n        pt = ro + rd * t;\n        \n        float dis = disEstimator(pt);\n        \n     \tif(dis < EPSILON)\n        {\n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(i, maxSteps));\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\nvec3 sphericalRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n   \t\n//    float dt = disEstimator(pt);\n\tfloat t = 0.0;\n    \n    for(int i = 1; i<MAX_STEPS; i++)\n\t{\n        pt = ro + t * rd;\n        \n        float dt = disEstimator(pt);\n        \n     \tif(dt < EPSILON)\n        {   \n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(float(i), MAX_STEPS));\n        }\n        \n\t\tt += dt;\n        \n        if(t > MAX_DIS)\n  \t    {\n         \treturn vec3(0.0);\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\n\n//-------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    #ifdef NAIVE_RAY_CAST\n\t    return naiveRayCast(ro, rd);\n    #else \n        return sphericalRayCast(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[812, 870, 903, 903, 922], [924, 924, 959, 959, 985], [987, 987, 1020, 1020, 1073], [1075, 1075, 1118, 1118, 1178], [1180, 1180, 1211, 1211, 1307], [1309, 1309, 1345, 1345, 1432], [1434, 1492, 1534, 1534, 1560], [1562, 1562, 1599, 1599, 1628], [1630, 1630, 1671, 1671, 1696], [1698, 1698, 1750, 1750, 1877], [1879, 1879, 1910, 1910, 2018], [2092, 2130, 2159, 2159, 2878], [3033, 3068, 3099, 3099, 3361], [4018, 4056, 4096, 4096, 4523], [4525, 4580, 4616, 4616, 4717], [4719, 4750, 4813, 4813, 5144], [5288, 5288, 5331, 5331, 5691], [5693, 5693, 5740, 5740, 6208], [6270, 6270, 6307, 6307, 6432], [6434, 6434, 6484, 6582, 6771], [6773, 6773, 6828, 6926, 7590]], "test": "valid"}
{"id": "4lBSzV", "name": "Lightning Balls", "author": "Roobird", "description": "Light the balls", "tags": ["balls", "lightning"], "likes": 6, "viewed": 190, "published": "Public", "date": "1444848692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distFunc(vec3 p)\n{\n    return length(mod(p+vec3(0,0,mod(-iTime*19.,4.)),4.)-2.)-.4;\n}\n\nfloat quad(float a)\n{\n\treturn a * a;\n}\n\nfloat sphere(vec3 M, vec3 O, vec3 d)\n{\n\tfloat r = 0.2;\n\tvec3 MO = O - M;\n\tfloat root = quad(dot(d, MO))- quad(length(d)) * (quad(length(MO)) - quad(r));\n\tif(root < 0.001)\n\t{\n\t\treturn -1000.0;\n\t}\n\tfloat p = -dot(d, MO);\n\tfloat q = sqrt(root);\n    return (p - q) > 0.0 ? p - q : p + q;\n}\n\nvec3 sphere_color(float t, vec3 mid){\n\t\n    float a = t < 10000.0? 1.0 : 0.0; \n    \n    return abs(normalize( mid * vec3( 1.4, 1.0, 0.2))) * a;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 sphereM;\n    \n    float fov = 70.0;\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / iResolution.x;\n\tvec2 p = tanFov * (fragCoord.xy * 2.0 - iResolution.xy);\n\n\tvec3 camP = vec3(3.0, 3.0, 0.0);\n\tvec3 camDir = normalize(vec3(p.x - 0.3, p.y - 0.2, 1.0));\n\n\tfloat t = 10000.0;\n\tfor(float x = -2.0; x <= 2.0; ++x)\n\t{\n\t\tfor(float y = 1.0; y <= 1.0; ++y)\n\t\t{\n\t\t\tfor(float z = 1.0; z <= 20.0; z+= 0.25)\n\t\t\t{\t\n                vec3 newSphereMid = vec3(x, y + cos(iTime * 2.0 + z), z);\n\t\t\t\tfloat newT = sphere(newSphereMid, camP, camDir);\n\t\t\t\tif (0.0 < newT && newT < t)\n\t\t\t\t{\t\n\t\t\t\t\tt = newT;\n                    sphereM = newSphereMid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec3 intersect_pt = camP + t* camDir;\n    \n    vec3 intersec_normal = normalize( intersect_pt - sphereM );\n                                   \n    float lightning = max(0.2, dot(intersec_normal, light));\n\n\tfragColor = lightning * vec4(sphere_color(t, sphereM), 1.0) * 1.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [93, 93, 114, 114, 131], [133, 133, 171, 171, 418], [420, 420, 457, 457, 566], [568, 568, 625, 625, 1620]], "test": "valid"}
{"id": "4lBXRV", "name": "15th Pentagonal Tiling", "author": "tomkh", "description": "One pentagonal prototile can cover a plane.\nThis is a newly discovered type of pentagonal tiling, few months ago only 14 types were known. \nPrototyped in [url=http://polycu.be]PolyCube[/url]: [url]http://polycu.be/edit/?h=OewoGS[/url]", "tags": ["tiling", "bsp", "pentagon", "pentagonal", "prototile"], "likes": 33, "viewed": 994, "published": "Public API", "date": "1444821679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pentagonal tiling of type 15th\n// by Tomkh @2015\n\n// Prototyped in PolyCube:\n//   http://polycu.be/edit/?h=OewoGS - derivation of unit cell and BSP\n//   http://polycu.be/edit/?h=ckcP5s - original shader\n\n// Background:\n//   One pentagonal prototile can cover a plane.\n//   This is a newly discovered type of pentagonal tiling,\n//   few months ago only 14 types were known.\n\n// Related paper (pre-print):\n//   http://arxiv.org/abs/1510.01186\n//   Casey Mann, Jennifer McLoud-Mann, David Von Derau\n//   \"Convex pentagons that admit i-block transitive tilings\"\n\n// Method used:\n//   First tiles and edges in unit cell are found,\n//   then BSP is calculated for the edges,\n//   and generated into shader code.\n\n// Do you like colors? \n//  Put 0 if not ;)\n//  Put 1 for unique coloring\n//  Put 2 for isohedral coloring\n#define USE_COLORS 2\n\nconst int iterations = 64;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .04;\nconst float fog_start = 16.;\n\nconst float cam_dist = 13.5;\n\n//---------------------------------------------\n// Tiling code\n\n#define N 5\nvec3 edge[N];\nmat3 u2t[24];\nmat3 s2u, u2s;\n\n#define REC0(nx,ny,nd) n=vec3(nx,ny,nd);d=dot(n.xy,q)-n.z;if(d<0.){\n#define REC1 }else{\n#define END }\n#define LEAF0(nx,ny,nd,type,tile) REC0(nx,ny,nd) c=type; m=u2t[tile];\n#define LEAF1(type,tile) REC1 c=type; m=u2t[tile];\n\nvoid initTiling()\n{\n// Auto-generated unit cell, tile transformations and edges\nu2s = mat3(8.175694346,-9.400439218,0,2.638958434,0.707106781,0,0,0,1);\ns2u = mat3(0.023116785,0.307319821,0,-0.086273015,0.267280376,0,0,0,1);\nu2t[0] = mat3(0.866025404,-0.5,0,-0.5,-0.866025404,0,-0.448287736,-1.673032607,1);\nu2t[1] = mat3(0.5,0.866025404,0,0.866025404,-0.5,0,2.897777479,-3.60488426,1);\nu2t[2] = mat3(0.5,-0.866025404,0,0.866025404,0.5,0,2.897777479,3.60488426,1);\nu2t[3] = mat3(1,0,0,0,1,0,0,0,1);\nu2t[4] = mat3(0.866025404,0.5,0,-0.5,0.866025404,0,-2.380139389,-0.258819045,1);\nu2t[5] = mat3(0.866025404,-0.5,0,-0.5,-0.866025404,0,-2.380139389,0.258819045,1);\nu2t[6] = mat3(0.5,0.866025404,0,0.866025404,-0.5,0,0.965925826,-5.536735913,1);\nu2t[7] = mat3(0.866025404,0.5,0,0.5,-0.866025404,0,0.258819045,-6.243842694,1);\nu2t[8] = mat3(0.5,-0.866025404,0,0.866025404,0.5,0,0.965925826,5.536735913,1);\nu2t[9] = mat3(-0.866025404,-0.5,0,-0.5,0.866025404,0,1.673032607,6.243842694,1);\nu2t[10] = mat3(1,0,0,0,1,0,-2.638958434,-0.707106781,1);\nu2t[11] = mat3(0.5,0.866025404,0,0.866025404,-0.5,0,-0.965925826,-7.468587565,1);\nu2t[12] = mat3(0.866025404,0.5,0,0.5,-0.866025404,0,-2.380139389,-6.950949475,1);\nu2t[13] = mat3(-1,0,0,0,-1,0,1.931851653,0,1);\nu2t[14] = mat3(-1,0,0,0,-1,0,10.107545999,-9.400439218,1);\nu2t[15] = mat3(-0.866025404,-0.5,0,0.5,-0.866025404,0,11.073471825,-3.346065215,1);\nu2t[16] = mat3(-0.866025404,0.5,0,0.5,0.866025404,0,11.073471825,3.346065215,1);\nu2t[17] = mat3(-0.5,-0.866025404,0,-0.866025404,0.5,0,-2.121320344,7.916875301,1);\nu2t[18] = mat3(-0.866025404,-0.5,0,-0.5,0.866025404,0,4.311991041,6.950949475,1);\nu2t[19] = mat3(-0.5,0.866025404,0,-0.866025404,-0.5,0,-2.121320344,-7.916875301,1);\nu2t[20] = mat3(-0.866025404,-0.5,0,0.5,-0.866025404,0,13.005323478,-1.414213562,1);\nu2t[21] = mat3(-0.866025404,0.5,0,0.5,0.866025404,0,13.005323478,1.414213562,1);\nu2t[22] = mat3(-0.5,-0.866025404,0,-0.866025404,0.5,0,-0.189468691,9.848726954,1);\nu2t[23] = mat3(-0.5,0.866025404,0,-0.866025404,-0.5,0,-0.189468691,-9.848726954,1);\nedge[0] = vec3(0,-1,0);\nedge[1] = vec3(0.707106781,-0.707106781,0);\nedge[2] = vec3(0.258819045,0.965925826,-0.866025404);\nedge[3] = vec3(-0.258819045,0.965925826,-1.5);\nedge[4] = vec3(-0.965925826,-0.258819045,-1.866025404);\n}\n\nvec2 dTile(in vec2 p)\n{\n   // Transform to unit cell space\n   vec3 p2 = s2u * vec3(p, 1.);\n   \n   // Repeat\n   p2.xy = fract(p2.xy);\n   \n   // Transform back\n   vec2 q = vec2(u2s * p2);\n   \n   vec3 n;\n   int c;\n   float d;\n   mat3 m;\n\n// Auto-generated BSP\nREC0(0.707106781,-0.707106781,6.464101615)\n REC0(0.866025404,-0.5,3.60488426)\n  REC0(0.258819045,-0.965925826,1.5)\n   REC0(0.258819045,0.965925826,0.5)\n    LEAF0(0.258819045,0.965925826,-0.866025404,2,0)\n    REC1\n     REC0(0,1,0)\n      LEAF0(0.965925826,0.258819045,1.866025404,0,3)\n      LEAF1(2,5)\n      END\n     LEAF1(6,13)\n     END\n    END\n   REC1\n    LEAF0(-0.707106781,0.707106781,-1.366025404,0,10)\n    LEAF1(6,13)\n    END\n   END\n  REC1\n   REC0(0.707106781,0.707106781,0)\n    LEAF0(0.707106781,-0.707106781,2.732050808,2,0)\n    LEAF1(3,1)\n    END\n   REC1\n    LEAF0(0.5,0.866025404,0.258819045,1,4)\n    LEAF1(2,5)\n    END\n   END\n  END\n REC1\n  REC0(0.258819045,0.965925826,-1.866025404)\n   REC0(0.258819045,-0.965925826,4.598076211)\n    LEAF0(0.965925826,-0.258819045,4.232050808,5,2)\n    REC1\n     LEAF0(0.866025404,-0.5,5.536735913,3,6)\n     LEAF1(5,8)\n     END\n    END\n   REC1\n    REC0(0.5,-0.866025404,6.243842694)\n     LEAF0(0.965925826,0.258819045,3.232050808,4,7)\n     LEAF1(5,8)\n     END\n    LEAF1(10,9)\n    END\n   END\n  REC1\n   REC0(0.5,0.866025404,0.258819045)\n    LEAF0(0.965925826,-0.258819045,4.232050808,1,4)\n    REC1\n     LEAF0(0.866025404,-0.5,5.536735913,3,6)\n     LEAF1(5,8)\n     END\n    END\n   REC1\n    REC0(0.866025404,-0.5,5.536735913)\n     LEAF0(0.707106781,-0.707106781,4.098076211,2,5)\n     LEAF1(3,6)\n     END\n    REC1\n     LEAF0(0.965925826,-0.258819045,6.598076211,5,8)\n     LEAF1(3,11)\n     END\n    END\n   END\n  END\n END\nREC1\n REC0(0.258819045,0.965925826,-4.598076211)\n  REC0(0.258819045,0.965925826,-5.598076211)\n   REC0(-0.258819045,0.965925826,-10.196152423)\n    LEAF0(-0.965925826,-0.258819045,-5.464101615,6,14)\n    LEAF1(8,16)\n    END\n   REC1\n    LEAF0(-0.5,-0.866025404,3.346065215,7,15)\n    LEAF1(8,16)\n    END\n   END\n  REC1\n   REC0(-0.707106781,0.707106781,-11.062177826)\n    LEAF0(0.707106781,0.707106781,0.5,7,15)\n    LEAF1(8,21)\n    END\n   REC1\n    REC0(-0.965925826,0.258819045,-7.964101615)\n     LEAF0(0.707106781,0.707106781,0.5,7,15)\n     LEAF1(9,22)\n     END\n    REC1\n     LEAF0(-0.866025404,0.5,-7.916875301,9,17)\n     LEAF1(11,19)\n     END\n    END\n   END\n  END\n REC1\n  REC0(-0.258819045,0.965925826,-7.098076211)\n   REC0(-0.866025404,0.5,-9.848726954)\n    REC0(-0.5,-0.866025404,1.414213562)\n     LEAF0(-0.965925826,0.258819045,-10.330127019,7,20)\n     LEAF1(9,22)\n     END\n    REC1\n     LEAF0(-0.707106781,0.707106781,-11.062177826,8,21)\n     LEAF1(9,22)\n     END\n    END\n   REC1\n    REC0(-0.866025404,0.5,-7.916875301)\n     LEAF0(0.965925826,-0.258819045,7.964101615,9,17)\n     LEAF1(11,23)\n     END\n    LEAF1(11,19)\n    END\n   END\n  REC1\n   REC0(0.258819045,0.965925826,-3.232050808)\n    LEAF0(0.707106781,-0.707106781,7.330127019,10,9)\n    REC1\n     REC0(0.707106781,-0.707106781,8.696152423)\n      LEAF0(-0.965925826,-0.258819045,-4.098076211,10,18)\n      LEAF1(11,19)\n      END\n     LEAF1(11,23)\n     END\n    END\n   REC1\n    REC0(0.5,-0.866025404,6.950949475)\n     LEAF0(0.258819045,-0.965925826,4.598076211,3,11)\n     LEAF1(4,12)\n     END\n    REC1\n     LEAF0(0.707106781,-0.707106781,8.696152423,10,18)\n     LEAF1(11,23)\n     END\n    END\n   END\n  END\n END\nEND\n\n   // Transform to prototile\n   q = vec2(m * vec3(q,1));\n   \n   // Calculate closest distance to edges\n   float sd = 1.;\n   for(int i=0; i<N; ++i) {\n      vec3 n = edge[i];\n      sd = min(sd, abs(dot(n.xy,q)-n.z));\n   }\n   \n   return vec2(float(c),sd);\n}\n\n//---------------------------------------------\n\nconst float bump = .1;\nconst float ground = .2;\n\nfloat dField(in vec3 p)\n{\n   float d = p.y + ground;\n   \n   vec2 tile = dTile(p.xz);\n   float d3;\n   //d3 = min(.05,smoothstep(0.,1.,tile.y*20.)*.05)*.5;\n   d3 = min(.05,tile.y)*.5;\n   d3 += tile.y*.3;\n   d3 = min(d3,bump);\n   //d3 = smoothstep(0.,1.,d3/cut)*cut;\n   d -= d3;\n   return d;\n}\n\nvec3 dNormal(in vec3 p, in float eps)\n{\n   vec2 e = vec2(eps,0.);\n   return normalize(vec3(\n      dField(p + e.xyy) - dField(p - e.xyy),\n      dField(p + e.yxy) - dField(p - e.yxy),\n      dField(p + e.yyx) - dField(p - e.yyx) ));\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   \n   // Intersect with ground plane first\n   \n   if (ray_dir.y >= 0.) return vec4(0.);\n   \n   float dist;\n   dist = (ray_start.y + ground - bump)/-ray_dir.y;\n   p += dist*ray_dir;\n   ray_len += dist;\n   if (ray_len > ray_max) return vec4(0.);\n   //return vec4(p, ray_len);\n   \n   for(int i=0; i<iterations; ++i) {\n   \t  dist = dField(p);\n      if (dist < dist_eps*ray_len) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, ray_len);\n}\n\nvec3 shade(in vec3 ray_start, in vec3 ray_dir,\n   in vec3 light_dir, in vec3 fog_color, in vec4 hit)\n{   \n   vec3 dir = hit.xyz - ray_start;\n   vec3 norm = dNormal(hit.xyz, .015);//*hit.w);\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n   spec = pow(spec, 32.0)*.7;\n\n   vec2 tile = dTile(hit.xz);\n   float sh = tile.x;\n#if USE_COLORS == 2\n   sh = (mod(sh,6.)+3.)*(1./9.);\n#else\n   sh *= (1./12.);\n#endif\n   float sd = min(tile.y,.05)*20.;\n#if USE_COLORS == 0\n   vec3 base_color = vec3(.5);\n#else\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n#endif\n   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n   color *= sd;\n   \n   float fog_dist = max(0.,length(dir) - fog_start);\n   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   initTiling();\n   \n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, .25));\n   \n   // Simple model-view matrix:\n   float ms = 2.5/iResolution.y;\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -ms :\n      -iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si,\n      0., 1., 0.,\n     -si, 0., co);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y) * -ms - .1:\n      cos(-iTime*.5)*.4 + .8;\n   ang = max(0.,ang);\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat3(\n      1., 0., 0.,\n      0., co, si,\n      0.,-si, co);\n\n   vec3 pos = cam_mat*vec3(0., 0., -cam_dist);\n   vec3 dir = normalize(cam_mat*vec3(uv, 1.));\n\n   vec3 color;\n   vec3 fog_color = vec3(min(1.,.4+max(-.1,dir.y*.8)));\n   vec4 hit = trace(pos, dir);\n   if (hit.w == 0.) {\n      color = fog_color;\n   } else {\n      color = shade(pos, dir, light_dir, fog_color, hit);\n   }\n   \n   // gamma correction:\n   color = pow(color,vec3(.7));\n   \n   fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1359, 1359, 1378, 1438, 3639], [7373, 7373, 7398, 7398, 7663], [7665, 7665, 7704, 7704, 7896], [7898, 7898, 7946, 7946, 8505], [8507, 8507, 8609, 8609, 9482], [9484, 9484, 9541, 9541, 10625]], "test": "valid"}
{"id": "4lBXzm", "name": "raytrace_bk", "author": "d1kkop", "description": "raytrace_bk", "tags": ["raytracebk"], "likes": 0, "viewed": 148, "published": "Public", "date": "1444074587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define BG vec3(0,0,0);\n#define AA 4\n#define AMBIENT 0.0015\n#define REFLECT_COUNT 5\n#define REFRACT\n#define time iTime\n#define EPS 0.001\n\n\n// Struct definitions\nstruct Camera\n{\n    vec3 pos;\n    vec3 dir;\n    float fov;\n    float zoom; // derived\n    mat3 view; // derived\n};\n    \n        \nstruct Material\n{\n    vec3 color;\n    float shine;\n    float refl;\n    float refr;\n};\t\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n    Material mat;\n};\n    \n\nstruct Light\n{\n    vec4 ori_dir;\n    vec3 color;\n};\n    \n\n// Init of structures\nCamera cam = Camera(\n    vec3(0.0, 2.0, -7.0),\n    vec3(0.0, -1.0, 2.0),\n    45.0,\n    0.0, // zoom\n    mat3(vec3(0), vec3(0), vec3(0)) // view\n);  \n    \n\nLight light = Light( \n    vec4(0.0, 20.0, -10.0, 1.0),          \n    vec3(1.0, 1.0, 1.0) \t\n);\n\n\nSphere spheres[30];\nconst int c_numSpheres = 20;\n\nvoid initSpheres()\n{\n    float dAng = 360.0 / float(c_numSpheres);\n    float r = 5.0;\n    for (int i = 0; i < c_numSpheres; i++)\n    {\n        float ang = float(i)*dAng;\n        float rad = radians(ang);\n        float x = cos(rad)*r;\n        float z = sin(rad)*r;\n        spheres[i] = Sphere(vec3(x, 0.0, z), \n                            0.6 /*0.5*(cos(ang)+1.0)*0.6+0.3*/,  \t\t\n                            Material(vec3(0.1 + 0.5*(cos(ang)+1.0)+0.3,\n                                          0.1 + 0.5*(cos(ang*4.0+1.2)+1.0)+0.3, \n                                          0.1 + 0.5*(sin(ang*4.0+1.2)+1.0)+0.1), \n                                     \t(sin(ang*3.0)+1.0)*800.0+3.0,\n                                     \t0.5,\n                                      \t1.0));\n    }\n}\n\n\nfloat zoomForFov(float fovDeg)\n{\n    return 1.0 / tan(radians(0.5 * fovDeg));\n}\n\n\nvoid rotateLight()\n{\n    float r = 40.0;\n    float rotspeed = time * 1.0;\n    float x = cos(rotspeed) * r;\n    float z = sin(rotspeed) * r;\n    light.ori_dir = vec4(x, 30.0, z, 1.0);\n}\n\n\n/*\nvoid traceHeight(vec3 ro, vec3 rd, vec2 map)\n{\n    vec2 as = vec2(ro.x, ro.z);\n    vec2 bs = vec2(rd.x, ro.z);\n    float dx = bs.x - as.x;\n    float dy = bs.y - as.y;\n    float det = bd.x * ad.y - bd.y * ad.x;\n    u = (dy * bd.x - dx * bd.y) / det;\n    v = (dy * ad.x - dx * ad.y) / det;\n}*/\n\n\nfloat sphereRayIntersect(vec3 sc, float sr, vec3 ro, vec3 rd)\n{\n    vec3 e = sc - ro;\n    float a = dot(e, rd);\n    if (a < 0.0)\n        return -1.0; // possible intersect is in opposite dir of ray\n    float e2 = dot(e, e);\n    float r2 = sr*sr;\n    float arg = r2 - e2 + a*a;\n    if (arg < 0.0)\n        return -1.0; // miss\n    if (e2 <= r2)\n        return -1.0; // origin on or inside\n    return a - sqrt(arg); // return dist to intersect\n}\n\n\nvec3 computeShading( vec3 hit, vec3 normal, Material m, Light l )\n{\n    vec3 ldir;\n    if (l.ori_dir.w > 0.5)\n    \tldir = normalize( l.ori_dir.xyz - hit );\n    else\n        ldir = normalize(-l.ori_dir.xyz);\n    \n    float diff = max( 0.0, dot(ldir, normal) );\n    vec3 hdir = normalize( ldir - cam.dir );\n    float spec = pow( max(0.0, dot(hdir, normal)), m.shine );\n    \n    return  diff * (m.color * l.color) +\n        \tspec * l.color +\n        \tAMBIENT * m.color;\n  //  return (diff + AMBIENT) * m.color * l.color + spec * l.color;\n}\n\n\nbool traceScene2( vec3 ro, vec3 rd, out vec3 hit, out vec3 normal, out vec3 col, inout float refl, out float refr )\n{\n    bool bhit = false;\n    float dist = 100000.0;\n    Sphere closest;\n    \n    // test spheres\n    for (int i = 0; i < c_numSpheres; i++)\n    {\n        Sphere s = spheres[i];\n        float distSphere = sphereRayIntersect( s.origin, s.radius, ro, rd );\n        if ( distSphere >= 0.0 && distSphere < dist )\n        {\n            dist = distSphere;\n            closest = spheres[i];\n            bhit = true;\n        }\n    }\n\n    if ( bhit )\n    {\n        hit = ro+rd*dist;\n        normal = normalize( hit - closest.origin );\n        col += computeShading( hit, normal, closest.mat, light ) * refl;\n        refl = closest.mat.refl;\n        refr = closest.mat.refr;\n    }\n    \n    return bhit;\n}\n\nvoid traceReflections( vec3 ro, vec3 rd, vec3 hit, vec3 normal, inout vec3 col, float refl, float refr )\n{\n    for (int i=0; i<REFLECT_COUNT; i++)\n    {\n        rd = reflect( rd, normal );\n        ro = hit+rd*EPS;\n        traceScene2( ro, rd, hit, normal, col, refl, refr);\n    }   \n}\n\nvoid traceRefractions( vec3 ro, vec3 rd, vec3 hit, vec3 normal, inout vec3 col, float refl, float refr )\n{\n    rd = refract( rd, normal, refr );\n    ro = hit+rd*EPS;\n    traceScene2( ro, rd, hit, normal, col, refl, refr );  \n}\n\nvec3 traceScene( vec3 ro, vec3 rd )\n{\n    float eps = 0.0001;\n    vec3 col = vec3(0);\n    float refl = 1.0;\n    float refr, trans;\n    vec3 hit, normal;\n\n    if ( traceScene2( ro, rd, hit, normal, col, refl, refr ) ) \n    {\n        traceReflections( ro, rd, hit, normal, col, refl, refr );\n        #ifdef REFRACT\n        traceRefractions( ro, rd, hit, normal, col, refl, refr );\n        #endif\n    }\n    \n    return col;\n}\n\nvec3 constructRay( vec2 ras )\n{\n    vec3 ray = vec3( ras, cam.zoom );\n    ray = normalize( ray );\n    return cam.view * ray;\n}\n\n\nvec3 traceSceneAA( vec2 ras, float asp )\n{\n    vec3 finalColor = BG;\n    ras = 2.0*ras - 1.0;\n    ras.x *= asp;\n    vec2 aa = vec2(2.0*asp, 2.0) / (iResolution.xy * float(AA));\n    ras += aa*0.5;\n    vec2 sub = ras;\n    for (int y = 0; y < AA; y++)\n    {\n        sub.x = ras.x;\n        for (int x = 0; x < AA; x++)\n        {\n            vec3 rd = constructRay( sub );\n            finalColor += traceScene( cam.pos, rd );\n            sub.x += aa.x;\n        }\n        sub.y += aa.y;\n    }\n    float denom = float(AA);\n    denom = 1.0 / (denom*denom);\n    return finalColor * denom;\n}\n\n\nmat3 lookatMatrix(vec3 forward)\n{\n    forward = normalize(forward);\n    vec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ));\n    vec3 up = normalize(cross(forward, right));\n    mat3 lookat = mat3(right, up, forward);\n    return lookat;\n}\n\n\nvoid updateCam()\n{\n    float spd = 0.076*time;\n    float hspd = 0.1*time;\n    float r=10.0;\n    float x=cos(spd)*r;\n    float z=sin(spd)*r;\n    float y=3.0;//cos(hspd)*2.0+3.0;\n    vec3 mid=vec3(0.0, 0.0, 0.0);\n    cam.pos = vec3(x,y,z);\n    vec3 dir= normalize (mid - cam.pos);\n    \n    \n    cam.zoom = zoomForFov( cam.fov );\n    cam.dir = normalize( dir );\n    cam.view = lookatMatrix( cam.dir );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initSpheres();\n   // rotateLight();\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float asp = iResolution.x / iResolution.y;\n    \n    updateCam();\n    vec3 col = traceSceneAA( uv, asp );\n    \n    col = pow(col, vec3(0.79));\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[838, 838, 858, 858, 1615], [1618, 1618, 1650, 1650, 1697], [1700, 1700, 1720, 1720, 1884], [2184, 2184, 2247, 2247, 2626], [2629, 2629, 2696, 2696, 3165], [3168, 3168, 3285, 3285, 3977], [3979, 3979, 4085, 4085, 4263], [4265, 4265, 4371, 4371, 4491], [4493, 4493, 4530, 4530, 4915], [4917, 4917, 4948, 4948, 5043], [5046, 5046, 5088, 5088, 5627], [5630, 5630, 5663, 5663, 5878], [5881, 5881, 5899, 5899, 6281], [6284, 6284, 6341, 6341, 6616]], "test": "valid"}
{"id": "4lBXzt", "name": "fract1", "author": "fantomas", "description": "test AO", "tags": ["fractale"], "likes": 10, "viewed": 219, "published": "Public", "date": "1445705621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 0.78539816339\n\nfloat distfunc (vec3 p)\n{\n    float r = length(p);\n    float df=1.;\n    float i3;\n    for (float i=1.; i<7.; i++)\n    {\n        i3=i*i*i;\n        df+=(1.+cos(pi*p.x*i3)*cos(pi*p.y*i3)*cos(pi*p.z*i3))/i3;\n    }\n    return (length(p-p/r*(df*1.8))-.2)/3.;\n}\n\n\nvec3 normal (vec3 pos, float rn)\n{\n    return vec3 ( distfunc (pos+vec3(rn,0,0))-distfunc (pos+vec3(-rn,0,0)),\n                  distfunc (pos+vec3(0,rn,0))-distfunc (pos+vec3(0,-rn,0)),\n                  distfunc (pos+vec3(0,0,rn))-distfunc (pos+vec3(0,0,-rn)) )/rn;                            \t\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float vr=0.05;\n    float cr=20.;\n    \n    vec3 camo = vec3(sin(iTime*vr)*cr,0.*sin(iTime*vr)*5.,cos(iTime*vr)*cr);\n    vec3 camd = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 dir = normalize(camd-camo);\n    \n    dir = normalize(up*(uv.y-iResolution.y/iResolution.x/2.)+cross(dir,up)*(uv.x-0.5)+(dir));\n    \n    \n    vec3 pos = camo;\n    float dmas;\n    float dmar;\n    \n    for (int i=0; i<48; i++)\n    {\n        dmar = distfunc(pos);\n        pos += dir*dmar;\n    }\n \n    dir = normalize(normal(pos,0.001));\n    vec3 posr=pos+dir/10.;\n   \n    for (int i=0; i<7; i++)\n    {\n        dmas = distfunc(posr);\n        posr += dir*dmas;   \n    }\n    \n    float ao = (6.4-length(posr-pos));\n    ao=1.-ao/6.4;\n    \n\n    float lr = length(normal(pos,0.1));\n    float lv = length(normal(pos,0.01));\n    float lb = length(normal(pos,0.001));\n    fragColor = (normalize(vec4(lr*lb*lv,lv*lr,lb,1.)))*ao/(1.+dmar*400.)*4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 51, 51, 280], [283, 283, 317, 317, 582], [585, 585, 642, 642, 1614]], "test": "valid"}
{"id": "4ljSRc", "name": "Standing Waves", "author": "croqueteer", "description": "Just playing around with sin functions and time. I like the flow.", "tags": ["sin", "cos", "smoothstep"], "likes": 3, "viewed": 1091, "published": "Public API", "date": "1445479984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) - \n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x;\n\tfloat y = 0.5+0.5*sin(x*iTime*2.0*PI)*cos(x*2.*PI);\n    vec3 color = vec3(0.0);\n    \n    float pct = plot(uv,y);\n    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 57, 57, 149], [151, 151, 208, 208, 471]], "test": "valid"}
{"id": "4lSSDw", "name": "Desert Sun", "author": "AlphaRogue", "description": "The sun rises upon the sand of the desert.", "tags": ["desertsandsunmorning"], "likes": 1, "viewed": 151, "published": "Public", "date": "1443973412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI2 6.2831853\n#define ACC 50.\n\nvoid mainImage(out vec4 pixColor, in vec2 pixCoord) {\n  float ratio = pixCoord.y / iResolution.y / 2.;\n  float radius = iResolution.y / 3.;\n      \n  float timeLoop = mod(iTime, iResolution.x / ACC);\n  \n  vec2 circ = vec2(timeLoop * ACC, iResolution.y / 2. + sqrt(timeLoop) * ACC);\n\n  float circleAdvance = circ.x / iResolution.x * 10.;\n\n  float dist = length(pixCoord - circ);\n  float wave = sin(pixCoord.x * M_PI2 / iResolution.x) * iResolution.y / 50. + iResolution.y / 2.;\n  float advancedCirc = circleAdvance * .03;\n\n    // TODO : antialiasing\n    // TODO : Change colors\n    \n  //Sun\n  if (dist <= radius && pixCoord.y >= wave) pixColor = vec4(advancedCirc + .1 + abs(dist / radius - 1.), advancedCirc + .2 + abs(dist / radius - 1.), advancedCirc + .8, 1.);\n  //Skies\n  else if (dist > radius && pixCoord.y > wave) pixColor = vec4(advancedCirc + .1, advancedCirc + .2, advancedCirc + .8, 1.);\n  //Dune\n  else pixColor = vec4(circleAdvance * .08 + ratio, circleAdvance * .04 + ratio, .05, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 94, 94, 1040]], "test": "valid"}
{"id": "4lSXR3", "name": "Hot Rocks", "author": "dr2", "description": "Night flight over hot terrain (with spotlight).", "tags": ["raymarching", "rocks"], "likes": 47, "viewed": 1590, "published": "Public API", "date": "1445191903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hot Rocks\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 ip = floor (p);\n  vec2 fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  vec4 t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 flMat;\nvec3 flPos, ltPos, ltAx;\nfloat tCur;\nfloat dstFar = 100.;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (10. * sin (0.1 * t) * sin (0.06 * t) * cos (0.033 * t) +\n     3. * cos (0.025 * t), 6., t);\n}\n\nfloat GrndDf (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q, t, ta, v;\n  float wAmp, pRough, ht;\n  wAmp = 1.;\n  pRough = 0.5;\n  q = 0.4 * p.xz;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + abs (cos (t)));\n    v = pow (1. - v, vec2 (pRough));\n    ht += (v.x + v.y) * wAmp;\n    q *= 1.5 * qRot;\n    wAmp *= 0.25;\n    pRough = 0.6 * pRough + 0.2;\n  }\n  return p.y - ht;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += 0.8 * h + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., GrndDf (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (GrndDf (p + e.xxx), GrndDf (p + e.xyy),\n     GrndDf (p + e.yxy), GrndDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat GrndGlow (vec3 ro, vec3 rd)\n{\n  float gl, f, d;\n  gl = 0.;\n  f = 1.;\n  d = 0.;\n  for (int j = 0; j < 5; j ++) {\n    d += 0.4;\n    gl += f * max (d - GrndDf (ro + rd * d), 0.);\n    f *= 0.5;\n  }\n  return clamp (gl, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, ltDir;\n  float dstGrnd, di, atten, glw, dk;\n  dstGrnd = GrndRay (ro, rd);\n  vec3 bgCol = vec3 (0., 0., 0.03);\n  vec3 col = bgCol;\n  if (dstGrnd < dstFar) {\n    ro += rd * dstGrnd;\n    ltDir = ro - ltPos;\n    di = 1. / max (length (ltDir), 0.01);\n    ltDir *= di;\n    atten = 30. * pow (min (di, 1.), 1.3) * pow (max (dot (ltAx, ltDir), 0.), 64.);\n    vn = GrndNf (ro);\n    vn = VaryNf (5. * ro, vn, max (2., 6. - 0.3 * dstGrnd));\n    glw = GrndGlow (ro, vn);\n    col += (1. - glw) * atten * (min (0.5 * Fbmn (31. * ro, vn), 1.) *\n       (0.1 + 0.5 * max (dot (vn, - ltDir), 0.)) +\n       pow (max (dot (reflect (- ltDir, vn), rd), 0.), 64.));\n    col = mix (col, 2. * HsvToRgb (clamp (vec3 (0.06 * glw * glw,\n       1.,  5. * glw), 0., 1.)), 1.2 * glw * glw);\n    dk = clamp (2. * (dstGrnd / dstFar - 0.1), 0., 1.);\n    col = mix (col, bgCol, dk * dk);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 0.2;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec3 rd, ro;\n  FlyerPM (tCur);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 3.)) * flMat;\n  ltPos = flPos;\n  ltPos.y += 1.;\n  ltAx = vec3 (0., 0., 1.);\n  ltAx.yz = Rot2D (ltAx.yz, 0.3 + 0.3 * sin (tCur));\n  ltAx = ltAx * flMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSXR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[264, 264, 288, 288, 335], [337, 337, 362, 362, 551], [553, 553, 582, 582, 794], [796, 796, 835, 835, 1052], [1054, 1054, 1078, 1078, 1209], [1211, 1211, 1241, 1241, 1315], [1388, 1388, 1414, 1414, 1523], [1525, 1525, 1548, 1548, 1999], [2001, 2001, 2035, 2035, 2542], [2544, 2544, 2566, 2566, 2786], [2788, 2788, 2823, 2823, 3018], [3020, 3020, 3055, 3055, 3955], [3957, 3957, 3981, 3981, 4575], [4577, 4577, 4633, 4633, 5031]], "test": "valid"}
{"id": "4t2XDy", "name": "HoneyCombWave", "author": "jt", "description": "A hexagonal distance grid distorted by a sine-wave.", "tags": ["grid", "wave", "distortion", "hexagonal"], "likes": 16, "viewed": 367, "published": "Public", "date": "1446214834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HoneyCombWave - written 2015 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat checker(vec2 pos)\n{\n    //if(fract(pos.x) < 0.5)\n    //    return 0.0;\n    //else\n    //    return 1.0;\n    //return step(0.5, fract(pos.x));\n    float a = (step(0.5, fract(pos.x)) - 0.5);\n    float b = (step(0.5, fract(pos.y)) - 0.5);\n    return step(0.0, a * b);\n}\n\nfloat tile1(vec2 pos)\n{\n    pos = fract(pos);\n    float val = length(pos - 0.5);\n    val = min(val, length(pos - vec2(0.0, 0.0)));\n    val = min(val, length(pos - vec2(1.0, 0.0)));\n    val = min(val, length(pos - vec2(0.0, 1.0)));\n    val = min(val, length(pos - vec2(1.0, 1.0)));\n    return val;\n}\n\nfloat tile(vec2 pos)\n{\n    pos = fract(pos);\n    float s = 1.5;\n    pos.x *= s;\n    float val = length(pos - vec2(0.5 * s, 0.5));\n    val = min(val, length(pos - vec2(0.0, 0.0)));\n    val = min(val, length(pos - vec2(  s, 0.0)));\n    val = min(val, length(pos - vec2(0.0, 1.0)));\n    val = min(val, length(pos - vec2(  s, 1.0)));\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    float distortion = 0.5 * sin(5.0 * (length(uv - 0.5) + t * 0.1) * 3.1415926 * 2.0);\n    //uv.x += distortion;\n    uv = (uv - 0.5) * (1.0 + 0.1 * distortion) + 0.5;\n    float val = 2.0 * tile(uv * 5.0);\n\tfragColor = vec4(vec3(val), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[137, 137, 162, 284, 409], [411, 411, 434, 434, 709], [711, 711, 733, 733, 1058], [1060, 1060, 1117, 1117, 1423]], "test": "valid"}
{"id": "4t2XRG", "name": "Surface Implicite Draz", "author": "Drazatlam", "description": "Surface Implicite Draz", "tags": ["surfaceimplicite"], "likes": 1, "viewed": 135, "published": "Public", "date": "1444642803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Blobs\n// Eric Galin\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Distance\n\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\tvec3 ab =b-a;\n    float scal=dot(p-a,ab);\n    \n    if(scal<0.0)\n        return length(p-a);\n    \n    if(scal>dot(ab,ab))\n        return length(p-b);\n    \n    vec3 projp=a+(scal/dot(ab,ab))*ab;\n    return length(p-projp);\n}\n\nfloat distCircle(vec3 p, vec3 c, vec3 n, float r){\n    n= normalize(n);\n    vec3 cp=p-c;\n    float scal = dot(cp,n);\n    float dicarre=dot(cp,cp)-scal*scal;\n    float dist=abs(sqrt(dicarre)-r);\n    return sqrt(dist*dist+scal*scal);\n}\nfloat distDisk(vec3 p, vec3 c, vec3 n, float r){\n    n= normalize(n);\n    vec3 cp=p-c;\n    float scal = dot(cp,n);\n    float dicarre=dot(cp,cp)-scal*scal;\n    float dist=max(sqrt(dicarre)-r,0.0);\n    return sqrt(dist*dist+scal*scal);\n}\n\nfloat distCylindre(in vec3 p,in vec3 a, in vec3 b, in float rayon)\n{\n    vec3 u = normalize(b-a);\n    float ha = dot((p-a),u);\n    float hb = dot((p-b),u);\n    \n   \n    if(ha < 0.0)\n   \t\treturn  distDisk(p, a, b-a, rayon);\n    if(hb > 0.0)\n        return  distDisk(p, b, b-a, rayon);\n  \n    return max(distLine(p,a,b)-rayon,0.0);\n}\n\nfloat distSphere(in vec3 p,in vec3 c, in float rayon)\n{\n    return abs(length(p-c)-rayon);\n}\n\n\n\nfloat distCube(in vec3 p,in vec3 a, in vec3 b)\n{\n    float d = 0.0;\n    \n    if(p.x < a.x)\n        d+=(a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d+=(b.x-p.x)*(b.x-p.x);\n        else\n            d+=0.0;\n        \n    if(p.y < a.y)\n        d+=(a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d+=(b.y-p.y)*(b.y-p.y);\n        else\n            d+=0.0;\n        \n    if(p.z < a.z)\n        d+=(a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d+=(b.z-p.z)*(b.z-p.z);\n        else\n            d+=0.0;\n        \n        \n    return sqrt(d);\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Line skeleton\n// p : point\n// a : \n// b : \n// e : energy associated to skeleton\n// R : large radius\nfloat line(vec3 p, vec3 a, vec3 b, float e,float R)\n{\n  return e*falloff(distLine(p,a,b),R);\n}\n\n// Circle skeleton\n// p : point\n// c : center of circle\n// n : norm of circle\n// rad : radius of circle\n// e : energy associated to skeleton\n// R : large radius\nfloat circle(vec3 p, vec3 c, vec3 n,float rad, float e,float R)\n{\n  return e*falloff(distCircle(p,c,n,rad),R);\n}\n\n// Disk skeleton\n// p : point\n// c : center of Disk\n// n : norm of Disk\n// rad : radius of Disk\n// e : energy associated to skeleton\n// R : large radius\nfloat disk(vec3 p, vec3 c, vec3 n,float rad, float e,float R)\n{\n  return e*falloff(distDisk(p,c,n,rad),R);\n}\n\nfloat cylindre(in vec3 p,in vec3 a, in vec3 b, float rayon, float e,float R)\n{\n    return e*falloff(distCylindre(p,a,b, rayon) ,R);\n}\n\nfloat sphere(in vec3 p,in vec3 c, float rayon, float e,float R)\n{\n    return e*falloff(distSphere(p,c, rayon) ,R);\n}\n\nfloat cube(in vec3 p,in vec3 a, in vec3 b, float e,float R)\n{\n    return e*falloff(distCube(p,a,b) ,R);\n}\n\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n    return min(a,b);\n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Difference(float a,float b)\n{\n    return min(a,2.0*T-b);\n}\n\nfloat colonne(in vec3 p,in vec3 a, float h,float r1, float r2, float e,float R){\n    float resu=0.0;\n    float i=0.0;\n    float fit = 5.0;\n    for(int j=0;j<5;j++){\n        vec3 pos1=a+(vec3(0.0,h,0.0)/fit*(i+0.3));\n        vec3 pos2=a+(vec3(0.0,h,0.0)/fit*(i+1.0));\n        resu=Union(resu,cylindre(p,pos1,pos2,r1+(r2-r1)/fit*i,e,R));\n    \ti+=1.0;\n    }\n    \n    return resu;\n}\n\nfloat colonneCube(in vec3 p,in vec3 a, float h,float r1, float r2, float e,float R){\n    float resu=0.0;\n    float i=0.0;\n    float fit = 4.0;\n    for(int j=0;j<4;j++){\n        float largeur=r1+(r2-r1)/fit*i;\n        vec3 pos1=a+(vec3(0.0,h,0.0)/fit*(i+0.3))-vec3(largeur/2.0,0.0,largeur/2.0);\n        vec3 pos2=a+(vec3(0.0,h,0.0)/fit*(i+1.0))+vec3(largeur/2.0,0.0,largeur/2.0);\n        resu=Blend(resu,cube(p,pos1,pos2,e,R));\n    \ti+=1.0;\n    }\n    \n    return resu;\n}\n\nfloat colonneSocle(in vec3 p,in vec3 a, float h,float r, float e,float R){\n    float resu=cube(p,a-vec3(r/2.0,0.0,r/2.0),a+vec3(r/2.0,0.05*h,r/2.0),e,R);\n    resu=Union(resu,cube(p,a-vec3(r/2.0,-0.95*h,r/2.0),a+vec3(r/2.0,h,r/2.0),e,R));\n    resu=Union(resu,colonne(p,a+vec3(0.0,0.05*h,0.0),0.9*h,r*0.4,0.6*r*0.4,e,1.0));\n    return resu;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  /*float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  v=Difference(v,point(p,vec3(-1.0, -1.0, 0.0),1.0,4.5));*/\n  //float v= line(p,vec3( 0.0, 1.0, 1.0),vec3( 2.0, 0.0,-3.0),1.0,4.5);\n  //v=Difference(v,point(p,vec3(-1.0, -1.0, 0.0),1.0,4.5));\n    \n  //float v= point(p,vec3( 0.0, 1.0, 1.0),1.0,4.0);\n  //v=Intersection(v,cube(p,vec3(0.0,0.0,0.0),vec3(3.0,3.0,3.0),1.0,4.5));\n    float v=0.0;\n    float fi=0.0;\n    for(int i=0; i<1; i++){\n       \n        v=Union(v,colonneSocle(p,vec3(-5.0+3.0*fi,-4.0,0.0),8.0,1.0,1.0,1.0));\n        fi+=1.0;\n    }\n  \n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 247, 278, 278, 376], [378, 378, 409, 409, 508], [510, 510, 541, 541, 640], [643, 710, 745, 745, 818], [833, 833, 872, 872, 1096], [1098, 1098, 1148, 1148, 1331], [1332, 1332, 1380, 1380, 1567], [1569, 1569, 1637, 1637, 1900], [1902, 1902, 1957, 1957, 1994], [1998, 1998, 2046, 2046, 2542], [2568, 2682, 2728, 2728, 2765], [2767, 2870, 2923, 2923, 2964], [2966, 3127, 3192, 3192, 3239], [3241, 3394, 3457, 3457, 3502], [3504, 3504, 3582, 3582, 3637], [3639, 3639, 3704, 3704, 3755], [3757, 3757, 3818, 3818, 3862], [3866, 3957, 3987, 3987, 4005], [4007, 4095, 4125, 4125, 4148], [4150, 4245, 4282, 4282, 4305], [4307, 4400, 4435, 4435, 4464], [4466, 4466, 4546, 4546, 4844], [4846, 4846, 4930, 4930, 5315], [5317, 5317, 5391, 5391, 5657], [5659, 5705, 5727, 5727, 6425], [6427, 6467, 6498, 6498, 6719], [6721, 6826, 6877, 6877, 7312], [7314, 7419, 7476, 7476, 7927], [7930, 7950, 7976, 7976, 8048], [8050, 8111, 8139, 8156, 8473], [8615, 8615, 8672, 8672, 9471]], "test": "valid"}
{"id": "4t2XWG", "name": "Penrose/Robinson Revisited", "author": "tomkh", "description": "Penrose/Robinson tiling with distance function to edge, textured tiles and cleaned-up commented code :-)", "tags": ["tiling", "penrose", "aperiodic", "robinson"], "likes": 43, "viewed": 816, "published": "Public", "date": "1446166014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Penrose/Robinson Tiling Revisited\n// (procedural texture and distance field)\n// 2015 (C) Tom\n\n// Original shader:\n//   http://polycu.be/edit/?h=mh4l7V\n//   http://webglplayground.net/?gallery=aperiodic-Penrose-Robinson-tilings\n\n// Subsitution rules:\n//   http://tilings.math.uni-bielefeld.de/substitution_rules/robinson_triangle\n\n#define PATTERN 0\n  // 0 = textured Penrose tiles\n  // 1 = colored Robinson tiles with wiggly pattern\n\nconst int base_levels = 9; // base substitution levels\n\n//----------------------------------------------------\n// getTile returns:\n//   * type = tile type, Robinson code 0..3\n//   * q = coordinate in local tile space\n//   * rotation matrix to local tile space\n//----------------------------------------------------\nmat2 getTile(out int type, inout vec2 q, int levels)\n{\n  const float sc = 1.6180339887498947; // = 2.0/(sqrt(5.0)-1.0) (inflation scale)\n  const float pi = 3.1415926535897931;\n   \n  // Transformations constants:\n  \n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  const float a1 = 0.61803398874989479; // = .5/cos(36*pi/180)\n  const float a2 = 0.80901699437494745; // = (1+a1)*.5\n  const float a3 = 0.5877852522924728; // = tan(36*pi/180)*a2\n  const float cos1 = -0.8090169943749475; // = cos(144*PI/180)*sc\n  const float sin1 = 0.5877852522924732; // = sin(144*PI/180)*sc\n  const float cos2 = -0.30901699437494734; // = cos(108*PI/180)*sc\n  const float sin2 = 0.9510565162951536; // = sin(108*PI/180)*sc\n\n  mat2 m, final_m = mat2(1);\n  \n  type = (q.y < 0.) ? 1 : 0; // starting prototile\n  if (q.y < 0.) {\n     // flip rotation matrix as well\n     final_m[0].y = -final_m[0].y;\n     final_m[1].y = -final_m[1].y;\n     q.y = -q.y;\n  }\n  \n  for (int k=0; k<base_levels; k++)  // iterate all subsitutions\n  {\n     if (k >= levels) break;\n     if (type < 2) \n     {\n        // We substitute triangle type 0/1\n        // with three triangles.\n        // We detect in which of those three\n        // our current q = (x,y) lies\n        // by checking line equations separating them:\n        \n        if (1.0 - d1*q.y - q.x > 0.0) // left triangle\n        {         \n           // translate:\n           q.x -= 1.;\n           \n           // mirror:\n           m = mat2(-1.,0.,0.,1.);\n            \n           type = 1 - type; // tile type changes here!\n        } \n        else if (1.0 - d2*q.y - q.x > 0.0) // middle triangle\n        {\n           // translate:\n           q -= vec2(a2,a3);\n           \n           // rotate:\n           m = mat2(cos1,sin1,-sin1,cos1);\n           \n           type = 3 - type; // tile type changes here!\n        } \n        else // right triangle\n        {      \n           // translate (x only):\n           q.x -= a1 + 1.;\n        \n           // rotate:\n           m = mat2(cos1,-sin1,sin1,cos1);\n        }      \n     } \n     else \n     {\n        // We substitute triangle type 2/3\n        // with two triangles (analogically).\n  \n        if (d1*q.y - q.x > 0.0) { // upper triangle\n        \n           // rotate only\n           m = mat2(-cos2,sin2,sin2,cos2);\n                    \n           type -= 2; // tile type changes here!\n           \n        } else { // lower triangle\n        \n           // translate (x only):\n           q.x -= a1;\n           \n           // rotate:\n           m = mat2(cos2,-sin2,sin2,cos2);\n        }\n     }  \n     \n     // final rotate:\n     q = m * q; \n     final_m = m * final_m;\n     \n     // inflaction scale:\n     q *= sc;\n  }\n  \n  // return final rotate (e.g. to rotate normal later):\n  return final_m;\n}\n\n//----------------------------------------------------\n// getEdgeDist returns:\n//   * distance to closest edge of Penrose tile\n//----------------------------------------------------\nfloat getEdgeDist(int type, vec2 q)\n{\n  const float inv_sc = 0.6180339887498949; // = (sqrt(5.0)-1.0)/2.0\n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  float dist = 0.;\n  if (type < 2) {\n     dist = 1.-(d1*q.y+q.x)*inv_sc;\n     dist = min(dist, (-d1*q.y+q.x)*inv_sc);\n  } else {\n     dist = (-d2*q.y+q.x);\n     dist = min(dist, (inv_sc-d2*q.y-q.x));\n  }\n  return dist;\n}\n\n//------------------------------------------------------\n// getDist returns:\n//   * beveled distance to closest edge of Penrose tile\n//------------------------------------------------------\nfloat getDist(int type, vec2 q)\n{\n  float dist = getEdgeDist(type,q);\n  return min(dist,.05)*2.+min(dist,.15)*1.;\n}\n\n//----------------------------------------------------\n// getNorm returns:\n//   * beveled normal rotated by \"m\"\n//----------------------------------------------------\nvec3 getNorm(int type, vec2 q, mat2 m)\n{\n  const vec2 eps = vec2(.001,0.);\n  vec3 norm = vec3(\n     getDist(type,q+eps.xy) - getDist(type,q-eps.xy),\n     getDist(type,q+eps.yx) - getDist(type,q-eps.yx),\n     eps.x*2.\n   );\n  norm.xy *= m;\n  return normalize( norm );\n}\n\n//----------------------------------------------------\n// getColor returns:\n//   * color from Robinson codes\n//----------------------------------------------------\nvec3 getColor(int type, vec2 q)\n{\n  const float r = .05;\n  vec3 base;\n  if (type >= 2) {\n     float f = (type == 2) ? q.y : -q.y;\n     f = smoothstep(-r,r,f);\n     base = mix(\n        vec3(40./255.,80./255.,166./255.),\n        vec3(86./255.,110./255.,167./255.),f);\n  } else {\n     float f = (type == 0) ? q.y : -q.y;\n     f = smoothstep(-r,r,f);\n     base = mix(\n        vec3(255./255.,204./255.,92./255.),\n        vec3(255./255.,102./255.,0.),f);\n  }\n  return base-.1;\n}\n\n//----------------------------------------------------\n// getTexture returns:\n//   * textured tile color\n//----------------------------------------------------\nvec3 getTexture(int type, vec2 q)\n{\n  const float r = .05;\n  vec3 base;\n  if (type >= 2) {\n     if (type == 2) q.y = -q.y;\n     base = texture(iChannel1, q).xyz*vec3(.12,1.,.1) + vec3(.1);\n  } else {\n     if (type == 0) q.y = -q.y;\n     base = texture(iChannel0, q).xyz + vec3(.25);\n  }\n  return base;\n}\n\n//----------------------------------------------------\n// penrose returns:\n//   * color for penrose tile with shading\n//----------------------------------------------------\nvec3 penrose(mat2 rot, vec2 q0, float sample_size, int levels)\n{\n  int type;\n  vec2 q = q0;\n  \n  rot = getTile(type, q, levels) * rot;\n  \n  vec3 norm = getNorm(type, q, rot);\n  \n  float dist = getDist(type, q);\n  \n#if PATTERN == 1\n  vec3 base = getColor(type, q);\n    \n  // Fancy wiggly pattern:\n  float d;\n  if (type < 2) {\n     d = abs(sqrt(1.0 - dot(q,q))-.6);\n  } else {\n     q.x -= 0.61803398874989479;\n     d = abs(sqrt(dot(q,q))*1.3-.27);\n  }\n  float r = pow(2.,float(levels))*.1*sample_size; // sample size\n  if (d > 0.) {\n    d = (1. - smoothstep(.1-r,.1,d));\n    base = mix(base, vec3(1.), d*.5);\n  }\n    \n  float spec = .2;\n    \n#else\n    \n  vec3 base = getTexture(type, q);\n  float spec = .5;\n\n#endif\n \n  // Lighting:\n  vec3 light_dir = normalize(vec3(.2,-.6,.5));\n  base *= min(1.,dist*5.)*max(0.,dot(norm,light_dir)*.3+.7);\n  base += vec3(1)*pow(max(0.,dot(norm,light_dir)),4.)*spec;\n  \n  return base;\n}\n\n//----------------------------------------------------\n// Main shader code\n//----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = (iMouse.z > 0.) ? iMouse.x*.005 : iTime*.25;\n  time += 2.;\n\n  int type;\n  float co, si;\n  \n  vec2 q;\n  \n  type = 0;\n  \n  // simple roto-zooming:\n  co = cos(time*.6);\n  si = sin(time);\n  float scale = sqrt(co*co + si*si);\n  \n  vec2 p = (fragCoord.xy - iResolution.xy*.5)*.5/iResolution.y;\n  \n  mat2 rot = mat2(co,-si,si,co)*(1./scale);\n  q = rot * p * (.5*scale) + vec2(.8,0.);\n    \n  float sample_size = scale/iResolution.y;\n  \n  vec3 base, base1, base2;\n  float blend = (iMouse.z > 0.) ? smoothstep(-.2,.2,iMouse.y/iResolution.y-.5) : 0.;\n  base1 = (blend < 1.) ? penrose(rot, q, sample_size, base_levels) : vec3(0);\n  base2 = (blend > 0.) ? penrose(rot, q, sample_size, base_levels-1) : base1;\n  base = mix(base1, base2, blend);\n    \n  base = pow(base,vec3(.6));\n\n  fragColor = vec4(base, 1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 751, 805, 805, 3584], [3586, 3768, 3805, 3805, 4213], [4215, 4405, 4438, 4438, 4520], [4522, 4689, 4729, 4729, 4957], [4959, 5123, 5156, 5156, 5595], [5597, 5757, 5792, 5792, 6060], [6062, 6235, 6299, 6299, 7152], [7154, 7284, 7341, 7341, 8155]], "test": "error"}
{"id": "4t2XzG", "name": "PsychÃ©delicious", "author": "apulby", "description": "This is just a little test for fun, enjoy Ã¨_Ã©", "tags": ["druuuuuuuugs"], "likes": 0, "viewed": 95, "published": "Public", "date": "1444642137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n    \n    float cameraAngle = 20.0*(3.14/180.0) + iTime;\n    float zoom = (iResolution.x / 1911100.0)* (1.0 + 0.2 * sin(2.0 * iTime));\n    float cameraX = 10.0 / iTime;\n    float cameraY = -3.0 - iTime ; \n    \n    float xBeforeRot = (pixCoords.x / zoom) - cameraX;\n    float yBeforeRot = (pixCoords.y / zoom) - cameraY;\n    \n    float x = (xBeforeRot*cos(cameraAngle))+(yBeforeRot*sin(cameraAngle));\n    float y = (xBeforeRot*-sin(cameraAngle))+(yBeforeRot*cos(cameraAngle));\n    \n    float radius = 0.3 + 0.1 * cos(3.0 * iTime + x * sin(y));\n\n    if (distanceTo(mod(x, 1.0), mod(y, 1.0), 0.5, 0.5) < radius) {\n        color = vec4(cos(xBeforeRot), sin(xBeforeRot/yBeforeRot), cos(yBeforeRot), 1.0);\n        return;\n    }\n    \n    color = vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 181], [183, 183, 236, 236, 1002]], "test": "valid"}
{"id": "4t2Xzt", "name": "Subluminic 3", "author": "aiekick", "description": "Subluminic 3", "tags": ["3", "subluminic"], "likes": 90, "viewed": 10731, "published": "Public API", "date": "1445899916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* \n\tthe cloudy famous tech come from the shader of duke : https://www.shadertoy.com/view/MljXDw\n        Himself a Port of a demo by Las => http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n*/\n\nvec4 freqs;\nfloat t;\n\n#define uTex2D iChannel0\nfloat pn( in vec3 x ) // iq 3d noise\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod(uTex2D, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nvec2 path(float t, float k, float c)\n{\n\treturn vec2(cos(t/k), sin(t/k))*c;\n}\n\nfloat df(vec3 p)\n{\n\tfloat pnNoise = pn(p*0.7)*1.7 + pn(p*0.8)*2.2 + pn(p*3.1)*0.6;\n\tp.z += pnNoise;\n\tp.xy += path(p.z, 5., 10.);\n\tfloat serpentA = length(p.xy) - 2.;\n\tp.xy += path(p.z, 1., 10.);\n\tfloat serpentB = length(p.xy/(freqs.xy+.1)) - 2.;\n\treturn min(serpentA, serpentB);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv, float fov)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu, rov));\n    vec3 v = normalize(cross(rov, u));\n    vec3 rd = normalize(rov + fov * u * uv.x + fov * v * uv.y);\n    return rd;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy) - df(p-e.xyy),\n\t\tdf(p+e.yxy) - df(p-e.yxy),\n\t\tdf(p+e.yyx) - df(p-e.yyx)\n\t\t);\n    return normalize(n);\n}\n\nvec3 march(vec3 f, vec3 ro, vec3 rd, float st)\n{\n\tvec3 s = vec3(1), h = vec3(.16,.008,.032), w = vec3(0);\n\tfloat d=1.,dl=0., td=0.;\n\tvec3 p = ro;\n\tfor(float i=0.;i<100.;i++)\n\t{      \n\t\tif(s.x<0.01||d>400.||td>.95) break;\n        s = df(p) * .1 * i/vec3(107,160,72);\n\t\tw = (1.-td) * (h-s) * i/vec3(61,27,54)* freqs.yzw * 4. * step(s,h);\n\t\tf += w;\n\t\ttd += w.x + .01;\n\t\tdl += 0.05;\t\n\t\ts = max(s, st);\n\t\td +=s.x; \n\t\tp =  ro+rd*d;\t\n   \t}\n\tdl += 0.5;\n\tf /= dl/15.;\n\tf = mix( f, vec3(0), 1. - exp( -.0002*d*d) ); // iq fog\n\treturn f;\n}\n\n#define uTime iTime\n#define uScreenSize iResolution.xy\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    // from CubeScape : https://www.shadertoy.com/view/Msl3Rr\n    freqs.x = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs.y = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs.z = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs.w = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n    \n\tt = uTime*2.5;\n\tf = vec4(0,0.15,0.32,1);\n    vec2 si = uScreenSize;\n\tvec2 q = g/si;\n\tfloat z = t * 5.;\n    vec3 ro = vec3(path(z,5.,5.+(sin(t*.5)*.5+.5)*5.), z );\n\tvec2 uv = (2.*g-uScreenSize)/uScreenSize.y;\n\tvec3 rd = cam(uv, ro, vec3(path(z,10.,10.),0), ro+vec3(0,0,1), 3.5);\n\tf.rgb = march(f.rgb, ro, rd, 0.2);\n\tuv*= uScreenSize * 10.;\n\tfloat k = fract( cos(uv.y * 0.0001 + uv.x) * 500000.);\n\tf.rgb = mix(f.rgb, vec3(1), pow(k, 50.));\n\tf.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); // vignette\n    f = sqrt(f*f*f*2.);\n}\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2Xzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[445, 445, 483, 483, 697], [699, 699, 737, 737, 775], [777, 777, 795, 795, 1057], [1059, 1059, 1116, 1116, 1306], [1308, 1308, 1340, 1340, 1508], [1510, 1510, 1558, 1558, 2038], [2095, 2095, 2136, 2198, 2970]], "test": "error"}
{"id": "4tBSDy", "name": "2D trip", "author": "fantomas", "description": "he", "tags": ["2d", "fractale"], "likes": 2, "viewed": 746, "published": "Public API", "date": "1446113035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy-0.5)*5.;\n    float an;\n    for (int i=0; i<24; i++)\n    {\n        an =1.+sin(length(uv/=1.6)*5.+_t/2.);\n        uv += normalize(vec2(-uv.y, uv.x))*an/6.;\n        uv = abs(uv*=1.8)-_t/20.-2.;        \n    }\n    float d=length(uv)*2.;\n\tfragColor = normalize(vec4(sin(d),sin(d*1.2),sin(d*1.3),0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 415]], "test": "valid"}
{"id": "4tBSzt", "name": "Raymarching test by Dan", "author": "dancasas", "description": "raymarching", "tags": ["raymarching"], "likes": 3, "viewed": 129, "published": "Public", "date": "1445705634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 transform(vec3 pt, vec3 translate, vec3 rot, vec3 scale) {\n    scale.x = 1.0/scale.x;\n    scale.y = 1.0/scale.y;\n    scale.z = 1.0/scale.z;\n    \n    mat3 invRot = mat3(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) ,\n                       cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z),\n                       -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z);\n    \n \tmat4 trans = mat4(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) , 0.0, \n                      cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z), 0.0, \n                      -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z, 0.0, \n                      (-invRot*translate).x, (-invRot*translate).y, (-invRot*translate).z, 1.0);\n    \n    vec4 newPt = vec4(pt, 1.0);\n    newPt = trans*newPt;\n    return vec3(newPt);\n                    \n}\n\nmat3 makeRotateX(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(1.0, c, -s,\n              0.0,  s, c,\n              0.0, 0.0, 1.0);\n}\nmat3 makeRotateY(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c,    0.0, s,\n              0.0,  1.0, 0.0,\n              -s,   0.0, c);\n}\nmat3 makeRotateZ(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c, -s, 0.0,\n              s,  c, 0.0,\n              0.0, 0.0, 1.0);\n}\n\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\nfloat sphereTranslated(vec3 pos, vec3 t, float radius)\n{\n    //float x = pow(abs(pos.x - t.x),2.0);\n    //float y = pow(abs(pos.y - t.y),2.0);\n    //float z = pow(abs(pos.z - t.z),2.0);\n\t\n    //return (sqrt(x+y+z) - radius);\n    //return sqrt(,pow(abs(pos.y - t.y)),2),pow(abs(pos.z - t.z)),2)); \n\n\n    mat4 m = mat4(vec4(1.0, 0.0, 0.0, t.x), \n                  vec4(0.0, 1.0, 0.0, t.y), \n                  vec4(0.0, 0.0, 1.0, t.z), \n                  vec4(0.0, 0.0, 0.0, 1.0));\n    vec3 q = vec4(m*vec4(pos,1.0)).xyz;\n    return sphere(q, radius);\n}\n\n\n\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\nfloat boxTransform(vec3 pos, vec3 size)\n{\n    //pos = transform(pos, -pos, vec3( 0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n   \n    pos = makeRotateY(2.0*iTime)*pos;\n    pos = makeRotateZ(iTime*2.0)*pos;\n    //pos = transform(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.5*iTime,1.0), vec3(1.0));\n    //pos = transform(os, vec3(-9.0, 0.0, 0.0), vec3( 1.0, 0.0, 0.0), vec3(3.0, 3.0, 3.0));\n    \n    //\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\n              /*\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n\n\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n*/\n\nfloat distfunc(vec3 pos)\n{\n    float sphere1 = sphere(pos, 1.0);\n    float sphere2 = sphere(pos + vec3(0.0, 1.0, -1.0), 1.0);\n    \n    //float sphere3 = sphere(pos - lightPos, 0.2);\n    //return sdHexPrism(pos, vec2(0.4,0.4));\n    float min1 = min(sphere1, sphere1);\n    //float min2 = min(min1, sphere3);\n    \n    return min1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    const float EPSILON  = 0.0001;\n    \n    vec2 eps = vec2(0.0, EPSILON);\n    \n\treturn normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n    distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n}\n\nvec3 computeRayDir(vec3 origin, vec3 target)\n{\n    vec3 upDirection   = vec3(0.0, 1.0, 0.0);\n    \n    vec3 localDir      = normalize(target - origin);\n    vec3 localRight    = normalize(cross(upDirection, origin));\n    vec3 localUp       = cross(localDir, localRight);\n    \n    // Screen range from -1 to 1\n    vec2 screenPos     = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x       *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir        = normalize(localRight * screenPos.x + localUp * screenPos.y + localDir* 4.0);\n \n    \n    return rayDir;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //vec3 cameraOrigin  = vec3(2.0*cos(iTime*1.0), 2.0*cos(iTime*1.0), 2.0);\n    vec3 cameraOrigin  = vec3(0.0, 0.0, 70.0);\n    vec3 lightOrigin   = vec3(22.0*cos(iTime*1.0), 12.0*sin(iTime*1.0), 20.0);\n    \n    //vec3 cameraTarget  = vec3(10.0*sin(iTime*1.0), 0.0, 0.0);\n    vec3 cameraTarget  = vec3(0.0,0.0, 0.0);\n    \n   \n    vec2 screenPos     = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    \n    \n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir      = computeRayDir(cameraOrigin, cameraTarget);//normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    vec3 rayDir4     = computeRayDir(cameraOrigin, vec3(5.0, 0.0, 0.0)); \n    \n    vec3 lightRayDir = computeRayDir(lightOrigin, cameraTarget);\n    \n    const int MAX_ITER   = 100;\n    const float MAX_DIST = 90.0;\n    const float EPSILON  = 0.0001;\n    \n    float totalDist      = 0.0;\n    vec3 pos             = cameraOrigin;\n    float dist           = EPSILON;\n    int closest;\n    \n    for(int i=0; i< MAX_ITER; i++)\n    {\n        // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break; // If you use windows and the shader isn't working properly, change this to continue;\n\n        float dist1   = sphere(pos, 6.0);\n        float dist2\t  = sphere( pos + vec3(-7.0, 0.0, -1.0), 3.5);\n       // vec3 posLight = sqrt(pow(pos.x - lightOrigin.x),2),pow(pos.x - lightOrigin.x),2),pow(pos.x - lightOrigin.x),2),); \n        //float dist3   = sphereTranslated(pos, lightOrigin, 0.5);\n        float dist3   = sphere(pos - lightOrigin, 1.5);\n        //float dist4   = sphere(pos + vec3(6.0, 0.0, -2.0), 3.5);\n        float dist4   = boxTransform(pos - vec3(-12.0, 0.0, 0.0), vec3(4.0, 4.0, 4.0));\n        \n        \n        dist    = dist1;\n        closest = 1;\n         \n        if(dist2 < dist)\n        {\n            dist    = dist2;\n        \tclosest = 2;\n        }\n        \n        if(dist3 < dist)\n        {\n            dist       = dist3;\n        \tclosest    = 3;\n            }\n\n        if(dist4 < dist)\n        {\n            dist       = dist4;\n            closest    = 4;\n            //lightRayDir = computeRayDir(vec3(2.0, 0.0, 0.0),  vec3(3.0, 0.0, 0.0));\n            lightRayDir = computeRayDir(lightOrigin , cameraTarget );\n            }\n\n        totalDist += dist; \n     \tpos += dist * rayDir;\n    }\n    \n    \n    vec3 normal    = computeNormal(pos);   \n    float diffuse  = max(0.0, dot(-lightRayDir, normal));\n    float specular = pow(diffuse, 32.0);\n    \n    vec3 color;\n    if(totalDist > MAX_DIST)\n    {\n    \tcolor = vec3(0.3, 0.3, 0.4);\n    }\n    else\n    { \n        color = vec3(0.5,0.1, 0.4);\n        \n        if(closest == 1)\n        {\n            color = vec3(0.0,(diffuse + specular)*0.5, 0.0); \n        }\n        if(closest == 2)\n        {\n            specular = pow(diffuse, 128.0);\n            color = vec3((diffuse + specular), 0.0, (diffuse*0.5 + specular));\n        }\n        if(closest == 3)\n        {\n            color = vec3(1.0, 0.5, 0.0);\n        }\n        if(closest ==4)\n        {\n            float specular = pow(diffuse, 2.0);\n            color = vec3((diffuse + specular)*0.3, (diffuse + specular)*0.2, (diffuse + specular)*0.5);\n        }\n    }\n    \n    //fragColor = vec4(pos.z, pos.z, pos.z, 1.0);\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 64, 64, 1243], [1245, 1245, 1272, 1272, 1396], [1397, 1397, 1424, 1424, 1553], [1554, 1554, 1581, 1581, 1705], [1708, 1708, 1746, 1746, 1781], [1782, 1782, 1838, 2078, 2332], [2337, 2337, 2369, 2369, 2417], [2420, 2420, 2461, 2538, 2856], [3161, 3161, 3187, 3187, 3490], [3492, 3492, 3522, 3522, 3795], [3797, 3797, 3843, 3843, 4366], [4370, 4370, 4427, 4427, 7872]], "test": "valid"}
{"id": "4tBXDD", "name": "Yet another raymarch #4", "author": "hexjayi", "description": "experiment #4", "tags": ["3d", "noise", "raymarch", "bumpmap"], "likes": 10, "viewed": 593, "published": "Public", "date": "1445356747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\tToying with code from :\n\t@paulofalcao -> https://www.shadertoy.com/view/ldfGzr\n\tIQ raymarch reference and noise -> https://www.shadertoy.com/view/Xds3zN \n\tShane's texture bump mapping -> https://www.shadertoy.com/view/MlXSWX\n*/\n\nconst int ITER = 50;\nconst float PI = 3.14159265;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.9 );\n\nmat3 rotate3(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat ss(float mi,float ma,float a)\n{ // sineSignal (min,max,alpha)\n\treturn (sin(a)+1.)*(ma-mi)*0.5+mi;\n}\n\n\n//   /\n//---  Noise\n//   \\\n\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec2 p )\n{\n\tp*=3.;\n\tfloat f = 0.0;\n    f += 0.25000*noise( p ); p = m2*p*0.02;\n    f += 0.12500*noise( p ); p = m2*p*0.13;\n    f += 0.06250*noise( p ); p = m2*p*0.01;\n    f += 0.03125*noise( p ); p = m2*p*0.04;\n    f += 0.01500*noise( p );\n    return f/0.38375;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//    /\n//----  Objects / Primitives\n//    \\\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n#if 0\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n#else\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n//    /\n//----  Operators\n//    \\\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p, float freq, float phase )\n{\n    float  c = cos(freq*p.y+phase);\n    float  s = sin(freq*p.y+phase);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n//    /\n// ---  Field\n//    \\\n\nmat3 rotation;\n\nfloat distanceField(in vec3 p) \n{\n    vec2 res,res0,res1,res2;\n\tres = vec2(9999999.,0.);\n\n    float fbmp=fbm(p);\n        \n  \tp = opRep(p, vec3(10,10.,10.) );\n    \n    res1 = vec2(sdCapsule(p, vec3(0.,0.,-5.), vec3(0.,0.,5.),4.2 ), 000002.);\n    res = opU(res,res1);\n    res1 = vec2(sdCapsule(p, vec3(0.,-5.,0.), vec3(0.,5.,0.),4.2 ), 009900.);\n    res = opU(res,res1);\n    res1 = vec2(sdCapsule(p, vec3(-5.,0.,0.), vec3(5.,0.,0.),4.2 ), 999900.);\n    res2 = opU(res,res1);\n    \n    res1 = vec2( sdBox(p,vec3(5.,5.,5.)),990000);\n    res.x = opS(res1.x,res2.x);\n    \n    return res.x+fbmp*ss(0.,0.8,iTime/2.35);\n}\n\n//    /\n// ---  Texturing\n//    \\\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// from Shane : https://www.shadertoy.com/view/MlXSWX\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n//    /\n// ---  Main\n//\t  \\\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec3 bgColor = vec3 (0.1,0.0,0.0);\n\n  \tvec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  \tvec3 finalColor = vec3 (0.0);  \n  \n  \t//Camera animation\n  \tvec3 vuv=vec3(0,0,1);//Change camere up vector here\n  \t\n    vec3 prp=vec3(\n        \tss(-5.4,15.6,iTime/2.),\n        \tss(-2.,2.,iTime),\n        \t4. ); //Change camera path position here\n  \t\n        \t//2.5 , 2., 2.5 );\n        \t\n    vec3 vrp=vec3(\n        2.5,\n        2.5,\n        //ss(0.,8.,iTime) ); //Change camere view here\n        2.5);\n\n  \t//Camera setup\n  \tvec3 vpn=normalize(vrp-prp);\n  \tvec3 u=normalize(cross(vuv,vpn)*rotate3(vec3(ss(-0.3,0.3,iTime*0.63),0.,0.) ));\n  \tvec3 v=cross(vpn,u);\n  \tvec3 vcv=(prp+vpn);\n  \tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t//Raymarching\n  \tconst vec3 e=vec3(0.2,0,0);\n  \tconst float maxd=50.0; //Max depth\n\n  \tfloat s= 0.1;\n  \tvec3 c,p,n;\n\n  \tfloat f=1.0;\n  \tfor(int i=0;i<  ITER ; i++)\n    {\n    \tif (abs(s)<.01||f>maxd) break;\n    \tf+=s;\n    \tp=prp+scp*f;\n    \ts=distanceField(p);\n  \t}\n\n  \tif (f<maxd)\n    {\n    \t\n    \tn=normalize(\n      \tvec3(s-distanceField(p-e.xyy),\n        \ts-distanceField(p-e.yxy),\n        \ts-distanceField(p-e.yyx)));\n    \t\n        float texScale = 0.5;\n        n = doBumpMap(iChannel1, p*texScale, n,  0.40);\n        \n        float b=dot(n,normalize(prp-p));\n\t\t\n        c=tex3D(iChannel1, p*texScale, n)*4.;\n    \t\n        vec3 lightPos = vec3( 2.5,2.5,sin(iTime*1.1)*4. );\n        vec3 lightDir = normalize(lightPos-p);\n        float lightDistance = distance(lightPos,p);\n        \n        float b2=dot(lightDir,n);\n        \n        vec3 c1 = vec3( b*c+pow(b,8.) ) ;\n        vec3 c2 = vec3( c*(b2 + pow(b2, 8.) + 0.35)*1.5/(1.+lightDistance*.1+lightDistance*lightDistance*.005));  // Shane suggestion\n        \n        \n        finalColor = mix(c1,c2,.6);\n\t\tfinalColor*=0.44;\n    \n    \t// vignetting from : https://www.shadertoy.com/view/4lSXDm\n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tvec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    \tfloat Falloff = 0.35;\n        float rf = sqrt(dot(coord, coord)) * Falloff;\n\t    float rf2_1 = rf * rf + 1.0;\n\t    float e = 1.0 / (rf2_1 * rf2_1);\n    \n\t    vec4 src = vec4(finalColor,1.);\n\t\tfragColor = vec4(src.rgb * e, 1.0);    \n    \t//fragColor = vec4( finalColor, 1.);\n  \t} else \n    { // background color\n    \tbgColor = \n\t  \t\tvec3(0.1,0.1,0.1)*0.4;\n\t  \tfragColor=vec4(bgColor,1.);\n  \t}\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 465, 465, 754], [756, 756, 793, 823, 861], [893, 893, 919, 919, 1063], [1065, 1065, 1091, 1091, 1296], [1298, 1298, 1319, 1319, 1572], [1574, 1574, 1595, 1595, 1777], [1779, 1825, 1850, 1850, 1865], [1867, 1867, 1902, 1902, 1928], [1930, 1930, 1961, 1961, 2048], [2050, 2050, 2095, 2095, 2135], [2137, 2137, 2170, 2170, 2223], [2225, 2225, 2261, 2261, 2503], [2505, 2505, 2557, 2557, 2671], [2673, 2673, 2709, 2709, 2957], [2959, 2959, 2995, 2995, 3094], [3096, 3096, 3134, 3134, 3375], [3377, 3377, 3402, 3402, 3439], [3441, 3441, 3466, 3466, 3524], [3526, 3526, 3551, 3551, 3616], [3618, 3618, 3653, 3653, 3720], [3722, 3722, 3757, 3757, 3824], [3826, 3826, 3863, 3863, 3914], [3917, 3952, 3985, 3985, 4011], [4013, 4013, 4043, 4043, 4076], [4078, 4078, 4111, 4111, 4136], [4138, 4138, 4171, 4171, 4196], [4198, 4198, 4228, 4228, 4257], [4259, 4259, 4308, 4308, 4442], [4492, 4492, 4525, 4525, 5103], [5105, 5140, 5162, 5162, 5206], [5208, 5208, 5258, 5258, 5454], [5456, 5510, 5583, 5583, 6047], [6049, 6078, 6133, 6133, 8577]], "test": "error"}
{"id": "4tjXDw", "name": "TP - Ombre avec Phong", "author": "Zoctos", "description": "Ombre", "tags": ["phong", "ombre"], "likes": 0, "viewed": 94, "published": "Public", "date": "1444206959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n  \t uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 origine = vec3(0.0, 0.0, -2.0);\n\tvec3 direction = normalize(vec3(uv.x*2.0, uv.y*2.0, 1.0));\n    \n\tvec3 sphere = vec3(1.2,1.2,1.0);\n\tfloat rayon = 1.0;\n    \n\tvec3 lumiere = vec3(cos(iTime), sin(iTime), -2);\n    \n    vec3 sol = vec3(0.0, 2.2, 0.0);\n  \t \n\tvec3 p = origine;\n    \n\tfragColor = vec4(1.0, 1.0, 1.0 ,1.0);\n    \n\tfor(float i = 0.0; i <= 512.0; i++){\n   \t \n    \tp += direction*0.02;\n   \t \n    \tif(distance(p, sphere) <= 1.0){\n\n        \tvec3 color = vec3(0.2, 0.0, 0.0);\n       \t \n        \tvec3 normale = normalize(p - sphere);\n        \tvec3 nLumPoint = normalize(lumiere - p);\n       \t \n        \tvec3 reflexion = reflect(nLumPoint, normale);\n       \t \n        \tfloat diffuse = max(dot(normale, nLumPoint), 0.0);\n        \tfloat specular = pow(max(dot(reflexion, p), 0.0), 64.0);\n       \t \n        \tfloat intensite = diffuse + specular;\n       \t \n        \tcolor += intensite;\n       \t \n        \tfragColor = vec4(color, 1.0);\n       \t \n        \tbreak;\n       \t \n    \t}\n        else if(distance(p.y, sol.y) <= 0.2){\n       \t\t\n            vec3 nLumPoint = normalize(lumiere - p);\n                \n            vec3 reflexion = reflect(nLumPoint, -p);\n\n            float diffuse = max(dot(p, nLumPoint), 0.0);\n            float specular = pow(max(dot(reflexion, p), 0.0), 64.0);\n            \n            if(distance(nLumPoint, sphere) >= 2.95){\n                fragColor = vec4(0.0, 0.0, 0.4, 1.0);\n                \n            }\n            else{\n            \tfragColor = vec4(0.0, 0.0, 0.5+(diffuse+specular), 1.0);\n            }\n            \n            break;\n            \n        }\n   \t \n\t}\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1756]], "test": "valid"}
{"id": "4tjXRV", "name": "Flashing Lines", "author": "ChazMeister", "description": "I was playing with this: https://www.shadertoy.com/view/4tl3W8 shader by nimitz and made it responsive to sound and added the ability to change the graphics a bit with mouse's y position - do that to make it more interesting.", "tags": ["pulse", "circles", "sound", "lines", "light", "colorful", "color", "fun", "visualiser", "colourful", "flash", "pulsing"], "likes": 3, "viewed": 276, "published": "Public", "date": "1445024677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original: https://www.shadertoy.com/view/4tl3W8 by nimitz\n\n// Sound response + mouse input: ChazMeister\n\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nfloat getPulse(float i, float mult) {\n    return (getWeight(squared(i)) * mult);\n}\n\nvoid mainImage( out vec4 f, in vec2 w ){\n\tvec4 p = vec4(w, 0., 1.) / iResolution.y - vec4(.9, .5, 0, 0), c = p - p;\n\tfloat t = iTime,r = length(p.xy += sin(t + sin(t * .8)) * .4), a = atan(p.y, p.x);\n\tfor (float i = 0.;i<60.;i++)\n        c = c * .98 + getPulse(i, 0.3) / 4.0 + (sin(i + vec4(5,3,2,1)) * .5 + .5 * (getWeight(squared(i) * 20.0) * 2.5)) * smoothstep(.99, 1., sin(log(r + i * .05) - t - i + sin(a += t * .01) * iMouse.y / 200.0));\n    f = c * r;\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 136, 136, 160], [162, 162, 193, 193, 252], [254, 254, 280, 280, 378], [380, 380, 417, 417, 462], [464, 464, 504, 504, 924]], "test": "error"}
{"id": "4tjXWD", "name": "Diamonds", "author": "eddietree", "description": "testing Voronesque", "tags": ["raymarch"], "likes": 17, "viewed": 417, "published": "Public", "date": "1443773911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a study on raymarching, soft-shadows, ao, etc\n// borrowed heavy from others, esp @cabbibo and @iquilezles and more\n// by @eddietree\n\n#define float3 vec3\n\nconst float INTERSECTION_PRECISION = 0.0001;\nconst int NUM_OF_TRACE_STEPS = 50;\n\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in float3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float radius = 7.0;\n    float theta = 0.3 + 5.0*mouse.x;// - iTime*0.3;\n    float phi = 3.14159*0.4;//5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// noise func\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2; \n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos )\n{  \n    //float t1 = sphere;\n    float t1 = Voronesque(pos);// - (sin(pos.x*10.0)*0.5+0.5);\n    \n    float sphere = distSphere(pos, 1.0 + t1*0.75 + sin(iTime*2.5+pos.x*1.));// + noise(pos * 1.0 + iTime*0.75);   \n    //t1 = max( t1, sphere );\n    t1 = sphere;\n   \n   \treturn vec2( t1, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float k = 2.0;\n    \n    const int maxSteps = 50;\n    float t = 0.0;\n    float res = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n            \n        if(d < INTERSECTION_PRECISION) {\n            \n            return 0.0;\n        }\n        \n        res = min( res, k*d/t );\n        t += d;\n    }\n    \n    return res;\n}\n\n\nfloat ambientOcclusion( in vec3 ro, in vec3 rd )\n{\n    const int maxSteps = 7;\n    const float stepSize = 0.05;\n    \n    float t = 0.0;\n    float res = 0.0;\n    \n    // starting d\n    float d0 = map(ro).x;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n\t\tfloat diff = max(d-d0, 0.0);\n        \n        res += diff;\n        \n        t += stepSize;\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nbool renderRayMarch(vec3 rayOrigin, vec3 rayDirection, inout vec3 color ) {\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    vec3 lightDir = normalize(vec3(1.0,0.4,0.0));\n    \n    for(int i = 0; i < maxSteps; ++i) \n    {\n        vec3 currPos = rayOrigin + rayDirection * t;\n        d = map(currPos).x;\n        if(d < INTERSECTION_PRECISION) {\n            \n            break;\n        }\n        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) \n    {    \n        vec3 currPos = rayOrigin + rayDirection * t;\n        vec3 normal = calcNormal( currPos );\n        vec3 normal_distorted = calcNormal( currPos +  noise(currPos*1.5 + vec3(0.0,0.0,sin(iTime*0.75))) );\n        float shadowVal = shadow( currPos - rayDirection* 0.01, lightDir  );\n        float ao = ambientOcclusion( currPos - normal*0.01, normal );\n\n        float ndotl = abs(dot( -rayDirection, normal ));\n        float ndotl_distorted = abs(dot( -rayDirection, normal_distorted ));\n        float rim = pow(1.0-ndotl, 6.0);\n        float rim_distorted = pow(1.0-ndotl_distorted, 6.0);\n\n        //color = vec3(0.9);\n        color = mix( color, normal*0.5+vec3(0.5), rim_distorted+0.1 );\n\n        //color = normal;\n\n        //color = normal;\n        //color *= vec3(mix(0.25,1.0,shadowVal));\n        //color *= vec3(mix(0.8,1.0,ao));\n        color += rim;\n\n        return true;\n    }\n    \n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    // calc color\n    vec3 col = vec3(0.9);\n    renderRayMarch( ro, rd, col );\n    \n    // vignette, OF COURSE\n    float vignette = 1.0-smoothstep(1.0,2.5, length(p));\n    col.xyz *= mix( 0.7, 1.0, vignette);\n        \n    fragColor = vec4( col , 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 279, 279, 312], [314, 366, 397, 397, 1182], [1184, 1184, 1250, 1250, 1428], [1430, 1430, 1511, 1511, 1851], [1853, 1853, 1894, 1894, 1965], [1967, 1967, 2000, 2000, 2026], [2028, 2028, 2061, 2061, 2086], [2088, 2102, 2125, 2125, 2161], [2162, 2162, 2188, 2188, 2557], [2559, 2653, 2682, 2682, 2716], [2718, 2718, 2751, 2751, 2776], [2778, 2862, 2884, 2911, 3175], [3177, 3177, 3217, 3217, 3594], [3597, 3597, 3647, 3647, 4014], [4016, 4016, 4047, 4047, 4273], [4278, 4278, 4353, 4353, 5709], [5712, 5712, 5769, 5769, 6408]], "test": "valid"}
{"id": "4tjXWy", "name": "Spooky Ghost", "author": "Vernou", "description": "HAPPY HALLOWEEN ! Enjoy my spooky paranormalt activity ghost.", "tags": ["halloween", "spooky", "isart"], "likes": 10, "viewed": 588, "published": "Public", "date": "1446202244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distanceTo(float x, float y, float centerX, float centerY) {\n    float deltaX = x-centerX;\n    float deltaY = y-centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\n\nvoid mainImage( out vec4 pixColor, in vec2 pixCoord )\n{\n    float PI = 3.1415;\n        \n    float windSpeed = 2.0;//TimeSlowEffect\n    float tParam = PI*iTime / windSpeed; //We use PI (3.1415) to obtain passage from -1 to 1 in 1 second\n    float sE = 0.5+0.01*tan(tParam* cos(tParam*1.3));\t//Luminosity effect of the dress\n    \n    //Camera\n    float cameraAngle =  5.0;\n\tfloat cameraX = (iResolution.x + pixCoord.x*cos(cameraAngle) + pixCoord.y*sin(cameraAngle))/ 2.0+1.0*tan(tParam*cos(tParam));\n    float cameraY = (iResolution.y + pixCoord.x*cos(cameraAngle) + pixCoord.y*sin(cameraAngle))/ 2.0+20.0*cos(tParam) -40.0;\n    float x = pixCoord.x - cameraX;\n    float y = pixCoord.y - cameraY;\n    x /= 1.0;\t//Zoom X\n    y /= 1.0;\t//Zoom Y\n    vec2 uv = pixCoord.xy / iResolution.xy;\t//Get coordinates on a 0 to 1 scale\n    \n    \n    float distance = distanceTo(x, y, 0.0, 80.0);\n    float distance2 = distanceTo(x, y, 0.0, -10.0);\n    float rayonOeil = distanceTo(x, y, -60.0, 80.0);\n    float rayonOeil2 = distanceTo(x, y, 60.0, 80.0);\n    float dColorEffect = 1.0-(distance2/200.0)*0.5;\t//colorEffect of the dress\n    float eColorEffet = 1.0-(distance2/120.0)*0.5;\t//colorEffect of the eye\n\n    float oeilX = -95.0;\t\t//CrÃ©ation de la fissure\n    float oeilY = 100.0;\n    float deltaOeilX = x-oeilX;\n    float deltaOeilY = y-oeilY;\n    float rayonOeilFlash = sqrt (-deltaOeilX*deltaOeilX + deltaOeilY*deltaOeilY);\n    float eyeSize = 40.0;\n\n    float hauteurMoyenne = -100.0;\t\t//Effet mÃ¢choire\n    float amplitude = 40.0+3.0*cos(1.3*tParam);\n    float phase = iTime * 2.5;\n    float periode = 50.0;\n    float fx = hauteurMoyenne + cos(x * 2.0 * PI/ periode + phase) * amplitude;\n    \n    \n    if (rayonOeilFlash < eyeSize*0.3+3.0*cos(tParam) && rayonOeil < 200.0) {\n        pixColor = vec4 (0.0, 0.0+0.2*dColorEffect, 0.0+0.3*dColorEffect, 1.0);\n        return;\n    }\n    \n    else if (rayonOeil < eyeSize-0.5*cos(tParam) && y<-x+5.0) {\t\n        pixColor = vec4 (0.3*eColorEffet, 0.8*eColorEffet, 0.8*eColorEffet, 1.0);\n        return;\n    }\n    \n    else if (rayonOeil2 < eyeSize-0.5*cos(tParam) && y<x+5.0) {\t\n        pixColor = vec4 (0.3*eColorEffet, 0.8*eColorEffet, 0.8*eColorEffet, 1.0);\n        return;\n    }\n    \n    else if (distance < 150.0){\n        pixColor = vec4 (0.6*dColorEffect*sE, 0.75*dColorEffect*sE, 1.0*dColorEffect*sE, 1.0);\t\n        return;\n    }\n    \n    else if (distance2 < 130.0 && y > fx) {\t\n        pixColor = vec4 (0.6*dColorEffect*sE, 0.75*dColorEffect*sE, 1.0*dColorEffect*sE, 1.0);\n        return;\n    }\n    \n    else {\n        pixColor = vec4 (0.0, 0.0+0.2*dColorEffect, 0.0+0.3*dColorEffect, 1.0);\n        pixColor = (pixColor + 0.1*texture(iChannel0, vec2((x+iResolution.x/2.0-10.0) / iResolution.x/2.0, (y+iResolution.y/2.0) / iResolution.y/2.0)))/2.0;\n        return;\n    }\n\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 180], [183, 183, 238, 238, 3007]], "test": "error"}
{"id": "4tSSDw", "name": "Trigollusion", "author": "AlphaRogue", "description": "How is the circle made of little circles drawn?", "tags": ["2d", "illusion", "sinus"], "likes": 2, "viewed": 127, "published": "Public", "date": "1443971645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI4 .7853981633974483\n#define PI8 .39269908169872415\n#define SQ2 1.41421356237309504\n#define BLUE vec4(.11, .15, .2, 1.)\n#define WHITE vec4(1., .98, .9, 1.)\n#define RED vec4(.6, .09, .08, 1.)\n\nvec4 aalias(float radius, float dist, vec4 bg, vec4 color, float ratio){\n    return mix(bg, color, smoothstep(radius, radius * ratio, dist));   \n}\n\nvoid mainImage(out vec4 pixColor, in vec2 pixCoord) {\n    vec2 pos = pixCoord.xy - iResolution.xy / 2.;\n    \n    vec2 radius = vec2(iResolution.y / 2.5, iResolution.y / 50.);\n    \n    float dist = length(pos);\n    \n    if (dist > radius.x + 2. + radius.y){\n        pixColor = BLUE;\n        return;\n    }\n    \n    float iTimeReg = iTime * 2.5;\n    \n    float cosTime = cos(iTimeReg);\n    float sinTime = sin(iTimeReg);\n    \n    float sqrt2 = (1. - SQ2 / 2.);\n    float sqrt4p = (sqrt(2. - SQ2) / 2.);\n    float sqrt4m = (1. - (sqrt(2. + SQ2) / 2.) );\n    \n    float timeLoops[6] = float [6](\n      sin(iTimeReg + PI4) - sqrt2 * sin(iTimeReg + PI4),\n      sin(iTimeReg - PI4) - sqrt2 * sin(iTimeReg - PI4),\n      sin(iTimeReg + PI8) - sqrt4m * sinTime,\n      sin(iTimeReg - PI8) - sqrt4m * sinTime,\n      sin(iTimeReg + 3. * PI8) - sqrt4m * cosTime,\n      sin(iTimeReg - 3. * PI8) + sqrt4m * cosTime\n    );\n\n    vec2 deltas[8] = vec2[8](\n      vec2(0. , cosTime),\n      vec2(sinTime, 0.),\n      vec2(timeLoops[0], timeLoops[0]),\n      vec2(timeLoops[1], -timeLoops[1]),\n      vec2(timeLoops[2], timeLoops[2] *  sqrt4p),\n      vec2(timeLoops[3], -timeLoops[3] * sqrt4p),\n      vec2(timeLoops[4] * sqrt4p, timeLoops[4]),\n      vec2(timeLoops[5] * sqrt4p, -timeLoops[5])\n    );\n    \n    for (int i = 0; i < 8; i++) {\n      float delta = length(pos - deltas[i] * radius.x);\n      if (delta < radius.y) {\n          pixColor = aalias(radius.y, delta, WHITE, RED, .8);\n          return;\n        }\n    }\n\n    pixColor = aalias(radius.x + radius.y + 2., dist, BLUE, WHITE, .98);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 273, 273, 347], [349, 349, 402, 402, 1918]], "test": "valid"}
{"id": "4tSSz3", "name": "Ray Marched Fractals", "author": "sanchitgarg", "description": "fractals", "tags": ["fractals"], "likes": 3, "viewed": 116, "published": "Public", "date": "1445287469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference : https://www.shadertoy.com/view/Xds3zN\n\n#define MAX_DIS 100.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n\n//Comment SHADOW_SCALE to remove shadow\n//#define SHADOW_SCALE 30.0\n\n//----------------------Color Modes----------------------\n//Uncomment the coloring mode you want to view and comment the rest\n\n//#define DEPTH_COLOR\n//#define STEP_COUNT_COLOR\n//#define NORMAL_COLOR\n#define LAMBERT_COLOR\n//-------------------------------------------------------\n\n\n\n//------------------Ray Casting Modes--------------------\n//#define NAIVE_RAY_CAST\n#define SPHERICAL_RAY_CAST\n//-------------------------------------------------------\n\n\n\n//-------------------------------------------------------\n//\t\t\t\t\tDistance Estimators\n//-------------------------------------------------------\n\n\n//--------Distance functions for various objects---------\nfloat sdPlane (vec3 p, float y)\n{\n\treturn p.y - y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//for fractals\nfloat sdCross( in vec3 p)\n{\n    float v = 1.5;\n\tfloat da = sdBox(p.xyz,vec3(1000.0, v, v));\n  \tfloat db = sdBox(p.yzx,vec3(v, 1000.0, v));\n\tfloat dc = sdBox(p.zxy,vec3(v, v, 1000.0));\n  \treturn min(da,min(db,dc));\n}\n\n//--------------------CSG Operations---------------------\nfloat opDifference( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat opIntersect( float d1, float d2 )\n{\n    return max(d2,d1);\n}\n\nfloat opBlend(float a, float b, float blendRadius) {\n    float c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return ((c) * a + (1.0-c) * b) - blendRadius * c * (1.0 - c);\n}\n\n//Function to create the actual scene\nfloat disEstimator(vec3 pt)\n{\n    float dis = sdBox(pt, vec3(1.0));\n   \tfloat s = 0.5;\n    \n    for( int m=0; m<3; m++ )\n   \t{\n        vec3 a = mod( pt*s, 2.0 )-1.0;\n      \ts *= 5.0;\n\t\tvec3 r = 5.0 - 5.0*abs(a);\n        float c = sdCross(r)/s;\n      \tdis = max(dis,-c);\n   \t}\n\n    return dis;\n}\n\n\n\n//-------------------------------------------------------\n//\t\t\t\tColor calculation functions\n//-------------------------------------------------------\n\n//Function to calculate the normal\nvec3 getNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    disEstimator(pos+eps.xyy) - disEstimator(pos-eps.xyy),\n\t    disEstimator(pos+eps.yxy) - disEstimator(pos-eps.yxy),\n\t    disEstimator(pos+eps.yyx) - disEstimator(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n#ifdef SHADOW_SCALE\n//Function to calculate the soft shadow\nfloat getSoftShadow(vec3 pt, vec3 lightPos)\n{\n    float t = 2.0;\n    float minT = 2.0;\n    \n    vec3 rd = normalize(lightPos - pt);\n    vec3 ro = pt;\n    float maxT = (lightPos.x - ro.x) / rd.x;\n\tfloat shadow = 1.0;\n    \n\tfor(int i=0; i<MAX_STEPS; ++i )\n    {\n\t\tpt = ro + t * rd;\n\n        float dt = disEstimator(pt);\n        \n        if(dt < EPSILON)\n        {\n\t\t\treturn 0.0;\n        }\n\n        t += dt;\n        shadow = min(shadow, SHADOW_SCALE * (dt / t));\t\t\n        \n        if(t > maxT)\n        {\n          \treturn shadow;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n#endif\n\n//Function to calculate lambert color\nvec3 getLambertColor(vec3 pt, vec3 ro)\n{\n \tvec3 lightPos = vec3(5.0,5.0,0.0);\n    vec3 lightCol = vec3(1.0);\n    vec3 lightVector = normalize(lightPos - pt);\n    \n    vec3 normal = getNormal(pt);\n    \n    #ifdef SHADOW_SCALE\n\t\tfloat shadow = getSoftShadow(pt, lightPos);\n\t\treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * (shadow) + 0.01;\n    #else\n\t    return clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol + 0.01;\n    #endif\n}\n\n//Function to calculate color based on number of steps\nvec3 getStepCountColor(vec2 steps)\n{\n    float t = (steps.y - steps.x) / steps.y;\n\tvec2 c = vec2(t, 0.0);\n    return vec3(1.0-t, t, 0);\n}\n\n//Function to calculate colors\nvec3 colorCalculation(vec3 pt, vec2 dis, vec3 ro, vec2 steps)\n{\n    #ifdef DEPTH_COLOR\n\t\treturn vec3(abs((dis.y - dis.x) / dis.y));\n    #endif\n    \n    #ifdef STEP_COUNT_COLOR\n\t\treturn getStepCountColor(steps);\n\t#endif\n    \n    #ifdef NORMAL_COLOR\n        return abs(getNormal(pt));\n\t#endif\n    \n    #ifdef LAMBERT_COLOR\n        return getLambertColor(pt, ro);\n\t#endif\n    \n\treturn vec3(0.0);\n}\n\n//-------------------------------------------------------\n//\t\t\t\tRay Cast Functions\n//-------------------------------------------------------\n\nvec3 naiveRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n    float i = 0.0;\n    int maxSteps = 500;\n\tfor(float t = 0.00; t < MAX_DIS; t+=0.01)\n\t{\n        ++i;\n        pt = ro + rd * t;\n        \n        float dis = disEstimator(pt);\n        \n     \tif(dis < EPSILON)\n        {\n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(i, maxSteps));\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\nvec3 sphericalRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n   \t\n//    float dt = disEstimator(pt);\n\tfloat t = 0.0;\n    \n    for(int i = 1; i<MAX_STEPS; i++)\n\t{\n        pt = ro + t * rd;\n        \n        float dt = disEstimator(pt);\n        \n     \tif(dt < EPSILON)\n        {   \n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(float(i), MAX_STEPS));\n        }\n        \n\t\tt += dt;\n        \n        if(t > MAX_DIS)\n  \t    {\n         \treturn vec3(0.0);\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\n\n//-------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    #ifdef NAIVE_RAY_CAST\n\t    return naiveRayCast(ro, rd);\n    #else \n        return sphericalRayCast(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[788, 846, 879, 879, 898], [900, 900, 935, 935, 961], [963, 963, 994, 994, 1090], [1092, 1092, 1125, 1125, 1178], [1180, 1180, 1223, 1223, 1283], [1285, 1300, 1327, 1327, 1515], [1517, 1575, 1617, 1617, 1643], [1645, 1645, 1682, 1682, 1711], [1713, 1713, 1754, 1754, 1779], [1781, 1781, 1833, 1833, 1960], [1962, 2000, 2029, 2029, 2294], [2449, 2484, 2515, 2515, 2777], [3434, 3472, 3512, 3512, 3919], [3921, 3976, 4012, 4012, 4113], [4115, 4146, 4209, 4209, 4540], [4684, 4684, 4727, 4727, 5087], [5089, 5089, 5136, 5136, 5604], [5666, 5666, 5703, 5703, 5828], [5830, 5830, 5880, 5978, 6167], [6169, 6169, 6224, 6322, 6986]], "test": "valid"}
{"id": "4tSSzV", "name": "Robots on Drugs", "author": "rohtie", "description": "Please do not give drugs to robots.", "tags": ["robot", "trippy", "drugs"], "likes": 3, "viewed": 207, "published": "Public", "date": "1445106473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 col, in vec2 p ) {\n\tp /= iResolution.xy;\n    \n    vec2 q = p;\n    \n    float r = length(p - 0.5);\n    r = smoothstep(0.23, 0.25, r);\n    r = max(r, smoothstep(0.49, 0.51, p.y + sin(p.x * iTime * 50.0)));  \n    r = max(r, smoothstep(0.39, 0.41, p.y));\n    \n    float a = p.x * 23.0 + iTime * 7.0;\n    p *= mat2(cos(a), -sin(a), \n              sin(a), cos(a));\n    \n    r = max(r, smoothstep(0.49, 0.51, p.y));\n    \n    col.rgb = vec3(0.1) - r + vec3(1.0 - p.y, p.x, p.y)\n        \t  + smoothstep(0.52, 0.51, length(q - vec2(0.5, 0.2))) * q.y * 1.5\n        \t  - smoothstep(0.05, 0.04, length(q - vec2(0.25, 0.52)))\n        \t  + smoothstep(0.045, 0.01, length(q - vec2(0.25, 0.52)))\n        \t  - smoothstep(0.05, 0.04, length(q - vec2(0.75, 0.52)))\n        \t  + smoothstep(0.045, 0.01, length(q - vec2(0.75, 0.52)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSSzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 839]], "test": "valid"}
{"id": "4tSXzd", "name": "Chroma Circles ", "author": "StanRee", "description": "Fun little circle drawing shader. ", "tags": ["2d"], "likes": 2, "viewed": 233, "published": "Public", "date": "1445766827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat t = iTime * .5 ; \n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= 16./9.;\n    uv.x -= 16./9./4.;\n    float l = 0.; \n    vec3 col; \n    float size = 10.; \n    for(int x = 0; x < 20; x++)\n    {\n        for(int y = 0; y < 20; y++)\n        {\n            float radius = 1./size*(sin(t+float(x)*0.)+1.)*.5*.05+.1;\n            float width = .0051*(sin(t+1.)*.5)+.01;\n            vec2 pos = vec2(float(x)/size+(sin(t+float(x))+.1)*.5, float(y)/size +(cos(t+float(y)+1.)*.5));\n            \n            // pos = pos * rotate2d(t); \n            pos.x += -.5; \n            \n            float d = length(pos - uv);    \n            float var1 = uv.x + uv.y;\n            var1 = pos.x - uv.x + pos.y - uv.y;    \n            col = vec3(sin(var1+t)+1., cos(var1+t)+1., cos(var1+t+3.14159));     \n            l += smoothstep(radius-width, radius, d) - smoothstep(radius, radius+width, d);\n            col = vec3(sin(var1+t)+1., cos(var1+t)+1., cos(var1+t+3.14159)) * l;     \n        }  \n    }\n    \n\tfragColor = vec4(col.x, col.y, col.z, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 88], [90, 90, 147, 147, 1189]], "test": "valid"}
{"id": "ll2SRy", "name": "Transparent Cube Field", "author": "Shane", "description": "Some simple code to produce a relatively cheap, transparent cube field.", "tags": ["transparency", "cube", "volumetric", "field"], "likes": 194, "viewed": 14207, "published": "Public API", "date": "1444747319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Transparent Cube Field\n    ----------------------\n\t\n\tObviously, this isn't what I'd consider genuine transparency, because there's no\n\tray bending, and so forth. However, it attempts to give that feel whilst maintaining \n\tframerate. I've tried to keep things simple and keep the code to a minimum. It needs \n\tsome God rays, but that'd just add to the complexity.\n\n\tThe inspiration to do this came from a discussion with Fabrice Neyret, after viewing\n\this various cube examples. He's a pretty clever guy, so he'll probably know how to do \n\tthis ten times faster with ten times more efficiency. :)\n\n\tIt doesn't look much like it, but Duke's port of Las's \"Cloudy Spikeball\" also provided \n\tinspiration.\n\n\tBy the way, I deliberately made it blurry, and added more jitter than necessary in the\n\tpursuit of demo art. :) However, you can tweak the figures and dull down the jitter\tto \n\tproduce a reasonably clean looking, transparent scene... of vacuum filled objects. :)\n\n\t// Related shaders:\n\n\tCrowded Cubes 2 - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltBSRy\n\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/prod.php?which=56866\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n    // Here's a more interesting, cleaner version.\n    Transparent Lattice - Shane\n    https://www.shadertoy.com/view/Xd3SDs\n\t\n*/\n\n\n// Cheap vec3 to vec3 hash. Works well enough, but there are other ways.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\nfloat map(vec3 p){\n    \n\t\n\t// Creating the repeat cubes, with slightly convex faces. Standard,\n    // flat faced cubes don't capture the light quite as well.\n   \n    // Cube center offset, to create a bit of disorder, which breaks the\n    // space up a little.\n    vec3 o = hash33(floor(p))*0.2; \n    \n    // 3D space repetition.\n    p = fract(p + o)-.5; \n    \n    // A bit of roundness. Used to give the cube faces a touch of convexity.\n    float r = dot(p, p) - 0.21;\n    \n    // Max of abs(x), abs(y) and abs(z) minus a constant gives a cube.\n    // Adding a little bit of \"r,\" above, rounds off the surfaces a bit.\n    p = abs(p); \n\treturn max(max(p.x, p.y), p.z)*.95 + r*0.05 - 0.21;\n    \n    \n    // Alternative. Egg shapes... kind of.\n    //float perturb = sin(p.x*10.)*sin(p.y*10.)*sin(p.z*10.);\n\t//p += hash33(floor(p))*.2;\n\t//return length(fract(p)-.5)-0.25 + perturb*0.05;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n\t\n    // Unit direction ray. The last term is one of many ways to fish-lens the camera.\n    // For a regular view, set \"rd.z\" to something like \"0.5.\"\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5)); // Fish lens, for that 1337, but tryhardish, demo look. :)\n    \n    // There are a few ways to hide artifacts and inconsistencies. Making things go fast is one of them. :)\n    // Ray origin, scene color, and surface postion vector.\n    vec3 ro = vec3(0., 0., iTime*3.), col = vec3(0), sp;\n\t\n    // Swivel the unit ray to look around the scene.\n\tfloat cs = cos( iTime*0.375 ), si = sin( iTime*0.375 );    \n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    rd.xy = mat2(cs, si,-si, cs)*rd.xy;\n    \n    // Unit ray jitter is another way to hide artifacts. It can also trick the viewer into believing\n    // something hard core, like global illumination, is happening. :)\n    rd *= 0.985 + hash33(rd)*0.03;\n    \n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. I deliberately\n    // wanted some blur, so bumped it up slightly.\n    float thD = .035; // + smoothstep(-0.2, 0.2, sin(iTime*0.75 - 3.14159*0.4))*0.025;\n\t\n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(int i=0; i<56; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>15. || col.x>1. || t>10.) break;\n        \n        // Current ray postion. Slightly redundant here, but sometimes you may wish to reuse\n        // it during the accumulation stage.\n        sp = ro + rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point in the cube field.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. I interpolated aD on a whim (see below), because it seemed \n        // to look nicer.\n        //\n        // 1/.(1. + t*t*.25) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d)*15./16.)/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            // Smoothly interpolate the accumulated surface distance value, then apply some\n            // basic falloff (fog, if you prefer) using the camera to surface distance, \"t.\"\n            col += aD*aD*(3. - 2.*aD)/(1. + t*t*.25)*.2; \n            layers++; \n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit of \n        // knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.7, thD*1.5); \n        \n\t\t\t    \n\t}\n    \n    // I'm virtually positive \"col\" doesn't drop below zero, but just to be safe...\n    col = max(col, 0.);\n    \n    // Mixing the greytone color and some firey orange with a sinusoidal pattern that\n    // was completely made up on the spot.\n    col = mix(col, vec3(min(col.x*1.5, 1.), pow(col.x, 2.5), pow(col.x, 12.)), \n              dot(sin(rd.yzx*8. + sin(rd.zxy*8.)), vec3(.1666))+0.4);\n    \n    \n\t// Doing the same again, but this time mixing in some green. I might have gone overboard\n    // applying this step. Commenting it out probably looks more sophisticated.\n    col = mix(col, vec3(col.x*col.x*.85, col.x, col.x*col.x*.3), \n             dot(sin(rd.yzx*4. + sin(rd.zxy*4.)), vec3(.1666)) + .25);\n    \n\n\t// Presenting the color to the screen -- Note that there isn't any gamma correction. That\n    // was a style choice.\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n    \n     \n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2SRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1435, 1508, 1528, 1528, 1637], [1640, 1640, 1658, 1900, 2527], [2530, 2530, 2584, 2617, 6828]], "test": "valid"}
{"id": "ll2SWD", "name": "first attempt...", "author": "marzinp", "description": "My first shader... Comments welcome, lots of things I dont really understand!", "tags": ["webcam"], "likes": 11, "viewed": 1013, "published": "Public", "date": "1443893573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.z;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//----------------------------------------------------------------------\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\tvec2 opB( vec2 d1, vec2 d2 )\n{\n\treturn vec2(smin(d1.x,d2.x,.2),smin(d1.x,d2.x,.2));\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n  vec2 res=vec2(sdEllipsoid( pos+vec3(sin(iTime/3.0),1.7*cos(iTime/3.0),0.0), vec3(2.0+cos(iTime)/5.0, 2.0+sin(iTime/2.0)/5.0, .5)/4.0 ), 45.0 );\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.6*sin(iTime),cos(iTime/2.5),0.0), vec3(2.0+sin(iTime)/5.0, 2.0+cos(iTime/1.2)/5.0, .5)/4.0 ), 45.0 ));    \n  res=opB(res,vec2(sdEllipsoid( pos+vec3(.8*cos(iTime/3.0),1.7*sin(iTime/3.0),0.0), vec3(2.0+cos(iTime/3.0)/5.0, 2.0+sin(iTime/5.0)/5.0, .5)/4.0 ), 45.0 ));\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(.8*sin(iTime/3.0),.8*cos(iTime/3.0),0.0), vec3(2.0+sin(iTime/2.0)/5.0, 2.0+cos(iTime/2.0)/5.0, .5)/4.0 ), 45.0 ));\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.6*cos(iTime/2.0),sin(iTime/3.0),0.0), vec3(2.0+cos(iTime/3.0)/5.0, 2.0+sin(iTime/5.0)/5.0, .5)/4.0 ), 45.0 ));\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(sin(iTime/2.0),1.7*cos(iTime/3.0),0.0), vec3(2.0+sin(iTime/2.0)/5.0, 2.0+cos(iTime/2.0)/5.0, .5)/4.0 ), 45.0 )); \n  res=opU(res,vec2(sdPlane(pos), 1.5)); \n    return res;\n}  \nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax =20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.0002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\t  float m = res.y;\n    if( m>0.0)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        vec2 ballUv =(pos.xy+vec2(2.5,2.0))*.2;\n        // material        \n\t\tcol = texture(iChannel0, ballUv).rgb,pow(-pos.z/.5, 5.0);\t\n         if( m>0.1)\n         {           \n              float f = mod( floor(5.0*pos.y) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n         }\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\t    vec3  lig = normalize( vec3(5.0*sin(iTime/3.0), 5.0*cos(iTime/3.0), 3.5) );\n\t\t    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\t    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\t    vec3 brdf = vec3(0.0);\n        brdf += .5*dif*vec3(1.00,0.90,0.60);\n\t\t    brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n    }\n    else t /= 15.0;\n\tcol *= exp( -0.015*t*t );\n\n    // lights\n        vec3 lv = normalize(vec3(5.0*sin(iTime/3.0), 5.0*cos(iTime/3.0), 3.5)) - ro/3.5;\n        float ll = length( lv );\n        if( ll<t )\n        {\n        float dle = clamp( dot( rd, lv/ll), 0.0, 1.0 );\n\t\t\t  dle = (1.0-smoothstep( 0.0, 0.2*(0.7+0.3*.5), acos(dle)*ll ));\n        col += dle*6.0*.5*vec3(1.0,1.0,0.0)*dle*exp( -0.1*ll*ll );;\n        }\n\treturn vec3( clamp(col,0.0,1.0) );\n}  \n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = gl_FragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3(0.0,-6.0+6.0*cos(mo.y*PI),2.0+2.0*cos(mo.y*PI));\n\tvec3 ta = vec3( 0.0, -0.5, 0.0 );\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2SWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 441, 482, 482, 575], [576, 576, 601, 601, 616], [618, 618, 661, 661, 721], [798, 798, 828, 828, 861], [864, 864, 894, 894, 949], [1025, 1025, 1050, 1050, 2027], [2030, 2030, 2070, 2070, 2660], [2663, 2663, 2737, 2737, 2998], [3000, 3000, 3032, 3032, 3253], [3255, 3255, 3297, 3297, 3596], [3599, 3599, 3638, 3638, 5716], [5720, 5720, 5772, 5772, 5949], [5952, 5952, 6009, 6009, 6561]], "test": "error"}
{"id": "llBSzG", "name": "basic mandelbrot set", "author": "MacSlow", "description": "Doing your own implementation of a mandelbrot shader is something I consider to be like a \"Hello, world!\" of shader-programming :) Thus I had to do it. It does 100 iterations per fragment and a very simple 4x4-grid super-sampling.", "tags": ["fractal", "mandelbrot", "zoom"], "likes": 3, "viewed": 275, "published": "Public", "date": "1444526665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// mandelbrot-set fragment-shader with 4x4-grid super-sampling, which steps\n// through z = z^2 + c, z = z^3 + c and z = z^4 + c switching every two seconds\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// 0 disbled, 1 enabled\n#define MSAA 0\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red = vec4 (1., .0, .0, 1.);\nconst vec4 green = vec4 (.0, 1., .0, 1.);\nconst vec4 blue = vec4 (.0, .0, 1., 1.);\nconst vec4 white = vec4 (1.);\nconst vec4 orange = vec4 (1., .4, .125, 1.);\nconst vec4 black = vec4 (.0, .0, .0, 1.);\nconst vec4 cyan = vec4 (.0, 1., 1., 1.);\nconst vec4 magenta = vec4 (1., .0, 1., 1.);\nconst vec4 yellow = vec4 (1., 1., .0, 1.);\n\nfloat deg2rad (in float degree)\n{\n    return degree * PI / 180.;\n}\n\nmat2 rot2dZ (in float angle)\n{\n    float rad = deg2rad (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 ( c, s, -s, c);\n}\n\nvec4 gradient (float v) {\n    float steps = 7.;\n    float step = 1. / steps;\n    vec4 col = black;\n\n    if (v >= .0 && v < step) {\n        col = mix (yellow, orange, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (orange, red, (v - step) * steps);\n    } else if (v >= 2.0 * step && v < 3.0 * step) {\n        col = mix (red, magenta, (v - 2.0 * step) * steps);\n    } else if (v >= 3.0 * step && v < 4.0 * step) {\n        col = mix (magenta, cyan, (v - 3.0 * step) * steps);\n    } else if (v >= 4.0 * step && v < 5.0 * step) {\n        col = mix (cyan, blue, (v - 4.0 * step) * steps);\n    } else if (v >= 5.0 * step && v < 6.0 * step) {\n        col = mix (blue, green, (v - 5.0 * step) * steps);\n    }\n\n    return col;\n}\n\nvec4 calc (vec2 c, int type)\n{\n    vec4 col = white;\n    vec2 z = vec2 (.0);\n    float lengthLimit = 5.;\n    float iter = .0;\n    const float maxIter = 100.;\n\n    for (float i = 0.; i < maxIter; i += 1.) {\n        // z = z^2 + c\n        if (type == 0) {\n            z = mat2 (z, -z.y, z.x) * z + c;\n        }\n\n        // z = z^3 + c\n        if (type == 1) {\n            float zr = z.x * z.x - z.y * z.y;\n            float zi = z.y * z.x + z.x * z.y;\n            z = vec2 (zr * z.x - zi * z.y,  zr * z.y + z.x * zi) + c;\n        }\n\n        // z = z^4 + c\n        if (type == 2) {\n            float zr = z.x * z.x - z.y * z.y;\n            float zi = z.y * z.x + z.x * z.y;\n            float zzr = zr * z.x - zi * z.y;\n            float zzi = zr * z.y + z.x * zi;\n            z = vec2 (zzr * z.x - zzi * z.y,  zzr * z.y + z.x * zzi) + c;\n        }\n        \n        if (length (z) > lengthLimit && iter == .0) {\n            iter = i;\n        }\n    }\n\n    return length (z) <= lengthLimit ? vec4 (0) : gradient (iter / maxIter);\n}\n\nvec4 mandel (vec2 c, vec2 size)\n{\n    vec2 msaa[16];\n    msaa[0]  = vec2 (.125, .125);\n    msaa[1]  = vec2 (.125, .375);\n    msaa[2]  = vec2 (.125, .625);\n    msaa[3]  = vec2 (.125, .875);\n    msaa[4]  = vec2 (.375, .125);\n    msaa[5]  = vec2 (.375, .375);\n    msaa[6]  = vec2 (.375, .625);\n    msaa[7]  = vec2 (.375, .875);\n    msaa[8]  = vec2 (.625, .125);\n    msaa[9]  = vec2 (.625, .375);\n    msaa[10] = vec2 (.625, .625);\n    msaa[11] = vec2 (.625, .875);\n    msaa[12] = vec2 (.875, .125);\n    msaa[13] = vec2 (.875, .375);\n    msaa[14] = vec2 (.875, .625);\n    msaa[15] = vec2 (.875, .875);\n\n    vec4 result = vec4 (.0);\n\n    #if MSAA\n    for (int i = 0; i < 16; ++i) {\n        result += calc (c + msaa[i] * size, int (mod (.5 * iTime, 3.)));\n    }\n\tresult /= 16.;\n    #else\n        result = calc (c, int (mod (.5 * iTime, 3.)));\n    #endif\n\n\treturn result;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p)\n{\n    vec2 res = iResolution.xy;\n    float t = iTime;\n    float s = 1.75 + sin (.5 * t);\n    p = p / res * vec2 (iResolution.x / iResolution.y, 1.);\n    p += vec2 (-1., -.5);\n    mat2 r = rot2dZ (90. * cos (.5 * t));\n    fragColor = mandel (r * s * p, s/res);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSzG.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1486, 1486, 1519, 1519, 1552], [1554, 1554, 1584, 1584, 1702], [1704, 1704, 1729, 1729, 2451], [2453, 2453, 2483, 2483, 3478], [3480, 3480, 3513, 3513, 4345], [4347, 4347, 4395, 4395, 4655]], "test": "valid"}
{"id": "llBXR3", "name": "[CIS565 2015F] ShaderHSQ", "author": "hsiqi", "description": "source:\nhttps://github.com/siqihuang/Project5-GLSL-Ray-Marcher/blob/master/raymarch.glsl\nReference:\nMorgan McGuire, Williams College. Numerical Methods for Ray Tracing Implicitly Defined Surfaces (2014)\nIÃ±igo QuÃ­lez. Raymarching Primitives (2013).", "tags": ["modeswitchfrom16"], "likes": 6, "viewed": 341, "published": "Public", "date": "1445310467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mode 5\n\nvec4 groundIntersection(in vec3 gPos,in vec3 rPos){\n    return vec4(0,1,0,rPos.y-gPos.y);\n}\n\nvec3 groundNormal(){\n    return vec3(0,1,0);\n}\n\nvec4 sphereIntersection(in vec3 sPos,in vec3 rPos,float radius){\n    vec3 dis=sPos-rPos;\n    vec4 m;\n    m.w=length(dis)-radius;\n    m.xyz=normalize(rPos-sPos);\n    return m;\n}\n\nvec3 sphereNormal(in vec3 sPos,in vec3 rPos){\n    return normalize(rPos-sPos);\n}\n\nvec4 cubeIntersection(in vec3 cPos,in vec3 rPos,float len){\n    vec3 dis=cPos-rPos;\n    float x=abs(dis.x),y=abs(dis.y),z=abs(dis.z);\n    vec4 m;\n    if(x>=y&&x>=z){\n        y=len/2.0*y/x;\n        z=len/2.0*z/x;\n        x=len/2.0;\n        m.xyz=-vec3(sign(dis.x),0.0,0.0);\n    }\n    else if(y>=x&&y>=z){\n        x=len/2.0*x/y;\n        z=len/2.0*z/y;\n        y=len/2.0;\n        m.xyz=-vec3(0.0,sign(dis.y),0.0);\n    }\n    else{\n        x=len/2.0*x/z;\n        y=len/2.0*y/z;\n        z=len/2.0;\n        m.xyz=-vec3(0.0,0.0,sign(dis.z));\n    }\n    m.w=length(dis)-length(vec3(x,y,z));\n    return m;\n}\n\nvec3 cubeNormal(in vec3 cPos,in vec3 rPos){\n    vec3 dir=rPos-cPos;\n    float x=abs(dir.x),y=abs(dir.y),z=abs(dir.z);\n    if(x>=y&&x>=z) return vec3(sign(dir.x),0.0,0.0);\n    else if(y>=x&&y>=z) return vec3(0.0,sign(dir.y),0.0);\n    else return vec3(0.0,0.0,sign(dir.z));\n}\n\nvec4 cylinderIntersection(in vec3 cPos,in vec3 rPos,float len,float radius){\n    vec3 dis=cPos-rPos;\n    float x=abs(dis.x),y=abs(dis.y),z=abs(dis.z);\n    float r=length(vec2(x,z));\n    vec4 m;\n    if(2.0*y/len>r/radius){\n        x=len/2.0*x/y;\n        z=len/2.0*z/y;\n        y=len/2.0;\n        m.xyz=-vec3(0.0,sign(dis.y),0.0);\n    }\n    else{\n        x=radius*x/r;\n        y=radius*y/r;\n        z=radius*z/r;\n        vec3 normal=vec3(dis.x,0.0,dis.z);\n        normal=normalize(normal);\n        m.xyz=-normal;\n    }\n    m.w=length(dis)-length(vec3(x,y,z));\n    return m;\n}\n\nvec3 cylinderNormal(in vec3 cPos,in vec3 rPos,float len,float radius){\n    vec3 dir=rPos-cPos;\n    float x=abs(dir.x),y=abs(dir.y),z=abs(dir.z);\n    float r=length(vec2(x,z));\n    if(2.0*y/len>r/radius){\n        return vec3(0.0,sign(dir.y),0.0);\n    }\n    else{\n        vec3 normal=vec3(dir.x,0.0,dir.z);\n        normal=normalize(normal);\n        return normal;\n    }\n}\n\nmat4 transform(in vec3 scale,in vec3 rotate,in vec3 translate){\n    mat4 ms,mx,my,mz,mt;\n    float PI=3.1415926;\n    float rx=rotate.x/180.0*PI;\n    float ry=rotate.y/180.0*PI;\n    float rz=rotate.z/180.0*PI;\n    ms=mat4(1);\n    ms[0].x=1.0/scale.x;\n    ms[1].y=1.0/scale.y;\n    ms[2].z=1.0/scale.z;\n    vec4 m00=vec4(cos(rx),sin(rx),0,0);\n    vec4 m01=vec4(-sin(rx),cos(rx),0,0);\n    vec4 m02=vec4(0,0,1,0);\n    vec4 m03=vec4(0,0,0,1);\n    vec4 m10=vec4(cos(ry),0,-sin(ry),0);\n    vec4 m11=vec4(0,1,0,0);\n    vec4 m12=vec4(sin(ry),0,cos(ry),0);\n    vec4 m13=vec4(0,0,0,1);\n    vec4 m20=vec4(1,0,0,0);\n    vec4 m21=vec4(0,cos(rz),sin(rz),0);\n    vec4 m22=vec4(0,-sin(rz),cos(rz),0);\n    vec4 m23=vec4(0,0,0,1);\n    mx[0]=m00;mx[1]=m01;mx[2]=m02;mx[3]=m03;\n    my[0]=m10;my[1]=m11;my[2]=m12;my[3]=m13;\n    mz[0]=m20;mz[1]=m21;mz[2]=m22;mz[3]=m23;\n    mt=mat4(1);\n    mt[3]=vec4(translate,1);\n    return mt*mz*my*mx*ms;\n    //return ms;\n}\n\nvec3 lightColor(in vec3 ro,in vec3 rd,in vec3 normal,in vec3 lPos,float t){\n    vec3 pos=ro+t*rd;\n    vec3 lDir=normalize(lPos-pos);\n    vec3 diff=vec3(1)*clamp(dot(normal,lDir),0.0,1.0);\n    vec3 ref=normalize(-lDir-2.0*normal*dot(-lDir,normal));\n    vec3 spec=vec3(1)*pow(max(0.0,dot(ref,-rd)),20.0);\n    return 0.8*diff+0.2*spec;\n    //return vec3(1,1,1)*clamp(dot(normal,lDir),0.0,1.0);\n}\n\nbool Union(vec4 m1,vec4 m2){\n    return m1.w<m2.w;\n}\n\nvec3 rayCastSmart(in vec3 ro,in vec3 rd){\n    float max=50.0;\n    float t=0.01;\n    float eplison=0.00001;\n    vec3 oPos0=vec3(1,1,1);\n    vec3 oPos1=vec3(0,0.3,0);\n    vec3 oPos2=vec3(0,0,0);\n    vec3 oPos3=vec3(1.2,0.8,-0.2);\n    float radius=0.4;\n    float len=0.6;\n    vec4 res,res1,res2,res3;\n    mat4 m[4],m0;\n    m[0]=transform(vec3(1,1,1),vec3(30,0,20),vec3(0));\n    m[1]=transform(vec3(1.0,1.0,1.0),vec3(0,0,0),vec3(0,0,0));\n    m[2]=transform(vec3(1.0,1.0,1.0),vec3(0,0,0),vec3(0,0,0));\n    m[3]=transform(vec3(1.0,1.0,1.0),vec3(-20,-30,-20),vec3(0,0,0));\n    vec3 o,d;\n    for(int i=0;i<1000;++i){\n        o=(m[0]*vec4(ro,0)).xyz;\n    \td=(m[0]*vec4(rd,1)).xyz;\n        res=cylinderIntersection(oPos0,o+t*d,len,radius);\n        o=(m[1]*vec4(ro,0)).xyz;\n    \td=(m[1]*vec4(rd,1)).xyz;\n        res1=sphereIntersection(oPos1,o+t*d,radius);\n        o=(m[2]*vec4(ro,0)).xyz;\n    \td=(m[2]*vec4(rd,1)).xyz;\n        res2=groundIntersection(oPos2,o+t*d);\n        o=(m[3]*vec4(ro,0)).xyz;\n    \td=(m[3]*vec4(rd,1)).xyz;\n        res3=cubeIntersection(oPos3,o+t*d,len);\n        if(Union(res,res1)){ \n            res=res;\n            m0=m[0];\n        }\n        else{\n            m0=m[1];\n            res=res1;\n        }\n        if(Union(res,res2)){\n            res=res;\n            //m0=m[2];\n        }\n        else{\n            res=res2;\n            m0=m[2];\n        }\n        if(Union(res,res3)){\n            res=res;\n            //m0=m[2];\n        }\n        else{\n            res=res3;\n            m0=m[3];\n        }\n        if(t>max||abs(res.w)<eplison) break;\n        t+=res.w;\n    }\n    if(res.w<eplison){\n        vec3 normal=res.xyz;\n        vec3 lPos=vec3(0,3,3);\n        lPos=(m0*vec4(lPos,0)).xyz;\n        vec3 color=lightColor(ro,rd,normal,lPos,t);\n        return color;\n        //return vec3(1);\n    }\n    else return vec3(0.8,0.9,1);\n}\n\nvec3 rayCastNaive(in vec3 ro,in vec3 rd){\n    float max=100.0;\n    float t=0.0;\n    float dt=0.01;\n    float eplison=0.01;\n    vec3 sPos=vec3(0,1,0);\n    float radius=0.2;\n    vec4 res=sphereIntersection(sPos,ro,radius);\n    for(int i=0;i<1000;++i){\n        if(t>max||res.w<eplison) break;\n       \tt+=dt;\n        res=sphereIntersection(sPos,ro+t*rd,radius);\n    }\n    if(res.w<eplison) return vec3(1);\n    else return vec3(0.8,0.9,1);\n}\n\nvec4 map( in vec3 pos )\n{\n   \tvec4 res=sphereIntersection(vec3(0.0,0.25,0.0),pos,0.25);\n    vec4 res1=cubeIntersection(vec3(0.5,0.25,0.6),pos,0.4);\n    vec4 res2=cylinderIntersection(vec3(-0.6,0.5,0.4),pos,0.8,0.3);\n    vec4 res3=groundIntersection(vec3(0,0,0),pos);\n    if(res.w>res1.w) res=res1;\n    if(res.w>res2.w) res=res2;\n    if(res.w>res3.w) res=res3;\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).w;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map(aopos).w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rayCastAO(in vec3 ro,in vec3 rd){\n    float max=50.0;\n    float t=0.01;\n    float eplison=0.00001;\n    vec4 res;\n    vec3 color;\n    for(int i=0;i<1000;++i){\n        res=map(ro+t*rd);\n        if(abs(res.w)<eplison||t>max) break;\n        t+=res.w;\n    }\n    if(t<max){\n    \t//float m = res.y;\n        float m=2.0;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.xyz;\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        color = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n        if( m<1.5 )\n        {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            color = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        brdf += 0.02;\n        color = color*brdf;\n\n        color = mix( color, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n\t    return vec3( clamp(color,0.0,1.0) );\n    }\n    return vec3(0.8,0.9,1);\n}\n\nvec3 rayCastDebug(in vec3 ro,in vec3 rd){\n    float max=20.0;\n    float t=0.01;\n    float eplison=0.00001;\n    vec4 res;\n    vec3 color;\n    for(int i=0;i<1000;++i){\n        res=map(ro+t*rd);\n        if(abs(res.w)<eplison||t>max) break;\n        t+=res.w;\n    }\n    return vec3(1)*t/max;\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat heightFun(float x,float z){\n    float h=noise(vec3(cos(x/1.2),sin(x/1.3)*cos(z/1.3),cos(z/1.4)));\n    return 2.0*h;\n}\n\nvec3 getNormalInHeightMap(in vec3 p ){\n    float eps=0.01;\n    vec3 n = vec3( heightFun(p.x-eps,p.z) - heightFun(p.x+eps,p.z),\n                         2.0*eps,\n                         heightFun(p.x,p.z-eps) - heightFun(p.x,p.z+eps) );\n    return normalize( n );\n}\n\nvec3 rayCastHeightMap(in vec3 ro,in vec3 rd){\n    float max=30.0;\n    float t=0.0;\n    float dt=0.01;\n    ro.y+=2.0;\n    for(int i=0;i<2000;++i){\n        vec3 pos=ro+t*rd;\n        if(pos.y<heightFun(pos.x,pos.z)){ \n            //return t/max*vec3(1);\n            vec3 normal=getNormalInHeightMap(ro+t*rd);\n            vec3 lightPos=vec3(2,3,4);\n            vec3 color=lightColor(ro,rd,normal,lightPos,t);\n            vec2 xz=vec2(pos.x,pos.z);\n            xz.x-=5.0*floor(xz.x/5.0);\n            xz.y-=5.0*floor(xz.y/5.0);\n            color = color*texture( iChannel1, xz/vec2(5,5) ).xyz;\n            return color;\n        }\n        t+=dt;\n        if(t>max) break;\n    }\n    return vec3(0.8,0.9,1);\n}\n\nvec4 cubeFractalIntersection(in vec3 cPos,in vec3 rPos,float len,int level){\n    float half_len=len/2.0;\n    float Len=len;\n    vec3 pos=cPos;\n    if(rPos.x>cPos.x+half_len||rPos.x<cPos.x-half_len) return vec4(0);\n    if(rPos.y>cPos.y+half_len||rPos.y<cPos.y-half_len) return vec4(0);\n    if(rPos.z>cPos.z+half_len||rPos.z<cPos.z-half_len) return vec4(0);\n    for(int l=0;l<2;++l){\n        float u=0.0,v=0.0,w=0.0;\n        if(rPos.x<pos.x+Len/6.0&&rPos.x>pos.x-Len/6.0) u=0.0;\n        else if(rPos.x>=pos.x+Len/6.0) u=1.0;\n        else u=-1.0;\n    \tif(rPos.y<pos.y+Len/6.0&&rPos.y>pos.y-Len/6.0) v=0.0;\n        else if(rPos.y>=pos.y+Len/6.0) v=1.0;\n        else v=-1.0;\n        if(rPos.z<pos.z+Len/6.0&&rPos.z>pos.z-Len/6.0) w=0.0;\n        else if(rPos.z>=pos.z+Len/6.0) w=1.0;\n        else w=-1.0;\n        float sum=abs(u)+abs(v)+abs(w);\n        if(sum<=1.0) return vec4(0);\n        Len/=3.0;\n        pos.x+=Len*u;\n        pos.y+=Len*v;\n        pos.z+=Len*w;\n    }\n    vec4 m;\n    m.xyz=pos;\n    m.w=Len;\n    return m;\n    //vec4 m=cubeIntersection(pos,rPos,Len);\n    //m.w=1.0;\n    //return m;\n    //return vec4(1);\n}\n\nvec3 rayCastFractal(in vec3 ro,in vec3 rd){\n    float max=50.0;\n    float t=0.0;\n    float dt=0.01;\n    float eplison=0.00001;\n    int level=3;\n    float len=1.0;\n    vec4 res;\n    for(int i=0;i<1000;++i){\n        res=cubeFractalIntersection(vec3(0),ro+t*rd,len,3);\n        //if(t>max) break;\n        if(t>max||res.w!=0.0) break;\n        t+=dt;\n    }\n    vec4 m=res;\n    if(m.w!=0.0){\n        t=0.0;\n        vec3 o=m.xyz;\n        for(int i=0;i<1000;++i){\n            res=cubeIntersection(o,ro+t*rd,m.w);\n \t       \tif(t>max||abs(res.w)<eplison) break;\n    \t    t+=res.w;\n    \t}\n        if(res.w<eplison){\n        \tvec3 normal=res.xyz;\n\t        vec3 lPos=vec3(0,3,3);\n        \tvec3 color=lightColor(ro,rd,normal,lPos,t);\n\t        return color;\n\t    }\n    }\n    return vec3(0.8,0.9,1);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    // TODO\n    #if mode==1\n    \tvec3 res=rayCastSmart(ro,rd);\n    #endif\n    #if mode==2\n    \tvec3 res=rayCastNaive(ro,rd);\n    #endif\n    #if mode==3\n    \tvec3 res=rayCastHeightMap(ro,rd);\n    #endif\n    #if mode==4\n    \tvec3 res=rayCastFractal(ro,rd);\n    #endif\n    #if mode==5\n    \tvec3 res=rayCastAO(ro,rd);\n    #endif\n    #if mode==6\n    \tvec3 res=rayCastDebug(ro,rd);\n    #endif\n    return res;  // camera ray direction debug view\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n    //ro=vec3(0,10,0);\n    //ta=vec3(1,0,0);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 67, 67, 107], [109, 109, 129, 129, 155], [157, 157, 221, 221, 333], [335, 335, 380, 380, 415], [417, 417, 476, 476, 1013], [1015, 1015, 1058, 1058, 1288], [1290, 1290, 1366, 1366, 1863], [1865, 1865, 1935, 1935, 2234], [2236, 2236, 2299, 2299, 3172], [3174, 3174, 3249, 3249, 3566], [3568, 3568, 3596, 3596, 3620], [3622, 3622, 3663, 3663, 5465], [5467, 5467, 5508, 5508, 5903], [5905, 5905, 5930, 5930, 6282], [6284, 6284, 6358, 6358, 6628], [6630, 6630, 6672, 6672, 6969], [6971, 6971, 7009, 7009, 8823], [8825, 8825, 8866, 8866, 9113], [9115, 9115, 9138, 9138, 9174], [9176, 9176, 9202, 9202, 9571], [9573, 9573, 9606, 9606, 9696], [9698, 9698, 9736, 9736, 9963], [9965, 9965, 10010, 10010, 10664], [10666, 10666, 10742, 10742, 11785], [11787, 11787, 11830, 11830, 12571], [12573, 12573, 12610, 12622, 13051], [13053, 13053, 13103, 13201, 13390], [13392, 13392, 13447, 13545, 14253]], "test": "error"}
{"id": "llBXRV", "name": "Colour experiment", "author": "ray10k", "description": "Just some early experiment with shaders in general, made to see if I properly understand the basics.\n", "tags": ["colour"], "likes": 0, "viewed": 131, "published": "Public", "date": "1444942094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave(float x)\n{\n    return 0.5+0.5*sin(x*2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(wave(uv.x+iTime*2.),wave((uv.y+iTime*0.25)),wave(uv.x*uv.y),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 54], [56, 56, 113, 113, 241]], "test": "valid"}
{"id": "llBXzc", "name": "Circle_PF", "author": "pfeodrippe", "description": "Simple circle", "tags": ["circle"], "likes": 1, "viewed": 967, "published": "Public API", "date": "1445394541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= vec2(0.5, 0.5);\n    uv.y *= 9./16.;\n   \n    float mult = 1.;\n    float timeInc = 0.1;\n    \n    uv.x += sin(iTime*0.1)*sin(iTime*1.2)*sin(iTime*1.2)*0.2;\n    uv.y -= sin(iTime*1.2)*sin(iTime)*sin(iTime*1.2)*0.1;\n    \n    float o = dot(uv,uv);\n    \n    if(o < (0.01*sin(iTime*(2.))+0.04)) {\n        fragColor = vec4(0.42, 0.2, 0.4,1.0);\n        if(o < (0.012*sin(iTime*(4.))+0.016)) {\n        \tfragColor = vec4(0.3, 0.3, 0.4,1.0);\n    \t} \n        if(o < (0.008*sin(iTime*(4.+timeInc*1.)+mult*1.)+0.011)) {\n        \tfragColor = vec4(0.3, 0.7, 0.4,1.0);\n    \t} \n        if(o < (0.004*sin(iTime*(4.+timeInc*2.)+mult*2.)+0.006)) {\n        \tfragColor = vec4(0.1, 0.7, 0.7,1.0);\n    \t} \n        if(o < (0.0005*sin(iTime*(4.+timeInc*3.)+mult*3.)+0.001)) {\n            fragColor = vec4(0.3, 0.4, 0.7,1.0);\n        }\n    }\n\telse\n        fragColor = vec4(vec2(0.3,0.2),0.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 983]], "test": "valid"}
{"id": "lljSDm", "name": "trees and houses", "author": "mattz", "description": "Trying to play around with composition and color a bit.", "tags": ["trees", "geometric", "houses", "pinksky"], "likes": 8, "viewed": 297, "published": "Public", "date": "1444416972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Just fooling around after looking at artwork on http://www.89a.co.uk/\n//\n// Many things borrowed from iq below: distance functions, raymarching, etc.\n// Also borrowed Dave_Hoskins' noise function to randomize house locations.\n\nconst int rayiter = 60;\nconst float maxd = 40.0;\nvec3 L = normalize(vec3(-1.1, 0.6, 2.0));\nconst float precis = 0.005;\n\n#define SKY_COLOR 0.0\n#define GROUND_COLOR 1.0\n#define TREE_COLOR 2.0\n#define TRUNK_COLOR 3.0\n#define HOUSE_COLOR 4.0\n#define ROOF_COLOR 5.0\n\nvec3 color(float t) {\n\n    if (t == SKY_COLOR) {\n        return vec3(1.0, 0.8, 0.7);\n    } else if (t == GROUND_COLOR) {\n        return vec3(0.5, 0.25, 0.3);\n    } else if (t == TREE_COLOR) {\n        return vec3(0.1, 0.3, 0.25);\n    } else if (t == TRUNK_COLOR) {\n        return vec3(0.15, 0.1, 0.1);\n    } else if (t == HOUSE_COLOR) {\n        return vec3(0.85, 0.5, 0.0);\n    } else {// if (t == ROOF_COLOR) {\n        return vec3(0.95, 0.75, 0.1);\n    } \n\n}\n\nvec2 opU(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdRoof(vec3 p, float s) {\n\n    p.y -= s;\n    float k = dot(vec2(abs(p.z), p.y), vec2(0.7071067811865475));\n    float l = -p.y-s;\n    float w = abs(p.x)-s;\n    return max(k, max(l, w));\n\n}\n\n/* Many distance functions adapted from \n   http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n*/\nfloat sdCube(vec3 p, float r) {    \n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0));    \n}\n\n\nfloat sdBox(in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),.0) +\n        length(max(d,.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec2 h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),.0) + length(max(d,.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdSquareCone( vec3 p, vec2 c) {\n    \n    p.xy = abs(p.xy);\n    return dot(vec2(max(p.x, p.y), p.z), c);\n    \n    \n}\n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\nmat3 rotZ(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\n/// From https://www.shadertoy.com/view/4djSRW\n\n// *** Use these for integer ranges, ie Value-Noise/Perlin functions.\n#define MOD3 vec3(.0631,.07369,.08787)\n#define MOD4 vec4(.0631,.07369,.08787, .09987)\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\nvec2 map(in vec3 pos) {\n\n    float p = 6.0;\n\n    vec2 rval = vec2(pos.y, GROUND_COLOR);\n    rval.x = max(rval.x, length(pos.xyz)-14.0);\n    \n    for (float dx=-0.0; dx<2.0; ++dx) {\n        for (float dz=-0.0; dz<2.0; ++dz) {\n\n            vec2 g = floor((pos.xz+0.5*p)/p) + vec2(dx, dz);\n            vec2 k = hash22(g+vec2(0.455));\n            vec3 q = pos;\n            vec2 r = p*g - 0.5*p;\n\n            if (length(r) < 12.0) { \n\n                q.xz -= p*(g - 0.5*k);\n                q.xz += vec2(0.3, 2.4);\n\n                rval = opU(rval, vec2(sdCube(q-vec3(0,1.0,0), 1.0), \n                                      HOUSE_COLOR));\n\n                rval = opU(rval, vec2(sdRoof(q-vec3(0,2.0,0), 1.1), \n                                      ROOF_COLOR));\n\n                rval = opU(rval, vec2(sdBox(q-vec3(0.7,2.2,0.25), vec3(0.2, 1.3, 0.2)), \n                                      HOUSE_COLOR));\n\n                vec2 s = vec2(sdSquareCone((q - vec3(-2.0, 5.0-(k.x+k.y), 1.5)) .xzy, \n                                           normalize(vec2(6.0, 1.0))), \n                              TREE_COLOR);\n                \n                s.x = max(s.x, -q.y+0.7);\n                \n                rval = opU(rval, s);\n\n                rval = opU(rval, vec2(sdBox(q - vec3(-2.0, 0.0, 1.5), vec3(0.15, 1.0, 0.15)), \n                                      TRUNK_COLOR));\n\n\n            }\n\n        }\n    }\n\n    return rval;\n\n}\n\n\nvec3 trace(vec3 ro, vec3 rd) {\n\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ ) {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;\n    }\n\n    if (t > maxd) { m = -1.0; }\n\n    return vec3(t, m, h);\n\n}\n\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.05, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\n\n\nvec3 shade(vec3 ro, vec3 rd) {\n\n    vec3 tm = trace(ro, rd);\n    if (tm.y < 0.0) { return color(0.0); }\n\n    vec3 pos = ro+tm.x*rd;\n    vec3 n = calcNormal(pos);\n\n    float nDotL = clamp(dot(n,L), 0.0, 1.0);\n\n    vec3 direct = color(tm.y);\n\n    vec3 tm2 = trace(pos+precis*n, L);\n\n    const float amb = 0.2;\n    const float diff = 1.0-amb;\n\n    if (abs(tm2.z) < 3.0*precis) {        \n        direct *= amb;\n    } else {\n        direct *= nDotL*diff + amb;\n    }\n\n    return direct;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const float yscl = 720.0;\n    const float f = 40.0;\n\n    vec3 pos = vec3(0.0, 0.0, 14.5);\n    vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 rz = normalize(tgt - pos);\n    vec3 rx = normalize(cross(rz,up));\n    vec3 ry = cross(rx,rz);\n\n    float thetax = -0.5;\n    float thetay = 0.4;\n\n    if (iMouse.y > 10.0 || iMouse.x > 10.0) { \n        thetax += (iMouse.y - 0.5*iResolution.y) *  3.0/iResolution.y; \n        thetay += (iMouse.x - 0.5*iResolution.x) * -1.8/iResolution.x; \n    } else {\n        thetay -= 0.1*iTime;\n    }\n\n    mat3 Rx = rotX(thetax);    \n    mat3 Ry = rotY(thetay);\n    mat3 R = Ry*Rx;\n\n    L = R*L;    \n\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * yscl / iResolution.y;\n\n    vec3 rd = normalize(tgt - pos);\n    vec3 ro = pos + mat3(rx,ry,rz)*vec3(uv/f,0);\n\n    rd = R*rd;\n    ro = R*(ro-tgt) + tgt;\n\n    fragColor.xyz = pow(shade(ro, rd), vec3(0.45));\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 513, 513, 950], [952, 952, 984, 984, 1016], [1018, 1018, 1049, 1049, 1211], [1213, 1327, 1358, 1358, 1460], [1463, 1463, 1499, 1499, 1596], [1598, 1598, 1638, 1638, 1739], [1741, 1741, 1773, 1801, 1862], [1864, 1864, 1901, 1901, 1985], [1987, 1987, 2010, 2010, 2131], [2133, 2133, 2156, 2156, 2277], [2279, 2279, 2302, 2302, 2427], [2746, 2746, 2767, 2767, 2909], [2912, 2912, 2935, 2935, 4327], [4330, 4330, 4360, 4360, 4674], [4678, 4709, 4741, 4741, 4979], [4985, 4985, 5015, 5015, 5469], [5472, 5472, 5529, 5529, 6448]], "test": "valid"}
{"id": "lljSDy", "name": "quadtree 3", "author": "FabriceNeyret2", "description": "See also the tri-tree version [url]https://www.shadertoy.com/view/Mt2XDc[/url],\nbinary-tree version [ MtlyRH ]\nand video versions: [url]https://www.shadertoy.com/view/MtBSDV[/url] , [url]https://www.shadertoy.com/view/ltBSDV[/url]", "tags": ["short", "quadtree"], "likes": 161, "viewed": 7646, "published": "Public API", "date": "1446320397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o,  vec2 U )\n{\n    o -= o;\n    float r=.1, t=iTime, H = iResolution.y;\n    U /=  H;                              // object : disc(P,r)\n    vec2 P = .5+.5*vec2(cos(t),sin(t*.7)), fU;  \n    U*=.5; P*=.5;                         // unzoom for the whole domain falls within [0,1]^n\n    \n    o.b = .25;                            // backgroud = cold blue\n    \n    for (int i=0; i<7; i++) {             // to the infinity, and beyond ! :-)\n        fU = min(U,1.-U); if (min(fU.x,fU.y) < 3.*r/H) { o--; break; } // cell border\n    \tif (length(P-.5) - r > .7) break; // cell is out of the shape\n\n                // --- iterate to child cell\n        fU = step(.5,U);                  // select child\n        U = 2.*U - fU;                    // go to new local frame\n        P = 2.*P - fU;  r *= 2.;\n        \n        o += .13;                         // getting closer, getting hotter\n    }\n               \n\to.gb *= smoothstep(.9,1.,length(P-U)/r); // draw object\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* // for the record: a 282 chars version\n\nvoid mainImage( out vec4 o, vec2 U )\n{\n    float r=.1, t=iDate.w, H = iResolution.y;\n    U *=  .5/H;  \n    vec2 P = .25+.25*vec2(cos(t),sin(t*.7)), f;  \n     \n    o -= o; o.b = .25;  \n    \n    for (int i=0; i<7; i++) { \n        f = min(U,1.-U); if (min(f.x,f.y) < 3.*r/H)  o--; \n    \tif (length(P-.5) - r < .7)\n        \tf = step(.5,U), \n        \tU += U - f,          \n        \tP += P - f,  r += r,       \n        \to += .13;    \n    }\n               \n\to.gb *= step(r,length(P-U));  \n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 981]], "test": "valid"}
{"id": "lljSRK", "name": "Grey Area 1", "author": "cabbibo", "description": "Thanks to Grey Area for putting on a wonderful show :)", "tags": ["raytrace", "trinoise"], "likes": 2, "viewed": 128, "published": "Public", "date": "1445069955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\nconst float PI = 3.14159;\n\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n// q is point\n// n is normal\n// p is point on plane\nvec3 projOnPlane( vec3 q, vec3 p , vec3 n){\n    \n    vec3 v = q - dot(q - p, n) * n;\n    return v;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 0.3 + 10.0*mouse.x;\n\tcamPos = vec3(5.5*sin(an),0.,5.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    float s3 = sqrt( 3. );\n    pos /= 2.5;\n    pos += vec3( 1. , s3 /3., 0.5 );\n    \n    \n    vec3 a, b, c, o;\n    \n    a = vec3( 0. , 0., -10000. );\n    b = vec3(  -1000000. , 0. , 10000. );\n    c = vec3(  1000000. , 0. , 10000. );\n    vec2 res = vec2( udTriangle( pos , a ,b , c) , 100. ); \n    \n    float ang = PI/2.5;\n    mat3 rotX = xrotate( ang  - .4 * ( 1. + sin( iTime ) ) );\n    mat3 rotZ = zrotate( -.5 );\n\n    \n  \tpos =  rotX * pos;\n   \n    // using super thin cube as plane\n    vec3 size = vec3( 1.  , 1. , .01 );\n   // vec3 rot = vec3( iTime * .1 , iTime * .4 , -iTime * .3 );\n    vec3 rot = vec3( 0.,0.,0. );\n  \n    \n    //res = vec2( sdSphere( pos , .03 ) , 1.0 );\n    \n    //float s3 = sqrt( 3. );\n    \n    \n    \n    \n    a = vec3( 0. , 0. , 0. );\n    b = vec3( 0. , s3 , 0. );\n    c = vec3( -.5 , s3 / 2. , 0. );\n    \n    o = vec3( .05 , -0.05 , 0. );\n    \n    \n     res = opU( res , vec2( udTriangle( pos , a-o ,b-o , c-o) , 1. ));\n    \n    o = vec3( -.0 , -0.1 , 0. );\n    a = vec3( 0. , 0. , 0. );\n    b = vec3( 1. , s3 , 0. );\n    c = vec3( 0. , s3 , 0. );\n    res = opU( res , vec2( udTriangle( pos , a-o ,b-o , c-o) , 2. ));\n    \n    \n    o = vec3( -.05 , -0.05 , 0. );\n    a = vec3( 0. , 0. , 0. );\n    b = vec3( 1.5 , s3 / 2. , 0. );\n    c = vec3( 1. , s3 , 0. );\n    res = opU( res , vec2( udTriangle( pos , a-o ,b-o , c-o) , 3. ));\n    \n    o = vec3( -.1 , 0.02 , 0. );\n    a = vec3( 0. , 0. , 0. );\n    b = vec3( 2. ,0. , 0. );\n    c = vec3( 1.5 , s3 /2. , 0. );\n    res = opU( res , vec2( udTriangle( pos , a-o ,b-o , c-o) , 4. ));\n    \n    \n  \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n#define STEPS 1\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float dVal = dot( rd , n );\n    float lum = 1.;\n    float step = 0.;\n    float val = 0.;\n    \n    vec3 col = vec3( 0. );\n    float broken = 0.;\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .036 * abs( dVal ) * float( i );\n        \n        val += fpn( p * 20.2  );\n        \n        //val += fpn( p * 50.2  );\n        \n        //val += fpn( p * 200.2  );\n    \tval *= triNoise3D( p * .2 , .4 );\n       // val += triNoise3D( p * .03 , .1 );\n        \n        float v =  pow(1.5-.3 * length( p - vec3( -2. , -.75 , -.5 )),2.);\n        val *= 5. * v;\n        val = pow( val , 2. );\n        col += vec3( val ) / float( STEPS );///hsv( val , 1. , 1. ) * float( i ) / float( STEPS );\n        step = float(i);\n        \n        // float blend = clamp(  ( val - .4 ) * 20.  , 0. , 1. );\n    \n\n       // if( val > .4 ){ broken = 1.; break; }\n        \n       \n    }\n    \n   // float blend = clamp(  val + 1.4  , 0. , 1. );\n    \n    col *= 1. / float( STEPS );\n\t//col = hsv( val * .1 , 1. , 1. ) * val * .1;\n   \n    return col;\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    mat3 basis = mat3(\n     \n        1. , 0. , 0. ,\n        0. , 1. , 0. ,\n        0. , 0. , 1.\n       \n    );\n        \n   \n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        \n        if( res.y > 10. ){\n            col = vec3( .01 );\n        }\n        \n        if( res.y < 10. ){\n            \n            vec3 c = hsv( res.y / 10. + .5 , 1. , 1. );\n        \tvec3 depthColor = fogCube( pos , rd , norm  );\n        \tcol += c* depthColor;//lum  * vec3( 1. , .6 , 0.2);\n            //col += c * .1;\n        }\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 373, 396, 396, 614], [617, 617, 636, 636, 699], [701, 701, 738, 738, 870], [873, 925, 968, 968, 1025], [1027, 1079, 1101, 1101, 1126], [1127, 1127, 1148, 1148, 1228], [1264, 1316, 1359, 1359, 1662], [1664, 1664, 1691, 1691, 1754], [1759, 1759, 1790, 1790, 1828], [1831, 1831, 1876, 1876, 1916], [1919, 1919, 1954, 1954, 1978], [1980, 1980, 2005, 2005, 2024], [2025, 2025, 2077, 2077, 2584], [2586, 2617, 2681, 2681, 2859], [2861, 2861, 2942, 2942, 3055], [3057, 3130, 3153, 3153, 3259], [3261, 3261, 3284, 3284, 3390], [3392, 3392, 3415, 3415, 3524], [3527, 3527, 3553, 3553, 3622], [3624, 3624, 3686, 3686, 3780], [3784, 3878, 3907, 3907, 3950], [3952, 4036, 4057, 4057, 5661], [5665, 5665, 5713, 5713, 6180], [6199, 6199, 6242, 6242, 7292], [7294, 7407, 7438, 7438, 7664], [7668, 7668, 7725, 7725, 8962]], "test": "error"}
{"id": "lljSRV", "name": "Smooth Floor", "author": "anastadunbar", "description": "Smooth math.floor();", "tags": ["math", "floor", "steps", "smooth", "power", "step", "formula", "ceil"], "likes": 11, "viewed": 233, "published": "Public", "date": "1445130255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smooth_floor(float x, float c) {\n    float a = fract(x);\n    float b = floor(x);\n    return ((pow(a,c)-pow(1.-a,c))/2.)+b;\n}\n\nfloat smooth_ceil(float x, float c) {\n    float a = fract(x);\n    float b = ceil(x);\n    return ((pow(a,c)-pow(1.-a,c))/2.)+b;\n}\n\nfloat smooth_step(float a, float b, float c) {\n    return clamp(1.-((a-b)*c),0.,1.);\n}\n\nfloat clamps(float x) {\n    return clamp(x,0.,1.);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    \n    float size = 5.; //How many to see\n    float sharpness = (sin(time*2.)*8.)+11.; //Animate floor sharpness\n    float formula = smooth_floor(uv.x*size,sharpness)/size; //Use the smooth_floor\n    float draw1 = formula; //Copy\n    float line_s = 30.; //Line sharpness\n    draw1 = clamps((smooth_step(uv.y+(1./line_s),draw1,line_s/2.)-smooth_step(uv.y+(1./line_s),draw1,line_s))*2.); //Use copy and draw graph\n\tfragColor = vec4(draw1+(hsl2rgb(vec3(formula,.6,0.3))-.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 130], [132, 132, 169, 169, 260], [262, 262, 308, 308, 348], [350, 350, 373, 373, 402], [404, 404, 431, 431, 574], [576, 576, 633, 633, 1180]], "test": "valid"}
{"id": "lljSWy", "name": "plasma snakes 1", "author": "FabriceNeyret2", "description": ".", "tags": ["2d"], "likes": 6, "viewed": 905, "published": "Public API", "date": "1446287658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P(t)   vec2( 1.7*cos(t)+.5*sin(-2.7*t), .8*sin(1.2*t)+.5*cos(3.2*t) ) /1.5\n\n#define draw(t,c)  o += smoothstep(.1*c, c-c, vec4(length(P((t))-U)))\n\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n\tvec2 R = iResolution.xy;  \n    U = (2.*U -R ) / R.y;\n    \n    for (float dt=0.; dt<3.; dt+= .1) {\n        \n        float t = dt+iTime;\n        \n        draw( t,       vec4(1,2,3,0));\n        draw( t-1234., vec4(3,2,1,0));        \n     // draw( t+1234., vec4(2,3,1,0));        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 195, 195, 500]], "test": "valid"}
{"id": "lljXDW", "name": "Metaballs for beginner", "author": "denosya", "description": "Newbie shader ! Blob is computed with 1/d². Shadows are computed while raymarching through the blob field.", "tags": ["metaballs", "beginner"], "likes": 10, "viewed": 486, "published": "Public", "date": "1443882808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float zNear = 1.0;\nconst float zFar  = 400.0;\nconst float SHININESS = 20.0;\n\nconst float NBSOURCES = 9.0;\n\n\nvec3 getSource(float i) {\n    \n    return vec3(8.0-0.7*(i*sqrt(i)), -2.0+0.8*mod(i+1.0,4.0), 40) \n           \t\t + vec3(mod(i,2.0)*sin(iTime*mod(i,5.0)*0.3)*3.0,\n                        mod(i,7.0)*sin(iTime*mod(i,3.0)*0.2)*2.0, 0);    \n}\n\n\nfloat getFieldIntensity(in vec3 m, out vec3 normal) {\n    \n    normal = vec3(0,0,0);\n    float \tfieldIntensity = 0.0;\n    \n    for(float i=0.0; i<NBSOURCES; i+=1.0) {\n        \n        vec3 source = getSource(i);\n        float d = length(m - source);\n        \n        float intensity = 1.0 / (d*d);\n        vec3 localNormal = normalize(m - source);\n        \n        normal += localNormal * intensity;\n        fieldIntensity += intensity;\n    }\n    \n    normal = normalize(normal);\n    return fieldIntensity;\n}\n\nfloat getFieldIntensity(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {\n    \n    float\tmarchingDist = 30.0;\n    float \tnbIter \t\t = 0.0;\n\n \tm = origin;   \n    float ii=0.0;\n    \n  float lastestIntensity = -1000.;    \n    \n    for(float nbIter = 0.0; nbIter<200.0; nbIter += 1.0) {\n        \n    \tfloat fieldIntensity = getFieldIntensity(m, normal);\n        \n        ii+=fieldIntensity;\n        marchingDist += 0.4;\n      \tm = origin + ray * marchingDist;    \n    }\n    \n\treturn ii;    \n}\n\n#define THRESHOLD 0.43445\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {\n    \n    float\tmarchingDist = 39.5;\n    float \tnbIter \t\t = 0.0;\n\n \tm = origin;   \n    \n    float lastestIntensity = -1000.;\n    \n    for(int i=0; i<200; i++) {\n        \n    \tfloat fieldIntensity = getFieldIntensity(m, normal);\n        \n      if(lastestIntensity>fieldIntensity) {\n            break;\n        }\n        \n        if(fieldIntensity > THRESHOLD-0.01) {\n            return true;\n        }\n        else {\n            float delta = THRESHOLD - fieldIntensity;\n            marchingDist += 0.01;//sqrt(delta)*0.5;\n        \tm = origin + ray * marchingDist;    \n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light) {\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = dot(normal, -lightRay);\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), SHININESS);\n\n    vec3 baseColor = vec3(1,0,0);\n    \n    vec3 diffuseComponent = baseColor * 0.8 * diffuse;\n    vec3 hilightComponent = vec3(1.0, 1.0, 1.0) * hilight;    \n    vec3 ambiantComponent = baseColor * 0.4;        \n\n    return vec4(diffuseComponent + hilightComponent + ambiantComponent, 1.0);\n}\n\nfloat shadow(in vec3 light, in vec3 eye, in vec3 ray, in vec3 m, in vec3 normal) {\n    \n    const float wallDist = 42.0;\n    vec3 wallPoint = ray / ray.z * wallDist;\n\n    vec3 lightdir = normalize(wallPoint - light);\n\n    const float e = 0.2;\n    float nbColl = 1.0;\n    \n    float i = getFieldIntensity(light, lightdir, m, normal);\n    \n    \n    return 1.0 - smoothstep(7.5,17.5, i);\n    \n    \n    /*\n    if(rayMarching(light, lightdir, m, normal)) {\n        \n        float shadow = max(dot(-lightdir,normal), 0.0);\n        \n        return 1.0 - shadow;\n    }\n    else {\n\t \treturn 1.0;   \n    }\n\t*/\n}\n\nvec4 background(in vec3 viewportCoord, in vec3 light, in vec3 eye, in vec3 ray, in vec3 m, in vec3 normal) {\n    \n    vec3 texcol = texture(iChannel0, viewportCoord.xy + 0.5).rgb;\n\tvec3 finalColor = mix(texcol, vec3(0,0,0), 1.0 - shadow(light, eye, ray, m, normal));    \n    \n    return vec4(finalColor, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, -0.8);\n    vec3\tray\t\t\t\t= normalize(viewportCoord - eye);\n    //vec3\tlight\t\t\t= vec3(-15.0*cos(iTime), 5.0*cos(iTime/3.0), 5.0);\n    vec3\tlight\t\t\t= vec3(-15.0, 5.0, 5.0);\n    \n    vec3\tm;\n    vec3 \tnormal;\n    \n    if(rayMarching(eye, ray, m, normal)) {\n        fragColor = computeColor(ray, m, normal, light);\n    }\n    else {\n        fragColor = background(viewportCoord, light, eye, ray, m, normal);\n    }\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 139, 139, 350], [353, 353, 406, 406, 861], [863, 863, 946, 946, 1360], [1389, 1389, 1465, 1465, 2073], [2076, 2076, 2150, 2150, 2667], [2669, 2669, 2751, 2751, 3270], [3272, 3272, 3380, 3380, 3581], [3583, 3583, 3640, 3640, 4229]], "test": "error"}
{"id": "lljXWG", "name": "Clouds mod experiment", "author": "Duke", "description": "Frankly I'm not sure whether it was necessary to publish this shader, as changes in comparison with the original are small. But perhaps it will seem interesting to someone. Main code is from iq's \"Clouds\" demo and noises from otaviogood's \"Alien Beacon\"", "tags": ["clouds"], "likes": 25, "viewed": 2678, "published": "Public API", "date": "1446231051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Clouds come from https://www.shadertoy.com/view/XslGRr\n// Noises come from https://www.shadertoy.com/view/ld2SzK\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define CLOUDTYPE3\n\n#ifdef CLOUDTYPE1\n// default noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n#endif\n\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n\n#ifdef CLOUDTYPE2\nfloat noise(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n#endif\n\n#ifdef CLOUDTYPE3\nfloat noise(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n#endif\n#ifdef CLOUDTYPE4\nfloat noise(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n#endif\n#ifdef CLOUDTYPE5\nfloat noise(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n#endif\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.75,-1.0) );\n\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*dif; \n    // original\n    //vec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    // scattering approximation\n    //vec4 col = vec4(vec3(1./exp( den * 0.2 ) * clamp(sin(iTime)*2.5,0.4,1.05)), den);// * 2.5);\n    vec4 col = vec4(vec3(1./exp( den * 0.2 ) * 1.05), den);// * 2.0);\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.1,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljXWG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2250, 2250, 2275, 2275, 2572], [2574, 2574, 2599, 2599, 2855], [2856, 2856, 2881, 2881, 3096], [3097, 3097, 3122, 3122, 3297], [3350, 3350, 3436, 3452, 4006], [4323, 4323, 4379, 4379, 4538], [4540, 4540, 4592, 4592, 4769], [4771, 4771, 4810, 4837, 5205], [5207, 5207, 5264, 5264, 5633], [5635, 5635, 5729, 5729, 5781]], "test": "valid"}
{"id": "llSSzt", "name": "Simple Sine Anim", "author": "jamad", "description": "practice04", "tags": ["basic"], "likes": 0, "viewed": 122, "published": "Public", "date": "1445799694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// graph : y=sin(2*pi*x+t)/2 + 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;  // uv : range 0..1\n\n    float t=iTime * 4.; // time adjusted\n    \n    float x=2. *3.14 * uv.x; // 2*pi*x \n    float y=uv.y;\n    \n    float diff=sin(x+t)/2.+0.5-y;// get diff of equation\n    float intensity = 1./ diff;// the bigger diff, the lower intensity\n \n    float band=0.005;// line width adjustment\n    \n    fragColor=vec4(abs(intensity*band), 0, 0, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 499]], "test": "valid"}
{"id": "llSXzK", "name": "Stromboli2", "author": "dr2", "description": "A 3-D volcano - daytime view (mouse enabled).", "tags": ["raymarching", "volcano"], "likes": 16, "viewed": 1797, "published": "Public API", "date": "1444922684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Stromboli2\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// A 3-D volcano - daytime view.\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, cHashA3.xy));\n  t2 = Hashv4f (dot (ip.zw, cHashA3.xy));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s, a;\n  s = 0.;  a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;  p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float s, a;\n  s = 0.;  a = 0.5;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    s += a * Noisefv3 (p);\n    a *= 0.5;  p *= 4. * mr;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  const vec3 e = vec3 (0.1, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\n#define NROCK 16\nvec4 rkPos[NROCK];\nvec3 sunDir, waterDisp, cloudDisp, flmCylPos;\nfloat tCur, lavHt, qRad, waterHt, flmCylRad, flmCylLen;\nint idObj;\nconst float dstFar = 100.;\nconst int nRock = NROCK;\nconst int idMnt = 1, idRock = 2, idLav = 3;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 150.;\n  vec3 col, bgCol;\n  float cloudFac;\n  bgCol = vec3 (0.1, 0.2, 0.5);\n  if (rd.y > 0.) {\n    ro.xz += 0.5 * tCur;\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (3. * (f - 0.5) * rd.y + 0.1, 0., 1.);\n    col = bgCol + 0.2 * pow (1. - max (rd.y, 0.), 5.);\n    col = mix (col, vec3 (0.75), cloudFac);\n  } else col = 0.9 * bgCol + 0.25;\n  return col;\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 mr = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.2;  wAmp = 1.;  pRough = 5.;\n  t4o.xz = 1.3 * tCur * vec2 (1., -1.);\n  q2 = 10. * p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v4 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= mr;  wFreq *= 2.;  wAmp *= 0.2;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return 0.03 * ht + waterHt;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 70; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.4, 1.2 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.002, 1e-3 * d * d), 0.);\n  float h = WaveHt (p);\n  return normalize (vec3 (h - WaveHt (p + e.xyy), e.x, h - WaveHt (p + e.yyx)));\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  vec3 q;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    q = ro + dHit * rd - flmCylPos;\n    d = PrCylDf (q.xzy, flmCylRad, flmCylLen);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat MountDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, r, hd, s;\n  q = p;\n  a = atan (q.z, q.x) / (2. * pi) + 0.5;\n  r = length (q.xz);\n  s = Fbm2 (vec2 (33. * a, 7. * r)) - 0.5;\n  d = PrCylDf (q.xzy, 2., 0.75);\n  q.y -= 0.75;\n  d = max (d, - (PrSphDf (q, 0.35) - 0.03 * s));\n  hd = 0.015 * (1. + sin (64. * pi * a) + 2. * sin (25. * pi * a)) *\n     SmoothBump (0.5, 1.8, 0.3, r) + 0.15 * s * SmoothBump (0.1, 2., 0.2, r);\n  q.y -= 1.2 + hd;\n  d = max (max (d, - PrTorusDf (q.xzy, 2.8, 2.8)), 0.15 - length (q.xz));\n  if (d < dMin) { dMin = d;  idObj = idMnt; }\n  q = p;\n  q.y -= lavHt;\n  d = PrCylDf (q.xzy, 0.3, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idLav; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  dMin = MountDf (p, dMin);\n  for (int j = 0; j < nRock; j ++) {\n    d = PrSphDf (p - rkPos[j].xyz, rkPos[j].w);\n    if (d < dMin) { dMin = d;  idObj = idRock;  qRad = rkPos[j].w; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvoid SetRocks ()\n{\n  vec3 bv0, bp0, bp;\n  float a, tm, fj;\n  for (int j = 0; j < nRock; j ++) {\n    fj = float (j);\n    a = 2. * pi * Hashff (100.11 * fj);\n    bv0.xz = 0.7 * vec2 (cos (a), sin (a));\n    bv0.y = 1.4 + 0.3 * Hashff (11.11 * fj);\n    bp0.xz = 0.1 * bv0.xz;  bp0.y = 0.5;\n    tm = mod (tCur + 0.15 * (fj + 0.6 * Hashff (fj)), 3.);\n    bp = bp0 + bv0 * tm;  bp.y -= 0.6 * tm * tm;\n    rkPos[j] = vec4 (bp, 0.04 - 0.035 * tm / 3.);\n  }\n}\n\nfloat FlmAmp (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fh, fr, f, hs;\n  p = ro + dHit * rd - flmCylPos;\n  hs = min (p.y / flmCylLen, 1.);\n  dp = (flmCylRad / 20.) * rd;\n  g = 0.;\n  for (int i = 0; i < 20; i ++) {\n    p += dp;\n    s = distance (p.xz, flmCylPos.xz);\n    q = 4. * p;  q.y -= 6. * tCur;\n    fh = 0.5 * max (1. - (p.y - flmCylPos.y) / flmCylLen, 0.);\n    fr = max (1. - s / flmCylRad, 0.);\n    f = Fbm3 (q);\n    q = 7. * p;  q.y -= 8.5 * tCur;\n    f += Fbm3 (q);\n    g += max (0.5 * fr * fr * fh * (f * f - 0.6), 0.);\n    q = 23. * p;  q.y -= 11. * tCur;\n    g += 1000. * pow (abs (Noisefv3 (q) - 0.11), 64.);\n    if (s > flmCylRad || p.y < flmCylPos.y - 0.99 * flmCylLen || g > 1.) break;\n  }\n  g = clamp (0.9 * g, 0., 1.);\n  if (hs > 0.) g *= 1. - hs * hs;\n  return g;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit, dstWat, dstFlm, dstFlmR, intFlm, bgFlm, reflFac, s;\n  int idObjT;\n  waterDisp = 0.002 * tCur * vec3 (-1., 0., 1.);\n  waterHt = -0.65;\n  lavHt = 0.4 + 0.08 * sin (0.47 * tCur) + 0.05 * cos (0.77 * tCur);\n  SetRocks ();\n  ro.y = max (ro.y, WaveHt (ro) + 0.3);\n  flmCylPos = vec3 (0., 0.9, 0.);\n  flmCylRad = 0.35;\n  flmCylLen = 1.3;\n  reflFac = 1.;\n  dstFlm = TransObjRay (ro, rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  bgFlm = (0.7 + 0.6 * Noiseff (10. * tCur));\n  intFlm = (dstFlm < dstHit) ? FlmAmp (ro, rd, dstFlm) : 0.;\n  dstWat = WaveRay (ro, rd);\n  if (rd.y < 0. && dstWat >= dstFar) dstWat = - (ro.y - waterHt) / rd.y;\n  if (dstWat < dstHit) {\n    ro += rd * dstWat;\n    rd = reflect (rd, WaveNf (ro, dstWat));\n    ro += 0.01 * rd;\n    dstFlmR = TransObjRay (ro, rd);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    if (dstFlmR < dstFlm) {\n      intFlm = (dstFlmR < dstHit) ? FlmAmp (ro, rd, dstFlmR) : 0.;\n      dstFlm = dstFlmR;\n    }\n    reflFac = 0.9;\n  }\n  if (dstHit >= dstFar) col = reflFac * SkyCol (ro, rd);\n  else {\n    ro += dstHit * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idMnt) {\n      s = clamp (ro.y / 1.2 + 0.6, 0., 1.);\n      vn = VaryNf (11. * ro, vn, 10. - 7. * s);\n      col = (0.5 + 0.7 * bgFlm * s) * vec3 (0.2 + 0.1 * (1. - s),\n         0.05 + 0.2 * (1. - s), 0.05);\n      col = reflFac * col * (0.1 + 0.1 * max (vn.y, 0.) +\n         0.8 * max (dot (vn, sunDir), 0.));\n    } else if (idObj == idLav) {\n      col = mix (vec3 (0.4, 0., 0.), vec3 (0.8, 0.7, 0.),\n         step (1.1, Fbm2 (41. * ro.xz * vec2 (1. + 0.2 * sin (1.7 * tCur) *\n\t vec2 (1. + 0.13 * sin (4.31 * tCur), 1. + 0.13 * cos (4.61 * tCur))))));\n      vn = VaryNf (21. * ro, vn, 10.);\n      col *= 0.5  + 1.5 * pow (max (vn.y, 0.), 32.);\n    } else if (idObj == idRock) {\n      col = mix (vec3 (1., 0., 0.), vec3 (0.1, 0.3, 0.1),\n         1. - (qRad - 0.005) / 0.03);\n      vn = VaryNf (200. * ro, vn, 10.);\n      col = reflFac * col * (0.6 + 0.4 * max (dot (vn, vec3 (0., 0.5, 0.)), 0.));\n    }\n  }\n  if (intFlm > 0.) col = mix (col, bgFlm * mix (vec3 (1., 0.1, 0.1),\n     vec3 (1., 1., 0.5), 0.5 * intFlm), 1.2 * intFlm);\n  return (clamp (col, 0., 1.));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  mat3 vuMat;\n  vec3 rd, ro;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, dist;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  dist = 8. + 3. * cos (0.2 * tCur);\n  az = - 0.03 * tCur;\n  el = 0.15 * (11. - dist);\n  if (mPtr.z > 0.) {\n    az -= 3. * mPtr.x;\n    el = clamp (el - 3. * mPtr.y, 0., 1.3);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = - vec3 (0., 0., dist) * vuMat;\n  rd = normalize (vec3 (uv, 3.5)) * vuMat;\n  sunDir *= vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSXzK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[299, 299, 323, 323, 360], [362, 362, 386, 386, 436], [438, 438, 462, 462, 509], [511, 511, 535, 535, 774], [776, 776, 801, 801, 946], [948, 948, 973, 973, 1171], [1173, 1173, 1198, 1198, 1541], [1543, 1543, 1568, 1568, 1896], [1898, 1898, 1919, 1919, 2054], [2056, 2056, 2077, 2077, 2307], [2309, 2309, 2338, 2338, 2546], [2548, 2548, 2587, 2587, 2810], [2812, 2812, 2869, 2869, 2952], [2954, 2954, 2987, 2987, 3014], [3016, 3016, 3058, 3058, 3109], [3111, 3111, 3157, 3157, 3214], [3462, 3462, 3494, 3494, 4046], [4048, 4048, 4071, 4071, 4755], [4757, 4757, 4791, 4791, 5320], [5322, 5322, 5353, 5353, 5509], [5511, 5511, 5549, 5549, 5786], [5788, 5788, 5824, 5824, 6483], [6485, 6485, 6507, 6507, 6744], [6746, 6746, 6779, 6779, 6988], [6990, 6990, 7011, 7011, 7219], [7221, 7221, 7239, 7239, 7670], [7672, 7672, 7717, 7717, 8478], [8480, 8480, 8515, 8515, 10820], [10822, 10822, 10878, 10878, 11690]], "test": "valid"}
{"id": "lt2SDD", "name": "Black Rainbow Coconut", "author": "eddietree", "description": "rainbow core", "tags": ["raymarching"], "likes": 30, "viewed": 1097, "published": "Public", "date": "1444014272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a study on raymarching, soft-shadows, ao, etc\n// borrowed heavy from others, esp @cabbibo and @iquilezles and more\n// by @eddietree\n\n#define float3 vec3\n\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 50;\n\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in float3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float radius = 6.0;\n    float theta = 9.6 + 5.0*mouse.x;// + iTime*0.5;\n    float phi = 3.14159*0.4;//5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// noise func\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2; \n}\n\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos )\n{  \n    vec3 voro0 = voronoi(pos);\n    \n    float t1 = distSphere( pos, 2.0 + snoise( vec4(pos*0.75, cos(iTime*1.5))) * 0.1 );//\n    \n    float torus = sdTorus( pos, vec2(1.6, 0.2 + noise(pos + vec3(sin(pos.z+iTime*1.5),0.0,cos(pos.y*0.8+iTime*1.5) )) ));\n    \n    t1 = opS( torus,t1 );\n    \n    //float cap0 = sdCapsule( pos + vec3(0.0, sin(pos.x + iTime*3.5)*0.1,0.0), vec3(0.8,0.0,0.0), vec3(9.0,0.3,-0.2), 0.05 );\n    //float cap1 = sdCapsule( pos + vec3(0.0, cos(pos.x + iTime*3.5)*0.1,0.0), vec3(0.8,0.0,0.0), vec3(9.0,-0.3,0.2), 0.05);\n    //float tail = smin( cap0, cap1, 9.0 );\n    //t1 = min( t1, tail);\n    //t1 = capsule;\n    \n    //t1 = min( t1, distSphere( pos + vec3(3.0,0.0,0.0), 0.2 +voronoi(pos).x ) + voronoi(pos*9.0).x*0.01 );\n    //t1 = min( t1, distSphere( pos + vec3(-3.0,0.0,0.0), 0.2 +voronoi(pos).x ) + voronoi(pos*9.0).x*0.01 );\n    //t1 = vnoise(pos*1.0, 2.0 );\n    //float radius = (sin(pos.x) * 0.5 + 0.5) * 2.0;\n    //float t1 = distSphere( pos,  floor(radius) );\n    \n    //t1 = min( t1, distSphere(pos + vec3(4.0,0.0,0.0), 0.3) );\n    //t1 = min( t1, distSphere(pos + vec3(-4.0,0.0,0.0), 0.3) );\n   \n   \treturn vec2( t1, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float k = 2.0;\n    \n    const int maxSteps = 10;\n    float t = 0.0;\n    float res = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n            \n        if(d < INTERSECTION_PRECISION) {\n            \n            return 0.0;\n        }\n        \n        res = min( res, k*d/t );\n        t += d;\n    }\n    \n    return res;\n}\n\nfloat ambientOcclusion( in vec3 ro, in vec3 rd )\n{\n    const int maxSteps = 11;\n    const float stepSize = 0.01;\n    \n    float t = 0.0;\n    float res = 0.0;\n    \n    // starting d\n    float d0 = map(ro).x;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n\t\tfloat diff = max(d0-d, 0.0);\n        \n        res += diff;\n        \n        t += stepSize;\n    }\n    \n    return 1.0-res;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 rayPlaneIntersection( vec3 ro, vec3 rd, vec4 plane )\n{\n\tfloat t = -( dot(ro, plane.xyz) + plane.w) / dot( rd, plane.xyz );\n\treturn ro + t * rd;\n}\n\n\nvec3 renderColor( vec3 ro , vec3 rd, in vec3 color, vec3 currPos )\n{\n    vec3 normal = calcNormal( currPos );\n    \n    vec3 lightPos = vec3(-1.5,0.0,0.0);\n    vec3 lightColor = vec3(1.0,0.5,0.6);\n\n    vec3 lightDir = normalize(vec3(1.0,0.0,0.0));\n    float shadowVal = shadow( currPos - rd* 0.03, lightDir  );\n    \n    float ao = ambientOcclusion( currPos - normal*INTERSECTION_PRECISION*3.0, -normal );\n    float ndotl = abs(dot( -rd, normal ));\n    float rim = pow(1.0-ndotl, 3.5);\n\n    \n    // sphere\n    float distToCenter = length(currPos);\n    if ( abs(distToCenter - 2.0) < 0.13  )\n    {\n        vec4 pos = vec4( currPos*15.0, 1.0 );\n        float noiseVal = snoise(pos);\n        \n        color = vec3(0.0);\n        color += vec3(rim + noiseVal*0.1);\n    }\n    \n    // inside\n    else\n    {\n        vec4 pos = vec4( currPos*15.0, 1.0 );\n        color = normal*0.5+vec3(0.5);\n        color += smoothstep( 1.5, 2.0, distToCenter ) * 0.6;\n    }\n    \n        \n    return color;\n}\n\nbool renderRayMarch(vec3 ro, vec3 rd, inout vec3 color ) {\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    vec3 lightDir = normalize(vec3(1.0,0.4,0.0));\n    \n    for(int i = 0; i < maxSteps; ++i) \n    {\n        vec3 currPos = ro + rd * t;\n        d = map(currPos).x;\n        if(d < INTERSECTION_PRECISION) \n        {\n        \tbreak;\n        }\n        \n        t += d;\n    }\n       \n    if(d < INTERSECTION_PRECISION) \n    {\n\t    vec3 currPos = ro + rd * t;\n    \tcolor = renderColor( ro, rd, color, currPos );\n        return true;\n    }\n    \n    \n     vec3 planePoint = rayPlaneIntersection(ro, rd, vec4(0.0, 1.0, 0.0, 2.5));\n\tfloat shadowFloor = shadow( planePoint, vec3(0.0,1.0,0.0));\n\tcolor = color * mix( 0.6, 1.0, shadowFloor );\n    \n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    // calc color\n    vec3 col = vec3(0.9);\n    //vec3 col = texture (iChannel0, rd).xyz;\n    renderRayMarch( ro, rd, col );\n    \n    // vignette, OF COURSE\n    float vignette = 1.0-smoothstep(1.0,2.5, length(p));\n    col.xyz *= mix( 0.5, 1.0, vignette);\n        \n    fragColor = vec4( col , 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 278, 278, 311], [313, 313, 346, 346, 411], [413, 413, 446, 446, 472], [474, 474, 507, 507, 532], [534, 534, 567, 567, 592], [594, 646, 677, 677, 1462], [1464, 1464, 1530, 1530, 1708], [1710, 1710, 1791, 1791, 2131], [2133, 2133, 2174, 2174, 2245], [2247, 2261, 2284, 2284, 2320], [2321, 2321, 2347, 2347, 2716], [2718, 2812, 2841, 2841, 2875], [2878, 2878, 2899, 2899, 3057], [3059, 3109, 3136, 3136, 3716], [3718, 3718, 3770, 3770, 3897], [3900, 3900, 3921, 3921, 3970], [3972, 3972, 3995, 3995, 4044], [4046, 4046, 4068, 4068, 4108], [4110, 4110, 4134, 4134, 4174], [4176, 4176, 4204, 4204, 4256], [4258, 4258, 4288, 4288, 4340], [4342, 4342, 4374, 4374, 4637], [4719, 4719, 4743, 4743, 7221], [7224, 7308, 7330, 7330, 8491], [8493, 8493, 8533, 8533, 8910], [8912, 8912, 8962, 8962, 9334], [9336, 9336, 9373, 9373, 9505], [9508, 9508, 9540, 9540, 9762], [9765, 9765, 9824, 9824, 9915], [9918, 9918, 9986, 9986, 10900], [10902, 10902, 10960, 10960, 11712], [11715, 11715, 11772, 11772, 12457]], "test": "valid"}
{"id": "lt2SRV", "name": "[CIS565 2015F]ss: all in demo", "author": "shrekshao", "description": "AcknowledgementsThis Shadertoy uses material from the following resources:\n(http://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf)\n(https://www.shadertoy.com/view/Xds3zN)\n(http://www.iquilezles.org/www/articles/terrainmarching/terrai\n", "tags": ["raymarching", "fractal"], "likes": 4, "viewed": 225, "published": "Public", "date": "1445181855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//MACRO-------------------------------------\n\n//Scene\n#define MENGER 1\n#define TERRAIN 1\n\n//Debug Render Type\n#define DEBUG_DISTANCE_TO_SURFACE 0\n#define DEBUG_NUM_RAY_MARCH_ITERATIONS 0\n\n\n\n//Ray March Mode\n//Enable the first to see correct fractal and terrain\n//Disable both to enabke sphere marching\n#define NAIVE_TRACE_INTERPOLATE 1\n#define NAIVE_TRACE 0\n\n\n\n//Trace Parameter\n#define MAX_ITERATIONS_NAIVE 2000\n#define DT 0.01\n#define RATIO_T 0.003\n\n#define MAX_ITERATIONS_SPHERE 50\n\n\n#define MAX_ITERATION_TIMES_DIVIDER 40\n\n\n//Optimize\n\n#define K_OVERRELAX (1.2)\n#define BOUNDING_SPHERE 1\n\n\n//Time measurement\n#define SHADE 1\n#define SOFTSHADOW 1\n#define AO 1\n\n\n//------------------------------------------\n\n\n\n#if DEBUG_NUM_RAY_MARCH_ITERATIONS\n\tint num_ray_march_interations=0;\n\t//int num_reverse=0;\n#endif\n\n//Distance Functions\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n\n\nfloat maxcomp(in vec2 p ) { return max(p.x,p.y);}\nfloat sdCross( in vec3 p )\n{\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.0;\n}\n\nfloat sdMengerSponge(vec3 p)\n{\n\n\t//bounding Sphere\n#if BOUNDING_SPHERE\n\tfloat tSquared = dot(p,p) - 3.0;\n\tif(tSquared > 0.0)\n\t{\n\t\treturn sqrt(tSquared);\n\t}\n#endif\n\n\tfloat d = sdBox(p,vec3(1.0));\n\n\tfloat s = 1.0;\n\tfor( int m=0; m<3; m++ )\n\t{\n\t\tvec3 a = mod( p*s, 2.0 )-1.0;\n\t\ts *= 3.0;\n\t\tvec3 r = 1.0 - 3.0*abs(a);\n\t\tfloat c = sdCross(r)/s;\n\t\td = max(d,c);\n\t}\n    \n    \n   return d;\n}\n\n\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//Repetition\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\nvec3 opTranslate(vec3 p, vec3 trans)\n{\n\treturn p - trans;\n}\n\nvec3 opRotate(vec3 p, vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n    float s = sin(radians(-angle));\n    float c = cos(radians(-angle));\n    float oc = 1.0 - c;\n\tmat3 R = mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n\t\n\t\n\treturn R*p;\n}\n\nvec3 opScale(vec3 p, vec3 scale)\n{\n\treturn p/scale;\n}\n\nvec3 opTransform(vec3 p, vec3 trans, vec3 axis,float angle, vec3 scale)\n{\n\t//transform T*R*S\n\t//inv order S*R*T\n\n\tmat4 T = mat4(1.0,0.0,0.0,0.0\n\t\t\t\t\t,0.0,1.0,0.0,0.0\n\t\t\t\t\t,0.0,0.0,1.0,0.0\n\t\t\t\t\t,-trans.x,-trans.y,-trans.z,1.0);\n\t\n\taxis = normalize(axis);\n    float s = sin(radians(-angle));\n    float c = cos(radians(-angle));\n    float oc = 1.0 - c;\n\tmat4 R = mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n\n\t\n\tmat4 S = mat4(1.0/scale.x,0.0,0.0,0.0,\n\t\t\t\t\t0.0,1.0/scale.y,0.0,0.0,\n\t\t\t\t\t0.0,0.0,1.0/scale.z,0.0,\n\t\t\t\t\t0.0,0.0,0.0,1.0);\n\n\tvec4 hp = p.xyzz;\n\thp.w = 1.0;\n\thp = S*R*T*hp;\n\n\treturn hp.xyz;\n}\n\n\nfloat opIntersect(float d1, float d2)\n{\n\treturn max(d1,d2);\n}\n\n//vec3 opScale(vec3 \n\n\n\nvec3 float2Color(float v,float vmin,float vmax)\n{\n\tfloat t = 2.0 * (v-vmin)/(vmax-vmin);\n\t\n\treturn vec3( 1.0 - min(1.0,max(0.0,t))\n\t\t\t\t, t>1.0 ? max(0.0,2.0-t) : t\n\t\t\t\t, min(1.0,max(0.0,t-1.0)) );\n\n}\n\n\nfloat opBump(float r,vec3 p, float h)\n{\n\treturn  r+h*sin(50.0*p.x)*sin(50.0*p.y)*sin(50.0*p.z);\n}\n\n//----------------------------------------------------------------------\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nfloat terrain(vec3 pos)\n{\n\t//float h = sin(pos.x)*sin(pos.z);\n    float h = sin(cos(pos.z)*(pos.x+pos.z))*cnoise(pos.xz);\n    h = max(-0.1,h);\n    h +=  0.01*cnoise(29.0*vec2(sin(pos.y+pos.z)+cos(pos.x),cos(pos.x + pos.y) ) ) -0.1;\n\treturn pos.y-h;\n}\nvec2 map( in vec3 pos )\n{\n    //vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t //           vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    \n\t//terrain\n\t//vec2 res= vec2(terrain(pos),1.0);\n\n\n#if TERRAIN\n\tvec2 res= vec2(terrain(opTranslate(pos,vec3(0.0,-1.0,0.0))),1.0);\n#else\n\tvec2 res = vec2( sdPlane(pos), 1.0 );\n#endif\n\tres = opU( res, vec2( sdSphere( opTranslate(pos,vec3(0.0,0.25,0.0)),0.25) , 58.0) );\n\tres = opU( res, vec2( sdSphere( opTransform(pos,vec3(-1.0,0.85,0.0),vec3(1.0,1.0,1.0),45.0,vec3(2.0,1.0,1.0)  ) ,0.25) , 58.0) );\n    \n\tres = opU( res, vec2( sdBox(     opTransform(pos,vec3(1.0,0.75,0.0),vec3(1.0,1.0,1.0),45.0,vec3(1.0,1.0,1.0)  ), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  opTransform(pos,vec3(1.0,0.25,1.0),vec3(0.0,1.0,0.0),60.0,vec3(1.0,1.0,1.0)), vec3(0.15), 0.1 ), 41.0 ) );\n\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 99.0 ) );\n    res = opU( res, vec2( sdTorus82(   pos-vec3( 1.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\t//simple bump\n\tres = opU( res, vec2( opBump(sdSphere(pos-vec3(-2.0,0.25,-1.0), 0.2 ),pos,0.01) , \n                                       365.0 ) );\n\n\n\tres = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 213.0 ) );\n    \n    \n\n\n#if MENGER\n\t//fractal\n\tres = opU( res, vec2( sdMengerSponge(opTransform(pos,vec3(-0.8,0.35,1.9),vec3(0.0,1.0,0.0),0.0,vec3(0.3,0.3,0.3)) ),107.0 ) );\n#endif\n\n    return res;\n}\n\n\n//const overRelaxK = 1.5;\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n\n//interpolate and dynamic delta\n#if NAIVE_TRACE_INTERPOLATE\n\n\n\tfloat tmin = 1.0;\n    float tmax = DT * float(MAX_ITERATIONS_NAIVE);\n\tfloat dt = DT;\n\n\tfloat t = tmin;\n\tvec2 res = map(ro+rd*t);\n\n    float lh = 0.0;\n    float ly = 0.0;\n\t//while loop is not allowed in shader toy\n\tfor( int i=0; i<MAX_ITERATIONS_NAIVE; i++ )\n    {\n#if DEBUG_NUM_RAY_MARCH_ITERATIONS\n\t\tnum_ray_march_interations = num_ray_march_interations + 1;\n#endif\n        vec3 p = ro+rd*t;\n        res = map(p);\n\t\tif(t >= tmax)\n        {\n            break;\n        }\n            \n        if(res.x <= 0.0)\n        {\n            t = t - dt + dt *(lh-ly)/(p.y-ly-(p.y-res.x)+lh);\n            break;\n        }\n\n\t\tt = t + dt;\n        \n\t\t\n        \n        //changing dt and interpolate\n        dt = RATIO_T*t;\n        lh = p.y - res.x;\n        ly = p.y;\n\n\t}\n\tif( t>tmax ) res.y=-1.0;\n\treturn vec2(t,res.y);\n\n\t//naive way\n#elif NAIVE_TRACE\n\n\n\tfloat tmin = 1.0;\n    float tmax = 20.0;\n\tfloat dt = DT;\n\n\tfloat t = tmin;\n\tvec2 res = map(ro+rd*t);\n\n\t//while loop is not allowed in shader toy\n\tfor( int i=0; i<MAX_ITERATIONS_NAIVE; i++ )\n    {\n#if DEBUG_NUM_RAY_MARCH_ITERATIONS\n\t\tnum_ray_march_interations = num_ray_march_interations + 1;\n#endif\n\t\tif(t >= tmax || res.x <= 0.0) break;\n\n\t\tt = t + dt;\n\t\tres = map(ro+rd*t);\n\t\t\n\t}\n\n    if( t>tmax ) res.y=-1.0;\n\treturn vec2(t,res.y);\n#else\n\t//Sphere Trace\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n\n\tfloat this_dt = 0.0;\n    float K = K_OVERRELAX;\n    float last_r=0.0;\n    for( int i=0; i<MAX_ITERATIONS_SPHERE; i++ )\n    {\n#if DEBUG_NUM_RAY_MARCH_ITERATIONS\n\t\tnum_ray_march_interations = num_ray_march_interations + 1;\n#endif\n        vec2 res = map( ro+rd*t );\n\t\tif(K>1.01 && last_r + abs(res.x) < this_dt)\n\t\t{\n\t\t\t//fail\n#if DEBUG_NUM_RAY_MARCH_ITERATIONS\n            //num_reverse += 1;\n\t\t\tnum_ray_march_interations = num_ray_march_interations + 1;\n#endif\n\n\t\t\tt += (1.0-K) * this_dt;\n\t\t\tres = map( ro + rd * t);\n            K=1.0;\n\t\t}\n\t\t\n\t\tif( res.x<precis || t>tmax ) break;\n\t\t\n        last_r = abs(res.x);\n\t\tthis_dt = K * last_r;\n        t += this_dt;\n        m = res.y;\n\n    }\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n#endif\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n#if SOFTSHADOW\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n#else\n\treturn 1.0;\n#endif\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n#if AO\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n#else\n\treturn 1.0;\n#endif\n}\n\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n\n#if DEBUG_DISTANCE_TO_SURFACE\n\tvec2 res = castRay(ro,rd);\n\tfloat tmp = res.x/20.0;\n\tvec3 col = vec3(tmp);\n\treturn clamp(col,0.0,1.0);\n\t\n#elif DEBUG_NUM_RAY_MARCH_ITERATIONS\n\tvec2 res = castRay(ro,rd);\n\t//vec3 col = vec3(float(num_ray_march_interations)/float(MAX_ITERATION_TIMES_DIVIDER),0.0,0.0);\n\t//return clamp(col,0.0,1.0);\n\treturn float2Color(float(num_ray_march_interations),0.0,float(MAX_ITERATION_TIMES_DIVIDER));\n    //return float2Color(float(num_reverse),0.0,10.0);\n#else \n    vec3 col = vec3(0.8, 0.9, 1.0); // Sky color\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n    float m = res.y;\n\n#if SHADE\n    if( m>-0.5 )  // Ray intersects a surface\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n        if( m<1.5 )\n        {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        brdf += 0.02;\n        col = col*brdf;\n\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n    }\n#endif\n\n    return vec3( clamp(col,0.0,1.0) );\n#endif\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n    float time = 15.0 + iTime;\n\n    // camera\t\n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    col = pow( col, vec3(0.4545) ); // Gamma correct\n\n    fragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[835, 835, 860, 860, 875], [877, 877, 912, 912, 938], [940, 940, 971, 971, 1058], [1060, 1060, 1103, 1103, 1163], [1165, 1165, 1210, 1210, 1250], [1252, 1252, 1285, 1285, 1338], [1340, 1340, 1376, 1376, 1618], [1620, 1620, 1672, 1672, 1786], [1788, 1788, 1824, 1824, 2072], [2074, 2074, 2110, 2110, 2209], [2211, 2211, 2249, 2249, 2418], [2420, 2420, 2492, 2492, 2707], [2708, 2708, 2733, 2733, 2770], [2772, 2772, 2797, 2797, 2855], [2857, 2857, 2882, 2882, 2947], [2949, 2949, 2984, 2984, 3051], [3053, 3053, 3088, 3088, 3155], [3157, 3157, 3194, 3194, 3245], [3250, 3250, 3277, 3277, 3299], [3300, 3300, 3328, 3328, 3462], [3464, 3464, 3494, 3514, 3847], [3925, 3925, 3958, 3958, 3984], [3986, 3986, 4016, 4016, 4049], [4051, 4064, 4094, 4094, 4123], [4125, 4125, 4149, 4149, 4281], [4284, 4284, 4322, 4322, 4343], [4345, 4345, 4392, 4392, 4882], [4884, 4884, 4918, 4918, 4937], [4939, 4939, 5012, 5050, 5866], [5869, 5869, 5908, 5908, 5930], [5956, 5956, 6005, 6005, 6155], [6158, 6158, 6197, 6197, 6255], [6775, 6775, 6796, 6796, 6845], [6847, 6847, 6869, 6869, 6906], [6908, 6908, 6936, 6936, 6988], [6990, 6990, 7009, 7009, 7049], [7051, 7075, 7097, 7097, 8139], [8142, 8142, 8167, 8203, 8392], [8393, 8393, 8418, 8603, 9937], [9968, 9968, 10008, 10041, 12228], [12231, 12231, 12305, 12305, 12615], [12617, 12617, 12649, 12649, 12888], [12891, 12891, 12933, 12933, 13268], [13274, 13274, 13313, 13313, 15499], [15501, 15501, 15553, 15553, 15742], [15744, 15744, 15801, 15801, 16439]], "test": "valid"}
{"id": "lt2SWy", "name": "plasma snakes 3", "author": "FabriceNeyret2", "description": ".", "tags": ["2d"], "likes": 11, "viewed": 1108, "published": "Public API", "date": "1446287840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P(t)   vec2( 1.7*cos(t)+.5*sin(-2.7*t), .8*sin(1.2*t)+.5*cos(3.2*t) ) /1.5\n\n#define draw(t,c)  o += .1*smoothstep(.03*c, c-c, vec4(length(P((t))-U)))\n\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n\tvec2 R = iResolution.xy;  \n    U = (2.*U -R ) / R.y;\n    \n    for (float dt=0.; dt<5.; dt+= .01) {\n        \n        float t = dt+iTime;\n        \n        draw( t,       vec4(1,2,3,0));\n        draw( t-1234., vec4(3,2,1,0));        \n        draw( t+1234., vec4(2,3,1,0));        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 199, 199, 505]], "test": "valid"}
{"id": "lt2SzG", "name": "Hexlicity", "author": "klk", "description": "Maze on hexagonal grid. With direction on walls.", "tags": ["mazehexagon"], "likes": 23, "viewed": 1318, "published": "Public API", "date": "1444708655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\n\nfloat vlx(float2 uv, out float a)\n{\n    float v=0.0;\n    float2 lp=uv-float2(-0.5,0.5*tan(pi/6.0));\n    v=length(lp);a=atan(lp.y, lp.x);\n\n    float2 lp1=uv-float2(0.5,0.5*tan(pi/6.0));\n    float v1=length(lp1);\n    if(v1<v){v=v1;a=atan(lp1.y, lp1.x);}\n\n    float2 lp2=uv-float2( 0.0,-0.5/cos(pi/6.0));\n    float v2=length(lp2);\n    if(v2<v){v=v2;a=atan(lp2.y, lp2.x);}\n    \n    a=(a/pi*0.5+0.5);\n    \n    return v;\n}\n\nfloat4 hex(float2 uv, out float ang1, out float ang2)\n{\n    float x=uv.x;\n    float y=uv.y;\n    float h=1.0/cos(pi/6.0);\n    \n\tx+=(fract(y*h/2.0)>0.5?0.0:0.5);\n    x=fract(x)-0.5;\n    y=fract(y*h)/h-0.5/h;\n    float n=6.0;\n    float a=atan(x,y)/pi/2.0;\n    float v=length(float2(x,y));\n    float2 p=float2(0,0);\n    float2 p0=float2(sin(pi/6.0),cos(pi/6.0));\n    if(y<0.0)p0.y=-p0.y;\n    if(x<0.0)p0.x=-p0.x;\n\tfloat v0=length(float2(x,y)-p0);\n    if(v0<v)\n    {\n        v=v0;p=p0;\n\t    x=x-p.x;\n\t    y=y-p.y;\n    }\n\n    a=atan(x,y);\n    v=length(float2(x,y))*2.0;\n    v=(v*5.0+a*pi/32.0)*10.0;\n\tfloat v1=0.0;\n    float v2=0.0;\n\n    v1=vlx(float2(x,y), ang1);\n    v2=vlx(float2(x,-y), ang2);\n    return float4(x,y,v1,v2);\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{\n\tfloat2 uv = fragCoord.xy /100.0;\n    float a1=0.0;\n    float a2=0.0;\n    float4 h=hex(uv, a1, a2);\n    float v=h.z;\n    float2 ixy=uv-h.xy;\n    float a=a1;\n    v=h.z; \n    if(fract(ixy.x*0.31+sin(ixy.y*0.073+ixy.x*0.0013))>0.5)\n    {\n        v=h.w;\n        a=a2;\n    }\n    float v0=abs(v-0.5*tan(pi/6.0));\n    float a0=a;\n    a=cos((a*6.0-v0*v0*30.0+iTime*2.0)*pi)*0.5+0.5;\n\tv0=abs(v-0.5*tan(pi/6.0));\n    v=clamp(v0*100.0-10.0,0.0,1.0);\n    \n    float3 col=mix(float3(0.0,0.3+0.3*sin(uv.x*0.71),1.0),float3(1,0.3+0.3*sin(uv.y*0.93),0.1),a);\n    float3 bak=float3(sin(ixy.x*0.315)*0.5+0.5,sin(ixy.y*0.635)*0.5+0.5,.8);\n    \n    float sh=clamp(v0*8.0-0.5,0.0,1.0);\n    bak=mix(float3(1,1,2),bak,sh);\n\tfragColor = float4(mix(col*(1.0-v0*v0*60.0),bak,v),1.0);\n//    fragColor = float4(bak,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 123, 123, 504], [506, 506, 561, 561, 1228], [1230, 1230, 1291, 1291, 2086]], "test": "valid"}
{"id": "lt2XDm", "name": "Terrain Relief", "author": "gcordonnier", "description": "Simple terrain from distant view with a relief enhancing shader using exagerated ambiant occlusion.\nTested on \"elevated\" map shader (https://www.shadertoy.com/view/MdX3Rr) and standart fbm.", "tags": ["terrain", "occlusion", "distant", "relief"], "likes": 17, "viewed": 582, "published": "Public", "date": "1444469602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// terrain relief enhancing shader by Guillaume Cordonnier\n\n// key \"r\" stops the rotation\n// key \"a\" moves the terrain\n\nconst float box_x = 1.6; \nconst float box_y = 0.2;\n\nconst int RAY_ITER  = 30;\nconst int RAY_ITER_BW = 20;\nconst float AO_SMALL_PREC = 0.003;\nconst float AO_DIST = 0.1;\nconst int AO_RAY_ITER = 5;\nconst int NUM_RAY_AO = 8;\nconst int NOISE_OCTAVES = 7;\n\nfloat elevated(vec2 p);\nfloat fbm(vec2 p);\n\nbool terrainMoving = false;\nbool rotation = true;\n\nfloat map(vec2 p)\n{\n    if(terrainMoving)\n        p += iTime * vec2(0.1, 0.05);\n    \n    //  *** Choose the map function here ***\n    return elevated(p);\n}\n\n\nvec3 noised( in vec2 x );\n\n\nfloat elevated(vec2 p)\n{\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n    \n    p = p*3.0+vec2(10.0,-1.0);\n    \n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<NOISE_OCTAVES; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    return 0.1*a;\n}\n\nfloat fbm(vec2 p)\n{\n    p = p*3.0+vec2(10.0,-1.0);\n    \n    float r = 0.0;\n    float a = 1.0;\n\n    for( int i=0; i<NOISE_OCTAVES; i++ )\n    {\n        vec3 n = noised(p);\n        r+=a*n.x;\n     \ta *= 0.5;\n        p = p*2.0;\n    }\n    return 0.1*r;\n}\n\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nvec2 boxRay(in vec3 ro, in vec3 rd)\n{\n    vec3 i_p = (vec3(box_x, box_y, box_x) - ro ) / rd;\n    vec3 i_m = (-vec3(box_x,0.5*box_y, box_x) - ro ) / rd;\n    \n    vec3 vmin = min(i_p, i_m);\n    vec3 vmax = max(i_p, i_m);\n    \n    // min, max\n    return vec2(max(max(vmin.x, vmin.y), vmin.z),min(min(vmax.x, vmax.y), vmax.z));\n}\n\nfloat castray(in vec3 ro, in vec3 rd)\n{\n    \n    vec2 box = boxRay(ro, rd);\n    \n    if(box.x > box.y || box.y <= 0.0)\n        return -1.0;\n    \n    float mint = box.x;\n    float maxt = box.y;\n    \n    vec3 first = ro + rd*box.x;\n    \n    if(map(first.xz) > first.y)\n        return -2.0;\n    \n\n    \n    float delt = (maxt-mint) / float(RAY_ITER);\n    \n    float lh = 0.0;\n    float ly = 0.0;\n    float t = mint;\n    vec3  p;\n    for(int i = 0; i<RAY_ITER; i++)\n    {\n        t+= delt;\n        p = ro + rd*t;\n        float h = map( p.xz );\n        if( p.y < h )\n        {\n            delt = delt / float(RAY_ITER_BW);\n            for(int j = 0; j<RAY_ITER_BW; j++)\n            {\n                t-= delt;\n                p = ro + rd*t;\n        \t\th = map( p.xz );\n                if( p.y > h )\n            \t\treturn t - delt + delt*(lh-ly)/(p.y-ly-h+lh);\n                lh = h;\n        \t\tly = p.y;\n            }\n        }\n        lh = h;\n        ly = p.y;\n        \n    }\n    \n    return -1.0;\n    \n}\n\n//oat ao_t0;\nfloat ao_factor;\n/*id compute_ao_t0()\n{\n    ao_t0 = AO_DIST / pow(1.0 + AO_DT_FACTOR, float(AO_RAY_ITER-1));\n}*/\nvoid compute_ao_factor()\n{\n    ao_factor = pow(AO_DIST / AO_SMALL_PREC , 1.0/float(AO_RAY_ITER-1))-1.0;\n}\n\n// return lowest ray seeing the sky (angle proportion)\n// rd must be normalized and null in y\nfloat aoray(in vec3 ro, in vec3 rd)\n{\n    \n    float maxt = AO_DIST;\n    \n    float t = AO_SMALL_PREC;\n    vec3 d = rd; // cur highest dir\n\n    for(int i = 0; i<AO_RAY_ITER; i++)\n    {\n        vec3 p = ro + rd*t;\n        p.y = map( p.xz ); // p design the map point\n        float t_d = t/dot(rd, d); // compute dist between vertical at p and ro alog dir\n        vec3 p2 = ro+d * t_d; // and deduce point along d\n        if( p2.y < p.y )\n        {\n            d = normalize(p-ro);\n        } \n        t +=  ao_factor * t;       \n    }\n\n    return acos(d.y)/3.141593;\n    \n}\n\n\n\nfloat ao(vec3 p)\n{\n    float illum = 0.0;\n    \n    float th = 0.0;\n    float dth = float(NUM_RAY_AO) *0.1591549430; // 1 / (2pi)\n    \n    for(int i = 0; i<NUM_RAY_AO; i++)\n    {\n        illum += aoray(p, vec3(cos(th), 0.0, sin(th)));\n        th += dth;\n    }                        \n    \n    return illum / float(NUM_RAY_AO)*2.0-1.0;\n}\n    \n\n// key is javascript keycode\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float d = castray(ro, rd);\n    \n    if(d<-1.5) // terrain \"dress\"\n        return vec3(0.1);\n    else if(d<0.0) // background\n    {\n        return mix(vec3(0.3, 0.3, 0.3), vec3(0.2, 0.2, 0.4), gl_FragCoord.y/iResolution.y);\n    }\n    vec3 p = ro + d*rd;\n\n    //return ao(p) * mix(vec3(0.5), vec3(0.8), p.y/0.2);\n    return  mix(vec3(0.1, 0.09, 0.08), vec3(0.9, 0.8, 0.7), 0.75*ao(p) + 0.25*min(1.0, p.y/0.2)) ;\n    \n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //mpute_ao_t0();\n    compute_ao_factor();\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = 0.0;\n    \n    terrainMoving = ReadKey(65, true); // key 'a'\n    rotation = !ReadKey(82, true); // key 'r'\n    \n    if(rotation)\n        time = iTime;\n    \n\t// camera\t\n\n    vec3 ro = 0.6*vec3( 3.5*cos(0.1*time + 6.0*mo.x), 2.0 + 4.0*mo.y, 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3(0.0, -0.5, 0.0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    vec3 col = render(ro, rd);\n    \n    col = pow( col, vec3(0.4545) );\n    \n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2XDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 485, 485, 621], [652, 652, 676, 676, 1007], [1009, 1009, 1028, 1028, 1257], [1260, 1260, 1286, 1286, 1725], [1727, 1727, 1764, 1764, 2052], [2054, 2054, 2093, 2093, 3051], [3083, 3179, 3205, 3205, 3284], [3286, 3380, 3417, 3417, 3951], [3955, 3955, 3973, 3973, 4290], [4487, 4487, 4524, 4524, 4950], [4952, 4952, 5004, 5004, 5181], [5183, 5183, 5240, 5261, 6019]], "test": "error"}
{"id": "lt2XDW", "name": "StereoProj 3D", "author": "Ouid", "description": "Stereographic projection of a cube in a plane. A way for me to understand stereographic.\nI'm not used at shader programming and rendering technics. I prefer slowly but readable code to understand mathematics and algorithms involved.", "tags": ["cube", "stereographic"], "likes": 11, "viewed": 321, "published": "Public", "date": "1443879366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Mathieu Simon aka Ouid (2015)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ref : https://www.shadertoy.com/view/4sfGzS (noise)\n// ref : http://iquilezles.org/www/articles/palettes/palettes.htm (color)\n\n//#define DEBUG\n\nconst float PI = 3.14159265359;\n\nconst float GOLDEN_RATIO = 1.6180339887498;\n\nconst float DEG_TO_RAD = 0.0174533;\n\nconst float MAX = 10000.0;\n\n#define FOV 25.0\n\n#define WITH_SHADOW 1\n#define WITH_STEREO_NORMAL 0\n\n#define PLANE(_Mat,_Vec3Point,_Vec3Normal) pointAndNormToPlane ( ( (_Mat) * vec4(_Vec3Point,1.0) ).xyz, ( (_Mat) * vec4(normalize(_Vec3Normal),0.0) ).xyz )\n#define CENTRIC_PLANE(_Mat,_dist,_Vec3Normal) pointAndNormToPlane ( ( (_Mat) * vec4(_dist*_Vec3Normal,1.0) ).xyz, ( (_Mat) * vec4(normalize(_Vec3Normal),0.0) ).xyz )\n\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#define COLOR_COUNT 12\n\n#if 0\n// tetrahedron\n\n#define CENTER(_x,_y,_z) (((_x)+(_y)+(_z))/3.0)\n#define P1 vec3(1.0,1.0,1.0)\n#define P2 vec3(1.0,-1.0,-1.0)\n#define P3 vec3(-1.0,1.0,-1.0)\n#define P4 vec3(-1.0,-1.0,1.0)\n\n#define FOREACH_PLANES(_WorldMat,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P1,P2,P3)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P1,P3,P4)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P1,P2,P4)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P2,P3,P4)), Object(13))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 4\n    \n#elif 0\n//cube\n\n#define FOREACH_PLANES(_WorldMat,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(1.0,0.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(-1.0,0.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,0.0,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,0.0,-1.0)), Object(15))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 6\n\n#elif 1 \n//dodecahedron\n    \nconst float GOLDEN_DIST = (GOLDEN_RATIO*GOLDEN_RATIO) / (GOLDEN_RATIO*GOLDEN_RATIO+2.0);\n    \n#define FOREACH_PLANES(_WorldMat,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(GOLDEN_RATIO,1.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-GOLDEN_RATIO,1.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(GOLDEN_RATIO,-1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-GOLDEN_RATIO,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,1.0)), Object(15))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,-1.0)), Object(16))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,-1.0)), Object(17))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(1.0,0.0,GOLDEN_RATIO)), Object(18))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(1.0,0.0,-GOLDEN_RATIO)), Object(19))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-1.0,0.0,GOLDEN_RATIO)), Object(20))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-1.0,0.0,-GOLDEN_RATIO)), Object(21))\n    \n#undef COLOR_COUNT\n#define COLOR_COUNT 12\n    \n#endif\n    \n#define SPHERE_SIZE 2.0\n#define SPHERE_OBJECT_RATIO 1.0\n\n// structures (I love structures, sorry, C/C++ habits)\n\nstruct Ray\n{\n    vec3 m_pos;\t\t\t// start of the ray\n    vec3 m_dir;    \t\t// direction of the ray, intersect functions need \"normalized\" dir\n};\n\nstruct Camera\n{ \n    mat4\tm_matrix;\t// this matrix can be \"Left\" or \"Right\" handed...just used to compute viewRay\n};\n    \nstruct Object\n{\n    int\t\tm_id;\t\t// just an id, to find material after all raycasts\n};\n    \nstruct RaycastResult\n{\n    float\tm_d;\t\t// distance from origin of the ray that cause the result\n\tvec3\tm_pos;\t\t// position of intersection\n\tvec3\tm_normal;\t// normal of intersection\n    Object\tm_object;\t// object intersected\n};\n    \nstruct Lighting\n{\n    vec3\tm_ambient; \t// xyz = color\n    vec2\tm_shading;\n};\n    \nstruct Light\n{\n    vec3\tm_pos;\t\t// position of the light    \n    vec4\tm_spec;\t\t// xyz = color, w = intensity\n};\n    \nstruct World\n{\n    vec4 \tm_sphere; \t// xyz = pos, w = radius\n    vec4\tm_plane;  \t// xyz = normal, w = d = -dot(n,p) { mathematical form : ax+by+cz+d=0 }\n    mat4\tm_cube;   \t// matrix of the object\n    mat4\tm_inverseCube;\n};\n    \nstruct Material\n{\n    vec2\tm_spec;\t\t//x : shininess, y : ratio\n    vec3\tm_color;\n};\n    \n   \n\n// util funcs\n\nfloat maxPerElem ( in vec2 _v )\n{\n    return max(_v.x,_v.y);\n}\n\nfloat maxPerElem ( in vec3 _v )\n{\n    return max(_v.z,maxPerElem(_v.xy));\n}\n\nfloat maxPerElem ( in vec4 _v )\n{\n    return max(_v.w,maxPerElem(_v.xyz));\n}\n    \n\nvoid minRaycastResult ( inout RaycastResult _rayResultMin, in float _min, in float _max, in RaycastResult _curr )\n{\n    if ( _curr.m_d < _min )\n        return;\n    \n    if ( _curr.m_d > _max )\n        return;\n    \n    if ( _curr.m_d > _rayResultMin.m_d )\n        return;\n    \n\t_rayResultMin = _curr;\n}\n\nvoid minRaycastResult ( inout RaycastResult _rayResultMin, in RaycastResult _curr )\n{ \n    if ( _curr.m_d > _rayResultMin.m_d )\n        return;\n    \n    _rayResultMin = _curr;\n}\n\nvoid maxRaycastResult ( inout RaycastResult _rayResultMax, in float _min, in float _max, in RaycastResult _curr )\n{\n    if ( _curr.m_d < _min )\n        return;\n    \n    if ( _curr.m_d > _max )\n        return;\n    \n    if ( _curr.m_d < _rayResultMax.m_d )\n        return;\n    \n\t_rayResultMax = _curr;\n}\n\nvoid maxRaycastResult ( inout RaycastResult _rayResultMax, in RaycastResult _curr )\n{  \n    if ( _curr.m_d < _rayResultMax.m_d )\n        return;\n    \n    _rayResultMax = _curr;\n}\n    \nvec4 appendColor ( in vec4 _color, in vec4 _mul, in vec4 _add, float _ratio )\n{\n    return _color * mix(vec4(1.0),_mul,_ratio) + _ratio * _add;\n}\n\nvec3 appendColor ( in vec3 _color, in vec3 _mul, in vec3 _add, float _ratio )\n{\n    return _color * mix(vec3(1.0),_mul,_ratio) + _ratio * _add;\n}\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat supernoise(in vec3 x)\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    float f = 0.0;\n    vec3 q = x;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n\tf += 0.0625*noise( q ); q = m*q*2.01;\n    \n    return f;\n}\n\nvec3 supernoise(in vec3 p, in float delta)\n{\n    float dx = supernoise(p+delta*vec3(1.0,0.0,0.0)) - supernoise(p-delta*vec3(1.0,0.0,0.0));\n    float dy = supernoise(p+delta*vec3(0.0,1.0,0.0)) - supernoise(p-delta*vec3(0.0,1.0,0.0));\n    float dz = supernoise(p+delta*vec3(0.0,0.0,0.0)) - supernoise(p-delta*vec3(0.0,0.0,1.0));\n    \n    return vec3(dx,dy,dz);\n}\n\nfloat gridXYZ ( in vec3 _pos, in float _size, in float _ceil )\n{\n    vec3 gridPos;\n    gridPos.x = mod(_pos.x/_size+0.5,1.0);\n    gridPos.y = mod(_pos.y/_size+0.5,1.0);\n    gridPos.z = mod(_pos.z/_size+0.5,1.0);\n\n    gridPos = 2.0*abs(gridPos-vec3(0.5));\n\n    float grid = maxPerElem(gridPos);\n \n    return smoothstep(0.0,1.0,pow(grid,15.0));\n}\n\nfloat distRayRay(in vec3 _p1, in vec3 _d1, in vec3 _p2, in vec3 _d2, out float _t1, out float _t2 )\n{\n    vec3 crossNorm = cross(_d1,_d2);\n    float dist = abs(dot(_p2-_p1,crossNorm))/length(crossNorm);\n    \n    _t1 = dot(cross(_p2-_p1,_d2),crossNorm) / dot(crossNorm,crossNorm);\n    _t2 = dot(cross(_p2-_p1,_d1),crossNorm) / dot(crossNorm,crossNorm);\n    \n    return dist;\n}\n\nfloat drawLine ( in Ray _r1, in Ray _r2, in float _dMax )\n{\n    float t1, t2;\n    float dist = distRayRay(_r1.m_pos, _r1.m_dir, _r2.m_pos, _r2.m_dir, t1, t2 );\n    \n    if ( dist > _dMax )\n        return 0.;\n    \n    return 1.0-smoothstep(0.0,1.0,dist/_dMax);\n}\n\nfloat drawSeg ( in Ray _seg1, in Ray _ray, in float _dMax )\n{\n    float t1, t2;\n    float dist = distRayRay(_seg1.m_pos, _seg1.m_dir, _ray.m_pos, _ray.m_dir, t1, t2 );\n    \n    if ( t1 < 0.0 )\n        return 0.0;\n        \n\tif ( t1 > 1.0 )\n        return 0.0;\n    \n    if ( dist > _dMax )\n        return 0.;\n    \n    return 1.0-smoothstep(0.0,1.0,dist/_dMax);\n}\n\nmat4 rotationX ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,cos(_angle),sin(_angle),0.0);\n    mat[2] = vec4(0.0,-sin(_angle),cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);    \n    return mat;\n}\nmat4 rotationY ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),0.0,-sin(_angle),0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(sin(_angle),0.0,cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\nmat4 rotationZ ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),sin(_angle),0.0,0.0);\n    mat[1] = vec4(-sin(_angle),cos(_angle),0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 scale (vec3 _scale)\n{\n    mat4 mat;\n    mat[0] = vec4(_scale.x,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,_scale.y,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,_scale.z,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 translate (vec3 _translation)\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(_translation,1.0);\n    return mat;\n}\n\n// raycCast funcs\n    \nbool intersectRayPlane(in vec3 _start, in vec3 _dir, in vec4 _plane, in Object _object, out RaycastResult _rayResult )\n{\n    float dotDir = dot (_dir,_plane.xyz);\n    \n    _rayResult.m_d = - ( dot(_start,_plane.xyz) + _plane.w ) / ( dotDir );\n\t_rayResult.m_pos = _start + _dir * _rayResult.m_d;\n\t_rayResult.m_normal = _plane.xyz;\n\t_rayResult.m_object = _object;\n    \n    if ( abs(dotDir)<0.000001 )\n        return false;\n    \n    return true;\n}\n\nvoid intersectRayPlaneRange (in vec3 _start, in vec3 _dir, in vec4 _plane, in Object _object, inout RaycastResult _rayResFront, inout RaycastResult _rayResRear )\n{\n    RaycastResult curr;\n    if ( intersectRayPlane ( _start, _dir, _plane, _object, curr ) )\n    {\n        if ( dot(_dir,_plane.xyz) > 0.0 )\n        {\n            minRaycastResult ( _rayResRear, curr );\n        }\n        else\n        {\n            maxRaycastResult ( _rayResFront, curr );\n        }\n    }\n}\n\nvoid intersectRayPlaneRear (in vec3 _start, in vec3 _dir, in vec4 _plane, in float _min, in float _max, in Object _object, inout RaycastResult _rayResRear )\n{\n    RaycastResult curr;\n    if ( intersectRayPlane ( _start, _dir, _plane, _object, curr ) )\n    {\n        //if ( dot(_dir,_plane.xyz) < 0.0 )\n        {\n            minRaycastResult ( _rayResRear, _min, _max, curr );\n        }\n    }\n}\n\nbool intersectRaySphere(in vec3 _start, in vec3 _dir, in vec4 _sphere, in Object _object, inout RaycastResult _rayResult1, inout RaycastResult _rayResult2 )\n{\n    vec3 centerToStart = _start - _sphere.xyz;\n    float projCenterToStart = dot ( _dir, centerToStart );\n    \n    float b2m4ac = projCenterToStart*projCenterToStart - dot(centerToStart,centerToStart) + _sphere.w*_sphere.w;\n\n    if ( b2m4ac < 0.0 )\n    {\n        return false;\n    }\n    else\n    {\n        _rayResult1.m_d = -projCenterToStart - sqrt(b2m4ac);\n\t\t_rayResult1.m_pos = _start + _rayResult1.m_d * _dir;\t\t\n\t\t_rayResult1.m_normal = normalize(_rayResult1.m_pos-_sphere.xyz);\n\t\t_rayResult1.m_object = _object;\n    \t_rayResult2.m_d = -projCenterToStart + sqrt(b2m4ac);\n\t\t_rayResult2.m_pos = _start + _rayResult2.m_d * _dir;\n\t\t_rayResult2.m_normal = normalize(_rayResult2.m_pos-_sphere.xyz);\n\t\t_rayResult2.m_object = _object;\n        return true;\n    }\n}\n\nvoid initRaycastResult ( inout RaycastResult _rayResult )\n{\n    _rayResult.m_d = MAX;\n    _rayResult.m_object.m_id = 0;    \n}\n\nvoid rayCastSphere ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{\n    RaycastResult rayR1, rayR2;\n    \n\tif ( intersectRaySphere(_ray.m_pos, _ray.m_dir, _world.m_sphere, Object(1), rayR1, rayR2 ) )\n    {\n        minRaycastResult ( _rayResult, _min, _max, rayR1 );\n        minRaycastResult ( _rayResult, _min, _max, rayR2 );\n    }   \n}\n\nvoid rayCastPlane( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{\n    RaycastResult rayResult;\n    if ( intersectRayPlane ( _ray.m_pos, _ray.m_dir, _world.m_plane, Object(2), rayResult ) )\n    {\n        minRaycastResult ( _rayResult, _min, _max, rayResult );\n    }    \n}\n\nvec4 pointAndNormToPlane ( in vec3 _p, in vec3 _n )\n{\n    return vec4 ( _n, -dot(_p,_n) );\n}\n\n\n\nvoid rayCastCube ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{  \n    RaycastResult rayResFront, rayResRear;\n    \n    rayResFront.m_d = _min;\n    rayResRear.m_d = _max;\n    \n\t#define INTERSECT_PLANE_RANGE(_Plane,_PlaneId) intersectRayPlaneRange ( _ray.m_pos, _ray.m_dir, _Plane, _PlaneId, rayResFront, rayResRear );\n\tFOREACH_PLANES(_world.m_cube,INTERSECT_PLANE_RANGE)\n        \n    // if front result is far (more than rear) we're outside of the convex\n    if ( rayResFront.m_d > rayResRear.m_d )\n    {\n        return;\n    }\n    \n    minRaycastResult ( _rayResult, _min, _max, rayResFront );\n}\n\nvoid rayCastCubeRear ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{  \n    RaycastResult rayResRear;\n    \n    rayResRear.m_d = _max;\n    \n    // a cube is convex, so we can intersect all planes, this will give us a range of frontal max and rear min\n\t\n\t#define INTERSECT_PLANE_REAR(_Plane,_PlaneId) intersectRayPlaneRear ( _ray.m_pos, _ray.m_dir, _Plane,  _min, _max, _PlaneId, rayResRear );\n\tFOREACH_PLANES(_world.m_cube,INTERSECT_PLANE_REAR)\n    \n    minRaycastResult ( _rayResult, _min, _max, rayResRear );\n}\n\nvoid rayCastWorld ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{\n    //rayCastSphere ( _world, _rayResult, _ray, _min, _max );\n    rayCastPlane ( _world, _rayResult, _ray, _min, _max );\n    rayCastCube ( _world, _rayResult, _ray, _min, _max );\n}\n\n// Stereographic projection\n\nvoid stereographicProj ( in World _world, in vec3 _pos, out RaycastResult _rayResult, out Ray _ray )\n{\n    // this function is basic, with 2 raycasts (from point to sphere, and sphere to cube)\n    // there are a lot of way to optimize it\n    \n    vec3 topSphere = _world.m_sphere.xyz + _world.m_sphere.w * _world.m_plane.xyz;\n    \n    // PTTS : PointToTopSphere\n    Ray rayPTTS; \n    rayPTTS.m_pos = _pos;\n    rayPTTS.m_dir = normalize(topSphere-_pos);\n    \n    RaycastResult rayResultPTTS;\n    initRaycastResult ( rayResultPTTS );\n    \n    rayCastSphere ( _world, rayResultPTTS, rayPTTS, 0.0, MAX);\n    \n    // STC : SphereToCube\n    Ray raySTC; \n    _ray.m_pos = rayResultPTTS.m_pos;\n    _ray.m_dir = normalize ( _world.m_cube[3].xyz - rayResultPTTS.m_pos );\n    \n    initRaycastResult ( _rayResult );\n    \n    rayCastCube ( _world, _rayResult, _ray, -MAX, MAX );\n}\n\n\n\n// standard [image -> screen -> view -> world] funcs\n\nvec2 imageToScreen ( in vec2 _uv )\n{\n    vec2 ratioUV = _uv.xy / iResolution.xy;\n    vec2 ratio = 2.0*iResolution.xy/vec2(min(iResolution.x,iResolution.y));\n    vec2 xy = (ratioUV*2.0-1.0)*ratio;\n    return xy;\n}\n\nvoid screenToWorld ( in Camera _camera, in vec2 _screenPos, float _z, out vec3 _pos )\n{\n    _pos = (_camera.m_matrix * vec4(_screenPos,_z,1.0)).xyz;    \n}\n\nvoid screenToRay ( in Camera _camera, in vec2 _screenPos, out Ray _ray )\n{\n    vec3 rayPoint;\n    \n    //fov is hardcoded here (distance of Z plane)\n    screenToWorld ( _camera, _screenPos, 1.0 / tan ( DEG_TO_RAD * FOV / 2.0), rayPoint );        \n    \n    _ray.m_pos = _camera.m_matrix[3].xyz;\n    _ray.m_dir = normalize(rayPoint-_ray.m_pos);\n}\n\nvoid cameraLookAt ( in vec3 _eye, in vec3 _lookAtPos, in vec3 _up, out Camera _camera )\n{\n    vec3 front = normalize(_lookAtPos-_eye);    \n    vec3 left = normalize(cross(front, _up));\n    vec3 up = normalize(cross(left,front));\n    _camera.m_matrix[0] = vec4(left,0.0);\n    _camera.m_matrix[1] = vec4(up,0.0);\n    _camera.m_matrix[2] = vec4(front,0.0);\n    _camera.m_matrix[3] = vec4(_eye,1.0);\n}\n\n// color funcs\n\nvoid computeMaterial ( in World _world, inout RaycastResult _rayResult, out Material _material )\n{\n    if ( _rayResult.m_object.m_id == 1 )\n    {\n        _material.m_color = vec3(1.0);\n        _material.m_spec = vec2(1.0,0.0);\n    }\n    else if ( _rayResult.m_object.m_id == 2 )\n    {\n        _material.m_color = vec3(0.5);\n        _material.m_spec = vec2(1.0,0.0);\n    }\n    else if ( _rayResult.m_object.m_id >= 10  )\n    {\n        float ratio = mod(float(_rayResult.m_object.m_id-9)+5.0,float(COLOR_COUNT)) / float(COLOR_COUNT);\n        vec3 a = vec3(0.28,0.5,0.5)*1.3;\n        vec3 b = vec3(0.5,0.2,0.5);\n        vec3 c = vec3(1.0,1.0,0.0);        \n        vec3 d = vec3(0.5,0.3, 0.25);\n        \n        //http://iquilezles.org/www/articles/palettes/palettes.htm\n        _material.m_color = a+b*cos(2.0*3.141592*(c*ratio+d));\n        _material.m_spec = vec2(10.0,1.0);\n\n\t\tvec4 localPos = _world.m_inverseCube * vec4(_rayResult.m_pos,1.0);\n\t\t\n        float grid = supernoise(localPos.xyz*20.0);\n        \n        //_rayResult.m_normal = normalize ( _rayResult.m_normal-0.5*supernoise(localPos.xyz*20.0, 0.1));\n        \n        //_material.m_color = appendColor(_material.m_color,vec3(0.90),vec3(-0.),grid); \n\n    }\n    else   \n    {\n        _material.m_color = vec3(0.0);\n        _material.m_spec = vec2(1.0,0.0);\n    }\n    \n    \n}\n\n\nvoid stereographicProjDebug ( in World _world, in Camera _cam, in vec2 _uv, out vec3 _p1, out vec3 _p2, out vec3 _p3 )\n{\n    Ray rayMouse;\n    RaycastResult rayResultMouse;\n    \n    vec2 mouseXY = imageToScreen ( _uv );\n    \n    initRaycastResult ( rayResultMouse );\n    screenToRay (_cam, mouseXY, rayMouse );\n    \n    Ray stDebugRay;\n    RaycastResult stDebugInter, stDebugViaInter;\n    \n    rayCastPlane ( _world, rayResultMouse, rayMouse, 0.0, MAX );\n    \n    // this function is basic, with 2 raycasts (from point to sphere, and sphere to cube)\n    // there are a lot of way to optimize it\n    \n    vec3 topSphere = _world.m_sphere.xyz + _world.m_sphere.w * _world.m_plane.xyz;\n    \n    // PTTS : PointToTopSphere\n    Ray rayPTTS; \n    rayPTTS.m_pos = rayResultMouse.m_pos;\n    rayPTTS.m_dir = normalize(topSphere-rayResultMouse.m_pos);\n    \n    RaycastResult rayResultPTTS;\n    initRaycastResult ( rayResultPTTS );\n    \n    rayCastSphere ( _world, rayResultPTTS, rayPTTS, 0.0, MAX);\n    \n    // STC : SphereToCube\n    Ray raySTC; \n    raySTC.m_pos = rayResultPTTS.m_pos;\n    raySTC.m_dir = normalize ( _world.m_cube[3].xyz - rayResultPTTS.m_pos );\n    \n    RaycastResult resultSTC;\n    initRaycastResult ( resultSTC );\n    \n    rayCastCube ( _world, resultSTC, raySTC, 0.0, MAX );\n    \n    _p1 = rayResultMouse.m_pos;\n    _p2 = rayResultPTTS.m_pos;\n    _p3 = resultSTC.m_pos;\n}\n\n// lighting is black magic for me, just sum up some sort of diffuse + spec things\n\nvec3 computeLighting ( in World _world, in Lighting _lighting, in Light _light, in Material _material, in Ray _viewRay, in RaycastResult _rayResult )\n{\n    vec3 light = normalize( _light.m_pos - _rayResult.m_pos );\n    float dotLight = dot(light,_rayResult.m_normal);\n    float lightIntensity = max(dotLight,0.) * _lighting.m_shading.y + _lighting.m_shading.x;\n    \n    float visibility = 1.0;\n    \n    // shadow (only if light)\n    #if WITH_SHADOW\n    if ( dotLight > 0.01 )\n    {\n        Ray shadowRay;\n        shadowRay.m_pos = _light.m_pos;\n        shadowRay.m_dir = normalize(_rayResult.m_pos - _light.m_pos);\n\n        RaycastResult shadowInter;\n        initRaycastResult ( shadowInter );\n        rayCastWorld ( _world, shadowInter, shadowRay, 0.0, MAX);\n\n        if ( shadowInter.m_object != _rayResult.m_object )\n        {        \n            visibility = _lighting.m_shading.x;\n        } \n    }\n    #endif\n    \n    vec3 color = _material.m_color.xyz * lightIntensity;\n\n    // specular\n    vec3 r = normalize(2.0 * dot(light, _rayResult.m_normal) * _rayResult.m_normal - light);\n    vec3 v = normalize(_viewRay.m_dir);\n\n    float dotSpec = max(dot(r, -v),0.0);\n    float powSpec = clamp(pow(dotSpec,_material.m_spec.x),0.0,1.0);\n    float specular = ( _light.m_spec.w * powSpec * length(color) ) * _material.m_spec.y;\n       \n    \n    return ( color + specular * _light.m_spec.xyz ) * visibility;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// setup world, cam & light\n    \n    Camera cam;\n    World world;    \n     \n    world.m_sphere = vec4(0.0,SPHERE_SIZE,0.0,SPHERE_SIZE);\n    world.m_plane = vec4(0.0,1.0,0.0,0.0);\n    \n    mat4 rot = rotationZ ( iTime*1.278914) * rotationY(iTime) * rotationX(iTime*0.332567);\n    mat4 inverseRot = rotationX(-iTime*0.332567) * rotationY(-iTime) * rotationZ ( -iTime*1.278914) ;\n    \n    float scaleFactor = SPHERE_OBJECT_RATIO * world.m_sphere.w/sqrt(3.0);\n    world.m_cube = translate (world.m_sphere.xyz) * scale ( vec3(scaleFactor) ) * rot;    \n    world.m_inverseCube = inverseRot * scale ( 1.0/vec3(scaleFactor) ) * translate (-world.m_sphere.xyz);    \n    \n\n    \n    vec2 eye = vec2(0.0);\n    \n#ifndef DEBUG\n    eye = iMouse.xy/iResolution.xy;\n#endif\n    \n    cameraLookAt ( vec3(10.0-20.0*(eye.x),10.0+20.0*(eye.y),10.0), vec3(0.0,1.0,0.0), vec3(0.0,1.0,0.0), cam );\n    \n    // compute raytrace\n    vec2 xy = imageToScreen ( fragCoord );    \n        \n    Ray viewRay;\n    \n    screenToRay ( cam, xy, viewRay );\n    \n    RaycastResult rayResult;\n    initRaycastResult ( rayResult );\n    \n    rayCastWorld ( world, rayResult, viewRay, 0.0, MAX );\n     \n    Material material;   \n    computeMaterial ( world, rayResult, material );   \n    \n    // if plane => stereographicProj to obtain color\n    if ( rayResult.m_object.m_id == 2 )\n    {\n        Ray stRay;\n        RaycastResult stInter;\n        stereographicProj ( world, rayResult.m_pos, stInter, stRay );\n        \n        Material material2 ;\n        computeMaterial ( world, stInter, material2 );\n        \n        material.m_color = material2.m_color;\n        \n        #if WITH_STEREO_NORMAL\n        rayResult.m_normal = -stInter.m_normal;\n        #endif\n    }\n    \n    // render with 2 lights, we can add more lights, but it would be great to add a distance attenuation    \n    \n    // I'm so bad in specular settings and lighting in general, sorry\n    Lighting lighting = Lighting ( vec3(0.15), vec2(0.2,0.3) );\n       \n    Light light1 = Light ( vec3(5.0,10.0,5.00), vec4(vec3(1.0),1.0 ) );\n    Light light2 = Light ( vec3(-10.0,20.0,0.0), vec4(vec3(1.0),1.0 ) );\n    \n    vec3 color = lighting.m_ambient;\n    \n    color += computeLighting (world, lighting, light1, material, viewRay, rayResult );\n    color += computeLighting (world, lighting, light2, material, viewRay, rayResult );\n    \n    fragColor = vec4(clamp(color,0.0,1.0),1.0);\n    \n#ifdef DEBUG\n    \n    vec3 p1, p2, p3;\n    stereographicProjDebug ( world, cam, iMouse.xy, p1, p2, p3 );\n\n    vec3 pa, pb, pc;\n    stereographicProjDebug ( world, cam, iMouse.zw, pa, pb, pc );\n    \n    Ray seg1 = Ray (p1,p2-p1); Ray seg2 = Ray (p2,p3-p2);\n    Ray sega = Ray (pa,pb-pa); Ray segb = Ray (pb,pc-pb);\n    \n    \n    RaycastResult inCubeResult;\n    Ray inCubeRay = Ray ( pc, normalize(p3-pc) );\n    \n    rayCastCubeRear ( world, inCubeResult, inCubeRay, 0.0, MAX );\n    \n    //Ray segInCube = Ray ( pc, inCubeResult.m_pos - pc );\n    \n    inCubeResult.m_d = MAX;    \n       \n    RaycastResult debugR;\n    debugR.m_d = MAX;\n\t\n\t#define INTERSECT_PLANE_REAR_MAX(_Plane,_PlaneId) intersectRayPlaneRear ( inCubeRay.m_pos, inCubeRay.m_dir, _Plane,  0.0, MAX, _PlaneId, debugR );\n\tFOREACH_PLANES(world.m_cube,INTERSECT_PLANE_REAR_MAX)    \n    \n    minRaycastResult ( inCubeResult, 0.0, MAX, debugR );\n    \n\tRay segInCube = Ray ( pc, debugR.m_pos - pc );\n    \n    vec3 onSphere = world.m_sphere.xyz + (normalize(debugR.m_pos-world.m_sphere.xyz))*world.m_sphere.w;\n    float twoRadius = 2.0*world.m_sphere.w;\n    vec3 onPlane = onSphere  * ( twoRadius / (twoRadius - onSphere.y));\n\tonPlane.y = 0.0;\n\n    float lineRatio = 0.0;\n\n\tMaterial materialD ;\n\tcomputeMaterial ( world, inCubeResult, materialD );\n    \n    lineRatio = max ( lineRatio, max( drawSeg ( seg1, viewRay, 0.02 ), drawSeg ( seg2, viewRay, 0.02 ) ) );\n    lineRatio = max ( lineRatio, max( drawSeg ( sega, viewRay, 0.02 ), drawSeg ( segb, viewRay, 0.02 ) ) );\n\n    lineRatio = max ( lineRatio, drawSeg(segInCube, viewRay, 0.02) );\n    lineRatio = max ( lineRatio, drawSeg(Ray(sega.m_pos,(onPlane - sega.m_pos)), viewRay, 0.02) );\n    \n    vec3 lineColor = materialD.m_color;\n    \n    fragColor.xyz = appendColor(fragColor.xyz, lineColor, lineColor, lineRatio );\n#endif\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2XDW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[4576, 4576, 4609, 4609, 4638], [4640, 4640, 4673, 4673, 4715], [4717, 4717, 4750, 4750, 4793], [4800, 4800, 4915, 4915, 5101], [5103, 5103, 5188, 5188, 5280], [5282, 5282, 5397, 5397, 5583], [5585, 5585, 5670, 5670, 5763], [5769, 5769, 5848, 5848, 5914], [5916, 5916, 5995, 5995, 6061], [6063, 6109, 6132, 6132, 6168], [6169, 6169, 6195, 6195, 6564], [6566, 6566, 6595, 6595, 6945], [6947, 6947, 6991, 6991, 7307], [7309, 7309, 7373, 7373, 7653], [7655, 7655, 7756, 7756, 8030], [8032, 8032, 8091, 8091, 8293], [8295, 8295, 8356, 8356, 8655], [8657, 8657, 8690, 8690, 8903], [8904, 8904, 8937, 8937, 9146], [9147, 9147, 9180, 9180, 9389], [9391, 9391, 9417, 9417, 9608], [9610, 9610, 9646, 9646, 9823], [9848, 9848, 9968, 9968, 10292], [10294, 10294, 10457, 10457, 10764], [10766, 10766, 10924, 10924, 11159], [11161, 11161, 11319, 11319, 12079], [12081, 12081, 12140, 12140, 12206], [12208, 12208, 12323, 12323, 12591], [12593, 12593, 12706, 12706, 12911], [12913, 12913, 12966, 12966, 13005], [14215, 14215, 14329, 14391, 14510], [14541, 14541, 14643, 14778, 15408], [15466, 15466, 15502, 15502, 15678], [15680, 15680, 15767, 15767, 15834], [15836, 15836, 15910, 15910, 16180], [16182, 16182, 16271, 16271, 16579], [16597, 16597, 16695, 16695, 17930], [17933, 17933, 18053, 18053, 19316], [19401, 19401, 19552, 19552, 20806]], "test": "error"}
{"id": "ltBXWw", "name": "noise planet attempt 1", "author": "cabbibo", "description": "trying to make clouds, and in failing also failed to make a planet....", "tags": ["noise", "volumetric"], "likes": 4, "viewed": 246, "published": "Public", "date": "1444067234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n// q is point\n// n is normal\n// p is point on plane\nvec3 projOnPlane( vec3 q, vec3 p , vec3 n){\n    \n    vec3 v = q - dot(q - p, n) * n;\n    return v;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 0.3 + 10.0*mouse.x;\n\tcamPos = vec3(5.5*sin(an),0.,5.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\nfloat noise(in vec3 x) //3d noise from iq\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\n\nfloat density( vec3 p ){\n return (fbm(p*0.3)-0.1) + sin(p.x*0.24 + sin(p.z*.01)*7.)*0.22+0.15 + sin(p.z*0.08)*0.05;   \n}\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n   \n    // using super thin cube as plane\n    vec3 size = vec3( 1.  , 1. , .01 );\n   // vec3 rot = vec3( iTime * .1 , iTime * .4 , -iTime * .3 );\n    vec3 rot = vec3( 0.,0.,0. );\n   //\tvec2 res = vec2( rotatedBox( pos , rot , size , .001 ) , 1.0 );\n    \n    vec2 res = vec2( sdSphere( pos , 2. ) , 1. );\n\n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n#define STEPS 4\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float dVal = dot( rd , n );\n    float lum = 1.;\n    float step = 0.;\n    float val = 0.;\n    \n    vec3 col = vec3( 0. );\n    float broken = 0.;\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * 2. * (float(i) / float(STEPS));\n    \tval += snoise( p * .5   -vec3( iTime ) * .01   );\n        val += snoise( p * 1.5  +vec3( iTime ) * .1  ) * .7;\n        val += snoise( p * 3.5  -vec3( iTime ) * .1  ) * .3;\n        val += snoise( p * 10.5 +vec3( iTime ) * .1  ) * .05;\n        col +=  vec3( val + 3.) * ( 1. - float( i ) / float( STEPS ));\n        step = float(i);\n        \n        // float blend = clamp(  ( val - .4 ) * 20.  , 0. , 1. );\n    \n\n       // if( val > .4 ){ broken = 1.; break; }\n        \n       \n    }\n    \n   // float blend = clamp(  val + 1.4  , 0. , 1. );\n    \n    col *= col * .03 /  float( STEPS );\n\t//col = hsv( val * .1 , 1. , 1. ) * val * .1;\n   \n    return col;\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    mat3 basis = mat3(\n     \n        1. , 0. , 0. ,\n        0. , 1. , 0. ,\n        0. , 0. , 1.\n       \n    );\n        \n   \n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        \n        vec3 depthColor = fogCube( pos , rd , norm  );\n \n        col += depthColor;//lum  * vec3( 1. , .6 , 0.2);\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 370, 370, 502], [505, 557, 600, 600, 657], [659, 711, 733, 733, 758], [759, 759, 780, 780, 860], [896, 948, 991, 991, 1294], [1692, 1692, 1713, 1713, 1762], [1764, 1764, 1785, 1785, 1834], [1836, 1836, 1858, 1858, 1898], [1900, 1900, 1928, 1928, 1980], [1982, 1982, 2006, 2006, 4152], [4155, 4155, 4182, 4182, 4245], [4250, 4250, 4281, 4281, 4319], [4322, 4322, 4367, 4367, 4407], [4410, 4410, 4445, 4445, 4469], [4471, 4502, 4566, 4566, 4744], [4746, 4746, 4827, 4827, 4940], [4942, 5015, 5038, 5038, 5144], [5146, 5146, 5169, 5169, 5275], [5277, 5277, 5300, 5300, 5409], [5412, 5412, 5438, 5438, 5507], [5509, 5509, 5571, 5571, 5665], [5667, 5667, 5710, 5710, 5919], [5921, 5921, 5943, 5943, 6098], [6101, 6101, 6125, 6125, 6221], [6225, 6319, 6348, 6348, 6391], [6393, 6477, 6498, 6542, 6828], [6832, 6832, 6880, 6880, 7347], [8326, 8439, 8470, 8470, 8696], [8700, 8700, 8757, 8757, 9779]], "test": "error"}
{"id": "ltjSDm", "name": "Scanline Noise w/ Mouse Touch", "author": "Retrotation", "description": "http://www.mattolick.com\n\nClicking the screen will subtly highlight and follow the mouse. ", "tags": ["noise", "mouse", "blending", "scanline", "blend", "tracking", "touch"], "likes": 6, "viewed": 2508, "published": "Public API", "date": "1444349158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// defining Blending functions\n#define Blend(base, blend, funcf) \t\tvec4(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b), funcf(base.a, blend.a))\n#define BlendOverlayf(base, blend) \t(base < 0.5 ? (1.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n#define BlendOverlay(base, blend) \t\tBlend(base, blend, BlendOverlayf)\n#define BlendAddf(base, blend) \t\tmin(base + blend, 1.0)\n#define BlendAdd(base, blend) \t\tmin(base + blend, vec4(1.0))\n\n\n// animated noise function\nfloat snoise(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// distance calculation between two points\nfloat dist(vec2 p0, vec2 pf){\n    return sqrt((pf.x-p0.x)*(pf.x-p0.x)+(pf.y-p0.y)*(pf.y-p0.y));\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// defining extra variables\n\nconst float speed     = 10.00; \n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// FRAGMENT SHADER\n\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n// add some movement\n    vec2  offset = vec2(0.0, iTime) * speed;\n\n    \n    vec2 pixelCoord = fragCoord + offset;\n\n// basic uv sampling\n    vec2 uv = floor(pixelCoord) * 2.0;\n \n// solid color for the background  \n    vec4 backcolor = vec4(0.22, 0.22, 0.22, 1.0);     \n       \n// generate scanlines from noise image, by stretching UV coordinates along Y-axis\n  \tvec4 scanlines = texture(iChannel0, uv  / iResolution.xy * vec2(0.0,1.0));\n  \n// use an 'Overlay' function similar to Photoshop's, to blend the scanlines and backcolor together  \n    vec4 firstpass = BlendOverlay(backcolor, scanlines);\n\n/////////////////////////////    \n   \n\n// generate animated noise    \n    float n = snoise(vec2(pixelCoord.x*cos(iTime),pixelCoord.y*tan(iTime))); \n \n// blend animated noise with the firstpass, using 'Overlay' function defined at the beginning of shader-code\n    vec4 secondpass = BlendOverlay(firstpass, vec4(n, n, n, 1.0));\n    \n/////////////////////////////           \n  \n    \n// calculate the distance between: the current pixel location, and the mouse position\n    float d = dist(fragCoord.xy,iMouse.xy);\n        \n// change the size of the gradient-distance over time, multiplied by \n    d = d*(sin(iTime)+7.0)*0.003;\n    \n// control the falloff of the gradient with a power/exponent, and multiply 'd' by the animated noise\n    d = pow(d*n,0.5);\n  \n// clamp the values of 'd', so that gradientgen cannot go below a 0.05 value\n    d = min(d,1.0);\n  \n// list the max,min gradient values, and linearly interpolate between the values using 'd' as a scale\n    vec4 gradientgen = mix(vec4(0.1, 0.1, 0.1, 1.0), vec4(0.05, 0.05, 0.05, 1.0), d);\n\n// blend the second pass and the mouse-controlled gradient together\n    vec4 thirdpass = BlendAdd(secondpass, gradientgen);\n  \n// final output     \n    color = thirdpass;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[474, 501, 526, 526, 598], [601, 644, 673, 673, 741], [1033, 1033, 1086, 1107, 2901]], "test": "error"}
{"id": "ltjXRV", "name": "Random Lines Flowing", "author": "vamoss", "description": "Studying lines from the book of shaders by Patricio Gonzales.", "tags": ["lines", "random"], "likes": 13, "viewed": 342, "published": "Public", "date": "1445139234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\n\nfloat barra(vec2 _st, float _width){\n    float pct0 = smoothstep(_st.x-_width,_st.x,_st.y);\n    pct0 *= 1.-smoothstep(_st.x,_st.x+_width,_st.y);\n\treturn pct0;\n}\n\nfloat contrabarra(vec2 _st, float _width){\n    float pct1 = smoothstep(_st.x-_width,_st.x,1.0-_st.y);\n    pct1 *= 1.-smoothstep(_st.x,_st.x+_width,1.0-_st.y);\n\treturn pct1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n\t\n    vec2 centerSt = st-0.5;\n    float r = length(centerSt)*2.0;\n    float a = atan(centerSt.y,centerSt.x);\n    \n    st *= 10.0; // Scale the coordinate system by 10\n    vec2 ipos = floor(st);  // get the integer coords\n    \n    st = tile(st,1.0);\n\n    vec2 localCenterSt = st-0.5;\n    float localR = length(localCenterSt)*2.0;\n    float localA = atan(localCenterSt.y,localCenterSt.x);\n    \n    float rotating=step(PI/4.,abs(cos((localA+iTime+(r*3.0)))));\n    float randX = random( ipos+rotating)+rotating;\n    //float randX = random(ipos+iTime/2000000.);\n    \n    vec3 color = vec3(0.0); \n    \n    //colors\n    if(randX>0.75){\n        color = vec3(0.0, 0.4, 0.4) + color;\n    }else if(randX>0.5){\n        color = vec3(0.0, 0.7, 0.4) + color;\n    }else if(randX>0.25){\n        color = vec3(0.0, 0.4, 1.0) + color;\n    }else{\n        color = vec3(0.0, 0.0, 0.4) + color;\n    }\n    color.r = 1.-abs(sin(r+u_time*2.0));\n    \n    //slashes\n    if(randX>0.5){\n        color *= vec3(barra(st,0.06));\n    }else{\n        color *= vec3(contrabarra(st,0.06));\n    }\n   //color=vec3(rotating);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 168, 168, 277], [279, 279, 312, 312, 355], [358, 358, 394, 394, 518], [520, 520, 562, 562, 694], [696, 696, 753, 753, 1917]], "test": "error"}
{"id": "ltjXzt", "name": "Verlet Spider!", "author": "Dave_Hoskins", "description": "It uses Verlet Integration to place the 'knees' correctly.", "tags": ["3d", "raymarching", "spider", "verlet"], "likes": 63, "viewed": 3258, "published": "Public API", "date": "1446331115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Verlet Spider. By David Hoskins - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// It uses Verlet Integration to place the 'knees' correctly.\n\n// https://www.shadertoy.com/view/ltjXzt\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nstruct SPID_LEGS\n{\n    vec3 point;\n    vec3 knee;\n    vec3 ankle;\n    vec3 fix;\n};\n\n    \nSPID_LEGS spiderLegs[8];\nfloat gTime;\nvec3 body = vec3(0.0);\nvec2 add = vec2(1.0, 0.0);\n\n\n//----------------------------------------------------------------------------------------\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise11(float n)\n{\n    float f = fract(n);\n     f = f*f*(3.0-2.0*f);\n    n = floor(n);\n    return mix(hash11(n),  hash11(n+1.0), f);\n}\n\n//----------------------------------------------------------------------------------------\nfloat  sphere(vec3 p, vec3 x, float s )\n{\n    return length(p-x)-s;\n}\n\n//----------------------------------------------------------------------------------------\nfloat  ass(vec3 p, vec3 x, float s )\n{\n    return length((p-x)* vec3(1., 1.0, .8)) - s;\n}\n\n//----------------------------------------------------------------------------------------\nfloat upperLeg( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r*(sin(h*2.14+.4));\n}\n\nfloat upperLegCE( vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tfloat d =  length( pa - ba*h ) - r*(sin(h*2.14+.4));\n\tif (d< .05)\n     \treturn h;\n        else return -1.0;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat lowerLeg(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n//----------------------------------------------------------------------------------------\nfloat lowerLegCE(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h ) - r1 + r2*h;\n\tif (d< .05)\n     \treturn h;\n        else return -1.0;\n}\n\n//----------------------------------------------------------------------------------------\nfloat smoothMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n//----------------------------------------------------------------------------------------\n// Map the distance estimation...\nfloat mapDE(vec3 p)\n{\n    float d;\n\n    // Body...\n    d = ass(p, body+vec3(0.0, 0.1, -1.7), .9);\n    d = smoothMin(d, sphere(p, body+vec3(0.0, 0., .5 ), .65), .8);\n    // Eight legs....\n    for (int i = 0; i < 8; i++)\n    {\n        d = min(d, upperLeg(p, spiderLegs[i].fix, spiderLegs[i].knee, .18)); \n        d = min(d, upperLeg(p, spiderLegs[i].knee, spiderLegs[i].ankle, .16)); \n        d = min(d, lowerLeg(p, spiderLegs[i].ankle, spiderLegs[i].point, .1, .08)); \n    }\n    \n    // Mirror down body...\n    p.x = abs(p.x);\n    // Eyeballs...\n    d = min(d, sphere(p, body+vec3(0.2, 0.4, .93 ), .18));\n    d = min(d, sphere(p, body+vec3(0.11, 0.14, 1.1), .08));\n    // Mandible parts..\n    d = min(d, lowerLeg(p, body+vec3(0.2, 0., 1. ), body+vec3(0.07, -.4, 1.24), .12,.12));\n    return d;\n}\n\n//----------------------------------------------------------------------------------------\n// Map the colour material...\nvec3 mapCE(vec3 p)\n{\n    // Default red...\n    vec3 mat  = vec3(.1, 0.0, 0.0);\n\n    \n    float d = ass(p, body+vec3(0.0, 0.1, -1.7), 1.);\n    if (d< .05)\n        mat  = mix(vec3(.05, 0.02, .0),mat, clamp((p.z-body.z+.7)*4.0, 0.0, 1.0));\n        \n    d = smoothMin(d, sphere(p, body+vec3(0.0, 0., .5 ), .65), .8);\n    \n        // Eight legs....\n    for (int i = 0; i < 8; i++)\n    {\n        float h = -1.0, h2 = h;\n        h = max(upperLegCE(p, spiderLegs[i].fix, spiderLegs[i].knee, .18), h); \n        \n        h = max(upperLegCE(p, spiderLegs[i].knee, spiderLegs[i].ankle, .16), h); \n        \n        h = max(lowerLegCE(p, spiderLegs[i].ankle, spiderLegs[i].point, .09, .05), h); \n        if (h  > .0)\n            mat = mix(vec3(.1, 0.0, 0.0), vec3(.008, .008, .0), fract(abs(h-.5))*2.);\n            \n    }\n    \n\n    p.x = abs(p.x);\n    // Eye balls...  \n    if (sphere(p, body+vec3(0.2, 0.40, .93 ), .18) < 0.02 || sphere(p, body+vec3(0.1, 0.18, 1.1), .09) <0.05)\n   \t\t mat  = vec3(.0, 0.00, 0.00);\n    \n    return mat;\n}\n\n//----------------------------------------------------------------------------------------\nfloat translucency(vec3 p, vec3 nor)\n{\n    float d = max(mapDE(p-nor*2.), 0.0);\n    return min(d*d*d, 2.);\n}\n\n//----------------------------------------------------------------------------------------\nfloat rayMarch(vec3 pos, vec3 dir, vec2 co)\n{\n    float d =  hash12(co)*8., de;\n    float res = 35.0;\n    for (int i = 0; i < 40; i++)\n    {\n        if (d > 35.0) break;\n        vec3 p = pos + dir * d;\n        de = mapDE(p);\n        if(abs(de) < 0.02)\n        {\n            res = d;\n            break;\n        }\n\n        d += de;\n    }\n        \n    return res;\n}\n//----------------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfloat h;\n\t\n    for (int i = 0; i <8; i++)\n\t{\n\t\th = max(mapDE( ro + rd*t )+.03, 0.0);\n\t\tres = min(3.*h / t, res);\n\t\tt += h+.1;\n\t}\n    return max(res, .12);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 normal( in vec3 pos)\n{\n\tvec2 eps = vec2(.003, 0.0);\n\tvec3 nor = vec3(\n\t    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),\n\t    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),\n\t    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 cameraLookAt(in vec2 uv, in vec3 cam, in vec3 tar)\n{\n\tvec3 cw = normalize(tar-cam);\n\tvec3 cp = vec3(0.0,1.0,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = (cross(cu,cw));\n\treturn normalize(-uv.x*cu + uv.y*cv +2.*cw );\n}\n\n//----------------------------------------------------------------------------------------\n// Verlet integration. Only effects the second vector because there is always an anchor point.\n// ie. the foot and the hip...\nvoid verlet (in vec3 anchor, inout vec3 knee, float len)\n{\n\n\t\tvec3 delta = anchor-knee;\n\t\tfloat deltalength = length(delta);\n\t\tfloat diff = (-len / (deltalength + len)) + 0.5;\n\t\tdelta = delta * diff;\n    //\tMove it double because it's there's an anchor, so I only move one.\n    \tknee += delta*2.0;\n}\n\n//----------------------------------------------------------------------------------------\n// Started off looking at iq's 'insect', then realised it's feet weren't passing each other.\n// So this is also a larger stride, an more legs of course.\nvoid moveSpider()\n{\n    float t  = gTime+sin(noise11(gTime*.7)+gTime+4.0);\n\tbody.z = 3.*mod(t*1.2, 12.0)-2.0;\n    body.y = 1.2 + sin(noise11(gTime*.9)*6.28) *.8;\n\n    for (int i = 0; i < 8 ; i++)\n    {\n\t    float s = sign( float(i)-3.5 );\n\t\tfloat h = mod( float(7-i),4. )/4.0;\n        \n\t\tfloat z = (body.z + h*4.+s*.66 )/3.0;\n\t\tfloat iz = floor(z);\n\t\tfloat fz = fract(z);\n\t    float az = smoothstep(.65,  1., fz);\n        \n        spiderLegs[i].point = spiderLegs[i].fix;\n        spiderLegs[i].point.y += sin(az*3.141); // az*(1.0-az)*4.0;//\n        spiderLegs[i].point.z +=  (iz*3.0 + az*3.0 -h * 4.) + (s<.0?1.5:0.);\n        spiderLegs[i].fix = spiderLegs[i].fix*vec3(.12, .4, .1) + body - vec3(.0, .34, 0.);\n        spiderLegs[i].knee  = (spiderLegs[i].point+spiderLegs[i].fix)*.5;\n\n        spiderLegs[i].knee.y+=1.3;\n      \n\n\t\t// Iterate twice for stronger constraints..\n\t    // Over exagerate the limbs size to increase the contraint effect,\n        // without the need for many iterations...\n\t\tverlet(spiderLegs[i].fix, spiderLegs[i].knee,2.);\n\t\tverlet(spiderLegs[i].point, spiderLegs[i].knee, 2.2);\n        \n\t\tspiderLegs[i].ankle = (spiderLegs[i].point + spiderLegs[i].knee)*.5;\n        spiderLegs[i].ankle.x *= 1.14;\n        \n    }\n}\n\n//----------------------------------------------------------------------------------------\n// I moved this away from random numbers to Kali's chaotic formula...\nvec3 getFloorBoards(vec2 p)\n{\n    p *= vec2(1.5, 20.0) * .01;// ...Fiddly adjustments!\n    p.y -=.4;\n\t//p = abs(.85-mod(p,vec2(.85*2.))); // tiling fold\n\t\n    for (int i=0; i < 6; i++)\n        p = abs(p * 2.27) / dot(p, p) - .94 ;\n    \n    float f = max(sin(dot(p,p)), 0.0);\n    return (0.6 + .4*sin( f + vec3(1.,1.8,2.) ) )* vec3(.3, .23, .15) ;\n\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n    gTime = iTime*.7-9.;\n    \n    vec2 xy = (coords.xy / iResolution.xy);\n\tvec2 uv = (xy-.5)*vec2( iResolution.x / iResolution.y, 1);\n    \n    // Set initial feet positions...\n    spiderLegs[0].fix = vec3(-1.9,0.0, 3.5);\n    spiderLegs[1].fix = vec3(-2.9,0.0, 1.4);\n    spiderLegs[2].fix = vec3(-3.0, 0.0, -.4);\n    spiderLegs[3].fix = vec3(-2.25, 0.0, -2.4);\n    \n    spiderLegs[4].fix = vec3(1.9,0.0, 3.5);\n    spiderLegs[5].fix = vec3(2.9, 0.0, 1.4);\n    spiderLegs[6].fix = vec3(3.0, 0.0, -.4);\n    spiderLegs[7].fix = vec3(2.25, 0.0, -2.4);\n    \n        // Do the animation..\n    moveSpider();\n\n\tfloat height = 10.0;\n    if (iMouse.z > 0.)  height = (iMouse.y/ iResolution.y * 17.0)+2.0;\n  \n    vec3 pos = vec3(-10.0, height,25.0)+0.04*cos(gTime*vec3(2.4,2.5,2.1) );\n    pos = mix(vec3(0.0, 1., 20.0), pos, smoothstep(0.5, 4.0, iTime));\n    vec3 dir = cameraLookAt(uv, pos, vec3(1.0, body.y*.4, 1.0+body.z)+0.04*sin(gTime*vec3(2.7,2.4,2.4) ));\n    vec3 col = vec3(0.5), mat;\n    \n    \n    float d = rayMarch(pos, dir, coords);\n    vec3 nor, loc;\n    float tra = 0.0;\n    if (d < 35.0)\n    {\n        // Spider...\n        loc = pos+dir*d;\n        nor = normal(loc);\n        mat = mapCE(loc);\n        tra = translucency(loc, nor);  \n    }else    \n    {\n        // Floor...\n        if (dir.y < 0.0)\n        {\n            d = (.0-pos.y) / dir.y;\n            nor = vec3(0.0, 1.0, 0.0);\n            loc = pos+dir*d;\n\t\t\tmat = getFloorBoards(loc.zx);\n            float f =  fract(loc.x*.14);\n            mat = mix(mat, vec3(0.0), smoothstep(0., .025,f)*smoothstep(.05, .025, f)*.75);\n        }else\n        {\n            outColour = vec4(.3, .3, .3, 1.0);\n            return;\n        }\n    }\n    vec3 sun = normalize(vec3(-18.5, 10.4, 10.)- loc);\n    float sha = shadow(loc, sun);\n\n    \n    vec3 ref = reflect(sun, nor);\n    col = (mat * (tra+max(dot(sun, nor), 0.0))+pow(max(dot(dir, ref), 0.0), 24.0)*.2) *sha;\n    col+= vec3(0.01, 0.01, .02) * max(dot(normalize(vec3(18.5, 10.4, -30.)), nor),0.0);\n    col += min(mat * abs(nor.y*.2), 1.0);\n    \n     col *= .5+.55*180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y);\n    // Gamma and end...\n\toutColour = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjXzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[453, 544, 567, 567, 679], [680, 680, 702, 702, 818], [819, 819, 843, 843, 959], [961, 1052, 1093, 1093, 1121], [1123, 1214, 1252, 1252, 1303], [1305, 1396, 1447, 1447, 1578], [1580, 1580, 1632, 1632, 1822], [1825, 1916, 1977, 1977, 2109], [2110, 2201, 2264, 2264, 2457], [2459, 2550, 2596, 2596, 2688], [2690, 2815, 2836, 2836, 3609], [3611, 3732, 3752, 3774, 4755], [4757, 4848, 4886, 4886, 4956], [4958, 5049, 5094, 5094, 5411], [5412, 5503, 5542, 5542, 5737], [5739, 5830, 5857, 5857, 6070], [6072, 6163, 6220, 6220, 6393], [6395, 6612, 6670, 6670, 6911], [6913, 7157, 7176, 7176, 8398], [8400, 8561, 8590, 8590, 8910], [8912, 9003, 9057, 9057, 11218]], "test": "valid"}
{"id": "ltSSRd", "name": "Sub", "author": "ValXp", "description": "Just my subwoofer.", "tags": ["raymarching"], "likes": 6, "viewed": 982, "published": "Public API", "date": "1445813378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 80.0\n#define MAX_RAY_DISTANCE 30.0\n#define M_PI 3.1415926535897932384626433832795\n\n#define LOW_FREQUENCY 20.0\n#define LOW_LIMIT 0.5\n\n#define JUST_BEATS\n\nvec3 lightPosition;\nmat4 rotation;\nmat4 coneRotation;\nvec3 diffuseColor = vec3(0.9, 0.02, 0.05);\nvec3 specularColor = vec3(0.1, 0.3, 0.6);\nvec3 ambientColor = vec3(0.01, 0.01, 0.01);\nfloat shininess = 20.0;\nfloat screenGamma = 2.2;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           -5.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 matMin(vec2 left, vec2 right)\n{\n    return left.x > right.x ? right : left;\n}\n\n\n// Distance field equation for a sphere.\nfloat sphereDist(vec3 position, float radius)\n{\n    return length(position) - radius;\n}\n\nfloat coneDist( vec3 position, vec2 cone )\n{\n    // c must be normalized\n    float q = length(position.xy);\n    return dot(cone,vec2(q,position.z));\n}\n\nfloat sdCappedCone( in vec3 position, in vec3 cone )\n{\n    vec2 q = vec2( length(position.xz), position.y );\n    vec2 v = vec2( cone.z*cone.y/cone.x, -cone.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdTorus( vec3 position, vec2 torus )\n{\n  vec2 q = vec2(length(position.xz)-torus.x,position.y);\n  return length(q)-torus.y;\n}\n\nfloat udRoundBox( vec3 position, vec3 box, float radius )\n{\n  return length(max(abs(position)-box,0.0))-radius;\n}\n\nfloat sdCappedCylinder( vec3 position, vec2 cylinder )\n{\n  vec2 d = abs(vec2(length(position.xz),position.y)) - cylinder;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance field.\n// Takes a 3D position and gives the distance value in the field.\nvec2 map(vec3 position)\n{\n    position.z -= 10.0;\n    position = (rotation * vec4(position, 0.0)).xyz;\n\n    vec3 boxPosition = position;\n    boxPosition.z -= 1.3;\n    float box = udRoundBox(boxPosition, vec3(4.0, 5.0, 3.0), 0.5);\n    \n    vec3 holesPosition = (coneRotation * vec4(position, 0.0)).xyz;\n    holesPosition.z -= 3.5;\n    holesPosition.x += 2.5;\n    float hole1 = sdCappedCylinder(holesPosition, vec2(1.0, 4.0));\n    \n    float holes;\n    vec3 torusPosition = holesPosition;\n    torusPosition.y += 2.15;\n    float hole1Entrance = sdTorus(torusPosition, vec2(1.0, 0.1));\n    float hole1Tube = sdCappedCylinder(holesPosition, vec2(0.95, 2.2));\n    float hole1TubeHole = sdCappedCylinder(holesPosition, vec2(0.85, 3));\n    \n    holes = smin(hole1Entrance, max(hole1Tube, -hole1TubeHole), 0.2);\n    \n    holesPosition.x -= 5.0;\n    float hole2 = sdCappedCylinder(holesPosition, vec2(1.0, 4.0));\n    box = max(max(box, -hole1), -hole2);\n    \n    torusPosition = holesPosition;\n    torusPosition.y += 2.15;\n    float hole2Entrance = sdTorus(torusPosition, vec2(1.0, 0.1));\n    float hole2Tube = sdCappedCylinder(holesPosition, vec2(0.95, 2.2));\n    float hole2TubeHole = sdCappedCylinder(holesPosition, vec2(0.85, 3));\n    \n    holes = min(holes, smin(hole2Entrance, max(hole2Tube, -hole2TubeHole), 0.2));\n    \n    \n    boxPosition.z += 0.2;\n    boxPosition.y -= 1.0;\n    boxPosition = (coneRotation * vec4(boxPosition, 0.0)).xyz;\n    float coneNeg = sdCappedCone(boxPosition, vec3(0.5, 0.5, 4.0));\n    box = max(box, -coneNeg);\n    \n    position.y -= 1.0;\n    float value = texture( iChannel0, vec2( 0.001, 0.25 ) ).x / 2.0;\n#ifdef JUST_BEATS\n    position.z += value;\n#else\n    float rawWave = sin(LOW_FREQUENCY * 2.0 * M_PI * iChannelTime[0]);\n\tfloat wave = rawWave * LOW_LIMIT * 0.5 + 0.5;\n\tposition.z += clamp(wave * value, 0.0, 1.0);\n#endif\n    \n    float centerSphere = sphereDist(position, 1.3);\n    position.z -= 1.0;\n    position = (coneRotation * vec4(position, 0.0)).xyz;\n    \n    float cone = sdCappedCone(position, vec3(0.5, 0.5, 3.0));\n    position.y += 0.1;\n    float coneNegative = sdCappedCone(position, vec3(0.5, 0.5, 3.0));\n    cone = max(cone, -coneNegative);\n    \n    position.y += 2.8;\n\tfloat torus = sdTorus(position, vec2(3.0, 0.3));\n\tcone = min(cone, torus);\n    \n    \n    return matMin(vec2(min(smin(centerSphere, cone, 0.2), holes), 1.0), vec2(box, 2.0));\n}\n\nfloat mapf(vec3 position)\n{\n    return map(position).x;\n}\n\n// Ray marching.\n// Given a start point and a direction. Sample the distance field until collision with an object.\n// Return this 3D collision point.\nvec4 rayMarch(vec3 start, vec3 direction)\n{\n    float rayPrecision = 0.008;\n    float rayLength = 0.0;\n    vec3 intersection = vec3(0.0);\n    float material = 0.0;\n    for (float i = 0.0; i < MAX_ITERATIONS; i++)\n    {\n        vec3 intersection = start + (direction * rayLength);\n        vec2 ret = map(intersection);\n        // ret.x -> Distance. ret.y -> material\n        if (abs(ret.x) < rayPrecision)\n            return vec4(intersection, ret.y);\n        if (ret.x > MAX_RAY_DISTANCE)\n            return vec4(0.0);\n        rayLength += ret.x * .85;\n        material = ret.y;\n    }\n    return vec4(intersection, material);\n}\n\n\n// Calculate normal of a point.\n// Samples the distance field to find the direction at which the distance increases in 3D space.\nvec3 calcNormal(vec3 point)\n{\n    vec3 delta = vec3(0.001, 0.001, 0.001);\n    float x0 = mapf(point);\n    float xn = mapf(vec3(point.x + delta.x, point.yz)) - x0;//mapf(vec3(point.x - delta.x, point.yz));\n    float yn = mapf(vec3(point.x, point.y + delta.y, point.z)) - x0;//mapf(vec3(point.x, point.y - delta.y, point.z));   \n    float zn = mapf(vec3(point.xy, point.z + delta.z)) - x0;//mapf(vec3(point.xy, point.z - delta.z));\n    return normalize(vec3(xn, yn, zn));\n}\n\n// Simple shading function\nvec4 shade(vec4 intersection)\n{\n    vec3 point = intersection.xyz;\n    vec3 normal = calcNormal(point);\n    vec3 lightDir = normalize(lightPosition - point);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = 0.0;\n    \n    if (lambertian > 0.0)\n    {\n        vec3 viewDir = normalize(-point);\n        \n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 diffuse = vec3(0.0);\n    if (intersection.a == 2.0) // box\n    {\n        diffuse = diffuseColor;\n        diffuse = texture(iChannel1, vec2(intersection.x / 4.0, intersection.y / 4.0)).xyz * 0.6;\n    } else if (intersection.a == 1.0) // Woofer\n    {\n        diffuse = vec3(0.02, 0.02, 0.02);\n        specular /= 10.0;\n    }\n    \n    vec3 colorLinear = ambientColor;\n    colorLinear += specular * specularColor;\n    colorLinear += lambertian * diffuse;\n      \n    return vec4(colorLinear, 1.0);\n}\n                     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPosition = vec3(5.0 * sin(iTime/2.0), 1.0 * sin(iTime*4.0), 5.0 * cos(iTime/2.0));\n    rotation = rotationMatrix(vec3(0.0, 1.0, 0.0), cos(5.0 + (iMouse.x / iResolution.x) * 6.3));\n    coneRotation = rotationMatrix(vec3(1.0, 0.0, 0.0), M_PI / 2.0);\n    \n    float screenZ = 3.0;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    screenUV.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(1.0, 0.5, 2.6);\n\tvec3 pixelLoc = vec3(screenUV, screenZ);\n    \n    vec3 ray = normalize(pixelLoc - eye);\n    vec4 intersection = rayMarch(pixelLoc, ray);\n    \n    fragColor = vec4(ambientColor, 1.0);\n    if (intersection.xyz != vec3(0.0)) {\n    \t//float depth = (intersection.z-3.0)/5.0;\n    \t//fragColor = vec4(depth, depth, 0.0, 1.0);\n        //fragColor = vec4(calcNormal(intersection.xyz), 1.0);\n        \n        fragColor = shade(intersection);\n    }\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0 / screenGamma)), 1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 409, 454, 454, 1083], [1086, 1122, 1163, 1163, 1256], [1259, 1259, 1295, 1295, 1341], [1344, 1385, 1432, 1432, 1472], [1474, 1474, 1518, 1546, 1624], [1626, 1626, 1680, 1680, 1998], [2000, 2000, 2044, 2044, 2131], [2133, 2133, 2192, 2192, 2246], [2248, 2248, 2304, 2304, 2424], [2426, 2511, 2536, 2536, 4901], [4903, 4903, 4930, 4930, 4960], [4962, 5112, 5155, 5155, 5739], [5742, 5871, 5900, 5900, 6342], [6344, 6371, 6402, 6402, 7376], [7399, 7399, 7456, 7456, 8396]], "test": "error"}
{"id": "ltSSRm", "name": "Controlled texture distortion", "author": "rohtie", "description": "Mainly a test for how to apply texture mapping. ", "tags": ["distancefields", "distortion", "texturemapping"], "likes": 2, "viewed": 177, "published": "Public", "date": "1444144529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat Box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec3 rotate(vec3 point) {\n    float t = iTime;\n    \n    float s = 0.9 - cos(t) * 0.2;\n    \n    point *= mat3(s, 0.0, 0.0,\n                  0.0, s, 0.0,\n                  0.0, 0.0, s);\n    \n    point *= mat3(1.0, 0.0, 0.0,\n                  0.0, -sin(t), cos(t),\n                  0.0, cos(t), sin(t));\n\n    return point;\n}\n\nfloat map (vec3 point) {\n    \n    point = rotate(point);\n    \n    return mix(\n        max(Box(point, vec3(0.75)), -Sphere(point, 1.0)), \n        texture(iChannel0, point.xx * point.yy * point.zz).r,\n        sin(iTime)*0.1\n    );\n}\n\nfloat intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n    \n    float distance = 0.0;\n\n    float currentDistance = 1.0;\n    \n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        currentDistance = map(rayOrigin + rayDirection * distance);\n\n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return -1.0;\n    }\n\n    return distance;\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy),\n        map(point + extraPolate.yxy),\n        map(point + extraPolate.yyx)\n    ) - map(point));\n}\n\nvec3 light = normalize(vec3(0.0, 2.0, 3.0));\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n\tpoint.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(point, -1.0));\n    \n    float distance = intersect(cameraPosition, rayDirection);\n    \n    vec3 col = vec3(0.0);\n\n    if (distance > 0.0) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n        \n        \n        point = rotate(point);\n        \n        col += texture(iChannel0, point.xx * point.yy * point.zz).rgb;\n        \n        col += vec3(0.05, 0.01, 0.35);\n        col += vec3(0.7, 1.0, 0.95) * max(dot(normal, light), 0.0);\n        \n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n    }\n\n    color.rgb = col;\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 59], [61, 61, 90, 90, 177], [180, 180, 205, 205, 503], [505, 505, 529, 529, 735], [737, 737, 790, 790, 1322], [1324, 1324, 1352, 1352, 1557], [1605, 1605, 1653, 1653, 2502]], "test": "error"}
{"id": "ltSXWG", "name": "Rotating Square", "author": "hugo", "description": "Simple rotating square, roughly based on https://www.shadertoy.com/view/4dBSRK", "tags": ["2d", "simple", "rotate", "square"], "likes": 2, "viewed": 232, "published": "Public", "date": "1446123670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  px = 2.0*(-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \n    float rot = .25 * iTime;\n    float x = px.x; float y = px.y;\n    px.x = cos(rot)*(x) + sin(rot)*(y);\n    px.y = -sin(rot)*(x) + cos(rot)*(y);\n  \n    vec3  color = vec3(0.90,0.54,0.38);\n    vec2  pa = smoothstep( 0.0, 0.2*abs(sin(iTime)), (cos(1.2*px) - 0.1) );\n    \n    fragColor = vec4( color*pa.y*pa.x, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 452]], "test": "valid"}
{"id": "ltXXzf", "name": "Hypnotic Hole", "author": "rohtie", "description": "Stare at it in fullscreen!", "tags": ["hole", "black"], "likes": 0, "viewed": 91, "published": "Public", "date": "1444143707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 col, in vec2 p ) {\n\tp /= iResolution.xy;\n    \n    vec2 q = p - vec2(0.5);\n    \n    q /= 0.25 + iTime * 0.4;\n    \n    q *= mat2(sin(q.y)*10.0, sin(q.y + iTime)*2.0, 0.0, sin(atan(q.x, q.y*3.0))*5.0);\n    q *= mat2(0.6, 1.0, 5.0, 1.2);\n    \n    col = vec4(smoothstep(0.0, 0.642, length(q)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 316]], "test": "valid"}
{"id": "Ml2SRV", "name": "Switching spirals", "author": "xpaberb", "description": "Just some spirals.", "tags": ["spiralshsv"], "likes": 2, "viewed": 361, "published": "Public", "date": "1445137070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI2 6.28318530718\n#define NARMS 50.0\n\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat onesin(in float t) {\n    return sin(t) / 2.0 + 0.5;\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\t   \n    // Spirals.\n    float r = length(uv) * PI2;\n\tfloat t = atan(uv.x, uv.y);\n    \n    float timeband = -iTime;\n    float timearm = iTime / PI2;\n\n    float spiral = sin(r * PI2 / 2.0 + timeband * PI2) - t;\n    \n    vec3 c = hsv2rgb(vec3(\n        onesin(r + timeband), \n\t\t1.0,\n\t    pow(onesin(r + timeband) * onesin((spiral + timearm) * NARMS), 0.25)\n   \t));\n\t\n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2SRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 194], [196, 196, 222, 222, 255], [257, 257, 318, 318, 519], [521, 521, 576, 576, 1071]], "test": "valid"}
{"id": "Ml2SzG", "name": "FisherCat", "author": "Makio64", "description": "Raymarching test featuring Cat", "tags": ["raymarching", "cat"], "likes": 2, "viewed": 179, "published": "Public", "date": "1444730885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fishing Cat\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define SHADOW\n\n#define RAYMARCHING_STEP 60\n#define RAYMARCHING_JUMP .85\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n\n//------------------------------------------------------------------ MATRIX Functions\n\nmat2 Rot2(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat2( c, -s, s, c );\n}\n\nmat4 Rot4X(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( 1, 0, 0, 0,\n\t\t\t\t 0, c,-s, 0,\n\t\t\t\t 0, s, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Y(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t-s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Z(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4(\n\t\tc,-s, 0, 0,\n\t\ts, c, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nmat4 matRotate( in vec3 xyz )\n{\n\tvec3 si = sin(xyz);\n\tvec3 co = cos(xyz);\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n\t\t\t\t si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n\t\t\t\t co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t\t 0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 Loc4( vec3 p ) {\n\treturn mat4(\n\t\t1,  0,  0,  -p.x,\n\t\t0,  1,  0,  -p.y,\n\t\t0,  0,  1,  -p.z,\n\t\t0,  0,  0,  1\n\t);\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n\t\tm[0][0], m[1][0], m[2][0], 0.0,\n\t\tm[0][1], m[1][1], m[2][1], 0.0,\n\t\tm[0][2], m[1][2], m[2][2], 0.0,\n\t\t-dot(m[0].xyz,m[3].xyz),\n\t\t-dot(m[1].xyz,m[3].xyz),\n\t\t-dot(m[2].xyz,m[3].xyz),\n\t\t1.0 );\n}\n\n//------------------------------------------------------------------ PRIMITIVES\n\nfloat sdCappedCylinder( in vec3 p, in vec2 h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat d1 = -p.y-c.z;\n\tfloat d2 = max( dot(q,c.xy), p.y);\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdSphere( vec3 p, float r ) {\n\treturn length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//------------------------------------------------------------------ OPERATIONS\nfloat sMinP( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float a, float b ) {\n\treturn max( a, -b );\n}\n\nvec3 opTx( vec3 p, mat4 m ) {\n\treturn (transpose(m)*vec4(p,1.0)).xyz;\n}\n\n//------------------------------------------------------------------ MATERIALS\n\n#define BLACK 1.\n#define WHITE 2.\n#define BLUE 3.\n#define PINK 4.\n\n\n//------------------------------------------------------------------ MAP : Create object in the scenes\n\nvec2 opU( in vec2 v1, in vec2 v2){\n\t//Alternative wihout if.\n\t//return mix(v1,v2,clamp(sign(v1.x - v2.x),0.,1.));\n\treturn (v1.x<v2.x)?v1:v2;\n}\n\nvec3 posFromAngle(in float phi, in float theta, in float radius){\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n// Return distance + material ID\nvec2 map( in vec3 pos )\n{\n\tvec3 q = pos;\n\n    vec3 headPos = pos+vec3(0.,abs(cos(iTime*2.))*.5,0.);\n\n    q = opTx( headPos - vec3(.5,5.2,-3.), Rot4X(.3) );\n\tfloat pinkHearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(.5,5.2,3.), Rot4X(-.3) );\n\tfloat pinkHearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat pinkHears = min(pinkHearL,pinkHearR);\n\n\tq = opTx( headPos - vec3(0.,6.,-3.), Rot4X(.3) );\n\tfloat hearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(0.,6.,3.), Rot4X(-.3) );\n\tfloat hearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat hears = min(hearR,hearL);\n\tpinkHears = max(pinkHears,hears);\n\thears = opS(hears,pinkHears);\n\n\tq = headPos;\n\tfloat head = min(hears,sdSphere(q,5.));\n\tfloat head2 = sdSphere(q,5.2);\n\tq = headPos;\n\tpinkHears = opS(pinkHears,head2);\n\tq = pos;\n\tfloat body = sdCapsule(q, vec3( 0., -12., 0. ), vec3( 0., -12., 0.), 8.2 );\n\tbody = sMinP(body, head, 5.);\n    \n    q = pos - vec3(-5.,0.,0.+sin(pos.y/2.+iTime));\n    float tail = sdCapsule(q, vec3( -15., -5., 0. ), vec3( 0., -15., 0.), .5+max(0.,min((pos.y+15.)/7.,3.)) );\n    \n    q = pos;\n    float can = sdCapsule(q, vec3( 4., -10., 5. ), vec3( 13., 8.+cos(iTime/2.)*1.5, 5.+sin(7.3/2.+iTime*2.)/2.), .5 );\n    float can2 = sdCapsule(q, vec3(  13., 8.+cos(iTime/2.)*1.5, 5.+sin(pos.y/2.+iTime*2.)/2. ), vec3( 16., -15., 5.), .1 );\n    can = min(can,can2);\n    \n    vec3 bassinPos = pos-vec3(15.,-17.,5.);\n    float bassin = sdTorus(bassinPos, vec2(6.,.5));\n    //return vec2(bassin, WHITE);\n    \n    vec2 white = vec2(min(bassin,min(can,min(tail,body))),WHITE);\n\n\tfloat phi = sin(iTime/2.)*.3;\n\n\tq = pos - posFromAngle(phi+1.35,.3,5.);\n\tfloat eyeL = sdSphere(q,.3);\n\n\tq = pos - posFromAngle(phi+1.35,-.3,5.);\n\tfloat eyeR = sdSphere(q,.3);\n\n    float water = sdCappedCylinder(bassinPos,vec2(6.,.25));\n\tfloat eyes = min(water,min(eyeL,eyeR));\n\tvec2 blue = vec2(eyes, BLUE);\n\tvec2 pink = vec2(pinkHears,PINK);\n\n\tq = pos - posFromAngle(phi+1.5,0.,5.1);\n\tfloat noze = sdSphere(q,.1);\n\n\tq = pos - posFromAngle(phi+1.5,.4,5.);\n\tq = opTx( q, Rot4X(-1.3) );\n\tfloat mustache = sdCappedCylinder(q, vec2(.05,2.5));\n\n\tq = pos - posFromAngle(phi+1.55,.4,5.);\n\tq = opTx( q, Rot4X(-1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,.4,5.);\n\tq = opTx( q, Rot4X(-1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.5,-.4,5.);\n\tq = opTx( q, Rot4X(1.3) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.55,-.4,5.);\n\tq = opTx( q, Rot4X(1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,-.4,5.);\n\tq = opTx( q, Rot4X(1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tvec2 black = vec2(min(noze,mustache),BLACK);\n\n\tvec2 infos = opU(white,blue);\n\tinfos = opU(infos,pink);\n\tinfos = opU(infos,black);\n\treturn infos;\n}\n\n\n//------------------------------------------------------------------ RAYMARCHING Stuffs\n\n#ifdef RENDER_DEPTH\nvec2 castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nvec2 castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat tmax = 120.;\n\tfloat precis = .01;\n\tfloat t = 0.0;\n\tvec2 res;\n\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res.x<precis || t>tmax ) break;\n\t\tt += res.x*RAYMARCHING_JUMP;\n\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn vec2( t, res.y );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773*.01;\n\treturn normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.01 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\n//------------------------------------------------------------------ POSTEFFECTS\n\nvec3 bw( in vec3 col )\n{\n\treturn vec3(0.299*col.r + 0.587*col.g + 0.114*col.b);\n}\n\n#ifdef POSTPROCESS\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n\tcol *= 0.25+0.75*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\n\t//extra bright\n\tcol+=0.05;\n\treturn col;\n}\n\n#endif\n\n//------------------------------------------------------------------ RENDER\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col;\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tvec2 res = castRay(ro,rd,depth);\n\t#else\n\tvec2 res = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n    if(mod(iTime,3.)<1.){\n\t\treturn vec3(depth)*vec3(.1,.5,1.);\n    }\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t * rd;\n\t#ifdef RENDER_NORMAL\n    if(mod(iTime,3.)<2.){\n\t\treturn calcNormal( pos );\n    }\n    #endif\n\n\tif(t>65.){\n\t\tcol = vec3(.6,.5,.35);\n\t}\n\telse if( m == WHITE )\n\t{\n\t\t// material\n\t\tcol = vec3(1.);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t\tvec3 ambient = vec3(.3,.3,.4);\n\t\tcol += ambient*(1.-col);\n        \n        //Uncomment for the Little Big Planet versions\n        //vec2 uv = vec2(pos.z*1.5,pos.y*1.5);\n        //vec3 text = texture( iChannel0, uv, 0.0 ).rgb;\n\t\t//col*=text*1.2;\n\t}\n\telse if( m == BLACK )\n\t{\n\t\tcol = vec3(.0);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t}\n\telse if( m == BLUE )\n\t{\n\t\tcol = vec3(.1,.1,.5);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t\tvec3 ambient = vec3(.2,.2,.5+sin(iTime)*.1);\n\t\tcol += ambient*(1.-col);\n\n\t}\n    \n\telse if( m == PINK )\n\t{\n\t\t// material\n\t\tcol = vec3(.85,0.4,.45);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tvec3 ambient = col/3.;\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t\tcol += ambient*(1.-col);\n\t}\n\n\treturn col;\n}\n\n//------------------------------------------------------------------ CAMERA\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------------------------------------------------------ MAIN\n// setup cam\n// render\n// apply postEffect\n//---------------------\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iTime;\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = (-iResolution.xy+2.0*coords.xy)/iResolution.y;\n\n\tfloat angle = 0.-time;\n\tfloat radius = 35.;\n    vec3 ro = vec3(cos(angle)*radius,cos(time/3.)*4.+9.,sin(angle)*radius);\n\tvec3 ta = vec3(0.);\n\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\tvec3 color = render( ro, rd, uv );\n\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2SzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 433, 454, 454, 527], [529, 529, 551, 551, 674], [676, 676, 698, 698, 821], [823, 823, 845, 845, 962], [964, 964, 995, 995, 1346], [1348, 1348, 1369, 1369, 1465], [1467, 1467, 1497, 1497, 1705], [1788, 1788, 1836, 1836, 1933], [1935, 1935, 1987, 1987, 2107], [2109, 2109, 2147, 2147, 2304], [2306, 2306, 2341, 2341, 2366], [2368, 2368, 2401, 2401, 2466], [2468, 2548, 2590, 2590, 2677], [2679, 2679, 2710, 2710, 2734], [2736, 2736, 2765, 2765, 2807], [3061, 3061, 3095, 3174, 3203], [3205, 3205, 3270, 3270, 3388], [3390, 3423, 3448, 3448, 6347]], "test": "valid"}
{"id": "Ml2XRt", "name": "Simple Sine Anim 2", "author": "jamad", "description": "practice for loop syntax", "tags": ["basic"], "likes": 2, "viewed": 115, "published": "Public", "date": "1445972331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// graph : y=sin(2*pi*x+t)/2 + 0.5\n\nvec4 SineCurve( vec2 uv,float t,float alpha){\n    \n    float x=2. *3.14 * uv.x; // 2*pi*x \n    float y=uv.y;\n    \n    float diff=sin(x+t)/2.+0.5-y;// get diff of equation\n    float intensity = 1./ diff;// the bigger diff, the lower intensity\n \n    float band=0.005;// line width adjustment\n    \n    return vec4(abs(intensity*band)*alpha, 0., 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;  // uv : range 0..1\n\n    float t=iTime * 1.; // time adjusted\n    fragColor = vec4(0.0);\n    for(float i=1.0;i<5.0;i+=0.2){\n    \tfragColor+=SineCurve(uv,t*i,i-2.);\n    }\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2XRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 81, 81, 388], [391, 391, 446, 446, 665]], "test": "valid"}
{"id": "Ml2XWy", "name": "inverse trochoid approximation 2", "author": "jt", "description": "Approximation of inverse-trochoid function with implicit-surface ray-tracer.\nSee here for FabriceNeyret2's original inverse trochoid function: [url]https://www.shadertoy.com/view/MtSSDG[/url]\n", "tags": ["raytracer", "implicitsurface", "parametriccurve", "trochoid"], "likes": 15, "viewed": 339, "published": "Public", "date": "1446318492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Approximation of inverse-trochoid function with implicit-surface ray-tracer by Jakob Thomsen\n// Original inverse trochoid function by FabriceNeyret2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define pi 3.1415926\n\nfloat localtime;\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat trochoid2d(vec2 v, float t) // Approximation to FabriceNeyret2's inverse trochoid function (source: https://www.shadertoy.com/view/MtSSDG)\n{\n    float A = 0.5 + 0.4 * sin(0.1 * iTime * 2.0 * pi);\n    return -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(v.x - t), A + 1.0), 1.0 / (A + 1.0));\n}\n\nfloat fn(vec3 v)\n{\n    v *= 10.0;\n    return v.z + clamp(trochoid2d(v.xy, localtime), -1.0, 1.0);\n}\n\nvec3 nrm(vec3 v)\n{\n    v *= 10.0;\n    float d = 0.01;\n    vec2 grad;\n    grad.x = trochoid2d(v.xy + vec2(d, 0.0), localtime) - trochoid2d(v.xy + vec2(-d, 0.0), localtime);\n    grad.y = trochoid2d(v.xy + vec2(0.0, d), localtime) - trochoid2d(v.xy + vec2(0.0, -d), localtime);\n    return normalize(vec3(-grad, d));\n}\n\nfloat comb(float v)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), 10.0);\n}\n\nvec3 texGrid(vec3 v)\n{\n    v.x = fract(v.x * 8.0);\n    v.y = fract(v.y * 8.0);\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return vec3(q);\n}\n\nvec3 texHeight(vec3 v)\n{\n    v = 0.5 + 0.5 * clamp(v, -1.0, 1.0);\n    return vec3(0.0, v.z, 1.0 - v.z);\n}\n\nvec3 texLight(vec3 v)\n{\n    return vec3(abs(nrm(v).z));\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime * 0.0;\n    //float phi = 2.0 * iMouse.x / iResolution.x - 1.0;\n    vec3 v = vec3(uv, depth);\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    v.x = iso.x * cos(phi) + iso.y * sin(phi);\n    v.y = iso.x * -sin(phi) + iso.y * cos(phi);\n    v.z = iso.z;\n\n    return v;\n}\n\nvec3 bisection(vec3 a, vec3 b) // slow root-finder, but simple & stable\n{\n    float fa = fn(a);\n    float fb = fn(b);\n    const int n = 16;\n    for(int i = 0; i < n; i++)\n    {\n        vec3 c = (a + b) / 2.0;\n        float fc = fn(c);\n        if(sign(fc) == sign(fa))\n        {\n            a = c;\n            fa = fc;\n        }\n        else\n        {\n            b = c;\n            fb = fc;\n        }\n    }\n    \n    return (a + b) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localtime = iTime;\n\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv /= 2.0;\n\n    vec3 a = camera(uv.xy, 1.0);\n    vec3 b = camera(uv.xy,-1.0);\n    vec3 v = bisection(a, b);\n    vec3 color = (abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0) ? vec3(0.0, 0.0, 0.0) : texLight(v) * texHeight(v) + 0.1 * texGrid(v);\n\n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2XWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[280, 280, 318, 318, 385], [387, 387, 533, 533, 684], [686, 686, 704, 704, 785], [787, 787, 805, 805, 1101], [1103, 1103, 1124, 1124, 1179], [1181, 1181, 1203, 1203, 1354], [1356, 1356, 1380, 1380, 1461], [1463, 1463, 1486, 1486, 1520], [1522, 1522, 1557, 1557, 1931], [1933, 1933, 2006, 2006, 2372], [2374, 2374, 2431, 2431, 2891]], "test": "valid"}
{"id": "Ml2Xzc", "name": "public_int_i slime puddles (mod)", "author": "rcread", "description": "mod of https://www.shadertoy.com/view/MtjXzc\ntried to brighten and get rid of artifacts", "tags": ["2d"], "likes": 18, "viewed": 478, "published": "Public", "date": "1445627644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\tmod of https://www.shadertoy.com/view/MtjXzc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5 -iTime*.1;\n    vec3 c = cos(vec3(iTime*.06,\n                  iTime*.045,\n                  iTime*.015))*2.+2.;\n    for (int i = 0; i < 27; i++) {\n        vec3 p = vec3(uv*float(i),float(i));\n//      c += abs( cos( ( c + sin( p )).yzx ) );\n    \tc += abs( vec3( cos(c.y+sin(p.x)),\n                   cos(c.z+sin(p.z)),\n                   -cos(c.x+sin(p.y)) ) );\n    }\n    fragColor = vec4((c*.04-.66)*3.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2Xzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[176, 176, 233, 233, 689]], "test": "valid"}
{"id": "MlBSDy", "name": "Asteround - Raymarching", "author": "Lallis", "description": "Just trying out some space stuff :)\nThanks to iq as always.", "tags": ["procedural", "3d", "raymarching"], "likes": 8, "viewed": 164, "published": "Public", "date": "1446147432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime*0.25\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nfloat smooth3D(vec3 p)\n{\n    vec3 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n\tfloat p0 = noise3D(p);\n\tfloat x = noise3D(p+vec3(1.0,0.0,0.0));\n\tfloat y = noise3D(p+vec3(0.0,1.0,0.0));\n\tfloat z = noise3D(p+vec3(0.0,0.0,1.0));\n\tfloat xy = noise3D(p+vec3(1.0,1.0,0.0));\n\tfloat xz = noise3D(p+vec3(1.0,0.0,1.0));\n\tfloat yz = noise3D(p+vec3(0.0,1.0,1.0));\n\tfloat xyz = noise3D(p+1.0);\n\t\n    return mix(\tmix(\tmix(p0, x, \t f.x), \n                    \tmix(y, \txy,  f.x), \tf.y), \n               \tmix(\tmix(z, \txz,\t f.x), \n                    \tmix(yz, xyz, f.x), \tf.y), \tf.z);\n}\n\nfloat fbm(vec3 p)\n{\n \tfloat f = 0.5000*smooth3D(p*1.00);\n    \t  f+= 0.2500*smooth3D(p*2.01);\n    \t  f+= 0.1250*smooth3D(p*4.02);\n    \t  f+= 0.0625*smooth3D(p*8.03);\n    \t  f/= 0.9375;\n    return f;\n}\n\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat sphere( vec3 rp, vec3 c, float r )\n{\n    return distance(rp, c) - r;\n}\n\nfloat map(vec3 rp)\n{\n    float d = sphere( rp, vec3(0.0), (fbm(rp*0.2)*0.5+0.5)*5.0+(fbm(rp*0.01+21.0)*0.5+0.5)*100.0 );\n    return d;\n}\n\nfloat mapCam(vec3 rp)\n{\n    return sphere( rp, vec3(0.0), (fbm(rp*0.01+21.0)*0.5+0.5)*100.0 );\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy) - map(rp-eps.xyy),\n           map(rp+eps.yxy) - map(rp-eps.yxy),   //shamelessly stolen from iq :(\n           map(rp+eps.yyx) - map(rp-eps.yyx) ) );\n\n}\n\nfloat softShadow(vec3 rp, vec3 ld)\n{\n \tvec3 ro = rp;\n    float ldmax = 20.0;\n    float td = 0.1;\n    float res = 1.0;\n    float d;\n    for(int i = 0; i < 64; i++)\n    {\n     \trp = ro + ld * td;\n        d = map( rp );\n        if( d < 0.01 || td >= ldmax )\n        {\n         \tbreak;   \n        }\n        res = min(res,8.0*d);\n        td += d;\n    }\n    if( d < 0.01 )\n    {\n     \tres = 0.0;   \n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if( iMouse.xy == vec2(0.0) )\n    {\n       m = vec2(0.5);     \n    }\n    vec3 col = vec3(0.0);\n    \n    vec3 cam = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize( vec3( p, 0.0 ) - cam );\n    vec3 ro = vec3(0.0, 100.0, 0.0);\n    vec3 rp;\n\n    vec3 ang = vec3( 3.14*(0.5-(sin(time*0.2+1.54)*0.5+0.5)*0.25), 3.14*0.0, 3.14*0.0 );\n     rd *= rot(ang);\n    ang = vec3(m.y*6.28-3.14, m.x*6.28-3.14, 0.0);\n    \n    ro *= rot(ang);\n    rd *= rot(ang);\n    \n    ang =  vec3( time*0.25+3.14*1.25, 0.0, 0.0 );\n    ro *= rot( vec3( ang ) );\n    rd *= rot( vec3( ang ) );\n    \n    vec3 rod = normalize(ro);\n    \n    ro -= rod*(mapCam(ro)-(25.0+(sin(time*0.2-1.54)*0.5+0.5)*225.0));\n    \n    vec3 s = normalize(vec3(0.5,0.25,1.0));\n    \n    vec3 stars = vec3(smooth3D(rd*300.0)*0.5+0.5);\n    col = mix(col, vec3(0.8,0.9,1.0), smoothstep(0.95, 1.0, stars)*clamp(dot(-s,rd)+0.75,0.0,1.0));\n    col = clamp(col, 0.0, 1.0);\n    \n    rd -= s;\n\tfloat rdatan = abs(atan(rd.y, rd.x)) ;\n    rd += s;\n    \n    float srd = max(0.0,dot(s,rd))*(fbm(vec3(rdatan*2.0,time*0.5,0.0))*0.5+0.5); \n    col = mix(col,vec3(1.0,0.8,0.4),0.10*srd);\n    \n    float ss = smoothstep( 0.0, 1.0, dot(rd, s) );  \n    float sss = smoothstep( 0.8, 1.0, dot(rd, s) );\n    col += 0.4*pow(ss,5.0)*vec3(1.0,0.7,0.6)*1.0;    // from iq's shader https://www.shadertoy.com/view/llj3Rz\n    col += 0.4*pow(sss,64.0)*vec3(1.0,0.9,0.7)*2.0;   //\n    \n    \n    float td = 0.0;\n    const float maxd = 500.0;\n    float d = 0.0;\n    float dp = 0.01;\n\n    \n    for( int i = 0; i < 512; i++ )\n    {\n        rp = ro + rd * td;\n     \td = map( rp );\n        if( d < dp || td >= maxd )\n        {\n         \tbreak;   \n        }\n        td += d*(0.25+td/(maxd*2.0));\n    }\n\n    if( d < dp )\n    {\n        vec3 n = normal(rp);\n        col = clamp(col, 0.0, 1.0);\n     \tcol = vec3(0.2, 0.25, 0.3)*(fbm(rp*4.0 +100.0)*0.5+0.5);\n        \n        float sha = softShadow( rp, s );\n        float sun = clamp( dot( n, s ), 0.0, 1.0 );\n        \n        vec3 lighting = vec3(0.0);\n        lighting += sun*vec3(1.64,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        lighting += vec3(0.05);\n        col = clamp(col, 0.0, 1.0);\n        col *= lighting;\n    }\n    \n    col = pow(col , vec3(0.45));\n    float t = 0.5;\n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018);\n    \n     float jitter = (noise3D(rd)*2.0-1.0)*2.0/256.0;\n    col += jitter;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 48, 48, 129], [131, 131, 155, 155, 716], [718, 718, 737, 737, 917], [920, 920, 940, 940, 1203], [1205, 1205, 1247, 1247, 1281], [1283, 1283, 1303, 1303, 1419], [1421, 1421, 1444, 1444, 1517], [1519, 1519, 1541, 1541, 1783], [1785, 1785, 1821, 1821, 2201], [2203, 2203, 2260, 2260, 4834]], "test": "valid"}
{"id": "MlBSRG", "name": "iris shield", "author": "sourcerect", "description": "for iris/boxcar bandits. some code from /view/4sXXR7", "tags": ["spiral"], "likes": 4, "viewed": 169, "published": "Public", "date": "1444497799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPCOL1 (vec3(116.,255.,255.)/255.)\n#define SPCOL2 (vec3(55.,213.,255.)/255.)\n#define BACKCOL (vec3(209.,50.,54.)/255.)\n#define PI 3.14159265359\n\nvec4 fakeAlpha(vec4 inp) {\n    float clampedAlpha = clamp(inp.a, 0., 1.);\n    vec3 resultFullAlpha = mix(BACKCOL, inp.xyz, clampedAlpha);\n    return vec4(resultFullAlpha, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.* (fragCoord.xy - iMouse.xy) / iResolution.y;\n    \n    float r = length(uv);\n    float a = atan(uv.y,uv.x); // to polar\n    float s2 = 3.*a + 2.*PI*log(r);\n    float c2 = smoothstep(-1., 1., sin(s2-iTime*20.));\n    \n    vec3 col = mix(SPCOL1, SPCOL2, c2);\n    fragColor = vec4(col,log(r*7.)*r);\n    fragColor.a = clamp(fragColor.a, 1., 1.);\n    fragColor.a -= 0.;\n    \n    //omit in sfml\n    fragColor = fakeAlpha(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 179, 179, 330], [332, 332, 389, 389, 833]], "test": "valid"}
{"id": "MlBSRy", "name": "crowded cubes 4", "author": "FabriceNeyret2", "description": "one more variant of https://www.shadertoy.com/view/ltfXRM <br/><br/>How many different behavior will you count ? :-)", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 5, "viewed": 1136, "published": "Public API", "date": "1444555782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) v *= mat2( C = cos((t)*T), S = sin((t)*T), -S, C )\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    f-=f;\n    float C,S,r,rt,r2,x,x1,x2,x3,n;\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5.*T;\n   \n    for (float i=1.; i>0.; i-=.01)  \n    {\n        vec4 u = floor(p/8.), t = mod(p, 8.)-4., ta, M,m; // objects id + local frame\n        //r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);           // objects rotations\n        u = fract(1234.*sin(78.*(u+u.yzxw)));             // randomize ids\n   \n        r = 1.2;\n        ta = abs(t); M=max(ta,ta.yzxw); m=min(M,M.yzxw);\n        x1 = max(ta.x,M.y)-r;\n        x2 = min(m.x,m.y);\n        x = max(x1,1.1-x2);                     // cube frame\n        rt = cos(3.*T+10.*u.y+23.*u.z);\n        r2 = r*(.5+.4*rt);\n        n = fract(u.x+u.y+u.z);\n        if      (n<.25) x3 = max(ta.x-r2,M.y-r); // growing plate\n        else if (n< .5) x3 = max(ta.x-r,M.y-r2); // growing bar\n        else if (n<.75) {                        // moving plate\n       \t\t     ta.x = abs(t.x-r*rt);  M=max(ta,ta.yzxw);      \n        \t     x3 = max(ta.x-r*.1,M.y-r);\n               }\n        else   { r(t.xy,3.); ta = abs(t); M=max(ta,ta.yzxw);\n                 x3 = max(ta.x-r*.1,M.y-r);      // rotating plate\n               }\n        x = min(x, x3 );\n\n        if(x<.01)  // hit !\n            { f = i*i*(1.+.2*t); break; } // color texture + black fog \n\n        p -= d*x;           // march ray\n     }\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 206, 206, 1693]], "test": "valid"}
{"id": "MlBSzc", "name": "[CIS565 2015F] GLSL Ray Marching", "author": "bblader627", "description": "https://github.com/bcrusco/Project5-GLSL-Ray-Marcher\n\nAcknowledgements:\n* graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf\n* iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\n* https://www.shadertoy.com/view/XsXXWS", "tags": ["raymarch", "glsl"], "likes": 0, "viewed": 202, "published": "Public", "date": "1445384428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.01\n#define MAX_STEPS 500\n#define MAX_DISTANCE 100.0\n#define DISPLACEMENT_FACTOR 4.0\n#define SHADOW_SCALE 25.0\n\n// Defined propertitres\n#define NAIVE\n#define LAMBERT_COLOR\n#define SOFT_SHADOW\n//#define STEP_COUNT_COLOR\n//#define DISTANCE_COLOR\n\n// Distance estimates for different objects\nfloat sphereDistance(vec3 vector, float radius) {\n\treturn length(vector) - radius;\n}\n\nfloat planeDistance(vec3 point, float y) {\n\treturn point.y - y;\n}\n\nfloat boxDistance(vec3 point, vec3 bvec) {\n\tvec3 distance = abs(point) - bvec;\n    return min(max(distance.x, max(distance.y, distance.z)), 0.0) + length(max(distance, 0.0));\n}\n\nfloat roundedBoxDistance(vec3 point) {\n\treturn length(max(abs(point) - 1.0, 0.0)) - 0.1;\n}\n\nfloat torusDistance(vec3 point, float minorRadius, float majorRadius) {\n\treturn length(vec2(length(point.xz) - minorRadius, point.y)) - majorRadius;\n}\n\n// Distance estimator operations\nfloat unionDistance(float distance1, float distance2) {\n\treturn min(distance1, distance2);\n}\n\nfloat intersectionDistance(float distance1, float distance2) {\n\treturn max(distance1, distance2);\n}\n\nfloat subtractionDistance(float distance1, float distance2) {\n\treturn max(distance1, -distance2);\n}\n\nfloat displacementDistance(vec3 point) {\n\treturn sin(DISPLACEMENT_FACTOR * point.x) * sin(DISPLACEMENT_FACTOR * point.y)\n        * sin(DISPLACEMENT_FACTOR * point.z);\n}\n\nfloat blendDistance(float a, float b, float blendRadius) {\n\tfloat c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return (c * a + (1.0 - c) * b) - blendRadius * c * (1.0 - c);\n}\n\nvec3 transform(vec3 point, vec3 t, vec3 rot_axis, float angle, vec3 s) {\n    // translation\n\tmat4 translation = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        -t.x, -t.y, -t.z, 1.0);\n\n    //rotation matrix\n    rot_axis = normalize(rot_axis);\n    float sin = sin(radians(-angle));\n    float cos = cos(radians(-angle));\n\n   mat4 rotation = mat4(\n       (1.0 - cos) * rot_axis.x * rot_axis.x + cos, (1.0 - cos) * rot_axis.x * rot_axis.y - rot_axis.z * sin, (1.0 - cos) * rot_axis.z * rot_axis.x + rot_axis.y * sin, 0.0,\n       (1.0 - cos) * rot_axis.x * rot_axis.y + rot_axis.z * sin, (1.0 - cos) * rot_axis.y * rot_axis.y + cos, (1.0 - cos) * rot_axis.y * rot_axis.z - rot_axis.x * sin, 0.0,\n       (1.0 - cos) * rot_axis.z * rot_axis.x - rot_axis.y * sin, (1.0 - cos) * rot_axis.y * rot_axis.z + rot_axis.x * sin, (1.0 - cos) * rot_axis.z * rot_axis.z + cos, 0.0,\n       0.0, 0.0, 0.0, 1.0);\n\n    //scale matrix\n    mat4 scale = mat4(\n        1.0 / s.x, 0.0, 0.0, 0.0,\n        0.0, 1.0 / s.y, 0.0, 0.0,\n        0.0, 0.0, 1.0 / s.s, 0.0,\n        0.0, 0.0, 0.0, 1.0);\n\n    vec4 new_point = point.xyzz;\n    new_point.w = 1.0;\n    new_point = scale * rotation * translation * new_point;\n    return new_point.xyz;\n}\n\n// Mandelbulb fractal estimator\n// https://www.shadertoy.com/view/XsXXWS\nfloat mandelbulbDistance(vec3 point) {\n\tfloat scale = 1.0; // scale the surface brightness by this value\n    float power = 8.0;\n    float derivative = 1.0;\n    float internalBoundingRadius = 0.72;\n    vec3 temp_point = point;\n\n    // Use a bouncing sphere to speedup the distant ray marching\n    float externalBoundingRadius = 1.2;\n\tfloat r = length(point) - externalBoundingRadius;\n\tif (r > 1.0) {\n    \treturn r;\n    }\n\n    // Darker the deeper we go\n\tfor (int i = 0; i < 10; i++) {\n\t\tscale *= 0.725;\n\t\tfloat r = length(temp_point);\n\n\t\tif (r > 2.0) {\n\t\t\t// The point escaped, remap the scale for more brightness and return\n\t\t\tscale = min((scale + 0.075) * 4.1, 0.0);\n\t\t\treturn min(length(point) - internalBoundingRadius, 0.5 * log(r) * r / derivative);\n\t\t} else {\n\t\t\t// Convert to polar coordinates and then rotate by the power\n\t\t\tfloat theta = acos(temp_point.z / r) * power;\n\t\t\tfloat phi   = atan(temp_point.y, temp_point.x) * power;\n\t\t\tfloat sinTheta = sin(theta);\n\n\t\t\tderivative = pow(r, power - 1.0) * power * derivative + 1.0;\n\n\t\t\t// Convert back to Cartesian coordinates and offset by original point\n\t\t\ttemp_point = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta)) * pow(r, power) + point;\n\t\t}\n\t}\n\n\treturn EPSILON;\n}\n\n// Height-mapped terrain estimator\nfloat terrainDistance(vec3 point, float height, float length) {\n\treturn point.y - height * sin(length * point.x) * cos(point.z);\n}\n\n// Scene creation\nfloat map(vec3 point) {\n    float distance = 0.0;\n\n    // add a sphere\n    vec3 temp_point = transform(point, vec3(-1.5, 0.0, 0.0), vec3(1.0), 0.0, vec3(1.5));\n    float sphere = sphereDistance(temp_point - vec3(1.0, 0.0, 0.0), 0.5);\n\n    // add a plane\n    float plane = planeDistance(point, -2.0);\n    distance = unionDistance(sphere, plane);\n\n    // add a torus\n    temp_point = transform(point, vec3(2.0, -0.5, 0.0), vec3(1.0), 0.0, vec3(0.3));\n    float torus = torusDistance(temp_point, 2.0, 1.0);\n    distance = unionDistance(distance, torus);\n\n    // add rounded box\n    temp_point = transform(point, vec3(-2.0, 0.5, 0.0), vec3(0.0, 1.0, 0.0), 45.0, vec3(0.5));\n    float roundedBox = roundedBoxDistance(temp_point);\n    distance = unionDistance(distance, roundedBox);\n\n    return distance;\n}\n\n// Soft shadow effect\nfloat calculateSoftShadow(vec3 point, vec3 lightPosition) {\n\tfloat t = 2.0;\n    float minT = 2.0;\n    vec3 ro = point;\n    vec3 rd = normalize(lightPosition - point);\n    float maxT = (lightPosition.x - ro.x) / rd.x;\n    float shadowColor = 1.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n        point = ro + rd * t;\n\n        float distance = map(point);\n\n        if(distance < EPSILON) {\n        \treturn 0.0;\n        }\n\n        t += distance;\n        shadowColor = min(shadowColor, SHADOW_SCALE * (distance / t));\n\n        if(t > maxT) {\n        \treturn clamp(shadowColor, 0.0, 1.0);\n        }\n    }\n\n    return clamp(shadowColor, 0.0, 1.0);\n}\n\nvec3 calculateNormal(in vec3 point) {\n\tvec3 epsilon = vec3(EPSILON, 0.0, 0.0);\n    vec3 normal = vec3(\n        map(point + epsilon.xyy) - map(point - epsilon.xyy),\n        map(point + epsilon.yxy) - map(point - epsilon.yxy),\n        map(point + epsilon.yyx) - map(point - epsilon.yyx));\n    return normalize(normal);\n}\n\n// Lambert color calculation\nvec3 calculateLambertColor(vec3 point, vec3 ro) {\n\tvec3 lightPosition = vec3(6.0, 5.0, 0.0);\n    vec3 lightColor = vec3(0.8);\n    vec3 lightVector = normalize(lightPosition - point);\n\n    // calculate the normal\n    vec3 normal = calculateNormal(point);\n\n    // also require naive right?\n    #ifdef SOFT_SHADOW\n    \tfloat shadowColor = calculateSoftShadow(point, lightPosition);\n    \treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightColor * (shadowColor) + 0.05;\n    #else\n    \treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightColor + 0.01;\n\t#endif\n}\n\n// Step count color\nvec3 calculateStepCountColor(vec2 steps) {\n\tfloat t = (steps.y - steps.x) / steps.y;\n    return vec3(1.0 - t, t, 0.0);\n}\n\n// Calls the different types of color calculations\nvec3 calculateColor(vec3 point, vec2 distance, vec3 ro, vec2 steps) {\n    #ifdef LAMBERT_COLOR\n\t\treturn calculateLambertColor(point, ro);\n    #endif\n\n    // Debug colors\n    #ifdef DISTANCE_COLOR\n    \treturn vec3(abs((distance.y - distance.x) / distance.y));\n    #endif\n\n    #ifdef STEP_COUNT_COLOR\n    \treturn calculateStepCountColor(steps);\n    #endif\n\n    return vec3(0.0);\n}\n\nvec3 naiveRayMarch(in vec3 ro, in vec3 rd) {\n\tvec3 point; //The point on the ray\n\n    float i = 0.0;\n    for(float t = 0.0; t < MAX_DISTANCE; t += 0.01) {\n        i++;\n    \tpoint = ro + rd * t;\n\n        // distance estimator goes here\n        float distance = map(point);\n\n        if(distance < EPSILON) {\n        \t// if valid distance return color calculation\n            return calculateColor(point, vec2(t, MAX_DISTANCE), ro, vec2(i, MAX_STEPS));\n        }\n    }\n\n    return vec3(0.0);\n}\n\n// Spherical trace\nvec3 sphericalRayMarch(in vec3 ro, in vec3 rd) {\n    float minStep = 0.01;\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 point = ro + rd * t;\n        float distance = map(point);\n\n        if(distance <= EPSILON) {\n        \treturn calculateColor(point, vec2(t, MAX_DISTANCE), ro, vec2(float(i), MAX_STEPS));\n        }\n\n        if(distance > 0.0) {\n        \tt += max(distance, minStep);\n        }\n\n        if(t >= MAX_DISTANCE) {\n        \tbreak;\n        }\n    }\n\n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    #ifdef NAIVE\n    \treturn naiveRayMarch(ro, rd);\n    #else\n    \treturn sphericalRayMarch(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 306, 355, 355, 390], [392, 392, 434, 434, 457], [459, 459, 501, 501, 635], [637, 637, 675, 675, 727], [729, 729, 800, 800, 879], [881, 914, 969, 969, 1006], [1008, 1008, 1070, 1070, 1107], [1109, 1109, 1170, 1170, 1208], [1210, 1210, 1250, 1250, 1378], [1380, 1380, 1438, 1438, 1562], [1564, 1564, 1636, 1655, 2824], [2826, 2899, 2937, 2937, 4133], [4135, 4170, 4233, 4233, 4300], [4302, 4320, 4343, 4343, 5120], [5122, 5144, 5203, 5203, 5788], [5790, 5790, 5827, 5827, 6108], [6110, 6139, 6188, 6188, 6703], [6705, 6725, 6767, 6767, 6845], [6847, 6898, 6967, 6967, 7276], [7278, 7278, 7322, 7322, 7768], [7770, 7789, 7837, 7837, 8298], [8300, 8300, 8337, 8337, 8451], [8453, 8453, 8503, 8601, 8790], [8792, 8792, 8847, 8945, 9609]], "test": "valid"}
{"id": "MlBSzK", "name": "Police Light", "author": "rohtie", "description": "Turn your lights on!", "tags": ["face", "flash", "police"], "likes": 1, "viewed": 120, "published": "Public", "date": "1445105084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p, float radius, float e) {\n\treturn smoothstep(radius - e, radius + e, length(p));\n}\n\nfloat circle(vec2 p, float radius) {\n\treturn circle(p, radius, 0.01);\n}\n\nfloat horizontal(vec2 p, float height, float e) {\n\treturn smoothstep(height - e, height + e, p.y);\n}\n\nfloat horizontal(vec2 p, float height) {\n\treturn horizontal(p, height, 0.01);\n}\n\n\nvoid mainImage( out vec4 col, in vec2 p ) {\n    p /= iResolution.xy;\n    \n    float texture = smoothstep(0.49, 0.51, p.y + p.x * tan(iTime + p.x * 500.0));\n    \n    float move = sin(iTime) * 0.05;\n    \n    float headMask = circle(p * vec2(1.2, 1.0) - vec2(0.5 + move, 0.2 + move), 0.75);\n    \n    float eyes = min(circle(p - vec2(0.25 + move, 0.65), 0.075), circle(p - vec2(0.75 + move, 0.65), 0.075));\n    eyes = max(horizontal(p, 0.71, 0.0175), eyes);\n    eyes = max(1.0 - horizontal(p, 0.68, 0.005), eyes);\n    \n    float mouth = circle(p - 0.5 + move * 0.25, 0.1, 0.005);\n    mouth = max(horizontal(p, 0.45), mouth);\n    \n    float a = iTime * 25.0;\n    p *= mat2(cos(a), -sin(a),\n             sin(a), cos(a));    \n    \n    col.rgb = vec3(p.x * 0.2, p.y * 0.5, p.x * p.y) * headMask * (1.0 - texture * 0.1) + \n        \t  vec3(p.x * 0.3, p.y * 0.2, p.y * 0.35) * texture * (1.0 - headMask) + \n        \t  vec3(1.0 - min(eyes, mouth)) * vec3(p.y * 0.75, p.y * 0.55, p.y * 0.75) * texture +\n        \t  length(p + 1.0) * 0.15;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 102], [104, 104, 140, 140, 175], [177, 177, 226, 226, 277], [279, 279, 319, 319, 358], [361, 361, 404, 404, 1388]], "test": "valid"}
{"id": "MlBSzy", "name": "Pu-239", "author": "lebek", "description": "Just learning - copied code from https://www.shadertoy.com/view/Xds3zN", "tags": ["raymarching", "donut"], "likes": 2, "viewed": 161, "published": "Public", "date": "1444590061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat ripple(vec3 p) {\n    float t = iTime;\n    float o = cos(t*1.0)+sin(t+0.4);\n \treturn 0.07*o*sin(8.0*p.x+o)*sin(8.0*p.y)*sin(8.0*p.z);   \n}\n\nfloat rippleSphere(vec3 p, float s) {\n\treturn sdSphere(p, s)+ripple(p);\n}\n\nfloat rippleTorus(vec3 p, vec2 t) {\n\treturn sdTorus(p, t)+ripple(p);\n}\n\n\nvec2 map(vec3 p) {\n    return vec2(rippleTorus(p, vec2(1.0, 0.3)), 0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float cam_path_r = 3.0;\n    \n    // camera\t\n    vec3 ro = vec3(cam_path_r*sin(iTime),cam_path_r*sin(iTime),cam_path_r*cos(iTime));\n\tvec3 ta = vec3(0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // ray direction\n\tvec3 rd = ca*normalize(vec3(p.xy,2.0));\n    \n    float tmin = 0.02;\n    float tmax = 6.0;\n    float t = tmin;\n    float precis = 0.0002;\n    float fg = tmin;\n    float bg = tmax;\n    for (int i = 0; i < 10; i++) {\n    \tfloat d1 = map(ro+rd*t).x;\n        \n        //float d2 = sdSphere(ro+rd*t-vec3(-1,-2,0), 1.0);\n        \n        float d = d1; //min(d1,d2);\n        if(d<precis || t>tmax) break;\n        \n        t += d/1.0;\n    }\n    \n    if (t<tmax) {\n        vec3 n = calcNormal(ro+rd*t);\n        float s1 = dot(n,-normalize(vec3(1,0,-1)));\n        float s2 = dot(n,-normalize(vec3(0,-1,1)));\n        float s = clamp(0.4+(s1+s2)/2.0, 0.0, 1.0);\n        fragColor = vec4(s,(sin(s)+1.0)/2.0,(cos(s)+1.0)/2.0,0);//1.0-t/tmax);\n        return;\n    }\n    \n\n\tfragColor = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 35, 35, 59], [61, 61, 92, 92, 157], [159, 159, 181, 181, 302], [304, 304, 341, 341, 377], [379, 379, 414, 414, 449], [452, 452, 470, 470, 524], [526, 526, 556, 556, 777], [779, 779, 831, 831, 1008], [1010, 1010, 1067, 1067, 2217]], "test": "valid"}
{"id": "MlBXzc", "name": "[CIS565 2015F] Basic RayMarching", "author": "queenkong", "description": "Acknowledgement:\nhttps://www.shadertoy.com/view/Xds3zN\nhttp://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nhttp://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf", "tags": ["raymarching"], "likes": 6, "viewed": 249, "published": "Public", "date": "1445398881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 0 = None, 1 = Position, 2 = Normals, 3 = Steps\n#define DEBUG 3\n#define SPHERE_TRACE 1\n\n/*****************Distance estimators from iq***************/\n//https://www.shadertoy.com/view/Xds3zN\n\nfloat sdTerrain( vec3 p )\n{\n    //http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\n\treturn p.y - 0.5 * sin(p.x) * sin(p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat unionDistance(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\n//construct scene and estimate distance\nvec2 estimateDistance(in vec3 point) {\n    \n    float d1 = sdSphere(point + vec3(-0.5, -0.6, 0), 0.15);\n    float d2 = sdBox(point, vec3(0.2, 0.2, 0.2));\n    float d3 = sdCone(point + vec3(1.2, -0.2, -0.1),\n                     vec3 (0.7, 0.3, 0.7));\n    float d4 = sdTerrain(point + vec3(0, 0.5, 0));\n    float d5 = sdCylinder(point + vec3(-1.0, 0.1, 0.5),\n                         vec2(0.2, 0.8));\n    \n    float nearest = unionDistance(d5, \n                                  unionDistance(unionDistance(d3,d4),\n                                  unionDistance(d1,d2)));\n    float col = 0.0;\n    \n    if (nearest == d1) {\n        col = 1.0;\n    } else if(nearest == d2) {\n        col = 2.0;\n    } else if(nearest == d3){\n        col = 3.0;\n    } else if(nearest == d4){\n        col = 4.0;\n    } else {\n        col = 3.0;\n    }\n    return vec2(nearest, col);\n}\n\n//http://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf\n//McGuire 11.5\nvec3 transform(in vec3 point, in vec3 trans, in vec3 rot_axis,\n               in float rot_angle, in vec3 scale) {\n    \n\tmat4 trans_mat = mat4(1.0, 0.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0, 0.0,\n                          0.0, 0.0, 1.0, 0.0,\n                          -trans.x, -trans.y, -trans.z, 1.0);\n\n    mat4 scale_mat = mat4(1.0/scale.x, 0.0, 0.0, 0.0,\n                          0.0, 1.0/scale.y, 0.0, 0.0,\n                          0.0, 0.0, 1.0/scale.z, 0.0,\n                          0.0, 0.0, 0.0, 1.0);\n\n    vec4 new_point = vec4(point.x, point.y, point.z, 1.0);\n    new_point = scale_mat * trans_mat * new_point;\n    return vec3(new_point.x, new_point.y, new_point.z);\n}\n\nvec3 naiveRayMarch(in vec3 ro, in vec3 rd) {\n    const float maxDistance = 100.0;\n    const float dt = 0.01;\n    int steps = 0;\n    for (float t = 0.0; t < maxDistance; t += dt) {\n     steps++;\n     //t += dt;\n     vec3 point = ro + rd * t;\n     float intersected = estimateDistance(point).x;\n     if(intersected < 0.0) {\n        return vec3(t, steps, estimateDistance(point).y);\n     }\n    }\n    return vec3(-1);\n}\n\nvec3 sphereTrace(in vec3 ro, in vec3 rd) {\n    const float epsilon = 0.00001;\n    const float minStep = 0.01;\n    const int maxSteps = 100;\n    \n    float t = 0.0;\n    float dt = estimateDistance(ro + rd * t).x;\n    int steps = 0;\n    float col;\n    for (int i = 0; i <= maxSteps; i++ ) {\n        steps++;\n        dt = estimateDistance(ro + rd * t).x;\n        t += max(dt, minStep);\n        if (dt < epsilon) {\n            col = estimateDistance(ro + rd * t).y;\n            break;\n        }   \n    }\n    return vec3(t, steps, col);\n}\n\n\nvec3 calcNormal(in vec3 pos)\n{\n\tfloat eps = 0.0001;\n    vec3 posx = vec3(pos.x + eps, pos.y, pos.z);\n    vec3 posy = vec3(pos.x, pos.y + eps, pos.z);\n    vec3 posz = vec3(pos.x, pos.y, pos.z + eps);\n\tvec3 nor = vec3(estimateDistance(pos).x - estimateDistance(posx).x,\n                    estimateDistance(pos).x - estimateDistance(posy).x,\n                    estimateDistance(pos).x - estimateDistance(posz).x);\n\treturn normalize(nor);\n}\n\n\n/******************LIGHTING***************************/\n\n//lambert\nvec3 lambert(in vec3 point, in vec3 normal, in vec3 mat_color) {\n\tvec3 light_pos = vec3(0.0, -10, -4);\n    float diffuse_term = 0.7;\n    \n    return mat_color * diffuse_term * max(0.0,dot(normal, normalize(light_pos - point)));\n}\n\n\n//soft shadow\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i < 16; i++ )\n    {\n\t\tfloat h = estimateDistance(ro + rd*t).x;\n        res = min( res, 3.0 * h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\n/******************* RENDER ***************/\nvec3 render(in vec3 ro, in vec3 rd, in vec2 pixel) {\n  \n    vec3 marched_ray;\n    vec3 BG = vec3(0.7);\n    \n    if (SPHERE_TRACE == 1) {\n    \tmarched_ray = sphereTrace(ro, rd);\n    } else {\n        marched_ray = naiveRayMarch(ro, rd);\n    }\n    \n    vec3 point = ro + rd * marched_ray.x;\n \n  \n    if (DEBUG == 1) {\t\n        //debug image with distance to surface\n        return point;\n    } else if (DEBUG == 2){\t\n        //debug image with normals\n        return calcNormal(point);        \n    } else if (DEBUG == 3) {\t\n        //debug image with distance to surface\n        return vec3(0.0, marched_ray.y/255.0, marched_ray.y/255.0);\n    } else {\n        //render the image\n        if(marched_ray.x > 0.0) {\n            \n           if(SPHERE_TRACE == 1 && marched_ray.y >= 50.0){\n              return BG;\n           } \n            \n            vec3 col = vec3(0.7);\n            if(marched_ray.z == 1.0) {\n                col = vec3(0.1, 0, 0.8);\n            } else if (marched_ray.z == 2.0) {\n                col = vec3(0, 1, 1);\n            } else if (marched_ray.z == 3.0) {\n                col = vec3(0.7, 0, 0);\n            } else {\n                col = vec3(0.5);\n            }\n            \n            return lambert(point, calcNormal(point), col) * \n                vec3(softshadow(point, ro, 0.01, 50.0));\n         } else {\n           return BG;\n         }\n    }\n \n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd, fragCoord);\n\n    col = pow(col, vec3(0.3545));\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 220, 301, 344], [346, 346, 381, 381, 407], [409, 409, 440, 440, 527], [529, 529, 565, 565, 664], [666, 666, 704, 704, 873], [875, 875, 908, 908, 961], [963, 963, 1004, 1004, 1027], [1029, 1069, 1107, 1107, 1929], [1931, 2019, 2133, 2133, 2714], [2716, 2716, 2760, 2760, 3131], [3133, 3133, 3175, 3175, 3666], [3669, 3669, 3699, 3699, 4107], [4167, 4177, 4241, 4241, 4406], [4409, 4423, 4497, 4497, 4773], [4776, 4821, 4873, 4873, 6198], [6200, 6200, 6250, 6348, 6537], [6539, 6539, 6594, 6692, 7367]], "test": "valid"}
{"id": "MlBXzK", "name": "less noob-raymarching", "author": "MacSlow", "description": "By now the raymarching is a bit more sophisticated (compared my first attempt) as it implements over-relaxed sphere-tracing as described by Keinert et al 2014. The artifacts on the twisting box suck, but that's expected when messing with space like that.", "tags": ["raymarching"], "likes": 5, "viewed": 290, "published": "Public", "date": "1444925478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Basic raymarching-renderer\n//\n// Copyright 2015 Mirco MÃ¼ller\n//\n// Author(s):\n//   Mirco \"MacSlow\" MÃ¼ller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red   = vec4 (1., .0, .0, 1.);\nconst vec4 green = vec4 (.0, 1., .0, 1.);\nconst vec4 blue  = vec4 (.0, .0, 1., 1.);\nconst vec4 white = vec4 (1.);\nconst vec4 black = vec4 (.0, .0, .0, 1.);\nconst vec4 orange = vec4 (1., .5, .25, 1.);\nconst int MAX_STEPS = 128;\nconst float epsilon = 0.0001;\n\nvec4 gradient (float v) {\n    float steps = 3.;\n    float step = 1. / steps;\n    vec4 col = black;\n\n    if (v >= 0.0 && v < step) {\n        col = mix (white, blue, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (blue, red, (v - step) * steps);\n    }\n\n    return col;\n}\n\nfloat opUnion (float d1, float d2)\n{\n    return max (d1, d2);\n}\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5 * (b - a) / k, .0, 1.);\n    return mix (b, a, h) - k * h * (1. - h);\n}\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nvec3 opTransf (vec3 p, mat4 m)\n{\n    return vec4 (m * vec4 (p, 1.)).xyz;\n}\n\nvec3 opTwistX (vec3 p, float angle)\n{\n    float rad = radians (angle * p.x);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (1.0, 0.0, 0.0),\n                     vec3 (0.0,   c,   s),\n                     vec3 (0.0,  -s,   c));\n\n    return p * mat;\n}\n\nvec3 opTwistY (vec3 p, float angle)\n{\n    float rad = radians (angle * p.y);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (  c, 0.0,  -s),\n                     vec3 (0.0, 1.0, 0.0),\n                     vec3 (  s, 0.0,   c));\n\n    return p * mat;\n}\n\nvec3 opTwistZ (vec3 p, float angle)\n{\n    float rad = radians (angle * p.z);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (  c,   s, 0.0),\n                     vec3 ( -s,   c, 0.0),\n                     vec3 (0.0, 0.0, 1.0));\n\n    return p * mat;\n}\n\nmat4 rotX (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1.0, 0.0, 0.0, 0.0),\n                     vec4 (0.0,   c,   s, 0.0),\n                     vec4 (0.0,  -s,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat hash (float f)\n{\n    return fract (sin (f) * 45734.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\n// fractal brownian motion with four different octaves\n// rotating input point p to make it a less dull\nfloat fbm (vec3 p)\n{\n    mat3 m1 = mat3 (rotZ (23.4));\n    mat3 m2 = mat3 (rotZ (45.5));\n    mat3 m3 = mat3 (rotZ (77.8));\n\n    float result = .0;\n    result = 0.5 * noise3d (p);\n    p *= m1 * 2.02;\n    result += 0.25 * noise3d (p);\n    p *= m2 * 2.03;\n    result += 0.125 * noise3d (p);\n    p *= m3 * 2.04;\n    result += 0.0625 * noise3d (p);\n    result /= 0.9375;\n\n    return result;\n}\n\nvec3 opRepeatX (vec3 p, float v)\n{\n    return vec3 (mod (p.x, v), p.y, p.z);\n}\n\nvec3 opRepeatY (vec3 p, float v)\n{\n    return vec3 (p.x, mod (p.y, v), p.z);\n}\n\nvec3 opRepeatZ (vec3 p, float v)\n{\n    return vec3 (p.x, p.y, mod (p.z, v));\n}\n\nfloat opSubtract (float d1, float d2)\n{\n    return max (-d1, d2);\n}\n\nfloat opIntersect (float d1, float d2)\n{\n    return max (d1, d2);\n}\n\nfloat opBlend (float d1, float d2, float k)\n{\n    return smin (d1, d2, k);\n}\n\nfloat sphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat box (vec3 p, vec3 b, float r)\n{\n    return length (max (abs (p) - b + vec3 (r), .0)) - r;\n}\n\nfloat cylinder (vec3 p, vec3 n)\n{\n    return length (p.xz - n.xy) - n.z;\n}\n\nfloat func (vec3 p)\n{\n    return -.4 * sin (p.x * 2.) * cos (p.z * 3.) * sin (p.y * .05);\n}\n\nfloat plane (vec3 p, vec4 n)\n{\n    return dot ((p).xyz, n.xyz) + n.w;\n}\n\nvec3 materialOne (vec3 p)\n{\n    vec3 color;\n\n    color.r = fbm (2.1 * p);\n    color.g = fbm (3.2 * p);\n    color.b = fbm (4.3 * p);\n\n    return color;\n}\n\nvec3 materialTwo (vec3 p)\n{\n    vec3 color;\n\n    color.r = fbm (1.2 * p);\n    color.g = fbm (1.3 * p);\n    color.b = fbm (1.4 * p);\n\n    return color;\n}\n\nfloat map (vec3 p)\n{\n    float d = .0;\n    float d1 = .0;\n    float d2 = .0;\n    float d3 = .0;\n    float d4 = .0;\n    float d5 = .0;\n    float t = iTime;\n\n    // twisting box with sphere cutout\n    mat4 m = trans (vec3 (-2., 1., 3.));\n    d = opSubtract (sphere (opTransf (p, m), 1.),\n                    box (opTwistY (opTransf (p, m),\n                                   sin (t) * 20.),\n                         vec3 (.6, 2., .6), .1));\n\n    d2 = plane (p, normalize (vec4 (.0, -1., .0, 1.)));\n    d = min (d, d2);\n\n    // dice-like things\n    m = rotY (50. * t) * trans (vec3 (-3.6, .5, .5 + 1.5 * sin (t)));\n    mat4 m1 = trans (vec3 (-3., -.45, .0));\n    d3 = opBlend (opIntersect (box (opTransf (p, m), vec3 (.55), .1),\n                               sphere (opTransf (p, m), .7)),\n                  opIntersect (box (opTransf (p, m1), vec3 (.55), .1),\n                               sphere (opTransf (p, m1), .7)),\n                  .6);\n    d = min (d, d3);\n\n    // T1000-ish ball-box magic\n    m = trans (vec3 (1.05, -.3, 2.2 + sin (t)));\n    m1 = trans (vec3 (-.05, .5, 1.5));\n    d2 = opBlend (box (opTransf (p, m), vec3 (.7), .1),\n                  sphere (opTransf (p, m1), .7),\n                  .5 + .25 * cos (iTime));\n    d = min (d, d2);\n\n    // dice with holes\n    m = trans (vec3 (-1.25, -.4, -1.25));\n    m1 = rotX (90.) * trans (vec3 (-.9, .1, 1.5));\n    mat4 m2 = trans (vec3 (-.9, -1., -.75));\n    d2 = opIntersect (box (opTransf (p, m), vec3 (.55), .0),\n                      sphere (opTransf (p, m), .7));\n    d3 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)),\n                     d2);\n    d2 = opSubtract (cylinder (opTransf (p, m2), vec3 (.35, .5, .35)),\n                     d3);\n    m1 = rotZ (90.) * trans (vec3 (.0, -.75, -.75));\n    d3 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)), d2);\n    d = min (d, d3);\n\n    return d;\n}\n\n// \"borrowed\" from iq... have a slightly better understanding of this now\nvec3 objectNormal (vec3 p)\n{\n    vec2 e = vec2 (.0001, .0);\n    float d = map (p);\n\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d);\n\n    return normalize (n);\n}\n\nfloat march (in vec3 ro, in vec3 rd, in float pixelSize, out int iter)\n{\n    bool forceHit = true;\n    float infinity = 10000000.0;\n    float t_min = .0000001;\n    float t_max = 1000.0;\n    float t = t_min;\n    float candidate = t_min;\n    float candidate_error = infinity;\n    float w = 1.2;\n    float lastd = .0;\n    float stepSize = .0;\n    float sign = map (ro) < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        iter++;\n        float signedd = sign * map (ro + rd * t);\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = 1.;\n        } else {\n            stepSize = signedd * w;\n        }\n\n        lastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error) {\n            candidate_error = error;\n            candidate = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n            break;\n        }\n\n        t += stepSize;\n \n    }\n\n    if ((t > t_max || candidate_error > pixelSize) && !forceHit) {\n        return infinity;\n    }\n\n    return candidate;\n}\n\nfloat softShadow (vec3 ro, vec3 rd, float tmin, float k)\n{\n    float s = 1.;\n    float d = .0;\n    float t = tmin;\n    for (int i = 0; i < 64; i++) {\n        d = map (ro + rd * t);\n        if (d < epsilon) {\n            return .0;\n        }\n        s = min (s, k * d / t);\n        t += d;\n    }\n    return s;\n}\n\nfloat hardShadow (in vec3 ro, in vec3 rd)\n{\n    float t = .02;\n    for (int i = 0; i < 64; i++) {\n        float d = map (ro + rd * t);\n        if (d < epsilon) {\n            return .1;\n        }\n        t += d;\n    }\n\n    return 1.;\n}\n\nvec3 shade (in vec3 p)\n{\n    // animate the light-sources a bit\n    float t = 1.5 * iTime;\n    vec3 lPos0 = vec3 (1.5 * cos (t), -2., 1.5 * sin (t));\n    vec3 lPos1 = vec3 (4. * cos (-t * .2), -4., 4. * sin (-t));\n\n    vec3 lCol0 = vec3 (.95, .95, .75) * 4.75;\n    vec3 lCol1 = vec3 (.5, .5, .75) * 6.5;\n    vec3 normal = objectNormal (p);\n    vec3 lDir0 = normalize (lPos0 - p);\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec3 lInt0 = lCol0 * max (dot (normal, lDir0), .0);\n    vec3 lInt1 = lCol1 * max (dot (normal, lDir1), .0);\n    vec3 col = softShadow (p, normalize (lPos0 - p), 0.001, 64.) * .7 * lInt0;\n    col += softShadow (p, normalize (lPos1 - p), 0.001, 64.) * .8 * lInt1;\n    //vec3 col = hardShadow (p, normalize (lPos0 - p)) * .7 * lInt0;\n    //col += hardShadow (p, normalize (lPos1 - p)) * .8 * lInt1;\n\n    return col;\n}\n\nmat3 camera (in vec3 eye, in vec3 aim, in float r)\n{\n    vec3 cw = normalize (aim - eye);\n    vec3 cp = vec3 (sin (r), cos (r), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    float tm = iTime;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (2. * mouse.x) * 9.,\n                     -6. + 4. * mouse.y,\n                     sin (2. * mouse.x) * 9.);\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 cam = camera (eye, aim, .0);\n    float u = -.5 + fragCoord.x / iResolution.y;\n    float v = -.5 + fragCoord.y / iResolution.y;\n    vec2 uvRaw = fragCoord.xy / iResolution.xy;\n\n    vec3 ro = eye;\n    vec3 rd = cam * normalize (vec3 (u, -v, 1.8));\n    vec3 bg = vec3 (.125, .125, .05);\n    float pixelSize = 1. / iResolution.x;\n    int iter = 0;\n    float t = march (ro, rd, pixelSize, iter);\n    vec3 p = ro + rd * t;\n    float fog = 1. / pow (1. + t * t * .1, .25);\n    vec3 color = mix (shade (p) * materialTwo (p), bg, length (rd * t) / 30.);\n    color *= fog;\n    \n    color = color / (1. + color);\n    color = pow (color, vec3 (1./2.2));\n    color *= vec3 (.95, .9, .85);\n    color *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4 (color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBXzK.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1255, 1255, 1280, 1280, 1552], [1554, 1554, 1590, 1590, 1617], [1619, 1619, 1659, 1659, 1759], [1761, 1761, 1782, 1782, 1980], [1982, 1982, 2014, 2014, 2056], [2058, 2058, 2095, 2095, 2338], [2340, 2340, 2377, 2377, 2620], [2622, 2622, 2659, 2659, 2902], [2904, 2904, 2932, 2932, 3228], [3230, 3230, 3258, 3258, 3554], [3556, 3556, 3584, 3584, 3880], [3882, 3882, 3904, 3904, 3947], [3949, 3949, 3973, 3973, 4647], [4649, 4753, 4773, 4773, 5140], [5142, 5142, 5176, 5176, 5220], [5222, 5222, 5256, 5256, 5300], [5302, 5302, 5336, 5336, 5380], [5382, 5382, 5421, 5421, 5449], [5451, 5451, 5491, 5491, 5518], [5520, 5520, 5565, 5565, 5596], [5598, 5598, 5630, 5630, 5659], [5661, 5661, 5698, 5698, 5758], [5760, 5760, 5793, 5793, 5834], [5836, 5836, 5857, 5857, 5927], [5929, 5929, 5959, 5959, 6000], [6002, 6002, 6029, 6029, 6154], [6156, 6156, 6183, 6183, 6308], [6310, 6310, 6330, 6330, 8202], [8204, 8278, 8306, 8306, 8511], [8513, 8513, 8585, 8585, 9650], [9652, 9652, 9710, 9710, 9962], [9964, 9964, 10007, 10007, 10198], [10200, 10200, 10224, 10263, 11038], [11040, 11040, 11092, 11092, 11288], [11290, 11290, 11346, 11346, 12395]], "test": "valid"}
{"id": "MljSDW", "name": "Black Jelly", "author": "eddietree", "description": "Obisidian using voronoi and displacement", "tags": ["raymarching"], "likes": 17, "viewed": 490, "published": "Public", "date": "1443894878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a study on raymarching, soft-shadows, ao, etc\n// borrowed heavy from others, esp @cabbibo and @iquilezles and more\n// by @eddietree\n\n#define float3 vec3\n\nconst float INTERSECTION_PRECISION = 0.0001;\nconst int NUM_OF_TRACE_STEPS = 40;\n\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in float3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float radius = 6.0;\n    float theta = 2.0 + 5.0*mouse.x;// + iTime*0.5;\n    float phi = 3.14159*0.4;//5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// noise func\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2; \n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos )\n{  \n    vec3 voro0 = voronoi(pos);\n    \n    float t1 = distSphere( pos + vec3(0.0,0.0,0.0), 1.5 +voro0.y * voro0.x  + sin(pos.x*3.0 - iTime*3.5)*0.6);\n    \n    //float cap0 = sdCapsule( pos + vec3(0.0, sin(pos.x + iTime*3.5)*0.1,0.0), vec3(0.8,0.0,0.0), vec3(9.0,0.3,-0.2), 0.05 );\n    //float cap1 = sdCapsule( pos + vec3(0.0, cos(pos.x + iTime*3.5)*0.1,0.0), vec3(0.8,0.0,0.0), vec3(9.0,-0.3,0.2), 0.05);\n    //float tail = smin( cap0, cap1, 9.0 );\n    //t1 = min( t1, tail);\n    //t1 = capsule;\n    \n    //t1 = min( t1, distSphere( pos + vec3(3.0,0.0,0.0), 0.2 +voronoi(pos).x ) + voronoi(pos*9.0).x*0.01 );\n    //t1 = min( t1, distSphere( pos + vec3(-3.0,0.0,0.0), 0.2 +voronoi(pos).x ) + voronoi(pos*9.0).x*0.01 );\n    //t1 = vnoise(pos*1.0, 2.0 );\n    //float radius = (sin(pos.x) * 0.5 + 0.5) * 2.0;\n    //float t1 = distSphere( pos,  floor(radius) );\n    \n    //t1 = min( t1, distSphere(pos + vec3(4.0,0.0,0.0), 0.3) );\n    //t1 = min( t1, distSphere(pos + vec3(-4.0,0.0,0.0), 0.3) );\n   \n   \treturn vec2( t1, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float k = 2.0;\n    \n    const int maxSteps = 7;\n    float t = 0.0;\n    float res = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n            \n        if(d < INTERSECTION_PRECISION) {\n            \n            return 0.0;\n        }\n        \n        res = min( res, k*d/t );\n        t += d;\n    }\n    \n    return res;\n}\n\n\nfloat ambientOcclusion( in vec3 ro, in vec3 rd )\n{\n    const int maxSteps = 10;\n    const float stepSize = 0.02;\n    \n    float t = 0.0;\n    float res = 0.0;\n    \n    // starting d\n    float d0 = map(ro).x;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n\t\tfloat diff = max(d-d0, 0.0);\n        \n        res += diff;\n        \n        t += stepSize;\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 renderColor( vec3 ro , vec3 rd, in vec3 color, vec3 currPos )\n{\n    //vec3 normal = calcNormal( currPos );\n    //vec3 normal = calcNormal( currPos - rd * Voronesque(currPos*35.0)*0.2 );\n    vec3 normal = calcNormal( currPos );\n    \n    vec3 lightPos = vec3(-1.5,0.0,0.0);\n    vec3 lightColor = vec3(1.0,0.5,0.6);\n\n    //vec3 lightDir = normalize(currPos-lightPos);\n    vec3 lightDir = normalize(vec3(-1.0,0.0,0.0));\n    float shadowVal = shadow( currPos - rd* 0.03, lightDir  );\n    //float ao = ambientOcclusion( currPos - normal*0.01, normal );\n    float ao = ambientOcclusion( currPos -normal*0.1, -normal );\n    float ndotl = abs(dot( -rd, normal ));\n    float rim = pow(1.0-ndotl, 1.75);\n    //float specular = pow( dot( lightDir, normal ), 3.0);\n\n    //vec3 reflectionColor = texture (iChannel0, reflect( rd, normal )).xyz;\n    \n\n    //color = vec3(0.2, 0.5,0.5);\n    //color = normal*0.5+vec3(0.5);\n    color = vec3(mix(vec3(0.0),vec3(0.6,0.2,0.8),shadowVal));\n    \n    color.xyz += (1.0 - smoothstep( 0.3, 2.5, length(currPos-lightPos)))*lightColor;\n    \n    //color = reflectionColor * vec3(0.2);\n    //color += rim * reflectionColor;\n    //color *= vec3(0.1);\n    //color = mix( color, normal*0.5+vec3(0.5), rim_distorted+0.1 );\n\n  \t//color = normal;\n    \n\n    //color = normal;\n    \n    //color *= vec3(mix(0.0,1.0,clamp(ao,0.0,1.0)));\n    color += vec3(rim) * 0.2;\n    //color += vec3(ao)*0.1;\n        \n    return color;\n}\n\nvec3 rayPlaneIntersection( vec3 ro, vec3 rd, vec4 plane )\n{\n\tfloat t = -( dot(ro, plane.xyz) + plane.w) / dot( rd, plane.xyz );\n\treturn ro + t * rd;\n}\n\nbool renderRayMarch(vec3 ro, vec3 rd, inout vec3 color ) {\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    vec3 lightDir = normalize(vec3(1.0,0.4,0.0));\n    \n    for(int i = 0; i < maxSteps; ++i) \n    {\n        vec3 currPos = ro + rd * t;\n        d = map(currPos).x;\n        if(d < INTERSECTION_PRECISION) \n        {\n        \tbreak;\n        }\n        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) \n    {\n\t    vec3 currPos = ro + rd * t;\n    \tcolor = renderColor( ro, rd, color, currPos );\n        return true;\n    }\n    \n    \n    // floor shadow\n    vec3 planePoint = rayPlaneIntersection(ro, rd, vec4(0.0, 1.0, 0.0, 2.5));\n\tfloat shadowFloor = shadow( planePoint, vec3(0.0,1.0,0.0));\n\tcolor = color * mix( 0.85, 1.0, shadowFloor );\n    \n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.6) ); // 2.0 is the lens length\n    \n    // calc color\n    vec3 col = vec3(0.9);\n    //vec3 col = texture (iChannel0, rd).xyz;\n    renderRayMarch( ro, rd, col );\n    \n    // vignette, OF COURSE\n    float vignette = 1.0-smoothstep(1.0,2.5, length(p));\n    col.xyz *= mix( 0.5, 1.0, vignette);\n        \n    fragColor = vec4( col , 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 279, 279, 312], [314, 366, 397, 397, 1182], [1184, 1184, 1250, 1250, 1428], [1430, 1430, 1511, 1511, 1851], [1853, 1853, 1894, 1894, 1965], [1967, 1967, 2000, 2000, 2026], [2028, 2028, 2061, 2061, 2086], [2088, 2102, 2125, 2125, 2161], [2162, 2162, 2188, 2188, 2557], [2559, 2653, 2682, 2682, 2716], [2718, 2718, 2751, 2751, 2776], [2778, 2778, 2799, 2799, 2957], [2959, 3009, 3036, 3036, 3616], [3618, 3618, 3670, 3670, 3797], [3799, 3883, 3905, 3905, 4930], [4932, 4932, 4972, 4972, 5348], [5351, 5351, 5401, 5401, 5769], [5771, 5771, 5803, 5803, 6024], [6026, 6026, 6094, 6216, 7465], [7467, 7467, 7526, 7526, 7617], [7619, 7619, 7677, 7677, 8446], [8449, 8449, 8506, 8506, 9191]], "test": "valid"}
{"id": "MljSDy", "name": "Edge of the universe", "author": "fernozzle", "description": "Yea it's scientifically accurate. I checked.", "tags": ["noise", "domaindistortion"], "likes": 39, "viewed": 2373, "published": "Public", "date": "1446320353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bump up the iterations!\n// More iterations means more detail + aliasing\n#define ITERATIONS 20\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float mouseDown = step(.05, iMouse.z);\n    float scale = mix(1., .4, mouseDown);\n    vec2 look = (iMouse.xy / iResolution.xy - .5) * 3. * mouseDown;\n    \n    float time = iTime * 2. + 15.;\n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord.xy / res - vec2(.5) + look;\n    uv *= vec2(res.x / res.y, 1.) * 4. * scale;\n    \n    float len = dot(uv, uv) * .3 - .4;\n    \n    vec3 z = sin(time * vec3(.23, .19, .17));\n    for (int i = 0; i < ITERATIONS; i++) {\n        z += cos(z.zxy + uv.yxy * float(i) * len);\n    }\n    \n    float val = z.r * .06 + .3;\n    val -= smoothstep(.1, -.3, len) * 1.5 + len * .3 - .4;\n    fragColor = vec4(vec3(max(val, .1)), 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 154, 154, 819]], "test": "valid"}
{"id": "MljSWy", "name": "plasma snakes 2", "author": "FabriceNeyret2", "description": ".", "tags": ["2d"], "likes": 3, "viewed": 897, "published": "Public API", "date": "1446287747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P(t)   vec2( 1.7*cos(t)+.5*sin(-2.7*t), .8*sin(1.2*t)+.5*cos(3.2*t) ) /1.5\n\n#define draw(t,c)  o += smoothstep(.03*c, c-c, vec4(length(P((t))-U)))\n\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n\tvec2 R = iResolution.xy;  \n    U = (2.*U -R ) / R.y;\n    \n    for (float dt=0.; dt<5.; dt+= .01) {\n        \n        float t = dt+iTime;\n        \n        draw( t,       vec4(1,2,3,0));\n        draw( t-1234., vec4(3,2,1,0));        \n     // draw( t+1234., vec4(2,3,1,0));        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 196, 196, 502]], "test": "valid"}
{"id": "MljSzd", "name": "Capri", "author": "dr2", "description": "The famous Faraglione di Mezzo (the spherical cow version x2) - mouse enabled.", "tags": ["raymarching", "seascape"], "likes": 21, "viewed": 1227, "published": "Public API", "date": "1446025099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Capri\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4v3 (ip);\n  t2 = Hashv4v3 (ip + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    a *= 0.5;\n    p *= 4. * mr;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  const vec3 e = vec3 (0.1, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi * clamp (p.x / rhi, -1., 1.), 0.)) - rlo,\n     abs (p.z) - h);\n}\n\nvec3 qHit, sunDir, cloudDisp, waterDisp;\nfloat tCur;\nint idObj;\nconst float dstFar = 100.;\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.2, 0.9), vec3 (0.45, 0.45, 0.6),\n     1. - max (rd.y, 0.));\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, clCol, col;\n  float fCloud, cloudLo, cloudRngI, atFac, colSum, attSum, s,\n     att, a, dDotS, ds;\n  const int nLay = 30;\n  cloudLo = 300.;  cloudRngI = 1./100.;  atFac = 0.04;\n  fCloud = 0.5;\n  if (rd.y < 0.015 * Fbm1 (16. * rd.x)- 0.0075) {\n    col = vec3 (0.2, 0.3, 0.2) *\n       (0.7 + 0.3 * Noisefv2 (1000. * vec2 (5. * atan (rd.x, rd.z), rd.y)));\n  } else if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro += cloudDisp;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      att += atFac * max (fCloud - 0.5 * Fbm3 (0.0035 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * 2.8 * (colSum + 0.05);\n    cSun = vec3 (1.) * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    col = clamp (mix (SkyBg (rd) + cSun, clCol, attSum), 0., 1.);\n    col = mix (col, SkyBg (rd), pow (1. - rd.y, 32.));\n  } else col = mix (vec3 (0.07, 0.15, 0.2), SkyBg (- rd), pow (1. + rd.y, 32.));\n  return col;\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 1.;  wAmp = 0.07;  pRough = 10.;\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 5; j ++) {\n    t2 = 0.6 * tCur * vec2 (1., -1.);\n    t4 = vec4 (q2 + t2.xx, q2 + t2.yy) * wFreq;\n    t2 = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + abs (cos (t4)));\n    v2 = pow (1. - sqrt (v4.xz * v4.yw), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.25;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = 0.;\n    sLo = 0.;\n    for (int j = 0; j < 100; j ++) {\n      p = ro + s * rd;\n      h = p.y - WaveHt (p);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.3, h) + 0.005 * s;\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        h = step (0., p.y - WaveHt (p));\n        sLo += h * (s - sLo);\n        sHi += (1. - h) * (s - sHi);\n      }\n      dHit = sHi;\n    }\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  float ht = WaveHt (p);\n  return normalize (vec3 (ht - WaveHt (p + e.xyy), e.x, ht - WaveHt (p + e.yyx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin, a, r, rb, h, dr;\n  dMin = dstFar;\n  p.z = abs (p.z) - 6.;\n  h = 2.5 + 0.02 * sin (23. * q.x);\n  q = p;\n  q.y -= 0.25;\n  rb = 1.8;\n  r = max (0., rb - 0.5 * q.y / h - 0.005 * sin (61. * q.y / h));\n  a = atan (q.z, q.x) + 0.03 * sin (16.2 * q.y / h);\n  dr = 0.04 * max (r - rb + 0.6, 0.) * sin (30. * a);\n  d = PrRCylDf (q.xzy, r + dr, 0.5, h);\n  a = atan (q.y, q.x) + 0.03 * sin (22.2 * q.z / rb);\n  dr = 0.006 * sin (33. * a) + 0.004 * sin (43. * a + 1.);\n  d = max (d, - PrFlatCylDf (q.yxz, 0.4 + dr, 0.5 + dr, h));\n  d = max (d, - 0.5 - q.y);\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.05;\n  for (int i = 0; i < 20; i ++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.15;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 trkBox, rp;\n  float ti[9], tTurn, rdTurn, a, dt, rSeg;\n  trkBox = vec2 (1.7, 14.);\n  rdTurn = 0.9999 * min (trkBox.x, trkBox.y);\n  tTurn = 0.5 * pi * rdTurn * 1.5;\n  ti[0] = 0.;\n  ti[1] = ti[0] + trkBox.y - rdTurn;\n  ti[2] = ti[1] + tTurn;\n  ti[3] = ti[2] + trkBox.x - rdTurn;\n  ti[4] = ti[3] + tTurn;\n  ti[5] = ti[4] + trkBox.y - rdTurn;\n  ti[6] = ti[5] + tTurn;\n  ti[7] = ti[6] + trkBox.x - rdTurn;\n  ti[8] = ti[7] + tTurn;\n  t = mod (0.5 * t, ti[8]);\n  rSeg = -1.;\n  rp = vec2 (1.) - rdTurn / trkBox;\n  p.xz = trkBox;\n  p.y = 0.;\n  if (t < ti[4]) {\n    if (t < ti[1]) {\n      dt = (t - ti[0]) / (ti[1] - ti[0]);\n      p.xz *= vec2 (1., rp.y * (2. * dt - 1.));\n    } else if (t < ti[2]) {\n      dt = (t - ti[1]) / (ti[2] - ti[1]);\n      rSeg = 0.;\n      p.xz *= rp;\n    } else if (t < ti[3]) {\n      dt = (t - ti[2]) / (ti[3] - ti[2]);\n      p.xz *= vec2 (rp.x * (1. - 2. * dt), 1.);\n    } else {\n      dt = (t - ti[3]) / (ti[4] - ti[3]);\n      rSeg = 1.;\n      p.xz *= rp * vec2 (-1., 1.);\n    }\n  } else {\n    if (t < ti[5]) {\n      dt = (t - ti[4]) / (ti[5] - ti[4]);\n      p.xz *= vec2 (- 1., rp.y * (1. - 2. * dt));\n    } else if (t < ti[6]) {\n      dt = (t - ti[5]) / (ti[6] - ti[5]);\n      rSeg = 2.;\n      p.xz *= - rp;\n    } else if (t < ti[7]) {\n      dt = (t - ti[6]) / (ti[7] - ti[6]);\n      p.xz *= vec2 (rp.x * (2. * dt - 1.), - 1.);\n    } else {\n      dt = (t - ti[7]) / (ti[8] - ti[7]);\n      rSeg = 3.;\n      p.xz *= rp * vec2 (1., -1.);\n    }\n  }\n  if (rSeg >= 0.) {\n    a = 0.5 * pi * (rSeg + dt);\n    p += rdTurn * vec3 (cos (a), 0., sin (a));\n  }\n  p.x -= trkBox.x;\n  return p;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 objCol, col, rdd, vn, vnw;\n  float dstHit, dstWat, sh;\n  int idObjT;\n  bool waterRefl;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  dstWat = WaveRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstHit));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    vnw = WaveNf (ro, dstWat);\n    rdd = rd;\n    rd = reflect (rd, vnw);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == 1) {\n      vn = VaryNf (21.1 * qHit, vn, 5.);\n      objCol = mix (vec3 (0.45, 0.4, 0.4), vec3 (0.6),\n         clamp (Fbm2 (vec2 (50. * (atan (qHit.z, qHit.x) / pi + 1.),\n\t 21. * qHit.y)) - 0.6, 0., 1.));\n      objCol *= mix (vec3 (0.5, 0.6, 0.5), vec3 (1.),\n         smoothstep (-0.2, -0.15, qHit.y));\n    }\n    sh = 0.5 + 0.5 * ObjSShadow (ro, sunDir);\n    col = objCol * (0.2 +\n       0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       sh * max (dot (vn, sunDir), 0.)) +\n       0.4 * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else col = SkyHrzCol (ro, rd);\n  if (waterRefl) {\n    col = mix (vec3 (0.07, 0.15, 0.2), col,\n       0.8 * pow (1. - abs (dot (rdd, vnw)), 4.));\n    col = mix (col, vec3 (0.9),\n       pow (clamp (WaveHt (ro) + 0.5 * Fbm3 (4. * ro), 0., 1.), 8.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 sa;\n  const vec3 e = vec3 (1., 0., -1.);\n  const vec2 hax = vec2 (0.866, 0.5);\n  uv *= 2.;\n  if (sd.z > 0.) {\n    sa = uv + 0.3 * sd.xy;\n    col = 0.2 * pow (sd.z, 8.) *\n       (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n       e.xxy * (1. - smoothstep (0.11, 0.12, max (abs (sa.y),\n       max (abs (dot (sa, hax)), abs (dot (sa, hax * e.xz)))))) +\n       e.xyx * SmoothBump (0.32, 0.4, 0.04, length (uv - 0.7 * sd.xy)) +\n       0.8 * e.yxx * SmoothBump (0.72, 0.8, 0.04, length (uv + sd.xy)));\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, ca, sa, vd, u;\n  vec2 uv;\n  float el, az, rl, f;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  sunDir = normalize (vec3 (-0.5, 0.5, -1.));\n  cloudDisp = 10. * tCur * vec3 (1., 0., -1.);\n  waterDisp = 0.1 * tCur * vec3 (-1., 0., 1.);\n  ro = TrackPath (tCur);\n  vd = normalize (TrackPath (tCur + 0.2) - ro);\n  ro.y = 0.6;\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (- vd.z, 0., vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  az = 0.15 * sin (0.22 * tCur + 0.2) + 0.1 * sin (0.53 * tCur);\n  el = -0.05 * pi + 0.05 * (1. + sin (0.5 * tCur + 0.3)) +\n     0.034 * (1. + sin (0.8 * tCur));\n  if (mPtr.z > 0.) {\n    az = clamp (az - 1.5 * pi * mPtr.x, -0.5 * pi, 0.5 * pi);\n    el = clamp (el - 0.3 * pi * mPtr.y, -0.2 * pi, 0.4 * pi);\n  }\n  rl = 0.1 * sin (0.5 * tCur) + 0.06 * sin (0.8 * tCur + 0.3);\n  ca = cos (vec3 (el, az, rl));\n  sa = sin (vec3 (el, az, rl));\n  vuMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) * vuMat;\n  rd = normalize (vec3 (uv, 2.5)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd) + GlareCol (rd, vuMat * sunDir, uv), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljSzd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[260, 260, 284, 284, 334], [336, 336, 360, 360, 407], [409, 409, 433, 433, 672], [674, 674, 699, 699, 845], [847, 847, 872, 872, 1071], [1073, 1073, 1099, 1099, 1419], [1421, 1421, 1443, 1443, 1581], [1583, 1583, 1604, 1604, 1743], [1745, 1745, 1766, 1766, 1988], [1990, 1990, 2019, 2019, 2231], [2233, 2233, 2272, 2272, 2495], [2497, 2497, 2554, 2554, 2637], [2639, 2639, 2692, 2692, 2871], [2873, 2873, 2932, 2932, 3036], [3130, 3130, 3152, 3152, 3241], [3243, 3243, 3278, 3278, 4683], [4685, 4685, 4708, 4708, 5380], [5382, 5382, 5416, 5416, 6005], [6007, 6007, 6038, 6038, 6197], [6199, 6199, 6221, 6221, 6869], [6871, 6871, 6904, 6904, 7080], [7082, 7082, 7103, 7103, 7311], [7313, 7313, 7350, 7350, 7562], [7564, 7564, 7590, 7590, 9210], [9212, 9212, 9247, 9247, 10664], [10666, 10666, 10709, 10709, 11298], [11300, 11300, 11356, 11356, 12729]], "test": "error"}
{"id": "MljXDG", "name": "vt220", "author": "sprash3", "description": "Trying to emulate the look of a DEC vt220 vintage serial terminal.\nUse mouse to adjust screen curvature. Uncomment MOUSE_MOVE to move terminal around.", "tags": ["2d", "retro", "screen", "crt", "curve", "terminal"], "likes": 22, "viewed": 1596, "published": "Public", "date": "1446257155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOUSE_CURVE\n//#define MOUSE_MOVE\n\n#define WIDTH 0.48\n#define HEIGHT 0.3\n#define CURVE 3.0\n\n#define BEZEL_COL vec4(0.8, 0.8, 0.6, 0.0)\n#define PHOSPHOR_COL vec4(0.2, 1.0, 0.2, 0.0)\n#define SHINE 0.66\n#define AMBIENT 0.33\n\n#define NO_OF_LINES iResolution.y*HEIGHT\n#define SMOOTH 0.004\n\nprecision highp float;\n\n// using normal vectors of a sphere with radius r\nvec2 crtCurve(vec2 uv, float r) \n{\n        uv = (uv - 0.5) * 2.0;// uv is now -1 to 1\n    \tuv = r*uv/sqrt(r*r -dot(uv, uv));\n        uv = (uv / 2.0) + 0.5;// back to 0-1 coords\n        return uv;\n}\n\nfloat roundSquare(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// Some Plasma stolen from dogeshibu for testing\nfloat somePlasma(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 ||  uv.y < 0.0 || uv.y > 1.0) return 0.0;\n    \n    float scln = 0.5 - 0.5*cos(uv.y*3.14*NO_OF_LINES); // scanlines\n    uv *= vec2(80, 24); // 80 by 24 characters\n    uv = ceil(uv);\n    uv /= vec2(80, 24);\n    \n    float color = 0.0;\n    color += 0.7*sin(0.5*uv.x + iTime/5.0);\n    color += 3.0*sin(1.6*uv.y + iTime/5.0);\n    color += 1.0*sin(10.0*(uv.y * sin(iTime/2.0) + uv.x * cos(iTime/5.0)) + iTime/2.0);\n    float cx = uv.x + 0.5*sin(iTime/2.0);\n    float cy = uv.y + 0.5*cos(iTime/4.0);\n    color += 0.4*sin(sqrt(100.0*cx*cx + 100.0*cy*cy + 1.0) + iTime);\n    color += 0.9*sin(sqrt(75.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += -1.4*sin(sqrt(256.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += 0.3 * sin(0.5*uv.y + uv.x + sin(iTime));\n    return scln*floor(3.0*(0.5+0.499*sin(color)))/3.0; // vt220 has 2 intensitiy levels\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t// aspect-ratio correction\n\tvec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\tuv = 0.5 + (uv -0.5)/ aspect.yx;\n    \n#ifdef MOUSE_CURVE\n    float r = 1.5*exp(1.0-iMouse.y/iResolution.y);\n#else\n    float r = CURVE;\n#endif\n        \n    // Screen Layer\n    vec2 uvS = crtCurve(uv, r);\n#ifdef MOUSE_MOVE\n    uvS.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n\n    // Screen Content           \n    vec2 uvC = (uvS - 0.5)* 2.0; // screen content coordinate system\n    uvC *= vec2(0.5/WIDTH, 0.5/HEIGHT);\n    uvC = (uvC / 2.0) + 0.5;\n     \n    float val = somePlasma(uvC);\n                \n  \tc += PHOSPHOR_COL * val * 2.0 *\n    \tsmoothstep(SMOOTH/2.0, -SMOOTH/2.0, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH-1E-3, HEIGHT-1E-3), 1.0E-10));\n    \n    // Shine\n    c += max(0.0, SHINE - distance(uvS, vec2(0.5, 1.0))) *\n        smoothstep(SMOOTH/2.0, -SMOOTH/2.0, roundSquare(uvS-vec2(0.5, 0.47), vec2(WIDTH, HEIGHT), 0.05));\n    \t\n    // Ambient\n    c += max(0.0, AMBIENT - 0.5*distance(uvS, vec2(0.5,0.5))) *\n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05));\n  \n\n    // Enclosure Layer\n    vec2 uvE = crtCurve(uv, r+0.25);\n#ifdef MOUSE_MOVE\n    uvE.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n    \n    // Inner Border\n  \tc += (BEZEL_COL + 0.2 - uv.y) * \n        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    \n    // Shine\n  \tc += (BEZEL_COL - 0.4)* \n        smoothstep(-SMOOTH*2.0, SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.505), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.495), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n\n    // Outer Border\n    c += BEZEL_COL * \n       \tsmoothstep(-SMOOTH, SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.15, 0.05)); \n\n    // Shine\n    c += (BEZEL_COL - 0.4)* \n       \tsmoothstep(-SMOOTH*2.0, SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.495), vec2(WIDTH, HEIGHT) + 0.15, 0.05)) * \n        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.505), vec2(WIDTH, HEIGHT) + 0.15, 0.05)); \n\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 366, 400, 400, 563], [565, 565, 609, 609, 651], [653, 702, 729, 729, 1603], [1606, 1606, 1662, 1662, 4069]], "test": "valid"}
{"id": "MlSSzc", "name": "Cloudy Spiral", "author": "aiekick", "description": "Cloudy Spiral ", "tags": ["spiral", "cloudy"], "likes": 27, "viewed": 1522, "published": "Public API", "date": "1445375097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* \n\tthe cloudy famous tech come from the shader of duke : https://www.shadertoy.com/view/MljXDw\n        Himself a Port of a demo by Las => http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n*/\n\nfloat t;\n\n#define uTex2D iChannel0\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture(uTex2D, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n// new code by shane\nfloat df(vec3 p)\n{\n    float pnNoise = pn(p*.26)*1.98 + pn(p*.26)*.62 + pn(p*1.17)*.39;\n    p.xy = 20. - abs(p.xy - vec2(cos(p.z - t), -sin(p.z - t))*12.);\n    return min(p.x, p.y) + pnNoise;\n}\n\n/* original code\nfloat df(vec3 p)\n{\n\tfloat pnNoise = pn(p*.26)*1.98 + pn(p*.26)*.62 + pn(p*1.17)*.39;\n\tp.x -= cos(p.z - t)*12.;\n\tp.y += sin(p.z - t)*12.;\n\tfloat lr = min(p.x, -p.x) + 20.;\n\tfloat bt = min(p.y, -p.y) + 20.;\n\treturn min(lr, bt) + pnNoise;\n}*/\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv, float fov)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu, rov));\n    vec3 v = normalize(cross(rov, u));\n    vec3 rd = normalize(rov + fov*u*uv.x + fov*v*uv.y);\n    return rd;\n}\n\nvec3 march(vec3 f, vec3 ro, vec3 rd, float st)\n{\n\tvec3 s = vec3(1), h = vec3(.16,.008,.032), w = vec3(0);\n\tfloat d=1.,dl=0., td=0.;\n\tvec3 p = ro;\n\tfor(float i=0.;i<100.;i++)\n\t{      \n\t\tif(s.x<0.01||d>40.||td>.95) break;\n        s = df(p) * .1 * i/vec3(107,160,72);\n\t\tw = (1.-td) * (h-s) * i/vec3(61,27,54) * step(s,h);\n\t\tf += w;\n\t\ttd += w.x + .01;\n\t\tdl += 1. - exp(-0.001 * log(d));;\t\n\t\ts = max(s, st);\n\t\td +=s.x; \n\t\tp =  ro+rd*d;\t\n   \t}\n\tdl += 2.52;\n\tf /= dl/7.04;\n\tf = mix( f.rgb, vec3(0), 1. - exp( -.0017*d*d) ); // fog\n\treturn f;\n}\n\n#define uTime iTime\n#define uScreenSize iResolution.xy\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tt = uTime*1.5;\n\tf = vec4(0,0.15,0.32,1);\n    vec2 q = g/uScreenSize;\n    vec3 ro = vec3(cos(-t), sin(-t),t )*vec3(vec2(8.+(sin(t)*.5+.5)*4.),5.);\n\tvec3 rd = cam((2.*g-uScreenSize)/uScreenSize.y, ro, vec3(0,1,0), ro + vec3(0,0,1), 3.5);\n\tf.rgb = march(f.rgb, ro, rd, 0.396);\n    f.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); // vignette\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[433, 433, 456, 456, 670], [672, 693, 711, 711, 886], [1146, 1146, 1203, 1203, 1385], [1387, 1387, 1435, 1435, 1923], [1980, 1980, 2021, 2021, 2380]], "test": "error"}
{"id": "MlSXRG", "name": "Jungle Fractal II", "author": "gtoledo3", "description": "A progression of my earlier \"Altered Julia Jungle\" post. It seemed different enough in style to merit a separate post.", "tags": ["julia", "jungle"], "likes": 11, "viewed": 1176, "published": "Public API", "date": "1444506272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float depthCull=.1;\nfloat zoom=2.;\nfloat bailout=12.;\nfloat X=-.7;\nfloat Y=.3;\nvec2 offset=vec2(0.,.4);\nconst int iterations=16;\n//jungle fractal II, by George Toledo, 2015.\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details, located in ZIP file here:\n// http://webstaff.itn.liu.se/~stegu/GLSL-cellular/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nvec2 cmult(vec2 a, vec2 b)\n{\n\tvec2 p;\n\tp[0]=a[0]*b[0]-a[1]*b[1];\n\tp[1]=a[0]*b[1]+a[1]*b[0];\n\treturn p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 offset=vec2(offset.x+sin(iTime*.1)*.1,offset.y+cos(iTime*.1)*.1);\n\tvec2 position = (gl_FragCoord.xy/iResolution.x) - offset;\n\t\n\tposition = position * (zoom+sin(iTime*.1)*.2);\n\tvec2 mouse=vec2(X+sin(iTime)*.01,Y+cos(iTime)*.02);\n\tvec2 c, c0, d;\n\tfloat v;\n\t\n\tc = vec2(position);\n\tc0 = mouse;\n\tc +=sin(iTime+cellular(c )*.1)*.01;\n\tvec2 f = position.xy;\n\tfor(int i=0; i<iterations; i++) {\n\t\td = cmult(c, c);\n\t\tc = d + c0;\n\t\tv = sqrt((c.x*c.x)) + (c.y*c.y) / sin(length(c.x )*4.);\n\n\t\tif (v > bailout) break;\n\t}\n\tfloat l=sin(( c.y*2.)*.23);\n\tc +=cellular( c*23.);\n\t//l +=sin(c.y *1.2)*.5;\n\t//l +=sin(c.y *.2)*.1;\n\tc.x+=sin(c.y*2.);\n\tc.y+=sin(c.x*20.)*.1;\n\tc.x+=sin(c.y*3.);\n\tc.y+=sin(c.x*5.);\n\t\n\tfloat rand = mod(fract(sin(dot(2.5*gl_FragCoord.xy/iResolution.xy, vec2(12.9898,100.233))) * 43758.5453), .7);\n\tfragColor=vec4(0.);\n\tif(v>depthCull*100.){\n\n\tfragColor = vec4(vec3(sin(c.x*l*10.)*.6,length(-1.5-sin(-c*.6))*.17,sin(c.y*l)*.5)*(smoothstep(d.x,.1,.7)),.3);}\n\t\n\telse if(v<depthCull*100. && v>depthCull*.1 ){\n\tc.x=c.x+iTime*1.1;\n\tv +=sin(c.x*1.1)*.1;\n\tv +=sin(c.y*2.3)*.1;\n\tv +=sin(c.x*3.5)*.1;\n\tv +=sin(c.y*4.)*.1;\n\tv +=sin(c.y*6.)*.1;\n\tv +=sin(c.x*5.)*.1;\n\tv +=sin(c.x*10.)*.1;\n\tv +=sin(c.x*128.)*.01;\n\tv +=cellular( c ).x;\n\n\tv=max(0.,v);\n\tv=exp(v)-1.4;\n\tfragColor = vec4(rand+vec3(pow(v+.46,-.75)),1.)*vec4(.1,.17,.2,1.);\n\t}\n\t//fragColor=vec4(vec3(0.),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[470, 517, 539, 539, 584], [586, 692, 715, 715, 2246], [2248, 2248, 2276, 2276, 2352], [2353, 2353, 2410, 2410, 3782]], "test": "valid"}
{"id": "MlSXWw", "name": "2d experiment #3 - pii", "author": "public_int_i", "description": "2d experiment, mouse y to change iterations.", "tags": ["2d", "experiment"], "likes": 0, "viewed": 296, "published": "Public API", "date": "1445270527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = cos(iTime*.3)*.25+.29;\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy)*zoom - (zoom-.2);\n    vec2 uv1,uv2,uv3,uv4;\n    uv1 = uv2 = uv3 = uv4 = uv;\n    \n    int iterations = int((iMouse.y/iResolution.y)*11. + 1.);\n    if (iMouse.w < 1.) iterations = 11;\n    \n    vec3 col = vec3(0.);\n    float d = 0.;\n    for (int i = 0; i < 12; i++) {\n        if (i > iterations) break;\n        \n        vec2 dir = vec2(.5/float(i+1), 0.);\n    \n        uv1 += dir;\n        uv2 += dir.yx;\n        uv3 -= dir;\n        uv4 -= dir.yx;\n        \n        float size = (.5/float(i+1));\n        float sizeDiv = size/1.25;\n    \td = max(d, length(max(abs(mod(uv1,size*2.)-size)-sizeDiv, 0.)));\n        d = max(d, length(max(abs(mod(uv2,size*2.)-size)-sizeDiv, 0.)));\n        d = max(d, length(max(abs(mod(uv3,size*2.)-size)-sizeDiv, 0.)));\n        d = max(d, length(max(abs(mod(uv4,size*2.)-size)-sizeDiv, 0.)));\n    \n    \tcol = (vec3(sin(d*160.2345+float(i)*.1+uv3.y*36.),\n                    cos(d*120.2+float(i)*.1+uv2.x*36.),\n                    -cos(d*240.4+uv1.y*36.))*.5+.5)*\n               max(0., 1.-d*20.);\n    }\n    \t\n    fragColor = vec4(col,1.);//max(0., 1.-d*20.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1229]], "test": "valid"}
{"id": "MlSXzG", "name": "Are Gee Be", "author": "jasminpatry", "description": "First foray into 3D SDF raymarching.  See top of code to enable AA, importance sampling, DOF, motion blur, etc. \n", "tags": ["procedural", "3d", "raymarching", "sdf", "metaballs", "motionblur", "dof", "importancesampling", "pbr", "ggx"], "likes": 108, "viewed": 6320, "published": "Public", "date": "1444539928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Configuration\n\n// Number of (primary) rays per pixel\n\n#define RAY_COUNT (1)\n\n// Enable specular importance sampling?\n\n#define ENABLE_IS 0\n\n// Larger values reduces fireflies\n\nconst float g_gISNoiseReduction = 0.005;\n\n// Enable depth of field?\n\n#define ENABLE_DOF 0\n\n// Controls size of DOF ray cone\n\nconst float g_rDOFScale = 0.015;\n\n// Enable motion blur?\n\n#define ENABLE_MOTION_BLUR 0\n\n// Motion blur exposure time in seconds.\n\nconst float g_dTExposure = 1.0 / 48.0;\n\n// Number of reflection bounces\n\nconst int g_cBounce = 3;\n\n// Angle (radians) to tilt camera down\n\nconst float g_radTiltCamera = 0.06;\n\n// Full-strength (mirror-like, no fog) sun reflections. Fake, but combined with long-exposure\n//\tmotion blur gives cool specular light painting effects. Has no effect unless ENABLE_IS is on.\n\n#define FULL_STRENGTH_SUN 0\n\n// Scaling factor for sun reflections & specular highlights. Alternative or complement to\n//\tFULL_STRENGTH_SUN to achieve light painting effects.\n\nconst float g_rSunSpecScale = 1.0;\n\n// If true, uses same low-discrepancy sequence to generate DOF and IS samples. Generally not good\n//\tpractice, but can generate rather beautiful results when combined with long exposure times.\n\n#define CORRELATED_DOF 0\n\n// If true, uses same low-discrepancy sequence to generate motion blur and IS samples. Generally\n//\tnot good practice, but can generate rather beautiful results when combine with long exposure\n//\ttimes. For example see https://twitter.com/jasminpatry/status/652570309204115456\n\n#define CORRELATED_MB 0\n\n// For doing high-res offline tiled renders\n\n#define TILED_RENDER 0\n\n// If true, use soft-min from @mmalex's SIGGRAPH 2015 presentation. (This is what started me on\n//\tthis in the first place.) If false, uses \"classic\" soft-min (see\n//\thttp://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/ ), which has the\n//\tadvantage that its derivatives are continuous everywhere.\n\n#define MM_SOFT_MIN 0\n\n// My son's color scheme :)\n\n#define BERNIE_COLORS 0\n\n// Halloween colors\n\n#define HALLOWEEN_COLORS 0\n\n// Disable AO? Doesn't contribute very much since diffuse albedo is dark, and it's pretty\n//\texpensive...\n\n#define DISABLE_AO 0\n\n// Disable shadows?\n\n#define DISABLE_SHADOWS 0\n\n// Debug displays\n\n#define DEBUG_STEPS\t\t0\n#define DEBUG_DIFFUSE\t0\n#define DEBUG_NORMALS\t0\n#define DEBUG_AO\t\t0\n#define DEBUG_SHADOWS\t0\n\n// End configuration\n\n\n\nconst float g_gPi = 3.14159265359;\n\n// Maximum ray length\n\nconst float g_sRayMax = 1.0e5;\n\n// Maximum geometry height\n\nconst float g_zMax = 400.0;\n\n// Specular reflectance at normal incidence\n\nconst float g_rSpecular = 0.04;\n\n// Global time (jittered if motion blur is enabled)\n\nfloat g_t = 0.0;\n\n// [0-1] uniform random values for importance sampling\n\nvec2 g_vecURandomIS = vec2(0);\n\n// Light direction\n\nvec3 g_normalLight = vec3(0);\n\nfloat saturate(float g)\n{\n\treturn clamp(g, 0.0, 1.0);\n}\n\nvec2 saturate(vec2 vec)\n{\n\treturn clamp(vec, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 vec)\n{\n\treturn clamp(vec, 0.0, 1.0);\n}\n\nvec4 saturate(vec4 vec)\n{\n\treturn clamp(vec, 0.0, 1.0);\n}\n\nfloat GLuminance(vec3 rgbLinear)\n{\n\treturn dot(rgbLinear, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat GSign(float g)\n{\n\treturn (g < 0.0) ? -1.0 : 1.0;\n}\n\nfloat GSqr(float g)\n{\n\treturn g * g;\n}\n\nfloat GLengthSqr(vec3 vec)\n{\n\treturn dot(vec, vec);\n}\n\nfloat UHash(vec2 xy)\n{\n\treturn fract(sin(dot(xy.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 VecHash2(vec2 xy)\n{\n\t// BB Values for y component pulled out of the air, more or less.\n\n\treturn fract(sin(vec2(\n\t\t\t\t\t\tdot(xy, vec2(12.9898, 78.233)),\n\t\t\t\t\t\tdot(xy, vec2(-67.233, 10.9898)))) * vec2(43758.5453, 73756.5453));\n}\n\nvec2 VecSubRandom(vec2 vecPrev)\n{\n\t// From http://mollwollfumble.blogspot.com/2011/03/subrandom-numbers.html\n\t//\tInteractive graph: https://www.desmos.com/calculator/rvtbalxuhq\n\n\tvecPrev += vec2(0.5545497, 0.308517);\n\treturn vecPrev - floor(vecPrev);\n}\n\nvec2 VecDisc(vec2 vecURandom)\n{\n\t// For vecURandom uniformly distributed in [0, 1], returns uniform samples on unit disc.\n\n\tfloat rad = vecURandom.x * 2.0 * g_gPi;\n\tfloat s = sqrt(vecURandom.y);\n\treturn s * vec2(cos(rad), sin(rad));\n}\n\nvec3 VecRotateY(vec3 vec, float rad)\n{\n\tfloat gSin = sin(rad);\n\tfloat gCos = cos(rad);\n\tvec3 vecRot = vec;\n\tvecRot.x = vec.x * gCos + vec.z * gSin;\n\tvecRot.z = - vec.x * gSin + vec.z * gCos;\n\treturn vecRot;\n}\n\nvoid UpdateLightDirection()\n{\n\tvec3 normalLight = normalize(vec3(0.2, 0.9, 0.2));\n\tfloat radTheta = 2.0 * g_gPi * g_t / 60.0;\n\tfloat gSin = sin(radTheta);\n\tfloat gCos = cos(radTheta);\n\tmat2 matRot = mat2(gCos, -gSin, gSin, gCos);\n\tnormalLight.xy = matRot * normalLight.xy;\n\tg_normalLight = normalLight;\n}\n\nvec3 RgbLight()\n{\n#if BERNIE_COLORS\n\treturn vec3(1.7, 0.3, 0.1);\n#elif HALLOWEEN_COLORS\n\treturn vec3(1.7, 0.15, 0.0);\n#else\n\treturn vec3(2.0, 0.1, 0.1);\n#endif\n}\n\nfloat RLightCone()\n{\n\t// tan of one half of subtended angle of sun disc in sky\n\n\treturn 0.02;\n}\n\nfloat GDotLightCone()\n{\n\treturn cos(atan(RLightCone()));\n}\n\nvec3 RgbSunDisc()\n{\n\treturn RgbLight() / (GSqr(RLightCone()));\n}\n\nvec3 RgbSky()\n{\n#if BERNIE_COLORS\n\treturn vec3(0.6, 0.4, 0.05);\n#elif HALLOWEEN_COLORS\n\treturn vec3(0.01, 0.001, 0.0);\n#else\n\treturn vec3(1.0, 1.0, 1.0) * 0.1;\n#endif\n}\n\nvec3 RgbAmbient()\n{\n\treturn RgbSky() / g_gPi;\n}\n\nvec3 RgbFog(vec3 normalRay)\n{\n#if BERNIE_COLORS\n\tvec3 rgbFog = RgbSky() * 3.0;\n#elif HALLOWEEN_COLORS\n\tvec3 rgbFog = vec3(1.0, 0.0, 0.0) * 0.03;\n#else\n\tvec3 rgbFog = vec3(0.6, 0.2, 1.0);\n#endif\n\treturn mix(rgbFog, RgbLight() * 3.5, GSqr(saturate(dot(normalRay, g_normalLight))));\n}\n\nvec4 VecOsc(vec4 vecFreq, vec4 vecAmp, float dT)\n{\n\treturn vecAmp * sin(vec4((g_t + dT) * 2.0 * g_gPi) * vecFreq);\n}\n\nvec4 Sphere0(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0, 0.0),\n\t\t\t\t\t\t\tvec4(20, 100, 100, 0) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(1.10382 / 6.0, 1.092385 / 10.0, 1.03389 / 14.0, 0),\n\t\t\t\t\t\t\t\tvec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);\n}\n\nvec4 Sphere1(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0, 0),\n\t\t\t\t\t\t\tvec4(20, 100, 100, 0) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(1.0328 / 14.0, 1.1381 / 6.0, 1.0238 / 10.0, 0),\n\t\t\t\t\t\t\t\tvec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);\n}\n\nvec4 Sphere2(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0, 0),\n\t\t\t\t\t\t\tvec4(20, 100, 100, 0) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(1.0 / 10.0, 1.0 / 14.0, 1.0 / 6.0, 0),\n\t\t\t\t\t\t\t\tvec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);\n}\n\nfloat SSoftMinRadius01(float uRandom)\n{\n\treturn 100.0 + 50.0 * sin(g_t * 1.14 + uRandom * 100.0);\n}\n\nfloat SSoftMinRadius12(float uRandom)\n{\n\treturn 100.0 + 50.0 * sin(g_t * 1.16323823 + uRandom * 100.0);\n}\n\nvec3 RgbTonemap(vec3 rgbLinear)\n{\n\t// Desaturate with luminance\n\n\tfloat gLuminance = GLuminance(rgbLinear);\n\trgbLinear = mix(rgbLinear, vec3(gLuminance), GSqr(saturate((gLuminance - 1.0) / 1.0)));\n\n\t// Hejl/Burgess-Dawson approx to Hable operator; includes sRGB conversion\n\n\tvec3 rgbT = max(vec3(0.0), rgbLinear - 0.004);\n\tvec3 rgbSrgb = (rgbT * (6.2 * rgbT + 0.5)) / (rgbT * (6.2 * rgbT + 1.7) + 0.06);\n\n\treturn rgbSrgb;\n}\n\nstruct SMaterial\t// tag = mtl\n{\n\tvec3 m_rgbDiffuse;\n\tfloat m_gGgxAlpha;\n};\n\nSMaterial MtlCreate(vec3 rgbDiffuse, float gGgxAlpha)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = rgbDiffuse;\n\tmtl.m_gGgxAlpha = gGgxAlpha;\n\treturn mtl;\n}\n\nSMaterial MtlLerp(SMaterial mtl0, SMaterial mtl1, float u)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = mix(mtl0.m_rgbDiffuse, mtl1.m_rgbDiffuse, u);\n\tmtl.m_gGgxAlpha = mix(mtl0.m_gGgxAlpha, mtl1.m_gGgxAlpha, u);\n\treturn mtl;\n}\n\nstruct SHit\t// tag = hit\n{\n\tfloat m_s;\n\tvec3 m_normal;\n\tSMaterial m_mtl;\n};\n\nSHit HitMin(SHit hit0, SHit hit1)\n{\n\tif (hit0.m_s < hit1.m_s)\n\t{\n\t\treturn hit0;\n\t}\n\telse\n\t{\n\t\treturn hit1;\n\t}\n}\n\nSHit HitPlane(vec4 plane, SMaterial mtl, vec3 posRay, vec3 normalRay)\n{\n\tfloat gDotNormal = dot(plane.xyz, normalRay);\n\n\tfloat s = -dot(plane, vec4(posRay, 1.0)) / gDotNormal;\n\n\tSHit hit;\n\n\thit.m_normal = plane.xyz;\n\tvec3 posHit = (posRay + s * normalRay);\n\thit.m_normal.xy += saturate(-normalRay.z) * 0.1 * sin(posHit.xy / (100.0));\n\thit.m_normal = normalize(hit.m_normal);\n\thit.m_s = (abs(gDotNormal) > 1e-6 && s > 0.0) ? s : g_sRayMax;\n\thit.m_mtl = mtl;\n\n\treturn hit;\n}\n\nstruct SSdfSample\t// tag = sdf\n{\n\tfloat m_s;\n\tSMaterial m_mtl;\n};\n\nSSdfSample SdfSoftMin(SSdfSample sdf0, SSdfSample sdf1, float sRadiusBlend)\n{\n#if MM_SOFT_MIN\n\tfloat gT = max(sRadiusBlend - abs(sdf0.m_s - sdf1.m_s), 0.0);\n\tfloat s = min(sdf0.m_s, sdf1.m_s) - gT * gT * 0.25 / sRadiusBlend;\n#else\n\tfloat gK = 0.25 * sRadiusBlend;\n\tfloat sMin = min(sdf0.m_s, sdf1.m_s);\n\tfloat sMax = max(sdf0.m_s, sdf1.m_s);\n\tfloat s = sMin - gK * log2(exp2((sMin - sMax) / gK) + 1.0);\n#endif\n\tfloat dS0 = sdf0.m_s - s;\n\tfloat dS1 = sdf1.m_s - s;\n\tfloat u = dS0 / (dS1 + dS0);\n\tSSdfSample sdf;\n\tsdf.m_s = s;\n\tsdf.m_mtl = MtlLerp(sdf0.m_mtl, sdf1.m_mtl, u);\n\treturn sdf;\n}\n\nSSdfSample SdfSphere(vec4 sphere, SMaterial mtl, vec3 pos)\n{\n\tvec3 posSphere = sphere.xyz;\n\tfloat sRadius = sphere.w;\n\n\tSSdfSample sdf;\n\tsdf.m_s = length(pos - posSphere) - sRadius;\n\tsdf.m_mtl = mtl;\n\treturn sdf;\n}\n\nSSdfSample SdfBlobby(vec3 pos, float uRandom)\n{\n\tconst float gGgxAlpha = 1.0 / 64.0;\n\tconst vec4 sphereBase = vec4(0.0, 0.0, 200.0, 50.0);\n\n\tSSdfSample sdf = SdfSphere(\n\t\t\t\t\t\tSphere0(sphereBase, uRandom),\n\t\t\t\t\t\tMtlCreate(vec3(0.1, 0.8, 0.1) / 4.0, gGgxAlpha),\n\t\t\t\t\t\tpos);\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere1(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.1, 0.3, 0.8) / 4.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius01(uRandom));\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere2(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.7, 0.05, 0.2) / 4.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius12(uRandom));\n\n\treturn sdf;\n}\n\nconst float g_sRepeat = 800.0;\n\nvec2 PosIndex(vec3 pos)\n{\n\tvec2 posIndex;\n\tposIndex.x = floor((pos.x + 0.5 * g_sRepeat) / g_sRepeat);\n\tposIndex.y = floor((pos.y + 0.5 * g_sRepeat) / g_sRepeat);\n\treturn posIndex;\n}\n\nvec3 PosWrap(vec3 pos)\n{\n\tvec2 posIndex = PosIndex(pos);\n\tpos.xy = fract(pos.xy / g_sRepeat + 0.5) * g_sRepeat - 0.5 * g_sRepeat;\n\tif (dot(posIndex, posIndex) != 0.0)\n\t{\n\t\tpos.xy += (VecHash2(posIndex) - vec2(0.5, 0.5)) * g_sRepeat * 0.5;\n\t}\n\treturn pos;\n}\n\nfloat UHashFromPos(vec3 pos)\n{\n\tpos.xy = PosIndex(pos);\n\treturn UHash(pos.xy);\n}\n\nvec3 PosRound(vec3 pos)\n{\n\tpos.xy = floor((pos.xy + 0.5 * g_sRepeat) / g_sRepeat + 0.5) * g_sRepeat - 0.5 * g_sRepeat;\n\treturn pos;\n}\n\nfloat DSCellEdge(vec3 pos)\n{\n\tvec2 dPos = abs(PosRound(pos).xy - pos.xy);\n\tconst float sZSlop = 10.0;\n\treturn (pos.z > g_zMax) ? (pos.z - g_zMax - sZSlop) : min(dPos.x, dPos.y);\n}\n\nSSdfSample SdfScene(vec3 pos, float uRandom)\n{\n\tSSdfSample sdf = SdfBlobby(pos, uRandom);\n\n\t// Try to keep from penetrating the ground plane\n\t// BB Causes issues with shadows, better solution?\n\n\tsdf.m_s += max(0.0, max(20.0 - pos.z, 100.0 / max(pos.z, 1e-6)));\n\n\t// And g_zMax\n\n\tsdf.m_s += max(0.0, max(20.0 - (g_zMax - pos.z), 100.0 / max(g_zMax - pos.z, 1e-6)));\n\n\treturn sdf;\n}\n\nbool FIntersectScene(\n\t\tvec3 posRay,\n\t\tvec3 normalRay,\n\t\tout SHit o_hit,\n\t\tout int o_cStep)\n{\n\tSMaterial mtlPlane = MtlCreate(vec3(0.2, 0.2, 0.2), 1.0 / 20.0);\n\tSHit hitPlane = HitPlane(vec4(0, 0, 1, 0), mtlPlane, posRay, normalRay);\n\n\tfloat sRay = 0.0;\n\tconst int cStepMax = 100;\n\tfor (int cStep = 0; cStep < cStepMax; ++cStep)\n\t{\n\t\to_cStep = cStep;\n\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat uRandom = UHashFromPos(pos);\n\t\tSSdfSample sdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\tfloat dSEdge = DSCellEdge(pos);\n\t\tconst float sEdgeSlop = 100.0;\n\t\tsRay += min(sdf.m_s, dSEdge + sEdgeSlop);\n\n\t\tif (sRay >= hitPlane.m_s ||\n\t\t\tpos.z < 0.0 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.0))\n\t\t{\n\t\t\to_hit = hitPlane;\n\t\t\treturn hitPlane.m_s < g_sRayMax;\n\t\t}\n\n\t\tif (sdf.m_s < 1.0)\n\t\t{\n\t\t\to_hit.m_s = sRay;\n\t\t\tvec3 posHit = posRay + normalRay * sRay;\n\t\t\tposHit = PosWrap(posHit);\n\t\t\tSSdfSample sdfHit = SdfScene(posHit, uRandom);\n\n\t\t\t// Construct normal\n\n\t\t\tSSdfSample sdfHitX = SdfScene(posHit + vec3(0.1, 0, 0), uRandom);\n\t\t\tSSdfSample sdfHitY = SdfScene(posHit + vec3(0, 0.1, 0), uRandom);\n\t\t\tSSdfSample sdfHitZ = SdfScene(posHit + vec3(0, 0, 0.1), uRandom);\n\n\t\t\to_hit.m_normal = vec3(\n\t\t\t\t\t\t\t\tsdfHitX.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitY.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitZ.m_s - sdfHit.m_s);\n\t\t\to_hit.m_normal = normalize(o_hit.m_normal);\n\n\t\t\to_hit.m_mtl = sdfHit.m_mtl;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\to_cStep = cStepMax;\n\n\to_hit = hitPlane;\n\treturn hitPlane.m_s < g_sRayMax;\n}\n\nfloat UConeTraceScene(vec3 posRay, vec3 normalRay, float rConeWidth, float dS, float dUOccMax, bool fCrossCells)\n{\n\tfloat sRay = 3.0;\n\n\tfloat uOcclusion = 1.0;\n\n\tfloat uRandom = 0.0;\n\n\t// rConeNoOcc is the non-occluded portion of the cone (tan of the cone half-angle)\n\n\tfloat rConeNoOcc = rConeWidth;\n\n\tif (!fCrossCells)\n\t{\n\t\tuRandom = UHashFromPos(posRay);\n\t\tposRay = PosWrap(posRay);\n\t}\n\n\tfor (int iStep = 0; iStep < 50; ++iStep)\n\t{\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat sConeWidth = sRay * rConeWidth;\n\n\t\t// Compute min step size. The second argument to max() is the step size yielding a maximum occlusion change of\n\t\t//\tdUOccMax.\n\n\t\tfloat dSMin = max(dS, 2.0 * dUOccMax * sRay * rConeWidth);\n\n\t\t// Find sRay_new such that sRay_new - sRay_old == sdf.m_s - rConeNoOcc * sRay_new\n\t\t//\ti.e., march until until new cone potentially touches surface\n\t\t//\tSolution is: sRay_new := (sdf.m_s - sRay_old * rConeNoOcc) / (1.0 + rConeNoOcc)\n        //  Then add dSMin to potentially get some occlusion.\n\n\t\tSSdfSample sdf;\n\t\tif (fCrossCells)\n\t\t{\n\t\t\tuRandom = UHashFromPos(pos);\n\t\t\tsdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\t\tfloat dSCellEdge = DSCellEdge(pos);\n\t\t\tconst float sEdgeSlop = 10.0;\n\t\t\tsRay += max(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t(min(dSCellEdge + sEdgeSlop, sdf.m_s) - sRay * rConeNoOcc) /\n\t\t\t\t\t\t(1.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsdf = SdfScene(pos, uRandom);\n\n\t\t\tsRay += max(0.0, (sdf.m_s - sRay * rConeNoOcc) / (1.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\n\t\t// Update occlusion and non-occluded cone width\n\n\t\tuOcclusion = min(uOcclusion, saturate(0.5 * (1.0 + sdf.m_s / sConeWidth)));\n\t\trConeNoOcc = rConeWidth * saturate(2.0 * uOcclusion - 1.0);\n\n\t\tif (uOcclusion < 0.01 ||\n\t\t\tpos.z < 0.0 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.0))\n\t\t{\n\t\t\treturn uOcclusion;\n\t\t}\n\t}\n\n\treturn uOcclusion;\n}\n\n// GGX specular lighting\n// See e.g. http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\nfloat GGgxVisRcp(float gGgxAlphaSqr, float gDot)\n{\n\tgDot = saturate(gDot);\n\treturn gDot + sqrt(mix(GSqr(gDot), 1.0, gGgxAlphaSqr));\n}\n\nfloat UFresnel(float gDot)\n{\n\tfloat uFresnel = 1.0 - gDot;\n\tfloat uFresnel2 = GSqr(uFresnel);\n\tuFresnel = GSqr(uFresnel2) * uFresnel;\n\treturn uFresnel;\n}\n\nfloat RSpecularLight(vec3 normalRay, vec3 normal, float gGgxAlpha, out float o_rDiffuse)\n{\n\tfloat gGgxAlphaSqr = GSqr(gGgxAlpha);\n\n\tvec3 normalHalf = normalize(g_normalLight - normalRay);\n\tfloat gDotHalf = saturate(dot(normalHalf, normal));\n\n\tfloat uFresnel = UFresnel(gDotHalf);\n\n\tfloat rSpecular = mix(g_rSpecular, 1.0, uFresnel);\n\n\tfloat gNdf = gGgxAlphaSqr / GSqr(GSqr(gDotHalf) * (gGgxAlphaSqr - 1.0) + 1.0);\n\tfloat gVis = 1.0 / (GGgxVisRcp(gGgxAlphaSqr, dot(-normalRay, normal)) *\n\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, dot(g_normalLight, normal)));\n\n\to_rDiffuse = 1.0 - rSpecular;\n\n#if ENABLE_IS\n\treturn 0.0;\n#else\n\treturn gNdf * gVis * rSpecular * g_rSunSpecScale;\n#endif\n}\n\nvec3 RgbLightHit(vec3 posHit, vec3 normalRay, SHit hit)\n{\n\tconst float rScaleLightCone = 3.0;\t// Enlarge light cone for softer shadows\n\n\tfloat uShadow = UConeTraceScene(\n\t\t\t\t\t\tposHit,\n\t\t\t\t\t\tg_normalLight,\n\t\t\t\t\t\tRLightCone() * rScaleLightCone,\n\t\t\t\t\t\t20.0,\n\t\t\t\t\t\t0.15,\n\t\t\t\t\t\ttrue);\n\n#if DISABLE_SHADOWS\n\tuShadow = 1.0;\n#endif\n\n#if DEBUG_SHADOWS\n\treturn vec3(uShadow);\n#endif\n\n\tfloat uAmbient = UConeTraceScene(posHit, hit.m_normal, 1.0, 20.0, 0.05, false);\n\n\t// BB Hacky AO based on normal Z with height falloff\n\n\tuAmbient = min(uAmbient, mix(\n\t\t\t\t\t\t\t\tsaturate(0.5 + 0.5 * hit.m_normal.z),\n\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\tsaturate(posHit.z / 300.0)));\n\n\tfloat dSCellEdge = DSCellEdge(posHit);\n\tuAmbient = mix(uAmbient, 1.0, smoothstep(0.0, 1.0, 1.0 - dSCellEdge / 100.0));\n\n#if DISABLE_AO\n\tuAmbient = 1.0;\n#endif\n\n#if DEBUG_AO\n\treturn vec3(uAmbient);\n#endif\n\n\tvec3 rgbLight = uAmbient * RgbAmbient() * hit.m_mtl.m_rgbDiffuse;\n\tfloat gDotLight = dot(g_normalLight, hit.m_normal);\n\tvec3 rgbDiffuse = hit.m_mtl.m_rgbDiffuse;\n\tfloat rDiffuse;\n\tfloat rSpecularLight = RSpecularLight(\n\t\t\t\t\t\t\tnormalRay,\n\t\t\t\t\t\t\thit.m_normal,\n\t\t\t\t\t\t\thit.m_mtl.m_gGgxAlpha,\n\t\t\t\t\t\t\trDiffuse);\n\trgbDiffuse *= rDiffuse;\n\trgbLight += uShadow * saturate(gDotLight) * (rgbDiffuse + rSpecularLight) * RgbLight();\n\n\treturn rgbLight;\n}\n\nfloat RFog(float s, vec3 posRay, vec3 normalRay)\n{\n\t// Height-based exponential fog\n\n\tconst float gDensityAtGround = 1.0 / 40000.0;\n\tconst float gHeightFalloff = 1.0 / 10000.0;\n\n\tfloat gT = -gDensityAtGround * exp(-gHeightFalloff * posRay.z);\n\n\tif (abs(normalRay.z) > 1e-6)\n\t{\n\t\tgT *= (1.0 - exp(-gHeightFalloff * normalRay.z * s)) / (gHeightFalloff * normalRay.z);\n\t}\n\telse\n\t{\n\t\tgT *= s;\n\t}\n\n\treturn exp(gT);\n}\n\nvec3 RgbIntersectScene(vec3 posRay, vec3 normalRay)\n{\n\tSHit hit;\n\tvec3 rgbLight = vec3(0);\n\tfloat r = 1.0;\n\tint cStepTotal = 0;\n\n\tfor (int iBounce = 0; iBounce <= g_cBounce; ++iBounce)\n\t{\n\t\tint cStep = 0;\n\t\tbool fIntersect = FIntersectScene(posRay, normalRay, hit, cStep);\n\n\t\tcStepTotal += cStep;\n\n#if DEBUG_DIFFUSE\n\t\t// BB Should use exact sRGB conversion\n\n\t\treturn (fIntersect) ? pow(hit.m_mtl.m_rgbDiffuse, vec3(1.0 / 2.2)) : vec3(0);\n#endif\n\n#if DEBUG_NORMALS\n\t\treturn (fIntersect) ? hit.m_normal * 0.5 + 0.5 : vec3(0);\n#endif\n\n\t\tif (fIntersect)\n\t\t{\n\t\t\tvec3 posHit = posRay + normalRay * hit.m_s;\n\n\t\t\tfloat rFog = RFog(hit.m_s, posRay, normalRay);\n\t\t\trgbLight += (1.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\tvec3 rgbLightHit = RgbLightHit(posHit, normalRay, hit);\n\n#if DEBUG_AO || DEBUG_SHADOWS\n\t\t\treturn rgbLightHit;\n#endif\n\n\t\t\trgbLight += r * rgbLightHit;\n\n\t\t\t// Prepare for next bounce\n\n\t\t\tvec3 normalReflect;\n\n#if ENABLE_IS\n\t\t\t{\n\t\t\t\t// GGX importance sampling (see Karis notes linked above)\n\n\t\t\t\tfloat gGgxAlphaSqr = GSqr(hit.m_mtl.m_gGgxAlpha);\n\t\t\t\tfloat radPhi = 2.0 * g_gPi * g_vecURandomIS.x;\n\t\t\t\tfloat gCosTheta = sqrt((1.0 - g_vecURandomIS.y) /\n\t\t\t\t\t\t\t\t\t   (1.0 + (gGgxAlphaSqr - 1.0) * g_vecURandomIS.y));\n\t\t\t\tfloat gSinTheta = sqrt(1.0 - GSqr(gCosTheta));\n\n\t\t\t\tvec3 normalHalfTangentSpace = vec3(\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * cos(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * sin(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgCosTheta);\n\n\t\t\t\t// Construct orthonormal basis (Frisvad method)\n\n\t\t\t\tfloat gA = (hit.m_normal.z > -0.99999) ? 1.0 / (1.0 + hit.m_normal.z) : 0.0;\n\t\t\t\tfloat gB = -hit.m_normal.x * hit.m_normal.y * gA;\n\t\t\t\tvec3 tangent = vec3(1.0 - GSqr(hit.m_normal.x) * gA, gB, -hit.m_normal.x);\n\t\t\t\tvec3 binormal = vec3(gB, 1.0 - GSqr(hit.m_normal.y) * gA, -hit.m_normal.y);\n\t\t\t\tvec3 normalHalf = normalHalfTangentSpace.x * tangent +\n\t\t\t\t\tnormalHalfTangentSpace.y * binormal +\n\t\t\t\t\tnormalHalfTangentSpace.z * hit.m_normal;\n\n\t\t\t\tnormalReflect = normalRay - 2.0 * dot(normalRay, normalHalf) * normalHalf;\n\n\t\t\t\tfloat gDotRay = saturate(dot(hit.m_normal, -normalRay));\n\t\t\t\tfloat gDotReflect = saturate(dot(hit.m_normal, normalReflect));\n\t\t\t\tfloat gDotHalf = saturate(dot(hit.m_normal, normalHalf));\n\t\t\t\tfloat gRayDotHalf = saturate(dot(-normalRay, normalHalf));\n\t\t\t\tif (gDotReflect > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfloat gVisRcp = GGgxVisRcp(gGgxAlphaSqr, gDotRay) *\n\t\t\t\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, gDotReflect);\n\t\t\t\t\tfloat uFresnel = UFresnel(gRayDotHalf);\n\t\t\t\t\tfloat rSpecular = mix(g_rSpecular, 1.0, uFresnel);\n\t\t\t\t\tr *= 4.0 * rSpecular * gRayDotHalf * gDotReflect / (gVisRcp * gDotHalf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\t\t\tr = 0.0;\n\t\t\t\t\tposRay = vec3(0.0, 0.0, g_zMax * 10.0);\n\t\t\t\t\tnormalRay = vec3(0.0, 0.0, 1.0);\n\t\t\t\t}\n\t\t\t}\n\n#else // !ENABLE_IS\n\t\t\t// BB This works ok for our low roughness values, but for rougher materials would want\n\t\t\t//\tsomething better, e.g. an analytic approximation to the pre-integrated ambient\n\t\t\t//\tspecular BRDF LUT in Karis's notes.\n\n\t\t\tnormalReflect = reflect(normalRay, hit.m_normal);\n\t\t\tr *= mix(g_rSpecular, 1.0, UFresnel(saturate(dot(normalReflect, hit.m_normal))));\n#endif // !ENABLE_IS\n\n\t\t\tposRay = posHit + normalReflect * 10.0;\n\t\t\tnormalRay = normalReflect;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat rFog = RFog(1e10, posRay, normalRay);\n\t\t\trgbLight += (1.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\t// Sun + sky\n\t\t\t// BB Just hacking here, can probably be simplified a bunch.\n\n\t\t\tfloat gDotLight = dot(normalRay, g_normalLight);\n\n\t\t\tvec3 vecPerp = normalRay - gDotLight * g_normalLight;\n\n\t\t\tfloat gPerpDistSqr = dot(vecPerp, vecPerp);\n\t\t\tfloat rGlow = 20.0;\n\n\t\t\tbool fDrawSun = true;\n#if !ENABLE_IS\n\t\t\tfDrawSun = (iBounce == 0);\n#endif\n\n\t\t\tif (fDrawSun &&\n\t\t\t\tgDotLight > 0.0 &&\n\t\t\t\tgPerpDistSqr < GSqr(RLightCone() * rGlow * gDotLight))\n\t\t\t{\n\t\t\t\tfloat gSunLum = GLuminance(RgbSunDisc());\n\t\t\t\tfloat gK = 0.1;\n\t\t\t\tgSunLum /= gK + gSunLum;\n\t\t\t\tfloat gNewLum = gSunLum * GSqr(smoothstep(\n\t\t\t\t\t\t\t\t\t\t\t(RLightCone() * rGlow),\n\t\t\t\t\t\t\t\t\t\t\tRLightCone() * 1.0,\n\t\t\t\t\t\t\t\t\t\t\tlength(vecPerp)));\n\t\t\t\tgNewLum *= gK / (1.0 - gNewLum);\n\n\t\t\t\tfloat rSun = r;\n\n#if FULL_STRENGTH_SUN\n\t\t\t\trSun = 1.0;\n#endif\n\n\t\t\t\tif (iBounce > 0)\n\t\t\t\t{\n\t\t\t\t\trSun *= g_rSunSpecScale;\n\t\t\t\t}\n\n\t\t\t\trgbLight += rSun * gNewLum / GLuminance(RgbSunDisc()) * RgbSunDisc();\n\t\t\t}\n\n\t\t\trgbLight += r * RgbSky();\n\n\t\t\tfloat u = saturate(\n\t\t\t\t\t\t-gDotLight / (GDotLightCone() + 1.0) + 1.0 / (1.0 / GDotLightCone() + 1.0));\n\t\t\tfloat g = u / max(1.0 - u, 1e-8);\n\t\t\tfloat rHaze = exp(-g * 10.0);\n\t\t\trHaze += rHaze * (1.0 + rHaze * (1.0 + rHaze * (1.0 + rHaze)));\n\t\t\trgbLight += r * 0.4 * RgbLight() * rHaze;\n\n\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\tr = 0.0;\n\t\t\tposRay = vec3(0.0, 0.0, g_zMax * 10.0);\n\t\t\tnormalRay = vec3(0.0, 0.0, 1.0);\n\t\t}\n\t}\n\n#if DEBUG_STEPS\n\treturn vec3(float(cStepTotal) / 100.0);\n#endif\n\n\treturn rgbLight;\n}\n\nvoid mainImage(out vec4 o_rgbaColor, in vec2 xyPixel)\n{\n#if TILED_RENDER\n\txyPixel += iOffset;\n#endif\n\n\tg_t = iTime;\n\tvec3 rgbColor = vec3(0);\n\tfloat gWeightSum = 0.0;\n\n\tg_vecURandomIS = VecHash2(vec2(xyPixel + g_t));\n\tvec2 vecURandomDOF = VecHash2(vec2(xyPixel * g_gPi + g_t * exp(1.0)));\n\tvec2 vecURandomAA = VecHash2(vec2(xyPixel * exp(1.0) + g_t * g_gPi));\n\tfloat uRandomMB = UHash(vec2(xyPixel * sqrt(2.0) + g_t * 0.5 * (1.0 + sqrt(5.0))));\n\n\tfor (int iRay = 0; iRay < RAY_COUNT; ++iRay)\n\t{\n#if CORRELATED_DOF\n\t\tvecURandomDOF = g_vecURandomIS;\n#endif\n\n#if CORRELATED_MB\n\t\tuRandomMB = g_vecURandomIS.x;\n#endif\n\n#if ENABLE_MOTION_BLUR\n\t\tg_t = iTime - uRandomMB * g_dTExposure;\n#endif\n\n\t\tUpdateLightDirection();\n\n\t\tvec3 posView = vec3(-500.0, 0.0, 200.0);\n\t\tvec2 dXyOffset = vec2(0);\n#if RAY_COUNT > 1\n\t\tdXyOffset = vecURandomAA - 0.5;\n#endif\n\t\tvec2 xyPixelOffset = (xyPixel.xy + dXyOffset);\n\t\tvec2 uvScreen = xyPixelOffset / iResolution.xy;\n\t\tvec3 normalCm = vec3(1.0, 0.0, 0.0);\n\t\tvec2 vecAspect = vec2(-1.0, iResolution.y / iResolution.x);\n\t\tfloat gFov = 0.9;\n\t\tnormalCm.yz = (uvScreen * 2.0 - 1.0) * vecAspect * gFov;\n\n#if ENABLE_DOF\n\t\tvec2 vecDisc = VecDisc(vecURandomDOF);\n\t\tnormalCm.yz += vecDisc * g_rDOFScale;\n\t\tposView.yz += vecDisc * g_rDOFScale * posView.x;\n#endif\n\n\t\tnormalCm = VecRotateY(normalCm, g_radTiltCamera);\n\n\t\t// Lens distortion\n\n\t\tnormalCm.yz *= 5.0 / (5.0 + dot(normalCm.yz, normalCm.yz));\n\n\t\tnormalCm = normalize(normalCm);\n\n\t\tvec3 rgbHit = RgbIntersectScene(posView, normalCm);\n\t\tfloat gLum = GLuminance(rgbHit);\n\t\tfloat gWeight = 1.0 / (1.0 / (g_gISNoiseReduction + 1e-10) + gLum);\n\t\trgbColor += rgbHit * gWeight;\n\t\tgWeightSum += gWeight;\n\n\t\tg_vecURandomIS = VecSubRandom(g_vecURandomIS);\n\t\tvecURandomDOF = VecSubRandom(vecURandomDOF);\n\t\tvecURandomAA = VecSubRandom(vecURandomAA);\n\t\tuRandomMB = VecSubRandom(vec2(uRandomMB)).x;\n\t}\n\n\trgbColor = rgbColor / gWeightSum;\n\n#if DEBUG_STEPS || DEBUG_DIFFUSE || DEBUG_NORMALS || DEBUG_AO || DEBUG_SHADOWS\n\to_rgbaColor.rgb = rgbColor;\n#else\n\to_rgbaColor.rgb = RgbTonemap(rgbColor);\n#endif\n\n\t// Vignette\n\n\to_rgbaColor.rgb *= 1.0 - smoothstep(0.8, 2.6, length((xyPixel.xy / iResolution.xy) * 2.0 - 1.0));\n\n\t// Noise to reduce banding\n\n\to_rgbaColor.rgb += (g_vecURandomIS.x - 0.5) / 255.0;\n\n\to_rgbaColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2824, 2824, 2849, 2849, 2879], [2881, 2881, 2906, 2906, 2938], [2940, 2940, 2965, 2965, 2997], [2999, 2999, 3024, 3024, 3056], [3058, 3058, 3092, 3092, 3148], [3150, 3150, 3172, 3172, 3206], [3208, 3208, 3229, 3229, 3246], [3248, 3248, 3276, 3276, 3301], [3303, 3303, 3325, 3325, 3395], [3397, 3397, 3421, 3488, 3626], [3628, 3628, 3661, 3804, 3880], [3882, 3882, 3913, 4003, 4116], [4118, 4118, 4156, 4156, 4326], [4328, 4328, 4357, 4357, 4632], [4634, 4634, 4651, 4651, 4795], [4797, 4797, 4817, 4875, 4892], [4894, 4894, 4917, 4917, 4952], [4954, 4954, 4973, 4973, 5018], [5020, 5020, 5035, 5035, 5188], [5190, 5190, 5209, 5209, 5237], [5239, 5239, 5268, 5268, 5520], [5522, 5522, 5572, 5572, 5638], [5640, 5640, 5686, 5686, 5961], [5963, 5963, 6009, 6009, 6274], [6276, 6276, 6322, 6322, 6577], [6579, 6579, 6618, 6618, 6678], [6680, 6680, 6719, 6719, 6785], [6787, 6787, 6820, 6850, 7210], [7288, 7288, 7343, 7343, 7436], [7438, 7438, 7498, 7498, 7658], [7737, 7737, 7772, 7772, 7848], [7850, 7850, 7921, 7921, 8322], [8391, 8391, 8468, 8468, 8979], [8981, 8981, 9041, 9041, 9195], [9197, 9197, 9244, 9244, 9825], [9859, 9859, 9884, 9884, 10040], [10042, 10042, 10066, 10066, 10298], [10300, 10300, 10330, 10330, 10380], [10382, 10382, 10407, 10407, 10515], [10517, 10517, 10545, 10545, 10696], [10698, 10698, 10744, 10744, 11078], [11080, 11080, 11173, 11173, 12542], [12544, 12544, 12658, 12658, 14375], [14510, 14510, 14560, 14560, 14643], [14645, 14645, 14673, 14673, 14798], [14800, 14800, 14890, 14890, 15473], [15475, 15475, 15532, 15532, 16762], [16764, 16764, 16814, 16847, 17175], [17177, 17177, 17230, 17230, 22050], [22052, 22052, 22107, 22107, 24333]], "test": "valid"}
{"id": "MlSXzy", "name": "crowded cubes 5", "author": "FabriceNeyret2", "description": "one more variant of https://www.shadertoy.com/view/ltfXRM ", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 8, "viewed": 1174, "published": "Public API", "date": "1444596107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) v *= mat2( C = cos((t)*T), S = sin((t)*T), -S, C )\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    f-=f;\n    float C,S,r,x;\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,p2; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5.*T;\n   \n    for (float i=1.; i>0.; i-=.01)  \n    {\n        vec4 u = floor(p/8.), t = mod(p, 8.)-4., M,m; // objects id + local frame\n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);      // objects rotations\n        u = fract(1234.*sin(78.*(u+u.yzxw)));         // randomize ids\n        \n        p2 = p; p2.x -= 15.*T*(2.*u.y-1.);            // offset column\n        u = floor(p2/8.); t = mod(p2, 8.)-4.;\n        u = fract(1234.*sin(78.*(u+u.yzxw)));\n        \n        if (u.y<.5) if (mod(T,6.)<1.) r(t.xy,3.14159);// rotate column\n              \n        r = 1.2;\n        t = abs(t); M=max(t,t.yzxw); \n        x = max(t.x,M.y)-r;\n        if (u.x<.5) x = max(x,r-u.x -M.x);\n        if (u.y<.5) x = max(x,r-u.y -M.y);\n        if (u.z<.5) x = max(x,r-u.z -M.z);\n        if(x<.01)  // hit !\n            { f = i*i*(1.+.2*t); break; } // color texture + black fog \n\n        p -= d*x;           // march ray\n     }\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 206, 206, 1364]], "test": "valid"}
{"id": "Mt2SDD", "name": "Zebra 1", "author": "swellbastion", "description": "weird sin stuff", "tags": ["sin"], "likes": 1, "viewed": 93, "published": "Public", "date": "1443913241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float posSin(float angle) {\n    return sin(angle)/ 2.0 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = abs(fragCoord.xy / iResolution.xy - 0.5);\n    \n    float angleOsc = (sin(iTime) + 256.0) * 16.0;\n    \n    float angle = atan(position.y / position.x) * angleOsc;\n    \n \t\n    fragColor = vec4( posSin(angle) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 63], [65, 65, 122, 122, 353]], "test": "valid"}
{"id": "Mt2SWy", "name": "plasma snakes 4", "author": "FabriceNeyret2", "description": ".", "tags": ["2d"], "likes": 1, "viewed": 988, "published": "Public API", "date": "1446288781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C(t) sign(cos(t))*pow(abs(cos(t)),z)\n#define S(t) C(t+1.57)\n\n#define P(t)   vec2( 1.7*C(t)+.5*S(-2.7*t), .8*S(1.2*t)+.5*C(3.2*t) ) /1.5\n\n#define draw(t,c)  o += 20.*smoothstep(.03*c, c-c, vec4(length(P((t))-U))) * length(P((t+.01))-P((t)))\n\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n\tvec2 R = iResolution.xy;  \n    U = (2.*U -R ) / R.y;\n    float T = iTime, \n        z = 5.+5.*cos(T*.3);\n    \n    for (float dt=0.; dt<5.; dt+= .03) {\n        \n        float t = dt+T;\n        \n        draw( t,       vec4(1,2,3,0));\n        draw( t-1234., vec4(3,2,1,0));        \n        draw( t+1234., vec4(2,3,1,0));        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 289, 289, 642]], "test": "valid"}
{"id": "Mt2SzK", "name": "[CIS 565 2015f] RayMarcher", "author": "sanchitgarg", "description": "Another ray marcher", "tags": ["raymarching"], "likes": 0, "viewed": 110, "published": "Public", "date": "1445287331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Github Project Page : https://github.com/sanchitgarg/Project5-GLSL-Ray-Marcher\n\n//Other ray marching demos can be found at the following links\n// PACMAN : https://www.shadertoy.com/view/4lBSz3\n// FRACTAL : https://www.shadertoy.com/view/4tSSz3\n// TERRAIN : https://www.shadertoy.com/view/ll2SzK\n\n// Reference : https://www.shadertoy.com/view/Xds3zN\n\n#define MAX_DIS 20.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n#define SCENE_Y -3.0\n\n//Comment SHADOW_SCALE to remove shadow\n#define SHADOW_SCALE 30.0\n\n//----------------------Color Modes----------------------\n//Uncomment the coloring mode you want to view and comment the rest\n\n//#define DEPTH_COLOR\n//#define STEP_COUNT_COLOR\n//#define NORMAL_COLOR\n#define LAMBERT_COLOR\n//-------------------------------------------------------\n\n#define DISPLACEMENT 5.0\n\n//------------------Ray Casting Modes--------------------\n//#define NAIVE_RAY_CAST\n#define SPHERICAL_RAY_CAST\n//-------------------------------------------------------\n\n\n//-------------------------------------------------------\n//\t\t\t\t\tTransformation Matrices\n//-------------------------------------------------------\n\n\nstruct transformationMat {\n\tvec3 translate;\n    vec3 rotate;\n    vec3 scale;\n \n    mat4 translateMat;\n\tmat4 rotateMat;\n    mat4 scaleMat;\n};\n\ntransformationMat m1, m2, m3, m4, m5;\nmat4 matrix1, matrix2, matrix3, matrix4, matrix5;\n\nmat4 transpose(mat4 m)\n{\n\tmat4 retM;\n    \n    for(int i=0; i<4; i++)\n    {\n\t\tfor(int j=0; j<4; j++)\n        {\n            retM[i][j] = m[j][i];\n        }\n    }\n    \n    return retM;\n}\n\nmat3 transpose(mat3 m)\n{\n\tmat3 retM;\n    \n    for(int i=0; i<3; i++)\n    {\n\t\tfor(int j=0; j<3; j++)\n        {\n            retM[i][j] = m[j][i];\n        }\n    }\n    \n    return retM;\n}\n\nmat4 buildTransformationMatrix(transformationMat m)\n{\n    m.translateMat = (mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        -m.translate.x, -m.translate.y, -m.translate.z, 1.0));\n    \n\tmat4 rotateX = (mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, cos(m.rotate.x), sin(m.rotate.x), 0.0,\n\t\t\t\t\t\t0.0, -sin(m.rotate.x), cos(m.rotate.x), 0.0,\n                        0.0, 0.0, 0.0, 1.0));\n    \n\tmat4 rotateY = (mat4(cos(m.rotate.y), 0.0, -sin(m.rotate.y), 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n\t\t\t\t\t\tsin(m.rotate.y), 0.0, cos(m.rotate.y), 0.0,\n                        0.0, 0.0, 0.0, 1.0));\n    \n    mat4 rotateZ = (mat4(cos(m.rotate.z), sin(m.rotate.z), 0.0, 0.0,\n                        -sin(m.rotate.z), cos(m.rotate.z), 0.0, 0.0,\n\t\t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n                     \t0.0, 0.0, 0.0, 1.0));\n   \n    m.rotateMat = transpose(rotateX * rotateY * rotateX);\n    \n    m.scaleMat = mat4(1.0/m.scale.x, 0.0, 0.0, 0.0,\n                      0.0, 1.0/m.scale.y, 0.0, 0.0,\n                      0.0, 0.0, 1.0/m.scale.z, 0.0,\n                      0.0, 0.0, 0.0, 1.0);\n    \n    return (m.scaleMat * m.rotateMat * m.translateMat);\n}\n\nvoid setMatrices()\n{\n \tm1.translate = vec3(-0.5, 1.5 + SCENE_Y, 4.5);\n    m1.rotate = radians(vec3(0.0));\n    m1.scale = vec3(1.0);\n    matrix1 = buildTransformationMatrix(m1);\n    \n\tm2.translate = vec3(2.0, -0.5+ SCENE_Y, 7.0);\n    m2.rotate = radians(vec3(0.0));\n    m2.scale = vec3(1.0);\n    matrix2 = buildTransformationMatrix(m2);\n    \n   \tm3.translate = vec3(-3.0, -0.5+ SCENE_Y, 7.0);\n    m3.rotate = radians(vec3(0.0));\n    m3.scale = vec3(1.0);\n    matrix3 = buildTransformationMatrix(m3);\n    \n    m4.translate = vec3(-3.0, -0.5+ SCENE_Y, 2.0);\n    m4.rotate = radians(vec3(0.0));\n    m4.scale = vec3(1.0);\n    matrix4 = buildTransformationMatrix(m4);\n    \n\tm5.translate = vec3(2.0, -0.5+ SCENE_Y, 2.0);\n    m5.rotate = radians(vec3(0.0));\n    m5.scale = vec3(1.0);\n\tmatrix5 = buildTransformationMatrix(m5);\n}\n\n//-------------------------------------------------------\n//\t\t\t\t\tDistance Estimators\n//-------------------------------------------------------\n\n\n//--------Distance functions for various objects---------\nfloat sdPlane (vec3 p, float y)\n{\n\treturn p.y - y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//--------------------CSG Operations---------------------\nfloat opDifference( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat opIntersect( float d1, float d2 )\n{\n    return max(d2,d1);\n}\n\nfloat opBlend(float a, float b, float blendRadius) {\n    float c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return ((c) * a + (1.0-c) * b) - blendRadius * c * (1.0 - c);\n}\n\n#ifdef DISPLACEMENT\nfloat opDisplacement(vec3 pt)\n{\n    float factor = DISPLACEMENT;\n    return sin(factor * pt.x) * sin(factor * pt.y) * sin(factor * pt.z);\n}\n#endif\n\nvec3 opTx( vec3 p, mat4 m )\n{\n\treturn vec3(m * vec4(p, 1.0));\n}\n\nvec3 opTx( vec3 p, transformationMat m )\n{\n\treturn vec3(buildTransformationMatrix(m) * vec4(p, 1.0));\n}\n\n\n//Function to create the actual scene\nfloat disEstimator(vec3 pt)\n{\n    //Infinite\n    float dis = sdPlane(pt, -2.0 + + SCENE_Y);\n    \n    //Difference\n    \t  dis = opUnion(dis, opDifference(sdBox(opTx(pt, matrix2), vec3(0.5)),\n                                          sdSphere(opTx(pt, matrix2), 0.6)));\n\t\t\n    //Intersection\n    \t//Dice\n\t\t  dis = opUnion(dis, opIntersect(sdBox(opTx(pt, matrix3), vec3(0.5)),\n                                          sdSphere(opTx(pt, matrix3), 0.7)));\n    \t//one\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.0,-0.5,0.0), matrix3), 0.1));\n        //two\n    \tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2,0.5,-0.2), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2,0.5,0.2), matrix3), 0.1));\n    \t//three\n    \tdis = opDifference(dis, sdSphere(opTx(pt-vec3(0.5,0.0,0.0), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.5,0.25,0.25), matrix3), 0.1));\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.5,-0.25,-0.25), matrix3), 0.1));\n\t    //four\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, 0.2, 0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, -0.2, 0.5), matrix3), 0.1));\n\t\t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, 0.2, 0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, -0.2, 0.5), matrix3), 0.1));\n    //five\n    \tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,0.0,0.0), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,0.25,0.25), matrix3), 0.1));\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,-0.25,-0.25), matrix3), 0.1));\n\t\t\tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,0.25,-0.25), matrix3), 0.1));\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,-0.25,0.25), matrix3), 0.1));\n    //six\n\t\tdis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, 0.25, -0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, 0.0, -0.5), matrix3), 0.1));\n\t\t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, -0.25, -0.5), matrix3), 0.1));\n\t\tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, 0.25, -0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, 0.0, -0.5), matrix3), 0.1));\n\t\t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, -0.25, -0.5), matrix3), 0.1));\n    \n    //Blend\n    \tdis = opUnion(dis, opBlend(\n                      sdSphere(opTx(pt-vec3(0.0,0.0,0.5), matrix4), 0.5),\n\t\t  \t          sdSphere(opTx(pt+vec3(0.0,0.0,0.5), matrix4), 0.5),\n            \t\t\t0.5)\n                      );\n   \n//    #ifdef NAIVE_RAY_CAST\n    #ifdef DISPLACEMENT\n    //Displacement\n\t    dis = opUnion(dis, (opDisplacement(opTx(pt, matrix5))+\n\t\t\t\t\t\t\tsdSphere(opTx(pt, matrix5), 0.5)));\n    #endif\n //   #endif\n\n    \n    \n    return dis;\n}\n\n\n\n//-------------------------------------------------------\n//\t\t\t\tColor calculation functions\n//-------------------------------------------------------\n\n//Function to calculate the normal\nvec3 getNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    disEstimator(pos+eps.xyy) - disEstimator(pos-eps.xyy),\n\t    disEstimator(pos+eps.yxy) - disEstimator(pos-eps.yxy),\n\t    disEstimator(pos+eps.yyx) - disEstimator(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n#ifdef SHADOW_SCALE\n//Function to calculate the soft shadow\nfloat getSoftShadow(vec3 pt, vec3 lightPos)\n{\n    float t = 2.0;\n    float minT = 2.0;\n    \n    vec3 rd = normalize(lightPos - pt);\n    vec3 ro = pt;\n    float maxT = (lightPos.x - ro.x) / rd.x;\n\tfloat shadow = 1.0;\n    \n\tfor(int i=0; i<MAX_STEPS; ++i )\n    {\n\t\tpt = ro + t * rd;\n\n        float dt = disEstimator(pt);\n        \n        if(dt < EPSILON)\n        {\n\t\t\treturn 0.0;\n        }\n\n        t += dt;\n        shadow = min(shadow, SHADOW_SCALE * (dt / t));\t\t\n        \n        if(t > maxT)\n        {\n          \treturn shadow;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n#endif\n\n//Function to calculate lambert color\nvec3 getLambertColor(vec3 pt, vec3 ro)\n{\n \tvec3 lightPos = vec3(5.0,5.0,0.0);\n    vec3 lightCol = vec3(1.0);\n    vec3 lightVector = normalize(lightPos - pt);\n    \n    vec3 normal = getNormal(pt);\n    \n    #ifdef SHADOW_SCALE\n\t\tfloat shadow = getSoftShadow(pt, lightPos);\n\t\treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * (shadow) + 0.01;\n    #else\n\t    return clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol + 0.01;\n    #endif\n}\n\n//Function to calculate color based on number of steps\nvec3 getStepCountColor(vec2 steps)\n{\n    float t = (steps.y - steps.x) / steps.y;\n\tvec2 c = vec2(t, 0.0);\n    return vec3(1.0-t, t, 0);\n}\n\n//Function to calculate colors\nvec3 colorCalculation(vec3 pt, vec2 dis, vec3 ro, vec2 steps)\n{\n    #ifdef DEPTH_COLOR\n\t\treturn vec3(abs((dis.y - dis.x) / dis.y));\n    #endif\n    \n    #ifdef STEP_COUNT_COLOR\n\t\treturn getStepCountColor(steps);\n\t#endif\n    \n    #ifdef NORMAL_COLOR\n        return abs(getNormal(pt));\n\t#endif\n    \n    #ifdef LAMBERT_COLOR\n        return getLambertColor(pt, ro);\n\t#endif\n    \n\treturn vec3(0.0);\n}\n\n//-------------------------------------------------------\n//\t\t\t\tRay Cast Functions\n//-------------------------------------------------------\n\nvec3 naiveRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n    float i = 0.0;\n    int maxSteps = 500;\n\tfor(float t = 0.00; t < MAX_DIS; t+=0.01)\n\t{\n        ++i;\n        pt = ro + rd * t;\n        \n        float dis = disEstimator(pt);\n        \n     \tif(dis < EPSILON)\n        {\n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(i, maxSteps));\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\nvec3 sphericalRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n   \t\n//    float dt = disEstimator(pt);\n\tfloat t = 0.0;\n    \n    for(int i = 1; i<MAX_STEPS; i++)\n\t{\n        pt = ro + t * rd;\n        \n        float dt = disEstimator(pt);\n        \n     \tif(dt < EPSILON)\n        {   \n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(float(i), MAX_STEPS));\n        }\n        \n\t\tt += dt;\n        \n        if(t > MAX_DIS)\n  \t    {\n         \treturn vec3(0.0);\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\n\n//-------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    #ifdef NAIVE_RAY_CAST\n\t    return naiveRayCast(ro, rd);\n    #else \n        return sphericalRayCast(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    setMatrices();\n    \n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1363, 1363, 1387, 1387, 1546], [1548, 1548, 1572, 1572, 1731], [1733, 1733, 1786, 1786, 2966], [2968, 2968, 2988, 2988, 3787], [3934, 3992, 4025, 4025, 4044], [4046, 4046, 4081, 4081, 4107], [4109, 4109, 4142, 4142, 4195], [4197, 4197, 4240, 4240, 4300], [4302, 4302, 4333, 4333, 4429], [4431, 4489, 4531, 4531, 4557], [4559, 4559, 4596, 4596, 4625], [4627, 4627, 4668, 4668, 4693], [4695, 4695, 4747, 4747, 4874], [5044, 5044, 5073, 5073, 5107], [5109, 5109, 5151, 5151, 5212], [5215, 5253, 5282, 5297, 8042], [8197, 8232, 8263, 8263, 8525], [9182, 9220, 9260, 9260, 9667], [9669, 9724, 9760, 9760, 9861], [9863, 9894, 9957, 9957, 10288], [10432, 10432, 10475, 10475, 10835], [10837, 10837, 10884, 10884, 11352], [11414, 11414, 11451, 11451, 11576], [11578, 11578, 11628, 11726, 11915], [11917, 11917, 11972, 12070, 12758]], "test": "valid"}
{"id": "Mt2XDD", "name": "Flight over Bespin", "author": "yamahabob", "description": "My first published shader, which is borrowing heavily from other great works on this fantastic site.  I have no idea what I'm doing...", "tags": ["clouds", "flight", "millenniumfalcon"], "likes": 31, "viewed": 793, "published": "Public", "date": "1443934432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Flight over Bespin - yamahabob\n// Borrowed most of this code from inigo quilez et al\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.141592654\n\n// General functions\n\nmat3 rx90 = mat3(1.0, 0.0, 0.0,\n\t\t\t     0.0, 0.0, 1.0,\n\t\t\t     0.0,-1.0, 0.0 );\nmat3 ry90 = mat3(0.0, 0.0,-1.0,\n\t\t\t     0.0, 1.0, 0.0, \n\t\t\t     1.0, 0.0, 0.0 );\nmat3 rz90 = mat3(0.0,-1.0, 0.0,\n\t\t\t     1.0, 0.0, 0.0, \n\t\t\t     0.0, 0.0, 1.0 );\n\nmat3 rotX( float a )\n{\n\treturn mat3(1.0,    0.0,    0.0,\n                0.0, cos(a),-sin(a),\n                0.0, sin(a), cos(a) );\n}\n\nmat3 rotY( float a )\n{\n\treturn mat3(cos(a), 0.0, sin(a),\n                   0.0, 1.0,    0.0, \n               -sin(a), 0.0, cos(a) );\n}\n\nmat3 rotZ( float a )\n{\n\treturn mat3(cos(a),-sin(a), 0.0,\n                sin(a), cos(a), 0.0,\n                   0.0,    0.0, 1.0 );\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n// -------------------------------------\n// Cloud Calculations\n// (borrowed from iq)\n// -------------------------------------\n\n#define SPEED 5.\n\nfloat speed;\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t//f = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, 0.00390625*uv ).yx;\n\treturn 1.5*mix( rg.x, rg.y, f.z ) - 0.75;\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-0.5,-0.1,-1.0) );\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.2 + 0.5*vec3(0.7, 0.5, 0.3)*dif;        \n    vec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.004*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3. || pos.y>1.2 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.1 ) { float dif = clamp((den - MAPLOD(pos+0.5*sundir))*2., 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.2,0.03*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(25,map4);\n    MARCH(20,map3);\n    MARCH(15,map2);\n    MARCH(15,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 lookat( vec3 fw, vec3 up ){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nmat3 setCamera( in vec3 fw )\n{\n\tvec3 cw = normalize( fw );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = vec3( -cw.z, 0.0, cw.x );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 cloudRender( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = 0.9*vec3(0.949,0.757,0.525) - rd.y*0.2*vec3(0.949,0.757,0.525);// + 0.15*0.5;\n\tcol += 0.8*vec3(1.0,.6,0.1)*pow( sun, 20.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.1*vec3(0.949,0.757,0.525)*pow( sun, 3.0 );\n\n    return col;\n}\n\n\n// =========== Ship Calculations ===========\n\nfloat time;\nvec3 shippos;\nmat3 shipltow;\nmat2 shiptilt;\n\n// the flight path\n\nvec3 shippath( float t )\n{\n    return vec3( 5.*sin( 0.9*t ), 2.5*sin( 0.6*t ), 0. );\n}\n\nvec3 shipvel( float t )\n{\n    return vec3( 5.*0.9*cos( 0.9*t ), 2.5*0.6*cos( 0.6*t ), 15. );\n}\n\nvec3 shipacc( float t )\n{\n    return vec3( -4.*0.9*0.9*sin( 0.9*(t)), -2.5*0.6*0.6*sin( 0.6*t ), 0. );\n}\n\n\n// distance functions for basic shapes\n\nfloat sdPlane( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\n\nfloat sdHexPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x); }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) { vec3 pa = p-a, ba = b-a; return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 )) - r; }\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat length8( vec3 d ) { vec3 q = pow( d, vec3(8.) ); return pow( q.x + q.y + q.z, 0.125 ); }\n\nfloat sdTorus82( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length8(vec3(q,0.))-t.y; }\n\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nvec2 min2( vec2 d1, vec2 d2 ) { return ( d1.x < d2.x ) ? d1 : d2; }\n\nvec2 max2( vec2 d1, vec2 d2 ) { return ( d1.x > d2.x ) ? d1 : d2; }\n\nfloat smin( float a, float b, float k ) { float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\nvec2 smin( vec2 a, vec2 b, float k ) { float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\n\n// texture functions\n\nfloat noise( float s )\n{\n    vec2 uv = vec2( s, s );\n    return texture( iChannel0, uv ).x;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// plate texture\nfloat texPlates( vec2 uv )\n{\n    vec2 n = vec2( 10., 4. );\n    vec2 sec = floor( uv*n );\n    vec2 suv = uv*n - sec;\n    \n    float s1 = noise( 0.3*( uv.x + sec.y/n.y ) );\n    float s2 = 0.3*s1+0.5;\n    float s3 = noise( 0.4*sec.y/n.y );\n    float luma = 0.5*(1. - cubicPulse( s3, 0.03, suv.x )) + 0.5;\n    luma *= mix(1.0, s2, smoothstep(0.0, 1.0, suv.y));\n    luma *= 0.5*smoothstep( 0.0, 0.005*n.y, min( suv.y, 1.-suv.y)) + 0.5;\n\treturn clamp(luma, 0., 1.);\n}\n\n// circular hull texture\nvec3 texHull( vec3 p )\n{\n    vec2 uv;\n    uv.x = atan(p.z, p.x)/PI;\n    float d = length(p.xz);\n    uv.y = 0.925 - 0.5*d;\n    vec3 shipCol1 = 0.9*vec3(0.729, 0.694, 0.627);\n    vec3 shipCol2 = 0.4*vec3(0.6, 0.537, 0.447);\n    return texPlates( uv ) * mix(shipCol1, shipCol2, cubicPulse( 0., 0.5, uv.x ));\n}\n\n// ship world to local transformation\n\nvec3 shipw2l( vec3 p )\n{\n    p.z = -p.z;\n    p = shipltow*(p - shippos);\n    p.zy *= shiptilt;\n\treturn p;\n}\n\n// ship distance evaluation where p is in world coords\n\nvec2 shipDE(vec3 p)\n{\n    float d1, d2, d3, d4;\n    p = shipw2l( p );\n    d1 = sdSphere( p, 3.3 ); // the bounding 'hit' sphere\n    if ( d1 > 0.2 ) return vec2( d1, 0. );\n\t\n    // main disk\n    vec3 q = p;\n    q.y = abs(q.y);\n\td1 = sdSphere( q + vec3( 0., 14.78, 0. ), 15. );\n    d1 = max( d1, sdSphere( q, 2. ));\n    d1 = max( -q.y + 0.06, d1 );\n\td2 = max(  q.y - 0.06, sdSphere( q, 1.95 ));\n    vec2 vres = vec2( min( d1, d2 ), 1.);\n    \n    // centre pylon\n  \tvres = smin( vres, vec2( sdCappedCylinder( p, vec2( 0.45, 0.28 )), 2.), 0.1);\n    \n    // front forks\n    q = p;\n    q.z = abs(q.z);\n    q += vec3(1.45, 0., -1.1);\n    float front = sdBox( q, vec3( 1.8, 0.09, 0.8 )); // front\n    vec3 norm = normalize(vec3(-1.1, 0.0, 2.3));\n    q = p;\n    q.z = abs(q.z);\n    float plane = sdPlane( q, vec4(-norm, 1.92) );\n    d1 = max( -plane, front );\n    vres = min2( vres, vec2( d1, 3. ));\n\t\n    // Z crossbar\n    d1 = sdHexPrism( p, vec2( 0.26, 2.0 ));\n  \td2 = sdBox( p, vec3( 0.8, 0.8, 0.6 ));\n    vres = min2( vres, vec2( max( -d2, d1 ), 4.));\n    \n    // X crossbar\n    q = p;\n    q.y = abs(q.y);\n    q = ry90 * rotZ(0.07) * q + vec3( 0., 0.02, -1.5);\n    vres = min2( vres, vec2( max( -abs(p.y) + 0.07, sdHexPrism( q, vec2(0.36, 0.9 ))), 5.));\n\n    // cockpit walkway\n    vec3 p1 = vec3(-0.8*sin(0.524), 0.1, -0.8*cos(0.524));\n    vec3 p2 = vec3(-2.1*sin(0.524), 0.07, -2.1*cos(0.524));\n    vec3 p3 = p2 + vec3(-0.2, 0., 0.);\n    vres = min2( vres, vec2( sdCapsule( p, p1, p2, 0.18 ), 6.));\n    vres = min2( vres, vec2( sdCapsule( p, p2, p3, 0.18 ), 6.1));\n\n    // cockpit\n    q = rz90*(p - p3 + vec3(0.2, 0., 0.));\n    vres = min2( vres, vec2( sdConeSection( q, 0.15, 0.18, 0.08), 7. ));\n    \n    // side cylinders\n    q = vec3( 0., 3.87, 0. );\n    q = mod( rx90 * p, q ) - 0.5*q;\n    vres = max2( vres, vec2( -sdTorus82( q, vec2( 0.26, 0.09 )), 8.));\n\n    // exhaust ports\n    p1 = vec3(0.75, 0., 0.);\n    p2 = vec3(0.45, 0., 0.);\n    q = p - p1;\n  \tvres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.255 )), 9.), 0.044);\n    q -= p2;\n  \tvres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.225 )), 9.), 0.044);\n\tq = p;\n    q.z = -abs(q.z); // reflect\n    q = rotY(0.45)*q - p1;\n    vres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.255 )), 9.), 0.044);\n    q -= p2;\n    vres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.225 )), 9.), 0.044);\n\n    // gun port\n    q = p + vec3(0.22, 0., 0.);\n  \tvres = min2( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.32 )), 9.));\n    \n    // gun\n    p1 = vec3(-0.22, 0., 0.);\n    p2 = p1 + vec3( 0., 0.35, 0.0);\n    p3 = vec3(-0.22, 0.33, 0.03);\n    vec3 p4 = p3 + vec3(-0.25, 0.04, 0.);\n    vec3 p5 = vec3(0., 0.03, 0.);\n    q = p;\n    q.z = abs(q.z);\n    q.y = abs(q.y);\n    d1 = sdCapsule( q, p1, p2, 0.06 ); // gun pod\n    d1 = min( d1, sdCapsule( q, p3, p4, 0.01 )); // gun 1\n    d1 = min( d1, sdCapsule( q, p3 + p5, p4 + p5, 0.01 )); // gun 2\n    vres = min2( vres, vec2( d1, 10.));\n    \n    // upper dish\n    p1 = vec3( -1.1, 0.4, 0.83 );\n    p2 = p1 - vec3( -0.05, 0.0, 0.0 );\n    p3 = p2 - vec3( -0.1, 0.25, 0.0 );\n    q = p - p1;\n    d1 = sdSphere( q, 0.2 );\n   \tq = q + vec3( 0.75, -0.1, 0.0 );\n    d2 = sdSphere( q, 0.8 );\n\td3 = sdSphere( q, 0.81 );\n    d4 = sdCapsule( p, p2, p3, 0.03 );\n    vres = min2( vres, vec2( min( d4, max( d3, max( -d2, d1 ))), 10.));\n    \n    return vres;\n}\n\n// ray marching and rendering\n\nvec2 shipCastRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tconst float precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = shipDE( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if ( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = shipDE( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    shipDE(pos+eps.xyy).x - shipDE(pos-eps.xyy).x,\n\t    shipDE(pos+eps.yxy).x - shipDE(pos-eps.yxy).x,\n\t    shipDE(pos+eps.yyx).x - shipDE(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = shipDE( aopos ).x;\n        occ -= (dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 shipRender( in vec3 ro, in vec3 rd, in vec3 col )\n{ \n    vec2 res = shipCastRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m >-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        vec2 uv = vec2(0.);\n        float luma = 0.;\n        \n        vec3 shipCol = 0.9*vec3(0.729, 0.694, 0.627);//vec3(0.5, 0.45, 0.45);\n\n        vec3 q = shipw2l( pos );\n        bool isExhaust = false;\n        \n        if ( abs(q.y) < 0.06 && m < 3.5 )\n        {\n            if (q.x < 1.6)\n            \tcol = mix(vec3(0.1), shipCol, 0.5 * texture( iChannel0, 0.2*q.xy ).x);\n            else\n                isExhaust = true;\n        } else if ( m < 1.1 ) // main disk\n        {\n        \tcol = texHull( q );\n        } else if ( m < 2.1 ) // centre pylon\n        {\n            q = 1.5*(q + vec3(0.22, 0., 0.));\n\t\t\tuv.x = 0.5*(atan(q.z, q.x)/PI);\n\t\t\tuv.y = 1. - length(q.xz);\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 3.1 ) // front forks\n        {\n            uv.x = 0.3*abs(q.z);\n            uv.y = 0.25*q.x+0.4;\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 4.1 ) // Z crossbar\n        {\n            uv.x = 0.5*q.x;\n            uv.y = -0.8*abs(q.z);\n            float luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 5.1 ) // X crossbar\n        {\n            uv.x = 0.5*q.z;\n            uv.y = q.x;\n            if (abs(q.z) < 0.12 && abs(q.x) > 0.8 && abs(q.x) < 2.3)\n            {\n                uv.y *= 0.5;\n                col = shipCol * mix( 0.5, 1., 0.5 * texture( iChannel0, 0.2*uv ).x);\n            } else\n                col = shipCol * texPlates( uv );\n        } else if ( m < 6.6 ) // cockpit walkway\n        {\n            uv = rot(0.524)*q.xz;\n            uv.x = 0.5*uv.x;\n            uv.y = uv.y;\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 7.1 ) // cockpit\n        {\n            if ( q.y > 0.12 )\n        \t\tcol = vec3(0.03);\n            else\n                col = shipCol;\n        } else if ( m < 8.1 ) // side ports\n        {\n            col = shipCol;\n        } else if ( m < 9.9 ) // exhaust ports and gun port\n        {\n            col = vec3(0.05);\n        } else\n        {\n        \tcol = shipCol;\n        }\n\n        if ( isExhaust )\n        {\n            // ship exhaust\n            float blume = pow( clamp( dot(nor,-rd), 0.0, 1.0), 10. );\n            col = clamp( blume + vec3( 0.215, 0.945, 1. ) * (0.5 * cos( 80.*q.z ) + 0.5), 0., 1.);\n        } else\n        {\n            // ship hull lighting        \n            float occ = calcAO( pos, nor );\n            vec3  lig = sundir;\n            float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float dom = smoothstep( -0.1, 0.1, ref.y );\n            float fre = pow( clamp( 1.0+dot(nor,rd),0.0,1.0), 2.0 );\n            float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n\n            dif *= softshadow( pos, lig, 0.02, 2.5 );\n            dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n            vec3 brdf = vec3(0.0);\n            brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n            brdf += 1.10*spe*vec3(1.00,0.90,0.60)*dif;\n            brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n            brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n            brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n            brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n            brdf += 0.02;\n            col = clamp(col*brdf, 0.0, 1.0);\n            \n            // Gamma correction\n\t\t\tcol = pow( col, vec3(0.4545) );\n        }\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n//    vec2 md = iMouse.xy/iResolution.xy - 0.5;\n\n    // render clouds and sky\n    speed = iTime * SPEED;\n    vec3 ro = 4.0*normalize(vec3( 0.0, 0.3, 5.0));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ta - ro );\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    vec3 col = cloudRender( ro, rd );\n\n    // animate\n\ttime = iTime;\n\tshippos = shippath( time );\n    vec3 shipv = shipvel( time );\n    vec3 shipa = shipacc( time );\n\n\t// camera\t\n    //ro = rotY(2.*PI*md.x) * rotX(-0.99*PI*md.y) * vec3( 0.0, 0.0, 9.);\n    ro = vec3( 0.0, 0.0, 5.*sin( 0.5*time ) + 13.);\n\t\n\t// camera-to-world transformation\n    ca = setCamera( ta - ro );\n    \n    // ship direction\n    shiptilt = rot( 0.4*shipa.x );\n    shipltow = ry90 * setCamera( -normalize( shipv ) );\n    \n    // ray direction\n\trd = ca * normalize( vec3(p.xy, 1.0) );\n\n    // render ship\n    col = shipRender( ro, rd, col );\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XDD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[465, 465, 487, 487, 599], [601, 601, 623, 623, 736], [738, 738, 760, 760, 872], [874, 874, 893, 893, 940], [1101, 1101, 1127, 1127, 1341], [1343, 1343, 1368, 1368, 1660], [1662, 1662, 1687, 1687, 1938], [1939, 1939, 1964, 1964, 2174], [2175, 2175, 2200, 2200, 2370], [2422, 2422, 2508, 2524, 2867], [3180, 3180, 3236, 3236, 3395], [3397, 3397, 3429, 3429, 3525], [3527, 3527, 3557, 3557, 3727], [3729, 3729, 3773, 3800, 4179], [4305, 4305, 4331, 4331, 4391], [4393, 4393, 4418, 4418, 4487], [4489, 4489, 4514, 4514, 4593], [4636, 4636, 4669, 4669, 4698], [4700, 4700, 4735, 4735, 4757], [4759, 4759, 4790, 4790, 4873], [4875, 4875, 4911, 4911, 4987], [4989, 4989, 5041, 5041, 5138], [5140, 5140, 5212, 5212, 5427], [5429, 5429, 5454, 5454, 5523], [5525, 5525, 5560, 5560, 5631], [5633, 5633, 5669, 5669, 5701], [5703, 5703, 5745, 5745, 5840], [5842, 5842, 5873, 5873, 5909], [5911, 5911, 5942, 5942, 5978], [5980, 5980, 6021, 6021, 6106], [6108, 6108, 6146, 6146, 6235], [6260, 6260, 6284, 6284, 6353], [6355, 6355, 6402, 6402, 6496], [6498, 6515, 6543, 6543, 6976], [6978, 7003, 7027, 7027, 7309], [7350, 7350, 7374, 7374, 7457], [7515, 7515, 7536, 7536, 10892], [10925, 10925, 10969, 10969, 11299], [11302, 11302, 11376, 11376, 11640], [11642, 11642, 11674, 11674, 11913], [11915, 11915, 11957, 11957, 12258], [12260, 12260, 12316, 12316, 16087], [16089, 16089, 16146, 16146, 17168]], "test": "error"}
{"id": "Mt2XRt", "name": "ImplicitBluePrint", "author": "jt", "description": "A simple (inefficient) proof-of-concept implicit-surface ray-tracer (originally written as test for my ShaderView-project).\n", "tags": ["raytracer", "implicitsurface", "simplified", "proofofconcept"], "likes": 35, "viewed": 1374, "published": "Public", "date": "1445969431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple (inefficient) proof-of-concept implicit-surface ray-tracer by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat fn(vec3 v)\n{\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    //x = sfract(x * 2.0, 1.0);\n    return min(min(x * x + y * y + z * z - 0.5, x * x + y * y - 0.125), min(x * x + z * z - 0.125, y * y + z * z - 0.125));\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec3 tex(vec3 v)\n{\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    //float d = exp(-pow(z * 20.0 + (2.0 * fract((0.5 + 0.5 * time) / 4.0) - 1.0) * 4.0 * 5.0, 2.0));\n    float d = exp(-pow(abs(z * 20.0 + sfract(iTime, 4.0) * 5.0), 2.0));\n    //x += 0.01 * time;\n    //y += 0.01 * time;\n    z += 0.1 * iTime;\n    x = (x * 8.0);\n    y = (y * 8.0);\n    z = (z * 8.0);\n    float q = 0.0;\n    q = max(q, comb(x, 10.0));\n    q = max(q, comb(y, 10.0));\n    q = max(q, comb(z, 10.0));\n    float w = 1.0;\n    w = min(w, max(comb(x, 10.0), comb(y, 10.0)));\n    w = min(w, max(comb(y, 10.0), comb(z, 10.0)));\n    w = min(w, max(comb(z, 10.0), comb(x, 10.0)));\n    return (w + vec3(0.0, q, 0.5 * q)) + d * 5.0;\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float t = iTime * 0.1;\n    vec3 v;\n    v.x = uv.x * cos(t) + uv.y * sin(t); // uv.x;\n    v.y = uv.x * -sin(t) + uv.y * cos(t); // uv.y;\n    v.z = depth;\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n\n    return iso;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.1;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const int depth = 256;\n    float m = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for(int layer = 0; layer < depth; layer++) // slow...\n    {\n        vec3 v = camera(uv, 2.0 * float(layer) / float(depth) - 1.0);\n\n        if(abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0)\n            continue;\n\n        if(abs(fn(v)) < 0.05)\n        {\n            m = 2.0 * float(layer) / float(depth) - 1.0;\n            color = tex(v);\n        }\n    }\n    \n    fragColor = vec4(color * vec3(m), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XRt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[257, 257, 295, 295, 362], [364, 364, 382, 382, 597], [599, 599, 629, 629, 681], [683, 683, 701, 701, 1395], [1397, 1397, 1432, 1432, 1733], [1735, 1735, 1792, 1792, 2417]], "test": "valid"}
{"id": "Mt2XWG", "name": "Max norm ellipsoid", "author": "sjb", "description": "Max norm signed distance field for ellipsoid shape, as described in http://gamma.cs.unc.edu/RECONS/maxnorm.pdf.", "tags": ["distance", "ellipsoid", "maxnorm"], "likes": 25, "viewed": 1689, "published": "Public", "date": "1446238845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 64\n#define SIGNED_DIST_MAX 1000.0\n\nfloat min3(float a, float b, float c)\n{\n\treturn min(min(a, b), c);\n}\nfloat max3(float a, float b, float c)\n{\n\treturn max(max(a, b), c);\n}\n\nfloat max_element(vec3 v)\n{\n\treturn max3(v.x, v.y, v.z);\n}\nfloat sumx(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\n\nfloat max_norm(vec3 v)\n{\n\treturn max_element(abs(v));\n}\nvec3 max_normalize(vec3 v)\n{\n    return v/max_norm(v);\n}\n\nfloat sd_cube(vec3 p, float r)\n{\n\treturn max_norm(p) - r;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n\t// ax^2 + bx + c = 0, a non-zero\n\tfloat q = b*b - 4.0*a*c;\n\tif (q < 0.0) {\n\t\treturn vec2(SIGNED_DIST_MAX);\n\t}\n\tfloat r0 = -b/(2.0*a);\n\tfloat r1 = sqrt(q)/(2.0*a);\n\treturn vec2(r0 - r1, r0 + r1);    \n}\n\nfloat sd_ellipsoid(vec3 p, vec3 r)\n{\n\t// move ellipse so that target point is at origin, centre in positive space\n\t// f(v) = (v.x - c.x)^2/r.x^2 + (v.y - c.y)^2/r.y^2 + (v.z - c.z)^2/r.z^2 - 1\n\tvec3 c = abs(p);\n\tvec3 c2 = c*c;\n\tvec3 r2 = r*r;\n    float d = SIGNED_DIST_MAX;\n\n\t// gather terms of quadratic\n\tvec3 qa = 1.0/r2;\n\tvec3 qb = -2.0*c/r2;\n\tvec3 qc = c2/r2;\n    float qcs = sumx(qc) - 1.0;\n\n    // check corners:\n    // solve f(v)=0 for v.x=v.y=v.z=t\n    {\n\t\tvec2 t0 = abs(solve_quadratic(sumx(qa), sumx(qb), qcs));\n        d = min3(d, t0.x, t0.y);\n    }\n\n\t// interior of convex shape always hits corners first, so early out\n\tif (qcs <= 0.0) {\n\t\treturn -d;\n\t}\n\n\t// check edges:\n\t// df/dx=0 => v.x=c.x, solve f(v)=0 for v.x=c.x, v.y=v.z=t\n    // then do the same for y and z cases\n    {\n        vec2 t = abs(solve_quadratic(qa.y + qa.z, qb.y + qb.z, qc.y + qc.z - 1.0));\n        d = min(d, max(min(t.x, t.y), c.x));\n\t}\n    {\n        vec2 t = abs(solve_quadratic(qa.x + qa.z, qb.x + qb.z, qc.x + qc.z - 1.0));\n        d = min(d, max(min(t.x, t.y), c.y));\n\t}\n    {\n        vec2 t = abs(solve_quadratic(qa.x + qa.y, qb.x + qb.y, qc.x + qc.y - 1.0));\n        d = min(d, max(min(t.x, t.y), c.z));\n\t}\n\n\t// check faces:\n    // df/dx=df/dy=0 => v.xy=c.xy, so f(v)=0 => |v.z - c.z|=r.z\n\t{\n\t\td = min(d, max3(c.x, c.y, abs(c.z - r.z)));\n\t\td = min(d, max3(c.x, abs(c.y - r.y), c.z));\n\t\td = min(d, max3(abs(c.x - r.x), c.y, c.z));\n\t}\n\n\t// done\n\treturn d;\n}\n\nfloat sd_scene(vec3 p)\n{\n    float sd = sd_cube(p - vec3(1.5, 0.0, 1.5), 0.5);\n    \n    sd = min(sd, sd_ellipsoid(p - vec3(-1.5, 0.0,  1.5), vec3(0.5, 1.0, 1.5)));\n    sd = min(sd, sd_ellipsoid(p - vec3( 1.5, 0.0, -1.5), vec3(1.5, 0.5, 1.0)));\n    sd = min(sd, sd_ellipsoid(p - vec3(-1.5, 0.0, -1.5), vec3(1.0, 1.5, 0.5)));\n    \n\treturn sd;\n}\n\nvoid sample_camera(\n\tvec2 pixel_coord,\n\tout vec3 camera_pos,\n\tout vec3 ray_dir,\n\tout float eps_factor)\n{\n\tvec2 uv = (pixel_coord - iResolution.xy/2.0)/iResolution.y;\n\n\tfloat camera_phi = 0.5*iTime + 0.5;\n\tcamera_pos = 8.0*vec3(cos(camera_phi), 0.7, sin(camera_phi));\n\n\tvec3 look_dir = normalize(-camera_pos);\n\tvec3 u_dir = normalize(cross(look_dir, vec3(0.0, 1.0, .0)));\n\tvec3 v_dir = cross(u_dir, look_dir);\n\n\tfloat fov_factor = 0.5;\n    vec2 fov_uv = fov_factor*uv;\n\tray_dir = max_normalize(look_dir + fov_uv.x*u_dir + fov_uv.y*v_dir);\n\teps_factor = 0.5*fov_factor/iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_pos, ray_dir;\n    float eps_factor;\n    sample_camera(fragCoord, camera_pos, ray_dir, eps_factor);\n    \n\tvec3 col = vec3(0.8);\n\n\t// show field on ground plane\n    float ground_y = (iTime > 10.0) ? (cos(iTime - 10.0) - 1.0) : 0.0;\n\tfloat debug_dist = (ground_y - camera_pos.y)/ray_dir.y;\n\tif (0.0 < debug_dist) {\n\t\t\n\t\tfloat debug_sd = sd_scene(camera_pos + ray_dir*debug_dist);\n\t\tfloat d = abs(debug_sd);\n\t\tcol = 0.4 + 0.6*vec3(fract(2.0*d), fract(4.0*d), debug_sd < 0.0);\n\t}\n\t\n\t// ray march\n\tfloat dist = 0.0;\n\tbool is_hit = false;\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\tfloat sd = sd_scene(camera_pos + ray_dir*dist);\n\t\tdist += sd;\n\t\tif (sd < dist*eps_factor) {\n\t\t\tis_hit = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (dist > debug_dist) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// shade\n\tif (is_hit) {\n\t\tvec3 hit_pos = camera_pos + ray_dir*dist;\n\t\tfloat eps = dist*eps_factor;\n\t\t\n\t\tvec2 e = eps*vec2(0.5, -0.5);\n\t\tvec3 normal = normalize(\n\t\t\t  e.xyy*sd_scene(hit_pos + e.xyy)        \n\t\t\t+ e.yxy*sd_scene(hit_pos + e.yxy)        \n\t\t\t+ e.yyx*sd_scene(hit_pos + e.yyx)        \n\t\t\t+ e.xxx*sd_scene(hit_pos + e.xxx));\n\t\t\n\t\tvec3 light_dir = normalize(vec3(2.0, 4.0, 1.0));\n        vec3 light_col = vec3(0.6, 0.5, 0.4);\n\t\tvec3 amb_col = vec3(0.4);        \n        \n\t\tcol = mix(amb_col + light_col*max(dot(normal, light_dir), 0.0), col, 0.2);\n\t}\n\n\tfragColor = vec4(pow(col, vec3(2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 91, 91, 120], [121, 121, 160, 160, 189], [191, 191, 218, 218, 249], [250, 250, 270, 270, 300], [302, 302, 326, 326, 357], [358, 358, 386, 386, 414], [416, 416, 448, 448, 475], [477, 477, 526, 560, 728], [730, 730, 766, 922, 2178], [2180, 2180, 2204, 2204, 2522], [2524, 2524, 2628, 2628, 3107], [3109, 3109, 3166, 3166, 4529]], "test": "valid"}
{"id": "Mt2XzK", "name": "hypno visualizer", "author": "public_int_i", "description": "visualizer", "tags": ["visualizer", "hypnotizing"], "likes": 4, "viewed": 237, "published": "Public", "date": "1445271311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    float ang = atan(uv.y,uv.x);\n    float len = 0.;\n    for (int i = 0; i < 5; i++) {\n        len = max(len,\n                  texture(iChannel0,vec2(abs(ang)*.04+.5,float(i)*.05)).x);\n    }\n    len *= .5;\n    \n    len = abs(length(uv)-len);\n    float ring = max(0.,1.-len*10.);\n    len = len*30. + iTime*8.;\n\tfragColor = mix( vec4(.1),\n                    vec4(sin(len),cos(len),-sin(len),1.)*.5+.5,\n                    1.-ring);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 543]], "test": "error"}
{"id": "MtBSRy", "name": "crowded cubes 3", "author": "FabriceNeyret2", "description": "one more variant of https://www.shadertoy.com/view/ltfXRM ", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 11, "viewed": 1139, "published": "Public API", "date": "1444555172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) v *= mat2( C = cos((t)*T), S = sin((t)*T), -S, C )\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    f-=f;\n    float C,S,r,x,x1;\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5.*T;\n   \n    for (float i=1.; i>0.; i-=.01)  \n    {\n        vec4 u = floor(p/8.), t = mod(p, 8.)-4., M,m; // objects id + local frame\n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);      // objects rotations\n        u = sin(78.*(u+u.yzxw));                      // randomize ids\n   \n        r = 1.2;\n        t = abs(t); M=max(t,t.yzxw); m=min(M,M.yzxw);\n        x = max(t.x,M.y)-r;\n        x1 = min(m.x,m.y);\n        x = max(x,1.1-x1);\n        x = min(x,x1-.02);\n        if(x<.01)  // hit !\n            { f = i*i*(1.+.2*t); break; } // color texture + black fog \n\n        p -= d*x;           // march ray\n     }\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 206, 206, 1069]], "test": "valid"}
{"id": "MtBSWy", "name": "GlowingStick", "author": "schwenk", "description": "This demo should realise a very simple GI-Model", "tags": ["2d", "illumination", "glowing", "linesegment"], "likes": 10, "viewed": 475, "published": "Public", "date": "1446204262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\n\nfloat angle_trunc(float a)\n{\n    for( int i = 0; i < 32; i++)\n    {\n        if( a >= 0.0 )\n            break;\n        else\n        \ta += PI * 2.0;\n    }\n    return a;\n}\n\nvec4 translate(vec2 translation,vec4 lineSeg)\n{\n    return vec4(lineSeg.r-translation.x,lineSeg.g-translation.y,lineSeg.b-translation.x,lineSeg.a-translation.y);\n}\n\nfloat lineSegToBrightness(vec4 lineSeg)\n{\n    float alpha = atan(lineSeg.g,lineSeg.r);\n    float beta =  atan(lineSeg.a,lineSeg.b);\n    \n    float bright = angle_trunc(alpha - beta);\n    if(bright > PI) bright = angle_trunc(beta - alpha);\n   \n    return (bright/PI);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lineSegment = vec4(0.5,0.5,0.5+0.5*sin(iTime/10.0),0.5+0.5*cos(iTime/10.0));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float bright = lineSegToBrightness(translate(uv,lineSegment));\n    \n    \n\tfragColor = vec4(bright,bright,bright,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 61, 61, 201], [203, 203, 250, 250, 366], [368, 368, 409, 409, 636], [640, 640, 697, 697, 959]], "test": "valid"}
{"id": "MtBSz3", "name": "raymaching-noob", "author": "Dermenslof", "description": "raymaching-noob", "tags": ["noobpower"], "likes": 3, "viewed": 152, "published": "Public", "date": "1445332916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SCENE int(mod(iDate.w, 32.)) / 8\n//int SCENE = 0;\n#define time iTime\n#define PI 3.14159265\nmat3 M3;\n\nmat3 rotx(float a) { return mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a)); }\nmat3 roty(float a) { return mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a)); }\nmat3 rotz(float a) { return mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1); }\nmat3 rot(float x, float  y, float z) { return M3 * rotx(radians(x)) * roty(radians(y)) * rotz(radians(z)); }\nmat3 scale(float x, float y, float z) { mat3 m = M3; m[0].x = 1. / x; m[1].y = 1. / y; m[2].z = 1. / z; return m; }\n\nvec2 obj_plane(in vec3 p, vec4 n) { return vec2(dot(p, n.xyz) + n.w, 0); }\nvec2 obj_sphere(in vec3 p, float radius) { return vec2(length(p) - radius, 1); }\nvec2 obj_cylinder(in vec3 p, vec3 c) { return vec2(length(p.xz - c.xy) - c.z, 1); }\nvec2 obj_cone(in vec3 p, vec2 c) { return vec2(dot(c, vec2(length(p.xy), p.z)), 1); }\n\nvec2 sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), 1);\n}\nvec2 obj_round_box(in vec3 p, vec3 dim, float radius) { return vec2(length(max(abs(p) - dim, .0)) - radius, 1); }\nvec2 obj_torus(in vec3 p, vec2 t) { return vec2(length(vec2(length(p.xz) - t.x, p.y)) - t.y, 1); }\nvec2 obj_torus82(in vec3 p, vec2 t) { return vec2(length(vec2(length(p.xz) - t.x, p.y)) - t.y, 1); }\nvec2 obj_triprism(in vec3 p, vec2 h) { vec3 q = abs(p); return vec2(max(q.z - h.y, max(q.x * 0.866025 + p.y * .5, -p.y) - h.x * .5), 1); }\nvec2 obj_hexprism(in vec3 p, vec2 h) { vec3 q = abs(p); return vec2(max(q.z - h.y, max((q.x * 0.866025 + q.y * .5), q.y) - h.x), 1); }\nvec2 obj_cappedcylinder(in vec3 p, vec2 h) { vec2 d = abs(vec2(length(p.xz), p.y)) - h; return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)), 1); }\nvec2 obj_capsule(in  vec3 p, vec3 a, vec3 b, float r) { vec3 pa = p - a, ba = b - a; float h = clamp(dot(pa, ba)/dot(ba, ba), .0, 1.); return vec2(length(pa - ba * h) - r, 1); }\nvec2 obj_ellipsoid(in vec3 p, vec3 r) { return vec2((length(p / r) - 1.) * min(min(r.x, r.y), r.z), 1); }\n\nvec2 op_union(vec2 a, vec2 b) { return vec2(min(a.x, b.x), a.x < b.x ? a.y : b.y); }\nvec2 op_sub(vec2 a, vec2 b) { return vec2(max(a.x, -b.x), a.x > b.x ? a.y : b.y); }\nvec2 op_int(vec2 a, vec2 b) { return vec2(max(a.x, b.x), a.x > b.x ? a.y : b.y); }\nvec2 op_mix(vec2 a, vec2 b, float m) { return vec2(mix(a.x, b.x, m), a.y); }\n\nvec3 op_rep(vec3 p, vec3 c) { return mod(p, c) - .5 * c; }\n\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  \tif (obj0.x < obj1.x)\n  \t\treturn obj0;\n  \telse\n  \t\treturn obj1;\n}\n \nvec2 distance_obj(in vec3 p)\n{\n    vec2 d = vec2(101., 0);\n    \n    if (SCENE == 0)\n    {\n    \td = obj_union(obj_plane(p, vec4(0,  1, 0, 3)), obj_torus(p - vec3(3, -2, 0), vec2(1.0, .2)));\n    \td = obj_union(d, op_sub(obj_sphere(p - vec3(0, -2, 0), 1.0), obj_round_box((p -  vec3(0, -2, 0)) * rot(45. + iTime * 10., 0. + iTime * 12., 45. + iTime * 5.), vec3(.6, .6, .6), 0.1)));\n\t\td = obj_union(d, op_sub(obj_round_box(p - vec3(-3, -2, 0), vec3(1),  0.), obj_sphere(p - vec3(-3, -2, 0),  1.2)));\n    \td = obj_union(d, obj_capsule(p - vec3(2, -3, -.5), vec3(1, 2, 1), vec3(1), 0.2));\n    \td = obj_union(d, obj_cappedcylinder((p - vec3(-3, -2, 0)) * rot(90.0, 0., 0.), vec2(0.2, 3)));\n    \td = obj_union(d, obj_ellipsoid((p - vec3(0, 0, 0)) * rot(90.0 + iTime * 10., 0., 0.  + iTime * 5.), vec3(.8, .5, .5)));\n    \td = obj_union(d, sdCone(p - vec3(2, -1, -2), vec3(1., .3, 2)));\n    }\n    else if (SCENE == 1)\n    {\n    \tp -= vec3(0, -4, 0);\n    \tvec2 b0 = obj_round_box(p * rot(45., 0., 45.), vec3(1.3, 1.3, 1.3), 0.1);\n    \tvec2 b1 = obj_round_box(p * rot(-45., 0., -45.), vec3(1.3, 1.3, 1.3), 0.1);\n    \tvec2 b2 = obj_round_box((p + vec3(0, -2, 0)) * rot(45., iTime * 20., 45.), vec3(.8, .8, .8), 0.);\n    \tvec2 s = op_sub(obj_round_box(p, vec3(1.), 0.), obj_sphere(p, 2.6));\n    \td = op_int(b0, s);\n    \td = op_mix(b1, d, 0.2);\n    \td = op_mix(obj_torus(p, vec2(1.4, 1.3)), d, 0.8);\n    \td.y = 2.0;\n    \ts = op_sub(b2, obj_sphere(p + vec3(0, -2, 0), 1.0));\n    \ts.y = 1.0;\n    \td = obj_union(d, obj_union(s, obj_plane(p, vec4(0,  1, 0, 1))));\n    }\n    else if (SCENE == 2)\n    {\n        p *= rot(0., time * 50., 0.);\n        \n        vec2 fuselage = op_int(obj_plane(p + vec3(-3.5, 0, 0), vec4(normalize(vec3(1, -.4, 0)), .2)\n                                        ), obj_ellipsoid(p , vec3(5, 1., 1.)));\n        vec2 queue = op_int(-obj_plane(p + vec3(-3.5, 0, 0), vec4(normalize(vec3(1, -.4, 0)), .2)), obj_ellipsoid((p + vec3(-3, 0, 0)) * rot(0., 0., -8.), vec3(2, .5, .5)));\n        \n        fuselage = obj_union(fuselage, queue);\n        d = obj_union(fuselage, obj_ellipsoid((p + vec3(0, 0, 0)) * rot(0., 90., 0.), vec3(6, .2, 1.5)));\n        d = obj_union(d, obj_ellipsoid((p + vec3(-2.8, -1, 0)) * rot(0., 0., 0.), vec3(.4, 1.5, .1)));\n        d = obj_union(d, obj_ellipsoid((p - vec3(0, .0, 0.)) * rot(mod(time * 600., 360.), 0., 0.) + vec3(5, -0.7, 0), vec3(.1, 1, .2)));\n        d = obj_union(d, obj_ellipsoid((p - vec3(0, .0, 0.)) * rot(mod(time * 600. + 180., 360.), 0., 0.) + vec3(5, -0.7, 0), vec3(.1, 1, .2)));\n        \n        d = obj_union(d, obj_plane(p, vec4(0, 1, 0, 2)));\n    }\n    else if (SCENE == 3)\n    {\n        p = op_rep(p + vec3(0, 0, -mod(time * 4., radians(350.))), vec3(6, 6, 6));\n        d = obj_round_box(p, vec3(1),  0.1);\n    }\n    return  d;\n}\n \nvec3 floor_color(in vec3 p)\n{\n  \tif (fract(p.x * .2) > .2)\n  \t{\n    \tif (fract(p.z * .2) > .2)\n     \t\treturn vec3(0, .1, .2);\n    \telse\n      \t\treturn vec3(1, 1, 1);\n  \t}\n  \telse\n  \t{\n    \tif (fract(p.z * .2) > .2)\n      \t\treturn vec3(1, 1, 1);\n    \telse\n      \t\treturn vec3(.3, 0, 0);\n   \t}\n}\n \nvec3 prim_c(in vec3 p)\n{\n  \treturn vec3(.6, .6, .8);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    M3 = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n  \tvec2 vPos = -1. + 2. * fragCoord / iResolution.xy;\n\n    float mx = (iMouse.x / iResolution.x) * PI;\n  \tfloat my = (iMouse.y / iResolution.y) * PI / 2.;\n\t//vec3 prp = vec3(cos(my) * cos(mx), sin(my), cos(my) * sin(mx)) * 6.; \n    \n    vPos.x *= iResolution.x / iResolution.y;\n  \tvec3 vuv = vec3(0, 1, 0); \n  \tfloat mov = iTime / 4.;\n    //vec3 prp = vec3(clamp(cos(mov) * 16., -8., 8.), clamp(-sin(mov * 2. + radians(90.)) * 0., -8., 8.), clamp(sin(mov) * 16., -8., 8.));\n    vec3 prp = vec3(0, 0, 5);\n    if (SCENE != 2)\n        prp = vec3(cos(time) * 8.0, 0, sin(time) * 8.);\n    else if (SCENE != 3)\n        prp = vec3(0, 5, 16);\n    vec3 light = vec3(0, 15, 0);\n    if (SCENE == 0)\n        light = vec3(0, 15, 15);\n  \t//vec3 vrp = prp + vec3(-cos(mov), 0, -sin(mov));\n    vec3 vrp = vec3(0, 0, 0);\n    vec3 vpn = normalize(vrp - prp);\n  \tvec3 u = normalize(cross(vuv, vpn));\n  \tvec3 v = cross(vpn, u);\n  \tvec3 vcv= prp + vpn;\n  \t//vec3 scrCoord=vcv+vPos.x*u*resolution.x/resolution.y+vPos.y*v;\n  \tvec3 scrCoord = vcv + vPos.x * u + vPos.y * v;\n  \tvec3 scp = normalize(scrCoord - prp);\n \n  \tconst vec3 e = vec3(0.00001, 0, 0);\n  \tconst float maxd = 100.;\n  \tvec2 d = vec2(.001, 0);\n  \tvec3 c, p, n;\n  \tfloat f = 1.0;\n  \tfor (int i = 0; i < 128; i++)\n  \t{\n    \tif ((abs(d.x) < .001) || (f > maxd)) \n      \t\tbreak;\n    \tf += d.x;\n    \tp = prp + scp * f;\n    \td = distance_obj(p);\n  \t}\n  \tif (f < maxd)\n  \t{\n    \tif (d.y == 0.0) \n      \t\tc = floor_color(p);\n    \telse if (d.y == 1.0)\n      \t\tc = prim_c(p);\n        else\n            c = texture(iChannel0, p.xy, -100.0).xyz;\n    \tvec3 n = vec3(d.x - distance_obj(p - e.xyy).x,\n                  d.x - distance_obj(p - e.yxy).x,\n                  d.x - distance_obj(p - e.yyx).x);\n    \tn = normalize(n);\n    \tfloat b = dot(n, normalize(light - p));\n    \tfragColor= vec4((b * c + pow(b, 16.)) * (1.0 - f * .01), 1);\n    }\n  \telse \n    \tfragColor = vec4(0, 0, 0, 1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 130, 130, 193], [194, 194, 214, 214, 277], [278, 278, 298, 298, 361], [362, 362, 400, 400, 470], [471, 471, 510, 510, 586], [588, 588, 623, 623, 662], [663, 663, 705, 705, 743], [744, 744, 782, 782, 827], [828, 828, 862, 862, 913], [915, 915, 952, 952, 1130], [1131, 1131, 1186, 1186, 1244], [1245, 1245, 1280, 1280, 1343], [1344, 1344, 1381, 1381, 1444], [1445, 1445, 1483, 1483, 1583], [1584, 1584, 1622, 1622, 1718], [1719, 1719, 1763, 1763, 1868], [1869, 1869, 1924, 1924, 2046], [2047, 2047, 2086, 2086, 2152], [2154, 2154, 2185, 2185, 2238], [2239, 2239, 2268, 2268, 2322], [2323, 2323, 2352, 2352, 2405], [2406, 2406, 2444, 2444, 2482], [2484, 2484, 2513, 2513, 2542], [2544, 2544, 2588, 2588, 2656], [2659, 2659, 2689, 2689, 5444], [5447, 5447, 5476, 5476, 5740], [5743, 5743, 5767, 5767, 5797], [5800, 5800, 5855, 5855, 7814]], "test": "error"}
{"id": "MtBXWw", "name": "ResolutionVsAntialiasing", "author": "TimothyLottes", "description": "Resolution vs Antialiasing vs Motion", "tags": ["resolutionvsantialiasingvsmotion"], "likes": 16, "viewed": 1098, "published": "Public", "date": "1444957078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SHOWING RESOLUTION VS SAMPLES VS MOTION\n//\n// Warning full-screen on a slow machine is a likely TDR!!!!\n// I'm too afraid to try it, so this is tuned to the standard 1920x1080 shadertoy view in a browser.\n// Shader built and tested only on a laptop, probably fine on big desktop GPU.\n//\n// Each pair of rows has same number of shaded samples.\n// Samples are shaded either to white or black.\n// Top of pair is at full resolution.\n// Bottom of pair is at 1/2 resolution (aka 1/4 area).\n// Shows geometric aliasing in motion.\n//\n// Rows from top to bottom,\n//\n//  1x       at full resolution \n//  4xSGSSAA at 1/4 area in resolution \n//\n//  2xSGSSAA at full resolution\n//  8xSGSSAA at 1/4 area in resolution \n//\n//  4xSGSSAA at full resolution\n// 16xSGSSAA at 1/4 area in resolution \n//\n//  8xSGSSAA at full resolution\n// 32xSGSSAA at 1/4 area in resolution \n//\n// 16xSGSSAA at full resolution\n// 64xSGSSAA at 1/4 area in resolution \n//\n// Since everything is exactly up/down this SGSSAA simplifies to sampling in a line...\n// Resolve is a simple cubic filter which is larger than a pixel.\n//\n// Precision in motion = resolution * intensity steps as edge moves across pixel.\n//\n// For the same number of samples the lower resolution display \n// offers better motion precision but with compromized sharpness.\n// The extra spatial precision for the lower resolution display\n// is a product of being able to adjust sampling locations\n// from exactly resolving detail in the rectangular grid, \n// to better resolving sub-pixel position.\n// providing more effective intensity steps as a edge moves across a pixel.\n\n// Types.\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n#define S1 int\n#define S2 int2\n#define S3 int3\n#define S4 int4\n\n// Controls.\n#define BARS (1.0/6000.0)\n#define THROW (16.0/1.0)\n#define SPEED (1.0/4.0)\n\n// Generates the source image.\nF1 Src(F1 x){return fract(x*x*BARS)<0.5?0.0:1.0;}\n\n// Convert from linear to sRGB.\nF1 Srgb(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n\n// Filter as Cubic B-spline (x = distance from center).\n// General Mitchell-Netravali filter,\n//   http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf\nF1 Filter(F1 x){\n  F1 b=1.0,c=0.0;\n  if(abs(x)<1.0)return(1.0/6.0)*((12.0-9.0*b-6.0*c)*x*x*abs(x)+(-18.0+12.0*b+6.0*c)*x*x+(6.0-2.0*b));\n  if(abs(x)<2.0)return(1.0/6.0)*((-b-6.0*c)*x*x*abs(x)+(6.0*b+30.0*c)*x*x+(-12.0*b-48.0*c)*abs(x)+(8.0*b+24.0*c));\n  return 0.0;}\n\n// Generates a swatch to test resolution and sample settings.\nF1 Swatch(F1 x,F1 o,F1 res,S1 num) {\n  // Filter sums.\n  F1 rSum=0.0;\n  F1 wSum=0.0;\n  F1 rSum2=0.0;\n  F1 wSum2=0.0;\n  // Base and stride for sampling.\n  F1 xBase=(floor(x/res)+(0.5/F1(num)))*res-(res*1.5);\n  F1 xStride=res/F1(num);\n  F1 xMid=(floor(x/res)+0.5)*res-(res*1.0);\n  // Filtering.\n  F1 xCenter=x+0.5;\n  F1 xScale=1.0/res;\n  F1 xScale2=1.0/res;\n  F1 p,r,w;\n  F1 r0,r1,r2;\n  F1 p0,p1,p2;\n  //    \n  if(num==1){return Src((floor(x/res)+(0.5/F1(num)))*res+o);}\n  //    \n  if(num==2){\n    p0=xMid;  \n    for(S1 i=0;i<2*2;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r0=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p0-xCenter)*xScale2);rSum2+=r0*w;wSum2+=w;  \n    p1=xMid;  \n    for(S1 i=0;i<2*2;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r1=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p1-xCenter)*xScale2);rSum2+=r1*w;wSum2+=w;  \n    p2=xMid;  \n    for(S1 i=0;i<2*2;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r2=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p2-xCenter)*xScale2);rSum2+=r2*w;wSum2+=w;\n    return rSum2/wSum2;}\n  //\n  if(num==4){\n    p0=xMid;  \n    for(S1 i=0;i<2*4;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r0=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p0-xCenter)*xScale2);rSum2+=r0*w;wSum2+=w;  \n    p1=xMid;  \n    for(S1 i=0;i<2*4;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r1=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p1-xCenter)*xScale2);rSum2+=r1*w;wSum2+=w;  \n    p2=xMid;  \n    for(S1 i=0;i<2*4;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r2=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p2-xCenter)*xScale2);rSum2+=r2*w;wSum2+=w;\n    return rSum2/wSum2;}\n  //\n  if(num==8){\n    p0=xMid;  \n    for(S1 i=0;i<2*8;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r0=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p0-xCenter)*xScale2);rSum2+=r0*w;wSum2+=w;  \n    p1=xMid;  \n    for(S1 i=0;i<2*8;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r1=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p1-xCenter)*xScale2);rSum2+=r1*w;wSum2+=w;  \n    p2=xMid;  \n    for(S1 i=0;i<2*8;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r2=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p2-xCenter)*xScale2);rSum2+=r2*w;wSum2+=w;\n    return rSum2/wSum2;}\n  //\n  if(num==16){\n    p0=xMid;  \n    for(S1 i=0;i<2*16;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r0=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p0-xCenter)*xScale2);rSum2+=r0*w;wSum2+=w;  \n    p1=xMid;  \n    for(S1 i=0;i<2*16;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r1=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p1-xCenter)*xScale2);rSum2+=r1*w;wSum2+=w;  \n    p2=xMid;  \n    for(S1 i=0;i<2*16;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r2=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p2-xCenter)*xScale2);rSum2+=r2*w;wSum2+=w;\n    return rSum2/wSum2;}\n  //\n  if(num==32){\n    p0=xMid;  \n    for(S1 i=0;i<2*32;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r0=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p0-xCenter)*xScale2);rSum2+=r0*w;wSum2+=w;  \n    p1=xMid;  \n    for(S1 i=0;i<2*32;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r1=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p1-xCenter)*xScale2);rSum2+=r1*w;wSum2+=w;  \n    p2=xMid;  \n    for(S1 i=0;i<2*32;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r2=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p2-xCenter)*xScale2);rSum2+=r2*w;wSum2+=w;\n    return rSum2/wSum2;}\n  //\n  if(num==64){\n    p0=xMid;  \n    for(S1 i=0;i<2*64;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r0=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p0-xCenter)*xScale2);rSum2+=r0*w;wSum2+=w;  \n    p1=xMid;  \n    for(S1 i=0;i<2*64;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r1=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p1-xCenter)*xScale2);rSum2+=r1*w;wSum2+=w;  \n    p2=xMid;  \n    for(S1 i=0;i<2*64;i++){p=xBase+F1(i)*xStride;r=Src(p+o);w=Filter(abs(p-xMid)*xScale);rSum+=r*w;wSum+=w;}\n    r2=rSum/wSum;xBase+=res;xMid+=res;rSum=0.0;wSum=0.0;\n    w=Filter(abs(p2-xCenter)*xScale2);rSum2+=r2*w;wSum2+=w;\n    return rSum2/wSum2;}\n  //\n  return 0.0;}      \n\n// Shader.\nvoid mainImage(out F4 fragColor,in F2 fragCoord){ \n  F1 x=fragCoord.x;\n  F1 y=1.0-fragCoord.y/iResolution.y;\n  F1 o=sin(iTime*SPEED)*THROW;\n  fragColor.g=0.0;  \n  if((y>0.04)&&(y<0.09))     fragColor.g=Swatch(x,o,1.0,1);\n  else if((y>0.11)&&(y<0.16))fragColor.g=Swatch(x,o,2.0,4);\n  //\n  else if((y>0.24)&&(y<0.29))fragColor.g=Swatch(x,o,1.0,2);\n  else if((y>0.31)&&(y<0.36))fragColor.g=Swatch(x,o,2.0,8);\n  //\n  else if((y>0.44)&&(y<0.49))fragColor.g=Swatch(x,o,1.0,4);\n  else if((y>0.51)&&(y<0.56))fragColor.g=Swatch(x,o,2.0,16);\n  //\n  else if((y>0.64)&&(y<0.69))fragColor.g=Swatch(x,o,1.0,8);\n  else if((y>0.71)&&(y<0.76))fragColor.g=Swatch(x,o,2.0,32);\n  //\n  else if((y>0.84)&&(y<0.89))fragColor.g=Swatch(x,o,1.0,16);\n  else if((y>0.91)&&(y<0.96))fragColor.g=Swatch(x,o,2.0,64);\n  //        \n  fragColor.g = Srgb(fragColor.g);\n  fragColor.rgb = fragColor.ggg;\n  fragColor.a = 0.0;}    \n    \n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1837, 1868, 1881, 1881, 1917], [1919, 1951, 1965, 1965, 2021], [2023, 2207, 2223, 2223, 2473], [2475, 2537, 2573, 2591, 7649], [7657, 7668, 7717, 7717, 8555]], "test": "valid"}
{"id": "MtjSWW", "name": "Positive Aura", "author": "wessles", "description": "They sync up sometimes.", "tags": ["2d", "glowing"], "likes": 0, "viewed": 149, "published": "Public", "date": "1443814213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define radius 20.0\n\nfloat getSpotlight(vec2 uv, float timex, float timey)\n{\n    vec2 spotlightLocation = iResolution.xy*vec2(0.5+0.4*sin(iTime*timex/10.0), 0.5+0.4*sin(iTime*timey/10.0));\n    float dx = spotlightLocation.x-uv.x;\n    float dy = spotlightLocation.y-uv.y;\n    float dist = sqrt(dx*dx+dy*dy)/radius;\n    return max(0.0, 1.0-dist*dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    float amt = 0.0;\n    for(int i = 0; i < 100; i++)\n        fragColor += getSpotlight(uv.xy, amt+=0.3, amt+amt*0.3);\n    fragColor.r += sin(iTime/1.0);\n    fragColor.g += sin(iTime/2.0);\n    fragColor.b += sin(iTime/3.0);\n    fragColor *= abs(sin(iTime))*0.4+0.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 76, 76, 351], [353, 353, 410, 410, 703]], "test": "valid"}
{"id": "MtjSzd", "name": "Waves (Anastadunbar)", "author": "anastadunbar", "description": "I feel always bored and tired.", "tags": ["2d", "waves", "water", "random", "flow", "spread"], "likes": 25, "viewed": 524, "published": "Public", "date": "1446018360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float clamps(float a) {\n    return clamp(a,0.,1.);\n}\nfloat make_wave(vec2 uv, vec2 position, float dist, float freq, float time) {\n    return clamps(1.-(length(uv-position)*dist))*sin((length(uv-position)*freq)-time);\n}\nfloat rand(float co){\n    return fract(sin(dot(vec2(co*1.21,co*2.131) ,vec2(12.9898,78.233))) * 431758.51453);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 rand2(float co){\n    return vec2(fract(sin(dot(vec2(co,co*2.) ,vec2(12.9898,78.233))) * 43758.5453),fract(sin(dot(vec2(co+1.,co*2.) ,vec2(12.9198,78.323))) * 43558.1453));\n}\nvec2 rand2(vec2 co){\n    return vec2(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),fract(sin(dot(co.xy*3. ,vec2(12.9198,78.323))) * 43558.1453));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = vec2(((uv.x-0.5)*(iResolution.x / iResolution.y))+0.5,uv.y);\n    \n    float time = iTime;\n    \n    float waves = 0.;\n    for (float i = 0.; i < 36.; i++) {\n    float delay = (rand(i*2.42)*2.)+3.;\n    float time2 = time+(rand(i)*6.12);\n    float fracttime = fract(time2/delay);\n    waves += make_wave(uv,rand2(floor(time2/delay)+(i*2.)),((1.-(fracttime-0.1))*10.),100.+(rand(floor(time2/delay)+i)*20.),time2*4.)*(1.-fract(time2/delay));\n    }\n    \n    float displays = (waves+1.)/2.;\n    \n\tfragColor = vec4(vec3(displays),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 52], [53, 53, 130, 130, 219], [220, 220, 241, 241, 332], [333, 333, 353, 353, 425], [426, 426, 447, 447, 604], [605, 605, 625, 625, 764], [766, 766, 823, 823, 1400]], "test": "valid"}
{"id": "MtjSzG", "name": "Cotton candy Pac-Man", "author": "Nrx", "description": "Quite the same as [url=https://www.shadertoy.com/view/XljXRG]this[/url] (= study of how to render cloudy stuff), but using [url=https://www.shadertoy.com/view/MlfGR4]this model[/url] instead.", "tags": ["noise", "pacman"], "likes": 19, "viewed": 706, "published": "Public API", "date": "1444723738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From https://www.shadertoy.com/view/MlfGR4\n// From https://www.shadertoy.com/view/MljXDw (from Duke)\n\n// Rendering parameters\n#define GROUND\n#define GHOST\n\n#define CAMERA_FOCAL_LENGTH\t3.0\n#define RAY_STEP_MAX\t\t100\n#define RAY_LENGTH_MAX\t\t500.0\n#define DIST_CORRECTION\t\t0.8\n#define DIST_MIN\t\t\t1.5\n\n// Math constants\n#define PI\t3.14159265359\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel0, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n\treturn noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, in float noiseFactor) {\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = iTime * 100.0;\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Pac-Man\n\tfloat body = length (p);\n\tbody = max (body - 32.0, 27.0 - body);\n\tfloat eyes = 10.0 - length (vec3 (abs (p.x) - 15.0, p.y - 20.0, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.07 + 0.07 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, 0.13);\n\tvec3 P = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0 * min (p.z / 20.0, 1.0), -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1);\n\tground = max (ground, -6.0 - ground) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\t#ifdef GHOST\n\tv = 130.0 + 60.0 * cos (iTime * 3.0);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\tbody = max (body - 28.0, 22.0 - body);\n\teyes = 10.0 - length (vec3 (abs (q.x) - 14.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, 0.76);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// FBM\n\td.x += noiseFactor * (fbm (P * 0.5) - 1.4);\n\td.y += 0.3 * noise (P * 0.5) - 0.15;\n\treturn d;\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the position of the camera\n\tfloat cameraDist = 125.0 + 60.0 * cos (iTime * 0.8);\n\tvec3 rayOrigin;\n\tif (iMouse.z < 0.5) {\n\t\trayOrigin = vec3 (cameraDist * cos (iTime), 5.0 + 70.0 * sin (iTime * 0.5), cameraDist * sin (iTime));\n\t} else {\n\t\tfloat cameraAngle = 4.0 * PI * iMouse.x / iResolution.x;\n\t\trayOrigin = vec3 (cameraDist * sin (cameraAngle), 5.0 + 70.0 * (1.0 - 2.0 * iMouse.y / iResolution.y), cameraDist * cos (cameraAngle));\n\t}\n\n\t// Define the orientation of the camera\n\tvec3 cameraLookAt = vec3 (10.0 * cos (iTime * 0.8), 10.0 + 10.0 * sin (iTime * 0.2), 20.0 * sin (iTime * 0.5) - 10.0);\n\tvec3 cameraForward = cameraLookAt - rayOrigin;\n\tvec3 cameraUp = vec3 (0.2 * cos (iTime * 0.1), 1.0, 0.2 * sin (iTime * 0.1));\n\tmat3 cameraOrientation;\n\tcameraOrientation [2] = normalize (cameraForward);\n\tcameraOrientation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraOrientation [1] = cross (cameraOrientation [2], cameraOrientation [0]);\n\tvec3 rayDirection = cameraOrientation * normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Define the sun direction\n\tfloat sunYawAngle = PI * 0.25;\n\tfloat sunPitchAngle = iTime * 0.1;\n\tvec3 sunDirection = vec3 (sin (sunYawAngle) * sin (sunPitchAngle), cos (sunPitchAngle), cos (sunYawAngle) * sin (sunPitchAngle));\n\n\t// Set the sky color\n\tvec3 skyColor = mix (vec3 (0.8, 0.4, 0.4), vec3 (0.4, 0.4, 0.6), smoothstep (0.0, 0.5, sunDirection.y));\n\tskyColor += vec3 (0.8, 0.6, 0.4) * pow (max (0.0, dot (rayDirection, sunDirection)), 12.0);\n\tskyColor = mix (vec3 (0.15, 0.15, 0.24), skyColor, min (1.0, 1.0 + sunDirection.y));\n\n\t// Set the noise and density factors\n\tfloat candyControl = smoothstep (0.4, 0.6, sin (iTime * 0.7));\n\tfloat noiseFactor = mix (4.0, 8.0, candyControl);\n\tfloat densityFactor = mix (0.1, 0.5, candyControl);\n\n\t// Ray marching\n\tfloat densityTotal = 0.0;\n\tvec3 colorTotal = vec3 (0.0);\n\tfloat rayLength = 0.0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Compute the maximum density\n\t\tfloat densityMax = 1.0 - rayLength / RAY_LENGTH_MAX;\n\t\tif (densityTotal > densityMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the scene information\n\t\tvec3 p = rayOrigin + rayDirection * rayLength;\n\t\tvec2 data = distScene (p, noiseFactor);\n\t\tfloat dist = data.x * DIST_CORRECTION;\n\t\tif (dist < 0.0) {\n\n\t\t\t// Compute the local density\n\t\t\tfloat densityLocal = (densityTotal - densityMax) * dist * densityFactor;\n\t\t\tdensityTotal += densityLocal;\n\n\t\t\t// Update the color\n\t\t\tvec3 colorLocal = hsv2rgb (vec3 (data.y, 0.2, 1.0));\n\t\t\tcolorTotal += colorLocal * densityLocal;\n\t\t}\n\n\t\t// Go ahead\n\t\trayLength += max (dist, DIST_MIN);\n\t}\n\tcolorTotal += skyColor * (1.0 - densityTotal);\n\n\t// Set the fragment color\n\tfragColor = vec4 (colorTotal, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjSzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 363, 388, 388, 589], [591, 598, 621, 621, 690], [692, 748, 798, 854, 2422], [2424, 2438, 2466, 2466, 2658], [2660, 2677, 2733, 2772, 5498]], "test": "error"}
{"id": "MtjSzK", "name": "Melting pot", "author": "rohtie", "description": "Just experimenting with some pattern making.", "tags": ["pattern"], "likes": 1, "viewed": 119, "published": "Public", "date": "1445103995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin(float a, float b, float k) {\n    float h = clamp( 0.5 + 0.5 * (b-a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\nfloat clearify(float dist) {\n\treturn smoothstep(0.19, 0.21, dist);\n}\n\nvoid mainImage( out vec4 col, in vec2 p ) {\n\tp /= iResolution.xy;    \n    p.x *= iResolution.x / iResolution.y;\n\n    // Hard box vs Round box  \n    #if 1\n    float r = length(max(abs(p - 0.4) - 0.1, 0.0));    \n    float g = length(max(abs(p - 0.6) - 0.1, 0.0));\n \t#else\n    float r = max(abs(p - 0.4).x, abs(p - 0.4).y);\n    float g = max(abs(p - 0.6).x, abs(p - 0.6).y);\n    #endif\n    \n    r *= texture(iChannel0, vec2((p.x) * 0.5, 0.75)).r * 2.5;\n    g *= texture(iChannel0, vec2((p.x) * 0.5, 0.75)).r * 0.25;\n    \n    // Create pattern\n    #if 1\n    float t = (iTime + 3000.0) / 150.0;\n    p += t * 5.0;\n    \n    r += cos(t / 2.0 * p.x) * tan(t * p.y);\n    g += sin(t * 3.0 * p.x) * cos(t / 5.0 * p.y);\n    #endif\n    \n    vec2 c = vec2(0.0, 1.0) * 0.25;\n\n    col.rgb = vec3(1.0) + \n        clearify(min(r, g))       * c.xyy -\n        clearify(mix(r, g, 0.5))  * c.yyx - \n        clearify(smin(r, g, 0.2)) * c.yyy - \n        clearify(max(r, g))       * c.xyy -\n        clearify(max(-r, g))      * c.xyy;\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 144], [146, 146, 174, 174, 214], [216, 216, 259, 259, 1225]], "test": "error"}
{"id": "MtjSzt", "name": "WaterRipples", "author": "jt", "description": "Water ripples (currently using dispersion-function by FabriceNeyret2 - see comments).", "tags": ["waves", "ripples", "water"], "likes": 9, "viewed": 961, "published": "Public", "date": "1445972695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Water-Ripples - written by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat zoom = 20.0;\n\nvec2 refl2(vec2 v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat sech(float v)\n{\n    return 2.0 / (exp(v) + exp(-v));\n}\n\nfloat ease(float v)\n{\n    return (0.5 - 0.5 * cos(v * 2.0 * 3.1415926));\n}\n\nfloat easeout(float v)\n{\n    return (0.5 + 0.5 * cos(fract(v) * 3.1415926));\n}\n\nfloat wave(float x, float k, float c, float t)\n{\n    float X = x - c * t;\n    return sin(k * X) * exp(-X * X);\n}\n\nfloat dispersion(float d, float t) // testing FabriceNeyret2's waves dispersion function (source: https://www.shadertoy.com/view/MtBSDG)\n{\n    float A = 0.8;\n    float sum = 0.0;\n    for (float k = 1.0; k < 10.0; k++)\n    {\n        sum += A * wave(abs(d), k, sqrt(k), t) / k; // dispertion for capillary waves\n        //sum += A * wave(abs(d), k, 1.0 / sqrt(k), t) / k;// dispertion for gravity waves\n    }\n    \n    //return sum; // 1d function\n    return sum / d; // correct 2d function (\"1/r\")\n}\n\nfloat ripple(vec2 seed, vec2 pos) // NOTE: seed must be in [0..127]\n{\n    float period = 20.0;\n    //vec2 src = vec2(float(perm[seed]) / 255.0, float(perm[seed + 128]) / 255.0);\n    vec2 src = texture(iChannel0, seed).xy;\n    float offset = texture(iChannel0, seed).z;\n    float localtime = iTime / period + offset;\n    src = refl2(src + floor(localtime) * texture(iChannel0, seed).zw); // change source-position\n    float d = zoom * length(pos - src);\n    float t = fract(localtime) * period;\n    float v = 5.0 * dispersion(d * 5.0, t) / d;\n    v *= easeout(t / period);\n    return v;\n}\n/*\nfloat ripple(vec2 seed, vec2 pos) // NOTE: seed must be in [0..127]\n{\n    float period = 10.0;\n    //vec2 src = vec2(float(perm[seed]) / 255.0, float(perm[seed + 128]) / 255.0);\n    vec2 src = texture(iChannel0, seed).xy;\n    float offset = texture(iChannel0, seed).z;\n    float localtime = iTime / period + offset;\n    src = refl2(src + floor(localtime) * texture(iChannel0, seed).zw); // change source-position\n    float d = zoom * length(pos - src);\n    float t = fract(localtime) * period;\n    float v = sech((-t + d) / 2.5 * 2.0 * 3.1415926) * sin(2.0 * (-iTime + d) * 2.0 * 3.1415926);\n    v *= exp(-pow(d / 5.0, 2.0)) * easeout(t / period);\n    return v;\n}\n*/\nfloat ripples(vec2 pos)\n{\n    float h = 0.0;\n    h += ripple(vec2(0.0, 0.0), pos);\n\n    h += ripple(vec2(0.0, 0.25), pos);\n    h += ripple(vec2(0.25, 0.25), pos);\n    h += ripple(vec2(0.25, 0.0), pos);\n\n    h += ripple(vec2(0.0, 0.5), pos);\n    h += ripple(vec2(0.25, 0.5), pos);\n    h += ripple(vec2(0.5, 0.5), pos);\n    h += ripple(vec2(0.5, 0.25), pos);\n    h += ripple(vec2(0.5, 0.0), pos);\n\n    return h / 9.0;\n\n//    h += ripple(vec2(0.0, 0.75), pos);\n//    h += ripple(vec2(0.25, 0.75), pos);\n//    h += ripple(vec2(0.5, 0.75), pos);\n//    h += ripple(vec2(0.75, 0.75), pos);\n//    h += ripple(vec2(0.75, 0.5), pos);\n//    h += ripple(vec2(0.75, 0.25), pos);\n//    h += ripple(vec2(0.75, 0.0), pos);\n//\n//    return h / 16.0;\n}\n\nfloat checker2(vec2 pos)\n{\n    return step((fract(pos.x) - 0.5) * (fract(pos.y) - 0.5), 0.0);\n}\n\nvec3 ripples_normal(vec2 pos)\n{\n    float d = 0.001;\n    return normalize(vec3(\n        ripples(pos - vec2(d, 0.0)) - ripples(pos + vec2(d, 0.0)),\n        ripples(pos - vec2(0.0, d)) - ripples(pos + vec2(0.0, d)),\n        d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float w = 0.5 + 0.5 * ripple(fragCoord.xy / iResolution.xy.xy);\n    //float w = 0.5 + 0.5 * ripples(fragCoord.xy / iResolution.xy.xy);\n    //w = 1.0 - pow(1.0 - 2.0 * w, 5.0);\n    vec3 n = ripples_normal(fragCoord.xy / iResolution.xy);\n    //float w = checker2(10.0 * fragCoord.xy / iResolution.xy + 10.0 * grad);\n    vec3 w = texture(iChannel1, fragCoord.xy / iResolution.xy + n.xy).rgb;\n    float specular = pow(abs(dot(n, normalize(vec3(1.0, 1.0, 1.0)))), 10.0);\n    fragColor = vec4(w + vec3(specular), 1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjSzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[152, 152, 172, 172, 218], [220, 220, 241, 241, 280], [282, 282, 303, 303, 356], [358, 358, 382, 382, 436], [438, 438, 486, 486, 550], [552, 552, 690, 690, 1049], [1051, 1051, 1120, 1120, 1638], [1639, 2309, 2334, 2334, 3043], [3045, 3045, 3071, 3071, 3140], [3142, 3142, 3173, 3173, 3370], [3372, 3372, 3429, 3611, 3950]], "test": "error"}
{"id": "MtjXzc", "name": "slime puddles", "author": "public_int_i", "description": "short 10 minute sketch, can definitely be minimized", "tags": ["slime", "puddles"], "likes": 8, "viewed": 468, "published": "Public", "date": "1445615514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5 -iTime*.05;\n    vec3 c = cos(vec3(iTime*.006,\n                  iTime*.025,\n                  iTime*.0095))*2.+2.;\n    for (int i = 0; i < 27; i++) {\n        vec3 p = vec3(uv*float(i),float(i));\n    \tc += vec3( sin(c.y+sin(p.x)),\n                   cos(c.z+sin(p.z)),\n                   -sin(c.x+sin(p.y)) );\n    }\n    fragColor = vec4(c*c*.004,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 455]], "test": "valid"}
{"id": "MtSSDG", "name": "inverse trochoids", "author": "FabriceNeyret2", "description": "Trochoid wave curve is parametric (x(),y()), while in a shader we need a \"procedural\" form y(x).\nNB: yMouse tunes the amplitude.", "tags": ["parametriccurve", "trochoid"], "likes": 10, "viewed": 1186, "published": "Public API", "date": "1446127127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trochoid : ( x(), y() ) = ( x0+A.cos(x0-t) , A.sin(x0-t) )\n// problem: we want y(x).\n\nfloat A,  t; \n\n#define C(x)   A*cos(x-t)    // indeed, x-t should be k.(x-c.t)\n#define S(x)   A*sin(x-t)\n#define X0(x,xx)  x-C(xx)\n\nfloat trochoid(float x, float t) {\n// solve x = x0 + A.cos(x0-t) for x0\n//  as  x = x_i+1 + A.cos(x_i-t) ; x_0 = x\n// then apply y = A.sin(x0-t)\n// see more here: https://www.desmos.com/calculator/r0uowdkejy\n    return S(X0(x,X0(x,X0(x,X0(x,X0(x,x))))));\n}\n\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\n\nvoid mainImage( out vec4 o, vec2 uv )\n{\n    vec2 R = iResolution.xy;\n    o = vec4(0); t=iTime;\n    uv = 10.* (2.*uv-R)/R.y; \n    A = iMouse.y<=0. ? sin(t) : iMouse.y/R.y;\n    \n    \n\tplot(  trochoid(uv.x, t) + 4.); // positive trochoid (gravity wave) \n\tplot( -trochoid(uv.x, t) - 4.); // negative trochoid (capillary wave)\n    \n    // approximations based on jt idea : \n    // plot( -2.* exp( - abs(sin(0.5 *( uv.x - t - 1.57))))   - 4.5);\n    // plot( - exp( sin(uv.x -  t ) )      -6.);\n \n    o.b += .2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 255, 428, 477], [582, 582, 621, 621, 1088]], "test": "valid"}
{"id": "MtSXDD", "name": "Infinity Eye", "author": "public_int_i", "description": "infinity eye", "tags": ["eye", "infinity"], "likes": 1, "viewed": 379, "published": "Public API", "date": "1443666971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float brightness = 3.;\nconst int iterations = 84;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\t\n    float ang = atan(uv.y,uv.x);\n    float len = length(uv);\n    \n    vec3 c = vec3(0.);\n    \n    for (int i = 0; i < iterations; i++) {\n        float wlen = len*(35.+cos(iTime+float(i)*.723)*10.) + iTime;\n        vec2 vuv = vec2(cos(wlen),sin(wlen))*len;\n        float o = max(0.,1.-length(uv-vuv)*(5.+cos(float(i)*.6345)*3.));\n        c += o*(vec3(sin(float(i)),cos(float(i)),-cos(float(i)))*.5+.5);\n        uv = uv-uv*vuv/len*.4;\n    }\n    \n    fragColor = vec4(c*(1./float(iterations))*brightness,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 682]], "test": "valid"}
{"id": "MtSXR3", "name": "[CIS565 2015F] FinalScene", "author": "momeg", "description": "https://github.com/megmo21/Project5-GLSL-Ray-Marcher\nAcknoledgments: (also at top of script) \nNumerical Methods for Ray Tracing Implicitly Defined Surfaces (2014). PDF\nIÃ±igo QuÃ­lez. Terrain Raymarchi", "tags": ["cis565"], "likes": 0, "viewed": 118, "published": "Public", "date": "1445295919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//http://www.iquilezles.org/www/articles/menger/menger.htm - mendel sponge\n//https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model - blinn-phong lighting\n//http://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf - ray marching/sphere tracing\n//http://www2.compute.dtu.dk/pubdb/views/edoc_download.php/6392/pdf/imm6392.pdf - ambient occlusion/soft shadows\n//--Distance Functions-------------------------------------------------------------------\n\n#define NORMALS 0 \n#define RAY_STEPS 0 \n#define DISTANCE 0\n#define SPHERE_TRACE 1\n\n\nfloat planeDist( vec3 p )\n{\n    /*if (p.y < ((sin(p.x) - sin(p.z)) / 4.0)) return (sin(p.x) - sin(p.z)) / 4.0;\n     else return 100.0;\n     return 100.0;*/\n    return p.y;\n    \n}\n\nfloat sphereDist(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxDist( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torusDist( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat roundBoxDist( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat crossDist( in vec3 p )\n{\n    float da = boxDist(p.xyz,vec3(100000,1.0,1.0));\n    float db = boxDist(p.yzx,vec3(1.0,100000,1.0));\n    float dc = boxDist(p.zxy,vec3(1.0,1.0,100000));\n    return min(da,min(db,dc));\n}\n\nfloat crossDist2( in vec3 p )\n{\n    float da = boxDist(p.xyz,vec3(.7,.3,.3));\n    float db = boxDist(p.yzx,vec3(.3,.7,.3));\n    float dc = boxDist(p.zxy,vec3(.3,.3,.7));\n    return min(da,min(db,dc));\n}\n\n//--CSG Functions----------------------------------------------------------------------\n\nfloat diffFunc(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat intersectionFunc(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    vec4 height = texture(iChannel0, p.xz);\n    //float avg = clamp((height.x + height.y + height.z + height.w) / 4.0, 0.0, 2.0);\n    return roundBoxDist(q - vec3(0.0, 0.0, 0.0), vec3(.35, 0.1, .35), 0.1);\n}\n\nfloat displace( vec3 p )\n{\n    float d1 = torusDist(p, vec2(.2, .2));\n    float d2 = (sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z)) / (16.0*p.y);\n    return d1+d2;\n}\n\nvec3 transform(vec3 pt, vec3 translate, vec3 rot, vec3 scale) {\n    scale.x = 1.0/scale.x;\n    scale.y = 1.0/scale.y;\n    scale.z = 1.0/scale.z;\n    mat3 invRot = mat3(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) ,\n                       cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z),\n                       -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z);\n \tmat4 trans = mat4(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) , 0.0, \n                      cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z), 0.0, \n                      -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z, 0.0, \n                      (-invRot*translate).x, (-invRot*translate).y, (-invRot*translate).z, 1.0);\n    \n    vec4 newPt = vec4(pt, 1.0);\n    newPt = trans*newPt;\n    return vec3(newPt);\n                    \n}\n\nvec2 myMin(vec2 d1, vec2 d2) {\n    \n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--Different Scenes-------------------------------------------------------------------\n\nvec2 scene(vec3 ro, vec3 rd, float t) {\n    vec3 pt = ro + rd*t;\n    \n    float tmin = boxDist(pt - vec3(1.0, 0.0, -1.0), vec3(.3));\n    //vec2 obj = vec2(tmin, 0.0);\n    float s = 1.0;\n    for( int m=0; m<5; m++ )\n    {\n        vec3 a = mod( pt*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        \n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n        \n        tmin = max(tmin,c);\n    }\n    vec2 obj = vec2(tmin, 0.0);\n    obj = myMin(obj, vec2(planeDist(pt - vec3(0.0, -1.0, 1.0)), 1.0));\n    obj = myMin(obj, vec2(displace(pt - vec3(-2.5, 0.0, 1.0)), 2.0));\n    obj = myMin(obj, vec2(diffFunc(boxDist(pt - vec3(-2.0, .5, -.5), vec3(0.30, 0.50, 0.30)), sphereDist(pt - vec3(-2.0, .5, -.5), 0.4)), 3.0));\n    obj = myMin(obj, vec2(torusDist(pt - vec3(0.3, -.2, 2.0), vec2(.3, .1)), 5.0));\n    vec3 pos = transform(pt, vec3(0.0), vec3(radians(iTime*100.), 0.0, 0.0), vec3(1.0));\n    obj = myMin(obj, vec2(crossDist2(pos), 6.0));\n    \n    vec4 color1 = texture (iChannel0, pt.xz/256.0);\n    float avg = (color1.x + color1.y + color1.z) / 3.0;\n    \n    //obj = myMin(obj, vec2(pt.y - (avg*2.0), 4.0));\n    \n    return obj;\n    \n}\n\n\n\n//--Ray Marching------------------------------------------------------------------\n\nvec3 calcNorm( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    scene(pos+eps.xyy, vec3(0.0), 0.0).x - scene(pos-eps.xyy, vec3(0.0), 0.0).x,\n                    scene(pos+eps.yxy, vec3(0.0), 0.0).x - scene(pos-eps.yxy, vec3(0.0), 0.0).x,\n                    scene(pos+eps.yyx, vec3(0.0), 0.0).x - scene(pos-eps.yyx, vec3(0.0), 0.0).x );\n    return normalize(nor);\n}\n\nvec3 findRoot(vec3 ro, vec3 rd) {\n    float dist = 100.0;\n    float i = 0.0;\n    float numObj = 0.0;\n    for (float t = 0.0; t < 5.0; t += .005) {\n        i++;\n        vec2 obj = scene(ro, rd, t);\n        if (obj.x < 0.0) {\n            dist = t;\n            numObj = obj.y;\n            break;\n        }\n    }\n    \n    return vec3(dist, i, numObj);\n    \n}\n\nvec3 sphereTrace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float dt;\n    vec2 objs;\n    float numTraces = 0.0;\n    float numObj = 0.0;\n    for (int i = 0; i < 50; i++) {\n        numTraces++;\n        objs = scene(ro, rd, t);\n        dt = objs.x;\n        numObj = objs.y;\n        t = t + dt;\n        if (dt < 0.0001) {\n            break;\n        }\n    }\n    return vec3(t, numTraces, numObj);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float shadow = 1.0;\n    float t = tmin;\n    float d = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        d = scene(ro, rd, t).x;\n        if (d < 0.0001) return 0.0;\n        shadow = min( shadow, 8.0*d/t );\n        t += d;\n        if( d<0.0001 || t > tmax) break;\n    }\n    return clamp(shadow, 0.0, 1.0);\n    \n}\n\nfloat ambientOcc( in vec3 pt, in vec3 norm )\n{\n    float occ = 0.0;\n    float d = 0.0;\n    for(float k=1.0; k<10.0; k++ )\n    {\n        d = scene(pt, norm, .01*k).x;\n        occ = (1.0 / pow(2.0, k)) * (k*.01 - d);\n    }\n    return clamp(1.0 - 3000.0*occ, 0.0, 1.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    // TODO\n    int debug = 1;\n    bool root;\n    if (SPHERE_TRACE == 1) root = false;\n    else root = true;\n    vec3 col = vec3(.8, .9, 1.0);\n    float t = -1.0;\n    vec3 dist;\n    if (root) {\n        dist = findRoot(ro, rd);\n    }\n    else {\n        dist = sphereTrace(ro, rd);\n    }\n    t = dist.x;\n    if (t < 10.0) {\n        vec3 pt = ro + rd*t;\n        vec3 norm = calcNorm(pt);\n        vec4 diffuse = vec4(1.0);\n        //material\n        if (dist.z == 0.0) {\n            diffuse = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n        if (dist.z == 1.0) {\n            vec4 x = texture( iChannel1, pt.yz );\n            vec4 y = texture( iChannel1, pt.zx );\n            vec4 z = texture( iChannel1, pt.yx );\n            vec3 a = abs(norm);\n            diffuse = (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n            \n        }\n        if (dist.z == 6.0) {\n            vec4 x = texture( iChannel2, pt.yz );\n            vec4 y = texture( iChannel2, pt.zx );\n            vec4 z = texture( iChannel2, pt.yx );\n            vec3 a = abs(norm);\n            diffuse = (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n        }\n        //end material\n        if (dist.z == 2.0) {\n            diffuse = vec4(0.0, 1.0, 0.0, 1.0);\n        }\n        if (dist.z == 3.0) {\n            diffuse = vec4(0.0, 1.0, 1.0, 1.0);\n        }\n        if (dist.z == 5.0) {\n            diffuse = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n        vec3 ref = reflect(rd, norm);\n        vec3 light = normalize(vec3(0.0, 2.0, 2.0) - pt);\n        float lambert = clamp(dot(light, norm), 0.0, 1.0);\n        float amb = ambientOcc(pt, norm);\n        //soft shadows\n        lambert *= softshadow( pt, light, 0.02, 2.5 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        dom *= softshadow( pt, ref, 0.02, 2.5 );\n        \n        float specular = 0.0;\n        if (lambert > 0.0) {\n            vec3 viewDir = normalize(-pt);\n            vec3 halfDir = normalize(light + viewDir);\n            float specAngle = clamp(dot(halfDir, norm), 0.0, 1.0);\n            specular = pow(specAngle, 8.0);\n            \n        }\n        \n        col = vec3(amb*.2) + lambert * vec3(diffuse) + dom * specular * vec3(0.5);\n        \n        //col = pow(col, vec3(1.0/2.2));\n        col *= 1.0 - smoothstep( 20.0, 40.0, t );\n        \n        \n            \n        if (NORMALS == 1) {\n            col = norm;\n        }\n        else if (RAY_STEPS == 1) {\n            if (root) {\n                col = vec3(1.0, 0.0, 0.0)*(dist.y / 1000.0);\n            }\n            else {\n                col = vec3(1.0, 0.0, 0.0)*(dist.y / 50.0);\n            }\n        }\n        else if (DISTANCE == 1) {\n            col = vec3(1.0) * ((5.0 - t) / 5.0);\n        }\n    }\n    return col; //rd;  // camera ray direction debug view\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n    \n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n   \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    float time = 15.0 + iTime;\n    \n    // camera\n    vec3 ro = vec3(\n                   -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n                   1.0 + 2.0 * mo.y,\n                   0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n    \n    // render\n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[555, 555, 582, 710, 733], [735, 735, 770, 770, 798], [800, 800, 833, 833, 924], [926, 926, 961, 961, 1016], [1018, 1018, 1065, 1065, 1107], [1109, 1109, 1139, 1139, 1328], [1330, 1330, 1361, 1361, 1532], [1623, 1623, 1659, 1659, 1686], [1688, 1688, 1732, 1732, 1758], [1760, 1760, 1792, 1792, 2029], [2031, 2031, 2057, 2057, 2193], [2195, 2195, 2258, 2258, 3427], [3429, 3429, 3459, 3459, 3500], [3591, 3591, 3630, 3630, 4845], [4933, 4933, 4963, 4963, 5346], [5348, 5348, 5381, 5381, 5702], [5704, 5704, 5740, 5740, 6097], [6099, 6099, 6173, 6173, 6487], [6489, 6489, 6535, 6535, 6757], [6759, 6759, 6796, 6808, 9550], [9552, 9552, 9602, 9700, 9893], [9895, 9895, 9950, 10048, 10764]], "test": "error"}
{"id": "MtSXWw", "name": "Searching Light", "author": "bbcollinsworth", "description": "Simulation of a hand-carried flashlight in the distance, searching the darkness.", "tags": ["noise", "light"], "likes": 1, "viewed": 129, "published": "Public", "date": "1444058293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// procedural noise from IQ\n\n#define PI 3.14159265359\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n    //setting p mult to 0.0001 seems to get slightly smoother results\n\treturn -1.0 + 2.0*fract(sin(p*0.0001)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    \n    vec2 center = vec2(0.0);\n    \n    float r = distance(uv,center);\n    \n    \n    float fadeToWhite = r;//pow(r,2.0);\n    \n    float fadeToBlack = 1.0-fadeToWhite;\n    fadeToBlack += noise(vec2(uv.x*0.1+sin(iTime),uv.y*0.1+cos(iTime+2.6)));\n\n    \n    vec3 color = vec3(fadeToBlack,fadeToBlack,(pow(fadeToBlack,3.0)*0.7));//smoothstep(0.0,1.0,(pow(fadeToBlack,3.0)*0.7)));//,0.0,1.0));//vec3(fadeToBlack*iChannel0);\n\n    \n    fragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 77, 77, 273], [275, 275, 301, 301, 759], [761, 761, 818, 818, 1342]], "test": "valid"}
{"id": "Xl2SRG", "name": "Sierpinski Carpet 1", "author": "tsone", "description": "Sierpinski carpet configurations.", "tags": ["sierpinski", "carpet"], "likes": 2, "viewed": 1000, "published": "Public API", "date": "1444639325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy;\n    p.x -= 0.5 * (iResolution.x-iResolution.y);\n    p *= 3.0 / iResolution.y;\n    \n    float t = 0.5 * iTime + 4.0;\n    float ti = floor(t);\n    vec2 ct = mod(vec2(ti, ti + 1.0), 9.0);\n    \n    vec2 c = vec2(p.x >= 0.0 && p.x < 3.0);\n    for (int i = 0; i < 5; ++i) {\n    \tvec2 m = floor(p);\n        float j = m.y*3.0 + m.x;\n   \t\tc *= 0.2 + 0.8 * vec2(j != ct[0], j != ct[1]);\n        p = 3.0 * (p-m);\n    }\n\n    float x = smoothstep(0.0, 1.0, t - ti);\n\tfragColor = vec4(vec3(0.1 + 0.9*mix(c[0], c[1], x)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2SRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 597]], "test": "error"}
{"id": "Xl2SRy", "name": "gdp_Flower", "author": "plancien", "description": "simple flower for students", "tags": ["teaching", "gdp"], "likes": 2, "viewed": 109, "published": "Public", "date": "1444645228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n    float zoom = (iResolution.x / 5.0);// * (1.0 + 0.2 * cos(2.0 * iTime));\n    float cameraX = 2.5;  // + 4.0 * cos(iTime);\n    float cameraY = 1.5; // + 4.0 * sin(iTime * 1.1);\n    \n    float x = (pixCoords.x / zoom) - cameraX;\n    float y = (pixCoords.y / zoom) - cameraY;\n\n    float lineSemiWidth = 0.05;\n    \n    if (abs(x) < lineSemiWidth || abs(y)<lineSemiWidth) {\n\t\tcolor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n    if (mod(x, 1.0) < lineSemiWidth || mod(y, 1.0) < lineSemiWidth) {\n\t\tcolor = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n    \n    float angle = atan(y, x);\n    float radius = 1.0 + 0.5 * cos(20.0 * angle + 3.0 * iTime);\n    \n    if (distanceTo(x, y, 0.0, 0.0) < radius) {\n        color = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n  \n    color = vec4(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2SRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 160, 160, 275], [277, 277, 330, 330, 1141]], "test": "valid"}
{"id": "Xl2XDW", "name": "rainbow disk - 2", "author": "FabriceNeyret2", "description": "a variant of https://www.shadertoy.com/view/Xt2XDW", "tags": ["rainbow", "short"], "likes": 6, "viewed": 1211, "published": "Public API", "date": "1443737811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(C=cos(a),S=-sin(a),-S,C)\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    float C,S, t=(iTime-11.)/1e3;\n    o -= o;\n    vec2 R = iResolution.xy, p;\n\tu = 16.3*(u+u-R)/R.y;\n    \n// #define B(k) ceil( (p=cos(u*=rot(t))).x * p.y )  * (.5+.5*cos(k))\n   #define B(k) ceil( (p=cos(u*=rot(t))).x )  * (.5+.5*cos(k))\n    \n    for (float a=0.; a<6.3; a+=.1)\n        o += vec4(B(a),B(a+2.1),B(a-2.1),1) / 31.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2XDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 87, 87, 419]], "test": "valid"}
{"id": "Xl2XDy", "name": "FakeCaustics", "author": "jt", "description": "Fake caustics-like effect by superposition of randomly phased sines.", "tags": ["waves", "caustics", "sumofsines"], "likes": 11, "viewed": 721, "published": "Public", "date": "1446215215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fake Caustics - written 2015 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define pi 3.1415926\nfloat pi = 3.1415926;\nfloat pi2 = 2.0 * 3.1415926;\n\nvec4 rnd(vec2 pos)\n{\n    return texture(iChannel0, pos);\n}\n\nfloat wave(vec2 uv)\n{\n    float m = 0.0;\n    float sum = 0.0;\n    const float n = 4.0;\n    for(float y = 1.0; y <= n; y++)\n    {\n        for(float x = 1.0; x <= n; x++)\n        {\n            //vec4 r = rnd(0.001 * iTime + vec2(x, y) / n);\n            vec4 r = rnd(vec2(x, y) / n);\n            r.z = 2.0 * r.z - 1.0;\n            float a = sin(pi2 * (x * uv.x + r.x + 0.1 * iTime * r.z));\n            float b = sin(pi2 * (y * uv.y + r.y + 0.1 * iTime * r.z));\n            sum += a * b / (x * y);\n            m += 1.0 / (x * y);\n        }\n    }\n    return sum / m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 d = 1.0 / iResolution.xy;\n    vec3 nrm;\n    nrm.x = -wave(uv + vec2(-d.x, 0.0)) - wave(uv + vec2(+d.x, 0.0));\n    nrm.y = -wave(uv + vec2( 0.0,-d.y)) - wave(uv + vec2( 0.0,+d.y));\n    nrm.z = 1.0;\n    nrm = normalize(nrm);\n    \n    vec3 r = refract(vec3(0.0, 0.0, 1.0), nrm, 1.0);\n    fragColor = texture(iChannel1, uv.xy + 0.01 * r.xy);\n    //fragColor = texture(iChannel1, uv.xy);\n    fragColor.rgb += pow(abs(r.z), 100.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2XDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[212, 212, 232, 232, 270], [272, 272, 293, 293, 835], [837, 837, 894, 894, 1378]], "test": "error"}
{"id": "Xl2XzG", "name": "09", "author": "anilord", "description": "09", "tags": ["09"], "likes": 2, "viewed": 80, "published": "Public", "date": "1444643248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n    float zoom = (iResolution.x / 10.0);// * (1.0 + 0.2 * cos(2.0 * iTime));\n    float cameraX = 5.0;  // + 4.0 * cos(iTime);\n    float cameraY = 2.0; // + 4.0 * sin(iTime * 1.1);\n    \n    float x = (pixCoords.x / zoom) - cameraX;\n    float y = (pixCoords.y / zoom) - cameraY;\n\n    float lineSemiWidth = 0.05;\n    \n    if (abs(x) < lineSemiWidth || abs(y)<lineSemiWidth) {\n\t\tcolor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n    if (mod(x, 1.0) < lineSemiWidth || mod(y, 1.0) < lineSemiWidth) {\n\t\tcolor = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n    \n    float PI = 3.1415;\n    float hauteurMoyenne = 0.0;\n    float amplitude = .5;\n    float phase = iTime * 1.5;\n    float periode = 1.0;\n    float fx = hauteurMoyenne + cos(x * 2.0 * PI/ periode + phase) * amplitude;\n    \n    if (y < fx) {\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    float fx2 = 1.0 + cos(2.5 * (x + iTime)) * 0.3;\n    \n    if (y < fx2) {\n        color = vec4(0.6, 0.6, 1.0, 1.0);\n        return;\n    }\n\t\n    /*float radius = 0.3 + 0.2 * rand(vec2(floor(x), floor(y)));// * cos(3.0 * iTime + x + y);\n    radius *= 0.8 + 0.3 * cos(10.0 * rand(vec2(floor(x), floor(y))) * iTime);\n    float distance = distanceTo(mod(x, 1.0), mod(y, 1.0), 0.5, 0.5);\n    if (distance < radius) {\n        color = vec4(cos(20.0 * distance / radius), 0.5, 1.0, 1.0);\n        return;\n    }*/\n    \n    //float light = (cos(y * 3.0 + 6.0 * iTime) + 1.0) * 0.5;\n    //color = vec4(0.8, light, light * (0.5 + 0.5 * cos(x * 30.0)), 1.0);\n    color = vec4(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2XzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 160, 160, 275], [277, 277, 330, 330, 1884]], "test": "valid"}
{"id": "Xl2XzK", "name": "2d experiment #5 - pii", "author": "public_int_i", "description": "lksjflsjdlfj", "tags": ["sfklasdlfklj"], "likes": 4, "viewed": 413, "published": "Public API", "date": "1445271268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int iterations = 12;\nconst float view = 40.;\n//#define CIRCLE\n#define COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= view;\n    \n    for (int i = 0; i < iterations; i++) {\n        float ang = atan(uv.y+cos(uv.x*2.+iTime)*.5,\n                         uv.x+sin(uv.y*2.+iTime)*.5)-length(uv)*.1;\n        float sn = sin(ang);\n        float cs = cos(ang);\n        \n        mat2 m = mat2(sn,cs,-cs,sn);\n        uv = uv*.2-abs(uv*.5*m);\n    }\n    \n    #ifdef CIRCLE\n    float d = length(mod(uv,1.)-.5)-.4;\n    #else\n    float d = length(max(abs(mod(uv,1.)-.5)-vec2(.1,.4), 0.));\n    #endif\n    \n    #ifdef COLOR\n    d += iTime*.05;\n    d *= 50.;\n    fragColor = vec4( sin(d), cos(d+.5346), -sin(d+1.63), 1. )*.5+.5;\n\t#else\n    fragColor = vec4(max(0.,1.-d*100.));\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2XzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 141, 141, 850]], "test": "valid"}
{"id": "XlBXRK", "name": "SmashEffect", "author": "dila", "description": "Textured, raytraced, planes fade out in time with the blocks motion to make it look like dust flying out.", "tags": ["raymarching"], "likes": 32, "viewed": 567, "published": "Public", "date": "1444776503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float t)\n{\n \treturn mat2(cos(t), sin(t), -sin(t), cos(t));   \n}\n\n/* thanks to iq */\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 times()\n{\n    float gt = fract(iTime * 0.5) * 3.0;\n    float a = clamp(gt - 0.0, 0.0, 1.0);\n    float b = clamp(gt - 1.0, 0.0, 1.0);\n    float c = clamp(gt - 2.0, 0.0, 1.0);\n    return vec3(a, b, c);\n}\n\nfloat map(vec3 p)\n{\n    float height = 1.0;\n    float ground = p.y + height;\n    \n    vec3 pt = times();\n    float pound = 1.0 - pow(1.0-pt.y, 2.0) - pow(pt.z, 32.0);\n    pound *= 2.0;\n    \n\tfloat srot = smoothstep(0.0, 1.0, (pt.y+pt.z)*0.5);\n    mat2 mrot = rot(-0.3 + srot * 3.14);\n    \n    vec3 boxoff = vec3(0.0, pound, 0.0);\n    p.xz *= mrot;\n    float box = udRoundBox(p - boxoff, vec3(height)*0.5, height*0.25);\n \treturn min(ground, box);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nfloat rayplane(vec3 o, vec3 r, vec3 p, vec3 n)\n{\n\treturn dot(p - o, n) / dot(r, n);\n}\n\nvec3 _texture(vec3 p)\n{\n\tvec3 ta = texture(iChannel2, p.xz).xyz;\n    vec3 tb = texture(iChannel2, p.yz).xyz;\n    vec3 tc = texture(iChannel2, p.xy).xyz;\n    return (ta*ta + tb*tb + tc*tc) / 3.0;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nvec3 smoke(vec3 o, vec3 r, vec3 f, float t)\n{\n    vec3 tms = times();\n    vec3 sm = vec3(0.0);\n    const int c = 32;\n    float fc = float(c);\n    for (int i = 0; i < c; ++i)\n    {\n        float j = float(i) / fc;\n        float bout = 1.0 + tms.x;\n        vec3 p = vec3(cos(j*6.28), 0.0, sin(j*6.28)) * bout;\n        p.y = -1.0;\n        float pt = rayplane(o, r, p, f);\n        if (pt < 0.0) continue;\n        if (pt > t)  continue;\n        vec3 pp = o + r * pt;\n        float cd = length(pp - p);\n        vec2 uv = (pp - p).xy * 0.1 + vec2(j,j) * 2.0;\n        vec3 tex = texture(iChannel1, uv).xyz;\n        tex *= tex;\n        tex = vec3(tex.x + tex.y + tex.z) / 3.0;\n        vec3 part = tex;\n        part /= 1.0 + cd * cd * 10.0 * tms.x;\n        part *= clamp(abs(t - pt), 0.0, 1.0);\n        part /= 1.0 + pt * pt;\n        part *= clamp(pt, 0.0, 1.0);\n        sm += part;\n    }\n    sm *= 1.0 - smoothstep(0.0, 1.0, tms.x);\n    return sm;\n}\n\nvec3 shade(vec3 o, vec3 r, vec3 f, vec3 w, float t)\n{\n    vec3 tuv = w;\n    if (tuv.y > -0.85)\n    {\n        vec3 pt = times();\n\t\tfloat srot = smoothstep(0.0, 1.0, (pt.y+pt.z)*0.5);\n    \tmat2 mrot = rot(-0.3 + srot * 3.14);\n        tuv.xz *= mrot;\n        float pound = 1.0 - pow(1.0-pt.y, 2.0) - pow(pt.z, 32.0);\n        pound *= 2.0;\n        tuv.y -= pound;\n    }\n    vec3 tex = _texture(tuv * 0.5);\n    vec3 sn = normal(w);\n\tvec3 ground = vec3(1.0, 1.0, 1.0);\n    vec3 sky = vec3(1.0, 0.9, 0.9);\n    vec3 slight = mix(ground, sky, 0.5+0.5*sn.y);\n    float aoc = 0.0;\n    const int aocs = 8;\n    for (int i = 0; i < aocs; ++i) {\n        vec3 p = w - r * float(i) * 0.2;\n        float d = map(p);\n        aoc += d * 0.5;\n    }\n    aoc /= float(aocs);\n    aoc = 1.0 - 1.0 / (1.0 + aoc);\n    float fog = 1.0 / (1.0 + t * t * 0.01);\n    vec3 smk = smoke(o, r, f, t);\n    float fakeocc = 0.5 + 0.5 * pow(1.0 - times().y, 4.0);\n    vec3 fc = slight * tex * aoc + smk * sky;\n    fc = mix(fc * fakeocc, sky, 1.0-fog);\n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 0.8 - dot(uv, uv) * 0.2));\n    vec3 o = vec3(0.0, 0.125, -1.5);\n    vec3 f = vec3(0.0, 0.0, 1.0);\n    \n    vec3 pt = times();\n    \n    float shake = pow(1.0 - pt.x, 4.0);\n    vec3 smack = texture(iChannel0, vec2(pt.x, 0.5)).xyz * 2.0 - 1.0;\n    smack *= shake;\n    \n    o.x += smack.x * shake * 0.25;\n    o.z += smack.y * shake * 0.1;\n    \n    mat2 smackrot = rot(0.3 + smack.z * shake * 0.1);\n    r.xy *= smackrot;\n    f.xy *= smackrot;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    float fd = map(w);\n    \n    vec3 fc = shade(o, r, f, w, t);\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 72], [74, 93, 138, 138, 178], [180, 180, 194, 194, 386], [388, 388, 407, 407, 835], [837, 837, 866, 866, 1016], [1018, 1018, 1066, 1066, 1103], [1105, 1105, 1128, 1128, 1301], [1303, 1303, 1324, 1324, 1525], [1527, 1527, 1572, 1572, 2467], [2469, 2469, 2522, 2522, 3497], [3499, 3499, 3556, 3556, 4302]], "test": "error"}
{"id": "XlBXRt", "name": "Dusty thing", "author": "kuvkar", "description": "Asteroid flying through dust, leaving a burning trail. Mouse to look around. Some optimization needed. ", "tags": ["volumetric", "asteroid"], "likes": 15, "viewed": 434, "published": "Public", "date": "1445798773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n// noise from iq's hell shader\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n}\n\n\nfloat planet(in vec3 rp)\n{\n    rp = rotx(iTime * 6.0) * rp;\n    \n    float rock = 0.02 + texture(iChannel1, rp.xz * 0.13, -100.0).r * 0.1;\n\tfloat L = length(rp) + rock;\n    return L;\n}\n\n\nvec3 planetGrad(in vec3 rp)\n{\n    vec2 off = vec2(0.01, 0.00);\n    vec3 g = vec3(planet(rp + off.xyy) - planet(rp - off.xyy),\n                  planet(rp + off.yxy) - planet(rp - off.yxy),\n                  planet(rp + off.yyx) - planet(rp - off.yyx));\n    return normalize(g);\n}\n\nvoid shadePlanet(in vec3 rp, inout vec4 color)\n{\n    vec3 g = planetGrad(rp);\n    float d = dot(g, vec3(-1.0, 0.0, .0));\n    d = clamp(d, 0.4, 1.0);\n    color += vec4(d * .1);\n    \n    float d2 = dot( normalize(rp), vec3(-1.0, 0.0, 0.0));\n    d2 = clamp(d2, 0., 1.0);\n    d2 = pow(d2, 1.0);\n    color += d2 * 0.5;\n    \n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    float T = iTime * 1.5;\n    float B = .8;\n    vec3 srd = rd;\n    \n    vec4 fog = vec4(0.0);\n    vec3 sampleP = rp;\n    bool doPlanet = false;\n    int steps = 240;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec3 D = vec3(-T, 0.0, 0.0);\n        float f = noise(B * sampleP + D);\n        f += noise( (sampleP + D) * B * 2.0) * 0.5;\n        f += noise( (sampleP + D * 1.0) * B * 4.0) * 0.45;\n        f += noise( (sampleP + D * 2.0) * B * 8.0) * 0.35;\n        f += noise( (sampleP + D * 4.0) * B * 16.0) * 0.25;\n        \n        float R = 1.;\n        float DD = dot(vec3(-1.0, 0.0, 0.0), rp);\n        \n        float morph = (1.5 - sin( DD * .32) * 0.5) * 0.3; // morph sphere to capsule for the fire\n        float LM = length(vec3(-0.7, 0., 0.0) + vec3(.2, morph, morph) * rp);\n        \n        float c = LM - R;\n        vec3 N = -normalize(rp);\n        \n        srd += -min(c * pow(LM, 1.5) * .04, 0.0) * N; //  sampling ray direction change for fire effect\n        srd = normalize(srd);\n        \n        float MINSTEP = 0.03;\n    \tsampleP += srd * max(f * 0.25, MINSTEP);\n        rp += rd * max(f * 0.25, MINSTEP);\n        float asteroidSize = -.45;\n        \n        {\n            float x = max(-f * 0.01, 0.0);\n\t        fog.rgb +=vec3(1.0, .6, .0) * x * 0.7 + (1. - clamp(dot(rd, srd), 0.0, 1.0)) * 0.05;\n            \n            vec3 diff = - rp;\n            vec3 nrm = normalize(diff);\n            \n            float frontBurn = clamp(dot(vec3(1.0, 0.0, 0.0), nrm), -.0, 1.0) * (1.0 / dot(diff, diff) * 0.35);\n            fog.rgb += vec3(1.0) * frontBurn * 0.03;            \n            fog.a += x;\n        }\n    \t\n        float pl = planet(rp);\n        float c2 = pl - R;\n        if(c2 < asteroidSize)\n        {\n          \t  \n            doPlanet = true;\n            break;\n        }\n        \n        if(fog.a >= 1.0)\n        {\n            break;\n        }\n        \n        if(length(ro - rp) > 10.0)\n        {\n            break;\n        }\n    }\n    \n    if(doPlanet)\n    {\n        shadePlanet(rp, color);\n    }\n    \n    color += fog;\n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(f, _tmpr));\n    vec3 r = normalize(cross(u, f));\n    \n    mat3 m;\n    m[0] = r;\n    m[1] = u;\n    m[2] = f;\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = mix(vec4(0.2, 0., 0., 0.0), vec4(0.2, 0.1, 0., 0.), uv.y);\n    uv -= vec2(0.5);\n\tuv.y /= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= vec2(0.5);\n    if(iMouse.xy == vec2(0.0))\n    {\n        m = vec2(-0.2, 0.);\n    }\n    \n    vec3 rp = vec3(m.x * 10.0, m.y * 10.0, -3.0 + sin(iTime * .7));\n    vec3 rd = normalize(vec3(uv, .5));\n    mat3 lat = lookat( rp, vec3(0.0));\n    \n    // cam shake\n    float shake = 0.021;\n    rp += lat[0] * shake * sin(iTime * 80.0);\n    rp += lat[1] * shake * sin(iTime * 80.0);\n    rd = lat * rd;\n    \n    trace(rp, rd, fragColor);\n    \n    // darkening\n    float l = length(uv);\n    fragColor *= smoothstep(0.9, 0.0, l);\n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 147], [148, 148, 168, 168, 295], [296, 296, 316, 316, 443], [445, 476, 502, 502, 719], [722, 722, 748, 748, 906], [909, 909, 938, 938, 1188], [1190, 1190, 1238, 1238, 1510], [1512, 1512, 1566, 1566, 3632], [3635, 3635, 3668, 3668, 3915], [3917, 3917, 3974, 3974, 4725]], "test": "error"}
{"id": "XlBXWG", "name": "phases of acid", "author": "fnord", "description": "wave after wave after wave...", "tags": ["2d", "patterns", "moire", "psychedelic", "acid"], "likes": 20, "viewed": 476, "published": "Public", "date": "1446064853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 xyRot(float n, in vec2 xy)\n\t{\n\t\treturn vec2(xy.x*cos(n)-xy.y*sin(n),\n\t\t\t\t\txy.x*sin(n)+xy.y*cos(n));\n\t}\n\nfloat r(vec2 xy)\n\t{\n\t\tvec2 tmp1 = xyRot(iTime*.02,xy);\n\t\tfloat tmp2 = 70.+10.*(sin(iTime*.1));\n\t\treturn sqrt(pow(sin(tmp1.x*tmp2),2.) +\n\t\t\t\t\tpow(sin(tmp1.y*tmp2),2.));\n\t}\n\nfloat a(float m, float n, float x, float y)\n\t{\n\t\treturn (x+sin(iTime*m))*(y+cos(iTime*n))*sin(iTime*.1+x*y+m+n);\n    }\n\nfloat s(float n, float r)\n\t{\n\t\treturn abs(1.-abs(n-r));\n\t}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n   vec2 xy = coord.xy / iResolution.xy - vec2(0.5,0.5);\n   xy.x *= iResolution.x/iResolution.y;\n   float r_ = r(xy);\n   color.r = s(s(a(xy.x*.2+iTime*.005,xy.y*.21,xy.x,xy.y),r_),xy.x);\n   color.g = s(s(a(xy.x*.23,xy.y*.25+iTime*.005,xy.x,xy.y),r_),xy.y);\n   color.b = s(s(a(xy.x*.27,xy.y*.29,xy.x,xy.y),r_),(xy.x+xy.y)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 107], [109, 109, 128, 128, 279], [281, 281, 327, 327, 399], [401, 401, 429, 429, 459], [461, 461, 508, 508, 835]], "test": "valid"}
{"id": "XlBXWw", "name": "Quasi Infinite Zoom Voronoi ", "author": "Shane", "description": "This was inspired by Fabrice Neyret's \"Infinite Fall\" shader.", "tags": ["voronoi", "zoom", "bump", "infinite"], "likes": 142, "viewed": 6232, "published": "Public API", "date": "1444080008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tQuasi Infinite Zoom Voronoi\n\t---------------------------\n\n\tThe infinite zoom effect has been keeping me amused for years.\n\n\tThis one is based on something I wrote some time ago, but was inspired by Fabrice Neyret's \n\t\"Infinite Fall\" shader. I've aired on the side of caution and called it \"quasi infinite,\" \n\tjust in case it doesn't adhere to his strict infinite zoom standards. :)\n\n\tSeriously though, I put together a couple of overly optimized versions a couple of days ago,\n\tjust for fun, and Fabrice's comments were pretty helpful. I also liked the way he did the \n\tlayer rotation in his \"Infinite Fall\" version, so I'm using that. The rest is stock standard \n\tinfinite zoom stuff that has been around for years.\n\n\tMost people like to use noise for this effect, so I figured I'd do something different\n\tand use Voronoi. I've also bump mapped it, added specular highlights, etc. It was \n\ttempting to add a heap of other things, but I wanted to keep the example relatively simple.\n\n\tBy the way, most of the code is basic bump mapping and lighting. The infinite zoom code \n\ttakes up just a small portion.\n\t\n\n\tFabrice Neyret's versions:\n\n\tinfinite fall - short\n\thttps://www.shadertoy.com/view/ltjXWW\n\n    infinite fall - FabriceNeyret2\n    https://www.shadertoy.com/view/4sl3RX\n\n\tOther examples:\n\n    Fractal Noise - mu6k\n    https://www.shadertoy.com/view/Msf3Wr\n\n    Infinite Sierpinski - gleurop\n    https://www.shadertoy.com/view/MdfGR8\n\n    Infinite Zoom - fizzer\n    https://www.shadertoy.com/view/MlXGW7\n\n\tPrivate link to a textured version of this.\n\tBumped Infinite Zoom Texture - Shane\n\thttps://www.shadertoy.com/view/Xl2XWw\n\n\n*/\n\n\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    //return sin( p*6.2831853 + time )*0.5 + 0.5; \n    \n}\n\n// One of many 2D Voronoi algorithms getting around, but all are based on IQ's \n// original. I got bored and roughly explained it. It was a slow day. :) The\n// explanations will be obvious to many, but not all.\nfloat Voronoi(vec2 p)\n{\t\n    // Partitioning the 2D space into repeat cells.\n    vec2 ip = floor(p); // Analogous to the cell's unique ID.\n    p -= ip; // Fractional reference point within the cell (fract(p)).\n\n    // Set the minimum distance (squared distance, in this case, because it's \n    // faster) to a maximum of 1. Outliers could reach as high as 2 (sqrt(2)^2)\n    // but it's being capped to 1, because it covers a good portion of the range\n    // (basically an inscribed unit circle) and dispenses with the need to \n    // normalize the final result.\n    //\n    // If you're finding that your Voronoi patterns are a little too contrasty,\n    // you could raise \"d\" to something like \"1.5.\" Just remember to divide\n    // the final result by the same amount, clamp, or whatever.\n    float d = 1.;\n    \n    // Put a \"unique\" random point in the cell (using the cell ID above), and it's 8 \n    // neighbors (using their cell IDs), then check for the minimum squared distance \n    // between the current fractional cell point and these random points.\n    for (int i = -1; i <= 1; i++){\n\t    for (int j = -1; j <= 1; j++){\n\t    \n     \t    vec2 cellRef = vec2(i, j); // Base cell reference point.\n            \n            vec2 offset = hash22(ip + cellRef); // 2D offset.\n            \n            // Vector from the point in the cell to the offset point.\n            vec2 r = cellRef + offset - p; \n            float d2 = dot(r, r); // Squared length of the vector above.\n            \n            d = min(d, d2); // If it's less than the previous minimum, store it.\n        }\n    }\n    \n    // In this case, the distance is being returned, but the squared distance\n    // can be used too, if preferred.\n    return sqrt(d); \n}\n\n/*\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi2(vec2 p){\n    \n\tvec2 g = floor(p), o;\n\tp -= g;// p = fract(p);\n\t\n\tvec2 d = vec2(1); // 1.4, etc.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\tfloat h = dot(o, o);\n            d.y = max(d.x, min(d.y, h)); \n            d.x = min(d.x, h);            \n\t\t}\n\t}\n\t\n\t//return sqrt(d.y) - sqrt(d.x);\n    return (d.y - d.x); // etc.\n}\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Variable setup, plus rotation.\n\tfloat t = iTime, s, a, b, e;\n    \n    \n    // Rotation the canvas back and forth.\n    float th = sin(iTime*.1)*sin(iTime*.13)*4.;\n    float cs = cos(th), si = sin(th);\n    uv *= mat2(cs, -si, si, cs);\n    \n\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 ro = vec3(0, 0, -1); // Camera position, ray origin, etc.\n    vec3 rd = normalize(sp-ro); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*.375, sin(iTime)*0.1, -1); // Light position - Back from the screen.\n \n    \n    // The number of layers. More gives you a more continous blend, but is obviously slower.\n    // If you change the layer number, you'll proably have to tweak the \"gFreq\" value.\n    const float L = 8.;\n     // Global layer frequency, or global zoom, if you prefer.\n    const float gFreq = .5;\n    float sum = 0.; // Amplitude sum, of sorts.\n    \n    \n    // Setting up the layer rotation matrix, used to rotate each layer.\n    // Not completely necessary, but it helps mix things up. It's standard practice, but \n    // this one is based on Fabrice's example.\n    th = 3.14159265*.7071/L;\n    cs = cos(th), si = sin(th);\n    mat2 M = mat2(cs, -si, si, cs);\n    \n    \n    // The overall scene color. Initiated to zero.\n    vec3 col = vec3(0);\n    \n    \n    \n    \n    // Setting up the bump mapping variables and initiating them to zero.\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    float f = 0., fx = 0., fy = 0.;\n    vec2 eps = vec2(4./iResolution.y, 0);\n    \n    // I've had to off-center this just a little to avoid an annoying white speck right\n    // in the middle of the canvas. If anyone knows how to get rid of it, I'm all ears. :)\n    vec2 offs = vec2(.1);\n    \n    \n    // Infinite Zoom.\n    //\n    // The first three lines are a little difficult to explain without describing what infinite \n    // zooming is in the first place. A lot of it is analogous to fBm; Sum a bunch of increasing\n    // frequencies with decreasing amplitudes.\n    //\n    // Anyway, the effect is nothing more than a series of layers being expanded from an initial\n    // size to a final size, then being snapped back to its original size to repeat the process \n    // again. However, each layer is doing it at diffent incremental stages in time, which tricks\n    // the brain into believing the process is continuous. If you wish to spoil the illusion, \n    // simply reduce the layer count. If you wish to completely ruin the effect, set it to one.\n\t\n    // Infinite zoom loop.\n\tfor (float i = 0.; i<L; i++){\n\t\n        // Fractional time component -- Obviously, incremented by \"1./L\" and ranging from\n        // zero to one, whilst on a repeat cycle.\n\t\ts = fract((i - t*2.)/L);\n        \n        // Using the fractional time component to determine the layer frequency. It increases\n        // with time, then snaps back to one in a cyclic fashion.\n        // Note that exp2(t) is just another way to write pow(2., t). The latter is more\n        // intuitive, but slower... Well, I assume it is.\n        e = exp2(s*L)*gFreq; // Range (approx): [ 1, pow(2., L)*gFreq ]\n        \n        // Layer ampltude component -- Inversely propotional to the frequency, which makes sense.\n        // Because the layers are finite, you need to smoothly interpolate between them, \n        // and the \"cos\" setup below is just one of many ways to do it.\n        a = (1. - cos(s*6.2831))/e;  // Smooth transition.\n        //a = (1. - abs(s-.5)*2.)/e; // Alternative linear fade. Not as smooth, or accurate.\n        //a = (1. - abs(s-.5)*2.); a *= a*(3.-2.*a)/e; // Smooth linear fade, if so desired.\n        \n        \n        // Accumulating each layer.\n        \n        // I had to have a bit of a think as to how to bump map this. Normally, you'd write a function\n        // then call it three times, but that'd be too expensive, so it's all being done simultaneously.\n        //\n        // Either way, it's still pretty simple. In addition to accumulating the pixel value, accumulate \n        // sample values just to the left of it and above. The X-gradient and Y-gradient can then be \n        // determined outside the loop.\n        //\n        f += Voronoi(M*sp.xy*e + offs)*a; // Sample value multiplied by the amplitude.\n        fx += Voronoi(M*(sp.xy - eps.xy)*e + offs)*a; // Same for the nearby sample in the X-direction.\n        fy += Voronoi(M*(sp.xy - eps.yx)*e + offs)*a; // Same for the nearby sample in the Y-direction.\n        \n        // Sum each amplitude. Used to normalize the results once the loop is complete.\n        sum += a;\n        \n        // Rotating each successive layer is pretty standard, but this is the way Fabrice does\n        // it.\n        M *= M;\n\n\t}\n    \n    // I doubt it'd happen, but just in case sum is zero.\n    sum = max(sum, .001);\n    \n    // Normalizing the three Voronoi samples.\n    f /= sum;\n    fx /= sum;\n    fy /= sum;\n   \n \n    // Common bump mapping stuff.\n    float bumpFactor = .2;\n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    vec3 n = normalize( vec3(0, 0, -1) + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    \n    \n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), .001);\n\tld /= lDist;\n    \n    \n\n    // Light attenuation.    \n    float atten = 1.25/(1. + lDist*0.15 + lDist*lDist*0.15);\n\t//float atten = min(1./(dist*dist*2.), 1.);\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(n, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 16.); \n\n\n\t// Using the infinite Voronoi value to produce a purplish color.\n\tvec3 objCol = vec3(f*f, pow(f, 5.)*.05, f*f*.36);\n    // Blood... ruby red.\n    //vec3 objCol = vec3(f*f, pow(f, 16.), pow(f, 8.)*.5);\n    \n\n    // Using the values above to produce the final color.   \n    col = (objCol*(diff + .5) + vec3(.4, .6, 1)*spec*1.5)*atten;\n\n\n    // Done. \n\tfragColor = vec4(sqrt(min(col, 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1645, 1645, 1666, 2015, 2220], [2222, 2433, 2456, 2509, 4163], [4821, 4821, 4877, 4905, 11561]], "test": "valid"}
{"id": "XlBXzd", "name": "black hole 2", "author": "fantomas", "description": "test", "tags": ["ray"], "likes": 10, "viewed": 1257, "published": "Public API", "date": "1445775811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distfunc (vec3 p)\n{\n    return min( length(p-vec3(-4.,1,-3.))-2.0, 50.-length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float vr=0.5;\n    float cr=15.;\n    \n    vec3 camo = vec3(sin(iTime*vr)*cr,1.,cos(iTime*vr)*cr);\n    vec3 camd = vec3(0,0,0);\n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 dir = normalize(camd-camo);\n    \n    dir = normalize(up*(uv.y-iResolution.y/iResolution.x/2.)+cross(dir,up)*(uv.x-0.5)+(dir));\n    \n    \n    vec3 pos = camo;\n    float dmas;\n    float dmar;\n    float dbh;\n    \n    for (int i=0; i<48; i++)\n    {\n        dbh = length(pos);\n        dmar = min(distfunc(pos),dbh/2.);\n        dir-=pos/dbh/dbh/dbh/8.;\n        dir=normalize(dir);\n        pos += dir*dmar;\n\n    }\n \n    float do1 = length(pos-vec3(-5.,1,-5.))-2.0;\n    float do2 =  50.-length(pos);\n    \n    vec4 col=vec4(0.,0.,0.,0.);\n    if (do1 < do2)\n    {\n        float dam= (float(mod(pos.x,1.)>.5)-0.5)*(float(mod(pos.z,1.)>.5)-0.5)*(float(mod(pos.y,1.)>.5)-0.5);\n        dam = float(dam>0.);\n   \t\tcol=vec4(dam,1.-dam,0.,1.);\n    }\n    else\n    {\n        float dam= (float(mod(pos.x,16.)>8.)-0.5)*(float(mod(pos.z,16.)>8.)-0.5)*(float(mod(pos.y,16.)>8.)-0.5);\n        dam = float(dam>0.);\n        col=vec4(dam,dam,1.-dam,1.);\n    \t\n    }\n\n    float hit = .1/(distfunc(pos)+.1);\n    \n    fragColor = (col)*hit;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 90]], "test": "valid"}
{"id": "XlBXzy", "name": "Swirling Dots", "author": "aimeemarks", "description": "Glowing dots", "tags": ["2d", "sinewaves"], "likes": 11, "viewed": 427, "published": "Public", "date": "1444485004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 col, in vec2 coo)\n{\n\tvec2 uv = (coo - iResolution.xy * 0.5) / iResolution.y;\n    vec3 c = vec3 (0.0);  \n    for(float i = 0.0; i <= 1.0; i += 1.0) {\n        for(float x = -0.8; x <= 0.8; x += 1.6 / 32.0){\n            float v = 0.0025 / length(uv - vec2(x, sin(i * 2.0 + x * 5.0 + iTime)* 0.4)); \n            c += v * vec3 (1.0 - i * 0.5, i -x, i + x * 2.0);\n        }\n    }\n    col = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 423]], "test": "valid"}
{"id": "XljSRd", "name": "endlessFileboxes", "author": "polyomino", "description": "Learning a bit more about raymarching...", "tags": ["raymarching"], "likes": 2, "viewed": 86, "published": "Public", "date": "1445912086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.14159265;\n\n\nvec2 oRoundedBox(vec3 p, vec3 boxRadius, float rounding, float material)\n{\n    boxRadius -= vec3(rounding, rounding, rounding);\n    float d = length(max(abs(p)-boxRadius,0.0)) - rounding;\n    return vec2(d,1);\n}\n\nvec2 oUnion(in vec2 obj0, in vec2 obj1)\n{\n  if (obj0.x < obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n\nvec2 oMindProbe(vec3 p)\n{\n    float rpt = 12.0;\n    p += rpt / 2.0;\n    \n    vec3 k = floor(p / rpt);\n    p = mod(p, rpt) - rpt / 2.0;\n    float sM = 2.0;\n    float sT = 0.3;\n    float sR = 0.4;\n    float cM = 1.8;\n    float cR = 0.3;\n    vec2 p1 = oRoundedBox(p, vec3(sT, sM, sin(k.z) * sM), sR, 1.0);\n    vec2 p2 = oRoundedBox(p, vec3(sin(k.x) * sM, sT, sM), sR, 1.0);\n    vec2 p3 = oRoundedBox(p, vec3(sM, sin(k.y) * sM, sT), sR, 1.0);\n    vec2 p4 = oRoundedBox(p, vec3(cM, cM, cM), cR, 2.0);\n    \n    p1 = oUnion(p1,p2);\n    p1 = oUnion(p1,p3);\n    p1 = oUnion(p1,p4);\n    \n    return p1;\n}\n\n//Floor Color (checkerboard)\nvec3 floor_color(in vec3 p)\n{\n  if (fract(p.x*0.2)>0.2)\n  {\n    if (fract(p.z*0.2)>0.2)\n      return vec3(0,0.1,0.2);\n    else\n      return vec3(1,1,1);\n  }\n  else\n  {\n    if (fract(p.z*.2)>.2)\n      return vec3(1,1,1);\n    else\n      return vec3(0.3,0,0);\n   }\n}\n\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//float rand(float n){return fract(sin(n) * 43758.5453123);}\n//float noise(float p)\n//{\n//  float fl = floor(p);\n//  float fc = fract(p);\n//  return mix(rand(fl), rand(fl + 1.0), fc);\n//}\n\nvec3 rand3(vec3 n)\n{\n  return fract(sin(n) * 43758.5453123);\n}\nvec3 noise3(vec3 p)\n{\n    vec3 pF = floor(p);\n    vec3 pR = fract(p);\n    return mix(rand3(pF), rand3(pF + vec3(1,1,1)), pR);\n}\n\n// Primitive color\nvec3 prim_c(in vec3 p)\n{\n  return noise3(p * 8.3);\n// instead of grey\n//  return vec3(0.6,0.6,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n\n  // Camera up vector.\n  vec3 vuv=vec3(0,1,0); \n  \n  // Camera lookat.\n  vec3 vrp=vec3(0,0,0);\n\n  float mx=iMouse.x/iResolution.x*PI*2.0;\n  float my=iMouse.y/iResolution.y*PI/2.01;\n    float cameraDistance = 15.0;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*cameraDistance; \n  //vec3 prp = vec3(0.0);\n    \n    prp += iTime;\n\n  // Camera setup.\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  // Raymarching.\n  const vec3 e=vec3(0.02,0,0);\n  const float maxd=100.0; //Max depth\n  vec2 d=vec2(0.1,0.0);\n  vec3 c,p,N;\n\n  float f=1.0;\n  for(int i=0;i<64;i++)\n  {\n    if ((abs(d.x) < .001) || (f > maxd)) \n      break;\n    \n    f+=d.x;\n    p=prp+scp*f;\n      d = oMindProbe(p);\n  }\n  \n  if (f < maxd)\n  {\n    // y is used to manage materials.\n    if (d.y==0.0) \n      c=floor_color(p);\n    else\n      c=prim_c(p);\n    \n    vec3 n = vec3(d.x-oMindProbe(p-e.xyy).x,\n                  d.x-oMindProbe(p-e.yxy).x,\n                  d.x-oMindProbe(p-e.yyx).x);\n    N = normalize(n);\n      float lightAngle = iTime;\n      //lightAngle = 2.0;\n\tvec3 L = vec3(sin(lightAngle)*20.0,10,cos(lightAngle)*20.0);\n    float b=dot(N,normalize(prp-p+L));\n    //simple phong lighting, LightPosition = CameraPosition\n    fragColor=vec4((b*c+pow(b,6.0))*(1.0-f*.01),1.0);\n  }\n  else \n    fragColor=vec4(0,0,0,1); //background color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 97, 97, 234], [236, 236, 277, 277, 341], [343, 343, 368, 368, 937], [939, 968, 997, 997, 1231], [1496, 1496, 1516, 1516, 1558], [1559, 1559, 1580, 1580, 1686], [1688, 1707, 1731, 1731, 1808], [1810, 1810, 1867, 1867, 3407]], "test": "valid"}
{"id": "XljSWw", "name": "hsvoronoi", "author": "snolot", "description": "voronoi", "tags": ["voronoi", "hsv"], "likes": 29, "viewed": 460, "published": "Public", "date": "1444168116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash33(vec3 p){     \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\tfloat d = 1.; \n\n    for(float j = -1.; j < 1.01; j++) {\n\t    for(float i = -1.; i < 1.01; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1.);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\nvec3 hsv2rgb (in float h, in float s, in float v) {\n\treturn v * (1.0 + 0.5 * s * (cos (2.0 * 3.1415926535898 * (h + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z+sin(iTime*.25));\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t) * amp; // Add the layer to the total.\n        p *= 2.0; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= 0.5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n\t//uv.y *= iResolution.x/iResolution.y;\n\t\n    float light = smoothstep (-0.7, 0.7, cos (cos(iTime*1.2)));\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\n    float cs = cos(iTime*0.125), si = sin(iTime*0.125);\n\trd.xy *= mat2(cs, -si, si, cs);\n\t\n    float c = noiseLayers(rd*.7);\n\n\tc *= sqrt(c*(1.-length(uv)))+sin(1.-length(uv))*2.;\n\tvec3 col = vec3(c);\n\t\n    vec3 col2 =  hsv2rgb(length(uv) * 0.6 + iTime * .5, 0.9, light);\n\tcol = mix(col, col.xyz*.3+c*.86, (rd.x*rd.y)*.45);\n\tcol *= mix(col, col2, 1.-length(uv));\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 128], [130, 130, 152, 152, 672], [674, 674, 725, 725, 835], [838, 838, 868, 868, 1411], [1413, 1413, 1470, 1470, 2126]], "test": "valid"}
{"id": "XljSzy", "name": "Sea on night", "author": "lenkev", "description": "training wave\n12/10/2015", "tags": ["training"], "likes": 0, "viewed": 530, "published": "Public API", "date": "1444658170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 pixelColor, in vec2 pixelCoord )\n{\n\tfloat zoom = (iResolution.x / 10.0);\n    float cameraX = 5.0;\n    float cameraY = 2.0;\n    \n    float x = (pixelCoord.x / zoom) - cameraX;\n    float y = (pixelCoord.y / zoom) - cameraY;\n    \n    //Background\n    pixelColor = vec4(0.1,0.1,0.3,1.0);\n    //Circle\n    {\n    float centerX = 3.5;\n    float centerY = 2.5;\n    float dX = x - centerX;\n    float dY = y - centerY;\n    float dist = sqrt(dX * dX + dY * dY);\n    float radius = 0.6;\n    float color1 = 0.5 + cos(iTime) * 0.5;\n    if (dist < radius) pixelColor = vec4(0.95,0.95,0.9,1.0);\n    }\n    \n    //Axis\n    /*{\n    float width = 0.02;\n    if ((x < width && x > -width) || (y < width && y > -width)) \n    {    \n        pixelColor = vec4(1.0,0.0,0.0,1.0);\n        return;\n    }\n    if ((mod(x,1.0) < width && mod(x,1.0) > -width) || (mod(y,1.0) < width && mod(y,1.0)> -width))\n    {   \n     pixelColor = vec4(0.5,0.5,0.5,1.0);\n        return;\n    }\n    }*/\n    \n    //Vagues 1\n    {\n    float PI = 3.1415;\n    float hauteurMoyenne = 1.5 + cos(iTime)/2.0;\n    float amplitude = 0.1;\n    float dephasage = iTime;\n    float periode = 1.5;\n    float fx = hauteurMoyenne + cos(x * 2.0 * PI / periode + dephasage) * amplitude;\n    if (y < fx)\n    {\n    \tpixelColor = vec4(0.2,0.3,0.7,1.0);   \n    }\n    }\n    \n    //Vagues 2\n    {float PI = 3.1415;\n    float hauteurMoyenne2 = 0.5 + cos(iTime)/2.0;\n    float amplitude2 = 0.15;\n    float dephasage2 = iTime * -1.5;\n    float periode2 = 1.75;\n    float f2x = hauteurMoyenne2 + cos(x * 2.0 * PI / periode2 + dephasage2) * amplitude2;\n    if (y < f2x)\n    {\n    \tpixelColor = vec4(0.2,0.5,0.9,1.0);   \n    }\n    }\n    \n    //Vagues 3\n    {\n    float PI = 3.1415;\n    float hauteurMoyenne3 = -0.5 + cos(iTime)/2.0;\n    float amplitude3 = 0.19;\n    float dephasage3 = iTime * 3.0;\n    float periode3 = 2.0;\n    float f3x = hauteurMoyenne3 + cos(x * 2.0 * PI / periode3 + dephasage3) * amplitude3;\n    if (y < f3x)\n    {\n    \tpixelColor = vec4(0.2,0.7,1.0,1.0);   \n    }\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 2042]], "test": "valid"}
{"id": "XljXR3", "name": "Gotham City", "author": "dr2", "description": "A city without traffic problems, a short day/night cycle, and a skydeck (mousing encouraged).", "tags": ["raymarching", "cityscape"], "likes": 44, "viewed": 4965, "published": "Public API", "date": "1445431109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gotham City\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Architectural motifs and idea of dda-based raymarching from\n// Octavio Good's \"Skyline\"; with thanks.\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  s = 0.;\n  a = 1.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (10. * a * Noiseff (p));\n    a *= 0.6;\n    p *= 4.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nmat3 vuMat;\nvec3 vuPos, qHit, sunDir;\nvec2 iqBlk, cTimeV;\nfloat dstFar, tCur, scnCount, flyDir, fDayLt, qcCar, cDir;\nint idObj, flyMode;\nconst float flrHt = 0.05;\nconst int idBldgF = 1, idBldgC = 2, idRoad = 3, idSWalk = 4, idCarWhl = 5,\n   idCarBdy = 6, idTrLight = 7, idTwr = 8, idTwrTop = 9;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 dyCol, ntCol, rds;\n  vec2 p;\n  float cloudFac, a, s, sd;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    p = 0.005 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    a = 0.8;\n    s = 0.;\n    for (int j = 0; j < 4; j ++) {\n      s += a * Noisefv2 (p);\n      a *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (2. * s * sqrt (rd.y) - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  sd = max (dot (rd, sunDir), 0.);\n  dyCol = vec3 (0.05, 0.15, 0.3) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3));\n  dyCol = mix (dyCol, vec3 (1.), cloudFac);\n  ntCol = vec3 (0.02, 0.02, 0.04);\n  rds = rd + vec3 (1.);\n  for (int j = 0; j < 10; j ++)\n     rds = 11. * abs (rds) / dot (rds, rds) - 3.;\n  ntCol += vec3 (0.7, 0.6, 0.6) * max (1. - 8. * fDayLt, 0.) *\n     min (1., 1.5e-6 * pow (min (16., length (rds)), 5.));\n  return mix (ntCol, dyCol, fDayLt);\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 ip;\n  float d, bWid, bWidU, bHt, bHtU, bShape, tWid, hiMid, twHt;\n  bool bTall;\n  ip = floor (p.xz);\n  hiMid = dot (ip, ip);\n  bTall = (hiMid == 0.);\n  hiMid = 0.75 * clamp (4. / max (sqrt (hiMid), 1.), 0., 1.);\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = idRoad;  qHit = p;  iqBlk = ip; }\n  q = p;\n  q.xz = fract (q.xz) - vec2 (0.5);\n  bWid = floor ((0.2 + Hashfv2 (11. * ip) * 0.1) / flrHt + 0.5) * flrHt;\n  bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * ip)) / flrHt + 0.5) * flrHt;\n  bHt = (0.5 * Hashfv2 (13. * ip) + 0.05) * hiMid *\n     (1.5 + (bWid - 0.15) / flrHt) + 0.1;\n  bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * ip) - 0.5) * hiMid + 0.05;\n  bHt = (floor (bHt / flrHt) + 0.2) * flrHt;\n  bHtU = floor (bHtU / flrHt) * flrHt;\n  if (bHtU > 0.) bHtU += 0.2 * flrHt;\n  if (bTall) {\n    bHt = max (bHt, 40.2 * flrHt);\n    bHtU = max (bHtU, 20.2 * flrHt);\n  }\n  tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n  bShape = Hashfv2 (17. * ip);\n  q.y -= 0.0015;\n  d = PrOBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  if (d < dMin) { dMin = d;  idObj = idSWalk;  qHit = p; }\n  q.y -= 0.0015;\n  qq = q;\n  qq.xz = abs (qq.xz) - vec2 (0.345);\n  qq.y -= 0.02;\n  d = PrCylDf (qq.xzy, 0.002, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idTrLight;  qHit = qq; }\n  qq = q;\n  qq.y -= bHt - 0.2 * flrHt - 0.001;\n  if (bShape > 0.25) {\n    d = PrOBoxDf (qq, vec3 (bWid, bHt, bWid));\n    if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n  } else {\n    d = PrCylDf (qq.xzy, bWid, bHt);\n    if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n  }\n  qq.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n  if (bHtU > 0.) {\n    if (bShape > 0.5) {\n      d = max (PrOBoxDf (qq, vec3 (bWidU, bHtU, bWidU)),\n         - PrOBoxDf (qq - vec3 (0., bHtU, 0.),\n\t vec3 (tWid, 0.1 * flrHt, tWid)));\n      if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n    } else {\n      d = max (PrCylDf (qq.xzy, bWidU, bHtU),\n\t - PrCylDf ((qq - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    }\n  }\n  if (flyMode > 0) {\n    qq.y -= bHtU - 0.2 * flrHt - 0.001;\n    if (bShape < 0.1) {\n      d = PrCapsDf (qq.xzy, 0.4 * bWidU, 1.25 * flrHt);\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    } else if (bShape > 0.7) {\n      d = PrOBoxDf (qq, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n      if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n    }\n    if (bHt + bHtU > 30. * flrHt) {\n      twHt = 0.1 * (bHt + bHtU);\n      qq.y -= twHt;\n      d = PrCapsDf (qq.xzy, 0.3 * flrHt, twHt);\n      if (d < dMin) {\n\tdMin = d;  qHit = qq;  iqBlk = ip;\n\tidObj = (qq.y > 0.9 * twHt) ? idTwrTop : idTwr;  \n      }\n    }\n    if (bTall) {\n      qq = q;\n      qq.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n      d = PrCylDf (qq.xzy, 0.3, 1.2 * flrHt);\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    }\n  }\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, bf, vDir, cCar;\n  if (cDir == 0. && abs (fract (p.z) - 0.5) > 0.35 ||\n     cDir == 1. && abs (fract (p.x) - 0.5) < 0.35) {\n    p.xz = vec2 (- p.z, p.x);\n    vDir = 0.;\n  } else {\n    vDir = 1.;\n  }\n  q = p;\n  q.y -= -0.003;\n  q.z += 3. * floor (q.x);\n  q.x = fract (q.x) - 0.5;\n  q.z *= sign (q.x);\n  q.z -= cTimeV.x + ((cDir == vDir) ? vDir + cTimeV.y : 1.);\n  cCar = floor (20. * q.z);\n  q.z = fract (q.z) - 0.5;\n  q.x = abs (q.x) - 0.395 - 0.06 * step (0.7, Hashff (11. * cCar)) -\n     0.03 * Hashff (13. * cCar);\n  bf = PrOBoxDf (q + vec3 (0., 0., -0.1), vec3 (0.015, 0.05, 0.2));\n  q.z = mod (q.z, 0.05) - 0.025;\n  d = SmoothMin (PrOBoxDf (q + vec3 (0., -0.008, 0.), vec3 (0.007, 0.002, 0.015)),\n     PrOBoxDf (q + vec3 (0., -0.015, 0.003), vec3 (0.0035, 0.0003, 0.005)), 0.02);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObj = idCarBdy;  qHit = q;  qcCar = cCar; }\n  q.xz = abs (q.xz) - vec2 (0.0085, 0.01);\n  q.y -= 0.006;\n  d = max (PrCylDf (q.yzx, 0.003, 0.0012), bf);\n  if (d < dMin) { dMin = d;  idObj = idCarWhl;  qHit = q; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = CarDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = - sign (rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = ObjDf (p);\n    dHit += min (d, 0.2 + max (0., min (h.x, h.y)));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 30. * h / d);\n    d += 0.3 + 0.02 * d;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec3 col;\n  vec2 g;\n  float wFac, f, ff, spec;\n  wFac = 1.;\n  col = vec3 (0.);\n  spec = 0.;\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col = HsvToRgb (vec3 (0.7 * Hashfv2 (19. * iqBlk), 0.2,\n       0.4 + 0.2 * Hashfv2 (21. * iqBlk)));\n    if (abs (vn.y) < 0.05) {\n      f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n      wFac = 1. - 0.5 * sign (f) * step (abs (abs (f) - 0.24), 0.02) -\n         0.801 * step (abs (f), 0.22);\n      if (wFac < 0.2) {\n        f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n           length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n  \twFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n\t   (1. + Hashfv2 (51. * iqBlk))), 1.);\n      }\n      col *= wFac;\n      spec = 0.3;\n    } else if (vn.y > 0.95) {\n      g = step (0.05, fract (qHit.xz * 70.));\n      col *= mix (0.7, 1., g.x * g.y);\n    }\n    if (wFac > 0.5)\n       col *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  } else if (idObj == idTwr) {\n    col = vec3 (0.3);\n    spec = 0.3;\n  } else if (idObj == idTwrTop) {\n     col = vec3 (1., 0., 0.);\n     spec = -1.;\n  } else if (idObj == idSWalk) {\n    g = step (0.05, fract (qHit.xz * 35.));\n    col = vec3 (0.2) * mix (0.7, 1., g.x * g.y);\n  } else if (idObj == idTrLight) {\n    f = 2. * (atan (qHit.z, qHit.x) / pi + 1.) + 0.5;\n    ff = floor (f);\n    if (abs (qHit.y - 0.014) < 0.004 && abs (f - ff) > 0.3) {\n      col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n         (mod (ff, 2.) == 0.) ? cDir : 1. - cDir);\n      spec = -2.;\n    } else {\n      col = vec3 (0.4, 0.2, 0.1);\n      spec = 0.5;\n    }\n  } else if (idObj == idCarBdy) {\n    col = HsvToRgb (vec3 (Hashff (qcCar * 37.), 0.9,\n       0.4 + 0.6 * vec3 (Hashff (qcCar * 47.))));\n    f = abs (qHit.z + 0.003);\n    wFac = max (max (step (0.001, f - 0.005) * step (0.001, abs (qHit.x) - 0.0055),\n       step (f, 0.001)), step (0.0015, abs (qHit.y - 0.0145)));\n    col *= wFac;\n    spec = 1.;\n    if (abs (qHit.z) > 0.015) {\n      g = vec2 (qHit.x, 3. * (qHit.y - 0.008));\n      if (qHit.z > 0. && dot (g, g) < 3.6e-5) col *= 0.3;\n      g = vec2 (abs (qHit.x) - 0.005, qHit.y - 0.008);\n      f = dot (g, g);\n      if (qHit.z > 0. && f < 2.2e-6) {\n\tcol = vec3 (1., 1., 0.3);\n\tspec = -2.;\n      } else if (qHit.z < 0. && f < 1.1e-6) {\n\tcol = vec3 (1., 0., 0.);\n\tspec = -2.;\n      }\n    }\n  } else if (idObj == idCarWhl) {\n    if (length (qHit.yz) < 0.0015) {\n      col = vec3 (0.7);\n      spec = 0.8;\n    } else {\n      col = vec3 (0.03);\n    } \n  } else if (idObj == idRoad) {\n    g = abs (fract (qHit.xz) - 0.5);\n    if (g.x < g.y) g = g.yx;\n    col = mix (vec3 (0.05), vec3 (0.08), step (g.x, 0.355));\n    f = (step (abs (g.x - 0.495), 0.0015) + step (abs (g.x - 0.365), 0.0015)) *\n       step (g.y, 0.29);\n    col = mix (col, vec3 (1., 0.8, 0.3), f);\n    f = step (abs (g.x - 0.44), 0.0015) * step (g.y, 0.29) *\n       step (fract (g.y * 18. + 0.25), 0.7) +\n       step (0.6, fract (g.x * 30. + 0.25)) * step (0.36, g.x) *\n       step (abs (g.y - 0.32), 0.02);\n    col = mix (col, vec3 (0.8), f);\n  }\n  if (wFac < 0.5) {\n    rd = reflect (rd, vn);\n    g = Rot2D (rd.xz, 5.1 * atan (20. + iqBlk.y, 20. +  iqBlk.x));\n    col = 0.8 * (0.2 + 0.8 * (step (1., ro.y + 5. * rd.y -\n       0.2 * floor (5. * IFbm1 (0.3 * atan (g.y, g.x) + pi) + 0.05)))) *\n       SkyCol (ro, rd);\n    spec = -1.;\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, sCol, vn;\n  float dstHit, sh, f, s, fHaze, spec;\n  int idObjT;\n  sCol = SkyCol (ro, rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit == dstFar) idObj = -1;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = ObjCol (ro, rd, vn);\n    col = col4.rgb;\n    spec = col4.a;\n    if (spec >= 0.) {\n      if (idObj == idRoad) vn = VaryNf (500. * qHit, vn, 2.);\n      else if (idObj == idBldgF || idObj == idBldgC)\n         vn = VaryNf (500. * qHit, vn, 0.5);\n      sh = mix (1., 0.2 + 0.8 * ObjSShadow (ro, sunDir), fDayLt);\n      col = col * (0.1 + 0.1 * max (vn.y, 0.) * sh +\n         0.8 * fDayLt * sh * max (dot (vn, sunDir), 0.)) +\n\t fDayLt * sh * spec * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    }\n    if (spec == -1.) {\n      if (idObj == idBldgF || idObj == idBldgC) {\n        s = Hashfv2 (37. * iqBlk);\n        f = step (fDayLt, 0.2 + 0.3 * Hashfv2 (47. * iqBlk));\n        col = mix (0.2 * col, vec3 (0.8 + 0.2 * s, 0.75 - 0.4 * s, 0.), f);\n      } else if (idObj == idCarBdy) col = mix (vec3 (0.1, 0.05, 0.), col, fDayLt);\n      else if (idObj == idTwrTop) col *= 1. - 0.8 * fDayLt;\n    }\n    if (spec >= 0.) col *= 0.1 + 0.9 * fDayLt;\n    fHaze = (flyMode > 0) ? clamp (8. * (dstHit / dstFar - 0.8), 0., 1.) :\n       clamp (4. * (dstHit / dstFar - 0.2), 0., 1.);\n    col = mix (col, sCol, fHaze * fHaze);\n  } else col = sCol;\n  return pow (clamp (col, 0., 1.), vec3 (0.4));\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float ti[5], tLin, tCyc, pLen;\n  tLin = 1.;\n  tCyc = 4. * tLin;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tLin;\n  ti[2] = ti[1] + tLin;\n  ti[3] = ti[2] + tLin;\n  ti[4] = ti[3] + tLin;\n  pLen = 4.;\n  p = vec3 (0.);\n  p.y = 0.3 + 2.5 * SmoothBump (0.3, 0.8, 0.07, mod (0.11 * t, 1.));\n  t = mod (t + scnCount * tLin, tCyc);\n  if (t < ti[1]) {\n    p.x = pLen;\n    p.z = - pLen + 2. * pLen * (t - ti[0]) / (ti[1] - ti[0]);\n  } else if (t < ti[2]) {\n    p.x =   pLen - 2. * pLen * (t - ti[1]) / (ti[2] - ti[1]);\n    p.z = pLen;\n  } else if (t < ti[3]) {\n    p.x = - pLen;\n    p.z =   pLen - 2. * pLen * (t - ti[2]) / (ti[3] - ti[2]);\n  } else if (t < ti[4]) {\n    p.x = - pLen + 2. * pLen * (t - ti[3]) / (ti[4] - ti[3]);\n    p.z = - pLen;\n  }\n  p.x *= flyDir;\n  p.x += (scnCount - 3.) * pLen;\n  return p;\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel;\n  float a, ca, sa, dt;\n  dt = 0.05;\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.y = fpB.y;\n  vel = (fpF - fpB) / (2. * dt);\n  a = atan (vel.z, vel.x) - 0.5 * pi;\n  ca = cos (a);  sa = sin (a);\n  vuMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, tScene, cTime, cTimeI, t, tRep, sunAz, sunEl, asp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tRep = 40.;\n  scnCount = floor (tCur / (3. * tRep));\n  tScene = tCur - 3. * tRep * scnCount;\n  scnCount = mod (scnCount, 10.);\n  if (tScene < tRep) flyMode = 0;\n  else if (tScene < 2. * tRep) flyMode = 1;\n  else flyMode = 2;\n  flyDir = sign (mod (tCur, 6. * tRep) - 3. * tRep);\n  t = mod (0.013 * tCur + 0.2, 1.);\n  fDayLt = SmoothBump (0.2, 0.8, 0.05, t);\n  sunAz = 0.8 * pi * (2. * t - 1.);\n  sunEl = 0.97 * (1. - 0.7 * sin (abs (0.5 * sunAz)));\n  sunDir = vec3 (0., 0., - 1.);\n  sunDir.xz = Rot2D (sunDir.xz, sunAz);\n  sunDir.yz = Rot2D (sunDir.yz, sunEl);\n  cTime = 0.15 * tScene;\n  cTimeI = floor (cTime);\n  cDir = mod (cTimeI, 2.);\n  cTimeV = vec2 (floor (0.5 * cTimeI), cTime - cTimeI);\n  if (flyMode == 0) dstFar = 50.;\n  else dstFar = 70.;\n  if (flyMode == 0) {\n    az = 0.;\n    el = -0.05;\n    zmFac = 4.8;\n    if (mPtr.z > 0.) {\n      az -= 2. * pi * mPtr.x;\n      el = clamp (el - mPtr.y, -1.4, 0.3);\n    }\n  } else if (flyMode == 1) {\n    az = 0.;\n    el = 0.;\n    zmFac = 2.2;\n    if (mPtr.z > 0.) zmFac = clamp (zmFac + 3. * mPtr.y, 0.7, 4.);\n  } else if (flyMode == 2) {\n    az = 0.033 * tCur * flyDir;\n    t = SmoothBump (0.3, 0.8, 0.2, mod (0.025 * tCur, 1.));\n    el = 0.1 + 0.8 * t;\n    zmFac = 3.6 + 11. * t;\n  }\n  if (flyMode == 0) {\n    ro = vec3 (-0.03, 0.1, scnCount + cTimeV.x + ((cDir == 1.) ? cTimeV.y : 0.));\n  } else if (flyMode == 1) {\n    VuPM (0.1 * tCur);\n    ro = vuPos;\n  } else if (flyMode == 2) {\n    ori = vec2 (el, az);\n    ca = cos (ori);  sa = sin (ori);\n    vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n       mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n    ro = vec3 (0., 1., -25.) * vuMat;\n    if (mPtr.z > 0.) {\n      az -= 0.5 * pi * mPtr.x;\n      el = clamp (el - 2. * mPtr.y, -0.1, 1.5);\n    }\n  }\n  if (flyMode == 0 || flyMode == 2) {\n    ori = vec2 (el, az);\n    ca = cos (ori);  sa = sin (ori);\n    vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n       mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  }\n  rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  col = ShowScene (ro, rd);\n  asp = canvas.y / canvas.x;\n  t = step (50. * abs (mod (tCur / tRep + 0.5, 1.) - 0.5),\n     max (abs (uv.x * asp), abs (uv.y)) / max (asp, 1.));\n  col = mix (col, vec3 (0.1, 0.1, 0.2), t);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[372, 372, 396, 396, 433], [435, 435, 459, 459, 514], [516, 516, 540, 540, 590], [592, 592, 616, 616, 663], [665, 665, 690, 690, 836], [838, 838, 863, 863, 1062], [1064, 1064, 1087, 1087, 1245], [1247, 1247, 1276, 1276, 1488], [1490, 1490, 1529, 1529, 1746], [1748, 1748, 1781, 1781, 1824], [1826, 1826, 1868, 1868, 1919], [1921, 1921, 1964, 1964, 2037], [2039, 2039, 2084, 2084, 2182], [2184, 2184, 2241, 2241, 2324], [2326, 2326, 2356, 2356, 2430], [2432, 2432, 2456, 2456, 2587], [2885, 2885, 2917, 2917, 3807], [3809, 3809, 3844, 3844, 6856], [6858, 6858, 6892, 6892, 7981], [7983, 7983, 8005, 8005, 8106], [8108, 8108, 8141, 8141, 8497], [8499, 8499, 8520, 8520, 8736], [8738, 8738, 8775, 8775, 8991], [8993, 8993, 9034, 9034, 12412], [12414, 12414, 12449, 12449, 13946], [13948, 13948, 13974, 13974, 14779], [14781, 14781, 14802, 14802, 15123], [15125, 15125, 15181, 15181, 17787]], "test": "error"}
{"id": "XljXzd", "name": "Shadow Blob Blend", "author": "Donzanoid", "description": "Min-blending for shadow blobs with discontinuity", "tags": ["shadowblend"], "likes": 4, "viewed": 934, "published": "Public API", "date": "1445952927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat Blob(vec2 pos, vec2 uv, float r)\n{\n    return max(length(pos - uv) - r, 0.0);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Mix(float a, float b)\n{\n    // Smoothly blends but darkens with each blend\n    //return a * b;\n    \n    // Distance field union\n    // Maintains correct intensity regardless of blend count\n    // Blends with visual discontinuity\n    // My intuition is telling me I shouldn't see the discontinuity!\n    return min(a, b);\n    \n    // Smooth min\n    //return smin(a, b, 0.07);\n    \n    // Looks good but variable under number of blends\n    // Effectively \"steals\" detail from previous blends\n    //return sqrt(a * b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float i = 1.0;\n    i = Mix(i, Blob(vec2(0.25, 0.5), uv, 0.1));\n    i = Mix(i, Blob(vec2(0.75, 0.5), uv, 0.1));\n    i = Mix(i, Blob(vec2(0.5, 0.25), uv, 0.1));\n    i = Mix(i, Blob(vec2(0.5, 0.75), uv, 0.1));\n    \n    i = Mix(i, Blob(vec2(fract(iTime*0.25), 0.25), uv, 0.15));\n    \n    // Better contrast\n    i = pow(i, 0.5);\n    \n    // Highlight discontinuities\n    //i = abs(dFdx(i)*100.0)+abs(dFdy(i)*100.0);\n    \n    fragColor = vec4(i, i, i, i);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 42, 42, 87], [89, 89, 128, 128, 231], [233, 233, 262, 536, 755], [757, 757, 814, 814, 1317]], "test": "valid"}
{"id": "XljXzt", "name": "TazonCircles", "author": "fernandoanton", "description": "Circulos para tazon", "tags": ["circles", "tazon"], "likes": 1, "viewed": 959, "published": "Public API", "date": "1445897320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIO 0.4\n#define RADIO_2 0.16\n\n#define CENTER_X 0.3\n#define CENTER_Y 0.2\n\n#define COLOR_R 1.0\n#define COLOR_G 0.5\n#define COLOR_B 0.5\n\n#define SPEED 0.4\n#define MOVE_RADIO 0.3\n\n#define SPEED_2 0.6\n#define MOVE_RADIO_2 0.6\n\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat CenterX = CENTER_X + MOVE_RADIO*cos(SPEED*PI*iTime) + MOVE_RADIO_2*sin(SPEED_2*PI*iTime);\n\tfloat CenterY = CENTER_Y + MOVE_RADIO*sin(SPEED*PI*iTime) + MOVE_RADIO_2*cos(SPEED_2*PI*iTime);\n\tvec3 Color = vec3(0);\n\t// Convertimos las coordenadas del pixel X,Y con el que estamos trabajando (fragCoord)\n\t// R valdra un valor entre (-iResolution.X/2 .. +iResolution.X/2 , -iResolution.Y/2 .. +iResolution.Y/2)\n\t// Es una sentencia vectorial - R es un vector bidimensional y la operacion trabaja sobre las dos componentes\n\t// La sintaxis es igual que la de R o la de Matlab\n\tvec2 R = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// Ahora normalizamos R\n\t// R valdra un valor entre (-AspectRatio .. +AspectRatio , -1 .. +1)\n\t// Donde AspectRatio es iResolution.X / iResolution.Y - es decir, ajustamos por la pantalla que no es cuadrada\n\tR = 2.0 * R.xy / iResolution.y;\n\t// Procesamos el pixel. Se trata de saber si esta o no dentro de la circunferencia\n\tfloat DistanceX2 = (R.x - CenterX) * (R.x - CenterX);\n\tfloat DistanceY2 = (R.y - CenterY) * (R.y - CenterY);\n\tfloat Distance2 = DistanceX2+DistanceY2;\n\tif (Distance2<RADIO_2) Color=vec3(COLOR_R,COLOR_G,COLOR_B);\n\tfragColor=vec4(Color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 344, 344, 1538]], "test": "valid"}
{"id": "XlSSDG", "name": "First shader mGGk", "author": "mGGk", "description": "first shader", "tags": ["fractal"], "likes": 4, "viewed": 151, "published": "Public", "date": "1446065185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iterations=22;\nconst float speedCoef = .9;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //zVector\n\tvec2 z = fragCoord.xy / iResolution.xy*1.5;\n\tz.y*=iResolution.y/iResolution.x;\n    //Gestion rotation\n\tz=vec2(z.x*cos(iTime*speedCoef)-z.y*sin(iTime*speedCoef),z.y*cos(iTime*speedCoef)+z.x*sin(iTime*speedCoef));\n    //Synchro musique\n    z/= 1.2 + sin(iChannelTime[0]*.99);\n    //DÃ©placement camÃ©ra\n    z+=vec2(sin(iChannelTime[0]*.5),cos(iChannelTime[0]*.5));\n    //cVector\n\tvec2 c=vec2(0.1, .1);\n\tfloat average=0.;\n\tfloat l=length(z);\n\tfloat prevl;\n    //iterationZ\n\tfor (int i=0; i<iterations; i++) \n\t{\t\n\t\tz=abs(z)/dot(z,z) -c; \n\t\tprevl=l;\n\t\tl=length(z);\n\t\taverage+=abs(l-prevl);\n\t}\n    //Occurences itÃ©rations\n\taverage/=float(iterations) * 666.;\n\t//DÃ©finition couleurs\n    vec3 colorsDef=vec3(0.5,0.1,.62);\n\tvec3 finalColor;\t\n    //Affection couleurs\n\tfinalColor.r = (fract(float(average)/colorsDef.r));\n\tfinalColor.g = (fract(float(average)/colorsDef.g));\n\tfinalColor.b = (fract(float(average)/colorsDef.b));\n\t\n\tfragColor = vec4(finalColor,1.0);\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 124, 1090]], "test": "error"}
{"id": "XlSSRd", "name": "March of the Androids", "author": "dr2", "description": "Beware!", "tags": ["raymarching", "robots"], "likes": 7, "viewed": 713, "published": "Public API", "date": "1445708367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"March of the Androids\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// With ideas from simesgreen (4dfGz8) and iapafoto (MsB3zK)\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\nvec3 sunDir, qHit;\nfloat tCur, rAngH, rAngL, rAngA, gDisp;\nint idObj;\nbool walk;\nfloat dstFar = 150.;\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    col = mix (vec3 (0.6, 0.5, 0.3),\n       0.9 * (vec3 (0.1, 0.2, 0.4) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  hGap = 2.5;\n  bf = PrBoxDf (p, vec3 (7. * hGap, 6., 7. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  bFac = (ip.x == 0. && ip.y == 0.) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFar;\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y); // head\n  q = pp;\n  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7)); // trunk\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q.y -= 1.9;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.))); // ant\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6)); // arm\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55)); // leg\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObj = 2; }  // eye\n  d = p.y + 1.;\n  if (d < dMin) { dMin = d;  idObj = 0;  qHit = p; }  // ground\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.02, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFar;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  if (idObj == 1) col = vec3 (0.65, 0.8, 0.2);\n  else if (idObj == 2) col = vec3 (0.8, 0.8, 0.);\n  else col = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.6, 0.5, 0.4),\n     (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  return col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n     0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 15; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 10. * h / d);\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb;\n  bool rotStep;\n  rPath = 28.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 + (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, tCyc, refl, spd;\n  int idObjT;\n  spd = 0.7;\n  tCyc = mod (spd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (spd * tCur, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    col = ObjCol (rd, vn, dstHit);\n    idObj = idObjT;\n    if (idObj > 0) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRay (ro, rd);\n      if (dstHit < dstFar) {\n        ro += rd * dstHit;\n\tc = ObjCol (rd, ObjNf (ro), dstHit);\n      } else {\n        c = BgCol (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= (0.8 + 0.2 * ObjSShadow (ro, sunDir));\n  } else {\n    col = BgCol (ro, rd);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec2 canvas, uv;\n  vec3 ro, rd, vd, u;\n  float f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  ro = TrackPath (tCur);\n  vd = normalize (vec3 (0., 2., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  sunDir = normalize (vec3 (1., 2., 1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSSRd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[338, 338, 362, 362, 409], [411, 411, 436, 436, 635], [637, 637, 658, 658, 797], [901, 901, 931, 931, 1005], [1007, 1007, 1039, 1039, 1134], [1136, 1136, 1169, 1169, 1196], [1198, 1198, 1252, 1252, 1441], [1443, 1443, 1474, 1474, 2009], [2011, 2011, 2033, 2033, 3443], [3445, 3445, 3478, 3478, 3654], [3656, 3656, 3677, 3677, 3885], [3887, 3887, 3922, 3922, 4249], [4251, 4251, 4295, 4295, 4636], [4638, 4638, 4675, 4675, 4886], [4888, 4888, 4914, 4914, 5655], [5657, 5657, 5692, 5692, 6822], [6824, 6824, 6880, 6880, 7395]], "test": "error"}
{"id": "XlSSWW", "name": "Pink Bubblegum", "author": "airtight", "description": "simple ashima noise uv gradient camo", "tags": ["noise", "simple", "ashima"], "likes": 9, "viewed": 392, "published": "Public", "date": "1444685590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//START ASHIMA NOISE\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//END ASHIMA NOISE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t= iTime * 0.3;\n    \n    vec3 col = vec3(1,uv); //pink->orange\n    \n    //layer 1\n    float SCALE = 2.0;\n    float noise = snoise( vec3(uv*SCALE , t));\n    float b = smoothstep(0.2,0.25,noise);\n    col += vec3(uv,1)*b; //blue->pink\n \n    fragColor = vec4(col,1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSSWW.jpg", "access": "shaders20k", "license": "mit", "functions": [[416, 416, 437, 437, 486], [488, 488, 509, 509, 558], [560, 560, 582, 582, 622], [624, 624, 652, 652, 704], [706, 706, 730, 730, 2876], [2898, 2898, 2955, 2955, 3277]], "test": "valid"}
{"id": "XlSSzV", "name": "Another Cloudy Tunnel 2", "author": "aiekick", "description": "Variation more cloudy of my https://www.shadertoy.com/view/4lSXRK\nyou can modify cloudy precision with mouse y axis", "tags": ["3d", "raymarching", "tunnel", "cloud", "cloudy"], "likes": 29, "viewed": 1689, "published": "Public API", "date": "1444826936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* \n\tvariation more cloudy off Another Cloudy Tunnel : \n\t\thttps://www.shadertoy.com/view/4lSXRK\n\n\tthe cloudy famous tech come from the shader of duke : https://www.shadertoy.com/view/MljXDw\n        Himself a Port of a demo by Las => http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n*/\n\nfloat t;\n\nfloat cosPath(vec3 p, vec3 dec){return dec.x * cos(p.z * dec.y + dec.z);}\nfloat sinPath(vec3 p, vec3 dec){return dec.x * sin(p.z * dec.y + dec.z);}\n\nvec2 getCylinder(vec3 p, vec2 pos, float r, vec3 c, vec3 s)\n{\n\treturn p.xy - pos - vec2(cosPath(p, c), sinPath(p, s));\n}\n\n/////////////////////////\n// FROM Shader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p) \n{\n    p += t*5.;\n\treturn pn(p*0.02)*1.98 + pn(p*0.02)*0.62 + pn(p*0.09)*0.39;\n}\n/////////////////////////\n\nfloat map(vec3 p)\n{\n\tfloat pnNoise = fpn(p*13.)*.8;\n\tfloat path = sinPath(p ,vec3(6.2, .33, 0.));\n\tfloat bottom = p.y + pnNoise;\n\tfloat cyl = 0.;vec2 vecOld;\n\tfor (float i=0.;i<6.;i++)\n\t{\n\t\tfloat x = 1. * i;\n\t\tfloat y\t= .88 + 0.0102*i;\n\t\tfloat z\t = -0.02 -0.16*i;\n\t\tfloat r = 4.4 + 2.45 * i;\n\t\tvec2 vec = getCylinder(p, vec2(path, 3.7 * i), r , vec3(x,y,z), vec3(z,x,y));\n\t\tcyl = r - min(length(vec), length(vecOld));\n\t\tvecOld = vec;\t\n\t}\n\tcyl += pnNoise;\n\tcyl = min(cyl, bottom);\n\treturn cyl;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n\tfloat fov = 3.;\n    vec3 rd = normalize(rov + fov*u*uv.x + fov*v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    t = iTime*2.5;\n\tf = vec4(0,0.15,0.32,1);\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n    vec3 ro = vec3(0), p=ro;\n\tro.y = sin(t*.2)*15.+15.;\n\tro.x = sin(t*.5)*5.;\n\tro.z = t*5.;\n\tvec3 rd = cam(uv, p, vec3(0,1,0), p + vec3(0,0,1));\n\tfloat s = 1., h = .15, td = 0., d=1.,dd=0., w;\n    float var = 0.03;\n    if (iMouse.z>0.) var = 0.1*iMouse.y/iResolution.y;\n    for(float i=0.;i<200.;i++)\n\t{      \n\t\tif(s<0.01||d>500.||td>.95) break;\n        s = map(p) * (s>0.001?var:.2);\n\t\tif (s < h)\n\t\t{\n\t\t\tw = (1.-td) * (h-s)*i/200.;\n\t\t\tf += w;\n\t\t\ttd += w;\n\t\t}\n\t\tdd += 0.012;\n\t\ttd += 0.005;\n\t\ts = max(s, 0.05);\n\t\td+=s;\t\n\t\tp = ro+rd*d;\t\n   \t}\n\tf.rgb = mix( f.rgb, vec3(0,0.15,0.52), 1.0 - exp( -0.001*d*d) )/dd; // fog\n\t\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n    vec2 q = g/si;\n    f.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSSzV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[501, 501, 533, 533, 574], [575, 575, 607, 607, 648], [650, 650, 711, 711, 770], [772, 880, 903, 903, 1120], [1122, 1122, 1142, 1142, 1220], [1248, 1248, 1267, 1267, 1742], [1744, 1744, 1790, 1790, 1991], [1993, 1993, 2034, 2034, 2928]], "test": "error"}
{"id": "Xt2SDG", "name": "Nine Circles", "author": "soma_arc", "description": "It is constructed by inversion of circles.\nSee also https://www.shadertoy.com/view/4lBSDR.", "tags": ["2d", "fractal"], "likes": 1, "viewed": 142, "published": "Public", "date": "1446178790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc, Kazushi Ahara - 2015\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst vec2 c1Pos = vec2(1, 1);\nconst vec2 c2Pos = vec2(-1, 1);\nconst vec2 c3Pos = vec2(1, -1);\nconst vec2 c4Pos = vec2(-1, -1);\nconst vec2 c5Pos = vec2(0, 2.73205080757);//2 * sqrt(3) + 1;\nconst vec2 c6Pos = vec2(0, -2.73205080757);\nconst vec2 c7Pos = vec2(2.73205080757, 0.);\nconst vec2 c8Pos = vec2(-2.73205080757, 0.);\nconst vec2 c9Pos = vec2(0, 0);\nconst float r = 1.;\nconst float c9R = 0.4142;//2 * sqrt(2) - 2\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 50;\nfloat IIS(vec2 pos){\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(distance(pos,c1Pos) < r){\n\t\t\tpos = circleInverse(pos, c1Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c2Pos) < r){\n\t\t\tpos = circleInverse(pos, c2Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c3Pos) < r){\n\t\t\tpos = circleInverse(pos, c3Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c4Pos) < r){\n\t\t\tpos = circleInverse(pos, c4Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c5Pos) < r){\n\t\t\tpos = circleInverse(pos, c5Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c6Pos) < r){\n\t\t\tpos = circleInverse(pos, c6Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c7Pos) < r){\n\t\t\tpos = circleInverse(pos, c7Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c8Pos) < r){\n\t\t\tpos = circleInverse(pos, c8Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c9Pos) < c9R){\n\t\t\tpos = circleInverse(pos, c9Pos, c9R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 5.3;\n\n        float loopNum = IIS(position);\n\n        if(loopNum > 0.){\n            sum += hsv2rgb(vec3(iTime/1.5 + 0.04 * loopNum,1.0,1.0));\n        }else{\n            sum += vec3(0.,0.,0.);\n        }\n    }\n    fragColor = vec4(sum/SAMPLE_NUM, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2SDG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[145, 234, 275, 275, 564], [983, 983, 1043, 1043, 1159], [1188, 1188, 1208, 1208, 2403], [2405, 2405, 2427, 2427, 2596], [2629, 2629, 2685, 2685, 3189]], "test": "valid"}
{"id": "Xt2SRG", "name": "dream cavern", "author": "gtoledo3", "description": "Dream cavern derived from julia fractal.", "tags": ["fractal", "julia", "cavern", "hills"], "likes": 7, "viewed": 1107, "published": "Public API", "date": "1444618549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float depthCull=.1;\nconst float zoom=3.5;\nconst float bailout=10.;\nconst vec2 offset=vec2(.3,.45);\nconst int iterations=9;\n\n//\"dream cavern\", by George Toledo. 2015.\n\nvec3 hsv(const in float h, const in float s, const in float v) {\n\treturn mix(vec3(1.0),clamp((abs(fract(h+vec3(3.,2.,1.)/3.0)*6.-3.)-1.),0.,1.0),s)*v;\n}\n\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details, located in ZIP file here:\n// http://webstaff.itn.liu.se/~stegu/GLSL-cellular/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nvec2 cmult(vec2 a, vec2 b)\n{\n\tvec2 p;\n\tp[0]=a[0]*b[0]-a[1]*b[1];\n\tp[1]=a[0]*b[1]+a[1]*b[0];\n\treturn p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime;\n    \n    vec2 offset=vec2(offset.x+sin(time*.1)*.05,offset.y+cos(time*.1)*.05);\n\tvec2 position = gl_FragCoord.xy/iResolution.xy - offset;\n\t\n\tposition = position * (zoom-.7);\n\n\tvec2 perturb=vec2(-.7+(sin(time*.11)*.1)+(sin(time*.2)*.4),0.45+cos(time*.03)*.05)+(sin(time*.12)*.3);\n\tvec2 c, c0, d;\n\tfloat v;\n\t\n\tc = vec2(position);\n\tc0 = perturb;\n\tc +=(cellular( c*4.))*.025;\n\tvec2 f = position.xy;\n\tfor(int i=0; i<iterations; i++) {\n\t\td = cmult(c, c);\n\t\tc = d + c0;\n\t\tv = abs((c.x*c.x) + sin(.1*time+c.y*c.y)) / sqrt(.1*time+c.x*c.x );\n\t\t\t\n\t\t\t\n\n\t\tif (v > bailout) break;\n\t}\n\tvec2 c1=c+cellular( .1*time+c*3.);\n\tvec2 c2=cellular(-.1*vec2(sin(.4*time + c.y*.2),sin(.02*time + c.x*.5)));\n\tvec2 c3=cellular( c*.01);\n\n\t\n\tfloat rand = mod(fract(sin(dot(2.5*gl_FragCoord.xy/iResolution.xy, vec2(12.9898,100.233))) * 43758.5453), .4);\n\t\n\tfloat col=(pow(v,-.23)*pow(sin(c2.x),.99));\n\tfloat col2=(pow(sin(c1.y)+1.75,.99));\n\t\n    if(v>10.){\n\n\tfragColor = vec4(hsv(.8+sin(c3.r+col)*.3,.5-c3.r,.1+col*.75),1.);\n\t}\n\n\telse \n    \n    fragColor=vec4(hsv(.8+sin(col2)*.3,.5-col+sin(time*.4)*.3,col2*.3),1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2SRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 670, 692, 692, 737], [739, 845, 868, 868, 2399], [2401, 2401, 2429, 2429, 2505], [2508, 2508, 2565, 2565, 3673]], "test": "error"}
{"id": "Xt2SWw", "name": "A clockwork orange", "author": "jameswilddev", "description": "What a hack", "tags": ["2d", "distancefield"], "likes": 2, "viewed": 180, "published": "Public", "date": "1444219523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sampleLocation;\n\nfloat add(float shape) {\n    return shape;\n}\n\nfloat add(float shape, float scene) {\n    return min(shape, scene);\n}\n\nfloat subtract(float shape) {\n    return -shape;\n}\n\nfloat subtract(float shape, float scene) {\n    return max(-shape, scene);\n}\n\nfloat circle(vec2 origin, float radius) {\n    return distance(sampleLocation, origin) - radius;\n}\n\nfloat box(vec2 n, vec2 p) {\n    return max(sampleLocation.x - p.x, max(sampleLocation.y - p.y, max(n.x - sampleLocation.x, n.y - sampleLocation.y))); \n}\n\nfloat scene() {\n    return add(circle(vec2(0.6, 0.4) + vec2(sin(iTime), cos(iTime)) * 0.1, 0.07), subtract(circle(vec2(0.6, 0.4), 0.2), add(box(vec2(0.0, 0.0), vec2(1.0, 0.3)), subtract(circle(vec2(0.4, 0.5), 0.1), add(box(vec2(0.1, 0.2), vec2(0.6, 0.7)))))));\n}\n\n#define SKY_SHADED_COLOR vec3(0.4, 0.6, 1.0)\n#define SKY_LIT_COLOR vec3(0.2, 0.5, 0.7)\n#define SKY_SHADING_RADIUS 0.3\n#define SURFACE_LIT_COLOR vec3(1.0, 0.8, 0.5)\n#define SURFACE_SHADED_COLOR vec3(0.25, 0.2, 0.1)\n#define SURFACE_THICKNESS 0.02\n#define WALL_SHADED_COLOR vec3(0.025, 0.05, 0.5)\n#define WALL_LIT_COLOR vec3(0.15, 0.25, 1.0)\n#define WALL_SHADOW_RADIUS 0.15\n#define SURFACE_SHADOW_HARDNESS 2.0\n\n\nvec3 color() {\n    float dist = scene();\n    sampleLocation.x -= 0.02;\n    sampleLocation.y += 0.05;\n    float dist2 = scene();\n    float surfaceDepth = dist / -SURFACE_THICKNESS;\n    float wallDepth = (dist2 - SURFACE_THICKNESS) / -WALL_SHADOW_RADIUS;\n    float wallLit = min(1.0, max(0.0, wallDepth));\n    float surfaceLit = mix(1.0, min(1.0, max(0.0, SURFACE_SHADOW_HARDNESS - (((dist - dist2) * 0.5 * SURFACE_SHADOW_HARDNESS) / (-SURFACE_THICKNESS)))), 1.0 - surfaceDepth);\n    vec3 surfaceColor = mix(SURFACE_LIT_COLOR, SURFACE_SHADED_COLOR, surfaceLit);\n    vec3 wallColor = mix(WALL_SHADED_COLOR, WALL_LIT_COLOR, wallLit);\n    float skyDepth = min(1.0, dist / SKY_SHADING_RADIUS);\n    vec3 skyColor = mix(SKY_SHADED_COLOR, SKY_LIT_COLOR, skyDepth);\n    vec3 foregroundColor = surfaceDepth > 1.0 ? wallColor : surfaceColor;\n    return dist > 0.0 ? skyColor : foregroundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    sampleLocation = uv;\n\tfragColor = vec4(pow(color(), vec3(1.0 / 2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2SWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 66], [68, 68, 105, 105, 137], [139, 139, 168, 168, 189], [191, 191, 233, 233, 266], [268, 268, 309, 309, 365], [367, 367, 394, 394, 519], [521, 521, 536, 536, 783], [1194, 1194, 1208, 1208, 2077], [2079, 2079, 2136, 2136, 2278]], "test": "valid"}
{"id": "Xt2Sz3", "name": "(old) Acid demo", "author": "AstronautStr", "description": "My first fragment shader. Now using it as a screensaver )\nLooking better in FullHD.", "tags": ["procedural"], "likes": 10, "viewed": 212, "published": "Public", "date": "1445448046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n#define NORMSIN(x)              ((sin(x) + 1.0) / 2.0)\n#define NORMSIN_T(x)            (NORMSIN(x * iTime))\n#define NORMSIN_HZ(x)           (NORMSIN(2.0 * M_PI * x))\n#define NORMSIN_HZ_T(x)         (NORMSIN(2.0 * M_PI * x * iTime))\n\nvec2 hpolar(vec2 dPoint)\n{\n    return vec2((dPoint.x * dPoint.x + dPoint.y * dPoint.y), atan(dPoint.y, dPoint.x));\n}\n\nvec2 polar(vec2 dPoint)\n{\n    return vec2(sqrt(dPoint.x * dPoint.x + dPoint.y * dPoint.y), atan(dPoint.y, dPoint.x));\n}\n\nvec2 decart(vec2 pPoint)\n{\n    return vec2(pPoint.x * cos(pPoint.y), pPoint.x * sin(pPoint.y));\n}\n\nfloat softSquare(float phase, float width, float aaEdge)\n{\n    float result = NORMSIN(phase);\n    float alias = aaEdge * width;\n    \n    if (result > (width + alias))\n        return 1.0;\n    else if (result < (width - alias))\n        return 0.0;\n    else\n        return NORMSIN(M_PI + M_PI * (width - result) / (2.0 * alias));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 viewPort = vec2(1920.0, 1080.0);\n    float halfWidth = 0.5 * viewPort.x;\n    float halfHeight = 0.5 * viewPort.y;\n    vec2 fragmentPoint = fragCoord.xy / iResolution.xy * viewPort;\n    \n    float phase = 2.0 * M_PI * iTime * 1.0;\n    float radius = halfHeight;\n    \n    vec4 sphere;\n    {\n        vec2 center = vec2(halfWidth, halfHeight);\n        \n        vec2 dPoint = vec2(fragmentPoint.x - center.x, fragmentPoint.y - center.y);\n        vec2 pPoint = polar(dPoint);\n        \n        float maxRadius = sqrt(halfWidth * halfWidth + halfHeight * halfHeight);\n        float dist = pPoint.x / maxRadius;\n        \n        pPoint = hpolar(dPoint);\n        pPoint.x *= dist * dist * dist * dist;\n        \n        float speed = 8.0;\n        float width = 0.5;\n        float delay = 0.5 * NORMSIN(phase);\n        \n        float valueRed = NORMSIN(pPoint.x / 10.0 + iTime * speed);\n        float valueBlue = NORMSIN(pPoint.x / 10.0 + (iTime - delay) * speed);\n        float farFading = clamp(pPoint.x / maxRadius, 0.0, 1.0);\n        \n        sphere = vec4(farFading * valueRed, 0.0, farFading * valueBlue, 0.0);\n    }\n    \n    vec2 center = vec2(halfWidth, halfHeight);\n    vec2 camera = vec2(halfWidth + cos(phase) * radius, halfHeight + sin(phase) * radius);\n    vec2 dPoint = vec2(fragmentPoint.x - center.x, fragmentPoint.y - center.y);\n    vec2 pPoint = polar(dPoint);\n    \n    float maxRadius = sqrt(halfWidth * halfWidth + halfHeight * halfHeight);\n    float dist = pPoint.x / maxRadius;\n    \n    float magic = 0.0625;\n    center = center + dist * vec2(center.x - camera.x, center.y - camera.y) * magic;\n    \n    dPoint = vec2(fragmentPoint.x - center.x, fragmentPoint.y - center.y);\n    pPoint = polar(dPoint);\n    pPoint.x *= 1.0 - dist;\n    \n    float speed = 2.0;\n    float width = 0.5;\n    float delay = 0.5 * NORMSIN_HZ_T(0.25);\n    \n    float valueRed = softSquare(pPoint.x / 10.0 + iTime * speed, width, 0.1);\n    float valueBlue = softSquare(pPoint.x / 10.0 + (iTime - delay) * speed, width, 0.1);\n    \n    vec4 color = vec4(valueRed, valueBlue, valueBlue, 1.0);\n    \n    float merge = sqrt( dPoint.x * dPoint.x + dPoint.y * dPoint.y ) / maxRadius;\n    merge = 0.75 + 0.25 * merge * NORMSIN(phase + M_PI);\n    \n    fragColor = merge * color + (1.0 - merge) * sphere;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2Sz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 307, 307, 397], [399, 399, 424, 424, 518], [520, 520, 546, 546, 617], [619, 619, 677, 677, 947], [949, 949, 1006, 1006, 3293]], "test": "valid"}
{"id": "Xt2XDW", "name": "rainbow disk (262 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["rainbow", "short"], "likes": 11, "viewed": 1382, "published": "Public API", "date": "1443736938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o,  vec2 u )\n{\n    float C,S, t=(iTime-11.)/1e3;\n    o-=o;\n    vec2 R = iResolution.xy, p;\n\tu = 6.3*(u+u-R)/R.y;\n    \n#define B(k) ceil( (p=cos(u*=mat2(C=cos(t),S=-sin(t),-S,C))).x * p.y )  * (.5+.5*cos(k))\n \n    for (float a=0.; a<6.3; a+=.1)\n        o += vec4(B(a),B(a+2.1),B(a-2.1),1) / 31.;\n}\n\n\n/**  // expended version (283 chars)\n\nfloat C,S, t=(iTime-11.)/1e3;\n#define rot(a) mat2(C=cos(a),S=-sin(a),-S,C)\n\nvoid mainImage( out vec4 o,  vec2 u )\n{\n    o-=o;\n    vec2 R = iResolution.xy, p;\n\tu = 6.3*(u+u-R)/R.y;\n    \n#define B(k) ceil( (p=cos(u*=rot(t))).x * p.y )  * (.5+.5*cos(k))\n \n    for (float a=0.; a<6.3; a+=.1)\n        o += vec4(B(a),B(a+2.1),B(a-2.1),1) / 31.;\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2XDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 321]], "test": "valid"}
{"id": "XtBSWm", "name": "MandelbrotAttempt1", "author": "denosya", "description": "Wow... just magic :)", "tags": ["mandelbrot"], "likes": 0, "viewed": 107, "published": "Public", "date": "1443997661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec4 run(in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n   // Zoom    \n    const float initialzoom = 600.0;\n    float zoom = initialzoom + (exp(1.0 - cos(iTime*0.1))-1.0) * 5500.0;    \n    \n    //zoom = 40.2;\n    \n    uv /= zoom*0.01;\n\n    // Rotation\n    float t = iTime*0.1;\n    uv *= mat2(cos(t),sin(t), -sin(t),cos(t));\n\n    // Translation\n    //const vec2 focus = vec2(0.424513, 0.20753);  \n\tconst vec2 focus = vec2(-0.05, 0.6805);        \n    uv += focus;     \n    \n    vec2 c = vec2(uv.x, uv.y);\n    vec2 z = vec2(0.0, 0.0);\n    \n    bool draw = true;\n\n    int nbiter = 0;    \n    \n    float maxmod = 0.0;\n    \n       for(int i=0; i<100;i++) {\n     \n        float _2xy = 2.0*z.x*z.y;\n        z.x = z.x*z.x - z.y*z.y;\n        z.y = _2xy;\n        \n        z += c;\n        \n        if(length(z)>2.0) {\n\t\t\tbreak;            \n        }\n        \n        nbiter++;\n    }\n    \n    float col = pow(float(nbiter) / 100.0, 1.5);\n\treturn vec4(1.0-col);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 fragColor1 = run(fragCoord + vec2(-0.25, -0.25));\n    vec4 fragColor2 = run(fragCoord + vec2(+0.25, -0.25));\n    vec4 fragColor3 = run(fragCoord + vec2(-0.25, +0.25));\n    vec4 fragColor4 = run(fragCoord + vec2(+0.25, +0.25));\n    \n    fragColor = (fragColor1 + fragColor2 + fragColor3 + fragColor4) * 0.25;\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 32, 32, 1031], [1033, 1033, 1090, 1090, 1409]], "test": "valid"}
{"id": "XtBSWy", "name": "cellular daydream", "author": "gtoledo3", "description": "Combining cellular noise with various uv warp effects, zoom/density levels, and color mapping, for creative effect.", "tags": ["noise", "worley", "psychedelic", "cellular", "uvwarp"], "likes": 8, "viewed": 1342, "published": "Public API", "date": "1446087659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\"Cellular Daydream\", George Toledo. 2015. \n\nvec2 offset=vec2(.5);\n\nvec3 hsv(const in float h, const in float s, const in float v) {\n\treturn mix(vec3(1.0),clamp((abs(fract(h+vec3(3.,2.,1.)/3.0)*6.-3.)-1.),0.,1.0),s)*v;\n}\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details, located in ZIP file here:\n// http://webstaff.itn.liu.se/~stegu/GLSL-cellular/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n//end worley\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n    float time=iTime*.1;\n\n\tvec2 position = fragCoord.xy / iResolution.x - offset;\n\tposition = position * (.1+.5*(sin(time*.01)*2.2));//position and zoom offset fx\n\n\t//various uv distortion, zoom levels, offsets, cellular FX->pattern\n\tvec2 cec  =cellular(.35+vec2(0.,time*.2)+position*(9.+sin(time*.01)))+sin(time+position.x*3.)*.3;\n\tvec2 cec2 =cellular(2.+position*4.)+cos(position.y*12.)*.3;\n\tvec2 cec3 =cellular(7.+vec2(0.,time*.4)+sin(position*14.))*.5;\n\tvec2 cec4 =cellular(9.+position*12.+cos(position.x*4.)*.5);\n\tvec2 cec5 =cellular(12.+position*28.);\n\tvec2 cec6 =cellular(3.+vec2(0.,time*.4)+position*34.)+(cos(3.5+position.x*32.)*.3)+(cos(5.*time+position.y*9.)*.1);\n\tvec2 cec7 =cellular(vec2(time*2.4,0.)+(position+(cos(position.x*3.)*.1))*96.+cos(position.x*3.)*14.)+cos(time+position.x*12.)*.3;\n\n\t//min between different patterns\n    cec=min(cec,cec2);\n\tcec=min(cec,cec3);\n\tcec=min(cec,cec4);\n\tcec=min(cec,cec5);\n\tcec=min(cec,cec6);\n\tcec=min(cec,cec7);\n\t//rand idea I found at heroku one time, probably changed some\n\tfloat rand = mod(fract(sin(dot(fragCoord.xy / iResolution.xy, vec2(12.9898,1980.223+time))) * 43758.5453), .05);\n\t//combining x and y lanes with a slip timing and different instensities, to create a variety of formations\n\tfloat l=pow(1.-sin(cec.y),.5+(sin(time*.0011)*.3));\n\tfloat l2=pow(1.-sin(cec.x),1.5+(sin(time*.001)*.3));\n\tl=min(l,l2);\n    //vignette\n\tfloat v=length(fragCoord.xy / iResolution.xy-.5);\n    v=smoothstep(v,.8,.7);\n\tfragColor=vec4(hsv((time*.01)+.6-sin(l*1.8)*2.9,l*.65,l-.2),1.);\n\tfragColor.rgb +=vec3(rand);\n    fragColor.rgb -=vec3(1.-v);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 564, 586, 586, 631], [633, 739, 762, 762, 2293], [2308, 2308, 2364, 2364, 3958]], "test": "error"}
{"id": "XtBXRc", "name": "[CIS565 2015F] GLSL-Ray-Marcher", "author": "zhuxinyue", "description": "https://github.com/CIS565-Fall-2015/Project5-GLSL-Ray-Marcher\nThis Shadertoy uses material from the following resources:\niq Cloudy Terrain: https://www.shadertoy.com/view/MdlGW7\niq RayMarching Primitives: https://www.shadertoy.com/view/Xds3zN\n", "tags": ["raymarching", "glsl"], "likes": 2, "viewed": 236, "published": "Public", "date": "1445309563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.00001\n#define MinStep 0.01\n#define MaxDis 120.0\n#define R 0.25\n#define cpt vec3(0.0,R,0.0)\n#define disi 1.2\n\n//#define debugView1\n//#define debugView2\n//#define naive\n//#define terrMap\nfloat iterate_num=0.0;\nfloat terrain_y=0.0;\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdWheel( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n//----------------------------------------------------------------------\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n   return (d1.x< -d2.x)?-d2:d1;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nvec3 opTrans( vec3 p, vec3 s,vec3 r,vec3 t )//m:tranformation matrxi,s scale parameter\n{\n    \n     mat4 S_inv = mat4(vec4(1.0/s.x,0,0,0),\n                       vec4(0,1.0/s.y,0,0),\n                       vec4(0,0,1.0/s.z,0),\n                       vec4(0,0,0,1));\n    \n     mat4 T_inv = mat4(vec4(1,0,0,0),\n                       vec4(0,1,0,0),\n                       vec4(0,0,1,0),\n                       vec4(vec3(-t),1));\n    float sx = sin(r.x);\n    float sy = sin(r.y);\n    float sz = sin(r.z);\n    \n    float cx = cos(r.x);\n    float cy = cos(r.y);\n    float cz = cos(r.z);\n  \n   \n    mat4 Rmatrix = mat4(\tcy*cz,\tcx*sz+cz*sx*sy,\tsx*sz-cx*cz*sy,\t0,\n                      \t   -cy*sz,\tcx*cz-sx*sy*sz,\tcz*sx+cx*sy*sz,\t0,\n                        \tsy,\t\t-cy*sx,\t\t\tcx*cy,\t\t\t0,\n                        \t0,\t\t0,\t\t\t\t0,\t\t\t\t1);\n    mat4 R_inv = mat4(\tcy*cz,\t        -cy*sz,\t         sy,    0,\n                     \tcx*sz+cz*sx*sy,\tcx*cz-sx*sy*sz, -cy*sx, 0,\n                     \tsx*sz-cx*cz*sy, cz*sx+cx*sy*sz,  cx*cy, 0,\t\n                     \t0,0,0,1);\n\n    \n    mat4 invertMatrix = S_inv*R_inv*T_inv;\n    \n    vec4 p_transformed = invertMatrix*vec4(p,1.0);\n   \n    return p_transformed.xyz;\n\n}\n//----------------------------------------------------------------------\n\n\nfloat Textyrek( vec3 point )\n{\n    \n\tfloat k = 1.0-smoothstep( 0.42, 0.95, texture( iChannel0, 0.04*point.xz,-70.0).x);\n\treturn  k*texture( iChannel1, 0.02*point.zx ).x;\n\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - Textyrek(pos);\n}\n\nvec2 setGeo( in vec3 point )\n{\n    //plane,box,rounded box,shpere,wheel,cylinder\n    //sphere:0,0,0,R=0.25\n    \n    vec2 res = opU(vec2( sdPlane(point), 1.0 ), vec2( sdSphere(point-cpt, R ), 50.0 ) );\n#ifdef terrMap\n    float tt=0.5;\n    \n    res = opU(vec2( mapTerrain(point), 1.0 ), vec2( sdSphere(point-cpt-0.5, R ), 50.0 ) );\n#else \n    float tt=0.0;\n    res = opU(res, vec2(  sdBox  (point-vec3(cpt.x+disi,cpt.y, cpt.z)-tt, vec3(R) ),21.0 ) );\n #endif \n    res = opU( res, vec2( udRoundBox(point-vec3( cpt.x-disi,cpt.y, cpt.z)-tt, vec3(R-0.1), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus   (point-vec3( cpt.x-2.0*disi,cpt.y,cpt.z)-tt, vec2(R,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdWheel   (point-vec3( cpt.x+2.0*disi,cpt.y,cpt.z)-tt, vec2(R,0.05) ), 35.0 ) );    \n#ifdef terrMap\n#else \n    res = opU( res, vec2( sdBox   (point-vec3(cpt.x+disi, cpt.y, cpt.z+disi)-tt, vec3(R/3.0) ),60.0 ));\n    res = opU( res, vec2( sdCone  (point-vec3(cpt.x+disi, cpt.y+0.1, cpt.z-disi)-tt, vec3(R) ),31.0 ) );\n\n    //operation:subtraction,repeat, transform\n    res = opS( res, vec2( sdSphere (point-vec3(cpt.x+disi,cpt.y, cpt.z)-tt,R+0.05 ), 0.0 ));\n    //repeatl;\n    vec3 p1 = opRep(point-vec3(cpt.x+disi, cpt.y, cpt.z+disi), vec3(2.0) );\n    res = opU(res,vec2( sdBox (p1, vec3(R/3.0) ),10.0 ) );\n   //transform\n    vec3 sm=vec3(12.5,1.5,1.0);\n    vec3 rm=vec3(45.0,0.0,0.0);\n    vec3 tm=vec3(0.0,0.0,0.8);\n    vec3 p2 = opTrans(point-vec3(cpt.x, cpt.y, cpt.z+disi)-tt,sm,rm,tm);\n    res = opU(res, vec2( sdCylinder (p2, vec2(R/2.0,R/2.0) ), 15.0 ) );\n\n#endif\n    return res;\n}\n\n\nvec2 acc_rayMarching(vec3 dir, vec3 ori)\n{\n    \n    vec3 point;\n    vec2 h;\n    float t=1.0;\n    float m=0.0;\n    for(float s=0.0;s<MaxDis;s+=MinStep)\n\t{\n        point = ori+t*dir;\n       //***********************//\n        h= setGeo(point);\n        //*************************//\n        if(h.x<EPSILON)\n        {  \n          break;\n        }\n        if(t>MaxDis)break;\n        t+= max(h.x,MinStep);\n        iterate_num++;\n        m =h.y;\n\t}\n     return vec2( t, m );\n}\nvec2 naive_rayMarching(vec3 dir, vec3 ori)\n{\n    vec3 point;\n    vec2 dis;\n    float m=0.0;\n    float t_temp=0.0;\n    for(float t=.0;t<MaxDis;t+=MinStep)\n    {\n          point=ori+dir*t;\n          dis= setGeo(point);//length(point-centerPoint)-R;\n         \n       if(dis.x<.0){break;}\n        m=dis.y;\n        t_temp=t;\n        iterate_num++;\n    }\n    return vec2(t_temp,m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt,in float k )\n{\n\n    float t = mint;\n\tfloat res = 1.0;\n    for ( float i = 0.0; i < MaxDis; i++ )\n    {\n        float h = setGeo( ro + rd * t ).x;\n        if ( h < EPSILON ){return 0.0;break;}\t\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\nvec3 calTerrNor()\n{\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 diffNormal( in vec3 point )\n{\n\tvec3 eps = vec3( EPSILON, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    setGeo(point+eps.xyy).x - setGeo(point-eps.xyy).x,\n\t    setGeo(point+eps.yxy).x - setGeo(point-eps.yxy).x,\n\t    setGeo(point+eps.yyx).x - setGeo(point-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float d=0.0;\n    for( int i=0; i<6; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * h + pos;\n        d = setGeo(aopos).x;\n        occ += -(d-h)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    //two method of ray marching:\n#ifdef naive\n    vec2 res = naive_rayMarching(rd,ro);\n#else\n    vec2 res = acc_rayMarching(rd,ro);\n#endif\n    \n#ifdef debugView1\n    //res = acc_rayMarching(rd,ro);\n\tfloat tv = res.x/25.0;\n    col = vec3(tv);\n\treturn vec3( clamp(col,0.0,1.0));\n#else\n#endif\n    \n#ifdef debugView2\n   // res = acc_rayMarching(rd,ro);\n    //res = naive_rayMarching(rd,ro);\n    col=vec3(float(iterate_num/(2.0*MaxDis)));\n    return vec3( clamp(col,0.0,1.0));\n#else\n#endif\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n      \n        vec3 point = ro + t*rd;\n        vec3 normal = diffNormal( point );\n        vec3 ref = reflect( rd, normal );\n        vec3 lightpos=vec3(0.8, 0.6, -0.5);\n        vec3 lightdir=lightpos-point;        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.20)*(m-1.0) );\n\n        if( m<2.0 )//m=1.0(plane)\n        {\n            \n            float f = mod( floor(5.0*point.z) + floor(5.0*point.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n        // material  \n        float occ = calAO( point, normal );\n       //float occ=1.0;\n\t\tfloat amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n        float dif = clamp( dot( normal, lightdir ), 0.0, 1.0 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        \n        float light_len=length(lightdir);\n        vec3 H=normalize(lightdir+normalize(ro-point));\n        float hdot=dot(H,normal);\n        float spec = float(max(pow(hdot,10.0),0.0));\n        float fre = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 2.0 );\n        float attn = 1.0 - pow( min( 1.0, length(lightdir) / 10.0 ), 2.0 );\n        dif *= softshadow( point, lightpos, 0.02, 2.5,8.0 );\n        dom *= softshadow( point, ref, 0.02, 2.5,8.0 );\n        \n\t\tfloat phong_color =0.0;\n        phong_color= 1.5*dif+1.3*spec+0.1*amb*occ;\n        phong_color += 0.40*dom*occ;\n        phong_color += 0.40*fre*occ;\n\t\tcol = col*phong_color*attn;\n#ifdef terrMap\n        if(m<1.5){\n            float f = mod( floor(5.0*point.z) + floor(5.0*point.x), 2.0);\n            vec3 basec=vec3(0.75,0.75,0.75);\n            col = basec;\n            col*=1.0*dif+0.2*amb*occ;\n            col.xyz = mix( col.xyz, basec, 0.2);\n            col*=0.9;\n            // col*=vec3(0.2,0.8,0.7);\n            \n        }\n        //the terrin map\n#else\n#endif\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 272, 272, 287], [289, 289, 324, 324, 350], [352, 352, 383, 383, 470], [471, 471, 496, 496, 533], [535, 535, 560, 560, 625], [626, 626, 659, 659, 726], [729, 729, 774, 774, 814], [815, 815, 851, 851, 950], [951, 951, 984, 984, 1037], [1038, 1038, 1076, 1076, 1245], [1322, 1322, 1352, 1352, 1386], [1388, 1388, 1418, 1418, 1451], [1453, 1453, 1483, 1483, 1512], [1515, 1515, 1603, 1603, 2705], [2781, 2781, 2811, 2811, 2953], [2955, 2955, 2988, 2988, 3021], [3023, 3023, 3053, 3129, 4605], [4608, 4608, 4650, 4650, 5077], [5078, 5078, 5122, 5122, 5455], [5457, 5457, 5542, 5542, 5819], [5820, 5820, 5839, 5839, 5867], [5868, 5868, 5902, 5902, 6155], [6157, 6157, 6198, 6198, 6504], [6507, 6507, 6546, 6546, 8924], [8926, 8926, 8978, 8978, 9155], [9157, 9157, 9214, 9214, 9808]], "test": "error"}
{"id": "XtBXzK", "name": "pacman2", "author": "Dermenslof", "description": "weeeeeeeeeeeeeeeeeeee", "tags": ["pacman"], "likes": 1, "viewed": 100, "published": "Public", "date": "1444780854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(in vec2 uv, float a)\n{\n    a = radians(a);\n\treturn (vec2(uv.x * cos(a) - uv.y * sin(a), uv.x * sin(a) + uv.y * cos(a)));\n}\n\nbool isInCircle(vec2 uv, vec2 c, float r)\n{\n    return length(uv - c) <= r;\n}\n\nbool isOnCircle(vec2 uv, vec2 c, float r)\n{\n    return isInCircle(uv, c, r) && length(uv - c) > r - 0.005;\n}\n\nbool isNeedle(vec2 no, float w, float h, float a)\n{\n    no = rotate(no, a);\n    w /= 2.0;\n    return (no.x > -w && no.x < w && no.y > 0.0 && length(no) < h);\n}\n\n#define EPSILON 0.001\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec3 c = vec3(0.0);\n    \n    vec2 un = normalize(uv);\n\tif (isInCircle(uv, vec2(1.0 - mod(iTime * 2.0, 1.2), 0.0) * 2.0, 0.2))\n        c = vec3(1.0);\n    if (length(uv) < 1.0)\n    {\n    \t    float mousea = 30.0 * (cos(iTime * 10.0)/ 2.0 + 0.5);\n    \t    if (degrees(atan(un.y, un.x)) > mousea || degrees(atan(un.y, un.x)) < -mousea)\n    \t    \tc = vec3(1.0, 1.0, 0.0);\n    \tif (isInCircle(uv, vec2(0.4, 0.4), 0.2) && rotate(uv, 0.0).y > 0.4)\n    \t    if ((degrees(atan(un.y, un.x)) > 50.0  || degrees(atan(un.y, un.x)) < 49.0) && length(un) > 0.1)\n    \t    \tc = vec3(0.0);\n    }\n    float as = floor(iDate.w * 360.0 / 60.0);\n    float ah = (iDate.w / 3600.0) * 360.0 / 12.0;\n    float am = (iDate.w / 60.0) * 360.0 / 60.0;\n    if (isNeedle(uv, 0.03, 0.65, am))\n        c = vec3(0.0, 0.0, 1.0);\n    if (isNeedle(uv, 0.03, 0.4, ah))\n        c = vec3(0.0, 1.0, 0.0);\n   \tif (isNeedle(uv, 0.02, 0.8, as))\n  \t\tc = vec3(1.0, 0.0, 0.0);\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 134], [136, 136, 179, 179, 213], [215, 215, 258, 258, 323], [325, 325, 376, 376, 484], [509, 509, 566, 566, 1633]], "test": "valid"}
{"id": "XtjSDh", "name": "Parallax Scrolling Star Field", "author": "AxleMike", "description": "A rough parallax scrolling star field.", "tags": ["parallax", "starfield"], "likes": 12, "viewed": 1812, "published": "Public API", "date": "1444021607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Alexander Lemke, 2015\n// Voronoi and fractal noise functions based on iq's https://www.shadertoy.com/view/MslGD8\n\nfloat Hash(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    return -1.0 + 2.0 * fract(sin(h) * 43758.5453);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    float h2 = dot(p, vec2(37.271, 377.632));\n    return -1.0 + 2.0 * vec2(fract(sin(h) * 43758.5453), fract(sin(h2) * 43758.5453));\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\nfloat FractalNoise(in vec2 p)\n{\n    p *= 5.0;\n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n\tfloat f = 0.5000 * Noise(p); p = m * p;\n\tf += 0.2500 * Noise(p); p = m * p;\n\tf += 0.1250 * Noise(p); p = m * p;\n\tf += 0.0625 * Noise(p); p = m * p;\n    \n    return f;\n}\n\nvec3 Voronoi(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j)\n    {\n        for(int i = -1; i <= 1; ++i)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = Hash2D(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\treturn vec3(md, mr);\n}\n\nvec3 ApplyFog(in vec2 texCoord)\n{\n    vec3 finalColor = vec3(0.0);\n    \n    vec2 samplePosition = (4.0 * texCoord.xy / iResolution.xy) + vec2(0.0, iTime * 0.0025);\n    float fogAmount = FractalNoise(samplePosition) * 0.175;\n        \n    vec3 fogColor = vec3(texCoord.xy / iResolution.xy + vec2(0.5, 0.0), sin(iTime) * 0.25 + 0.5);\n    finalColor = fogColor * fogAmount * vec3(sin(iTime) * 0.00125 + 0.75);  \n    \n    return finalColor;\n}\n\nvec3 AddStarField(vec2 samplePosition, float threshold)\n{\n    vec3 starValue = Voronoi(samplePosition);\n    if(starValue.x < threshold)\n    {\n        float power = 1.0 - (starValue.x / threshold);\n        return vec3(power * power * power);\n    }\n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxResolution = max(iResolution.x, iResolution.y);\n    \n\tvec3 finalColor = ApplyFog(fragCoord.xy);\n    \n    // Add Star Fields\n    vec2 samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.01);\n    finalColor += AddStarField(samplePosition * 16.0, 0.00125);\n    \n    samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.004);\n    finalColor += AddStarField(samplePosition * 20.0, 0.00125);\n    \n    samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.0005 + 0.5);\n    finalColor += AddStarField(samplePosition * 8.0, 0.0007);\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 143, 143, 239], [241, 241, 265, 265, 442], [444, 444, 468, 468, 690], [692, 692, 723, 723, 949], [951, 951, 976, 976, 1457], [1459, 1459, 1492, 1492, 1896], [1898, 1898, 1955, 1955, 2168], [2171, 2171, 2228, 2228, 2862]], "test": "valid"}
{"id": "XtjSRV", "name": "3D Dot Rose", "author": "yasuo", "description": "It's just my drawing stuff.", "tags": ["3d", "animation", "art", "rose"], "likes": 5, "viewed": 998, "published": "Public API", "date": "1445011781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\nfloat tt;\nfloat atime;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec4 combine(vec4 val1, vec4 val2 )\n{\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( vec3 p, float r, float h )\n{\n    vec2 c = normalize( vec2( h, r ) );\n    float q = length(p.xy);\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\n}\n\nfloat cubicInOut(float t) {\n    return t < 0.5\n        ? 4.0 * t * t * t\n        : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat perlin(vec3 p) {\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*PI)*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z);\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\n    float t = floor(iTime);\n    float f = fract(iTime);\n    t += cubicInOut(2. - exp(-f*5.));\n    atime = t*0.2;\n\n    float deg = atime*50.0;\n    float deg2 = -1.0*atime*50.0+30.0;\n    float deg3 = atime*50.0+60.0;\n    float deg4 = -1.0*atime*50.0+90.0;\n    float deg5 = atime*50.0+120.0;\n    float deg6 = -1.0*atime*50.0+150.0;\n    float deg7 = atime*50.0+180.0;\n    float deg8 = -1.0*atime*50.0+210.0;\n    float deg9 = atime*50.0+240.0;\n    float deg10 = -1.0*atime*50.0+280.0;\n\n    vec4 newP = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg*DEG_TO_RAD)*matRotateY(deg*DEG_TO_RAD)*matRotateZ(deg*DEG_TO_RAD);\n    vec4 newP2 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg2*DEG_TO_RAD)*matRotateY(deg2*DEG_TO_RAD)*matRotateZ(deg2*DEG_TO_RAD);\n    vec4 newP3 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg3*DEG_TO_RAD)*matRotateY(deg3*DEG_TO_RAD)*matRotateZ(deg3*DEG_TO_RAD);\n    vec4 newP4 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg4*DEG_TO_RAD)*matRotateY(deg4*DEG_TO_RAD)*matRotateZ(deg4*DEG_TO_RAD);\n    vec4 newP5 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg5*DEG_TO_RAD)*matRotateY(deg5*DEG_TO_RAD)*matRotateZ(deg5*DEG_TO_RAD);\n    vec4 newP6 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg6*DEG_TO_RAD)*matRotateY(deg6*DEG_TO_RAD)*matRotateZ(deg6*DEG_TO_RAD);\n    vec4 newP7 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg7*DEG_TO_RAD)*matRotateY(deg7*DEG_TO_RAD)*matRotateZ(deg7*DEG_TO_RAD);\n    vec4 newP8 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg8*DEG_TO_RAD)*matRotateY(deg8*DEG_TO_RAD)*matRotateZ(deg8*DEG_TO_RAD);\n    vec4 newP9 = vec4(q.xyz + vec3( 5.0, 10.0, 0 ),1.0)*matRotateX(90.0*DEG_TO_RAD)*matRotateY(-40.0*DEG_TO_RAD);\n    vec4 newP10 = vec4(q.xyz + vec3( -7.0, 15.0, 0 ),1.0)*matRotateX(90.0*DEG_TO_RAD)*matRotateY(45.0*DEG_TO_RAD);\n\n    float glow = 0.0;\n    vec3 p = pos;\n    float grid = max(0.0, max((mod((p.x+p.y+p.z*50.0)-atime*0.01, 50.0)-40.0), 0.0) );\n\n    float size1 = 7.2;\n    float size2 = 7.2;\n    float size3 = 7.2;\n    float size4 = 7.2;\n    float size5 = 7.2;\n    float size6 = 7.2;\n    float size7 = 7.2;\n\n    vec3 roseCl = vec3(0.35,0.0,0.0)+vec3(grid,0.0,0.0);\n    vec3 scale1 = vec3(abs(sin(atime)*size1),size1,abs(sin(atime)*size1));\n    vec3 scale2 = vec3(size2,abs(sin(atime)*size2),size2);\n    vec3 scale3 = vec3(size3,size3,abs(sin(atime)*size3));\n    vec3 scale4 = vec3(size4,abs(sin(atime)*size4),size4);\n    vec3 scale5 = vec3(abs(sin(atime)*size5),size5,size5);\n    vec3 scale6 = vec3(abs(sin(atime)*size6),abs(sin(atime)*size6),size6);\n    vec3 scale7 = vec3(size7,abs(sin(atime)*size7),size7);\n\n    float noise = perlin(pos * 0.5) * 0.2;\n    vec4 val1 = vec4(roseCl,sdBox(newP.xyz,scale1 ) + noise);\n    vec4 val2 = vec4(roseCl,sdBox(newP2.xyz,scale2 ) + noise);\n    vec4 val3 = vec4(roseCl,sdBox(newP3.xyz,scale3 ) + noise);\n    vec4 val4 = vec4(roseCl,sdBox(newP4.xyz,scale4 ) + noise);\n    vec4 val5 = vec4(roseCl,sdBox(newP5.xyz,scale5 ) + noise);\n    vec4 val6 = vec4(roseCl,sdBox(newP6.xyz,scale6 ) + noise);\n    vec4 val7 = vec4(roseCl,sdBox(newP7.xyz,scale7 ) + noise);\n\n    vec4 val8 = vec4(vec3(0.0,0.1,0.0)+vec3(0.0,grid,0.0),sdBox(q.xyz + vec3( 0, 16.0, 0 ),vec3(1.0,10.0,1.0) ) + noise);\n    vec4 val9 = vec4(vec3(0.0,0.1,0.0)+vec3(0.0,grid,0.0),sdCone(newP9.xyz,1.0,7.0 ) + noise);\n    vec4 val10 = vec4(vec3(0.0,0.1,0.0+vec3(0.0,grid*-1.0,0.0)),sdCone(newP10.xyz,1.0,9.0 ) + noise);\n\n    vec4 val11 = combine ( val1, val2 );\n    vec4 val12 = combine ( val3, val4 );\n    vec4 val13 = combine ( val5, val6 );\n    vec4 val14 = combine ( val7, val8 );\n    vec4 val15 = combine ( val9, val10 );\n    vec4 val16 = combine ( val11, val12 );\n    vec4 val17 = combine ( val13, val14 );\n    vec4 val18 = combine ( val15, val16 );\n    vec4 val19 = combine ( val17, val18 );\n\n    return val19;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    position -= .5;\n    position = floor(position*150.0)/150.0;\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x / iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 5.0, 15.0);\n    mat4 m = matRotateY(iTime*0.5);\n\n    vec4 result;\n    int march = 0;\n\n    for (int i =0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        march = i;\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    if ( pos.z> 100. )\n    {\n        // bg\n        position.y /= 1.5;\n        vec3 pw\t= vec3(position.y - position.x, position.y + position.x, -(position.y * 2.));\n        pw\t\t*= .8;\n\n        float t = atime*-7.0;\n        float tau = (8. * atan(1.));\n        vec2 m = vec2((t-1.5) / tau, (t - .5) / tau);\n\n        vec3 r = vec3(m.x, tau/2., m.y);\n\n        mat3 rm3 = mat3RotateX(r.z*5.);\n        pw *= tau/1.;\n\n        float s = 1./0.7;\n        vec3 d = vec3(pw);\n\n        float w  = 0.0001/iResolution.x;\n        vec3 color = vec3(0);\n\n        pw = abs(pw)-s;\n        pw *= rm3;\n\n        color += float(pw.z*0.5<w);\n        float temp = length(vec2(position.xy))+0.5;\n\n        col = vec3(vec3(vec3(.2,.0,.0)/vec3(temp)))+vec3(color.y*0.1,0,0.);\n    }\n    else\n    {\n        // shade\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n\n        col += vec3(result.xyz);\n    }\n\tfloat cline = mod(fragCoord.y, 4.0) < 2.0 ? 0.5 : 1.0;\n    fragColor = vec4( col, 1.0)*cline;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 173, 173, 336], [338, 338, 366, 366, 530], [532, 532, 560, 560, 709], [711, 711, 740, 740, 857], [859, 933, 970, 970, 1029], [1031, 1105, 1136, 1136, 1227], [1229, 1303, 1345, 1345, 1465], [1467, 1467, 1494, 1494, 1588], [1590, 1590, 1612, 1612, 1860], [1862, 1862, 1891, 1891, 5729], [5731, 5731, 5758, 5758, 5852], [5854, 5854, 5911, 5911, 7910]], "test": "valid"}
{"id": "XtjSWD", "name": "rainbow disk - 4", "author": "FabriceNeyret2", "description": "a variant of https://www.shadertoy.com/view/Xl2XDW<br/>You can try the various commented versions,   or suppressing  \"ceil\"", "tags": ["rainbow", "short"], "likes": 11, "viewed": 1450, "published": "Public API", "date": "1443738943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(C=cos(a),S=-sin(a),-S,C)\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float C,S, t=(iTime+15.)/5e2;\n    o-=o;\n    vec2 R = iResolution.xy, p;\n\tu = 36.3*(u+u-R)/R.y;\n    \n// #define B(k) ceil( (p=cos(u*=rot(t))).x * p.y )  * (.5+.5*cos(k)) / 31.\n// #define B(k) ceil( (p=cos(u*=rot(t))).x )        * (.5+.5*cos(k)) / 31.\n// #define B(k) ceil( (p=cos(u*=rot(t))).x )        *     cos(k)     / 4.\n   #define B(k)     ( (p=cos(u=u*rot(t)+k)).x )     *     cos(k)     / 6.\n   \n    for (float a=0.; a<6.3; a+=.1)\n        o += vec4( B(a), B(a+2.1), B(a-2.1), 1) ;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 84, 84, 578]], "test": "valid"}
{"id": "XtjXRG", "name": "gdp_grid", "author": "plancien", "description": "Grid example, with cosine functions\nFor teaching purpose", "tags": ["teaching", "gdp"], "likes": 5, "viewed": 139, "published": "Public", "date": "1444637109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n    //********* CAMERA\n    float zoom = (iResolution.x / 10.0);\n    float cameraX = 5.0;\n    float cameraY = 2.0;\n    float x = (pixCoords.x / zoom) - cameraX;\n    float y = (pixCoords.y / zoom) - cameraY;\n\n    \n    \n    //********* GRID\n    float lineSemiWidth = 0.01;\n    \n    if (abs(x) < lineSemiWidth || abs(y)<lineSemiWidth) {\n\t\tcolor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    if (mod(x, 1.0) < lineSemiWidth || mod(y, 1.0) < lineSemiWidth) {\n\t\tcolor = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n    \n    \n    \n    \n    float PI             = 3.1415;\n    float hauteurMoyenne = 0.0;\n    float amplitude      = 1.0;\n    float phase          = 4.0 + 5.0 * cos(iTime);\n    float periode        = 3.0;\n    float fx = hauteurMoyenne + cos(x * 2.0 * PI / periode + phase) * amplitude;\n    \n    if (y < fx) {\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    \n    \n    \n    float fx2 = 1.0 + cos(2.5 * (x + iTime)) * 0.3;\n    \n    if (y < fx2) {\n        color = vec4(0.6, 0.6, 1.0, 1.0);\n        return;\n    }\n\t\n    \n\n    //********* BACKGROUND\n    color = vec4(1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 76, 1172]], "test": "valid"}
{"id": "XtjXWW", "name": "Carpet_", "author": "shezard", "description": "Escher's carpet", "tags": ["2d"], "likes": 3, "viewed": 156, "published": "Public", "date": "1443720984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(in float theta) {\n    return mat2(\n    \tcos(theta), -sin(theta), sin(theta), cos(theta)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1. + 2. * uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    p *= 2. + cos(iTime*.5 + length(p)) * 20.;\n    \n    p *= rotate(iTime * .5);\n    \n    float f = floor(length(p * p.x * p.y));\n    \n    f *= cos(p.x * .4);\n    f *= cos(p.y * .4);\n    \n    vec3 c = vec3(1.) * f * f*.05;\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 108], [110, 110, 167, 167, 550]], "test": "valid"}
{"id": "XtjXz3", "name": "secret lair", "author": "ryk", "description": "You could say I'm a fan of light fixtures behind fans. Better not, though.", "tags": ["volumetric"], "likes": 19, "viewed": 1431, "published": "Public API", "date": "1445501469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2015 Martin Rykfors\n// Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)\n// If you redistribute this work, please credit me by providing a link to https://www.shadertoy.com/user/ryk\nfloat time;\nvec2 size;\n#define PI 3.1415926535897\n#define Y_WALL 1.5\n#define Z_WALL 1.5\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415/180.;\n\tray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nfloat fan(vec2 p, float blur){\n    float y = p.y;\n    float rs = dot(p,p);\n    float arg = atan(p.y, p.x);\n    float f = 1. - smoothstep(1.-blur, 1.+blur, rs);\n    f *= smoothstep(0.02-blur/8., 0.02+blur/8., rs);\n    float period = 2.*PI/8.;\n    arg += time*2.;\n    arg += period;\n    arg = mod(arg, 2.*period);\n    arg -= period;\n    p = sqrt(rs) * vec2(cos(arg), sin(arg));\n    p -= vec2(0.55, 0.);\n    p *= vec2(1.9,6.5);\n    f *= smoothstep(1.-blur*4., 1.+blur*4., dot(p,p));\n    return f;\n}\n\nfloat intensity(vec3 pos,float bias){\n    float inside = (pos.y > -Y_WALL ? 1.: 0.) * (pos.z > -Z_WALL ? 1.: 0.);\n    pos.z -= 2.;\n    pos.z += pos.y/1.;\n    vec2 p = pos.xz;\n    float b = (pos.y + Y_WALL)/1.3 + bias;\n\n    return fan(p,b) * 0.03 * inside;\n}\n\nfloat renderFog(Ray ray){\n    float acc = 0.;\n    float dist = 0.;\n    vec3 pos;\n    for (int i = 0; i < 80; i++){\n        pos = ray.org + ray.dir*dist;\n        acc += intensity(pos, 1.0) * smoothstep(-Z_WALL, -Z_WALL+0.08, pos.z);\n        dist+=0.12;\n    }\n    return acc;\n}\n\nvec3 render(Ray ray){\n    float n = -dot(vec3(0.,1.,0.), ray.dir);\n    float delta = ray.org.y + Y_WALL;\n    float dist1 = delta/n;\n    dist1 = dist1 < 0. ? 100000. : dist1;\n    \n    n = -dot(vec3(0.,0.,1.), ray.dir);\n    delta = ray.org.z + Z_WALL;\n    float dist2 = delta/n;\n    dist2 = dist2 < 0. ? 100000. : dist2;\n    vec3 col;\n    if (dist1 < dist2){\n        vec3 pos = ray.org + ray.dir*dist1;\n        col = vec3(0.19,0.24,0.24)/(1.+sqrt(dist1/8.)) + intensity(pos+vec3(0.,0.0001,0.),0.02)*38.;\n    }\n    else{\n        vec3 pos = ray.org + ray.dir*dist2;\n        col = vec3(0.17,0.21,0.21)/(1.+sqrt(dist2/8.))+ intensity(pos+vec3(0.,0.,0.001),-0.9)*38.;\n    }\n    return col;\n}\n\nvec3 centerTrajectory(){\n    float t = sin(time/8.);\n    float at = atan(abs(t*4.));\n    t = sign(t)*at;\n    return vec3(0, t*2.8+0.0, -t*2.0 + 0.5);\n}\n\nvec3 cameraTrajectory(){\n    vec2 c = vec2(cos(time/4.), sin(time/4.));\n    c.y *= 2.5;\n    c.y += 4.5;\n    c.x *= 4.;\n    c.x += 1.;\n    return vec3(c,0.5);\n}\n\nvec4 mainRender(vec2 uv){\n   \n    vec2 p = uv*2. - 1.;\n    vec3 camPos = cameraTrajectory();\n    vec3 center = centerTrajectory();\n    vec3 up = vec3(0.,0.,1.);\n    Ray ray = createRay(camPos, center, up, uv, 90., size.x/size.y);\n\n    float fog = renderFog(ray);\n    vec3 fogCol = vec3(1.) * fog;\n\n    vec3 sceneCol = render(ray) + fogCol;\n    return vec4(sceneCol, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    size = iResolution.xy;\n    time = iTime + 15.;\n\tfragColor = mainRender(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjXz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[373, 373, 457, 457, 772], [774, 774, 804, 804, 1269], [1271, 1271, 1308, 1308, 1528], [1530, 1530, 1555, 1555, 1805], [1807, 1807, 1828, 1828, 2491], [2493, 2493, 2517, 2517, 2644], [2646, 2646, 2670, 2670, 2805], [2807, 2807, 2832, 2832, 3179], [3182, 3182, 3239, 3239, 3363]], "test": "valid"}
{"id": "XtSSRd", "name": "crowded leechs", "author": "FabriceNeyret2", "description": "one more variant of https://www.shadertoy.com/view/ltfXRM \n\n( \"if you can't draw a fish, draw some worms\" ;-) ).", "tags": ["3d", "raymarching", "spheremarching"], "likes": 3, "viewed": 990, "published": "Public API", "date": "1445706491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define r(v,t) v *= mat2( C = cos((t)*T), S = sin((t)*T), -S, C )\n\nfloat smin( float a, float b ) {\n    return min(a,b);\n/* #define N 8.\n    a = pow( max(0.,a), N ); b = pow( max(0.,b), N );\n    return pow( (a*b)/(a+b), 1./N );\n*/\n}\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    float T=iTime+5.;\n    f -= f;\n    float C,S,r,r1,x,x1,i0,a;\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,p2, u,t,t1,M,m; p.x-=.4; // init ray \n         \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5.*T;\n   \n    for (float i=1.; i>0.; i-=.01)  \n    { x = 1e3;\n     for(float j=0.; j<=1.; j++) {\n        u = floor(p/8.+11.5*j);                 // objects id + local frame\n        u = fract(1234.*sin(78.*(u+u.yzxw)));         // randomize ids\n        \n        p2 = p+11.5*j; \n         if (j==0.) p2.x -= 15.*T*(2.*u.y-1.);            // offset column\n         else       p2.y -= 15.*T*(2.*u.z-1.);    \n        u = floor(p2/8.); t = mod(p2, 8.)-4.;\n        u = fract(1234.*sin(78.*(u+u.yzxw)*vec4(1,-12,8,-4)));\n                 \n        t1 = t+1.5*sin(1.*T+u*6.);  \n        x1 = length(t .xyz*vec3(.25,1,1)-vec3(0,.1*sin(4.*t1.x+16.*T),0))-.5;    \n\n        x = smin(x,x1);\n        if(x<.01) break;   // hit !\n      }\n    \n        if(x<.01) {i0=i; break; }  // hit !\n    \n        p -= d*x;           // march ray\n     }\n    if(x<.01)  // hit !\n        { f = i0*i0*vec4(1.2,.4*u.x,.1,1)*(.5+.5*texture(iChannel0,.2*(t.xy+t.xz))); } // color texture + black fog \n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 184, 184, 317], [319, 319, 357, 357, 1623]], "test": "error"}
{"id": "XtSSRK", "name": "Another Cloudy Terrain", "author": "aiekick", "description": "Based on the [url=https://www.shadertoy.com/view/MljXDw]Cloudy Spikeball[/url] shader from duke\nand use the voronesque from shane\nuse mouse axis X to translate the cam horizontally\nthis shader use the code of my shader Subo Glacius", "tags": ["3d", "raymarching", "terrain", "cloud", "cloudy", "voronesque"], "likes": 37, "viewed": 1874, "published": "Public API", "date": "1444751222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n    \n/* \nBased on the Cloudy Spikeball shader from duke https://www.shadertoy.com/view/MljXDw \nand use the voronesque from shane\nuse mouse axis X to translate the cam horizontally\nthis shader use the code of my shader Subo Glacius\n*/\n\nconst vec2 RMPrec = vec2(.2, 0.01); \nconst vec2 DPrec = vec2(0.01, 50.); \n\nconst vec3 IceColor = vec3(0,.38,.47);\nconst vec3 DeepColor = vec3(0,.02,.15);\n\n/////////////////////////\n// FROM Shader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel1, (uv+ 0.5)/256.0, 0.0 ).yx;\n\trg = vec2(rg.x + rg.y)/2.;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p) \n{\n\treturn pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n/////////////////////////\n\nfloat disp(vec3 p)\n{\n    p *= 50.;\n    p.x+=iTime*50.;\n    return fpn(p) * .5;\n}\n\n// by shane from https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y);\n}\n\nvec2 map(vec3 p)\n{\n\tfloat voro = Voronesque(p);\n\tfloat tex = textureLod(iChannel0, p.xz/200.,0.0).r*12.;\n\treturn vec2(p.y - tex + voro + disp(p), 0.);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 si = iResolution.xy.xy;\n\tvec2 g = fragCoord.xy;\n   \tvec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(-11., 10., iTime);\n\tvec3 cv = vec3(0,0,1); \n    \n    vec4 f = vec4(0);\n\t\n    ro.x = -20.*iMouse.x/si.x;\n    \n   \tfloat vy = map(ro + cv).x;// cam h\n    \n    // smooth cam path\n\tconst int smoothIter = 8;\n\tfor (int i=0;i<smoothIter;i++)\n\tvy += map(ro + cv * float (i)).x;\n    vy /= float(smoothIter);\n    \n\tro.y -= vy * .78;\n    \n    vec3 rd = cam(uv, ro, cu, ro + cv);\n\t\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n\tfloat sgn = sign(map(p).x);\n    vec2 s = vec2(DPrec.y,0.);\n\t\n\tfloat h = 0.05;\n\tfloat td = 0.;\n\tfloat w = 0.;\n\tvec3 tc = IceColor;\n\t\n    for(int i=0;i<100;i++)\n\t{      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y||td>.95) break;\n\t\t\n        s = map(p);\n\t\ts.x *= (s.x>0.001?0.1:.2);\n\t\n\t\tif (s.x<h)\n\t\t{\n\t\t\tw = (1.-td) * (h-s.x);\n\t\t\ttc+=w;\n\t\t\ttd+=w;\n\t\t}\t\n\t\t\n\t\ttd+=0.005;\n        s.x = max(s.x, .03);\n        \n\t\td.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\n\tf.rgb = tc;\n\t\n\tf = mix( f, vec4(DeepColor, 1.), 1.2 - exp(-0.01*d.x*d.x) ); // fog\n    \n\tfragColor = f;\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSSRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[546, 654, 677, 677, 922], [924, 924, 944, 944, 1005], [1033, 1033, 1053, 1053, 1113], [1115, 1170, 1201, 1201, 1766], [1768, 1768, 1786, 1786, 1920], [1922, 1922, 1968, 1968, 2144], [2146, 2146, 2203, 2203, 3305]], "test": "error"}
{"id": "XtSXDw", "name": "Shinning Star", "author": "AlphaRogue", "description": "Pretty simple shinning star.", "tags": ["2d", "math", "star"], "likes": 4, "viewed": 208, "published": "Public", "date": "1443977520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 pixColor, in vec2 pixCoord) {\n    vec2 pos = pixCoord.xy / iResolution.xy - vec2(.5 + sin(iTime) / 4., .5 + cos(iTime) / 4.);\n    float curve = abs((sin(iTime * 1.5) / pos.x) * .00005 * pow(sin(iTime) * 5., 2.));\n    pixColor = vec4(pos.y > -curve && pos.y < curve ? smoothstep(curve, curve * .3, pos.y) * smoothstep(curve, curve * .3, -pos.y) : 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 376]], "test": "valid"}
{"id": "XtSXRV", "name": "dat ball", "author": "hexjayi", "description": "Shane's texture bump mapping on IQ's raymarching base code.", "tags": ["3d", "raymarch", "bumpmap"], "likes": 17, "viewed": 326, "published": "Public", "date": "1445079171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tToying with code from :\n\tShane's texture bump mapping -> https://www.shadertoy.com/view/MlXSWX\n\tIQ's raymarch code -> https://www.shadertoy.com/view/Xds3zN\n\tNimitz's fog -> https://www.shadertoy.com/view/4ts3z2\n\n\tThanks to Shane for the very useful help.\n*/\n\nmat3 rotate3(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat customShape( vec3 p, vec2 t )\n{\t// 3 torus with displacements\n  \tfloat t1 = length( vec2(length(p.xz)-t.x,p.y*0.2) )-t.y*cos(p.z*1.4);\n  \tfloat t2 = length( vec2(length(p.yx)-t.x,p.z*0.2) )-t.y*cos(p.x*1.4);\n  \tfloat t3 = length( vec2(length(p.zy)-t.x,p.x*0.2) )-t.y*cos(p.y*1.4);  \n  \treturn min(min(t1,t2),t3);\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.x += iTime*1.5;\n    p.z += sin(p.x*.5);\n    return triNoise3d(p*2.2/(d+20.),0.2)*(1.-smoothstep(0.,.7,p.y));\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .5;\n    for(int i=0; i<7; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n\t\tfloat grd =  clamp((rz - fogmap(pos+.8-float(i)*0.1,d))*3., 0.1, 1. );\n        vec3 col2 = (vec3(.1,0.1,.1)*.5 + .5*vec3(.1, .1, 0.1)*(1.7-grd))*0.55;\n        col = mix(col,col2,clamp(rz*smoothstep(d-0.4,d+2.+d*.75,mt),0.,1.) );\n        d *= 1.5+0.3;\n        if (d>mt)break;\n    }\n    return col;\n}\n\n//----------------------------------------------------------------------\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// from Shane : https://www.shadertoy.com/view/MlXSWX\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 p )\n{\n    float dist;\n    vec2 obj1, obj2, rmap;\n       \n   \tvec3 pr1 = rotate3(vec3(0.2,0.13,0.)*iTime*2.)*p;\n   \tvec3 pr2 = rotate3(vec3(-0.24,-0.13,1.1)*iTime)*p;    \n\n\tdist = sdSphere(pr1,0.8) ;\n    obj1 = vec2 ( dist, 1 );\n\n    dist = customShape( pr2-vec3( 0.0, 0.0, 0.0), vec2(1.3,0.1) );\n    obj2 = vec2 ( dist, 2 );\n    \n    rmap = opU(obj1,obj2);\n    return rmap;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmax = 20.0;  \n    float t = 1.;\n    float oid = -1.0;\n    \n    for( int i=0; i<550; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x< 0.001 || t>tmax ) break;\n        t += res.x;\n        oid = res.y; \n    }\n\n    if( t>tmax ) oid=-1.0;\n    return vec2(t,oid);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.);\n    vec2 res = castRay(ro,rd);\n    vec3 p = ro +rd*res.x;        \n    \n    if ( res.x < 20. ) \n    {\n        \n        vec3 n = calcNormal(p);\n        vec3 lightDir=normalize(vec3(1.,1.,-1.));\n        \n        vec3 light2Pos=vec3(2.,-1.,-4.);\n        vec3 light2Dir=normalize(light2Pos-p);\n\n        vec3 tex = vec3(0.);\n        mat3 rotMat = mat3( 0. );\n        if ( res.y == 1. ) // sphere\n        {\n            vec3 rotationValues = vec3(0.2,0.13,0.) * iTime*2.;\n            rotMat = rotate3( rotationValues );\n        \tp = rotMat * p;\n            n = rotMat * n;\n            \n            n = doBumpMap( iChannel1, p, n, 0.045);\n            tex = tex3D( iChannel1, p, n);\n        } else //( res.y == 2. ) // custom shape\n        {\n            vec3 rotationValues = vec3(-0.24,-0.13,1.1) * iTime; \n            rotMat = rotate3( rotationValues );\n        \tp = rotMat * p;\n            n = rotMat * n;\n        \n            n = doBumpMap( iChannel2, p, n, 0.045);\n            tex = tex3D( iChannel2, p, n);\n        }\n\t\t\n        lightDir = rotMat * lightDir;\n        light2Dir = rotMat * light2Dir;\n        float b=dot(lightDir,n);\n        float b2=dot(light2Dir,n);\n        col = vec3( (b+b2)*tex+pow( (b+b2)*0.5,9.0));    \n        \n    } else \n    {\n        col = vec3(0.,0.,0.);\n        p = mix(p,ro+rd*20.,exp(rd/20.));\n        vec3 btex = tex3D(iChannel1,p/20., -rd).xyz;\n        col = mix(col,btex,0.9);\n    }\n    \n    col = fog( col, ro, rd, 2.2);\n    \n \treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 4., 0., 0.);\n    \n\tvec3 ta = vec3( 0., 0., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.6) );\n\n   \t// vignetting from : https://www.shadertoy.com/view/4lSXDm\n   \tfloat falloff = 0.6;\n    float rf = sqrt(dot(p, p)) * falloff;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    \n\tfragColor = vec4(col * e * 1.3, 1.0);\n    \n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 290, 290, 579], [581, 581, 616, 616, 642], [644, 644, 681, 711, 964], [966, 966, 988, 988, 1013], [1014, 1014, 1035, 1035, 1115], [1198, 1198, 1241, 1241, 1541], [1543, 1543, 1580, 1580, 1697], [1699, 1699, 1759, 1759, 2177], [2179, 2252, 2274, 2274, 2318], [2320, 2320, 2370, 2370, 2566], [2568, 2622, 2695, 2695, 3159], [3161, 3161, 3191, 3191, 3224], [3226, 3226, 3249, 3249, 3619], [3621, 3621, 3653, 3653, 3873], [3875, 3875, 3915, 3915, 4200], [4202, 4202, 4241, 4241, 5761], [5763, 5763, 5815, 5815, 5992], [5994, 5994, 6051, 6051, 6783]], "test": "error"}
