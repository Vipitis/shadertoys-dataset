{"id": "4d3SWs", "name": "128-Bit 4-Color Sprites", "author": "Flyguy", "description": " Testing 128-bit multi-color spites which are packed into ivec4s utilizing all 32 bits of each integer component. Each sprite is 8x8 (64 pixels) and has 2 bits per pixel allowing for 4 colors per sprite pixel.", "tags": ["sprite", "bit", "integer"], "likes": 24, "viewed": 1025, "published": "Public API", "date": "1462248963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//128-bit, 4-Color sprites stored in ivec4s\n//This is very hacky and required alot of debugging just to get consistent results \n//between ANGLE and OpenGL on the same machine.\n//This only works on GPUs that support 32-bit integers in shaders.\n\n//Constants\n//Bits per pixel\n#define BPP 2\n//Bits per int\n#define BPI 32\n#define SPR_SIZE vec2(8, 8)\n\n//Derived constants\n#define PIXELS_PER_INT (BPI / BPP)\n\n//Macros\n//Define a 32-bit integer from high and low 16-bit parts.\n#define U32(h,l) (h*0x10000+l)\n\n//Define a sprite row by row.\n#define SPRITE(r0,r1,r2,r3,r4,r5,r6,r7) uvec4(U32(r0,r1),U32(r2,r3),U32(r4,r5),U32(r6,r7))\n\n//Sprite data (Generated with a custom image converter)\n//Pixel layout:\n/*\nBlock sprite:\n\n   Row:0      1      2      3      4      5      6      7 \nSPRITE(0xFFFE,0xEAA9,0xE569,0xE6B9,0xE6B9,0xEBF9,0xEAA9,0x9555)\n         ^                                                   ^\n         Top Left                                            Bottom Right\n\nEach hex digit defines 4 bits which defines 2 pixels @ 2 BPP.\nex.\n0xEAA9\nE    A    A    9\n1110 1010 1010 1001\n\n11 10 10 10 10 10 10 01\n|/ |/ |/ |/ |/ |/ |/ |/\n3  2  2  2  2  2  2  1  <- Pixel values/palette indexes.\n*/\n#define block   SPRITE(0xFFFE,0xEAA9,0xE569,0xE6B9,0xE6B9,0xEBF9,0xEAA9,0x9555)\n#define brckl   SPRITE(0x6FFF,0xBAAA,0xEAAA,0xEAAA,0xEAAA,0xAAAA,0x6AAA,0x5555)\n#define brckr   SPRITE(0xFFE5,0xAAA9,0xAAA9,0xAAA9,0xAAA9,0xAAA9,0xAAA5,0x5555)\n#define ball_01 SPRITE(0x0002,0x006A,0x019A,0x066A,0x1599,0x196A,0x1599,0x5966)\n#define ball_11 SPRITE(0x8000,0xAF00,0xBBC0,0xAFF0,0xBBFC,0xAEEC,0xABB8,0xAAAA)\n#define ball_00 SPRITE(0x5559,0x1596,0x1565,0x1559,0x0555,0x0155,0x0055,0x0001)\n#define ball_10 SPRITE(0x99AA,0x6AA8,0x9998,0x6664,0x5590,0x9940,0x5500,0x4000)\n#define ball_sm SPRITE(0x0AA0,0x26B8,0x5AFE,0x66BA,0x59AA,0x5666,0x1598,0x0550)\n\nfloat tau = atan(1.0)*8.0;\n\n//Blends 'b' with 'a' using b's alpha.\nvec4 blend(vec4 a, vec4 b)\n{\n\treturn mix(a, b, b.a);   \n}\n\n//Extract pixel 'p' from a 32-bit integer 'n'\n//Returns a normalized value (0-1) within the pixel's range (2^BPP - 1).\nfloat pixel(uint n, int p)\n{\n    if(p >= 0 && p < PIXELS_PER_INT)\n    {   \n        uint range = (1u << BPP) - 1u;\n        \n        n = (n >> (p * BPP)) & range;\n        \n        return float(n) / float(range);\n    }\n    return 0.0;\n}\n\n//8x8 Sprite\nfloat sprite8(uvec4 data, vec2 uv)\n{\n    uv = floor(uv);    \n    uv.x = SPR_SIZE.x - 1.0 - uv.x;\n    \n  \t//Calculate which pixel to extract & which component its in.\t  \n\tint idx = int(uv.y * SPR_SIZE.x + uv.x);\n    int com = idx / PIXELS_PER_INT;\n    idx = idx % PIXELS_PER_INT;\n    \n  \t//Clipping bounds  \n    float clip = float(all(greaterThan(uv, vec2(-1))) && all(lessThan(uv, SPR_SIZE)));\n    \n    return pixel(data[3 - com], idx) * clip;\n}\n\n//16x16 Sprite (4 8x8 sprites)\n//Data layout:\n//d2,d3\n//d0,d1\nfloat sprite16(uvec4 d0, uvec4 d1, uvec4 d2, uvec4 d3, vec2 uv)\n{\n\tvec2 uvt = floor(uv / SPR_SIZE);\n    vec2 uvs = mod(uv, SPR_SIZE);\n    \n    uvec4 cdata = (uvt == vec2(0,0)) ? d0 :\n\t\t\t\t  (uvt == vec2(1,0)) ? d1 :\n    \t\t\t  (uvt == vec2(0,1)) ? d2 :\n    \t\t\t  (uvt == vec2(1,1)) ? d3 : uvec4(0);\n    \n    return sprite8(cdata, uvs);\n}\n\n//4-Color custom palette.\nvec4 pal_0(float x)\n{\n     vec4 a = vec4(0.00, 0.00, 0.00, 0.00);\n     vec4 b = vec4(0.20, 0.20, 0.20, 1.00);\n     vec4 c = vec4(0.40, 0.40, 0.40, 1.00);\n     vec4 d = vec4(0.60, 0.60, 0.60, 1.00);\n    \n\t return (x < 0.25) ? a : \n         \t(x < 0.50) ? b : \n    \t\t(x < 0.75) ? c : \n    \t\t(x < 1.00) ? d : d; \n}\n\n//4-Color 'shade' palette. \nvec4 pal_sh(float x, vec3 col)\n{\n     vec4 a = vec4(0);\n     vec4 b = vec4(col * 0.33, 1.00);\n     vec4 c = vec4(col * 0.66, 1.00);\n     vec4 d = vec4(col * 0.50 + 0.50, 1.00);\n    \n\t return (x < 0.25) ? a : \n         \t(x < 0.50) ? b : \n    \t\t(x < 0.75) ? c : \n    \t\t(x < 1.00) ? d : d; \n}\n\n//Background tiles\nvec4 background(vec2 uv, vec2 res)\n{\n    vec2 uvt = floor(uv / SPR_SIZE);\n    vec2 uvs = mod(uv, SPR_SIZE);\n    \n    uvec4 data = uvec4(0);\n    \n    //Checkerboard of left/right brick sprites making a staggered brick pattern.\n    data = (mod(uvt.x + uvt.y, 2.0) == 0.0) ? brckl : brckr;\n    \n    res /= SPR_SIZE;\n    \n    //Border\n    if(uvt.x <= 1.0 || uvt.y <= 1.0 || uvt.x >= res.x - 2.0 || uvt.y >= res.y - 2.0)\n    {\n     \tdata = block;\n    }\n    \n    return pal_0(sprite8(data, uvs));\n}\n\n//Moving sprites\nvec4 sprites(vec2 uv, vec2 res)\n{\n    float idx = 0.0;\n    vec4 c = vec4(0);\n    \n    vec2 uvs = uv;\n    vec2 off = vec2(0);\n    uvs -= floor(res/2.0);\n    uvs += 8.5;\n    \n    float a = iTime * 2.0;\n    float rad = 32.0;\n    \n    //Red ball\n    off = floor(vec2(cos(a),sin(a)) * rad);\n    \n    idx = sprite16(ball_00, ball_10, ball_01, ball_11, uvs - off);\n    c = blend(c, pal_sh(idx, vec3(1,0,0)));\n\t\n    //Green ball\n    a -= tau / 3.0;\n    off = floor(vec2(cos(a),sin(a)) * rad);\n    \n    idx = sprite16(ball_00, ball_10, ball_01, ball_11, uvs - off);\n    c = blend(c, pal_sh(idx, vec3(0,1,0)));\n    \n    //Blue ball\n    a -= tau / 3.0;\n    off = floor(vec2(cos(a),sin(a)) * rad);\n    \n    idx = sprite16(ball_00, ball_10, ball_01, ball_11, uvs - off);\n    c = blend(c, pal_sh(idx, vec3(0,0.5,1)));\n    \n    //Yellow ball\n    idx = sprite8(ball_sm, uvs - 4.0);\n    c = blend(c, pal_sh(idx, vec3(1,1,0)));\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv = floor(uv / 2.0);\n    vec2 res = iResolution.xy / 2.0;\n      \n    vec4 back = background(uv, res);\n    vec4 spri = sprites(uv, res);\n    \n    vec4 c = mix(back, spri, spri.a);\n    \n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3SWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1862, 1901, 1929, 1929, 1958], [1960, 2079, 2107, 2107, 2312], [2314, 2327, 2363, 2363, 2772], [2774, 2836, 2901, 2901, 3169], [3171, 3197, 3218, 3218, 3507], [3509, 3537, 3569, 3569, 3826], [3828, 3847, 3883, 3883, 4339], [4341, 4358, 4391, 4391, 5288], [5290, 5290, 5347, 5347, 5585]], "test": "valid"}
{"id": "4dcSR2", "name": "wolf 3D", "author": "Natthan", "description": ".", "tags": ["wolf"], "likes": 0, "viewed": 138, "published": "Public", "date": "1463762094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI (3.1415926535897932384626433832795028841971693993751058209749445923078164062862)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(sin(iTime),\n                     sin(iTime + 2. /3. * PI),\n                     sin(iTime + 4. /3. * PI), 1);\n   \n    /*fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 150, 150, 379]], "test": "valid"}
{"id": "4ddXDs", "name": "G-Lectric Sheep 16", "author": "vox", "description": "G-Lectric Sheep 16", "tags": ["glectricsheep16"], "likes": 1, "viewed": 529, "published": "Public API", "date": "1462222381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E))*10.0;\n\tvec2 b = sin(seedling+vec2(time, time*GR/E))*10.0;\n\tvec2 c = sin(seedling+vec2(time, time*GR/E))*10.0;\n\tvec2 d = sin(seedling+vec2(time, time*GR/E))*10.0;\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    vec2 mob = mobius(zoom*(uv*2.0-1.0));\n    \n    return (mob*2.0*PI);\n}\n\nvec2 spiral(vec2 uv)\n{\n    return (1.0-saw(PI*(uv*.5+.5)));\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i = 1;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float ifsSqrt = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        \n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        \n        float weight = ifs;\n        \n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        ifsSqrt = sqrt(ifs);\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        float delta = sphereN(uv*2.0-1.0).z*ifsSqrt;\n        depth += (1.0-delta)*ifs;\n        \n\t\tif(ifs != 0.0)\n        {\n            uv = spiral(uv*2.0-1.0);//*clamp(pow(delta, SPIRAL_BLUR_SCALAR)*2.0, 0.0, 1.0);\n        }\n        \n        ifs = ifsSqrt;\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*PI*5.0*ifs*(sin(time)+2.0);\n    float black = saw(atan(uv.y*2.0-1.0, uv.x*2.0-1.0));//sqrt(smoothstep(0.0, .25, saw(stripes)));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(saw(depth*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[745, 745, 774, 774, 844], [846, 846, 875, 875, 959], [1037, 1037, 1059, 1059, 1317], [1319, 1319, 1338, 1338, 1412], [1414, 1414, 1436, 1436, 1475], [1477, 1477, 1536, 1536, 2109], [2111, 2111, 2168, 2168, 3868]], "test": "valid"}
{"id": "4ddXWs", "name": "Reflections Testings", "author": "gsitcia", "description": "Had to figure out another different way to do lighting.... at least reflections work now.", "tags": ["raytracing"], "likes": 3, "viewed": 170, "published": "Public", "date": "1462203003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rpBox( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox( p, vec3(0.5, 0.5, 0.5) );\n}\n\nfloat sdPlane( vec3 p )\n{\n  // n must be normalized\n  return p.y;\n}\n\nfloat omap( vec3 p ) {\n    float d1 = sdPlane( p );\n    float d2 = sdSphere( p - vec3(0.0, 0.5, 0.0), 1.0);\n    float d3 = udBox( p - vec3(-1.0, 1.0, 0.0), vec3(1.7, 2.0, 2.0) );\n    float d4 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5);\n    return min(max(-d2, max(d3, d4)), d1);\n}\n\nfloat map( vec3 p ) {\n    float d1 = sdPlane(p);\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) );\n    float d3 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5);\n    return min(min(d1, d3), d2);\n}\n\nvec3 cmap( vec3 p ) {\n    float d1 = sdPlane(p); // White\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) ); // Dark Gray\n    float d3 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5); // Barely White\n    float z = min(d1, d2);\n    z = min(z, d3);\n    if (z == d1) {\n        return vec3(1.0, 0.5, 0.3);\n    }\n    if (z == d2) {\n        return vec3(0.1, 0.3, 0.1);\n    }\n    if (z == d3) {\n        return vec3(0.9, 0.9, 0.7);\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nbool rmap( vec3 p ) {\n    float d1 = sdPlane(p); // Not Reflective\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) ); // Reflective\n    float d3 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5); // Not Reflective\n    float z = min(d1, d2);\n    z = min(z, d3);\n    if (z == d3) {\n        return true;\n    }\n    return false;\n}\n    \nvec3 norm( vec3 p ) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fr = vec3(0.0, 0.0, 1.0);\n    vec3 rt = vec3(1.0, 0.0, 0.0);\n    \n    float mp = map(p);\n    float mu = map(p + mp * up)/mp;\n    float md = map(p - mp * up)/mp;\n    float mr = map(p + mp * rt)/mp;\n    float ml = map(p - mp * rt)/mp;\n    float mf = map(p + mp * fr)/mp;\n    float mb = map(p - mp * fr)/mp;\n    \n    float k;\n    \n    k = 2.0 / (mu + md);\n    \n    mu *= k;\n    md *= k;\n    \n    k = 2.0 / (mr + ml);\n    \n    mr *= k;\n    ml *= k;\n    \n    k = 2.0 / (mf + mb);\n    \n    mf *= k;\n    mb *= k;\n    \n    float ud = sqrt(1.0 - mu*md);\n    float rl = sqrt(1.0 - mr*ml);\n    float fb = sqrt(1.0 - mf*mb);\n    \n    vec3 fv = vec3(0.0, 0.0, 0.0);\n    \n    if (mu > md) {\n        fv += ud * up;\n    } else {\n        fv -= ud * up;\n    }\n    \n    if (mr > ml) {\n        fv += rl * rt;\n    } else {\n        fv -= rl * rt;\n    }\n    \n    if (mf > mb) {\n        fv += fb * fr;\n    } else {\n        fv -= fb * fr;\n    }\n    \n    return fv;\n}\n\nvec3 normc( vec3 p ) {\n    float dt = 0.5*map(p);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fr = vec3(0.0, 0.0, 1.0);\n    vec3 rt = vec3(1.0, 0.0, 0.0);\n    \n    vec3 n1 = norm(p);\n    vec3 n2 = norm(p+dt*up);\n    vec3 n3 = norm(p-dt*up);\n    vec3 n4 = norm(p+dt*fr);\n    vec3 n5 = norm(p-dt*fr);\n    vec3 n6 = norm(p+dt*rt);\n    vec3 n7 = norm(p-dt*rt);\n    \n   \tvec3 n = (n1 + n2 + n3 + n4 + n5 + n6 + n7) / 7.0;\n    \n    return n;\n}\n\nfloat shadow( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    float dst = 0.0;\n    float res = 1.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.8;\n        dst += dt * 0.8;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, p) < 0.001) {\n                return res;\n            } else {\n            \treturn 0.0;\n            }\n        }\n        res = min(res, 4.0 * dt * dst / length(p - l.xyz));\n    }\n    return res * l.w;\n}\n\nfloat shadown( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    vec3 orig = l.xyz;\n    float dst = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.8;\n        dst += dt * 0.8;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, orig) < 0.0001) {\n                return 0.0;\n            } else {\n                return 1.0;\n            }\n        }\n    }\n    return 0.0;\n}\n\nvec3 lights( vec3 p, vec4 l, vec4 ldir, vec3 lc ) {\n    vec3 ld = normalize(l.xyz - p);\n    vec3 ds = norm(p);\n    float li = dot(ds, ld);\n    vec3 c = cmap(p);\n    c.x *= lc.x;\n    c.y *= lc.y;\n    c.z *= lc.z;\n   \treturn c * li * l.w * pow(clamp(ldir.w/distance(ld, ldir.xyz), 0.0, 1.0), 1.0/ldir.w);\n    /*if (distance(ld, ldir.xyz) < ldir.w) {\n    \treturn cmap(p) * li * l.w;\n    } else {\n        return vec3(0.03, 0.03, 0.03);\n    }*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 id = vec3(1.0, 1.0, 1.0);\n    \n    float mindist = min(iResolution.x, iResolution.y);\n    \n    vec3 uv = vec3((gl_FragCoord.xy - iResolution.xy / 2.0) / mindist, 0.0);\n    \n    // vec3 eye = vec3((2.0 * (iMouse.xy - iResolution.xy / 2.0) / mindist) + vec2(0.0, 1.0), -2.5);\n    \n    vec3 eye = vec3(3.0 * sin(iMouse.x * 3.141592 / 360.0), (iResolution.y - iMouse.y) / 45.0 , 3.0 * cos(iMouse.x * 3.141592 / 360.0));\n    \n    float fl = 1.0;\n    \n    vec3 fo = normalize(-1.0 * eye);\n    \n    // vec3 up = normalize(vec3(0.0, 1.0, 0.0)); // 2 point perspective\n    \n    vec3 up;\n    \n    vec4 light = vec4(3.0 * sin(iTime * 3.141592 / 45.0), 3.0, 3.0  * cos(iTime * 3.141592 / 45.0), 10.0);\n    \n    vec4 lightdir = vec4(normalize(-1.0 * light.xyz), 0.7);\n    \n    vec3 lightcolor = vec3(0.9, 0.9, 1.0);\n    \n    up.xz = -1.0 * fo.xz;\n    \n    up.xz *= fo.y / length(fo.xz);\n    \n    up.y = length(fo.xz); // 3 point perspective\n    \n    vec3 si = cross(up, fo);\n    \n    uv = eye + fl * fo + uv.x * si + uv.y * up;\n    \n    vec3 dr = uv - eye;\n    \n    uv = eye;\n    \n    dr = dr / length(dr);\n    \n    float dt = 0.0;\n    \n    for (int i = 0; i < 1000; ++i) {\n        dt = map( uv );\n        if (dt < 0.0001) {\n            dt = float(i);\n            break;\n        }\n        uv = uv + dr * dt * 0.8;\n    }\n    \n    // reflect\n    \n    vec4 rf = vec4(shadow( uv, light ) * lights( uv, light, lightdir, lightcolor ), 1.0);\n    \n    if (rmap(uv)) {\n    \tfloat dt = 0.01;\n        \n        vec3 ds = norm(uv);\n    \t\n    \tdr = -1.0 * dr;\n        \n        ds *= dot(ds, dr);\n        \n        vec3 q = ds - dr;\n        \n        dr += 2.0 * q;\n        \n        for (int i = 0; i < 100; ++i) {\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n            if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t}\n        rf.w = 0.9;\n    }\n    \n    if (rmap(uv)) {\n    \tfloat dt = 0.01;\n        \n        vec3 ds = norm(uv);\n    \t\n    \tdr = -1.0 * dr;\n        \n        ds *= dot(ds, dr);\n        \n        vec3 q = ds - dr;\n        \n        dr += 2.0 * q;\n        \n        for (int i = 0; i < 100; ++i) {\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n            if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t}\n        rf.w = 0.9;\n    }\n    \n    if (rmap(uv)) {\n    \tfloat dt = 0.01;\n        \n        vec3 ds = norm(uv);\n    \t\n    \tdr = -1.0 * dr;\n        \n        ds *= dot(ds, dr);\n        \n        vec3 q = ds - dr;\n        \n        dr += 2.0 * q;\n        \n        for (int i = 0; i < 100; ++i) {\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n            if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t}\n        rf.w = 0.9;\n    }\n    \n    \n    \n    // vec3 dc = vec3(dt, dt, dt) / 50.0;\n   \t\n    /* if (dt == 100.0) {\n       \tdc = vec3(0.0, 1.0, 0.5);\n    } else {\n        dc = vec3(dt, dt, dt) / 50.0;\n    } */\n    \n    vec3 dc = shadow( uv, light ) * lights( uv, light, lightdir, lightcolor );\n    \n    dc = rf.w*dc + (1.0 - rf.w)*rf.xyz;\n    \n    fragColor = vec4(dc, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 59], [61, 61, 92, 92, 130], [132, 132, 164, 192, 253], [255, 255, 288, 288, 353], [355, 355, 386, 386, 461], [463, 463, 488, 514, 530], [532, 532, 554, 554, 811], [813, 813, 834, 834, 1022], [1024, 1024, 1045, 1045, 1500], [1502, 1502, 1523, 1523, 1839], [1845, 1845, 1866, 1866, 2852], [2854, 2854, 2876, 2876, 3296], [3298, 3298, 3330, 3330, 3793], [3795, 3795, 3828, 3828, 4234], [4236, 4236, 4287, 4287, 4677], [4679, 4679, 4736, 4736, 7857]], "test": "valid"}
{"id": "4dGSDh", "name": "Basic Gaussian Grid", "author": "myke", "description": "Basic 2D tron looking grid using gaussian, still need to figure out intersections\n", "tags": ["2d", "grid", "blur", "line", "gaussian"], "likes": 3, "viewed": 333, "published": "Public", "date": "1463953404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p2 = 3.14159265359 * 2.0;\n    float t = float(iTime);\n    float rot = mod(t * 0.03, p2);\n    float glow = 0.3 * sin(mod(t * 4.0 - 1.5, p2)) + 0.2 * sin(mod(t * 2.0, p2));\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    float width = 150.0;\n    float gridspace = 10.0;\n    vec2 step = vec2((iResolution.x + iResolution.y) / 2.0 / gridspace);\n    vec2 rotfrag = fragCoord * rotate2d(rot);\n    vec2 relpos = mod(rotfrag, step) - step / 2.0;\n    vec2 g1 = (glow + vec2(2.0)) * 0.3 * exp(-1.0 * relpos * relpos / width); \n    vec2 g2 = 2.0 * exp(-1.0 * relpos * relpos / 2.0); \n  \n    float o1 = max(g1.x, g1.y);\n    float o2 = max(g2.x, g2.y);  // gives a weird X effect at intersections\n     //float o = max(g2.x + g2.y, min(0.5, g1.x + g1.y));  // overly bright spot at intersections\n    \n    fragColor = vec4(0.3, 0.0, 0.7, 0.0) * o1 + vec4(-0.3, 1.0, -0.5, 1.0) * o2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [116, 116, 173, 173, 1052]], "test": "valid"}
{"id": "4dGXR1", "name": "007 shutter", "author": "FabriceNeyret2", "description": "007's like camera shutter", "tags": ["2d"], "likes": 7, "viewed": 659, "published": "Public API", "date": "1462716743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R = iResolution.xy;\n    U = (U+U-R)/R.y;\n    \n    O = texture(iChannel0,.5+.5*U);\n    \n    float N = 12., c = cos(6.28/N),s=sin(6.28/N),\n          a = 3.14/4.*(.5+.5*sin(iTime)),d,A;\n    \n    for (int i=0; i<20; i++) {\n        d = -dot(U-vec2(-1,1),vec2(sin(a),cos(a)));\n        A = smoothstep(.01,0.,d);\n        O.rgb += (1.-O.w) * A * vec3(1.-4.*smoothstep(.01,0.,abs(d)));\n        O.w = A;\n        U *= mat2(c,-s,s,c);\n    }\n    O *= smoothstep(1.,.99,length(U));\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 513]], "test": "error"}
{"id": "4dGXRm", "name": "color keeping tonemap", "author": "nikq", "description": "HDR colors should be tonemapped.\nSimple linear tonemap kills color in brighter pixel.\nThis tonemap keeps color instead of losing luminance.", "tags": ["tonemap"], "likes": 4, "viewed": 198, "published": "Public", "date": "1463403361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    // https://www.shadertoy.com/view/XlfGDN\n    return mix(vec3(1.),clamp((abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),c.y)*c.z;\n}\n\nvec3 rgb_clamp( vec3 rgb )\n{\n    return vec3( \n        rgb.x > 1. ? 1. : rgb.x,       \n        rgb.y > 1. ? 1. : rgb.y,\n       \trgb.z > 1. ? 1. : rgb.z );\n                \n}\n\n// keep color vibrant\nvec3 rgb_clamp2( vec3 rgb )\n{\n\tfloat max = max( rgb.x, max( rgb.y, rgb.z ) );\n    return (max > 1.0) ? rgb / max : rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime / 10.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse / iResolution.xxxx;\n\n    if( uv.y > 0.5 )\n    {\n\t    vec3 hsv = vec3( time - floor(time), (uv.y-0.5)*2., uv.x * 2. );\n\t    vec3 rgb = hsv2rgb( hsv );\n        fragColor = vec4( rgb_clamp(rgb), 1. );\n    }\n    else\n    {\n\t    vec3 hsv = vec3( time - floor(time), (uv.y)*2., uv.x * 2. );\n\t    vec3 rgb = hsv2rgb( hsv );\n        vec3 c1 = rgb_clamp( rgb );\n        vec3 c2 = rgb_clamp2( rgb );\n        fragColor = vec4( mix(c1,c2,m.x), 1. );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 67, 158], [160, 160, 188, 188, 333], [335, 357, 386, 386, 478], [481, 481, 538, 538, 1076]], "test": "valid"}
{"id": "4dGXW1", "name": "Anti-Aliasing Compare", "author": "JasonD", "description": "ANTI-ALIASING:\n- = none\nQC = nVidia quincunx\n2x = 2x2 \n3D = 3Dfx rotate grid\nNx = 4x4\nR1 = rand 8x8\nR2 = rand 8x8 dynamic\n\nCONTROL\nMouse click and move:\nleft/right = move split screen (AA methods: left to right)\nup/down = change zoom factor", "tags": ["antialiasing", "random", "quincunx", "supersample", "3dfx", "2x2", "compare", "nxn"], "likes": 37, "viewed": 1453, "published": "Public", "date": "1463977610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Anti-Aliasing Tests - rev. 53J\n   May 21 - June 5, 2016\n\n   Authors: \n     Jason Doucette:    https://www.shadertoy.com/user/JasonD        \n                        http://xona.com/jason/\n     Michael Pohoreski: https://www.shadertoy.com/user/MichaelPohoreski\n\n  Methods:                       # Samples:\n  ----------------------------------------------\n  1. none                        1\n  2. nVidia Quincunx             2\n  3. standard 2x2 supersample    4\n  4. 3Dfx rotated grid           4\n  5. standard NxN supersample    4^2 (*N^2 set in #define METHOD_NXN_N     below)\n  6. random supersample static   8^2 (*N^2 set in #define METHOD_RND_NXN_N below)\n  7. random supersample dynamic  8^2 (*N^2 set in #define METHOD_RND_NXN_N below)\n*/\n\n\n// ---- MAIN SETTINGS --------------------------------\n\n// see Note 5 and 6 above:\n#define METHOD_NXN_N     4 \n#define METHOD_RND_NXN_N 8\n//  4x 4 =   16 samples\n//  8x 8 =   64 samples\n// 16x16 =  256 samples\n// 32x32 = 1024 samples\n\n#define GAMMA_CORRECTION 2.2\n// check your monitor gamma here:  https://www.shadertoy.com/view/ldVSD1\n\n// (NOTE: More internal settings are listed much further below.)\n\n\n// ---- METHOD EXPLANATIONS --------------------------------\n/*\n\n======== 1. none ========\n\nA single sample is used from the pixel's center:\n\n+------+------+\n|             |        \n|             |\n|             |\n+      X      +  <--- X marks the spot\n|             |\n|             |\n|             |        \n+------+------+\n\n\n======== 2. nVidia Quincunx ========\n\n5 samples are used:\n- 1 in the center\n- 4 at the corners of the pixel, which are shared with 3 other pixels (4 in total).\nThe result is that only 2 samples per pixel need to be taken\n\nX------+------X  <--- note the samples from ALL FOUR corners\n|             |        \n|             |\n|             |\n+      X      +\n|             |\n|             |\n|             |        \nX------+------X  <---- they are shared with adjacent pixels\n|             |        \n|             |\n|             |\n+      X  <- -+- - - - weight = 1/2 = 50%\n|             |\n|             |\n|             |        \nX------+------X < - - - weight = 1/8 = 12.5%\n\nThis is essentiall a blur.\n\n\n\n======== 3. standard 2x2 supersample ========\n\n4 samples are taken within a pixel,\nequi-distance from each other,\nand from samples from adjacent pixels\n\n+------+------+\n|      |      |        \n|  x       x  |\n|      |      |\n+ - - - - - - +\n|      |      |\n|  x       x  |\n|      |      |        \n+------+------+\n\n\n======== 4. 3Dfx rotated grid ========\n\n4 samples are taken within a pixel.\nequi-distance from each other,\nand from samples from adjacent pixels\n\n^^^ SOUND FAMILIAR? ^^^\n    Yup, it's very much like 2x2,\n\n    EXCEPT....\n\nThe pixel grid is rotated:\n\n+------+------+\n|    X-| - - -| - - - - }\n|             |         } dy = constant\n|      |    X | - -}- - }\n+ - - - - - - +    } dy\n| X- - | - - -|- - }- }\n|             |       } dy\n|      | X - -| - - - }       \n+------+------+\n  ^  ^   ^  ^\n  |  |   |  |\n  |  -----  |\n  |  |dx |  |\n  |  |   ----\n  ----     dx = constant\n\n     dx = dy\n\n3Dfx rotation angle is such that the four points are \nEQUI-DISTANCE from each other IN BOTH ORTHOGONAL DIRECTIONS.\n\nThus, when a near horizontal or near vertical plane moves \nthrough the pixel, instead of seeing 2 steps (as in a 2x2 AA):\n(step 1 = passing through the top    (or right) two samples)\n(step 2 = passing through the bottom (or left)  two samples)\n\nYou will see 4 steps:\n(step 1 = passing through the first sample)\n(step 2 = passing through the second sample)\n(step 3 = passing through the third sample)\n(step 4 = passing through the fourth sample)\n\nThis is maximum possible steps!  4 steps for 4 samples.\n\n\nMATHEMATICS FOR THE ANGLE:\n\nIt's not so hard.\nPicture the bottom & right dots, and make a right triangle:\n\n    X\n   /|\n  / o\n /  |\n X--o\n\nThe angle is within a triangle of:\n- oppsite side = exactly 2x length of adjacent.\n\n tan( angle ) =    opp / adj\n tan( angle ) =      1 / 2\n      angle   = atan(1 / 2)\n              = 26.5650512 degrees \n              = 0.46364760 radians\n\n\nHARD CODE THE RESULT FOR SPEED:\n\nRotate a point (0.25, 0.25), from the 2x2,\nby 26.5650512 degrees:\n    \n    vec2 p = rotateX( \n        vec2(0.25, 0.25),  \n        0.463647609 );  // radians (26.5650512 degrees)\n\nResult = (x,y) = 0.11218413712, 0.33528304367\n               =     small    ,     large\n\nThe 4 resultant dots (rotated 26.5 degrees clockwise) are:\n 1. -small, +large\n 2. +large, +small\n 3. +small, -large\n 4. -large, -small\n\n\n======== 5. standard NxN supersample ========\n\nSubdivides the pixel by N in both directions.\nFor N = 4:\n\n+------+------+\n| X  X | X  X |        \n|             |\n| X  X | X  X |\n+ - - - - - - +\n| X  X | X  X |        \n|             |\n| X  X | X  X |\n+------+------+\n\n\n======== 6. & 7. random supersample ========\n\nSame as NxX, except it's random.\n6. This could be static, which avoids moire patterns.\n7. However, this should CHANGE EVERY FRAME, to produce random photons reaching your eye.\n   Thus, this should run at the HIGHEST FRAME-RATE for best results:\n\n+-X----+---X--+\nX    X | X    |        \n| X    X      X\n|   X  |   X  |\n+ - - - -X- - +\nX  X   |    X |        \n|    X   X    |\n| X    |   X  X\nX----X-+-X----+\n\n\n\n======== 8. ADDITIONAL METHODS: EXERCISE FOR THE READER :) ========\n\n-\tmake a higher sample rate for 3Dfx's method, say a 4x4 grid!\n-\tcompare identical sample numbers, say 4x4 square vs. 4x4 random.\n\n*/\n\n\n// ---- INTERNAL SETTINGS --------------------------------\n\n// pattern 1:\n#define CIRCLE_PERCENTAGE_OF_SCREEN 0.90\n// these should be integers:\n#define MIN_ZOOM 1.0\n#define MAX_ZOOM 8.0\n// colors:\n#define BG_COLOR         vec3( 0.8, 1.0, 0.8 )\n#define COLOR_TITLE      vec3( 0.0, 0.3, 1.0 )\n#define COLOR_ZOOM       vec3( 0.8, 0.0, 0.8 )\n#define COLOR_EQUALS     vec3( 0.0, 0.0, 0.0 )\n#define COLOR_ZOOMFACTOR vec3( 1.0, 0.0, 0.0 )\n\n\n// ---- GLOBALS --------------------------------\n\n    // TODO -- could prefix these with \"g\" or \"g_\"\n\n    #define PI 3.1415926535897932384626\n    \n    // quantized zoom:\n    float ZOOM;\n\n    // ORIGINAL positions BEFORE zoom:\n    vec2 origM; // 0..1 (mouse)\n    vec2 origP; // 0..1 (pixel position)\n\n    // MODIFIED based on quantized zoom, used in many functions:\n    vec2  res; // resolution\n    vec2  mou; // mouse coordinates\n\n\n// ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ----\n// ---- GLSL NUMBER PRINTING --------------------------------\n// ---- @P_Malin --------------------------------\n\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nconst vec2 gvFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n\nfloat DigitBin(const in int x)\n{\n    if (x < 9) // NOTE: Not using 9\n        return\n           x==0 ? 480599.0\n          :x==1 ? 143906.0 // Note: Original '1' without top-left serif: 139810.0\n          :x==2 ? 476951.0\n          :x==3 ? 476999.0\n          :x==4 ? 350020.0\n          :x==5 ? 464711.0\n          :x==6 ? 464727.0\n          :x==7 ? 476228.0\n          :/* 8*/ 481111.0;\n    else\n    if (x < 91)\n        return // only include glyphs actually need to minimize the shader complexity\n           x==42 ?  21072.0 // *\n          :x==45 ?   3840.0 // -\n          :x==61 ?  61680.0 // =\n          :x==67 ? 921886.0 // C\n          :x==68 ? 498071.0 // D\n          :x==78 ? 638361.0 // N\n          :x==81 ? 432606.0 // Q\n          :x==82 ? 497561.0 // R\n          :/* 90*/ 475671.0;// Z\n/*\n    if (x < 10)\n        return // originals glyphs\n           x==0 ? 480599.0\n          :x==1 ? 143906.0 // Note: Original '1' without top-left serif: 139810.0\n          :x==2 ? 476951.0\n          :x==3 ? 476999.0\n          :x==4 ? 350020.0\n          :x==5 ? 464711.0\n          :x==6 ? 464727.0\n          :x==7 ? 476228.0\n          :x==8   481111.0\n          :       481095.0;\n    if (x < 78)\n        return // Glyphs added by Michael Pohoreski\n           x==42 ?  21072.0 // *\n          :x==45 ?   3840.0 // -\n          :x==61 ?  61680.0 // =\n          :x==65 ? 434073.0 // A\n          :x==66 ? 497559.0 // B\n          :x==67 ? 921886.0 // C\n          :x==68 ? 498071.0 // D\n          :x==69 ? 988959.0 // E\n          :x==70 ? 988945.0 // F\n          :x==71 ? 925086.0 // G\n          :x==72 ? 630681.0 // H\n          :x==73 ? 467495.0 // I\n          :x==74 ? 559239.0 // J\n          :x==75 ? 611161.0 // K\n          :x==76 ?  69919.0 // L\n          :        653721.0 // M\n          ;\n    else\n    if (x < 91)\n        return // Glyphs added by Michael Pohoreski\n           x==78 ? 638361.0 // N\n          :x==79 ? 432534.0 // O\n          :x==80 ? 497425.0 // P\n          :x==81 ? 432606.0 // Q\n          :x==82 ? 497561.0 // R\n          :x==83 ? 923271.0 // S\n          :x==84 ? 467490.0 // T\n          :x==85 ? 629142.0 // U\n          :x==86 ? 349474.0 // V\n          :x==87 ? 629241.0 // W\n          :x==88 ? 628377.0 // X\n          :x==89 ? 348706.0 // Y\n          :        475671.0;// Z\n*/\n    return 0.0;\n}\n\n// ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ----\n\n\n// ---- TEXT --------------------------------\n\nvec2 gvPrintCharXY = vec2( 0.0, 0.0 );\nvec3 Char( vec3 backgroundColor, vec3 textColor, vec2 fragCoord, float fValue)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - gvPrintCharXY) / gvFontSize;\n    if ((vStringCharCoords.y <  0.0) || \n        (vStringCharCoords.y >= 1.0) || \n        (vStringCharCoords.x <  0.0))\n    {\n        return backgroundColor;\n    }\n\n    float fCharBin = float(vStringCharCoords.x < 1.0) * DigitBin(int(fValue));\n\n    // Auto-Advance cursor one glyph plus 1 pixel padding\n    // thus characters are spaced 9 pixels apart    \n    // except for characters 3 pixels wide\n    // TODO -- LOTS OF COMPARES... BAD?\n    float fAdvance = /* false        \n        || (fValue == 42.) // *\n        || (fValue == 73.) // I\n        || (fValue == 84.) // T\n        || (fValue == 86.) // V\n        || (fValue == 89.) // Y\n        || (fValue == 90.) // Z        \n        ? 0.0 // glyph width has no padding\n        : */ 2.0; \n    gvPrintCharXY.x += gvFontSize.x + fAdvance;\n        \n    float a = floor(\n        mod(\n            (fCharBin / pow(\n                2.0, \n                floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), \n            2.0)\n    );\n    return mix( backgroundColor, textColor, a );\n}\n\n\n// ---- UTILITY --------------------------------\n\nvec2 rotateXY( vec2 p, float angleRadians )\n{\n    float s = sin( angleRadians );\n    float c = cos( angleRadians );\n    mat2  m = mat2( c, -s, \n                    s,  c );\n    return m * p; // vec2\n}\n\n// De facto \"noise\" function, modified to supply two values\nvec2 noise2( vec2 location, vec2 delta ) {\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location +      delta            , c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        );\n}\n\n\n// ---- PATTERNS TO ANTI-ALIAS --------------------------------\n\n// ------------------------------------------------------------\n// patternSet_circleWithSpokes\nfloat pattern1( vec2 uv )\n{    \n    // full circle\n    vec2 p = (2.*uv - 1.) / CIRCLE_PERCENTAGE_OF_SCREEN;\n   \n    // quick semi-distance to circle formula:\n    float g = dot( p, p );\n    \n    float insideCircle = float(\n        ((g < 1.0 ) && (g > 0.85 )) ||\n        ((g < 0.6 ) && (g > 0.5  )) ||\n        ((g < 0.2 ) && (g > 0.1  ))\n    );\n    \n    float insideSpokes = float(mod(atan(p.y, p.x) + iTime / 40., PI/8.) < 0.15);\n\n    return \n    \tmod(insideCircle + \n            insideSpokes * (1. - g), \n            1.333);\n}\n\n// ------------------------------------------------------------\n// patternSet_2Dchecker\nfloat pattern2(vec2 uv)\n{\n    // correct for aspect ratio    \n    float aspect = iResolution.y/iResolution.x;\n    \n    // rotate with time distortion in Y    \n    float angle = -iTime * 0.05;\n    \n    // TODO -- I suspect this could be massively optimized.\n    //         We are translating, rotating, scaling, translating\n    //         Twice.  Grabbing coordinates within each.\n\n    const float NUM_CELLS = 8.0;\n    const float SHIFT_POSITIVE = 32.0; // ensure no negatives are rendered, since we use int(x)\n    \n    vec2 pStart = uv.xy - vec2(0.5);\n    pStart.y *= aspect;\n    \n    // 1. normal checkerboard\n    \n    // translate\n    vec2 p1 = pStart;\n    // rotate\n    p1 = rotateXY( p1, angle );\n    // translate back\n    p1 += vec2(SHIFT_POSITIVE + 0.5);    \n\n    p1.xy = floor(p1.xy * NUM_CELLS);\n    \n    // 2. 45 degree rotated checkerboard, zoomed to match vertices\n    \n    // translate\n    vec2 p2 = pStart;\n    // rotate\n    p2 = rotateXY( p2, angle + PI / 4.0);\n    // expand\n    p2 *= 1.41421356237;\n    // translate back\n    p2 += vec2(SHIFT_POSITIVE + 0.5);    \n\n    p2.xy = floor(p2.xy * NUM_CELLS);\n    \n    // combine\n    return mod(p1.x+p1.y + p2.x+p2.y, 2.0);\n}\n\n// ------------------------------------------------------------\n// patternSet_3Dchecker\nfloat pattern3(vec2 uv)\n{\n    // distance from center\n    // NOTE: 0.499 is to avoid the infinity in mid-Y,\n    // which, for our checkerboard calculation, produces NaN,\n    // which shows as black (fully visible during transitions!)   \n    vec2 dCenter = vec2(0.5, 0.499) - uv.xy;\n    \n    float X_INV_SCALE = 1.0;\n    float Z_INV_SCALE = 0.5;\n    \n    // 3D perspective: 1/Z = constant\n    vec3 cam;\n    cam.z = 1.0 / dCenter.y;\n    cam.xy = vec2(\n        X_INV_SCALE * dCenter.x,\n        Z_INV_SCALE)\n         * cam.z;\n\n    // rotate\n    float angle = (iTime * 0.05) \n        * float(uv.y < 0.5); // only allow the ground to rotate, not the ceiling\n    cam.xy = rotateXY( cam.xy, angle );\n\n    // textured\n\tcam.xy = floor(cam.xy * 2.0); \n    return mod(cam.x+cam.y, 2.0);\n}\n\n// ------------------------------------------------------------\nfloat pixelSet(vec2 uv)\n{\n    \n    // our position (already quantized ZOOM):\n    // res is the NEW resolution after ZOOM\n    vec2 p = uv.xy / res.xy; \n    \n    // get slow time:\n    float tDistort = iTime * 1.5 + \n        dot( \n            origP, \n            vec2(0.5, 0.5) // NOTE: changing X vs. Y will change the angle of the swipe fade\n        );\n    \n    // the idea is that we will cycle through a bunch of \"frames\"\n    // each \"frame\" is either:\n    // 1. a static image of a pattern \n    //    (well, the pattern itself may be animating, but that's its own discretion)\n    // 2. a fade between two patterns.\n    // Since all \"frames\" are the same time length,\n    // we should double / triple (or more) up frames for static patterns,\n    // so the fades take a short amount of time.    \n    \n    const float REPEAT_PER_PATTERN = 9.0; // number of frames of just a single pattern (between fades)\n    const float NUM_FRAMES_PER_PATTERN = REPEAT_PER_PATTERN + 1.0; // + 1.0 for the fade\n    \n    const float NUM_PATTERNS = 3.0;\n\n    const float NUM_FRAMES = NUM_PATTERNS * NUM_FRAMES_PER_PATTERN;\n\n    // Thus for our three patterns, with a repeat of 2:\n    // E.g.:\n    // 1. A\n    // 2. A\n    // 3. A -> B  \n    // 4.      B\n    // 5.      B\n    // 6.      B -> C\n    // 7.           C\n    // 8.           C\n    // 9. A <------ C\n    \n    // Thus for our three patterns, with a repeat of 3:\n    // E.g.:\n    //  1. A\n    //  2. A\n    //  3. A\n    //  4. A -> B  \n    //  5.      B\n    //  6.      B\n    //  7.      B\n    //  8.      B -> C\n    //  9.           C\n    // 10.           C\n    // 11.           C\n    // 12. A <------ C\n    \n    float t = mod(tDistort, NUM_FRAMES ); // 0.0..NUM_FRAMES, wraps\n    float f = smoothstep(0.0, 1.0, fract(tDistort)); // change from linear to smooth\n    \n    // Optimized    \n         if (t < REPEAT_PER_PATTERN                              ) return     pattern1(p);\n    else if (t < NUM_FRAMES_PER_PATTERN)                           return mix(pattern1(p), pattern2(p), f);\n    else if (t < REPEAT_PER_PATTERN + NUM_FRAMES_PER_PATTERN     ) return                  pattern2(p);\n    else if (t < NUM_FRAMES_PER_PATTERN * 2.)                      return mix(             pattern2(p), pattern3(p), f);\n    else if (t < REPEAT_PER_PATTERN + NUM_FRAMES_PER_PATTERN * 2.) return                               pattern3(p);\n    else                                                           return mix(                          pattern3(p), pattern1(p), f);\n}\n\n// ---- HUD TITLE & ZOOM --------------------------------\n\n// -------------------------------------------------\nvec3 drawTitle( in vec2 fragCoord, \n               // TODO --- these are equidistant, so why not pass in START and DELTA_X?\n               float mx0, \n               float mx1, \n               float mx2, \n               float mx3, \n               float mx4,\n               float mx5)\n{\n    vec3 color = BG_COLOR;\n    \n    float scale  = iResolution.x;\n    float center = (mx1 - mx0) * 0.5 * scale;\n\n    gvPrintCharXY.y = iResolution.y - gvFontSize.y - 1.;\n    \n    gvPrintCharXY.x = mx0*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 45.); // -\n\n    gvPrintCharXY.x = mx1*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 81.); // Q\n    color = Char( color, COLOR_TITLE, fragCoord, 67.); // C\n\n    gvPrintCharXY.x = mx2*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord,  2.); // 2\n    color = Char( color, COLOR_TITLE, fragCoord, 42.); // *\n\n    gvPrintCharXY.x = mx3*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord,  3.); // 3\n    color = Char( color, COLOR_TITLE, fragCoord, 68.); // D\n\n    gvPrintCharXY.x = mx4*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 78.); // N\n    color = Char( color, COLOR_TITLE, fragCoord, 42.); // *\n\n    gvPrintCharXY.x = mx5*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 82.); // R\n    color = Char( color, COLOR_TITLE, fragCoord, 1. ); // 1\n\n    gvPrintCharXY.x = mx5*scale + center;\n    //                          ^-- positive, to show on the other side of the line\n\n    color = Char( color, COLOR_TITLE, fragCoord, 82.); // R\n    color = Char( color, COLOR_TITLE, fragCoord, 2. ); // 2\n\n    return color;\n}\n\n// -------------------------------------------------\nvec3 drawZoom ( vec2 fragCoord, vec3 color ) \n{\n    // \"Z=x\" text, where x = the zoom factor\n    gvPrintCharXY = vec2( 1.0, iResolution.y - gvFontSize.y - 1.);\n    \n    //color = drawStatus( color, fragCoord, nameLit, equalsLit );\n    color = Char( color, COLOR_ZOOM  , fragCoord, 90.0); // Z\n    color = Char( color, COLOR_EQUALS, fragCoord, 61.0); // =\n\n    // show Zoom factor in upper-left\n    color = Char( color, COLOR_ZOOMFACTOR, fragCoord, ZOOM);\n    return color;\n}\n\n// ---- MAIN --------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---- ORIGINAL POSITIONS ----\n    \n    // get original positions before ZOOM:\n    \n    // mouse y\n    origM = iMouse.xy    / iResolution.xy; // 0..1\n    origP = fragCoord.xy / iResolution.xy; // 0..1\n    \n    // ---- RESET ZOOM WHEN (LIKELY) IN THUMBNAIL MODE ----\n\n    // if we're not using the mouse\n    // AND the window size is LIKELY THAT of a thumbnail,\n    // force defaults to show off a nice thumbnail:\n    // NOTE: this will think it's a thumbnail, even when not, if you're in a very small browser window,\n    //       since the site will shrink the output target to the size of a thumbnail.\n    // ALSO: the site increases thumbnail sizes if your browser window is large; this makes life difficult! :(\n\n    // method of changing X and Y without if-statements:\n    \n    float multChange = \n        float(iMouse.z < 0.5) * \n        float(iResolution.y < 310.0);\n    \n    // 0.5 = center, to see most of the AA methods\n    origM.x = mix(origM.x, 0.5, multChange);\n    \n    // 1.5 is the middle of the ZOOM=2 region\n    origM.y = mix(origM.y, 1.5 / MAX_ZOOM, multChange);\n\n    \n    // ---- ZOOM QUANTIZE ----\n    \n    // get ZOOM factor from the original positions\n    ZOOM = MIN_ZOOM + \n        floor(\n            origM.y * (MAX_ZOOM + 0.99 - MIN_ZOOM) // +0.99 since we floor() the result, \n                                               // and want MAX_ZOOM to be selectable as well\n             ); // needs to be integer \n                // (unless you want cool but inaccurate video game pixel blur animations)\n    ZOOM = clamp(ZOOM, MIN_ZOOM, MAX_ZOOM); // can get out of range when window resizes.\n    \n    \n    // ---- COMPUTE SPLIT SCREEN SECTIONS ----\n        \n    // mouse position relative\n    float mx0 = origM.x - 0.40;\n    float mx1 = origM.x - 0.20;\n    float mx2 = origM.x       ;\n    float mx3 = origM.x + 0.20;\n    float mx4 = origM.x + 0.40;\n    float mx5 = origM.x + 0.60;\n        \n\tvec3 color = vec3(0.0); // final RGB color\n\tfloat colorRGB = 0.0; // single color channel: represents ALL three RGB = grayscale only!\n\t\t\n    // ----------------------------------------------------------------\n    // 1. Header\n    // background bar\n    if (fragCoord.y > (iResolution.y - gvFontSize.y - 2.0))\n    {\n        // the AA method names:\n        color = drawTitle( fragCoord, mx0, mx1, mx2, mx3, mx4, mx5 );\n        color = drawZoom ( fragCoord, color );\n    }\n    \n    // ----------------------------------------------------------------\n    // 2. Main Image (between the header/footer)\n    else\n    {\n        // ---- QUANTIZE TO ZOOM ----\n        \n        vec2 uv = floor(fragCoord / ZOOM) * ZOOM;\n        \n        // then do actual zoom (center zoom on 0.5,0.5)\n        res = (vec2(0.5) - iResolution.xy) / ZOOM;\n        mou = (vec2(0.5) - iMouse.xy     ) / ZOOM;\n        uv  = (vec2(0.5) - uv.xy         ) / ZOOM;\n        \n        // ---- SPLIT SCREEN ---- DIFFERENT AA METHODS ----\n        \n        /* (UNOPTIMIZED VERSION)\n             if (origP.x < mx0) color = pixelSet   ( uv ); // no AA\n        else if (origP.x < mx1) color = aa_quincunx( uv ); // 2 samples          }\n        else if (origP.x < mx2) color = aa_2x2     ( uv ); // 4 samples          }-> similar algorithms\n        else if (origP.x < mx3) color = aa_3dfx    ( uv ); // 4 samples (better) }   (in this shader, that is = share code)\n        else if (origP.x < mx4) color = aa_nxn     ( uv ); // 16 samples\n        else                    color = aa_random  ( uv ); // 64 samples\n        */\n        \n        // TODO -- we should show the resultant if-statement layoyut below\n        //         in a simple format where we just call getColorX(),\n        //         and setCommon(), so that we can see what we've optimized,\n        //         in terms of if statement depth.\n\t\t\n        // ---- METHOD 1. NO AA ----\n        \n        if( origP.x < mx0 )\n        {\n            colorRGB = pixelSet   ( uv );\n        }\n        else\n          \n        // ===========================\n        // EXPLANATION\n        // ===========================\n        // Because pixel shaders don't like too many if-statements, we tried to reduce them.\n        // Since 2x2, Quincunx, and 3Dfx are so similar pixel-shader-wise, we combined them.\n        // Individually, this isn't optimal, but globally (for the pixel shader to use less\n        // \"if-statement resources\", it is.  THIS MEANS MORE PEOPLE CAN RUN THIS SHADER.\n        // ===========================\n            \n        if (origP.x < mx3) {\n            \n            // ---- METHOD 2 & 3 & 4 ---- ALL ARE SHARING SOME PIXEL SHADER CODE ----\n\n            // ---- METHOD 3. 2x2 ----\n            \n            // fragCoord = pixel, not normalized\n            vec2  q = vec2( 0.25, 0.25 ); // common factor: aa_2x2(), aa_3dfx()\n            \n            float w1 = 0.25;\n            float w2 = 0.0 ;\n            \n\n            // ---- METHOD 4. 3DFX ----\n\n            if (origP.x > mx2) {\n                // WE KNOW THE RESULT OF THIS:\n                // small = 0.11218413712\n                // large = 0.33528304367\n                q = vec2(0.11218413712, 0.33528304367);\n            }\n            \n            // ---- METHOD 2. QUINCUNX ----\n\n            if (origP.x < mx1) {\n                // colorRGB = aa_quincunx( uv ); \n                //q = vec2( 0.5, 0.5 );\n                q *= 2.0; // 0.5, 0.5\n\n                // Weightings\n                // quincunx = 1/8th power for four corners that are shared with other pixels\n                //          = 1/2   power for one center\n                //          = TOTAL of 100%\n                w1 = 0.125;\n                w2 = 0.5  ;\n               \n            }\n\n            colorRGB = ( pixelSet(uv + vec2(-q.x, +q.y)) +\n                         pixelSet(uv + vec2(+q.y, +q.x)) +\n                         pixelSet(uv + vec2(+q.x, -q.y)) +\n                         pixelSet(uv + vec2(-q.y, -q.x)) ) * w1 +\n                       ( pixelSet(uv + vec2( 0.0,  0.0)) ) * w2;\n        }\n        \n        // ---- METHOD 5. NxN ----\n        \n        else if (origP.x < mx4) {\n\n            #define invNxN (1. / float(METHOD_NXN_N))\n\n            for (int i=0; i<METHOD_NXN_N; i++) {\n                float n1 = float(i) * invNxN;\n                for (int j=0; j<METHOD_NXN_N; j++) {\n                    \n                    // TODO: could be optimized with additions of a single constant delta \n                    //       applied to both x and y.\n                    // TODO: along with that optimization, the vec(.5,.5) could be placed\n                    //       there too.\n                    \n                    float n2 = float(j) * invNxN;                    \n                    \n                    vec2 offset = vec2(n1, n2) - vec2(0.5, 0.5); \n                    colorRGB += pixelSet(uv + offset);\n                }\n            }\n            colorRGB /= float(METHOD_NXN_N * METHOD_NXN_N);\n        }\n\n        // ---- METHOD 6. RANDOM NxN STATIC ----\n        // ---- METHOD 7. RANDOM NxN DYNAMIC ----\n        \n        else\n        {\n            float t = (origP.x > mx5 ? iTime : 1.0);\n            for (int i=0; i<METHOD_RND_NXN_N; i++) {\n                for (int j=0; j<METHOD_RND_NXN_N; j++) {\n                    \n                    // noise\n                    vec2 q = t * vec2(float(i), float(j)); // this could partially be optimized outside the loop\n                    vec2 n = noise2( uv , q );\n                    vec2 offset = vec2(n.x, n.y) - vec2(0.5, 0.5);\n                    colorRGB += pixelSet(uv + offset);\n                }\n            }\n            colorRGB /= float(METHOD_RND_NXN_N * METHOD_RND_NXN_N);           \n        }        \n\n\t\t// ---- GAMMA CORRECTION ----\n\t\t\n\t\tconst float invGamma = 1. / GAMMA_CORRECTION;\n\t\tcolor = vec3(pow(colorRGB, invGamma));\n        \n    } // else 2. MAIN IMAGE\n\n    // ---- SHOW BLACK BAR SPLITS BETWEEN AA METHODS ----\n\n    // float fade = 1.0; // TODO: Need to account for mouse y position: m.y;\n    #define X1 0.002\n    #define X2 0.003\n    color *=        smoothstep( X1, X2, abs(origP.x-mx0) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx1) );\n    color.g += 1. - smoothstep( X1, X2, abs(origP.x-mx2) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx3) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx4) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx5) );\n    \n    // ---- FINAL RESULT ----\n    fragColor = vec4(color, 1.);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9094, 9094, 9174, 9174, 10308], [10361, 10361, 10406, 10406, 10561], [10563, 10623, 10665, 10665, 10902], [10970, 11065, 11092, 11115, 11591], [11593, 11681, 11706, 11742, 12864], [12866, 12954, 12979, 13190, 13730], [13732, 13796, 13821, 13916, 16296], [16357, 16410, 16695, 16695, 18056], [18058, 18111, 18158, 18203, 18585], [18587, 18633, 18690, 18794, 27114]], "test": "error"}
{"id": "4dGXzw", "name": "Fuzzy Walls", "author": "innovati", "description": "These pink and yellow walls are awesome!", "tags": ["fuzzy", "walls"], "likes": 0, "viewed": 106, "published": "Public", "date": "1463381933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord ){\n  fragColor = step(\n    pow(\n      mod(\n        reflect(\n          vec4(\n            (1.2 + 1.2),\n            (1.3 * (0.7 - 0.6)),\n            iTime,\n            0.3\n          ),\n          exp2(\n            vec4(\n              1.4,\n              0.4,\n              step(1.1, 0.8),\n              1.0\n            )\n          )\n        ),\n        normalize(\n          reflect(\n            fract(\n              pow(\n                vec4(\n                  1.8,\n                  (fragCoord.x / iResolution.x),\n                  0.3,\n                  1.2\n                ),\n                vec4(\n                  0.0,\n                  ((fragCoord.y / iResolution.y) - iTime),\n                  atan(\n                    (fragCoord.x / iResolution.x),\n                    0.2\n                  ),\n                  (1.3 * 1.0)\n                )\n              )\n            ),\n            fract(\n              vec4(\n                (fragCoord.y / iResolution.y),\n                1.7,\n                1.8,\n                min(\n                  0.0,\n                  step(\n                    1.6,\n                    (0.3 * 1.8)\n                  )\n                )\n              )\n            )\n          )\n        )\n      ),\n      vec4(\n        0.9,\n        (0.3 / 1.1),\n        (0.7 / ceil(0.7)),\n        iTime\n      )\n    ),\n    vec4(\n      0.7,\n      (fragCoord.x / iResolution.x),\n      0.6,\n      1.5\n    )\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1474]], "test": "valid"}
{"id": "4dKSRw", "name": "Julia - Traps 1 Depth Compare", "author": "MichaelPohoreski", "description": "Modified i.q.'s Juliabrot animation to show the complexity (click to set the split screen!)\nOriginal: https://www.shadertoy.com/view/4d23WG\nSplit Screen: https://www.shadertoy.com/view/MdySzm\nTime Warp: https://www.shadertoy.com/view/XsKSRw", "tags": ["2d", "julia", "orbittrap", "splitscreen"], "likes": 2, "viewed": 122, "published": "Public", "date": "1463495907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// INSTRUCTIONS: Click/Drag in the output to change the depth!\n// Split Screen Functionality by Michael Pohoreski/2016 (borrowed from i.q.!)\n// Original version by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// line 34: pixel coordinates\t\n// line 14: c travels around the main cardiod c(t) = e^it - e^i2t\n// line 25: z = z + c\t\t\n// line 26: trap orbit\n// line 45: remap\t\n// line 46: color\t\n// line 47: split screen\n\nvec2 offset( float t )\n{\n    return 0.51*cos( vec2(0.0,1.5708) + 0.1*t )\n         - 0.25*cos( vec2(0.0,1.5708) + 0.2*t );\n}\n\nfloat orbit( vec2 z, vec2 bias, int depth )\n{\n\tfloat f = 1e20;\n\tfor( int i=0; i<256; i++ ) \n\t{   if (i > depth) break;\n\t\tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + bias;\n\t\tf = min( f, dot(z,z) );\n\t}\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float ar = 4./3.; // aspect ratio\n\tvec2 p = ar*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 m = ar*(-iResolution.xy+2.0*iMouse.xy   )/iResolution.y;\n    \n\tfloat f;\n    \n    // Right Half = Static, Time=0\n//    if( p.x > m.x )\n//        f = orbit( p, offset( 0.0 ), int(iMouse.x) );\n//    else\n        f = orbit( p, offset( iTime ), int(iMouse.x) );\n\n    f = 1.0+log(f)/16.0;\n    vec3 color = vec3( f*f*f, f*f, f ); // swapped f^1, f^2, f^3 for nicer blue :)\n    color *= smoothstep( 0.006, 0.008, abs(p.x-m.x) );\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKSRw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[495, 495, 519, 519, 618], [620, 620, 665, 665, 834], [836, 836, 893, 893, 1460]], "test": "valid"}
{"id": "4dKSzm", "name": "Inside the Motherboard", "author": "innovati", "description": "Follow the electrons down the winding path", "tags": ["inside", "motherboard"], "likes": 0, "viewed": 129, "published": "Public", "date": "1463546130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = sin(reflect(min(fract(vec4(0.5, 1.8, (fragCoord.x / iResolution.x), 0.2)), sign(vec4(floor(1.5), float(iFrame), step(0.1, ceil(0.3)), 1.1))), vec4((((mod(1.2, 1.3) + iTime) + (1.0 + 1.1)) / 0.3), (fragCoord.y / iResolution.y), 0.6, iTime)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 315]], "test": "valid"}
{"id": "4dKSzW", "name": "hummer alert", "author": "tomaes", "description": "experiment", "tags": ["2d"], "likes": 1, "viewed": 144, "published": "Public", "date": "1463215258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 c, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    float t = 60. + mod(sin((iTime)*.18+length(uv*sin(5.*uv.y+uv.x))),.1)*5.;\n    \n    c = vec4(1.3-uv.y*.5, 1., .3 * 1.5/sqrt(sin(t*5.+uv.x*40.)+cos(uv.y*20.)) , 1.);\n    \n    for(float f = 4.0; f < 10.; f += 2. )\n\t\tc += vec4( .06/sqrt(sin(uv.x*f)+cos(uv.y*f)+tan(f/t+t) ) );\n\n\tc -= (length(c) < 1.65+uv.x+uv.y) || (mod(t*.1,.1) < .005) ? 1.5 / c : c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 465]], "test": "valid"}
{"id": "4dKSzz", "name": "2030-SineWavyWorms", "author": "shortnotion", "description": "Wavy worms", "tags": ["2d", "flat", "blackwhite"], "likes": 1, "viewed": 97, "published": "Public", "date": "1462528873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat worm(vec2 fragCoord, vec2 scroll, float tiltFactor){\n    // sine-wave based baseline (causing the horizontal waviness)\n    float xLine = sin(fragCoord.x*0.02+scroll.x);\n    // add nother wave for some more randomness\n    xLine += sin(fragCoord.x*0.01)*2.5;\n    // tilt\n    xLine += fragCoord.x*tiltFactor;\n\n\n    // cursor used for the sine-based sinPos, offet by the above xLine for waviness\n    float yCursor = (xLine+fragCoord.y*0.2);\n    // multiply factor; high value means more/narrower horizontal bands\n    yCursor *= 0.1;\n    // vertical sine-pos; causing the vertically stacked bands\n    float val = sin(yCursor+scroll.y);\n\n    \n    // hardness; 0.0 means all black, 1.0 means blurry edges, 10.0 means high-contrast edges\n\tval *= 26.0;\n \t// increase; higher value means more white\n    val += -25.0;\n\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // global scroll movement speed\n    vec2 scroll = vec2(2.0, -0.1) * iTime; //*6.0;\n    float tilt = 0.0;\n \n\tfloat c = clamp(worm(fragCoord, scroll, tilt), 0.0, 1.0);\n    c += clamp(worm(fragCoord, scroll+vec2(5.0, 3.0), tilt+0.01), 0.0, 1.0);\n    c += clamp(worm(fragCoord, scroll+vec2(50.0, 2.0), tilt+0.003), 0.0, 1.0);\n\n\tfragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 59, 125, 832], [834, 834, 891, 927, 1253]], "test": "valid"}
{"id": "4dtSDs", "name": "A Few Fish", "author": "dr2", "description": "A few fish and lots of optical effects (mouse enabled)", "tags": ["raymarching", "reflection", "refraction", "optics"], "likes": 9, "viewed": 643, "published": "Public API", "date": "1462205298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"A Few Fish\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Fbm2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Length4 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nvec3 fishP, qHit, sunDir, waterDisp;\nfloat dstFar, tCur, bowlRad, bowlHt, fishLen, angTail, angFin, posMth;\nbool inBowl, chkBowl;\nint idObj;\nconst int idVWall = 1, idHWall = 2, idTbl = 3, idBowl = 4, idFBdy = 11,\n  idTail = 12, idFin = 13, idEye = 14;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  if (rd.y >= 0.) {\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - rd.y, 8.) +\n       0.35 * pow (max (dot (rd, sunDir), 0.), 6.);\n    col = mix (col, vec3 (1.), clamp (0.1 +\n       0.8 * Fbm2 (0.01 * tCur + 3. * rd.xz / max (rd.y, 0.001)) * rd.y, 0., 1.));\n  } else {\n    p = ro.xz - (ro.y + 2. * bowlRad - 1.) * rd.xz / rd.y;\n    col = 0.6 * mix (vec3 (0.4, 0.5, 0.1), vec3 (0.5, 0.6, 0.2),\n       Fbm2 (0.11 * p)) * (1. - 0.05 * Noisefv2 (5. * p));\n    col = mix (col, vec3 (0.35, 0.45, 0.65), pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nvec4 HexGrdCol (vec2 p)\n{\n  p *= 0.85;\n  p.y /= sqrt (0.75);\n  p.x += 0.5 * mod (floor (p.y), 2.);\n  p = abs ((fract (p) - 0.5));\n  return mix (vec4 (0.8, 0.8, 0.6, 0.1), vec4 (0.5, 0.5, 0.4, 0.4),\n     smoothstep (0.05, 0.1, abs (p.x + max (p.x, 1.5 * p.y) - 1.)));\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.7, 0.4, 0.3), vec3 (0.4, 0.25, 0.2), f);\n}\n\nfloat WaterHt (vec3 p)\n{\n  float ht, w, wb;\n  wb = 1.414;\n  p *= 0.05;\n  ht = 0.;\n  w = wb;\n  for (int j = 0; j < 4; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    p += waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return 0.1 * ht;\n}\n\nvec3 WaterNf (vec3 p)\n{\n  float h;\n  const vec2 e = vec2 (0.001, 0.);\n  h = WaterHt (p);\n  return normalize (vec3 (h - WaterHt (p + e.xyy), e.x, h - WaterHt (p + e.yyx)));\n}\n\nfloat TableDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, d1, d2, br, bl, sFac;\n  sFac = 2.5;  br = 1.6 * sFac;  bl = 1.1 * sFac;\n  p.y -= - 2.2 * sFac - 0.01 * br;\n  q = p;  q.y -= - 0.55 * br;\n  d = PrCylDf (q.xzy, 0.5 * br, 0.03 * br);\n  q = p;  q.y -= - 1.4 * bl;\n  d1 = PrCylDf (q.xzy, 0.07 * br, 0.6 * bl);\n  q.y -= - 0.6 * bl;\n  d2 = max (PrCylDf (q.xzy, 0.5 * br, 0.15 * br * (1. -\n     0.7 * smoothstep (0.2 * br, 0.35 * br, length (p.xz)))), -0.05 * br - q.y);\n  d = min (d, min (d1, d2));\n  if (d < dMin) { dMin = d;  idObj = idTbl;  qHit = q; }\n  return dMin;\n}\n\nfloat BowlWlDf (vec3 p, float dMin)\n{\n  float d, db;\n  db = Length4 (vec2 (length (p.xz), p.y));\n  d = inBowl ? max (max (db - 1.03 * bowlRad, p.y - bowlHt),\n     - max (db - bowlRad, p.y - bowlHt)) : max (db - bowlRad, p.y - bowlHt);\n  if (d < dMin) { dMin = d;  qHit = p;  idObj = idBowl; }\n  return dMin;\n}\n\nfloat FishDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, wr, tr, u, dTail;\n  q = p;  q.x = abs (q.x);  q -= fishLen * vec3 (0.12, 0.1, 0.9);\n  d = PrSphDf (q, 0.05 * fishLen);\n  if (d < dMin) { dMin = d;  idObj = idEye;  qHit = q; }\n  q = p;\n  wr = q.z / fishLen;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;\n    tr = 0.17 - u * (0.33 - 0.13 * u); \n  }\n  q.y *= 0.5;\n  d = PrCapsDf (q, 1.1 * tr * fishLen, fishLen);\n  q.y *= 2.;  q.z -= posMth * fishLen;\n  d = max (d, - PrCylDf (q.yzx, 0.03 * fishLen, 0.1 * fishLen));\n  if (d < dMin + 0.01 * fishLen) {\n    dMin = SmoothMin (dMin, d, 0.01 * fishLen);  idObj = idFBdy;  qHit = q;\n  }\n  q = p;  q.z -= -0.9 * fishLen;  q.y *= 0.1;\n  wr = q.z / (0.4 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.05 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  dTail = PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen);\n  d = max (dTail, 0.15 * fishLen - q.z);\n  if (d < dMin + 0.01 * fishLen) {\n    dMin = SmoothMin (dMin, d, 0.01 * fishLen);  idObj = idTail;  qHit = q;\n  }\n  q.z -= 0.15 * fishLen;\n  q.xz = Rot2D (q.xz, angTail);\n  d = max (PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen), q.z);\n  if (d < dMin) { dMin = d;  idObj = idTail;  qHit = q; }\n  q = p;  q.y *= 0.5;  q.z -= -0.75 * fishLen;\n  d = max (PrCylDf (q.xzy, 0.022 * fishLen, 0.11 * fishLen), dTail);\n  if (d < dMin) { dMin = d;  idObj = idTail;  qHit = 0.2 * q; }\n  q = p;  q.x = abs (q.x) - 0.18 * fishLen;  q.y *= 0.1;  q.z -= 0.4 * fishLen;\n  q.xz = Rot2D (q.xz, angFin);\n  wr = q.z / (0.2 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.01 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  q.z -= 0.3 * fishLen;\n  d = PrCylDf (q, 0.12 * tr * fishLen, 0.5 * fishLen);\n  if (d < dMin + 0.005 * fishLen) {\n    dMin = SmoothMin (dMin, d, 0.005 * fishLen);  idObj = idFin;  qHit = q;\n  }\n  return 0.75 * dMin;\n}\n\nfloat BowlExtDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;  q.y -= -2.72 * bowlRad + 11.2;  q.z -= 1.15 * bowlRad;\n  d = PrBoxDf (q, vec3 (2.4, 1.33, 0.01) * bowlRad);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idVWall; }\n  q = p;  q -= vec3 (0., -2. * bowlRad + 1., 1.2 * bowlRad);\n  d = max (PrCylDf (q.xzy, 2.4 * bowlRad, 0.01 * bowlRad), q.z + 0.2);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idHWall; }\n  q = p;  q.y -= - bowlHt + 5.1;\n  dMin = TableDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, s;\n  dMin = dstFar;\n  if (chkBowl) dMin = BowlWlDf (p, dMin);\n  else if (inBowl) {\n    q = p;\n    s = 2. * step (fishP.y, q.y) - 1.;\n    q.xz = Rot2D (q.xz, s * fishP.z);\n    q.xz = Rot2D (q.xz, 2. * pi *\n       (floor (5. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 5.);\n    q.x -= fishP.x;\n    q.y = abs (q.y - fishP.y) - 0.4 * bowlHt;\n    q.yz *= s;\n    dMin = FishDf (q, dMin);\n  } else dMin = BowlExtDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 FishCol ()\n{\n  vec3 col, c1, c2;\n  c1 = vec3 (0.1, 0.1, 1.);\n  c2 = vec3 (1., 0.2, 0.2);\n  qHit *= 20. / fishLen;\n  if (idObj == idEye) {\n    col = mix (vec3 (0.1, 1., 0.1), vec3 (1., 1., 0.), step (0.5, qHit.z));\n  } else if (idObj == idFBdy) {\n    col = mix (c2, c1, 0.5 * (1. + sin (4. * qHit.y)));\n    if (qHit.y > 2.) col = mix (col, c2,\n       SmoothBump (-0.5, 0.5, 0.2, abs (qHit.x)));\n    else if (qHit.y < -2.) col = mix (col, c1,\n       SmoothBump (-0.5, 0.5, 0.2, abs (qHit.x)));\n  } else if (idObj == idTail || idObj == idFin) {\n    col = mix (c2, c1, 0.5 * (1. + sin (40. * qHit.y)));\n  }\n  return col;\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col;\n  if (idObj == idVWall) col = HexGrdCol (qHit.xy);\n  else if (idObj == idHWall) col = HexGrdCol (qHit.xz);\n  else if (idObj == idTbl) col = vec4 (WoodCol (qHit, n), 0.2);\n  else col = vec4 (FishCol (), 1.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 roW, rdW, rdd, vn, vnW, colD, colR, col, qHitBowl, reflCol;\n  float dstHit, dstBowl, dstBowlW, yLim, dif, sh, frnlFac, eta;\n  int idObjT, hitBowl;\n  bool bWallHit;\n  eta = 1.33;\n  yLim = 0.999 * bowlHt;\n  inBowl = false;\n  chkBowl = true;\n  dstBowl = ObjRay (ro, rd);\n  hitBowl = -1;\n  if (dstBowl < dstFar) {\n    hitBowl = idObj;\n    qHitBowl = qHit;\n  }\n  chkBowl = false;\n  dstHit = ObjRay (ro, rd);\n  roW = ro;  rdW = rd;\n  dstBowlW = dstBowl;\n  reflCol = vec3 (1.);\n  frnlFac = 0.;\n  bWallHit = (dstBowl < dstHit && hitBowl > 0);\n  if (bWallHit) {\n    ro += dstBowl * rd;\n    chkBowl = true;\n    vn = (qHitBowl.y < yLim) ? ObjNf (ro) : WaterNf (qHitBowl);\n    vnW = vn;\n    frnlFac = (qHitBowl.y > - yLim) ? abs (dot (rd, vn)) : 0.;\n    rd = refract (rd, vn, 1. / eta);\n    ro += 0.01 * rd;\n    inBowl = true;\n    dstBowl = ObjRay (ro, rd);\n    hitBowl = -1;\n    if (dstBowl < dstFar) {\n      hitBowl = idObj;\n      qHitBowl = qHit;\n    }\n    chkBowl = false;\n    dstHit = ObjRay (ro, rd);\n    if (dstBowl < dstHit && hitBowl > 0) {\n      ro += dstBowl * rd;\n      chkBowl = true;\n      vn = (qHitBowl.y < yLim) ? ObjNf (ro) : - WaterNf (qHitBowl);\n      rdd = refract (rd, vn, eta);\n      if (length (rdd) > 0.) {\n        rd = rdd;\n        reflCol *= vec3 (0.9, 1., 0.9);\n        inBowl = false;\n      } else rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      chkBowl = false;\n      dstHit = ObjRay (ro, rd);\n    }\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    chkBowl = false;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, sunDir), 0.);\n    sh = (idObj < idFBdy) ? ObjSShadow (ro, sunDir) : 1.;\n    colD = reflCol * (objCol.rgb * (0.2 + 0.8 * dif * sh +\n       objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n  } else colD = reflCol * BgCol (ro, rd);\n  colR = vec3 (0.);\n  reflCol = vec3 (1.);\n  if (bWallHit) {\n    ro = roW + dstBowlW * rdW;\n    rd = (frnlFac > 0.) ? reflect (rdW, vnW) : rdW;\n    ro += 0.01 * rd;\n    inBowl = false;\n    chkBowl = false;\n    dstHit = ObjRay (ro, rd);\n    if (dstHit < dstFar) {\n      ro += rd * dstHit;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (vn);\n      dif = max (dot (vn, sunDir), 0.);\n      sh = ObjSShadow (ro, sunDir);\n      colR = reflCol * (objCol.rgb * (0.2 + 0.8 * dif * sh +\n         objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    } else colR = reflCol * BgCol (ro, rd);\n  }\n  frnlFac = (eta != 1. && frnlFac > 0.) ? 1. - pow (frnlFac, 4.) : 0.;\n  col = mix (colD, colR, smoothstep (0.98, 1., frnlFac));\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 80.;\n  bowlRad = 5.;\n  bowlHt = 2.5;\n  fishP = vec3 (-0.6 * bowlRad, bowlHt * (-0.2 + 0.4 * sin (0.077 * 0.5 * tCur)),\n     0.5 * tCur);\n  fishLen = 0.25 * bowlRad;\n  angTail = 0.1 * pi * sin (5. * tCur);\n  angFin = pi * (0.8 + 0.1 * sin (2.5 * tCur));\n  posMth = 1.04 + 0.01 * sin (5. * tCur);\n  waterDisp = 0.1 * tCur * vec3 (1., 0., 1.);\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    zmFac = 5.5;\n    el = clamp (el - 3. * mPtr.y, -1.4, 1.1);\n    az = clamp (az - 3. * mPtr.x, -1.5, 1.5);\n  } else {\n    zmFac = clamp (3. + 0.4 * tCur, 3., 7.);\n    el -= pi * (-0.15 + 0.6 * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.071 * tCur + 0.4 * pi, 2. * pi) / (2. * pi)));\n    az += 0.5 * pi * (1. - 0.5 * abs (el)) * sin (0.21 * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 0., -40.);\n  sunDir = vuMat * normalize (vec3 (-0.2, 0.2, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  p *= p;\n  return pow (p.x + p.y, 1./4.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtSDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[373, 373, 405, 405, 505], [507, 507, 540, 540, 567], [569, 569, 611, 611, 662], [664, 664, 707, 707, 780], [1035, 1035, 1066, 1066, 1629], [1631, 1631, 1656, 1656, 1899], [1901, 1901, 1932, 1932, 2142], [2144, 2144, 2168, 2168, 2419], [2421, 2421, 2444, 2444, 2594], [2596, 2596, 2632, 2632, 3169], [3171, 3171, 3208, 3208, 3480], [3482, 3482, 3517, 3517, 5541], [5543, 5543, 5581, 5581, 6048], [6050, 6050, 6072, 6072, 6530], [6532, 6532, 6565, 6565, 6741], [6743, 6743, 6764, 6764, 6977], [6979, 6979, 7016, 7016, 7254], [7256, 7256, 7273, 7273, 7879], [7881, 7881, 7903, 7903, 8138], [8140, 8140, 8175, 8175, 10884], [10886, 10886, 10942, 10942, 12318], [12441, 12441, 12465, 12465, 12512], [12514, 12514, 12539, 12539, 12738], [12740, 12740, 12765, 12765, 13109], [13111, 13111, 13132, 13132, 13271], [13273, 13273, 13318, 13318, 13421], [13423, 13423, 13480, 13480, 13563], [13565, 13565, 13589, 13589, 13644], [13646, 13646, 13676, 13676, 13734]], "test": "error"}
{"id": "4dtSRl", "name": "Oblivion Bubbleship HUD", "author": "calx", "description": "I went about recreating Joseph Chan's Bubbleship hud from Oblivion using distance transforms. The code's a total mess but the actual excersize in drawing with shaders was really interesting. http://www.josephychan.com/Oblivion", "tags": ["distancefield", "ui", "hud"], "likes": 16, "viewed": 657, "published": "Public", "date": "1463657765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define QUARTER_PI 0.78539816339\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\nconst vec4 \tBLUE\t\t\t= vec4(0.306, 0.502, 0.537, 1.000);\nconst vec4 \tRED\t\t\t\t= vec4(0.941, 0.306, 0.208, 1.000);\nconst vec4 \tGREY_BLUE\t\t= vec4(0.494, 0.620, 0.663, 1.000);\nconst vec4 \tYELLOW\t\t\t= vec4(0.969, 1.000, 0.804, 1.000);\nconst vec4 \tGREEN\t\t\t= vec4(0.804, 1.000, 0.965, 1.000);\nconst vec4 \tGREY\t\t\t= vec4(0.449, 0.481, 0.489, 1.000);\nconst vec4 \tD_GREY\t\t\t= vec4(0.050, 0.050, 0.050, 1.000);\nconst vec4 \tM_GREY\t\t\t= vec4(0.200, 0.200, 0.200, 1.000);\nconst vec4 \tWHITE \t\t\t= vec4(1.000, 1.000, 1.000, 1.000);\nconst vec4 \tT_WHITE \t\t= vec4(1.000, 1.000, 1.000, 0.500);\nconst vec4 \tBLACK\t\t\t= vec4(0.000, 0.000, 0.000, 0.000);\nconst vec2 \tORIGIN \t\t\t= vec2(0.0);\nconst float LINE_WEIGHT \t= 0.0035;\nconst float METER_WEIGHT \t= 0.0100;\n\t  float SMOOTH\t\t\t= 0.0;\n\t  float R_SMOOTH\t\t= 0.2000;\n\nfloat map(float value, float istart, float istop, float ostart, float ostop) \n{\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\nfloat n_angleBetween(vec2 v1, vec2 v2)\n{\n    float angle = atan(v1.y-v2.y, v1.x-v2.x);\n    return ((angle < 0.0) ? (angle += TWO_PI) : angle) / TWO_PI;\n}\n\nvec2 rotate(vec2 v, float rotation)\n{\n\treturn vec2(cos(rotation)*v.x + sin(rotation)*v.y, -sin(rotation)*v.x + cos(rotation)*v.y);\n}\n\nfloat radialLine(vec2 r, float radius, float cutoff, float weight, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 180.0;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring * line;;\n}\n\nfloat radialMeter(vec2 r, float radius, float cutoff, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;  \n\tfloat or = \tir + METER_WEIGHT;   \n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 200.0;\n    float grads = fract(s);    \n\tfloat steps = (1.0-smoothstep((0.4-R_SMOOTH), (0.41+R_SMOOTH), grads)) * smoothstep((0.2-R_SMOOTH),(0.21+R_SMOOTH), grads) ;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n\n    steps *= ring * line;\n        \n\treturn steps;\n}\n\nfloat dottedSect(vec2 r, float radius, float cutoff, float dotSize, bool flip, float num)\n{ \n    float a = num;\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n    float theta =  round(n_angleBetween(uv, vec2(0.0)) * (TWO_PI * a)) / a;\n    float x = radius * cos(theta);\n    float y = radius * sin(theta);\n    vec2  v = vec2(x, y);   \n \tfloat d = distance(uv, v);\n    float e = smoothstep(d-SMOOTH, d+SMOOTH, dotSize);\n    float line =  step(theta, cutoff);\n\n    return e*line;\n}\n\nfloat returnBracket(vec2 r, float radius, float cutoff, float weight, float vCut, bool flip)\n{\n    vec2 uv =  rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float line =   step(theta, cutoff/TWO_PI);\n    float halfs =  (cutoff/TWO_PI) / 2.0;\n    float sec = step(halfs-(vCut/TWO_PI), theta) * (1.0-step(halfs+((vCut/TWO_PI)), theta));\n\tfloat ring = smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n  \n\treturn ring * (line - sec);\t\n}\n\nfloat solBracket(vec2 r, float radius, float weight, float cutoff, float cut, float retrn)\n{\n    vec2 uv =  r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n  \tfloat ring =  smoothstep(ir-SMOOTH, ir+SMOOTH, d) * (1.0 - smoothstep(or-SMOOTH, or+SMOOTH, d));\n    float circ = step(radius+weight, d);\n\tfloat block = \tsmoothstep(uv.y-SMOOTH, uv.y+SMOOTH, cutoff) * (1.0 - smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -cutoff));\n    float topLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH,  cutoff-weight);\n    float botLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -(cutoff-(weight)));\n    \n\tfloat xblock = step(-retrn, uv.x) * (1.0-step(retrn, uv.x));\n    float yblock = step(-cut, uv.y) * (1.0-step(cut, uv.y));\n    \n    ring *= block;\n    topLine *= (1.0 - botLine);\n    block *= (1.0 - topLine);\n    ring += block;\n    ring *= 1.0-circ;\n    float blocks = (xblock+yblock);\n    \n\treturn ring * (1.0-(blocks));\t\n}\n\nfloat single(vec2 r, float radius, float weight)\n{\n    vec2  uv = r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring;\n}\n\nfloat splitLine(vec2 r, float w, float yOffset, float split, float weight) \n{\n    vec2 uv = r + vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float g = step(uv.x, split) * (1.0-step(split, -uv.x));\n    \n    return f * l * (1.0-g);\n}\n\nfloat meter(vec2 r, float w, float yOffset, float inc, float weight, float num) \n{\n    vec2 uv = r - vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float incr = fract(uv.x*num);\n    float gnn = (1.0-smoothstep((0.4-SMOOTH), (0.41+SMOOTH), incr)) * smoothstep((0.2-SMOOTH),(0.21+SMOOTH), incr);\n    f *= (gnn * l);   \n    \n    return f ;\n}\n\nfloat grid(vec2 r, float num, float weight)\n{\n    vec2 uv = r * num;\n    float gridx = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.x));\n    float gridy = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.y));\n    \n    return (1.0 - (gridx * gridy));\n}\n\nfloat dots(vec2 r, float num, float pointSize)\n{\n    vec2 uv = r * num;\n    vec2  v = vec2(round(uv.x),round(uv.y));   \n \tfloat d = distance(uv, v);\n    return smoothstep(d-SMOOTH, d+SMOOTH, pointSize);   \n}\n\nfloat bg(vec2 r, float w, float h)\n{\n    float f = 1.0 - step(w, distance(r, ORIGIN));\n    \n    float g = step(-h, r.y) * (1.0-step(h, r.y));\n    \n    f *= g;\n    \n\treturn 1.0-f;\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec2 hashPosition(float x)\n{\n    return vec2(hash(x) * 64.0, hash(x * 1.1) * 64.0);\n}\n\nfloat sineOut(float t) \n{\n  return sin(t * HALF_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SMOOTH \t\t= map(iResolution.x, 800.0, 2560.0, 0.0025, 0.0010);\n\tvec2 uv =  2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float rotation = - PI / 4.0;\n    rotation = 0.0;\n    uv = vec2(cos(rotation)*uv.x + sin(rotation)*uv.y, -sin(rotation)*uv.x + cos(rotation)*uv.y);\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n\t\n\tconst float sequenceDuration = 1.25;\n\tfloat currentSequence = floor(iTime / sequenceDuration);\n\tfloat currentSequenceTime = mod(iTime, sequenceDuration);\n\tvec2  startingPosition = hashPosition(currentSequence) * 0.005;\n\tvec2  goalPosition = hashPosition(currentSequence + 1.0) * 0.005;\n\tvec2  currentPosition;\n\tconst float speed = 0.5;\n\tfloat potentialDistance = speed * currentSequenceTime;\n\tfloat goalDistance = length(goalPosition - startingPosition);\n    \n\tif (potentialDistance < goalDistance) {\n\t\tcurrentPosition = mix(startingPosition, goalPosition, sineOut(potentialDistance / goalDistance));\n\t} else {\n\t\tcurrentPosition = goalPosition;\n\t}\n\t\n    vec2 targetPosition = uv-currentPosition;\n    \n    vec4 tex = texture(iChannel0, q) * 0.1; \n    \n    vec4 final  = mix(tex, \tBLACK, \tbg(uv, 1.4805, 0.500) * 0.50);      \n    \t final *= mix(tex, \tBLACK, \tbg(uv, 1.2805, 0.702) * 0.25); \n    \n    final = mix(final, \tWHITE\t, dots(uv, 20.0, 0.04) * 0.25);    \n    final = mix(final, \tWHITE\t, grid (uv, 10.0, 0.03) * 0.10);   \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, true)); \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, true));\n    final = mix(final,  BLUE    , splitLine  (targetPosition, 0.3000, 0.3300, 0.0160, 0.005));\n    final = mix(final,  WHITE   , splitLine  (targetPosition, 0.6231, 0.0000, 0.5324, LINE_WEIGHT));\n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, false, 12.40)); \n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, true, 12.40));  \n    final = mix(final,  GREY    , solBracket (targetPosition, 0.3490, LINE_WEIGHT, 0.3, 0.265, 0.000));\n   \tfinal = mix(final,  WHITE   , solBracket (targetPosition, 0.3777, LINE_WEIGHT, 0.05, 0.018, 0.3675));\n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, false));   \n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, true)); \n    final = mix(final,  GREY    , single     (targetPosition, 0.4527, LINE_WEIGHT));\n   \tfinal = mix(final, \tGREY_BLUE, splitLine  (targetPosition, 0.6231, 0.0, 0.5324, LINE_WEIGHT));    \n    final = mix(final, \tBLUE\t, solBracket (targetPosition, 0.5750, LINE_WEIGHT, 1.0, 0.2314, 0.0000));\n \tfinal = mix(final, \tWHITE\t, solBracket (uv, 1.4805, LINE_WEIGHT, 0.7000, 0.0592, 1.2900));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.6685, 0.1592, 0.0000));\n    final = mix(final, \tGREY\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.7000, 0.6950, 0.0000));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5174, 0.0000, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5374, 0.5300, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.6390, 0.6300, 0.8551));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, false, 112.40));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, true, 112.40));\n    final = mix(final, \tGREY\t, meter\t\t (uv, 0.8500, 0.6390, 0.9324, 0.010, 50.0));\n    \n\n    fragColor = final;\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[901, 901, 980, 980, 1060], [1063, 1063, 1103, 1103, 1216], [1218, 1218, 1255, 1255, 1350], [1352, 1352, 1431, 1431, 1833], [1835, 1835, 1901, 1901, 2496], [2498, 2498, 2589, 2589, 3000], [3002, 3002, 3096, 3096, 3610], [3612, 3612, 3704, 3704, 4546], [4548, 4548, 4598, 4598, 4818], [4820, 4820, 4897, 4897, 5158], [5160, 5160, 5242, 5242, 5603], [5605, 5605, 5650, 5650, 5870], [5872, 5872, 5920, 5920, 6079], [6081, 6081, 6117, 6117, 6261], [6263, 6263, 6284, 6284, 6337], [6339, 6339, 6367, 6367, 6424], [6426, 6426, 6451, 6451, 6480], [6482, 6482, 6539, 6539, 10317]], "test": "error"}
{"id": "4dtXDs", "name": "G-Lectric Sheep 15", "author": "vox", "description": "G-Lectric Sheep 15", "tags": ["glectricsheep15"], "likes": 2, "viewed": 497, "published": "Public API", "date": "1462218230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(seedling+iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat seedling;\n\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------GALAXY-----------------\n\nfloat galaxy(vec2 uv)\n{\n    uv /= 5.0;\n    float r1 = length(uv);\n    float r2 = length(uv);\n    \n    //float theta = atan(uv.y, uv.x)/3.14*.5+.5;\n//finalColor = vec4(vec3(theta),1.0);\n    float theta1 = atan(uv.y, uv.x)-r1*PI+iTime*.5;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+iTime*.5;\n    \nvec4 finalColor = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*vec4(1.0, 1.0, 1.0, 1.0)\n    \n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*vec4(0.0, 0.0, 2.0, 1.0)\n         + simplex3d(vec3(r2+iTime*.25, cos(theta2)*5., 0.0)*4.0)*(1.5-log(r2+1.))\n         + simplex3d(vec3(r2*r2+iTime*.25, cos(theta2)*5., 0.0)*4.0)*(1.25-log(r2+1.));\n    //finalColor.g *= (2.0+sin(iTime*.55));\n    //finalColor.r *= (3.0+cos(iTime*.45));\n    finalColor.b += .75;\n    \n    finalColor /= r1;\n    \n    finalColor *= 2.0;\n    return length(finalColor);\n    \n    //fragColor += (1.0-log(r1+1.));\n    \n    //fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0)+texture(iChannel0, uv/5.0).rgb;\n    \n    //fragColor.rgb *= .5;\n    return clamp(finalColor.b, 0.0, 1.0);\n}\n\n//-----------------RENDERING-----------------\n\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+5.0*vec2(time, time*GR/E))*GR;\n\tvec2 b = sin(seedling+4.666*vec2(time, time*GR/E))*GR;\n\tvec2 c = sin(seedling+4.333*vec2(time, time*GR/E))*GR;\n\tvec2 d = sin(seedling+4.0*vec2(time, time*GR/E))*GR;\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return mobius((uv*2.0-1.0));//*2.0*PI);\n}\n\nvec2 reflection(vec2 uv)\n{\n    return (1.0-saw(PI*(uv*.5+.5)));\n}\nvec2 spiral(vec2 uv)\n{\n    float turns = 2.0;\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x)*turns-r*PI*2.0;\n    return vec2(saw(r*PI),\n                saw(theta));\n}\n\nvec2 perspective(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 12;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    int last_i;\n    \n    #define FUNCTION_PERSPECTIVE 0\n    #define FUNCTION_SPIRAL 1\n    \n    int function = 0;\n    vec2 next, last; \n    \n    for(int i = 0; i < max_i; i++)\n    {\n        last_i = 0;\n        seedling += fract(float(i)*123456.123456);\n        \n        if(function == FUNCTION_PERSPECTIVE)\n        {\n            last = uv;\n            next = perspective(uv, .5/iResolution.xy, magnification);\n\n            //omg so platform dependent... pls help fix:\n            float weight = ifs;\n\n\n            float delta = galaxy(next*2.0-1.0);\n        \n            if(delta == 0.0)\n            {\n\t            uv = last*ifs+uv*(1.0-ifs);\n                uv = reflection(uv*2.0-1.0);//*clamp(pow(delta, SPIRAL_BLUR_SCALAR)*2.0, 0.0, 1.0);\n            }\n            else if(delta >= 1.0)\n            {\n                \n            ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n                uv = next*weight+uv*(1.0-weight);\n\t\t\t\tfunction = FUNCTION_SPIRAL;\n            }\n            else\n            {\n                uv = next*weight+uv*(1.0-weight);\n\t\t\t\tfunction = FUNCTION_SPIRAL;\n            }\n        }\n        else if(function == FUNCTION_SPIRAL)\n        {\n            seedling += \n            depth += galaxy(uv*2.0-1.0)*ifs/float(max_i)/float(i);\n         \tuv = spiral(uv*2.0-1.0)*(1.0-ifs)+last*ifs;;\n                \n            function = FUNCTION_PERSPECTIVE;\n        }\n        \n        ifs = sqrt(ifs);\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*1.0*PI+shift;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    if(pow(ifs, 1.0/abs(float(last_i-max_i))) < 1.0/2.0) discard;//DIVERGANCE + Free motion blur :)\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(saw(depth*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[770, 770, 792, 792, 989], [991, 991, 1016, 1016, 1747], [1797, 1797, 1826, 1826, 1896], [1898, 1898, 1927, 1927, 2011], [2057, 2057, 2080, 2080, 3203], [3253, 3253, 3275, 3275, 3545], [3547, 3547, 3566, 3566, 3612], [3614, 3614, 3640, 3640, 3679], [3680, 3680, 3702, 3702, 3860], [3862, 3862, 3925, 3925, 4498], [4500, 4500, 4557, 4557, 7100]], "test": "valid"}
{"id": "4dVSR1", "name": "shades of radial blur", "author": "tomaes", "description": "upper side is radial blured, lower side a bit motion blured. Not the best way to show off the effects of both, but ok. :)", "tags": ["pseudo3d", "radialblur"], "likes": 5, "viewed": 266, "published": "Public", "date": "1462907622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r(vec2 _uv, float _t)\n{\n    float b = sin(_t+5.*(_uv.x*.1/_uv.y*.5));\n    float c = .1/sqrt( .01/fract( 2.*distance(_uv,vec2(b,b+_uv.x)))   ); \n    return mod(c,.4) * (1.-length(_uv)) * 9.;    \n}\n\nfloat rb(vec2 _uv, float _t)\n{\n    float v = .0;\n    \n    for(float f = 1.; f > .0; f -= .02)\n        v += r(_uv*f,_t)*.02;\n\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    float t = iTime;   \n    \n    uv.y += sin(t+3.1459*1.5*uv.x)*.03;\n    \n    float c = r(uv,t) - r(uv,t+.1);\n    \n    c += (r( vec2(uv.x-.025,uv.y     ),t ) + \n          r( vec2(uv.x+.025,uv.y     ),t ) +\n          r( vec2(uv.x     ,uv.y+.025),t ) +\n          r( vec2(uv.x     ,uv.y-.025),t ))*.15;\n    \n    if (uv.y > .0)\n    \tc = rb(uv,t);\n\n\tfragColor = vec4(c-uv.y*.6,c*.8,c*.5, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 201], [203, 203, 233, 233, 343], [346, 346, 403, 403, 854]], "test": "valid"}
{"id": "4dVSRm", "name": "Dancing Rainbow", "author": "innovati", "description": "Dancing rainbow bars", "tags": ["rainbow", "dancing"], "likes": 1, "viewed": 100, "published": "Public", "date": "1463524055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = sin(\n    reflect(\n      vec4(\n        (fragCoord.y / iResolution.y),\n        iTime,\n        (fragCoord.y / iResolution.y),\n        1.1\n      ),\n      atan(\n        vec4(\n          reflect(iTime, (iTime * 0.4)),\n          (1.3 * 1.6),\n          iTime,\n          1.1\n        )\n      )\n    )\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 367]], "test": "error"}
{"id": "4dVSWR", "name": "Candy core", "author": "tdhooper", "description": "Playing with https://www.shadertoy.com/view/lsV3RV and reduced trace iterations", "tags": ["sdf"], "likes": 18, "viewed": 701, "published": "Public API", "date": "1463790392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n#define t iTime\n\n\n// HG_SDF\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n        // Fold in corner A \n        \n        vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n        vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            // Get corners of triangle created by fold\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n            \n            // Fold in corner A\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n            // Fold in corner B\n            \n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n\n    return p;\n}\n\nvec3 pRoll(inout vec3 p) {\n    //return p;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n    return p;\n}\n\nvec3 lerp(vec3 a, vec3 b, float s) {\n\treturn a + (b - a) * s;\n}\n\nfloat face(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    p = reflect(p, rn);\n\treturn min(\n        fPlane(p, vec3(0,0,-1), -1.4),\n        length(p + vec3(0,0,1.4)) - 0.02\n    );\n}\n\nvec3 planeNormal(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    return reflect(p, rn);  \n}\n\n\n\n #define t1 t*1.5\n #define t2 t/2.\n #define t3 t/2.\n #define t4 t/2.\n #define t5 t/8. \n #define t6 t/16.\n\n\nfloat inner(vec3 p) {\n    p += vec3(0.,0.,2.);\n    pR(p.xy, t1);\n    pR(p.zy, t2);\n\treturn fBox(p, vec3(.5,.1,.2));\n}\n\nfloat exampleModelC(vec3 p) {\n    pR(p.xy, t3);\n    pR(p.yz, t4);\n\t pModIcosahedron(p, 2);\n     pR(p.xy, t5);\n     pR(p.yz, t6);\n\tpModIcosahedron(p, 1);\n    p = planeNormal(p);\n    float b = inner(p);\n    return b;\n}\n\nfloat exampleModel(vec3 p) {\n    //pRoll(p);\n\treturn exampleModelC(p);\n}\n\nvec3 doBackground(vec3 rayVec) {\n    return vec3(.13);\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 200.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 10;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n    return (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){\n    vec2 res = vec2(exampleModel(p) ,1.); \n    return res;\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    camPos = vec3(0.0,0.0,22.0);\n\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = doBackground(rd);\n  \n    if (res.y == 2.) {\n        return vec3(0.987,0.257,1.000);\n    }\n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\tcolor = norm * 0.5 + 0.5;\n    float split = 1. - dot(pos, norm);\n    float light = dot(ref, normalize(vec3(0,1,1)));\n    light *= clamp((1.-split), 0., 1.);\n\tcolor *= split * 0.8;\n    color = clamp(color, vec3(0), vec3(1));\n    color += light * 0.5;\n\t//color = vec3(light);\n    \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, t, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,20.) ); // 2.0 is the lens length\n    vec2 res = calcIntersection( ro , rd  );\n\n    \n    vec3 color = render( res , ro , rd );\n    \n    fragColor = vec4(color,1.0);\n}\n\n//void main() {\n//    mainImage(gl_FragColor, gl_FragCoord.xy);\n//}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 76, 76, 111], [113, 113, 169, 169, 214], [216, 252, 280, 280, 361], [363, 601, 633, 633, 678], [680, 708, 770, 770, 894], [981, 981, 1005, 1038, 1473], [1475, 1504, 1557, 1557, 1626], [1628, 1628, 1682, 1682, 2855], [2857, 2857, 2883, 2899, 3068], [3070, 3070, 3106, 3106, 3133], [3135, 3135, 3155, 3191, 3368], [3370, 3370, 3396, 3432, 3514], [3625, 3625, 3646, 3646, 3742], [3744, 3744, 3773, 3773, 3960], [3962, 3962, 3990, 4006, 4034], [4036, 4036, 4068, 4068, 4092], [4355, 4449, 4478, 4478, 4524], [4527, 4611, 4630, 4630, 4691], [4695, 4695, 4743, 4743, 5216], [5219, 5250, 5314, 5314, 5492], [5494, 5494, 5573, 5573, 5636], [5639, 5752, 5783, 5783, 6027], [6032, 6032, 6076, 6076, 6626], [6630, 6630, 6687, 6687, 7295]], "test": "valid"}
{"id": "4dVXW1", "name": "Heat Blob", "author": "aiekick", "description": "You can use mouse x,y to control the shape", "tags": ["blob", "heat"], "likes": 29, "viewed": 873, "published": "Public API", "date": "1464133547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n#define BLACKBODY_ALTERNATE\n\nvec2 m = vec2(1.6, 1.92);\n\nfloat dstepf = 0.0;\n\n// famous function from shane\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(5.46,62.8,164.98); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*1000.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y);\n}\n\nvec2 df(vec3 p)\n{\n\tfloat y = length(p)-1.-Voronesque(p) * -m.x;\n\tvec2 res = vec2(max(-y, y)-m.y, 1);\n    dstepf += 0.02;\n    return res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#ifndef BLACKBODY_ALTERNATE\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 561e5 * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 1e2 * log(Temp) - 623.;\n   \tif (Temp > 6500.) col.y = 352e5 * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194. * log(Temp) - 1448.;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1e3) col *= Temp/1e3;\n   \treturn col;\n}\n#else\n// Steel Lattice - https://www.shadertoy.com/view/4tlSWl\nvec3 blackbody(float t){\n\n    // t = tLow + (tHigh - tLow)*t;\n    //t *= 4000.; // Temperature range. Hardcoded from 0K to 4000K, in this case. \n    \n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n                    \n   return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n#endif\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint) \n{\n\tfloat ms = 0.2; // min step len\n\tvec3 n = nor(surfPoint,0.01); \n\tvec3 p = surfPoint - n * ms; \n\tfloat s = df(p).x;\n\treturn s/ms; // s < 0. => inside df\n}\n\nvec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.01);\n\tvec3 refl = reflect(rd,n);\n\t\t\n\tvec3 lightdir = normalize(lightpos - p);\n\tfloat lightlen = length(lightpos - p);\n\t\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, lightdir ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, lightdir ), 0.0, 1.0 ),16.);\n        \n\tvec3 brdf = vec3(0);\n\tbrdf += amb * vec3(1,0,0); // color mat\n\tbrdf += diff * 0.6;\n\tbrdf += spe * lc * 0.8;\n\t\n\treturn vec4(brdf, lightlen);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n     \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n    \n    if (iMouse.z > 0.)\n    \tm *= iMouse.xy/si;\n    \n    vec3 col = vec3(0.);\n    \n\tfloat elev = 0.;\n\tfloat ang = t * 0.24;\n\tfloat dist = 4.;\n\tvec3 ro = vec3(cos(ang), elev, sin(ang));\n\tro.xz *= dist;\n\t\n\t// first point close to the cam, light for the first plane\n    vec3 lpNear = ro;\n        \n  \tvec3 cv = vec3(0);\n\t\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 10.;\n    float s = 1., so = s;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.025*log(d)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * (s>0.1?0.15:0.1);\n    }\n    \n\tif (d<md)\n\t{\n        // light close to cam\n\t\tvec4 lightNear = light(ro, rd, d, lpNear, vec3(1));\n\t\tfloat attenNear = 0.35 / lightNear.w; // basic attenuation\n\t\tcol += lightNear.rgb * attenNear;\n\t\t\n        // heat\n        vec3 p = ro + rd * d;\n\t\tfloat sb = 1.-SubDensity(p);\n#ifndef BLACKBODY_ALTERNATE\n\t\tcol += blackbody(900.*sb-1000.);\n#else\n        col += blackbody(550.*sb+200.);\n#endif\n\t}\n\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVXW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[291, 321, 352, 352, 918], [920, 920, 937, 937, 1058], [1060, 1060, 1097, 1097, 1309], [2714, 2796, 2831, 2831, 2986], [2988, 2988, 3051, 3051, 3556], [3558, 3558, 3604, 3604, 3773], [3775, 3775, 3832, 3832, 4951]], "test": "valid"}
{"id": "4dVXWD", "name": "Seascape with geometry", "author": "udart", "description": "Combination of seascape\nhttps://www.shadertoy.com/view/Ms2SD1\nand this\nhttps://www.shadertoy.com/view/Mdt3RX\n\nJust learning by cutting and pasting and tinkering.", "tags": ["sea", "radiolarian"], "likes": 4, "viewed": 256, "published": "Public", "date": "1464463802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\n#define t iTime\n\n\nvec2 rot2D(vec2 p, float angle) {\n\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n        \n    \n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nvec3 pModDodecahedron(inout vec3 p) {\n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    p.z = abs(p.z);\n    \n    pR(p.xz, -halfDdihedral);\n    pR(p.xy, faceAngle / 4.);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n    \n    return p;\n}\n\nvec3 pModIcosahedron(inout vec3 p) {\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float sides = 3.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n\n    p.z = abs(p.z);    \n    pR(p.yz, halfDdihedral);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n     \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n  \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n\n\treturn p;\n}\n\nfloat spikeModel(vec3 p) {\n    pR(p.zy, PI/2.);\n    return fCone(p, 0.25, 3.);\n}\n\nfloat spikesModel(vec3 p) {\n    float smoother = 0.6;\n    \n    pModDodecahedron(p);\n    \n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    float spikeA = spikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = spikeModel(p);\n\n    pR(p.xy, -faceAngle);\n    pR(p.zy, dihedral);\n    \n    float spikeC = spikeModel(p);\n    \n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            smoother\n       \t),\n        smoother\n   \t);\n}\n\nfloat coreModel(vec3 p) {\n    float outer = length(p) - .9;\n\tfloat spikes = spikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n\treturn outer;\n}\n\nfloat exoSpikeModel(vec3 p) {\n    pR(p.zy, PI/2.);\n    p.y -= 1.;\n    return fCone(p, 0.5, 1.);\n}\n\nfloat exoSpikesModel(vec3 p) {\n    pModIcosahedron(p);\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float dihedral = acos(dot(v1, v2));\n\n    float spikeA = exoSpikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = exoSpikeModel(p);\n\n    return fOpUnionRound(spikeA, spikeB, 0.5);\n}\n\nfloat exoHolesModel(vec3 p) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += 1.5;\n    return length(p) - .65;\n}\n\nfloat exoModel(vec3 p) {    \n    float thickness = 0.18;\n    float outer = length(p) - 1.5;\n    float inner = outer + thickness;\n\n    float spikes = exoSpikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.3);\n\t\n    float shell = max(-inner, outer);\n\n    float holes = exoHolesModel(p);\n\tshell = fOpIntersectionRound(-holes, shell, thickness/2.);\n    \n\treturn shell;\n}\n\n// Based on Template 3D by iq: https://www.shadertoy.com/view/ldfSWs\n\nfloat doModel(vec3 p) {\n    p.y -= 3.0;\n    \n    p.xz = rot2D(p.xz, (iTime) * 45.);\n    \n    float exo = exoModel(p);\n    float core = coreModel(p);\n    return min(exo, core);\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float an = 10.0 * mouse.x + PI / 2.;\n    //an = 10.;\n\n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - mouse.y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(mouse.y * PI / 2.),\n        cos(an)\n    ) * d;\n\n   \tcamTar = vec3(0);\n}\n\nvec3 doBackground(void) {\n    return vec3(0.0);\n}\n\nvec3 doMaterial(in vec3 pos, in vec3 nor) {\n    return vec3(0.25);\n}\n\n\nfloat doRulerModel(vec3 p) {\n    return 1000.0;\n    float t = 0.1;\n    return abs(p.y) - mod(t/5., 1.);\n}\n\nfloat rule(float d, float scale) {\n    return mix(1., .35, smoothstep(.6, 1., abs(fract(d * scale) * 2. - 1.)));\n}\n\nvec3 rulerColor(float t) {\n    t = clamp(log(t+1.0), 0.0, 1.0);\n    return mix(mix(vec3(0.,.1,1.), vec3(1.,.1,0.), t*5.), vec3(1.0), smoothstep(.2,.5,t));\n}\n\nvec3 doRulerMaterial(vec3 p, float d, float t) {\n    float lt = log(t) / log(10.0);\n    float s = pow(10.0, -floor(lt));\n    float m = smoothstep(0.0, 0.33, fract(lt));\n    float r = rule(d, s * 10.) * mix(rule(d, s * 100.0), rule(d, s), m);\n    return mix(rulerColor(s * d), rulerColor(s * d * 0.1), m) * 0.8 * r;\n}\n\nfloat doCombinedModels(vec3 p) {\n    return min(doModel(p), doRulerModel(p));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd);\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    //vec3 lig = normalize(vec3(1.1, 0.7, 0.9));\n    vec3 lig = normalize(vec3(0.0,1.0,0.8)); \n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0;\n    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n    lin += dif * vec3(2.) * sha;\n\n    // ambient light\n    //-----------------------------\n    //lin += vec3(0.5);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal * lin;\n\n    // fog\n    //-----------------------------\n    //col *= exp(-0.01 * dis * dis);\n\n    //Specular\n    float nrm = (60.0 + 8.0) / (3.1415 * 8.0);\n    col += pow(max(dot(reflect(rd,nor),lig),0.0),60.0) * nrm;\n \n//////experiment\n    \n    float fresnel = 1.0 - max(dot(nor,rd),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n    \n    //sky color\n\tvec3 e = reflect(rd,nor);\n    \n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    //Reflected\n    vec3 reflected = ret*0.05;\n\n    //Sea color\n    vec3 base = vec3(0.03,0.01,0.01);\n    vec3 scolor = vec3(0.1,0.04,0.0);\n\n    float diffuse = pow(dot(nor,lig) * 0.4 + 0.6,80.0)*200.0;\n  \t\n    //Refracted\n    vec3 refracted = base + diffuse * scolor * 0.32; \n    \n\t//Experiment - overwrite color\n\tcol = mix(refracted,col,fresnel);    \n    \n    //\n    \n    return col;\n}\n\nvec3 calcIntersection(in vec3 ro, in vec3 rd) {\n    const float maxd = 100.0;    // max trace distance\n    const float precis = 0.00001; // precission of the intersection\n    vec3 p;\n    float h = precis * 2.0;\n    float d, r;\n    float t = 0.0;\n    float res = -1.0;\n    for (int i = 0; i < 90; i++) // max number of raymarching iterations is 90\n    {\n        if (h < precis || t > maxd) break;\n        p = ro + rd * t;\n        r = doRulerModel(p);\n        d = doModel(p);\n        h = min(d, r);\n        t += h;\n    }\n\n    if (t < maxd) res = t;\n    return vec3(res, r < d ? 1.0 : 0.0, d);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float eps = 0.002; // precision of the normal computation\n\n    const vec3 v1 = vec3(1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3(1.0, 1.0, 1.0);\n\n    return normalize(v1 * doCombinedModels(pos + v1 * eps) + \n                     v2 * doCombinedModels(pos + v2 * eps) +\n                     v3 * doCombinedModels(pos + v3 * eps) + \n                     v4 * doCombinedModels(pos + v4 * eps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.0005; // selfintersection avoidance distance\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps\n        h = doModel(ro + rd * t);\n        res = min(res, 64.0 * h / t); // 64 is the hardness of the shadows\n        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\n/*\n\"Seascape\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\nconst int NUM_STEPS = 4;\n//const float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 1; //3\nconst int ITER_FRAGMENT = 4; //5\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.03,0.01,0.01);\nconst vec3 SEA_WATER_COLOR = vec3(0.1,0.04,0.0);\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p)*200.0;\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret*0.05;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p, float SEA_TIME) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p, float SEA_TIME) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps, float SEA_TIME) {\n    vec3 n;\n    n.y = map_detailed(p, SEA_TIME);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z), SEA_TIME) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps), SEA_TIME) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p, float SEA_TIME) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx, SEA_TIME);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm, SEA_TIME);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p, SEA_TIME);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat EPSILON_NRM\t= 0.1 / iResolution.x;\n\tfloat SEA_TIME = iTime * SEA_SPEED;\n\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    //vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);   \n    vec3 ang = vec3(0.0, 0.3, 0.0);\n    vec3 ori = vec3(0.0,4.5, 7.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n\n    //360 camera\n//   vec2 texCoord = fragCoord.xy / iResolution.xy; \n//    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n//    dir = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n\n\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p, SEA_TIME);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM, SEA_TIME);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n  \n    \n        //\n    \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n    \n    //\n\n    vec3 t = calcIntersection(ori, dir);\n    if (t.x > -0.5) {\n        // geometry\n        vec3 pos = ori + t.x * dir;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal;\n        if (t.y > 0.) {\n            mal = doRulerMaterial(pos, t.z, t.x);\n        \t//mal = doLighting(pos, nor, rd, t.x, mal);\n        } else {\n            mal = doMaterial(pos, nor);\n        }\n        \n        color = doLighting(pos, nor, dir, t.x, mal);\n    }\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 107, 107, 231], [247, 247, 302, 302, 437], [439, 535, 584, 584, 1083], [1085, 1113, 1175, 1175, 1281], [1283, 1521, 1553, 1553, 1595], [1597, 1676, 1724, 1724, 1855], [1857, 1970, 2020, 2020, 2410], [2413, 2413, 2450, 2450, 3315], [3317, 3317, 3353, 3353, 4178], [4180, 4180, 4206, 4206, 4260], [4262, 4262, 4289, 4289, 4943], [4945, 4945, 4970, 4970, 5100], [5102, 5102, 5131, 5131, 5199], [5201, 5201, 5231, 5231, 5539], [5541, 5541, 5570, 5570, 5661], [5663, 5663, 5687, 5687, 6036], [6108, 6108, 6131, 6131, 6285], [6287, 6287, 6366, 6366, 6626], [6628, 6628, 6653, 6653, 6677], [6679, 6679, 6722, 6722, 6747], [6750, 6750, 6778, 6778, 6855], [6857, 6857, 6891, 6891, 6971], [6973, 6973, 6999, 6999, 7129], [7131, 7131, 7179, 7179, 7447], [7449, 7449, 7481, 7481, 7528], [7577, 7577, 7659, 7659, 9053], [9055, 9055, 9102, 9102, 9647], [9649, 9649, 9679, 9679, 10167], [10169, 10169, 10215, 10215, 10629], [10631, 10631, 10693, 10693, 10867], [11442, 11450, 11476, 11476, 11822], [11823, 11823, 11845, 11845, 11925], [11926, 11926, 11952, 11952, 12253], [12255, 12267, 12305, 12305, 12353], [12354, 12354, 12400, 12400, 12504], [12506, 12513, 12539, 12539, 12682], [12684, 12691, 12732, 12732, 12903], [12905, 12905, 12940, 12940, 13384], [13386, 13386, 13430, 13430, 13874], [13876, 13876, 13939, 13939, 14426], [14428, 14439, 14490, 14490, 14711], [14713, 14713, 14785, 14785, 15327], [15329, 15337, 15394, 15394, 17148]], "test": "valid"}
{"id": "4dVXzR", "name": "Galactic Night", "author": "vox", "description": "Galactic Night", "tags": ["galacticnight"], "likes": 2, "viewed": 499, "published": "Public API", "date": "1462487076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n#define TIMES_DETAILED (1.0)\n//#define TIMES_DETAILED (5.0+sin(time*PI*1.0)*.1)\n\n//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS (2.0/max(iResolution.x, iResolution.y))\n\n#define time ((saw(float(__LINE__))+.5)*(iTime/PI+12345.12345))\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\n\nvec2 mobius(vec2 uv)\n{\n    float galacticwind = floor(saw(seedling*1.0*PI)*2.0);\n\tvec2 a = sin(seedling*2.10*PI*galacticwind+vec2(time*1.0*PI, time*GR/E*1.0*PI));\n\tvec2 b = sin(seedling*2.20*PI*galacticwind+vec2(time*1.0*PI, time*GR/E*1.0*PI));\n\tvec2 c = sin(seedling*2.30*PI*galacticwind+vec2(time*1.0*PI, time*GR/E*1.0*PI));\n\tvec2 d = sin(seedling*2.40*PI*galacticwind+vec2(time*1.0*PI, time*GR/E*1.0*PI));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius((uv*2.0-1.0))*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 1; i < iters; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    \n    float sound;\n    \n   \tconst int max_i =32;\n    int last_i;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    float total = 0.0;\n    float height = lowAverage();\n    seedling = height+time;\n    for(int i = 0; i < max_i; i++)\n    {\n        last_i = i;\n        sound = texture(iChannel0, uv).r;\n        seedling += fract(float(i)*123456.123456)+sound;\n        \n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(0.0, 0.125, ifs);\n        \n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        total += ifs;\n        \n        uv = next*weight+uv*(1.0-weight);\n        float delta = sphereN(uv*2.0-1.0).z*ifs;\n        depth += 1.0-delta*sound;\n        \n\t\tif(ifs <= EPS)\n            break;\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    \n    float s = simplex3d(vec3(uv*iResolution.xy, time));\n    //fragColor = vec4(vec3(sound), 1.0);return;\n    \n    if(pow(ifs, 1.0/float(last_i+1)) > .25+.25*simplex3d(vec3(fragCoord.xy/iResolution.xy, time*3.0*PI)))\n    {\n        if(sound < .125)\n            fragColor = vec4(0.0);\n        else\n        \tdiscard;\n        return;\n    }\n    \n    fragColor = vec4(uv, 0.0, 1.0);\n\n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = simplex3d(vec3(fragCoord.xy/iResolution.xy+uv, time))*sound+depth;\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n\n\n    vec3 final = (\n        vec3(saw(stripes*PI*2.0+shift),\n             saw(4.0*PI/3.0+stripes*PI*2.0+shift),\n             saw(2.0*PI/3.0+stripes*PI*2.0+shift)\n            )\n    )*black\n        +white;\n\n    fragColor = vec4(vec3(ifs), 1.0);\n\n    fragColor = vec4(saw((depth)));\n    sound = texture(iChannel0, uv).r;\n    fragColor = vec4(final, 1.0)*smoothstep(0.0, .1, height);\n    \n    //fragColor = vec4(simplex3d(vec3(fragCoord.xy/iResolution.xy, time)));\n}\n", "image_inputs": [{"id": "XdXGWS", "previewfilepath": "https://soundcloud.com/desertdwellers/crossing-beyond-govinda-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/desertdwellers/crossing-beyond-govinda-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 654, 654, 724], [726, 726, 755, 755, 839], [886, 886, 908, 908, 1105], [1107, 1107, 1132, 1132, 1863], [1929, 1929, 1951, 1951, 2387], [2389, 2389, 2408, 2408, 2451], [2453, 2453, 2512, 2512, 3085], [3088, 3088, 3108, 3108, 3456], [3458, 3458, 3515, 3515, 5694]], "test": "error"}
{"id": "4dySRm", "name": "passing lights", "author": "tomaes", "description": "stuff", "tags": ["light", "green", "radialblur"], "likes": 5, "viewed": 224, "published": "Public", "date": "1463401828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r( vec2 _uv, float _t)\n{\n    float v = 1./length(_uv-(sin(_t+_uv.x)*.15/cos(_t+_uv.y)*.5)   )*.2;\n    \n    // \"flicker\" + bg\n\tv = v - .4*min(v,fract(_t*5.));\n    v = fract(v*_uv.x*2./_uv.y*2.) + v;\n    \n    return v;\n}\n\nfloat rb(vec2 _uv, float _t)\n{\n    float v = .0;\n    \n    for(float f = 1.; f > .0; f -= .05)\n        v += r(_uv*f,_t)*.05;\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    \n    float t = iTime + 3.1;   \n    float c = .0;\n    \n    for(float f = .0; f < 10.; f += .5)\n\t\tc += sin(f*f+length(uv)) * cos( (.5+uv.x*uv.y) * rb(uv,(t+f)*.5 ) );\n    \n    fragColor = vec4(c-length(uv)*.6,c*.7,c*.4+uv.x*.1, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dySRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 224], [226, 226, 256, 256, 370], [372, 372, 429, 429, 727]], "test": "valid"}
{"id": "4dySWD", "name": "Shadow fx", "author": "gigatron", "description": "shadow noise ", "tags": ["noise", "texture", "shadow"], "likes": 1, "viewed": 135, "published": "Public", "date": "1464283050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Sort of a cross between https://www.shadertoy.com/view/MdXSD8 and\n//https://www.shadertoy.com/view/4dfSD4\n\n#define M_PI 3.1415926535\n\n#define tt iTime/10.\n\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec4 getFragColor(float noiseValue) {\n\tvec4 fragColor;\n\tfragColor.r = fract(noiseValue-tt)*0.20;\n    fragColor.b = fract(noiseValue-tt)*0.20;\n    fragColor.g = fract(noiseValue-tt)*0.20;\n\n\tfragColor.a = 1.0;\n\treturn fragColor-0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat t=iTime/2.;\n\tvec3 col=vec3(0.);\n\t\n\tvec3 tc=texture(iChannel0,uv).rgb;\n\tfloat smp=texture(iChannel1,uv).x;\n\t\n\tcol = getFragColor(cnoise(vec2( t-(uv.y*5.+(smp/10.)), uv.x*5.0+(smp/5.)))).rgb+tc;\n    \n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dySWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 180, 180, 229], [231, 231, 253, 253, 290], [292, 292, 320, 320, 372], [374, 374, 393, 393, 433], [435, 459, 481, 481, 1523], [1525, 1525, 1562, 1562, 1757], [1759, 1759, 1816, 1816, 2098]], "test": "error"}
{"id": "4dySzD", "name": "Crazy random shader", "author": "xem", "description": "A super-weird random shader generated by http://xem.github.io/shaderandom\nTry it out and share your best findings!", "tags": ["random"], "likes": 2, "viewed": 494, "published": "Public API", "date": "1463080951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = reflect(sin(step(max(vec4(0.4, 0.6, (fract((gl_FragCoord.y / iResolution.y)) / iTime), ceil(1.7)), vec4(0.0, 1.8, ((gl_FragCoord.x / iResolution.x) - 1.1), 1.7)), vec4((1.0 - 0.4), normalize((1.0 / 0.1)), (gl_FragCoord.x / iResolution.x), 1.6))), mod(pow(reflect(vec4(((gl_FragCoord.y / iResolution.y) / (0.2 / 0.0)), 0.5, (gl_FragCoord.x / iResolution.x), 0.6), sin(degrees(max(atan(radians(cos(max(vec4(((gl_FragCoord.y / iResolution.y) * iTime), 0.1, 1.8, log(min(0.4, ((1.9 + log2(1.5)) / 1.3)))), pow(normalize(vec4(1.2, 0.7, 0.1, (1.3 / 1.4))), step(vec4(degrees(acos((gl_FragCoord.y / iResolution.y))), 1.3, 0.0, 1.8), vec4((0.9 * 1.3), 1.2, (0.1 / 1.6), 0.0))))))), atan(mod(atan(reflect(pow(atan(vec4(1.3, sqrt((gl_FragCoord.x / iResolution.x)), min(float(iFrame), ((gl_FragCoord.x / iResolution.x) - 0.2)), (0.5 - iTime)), min(exp2(vec4(sign(1.6), 0.2, (0.5 - 0.5), 1.3)), sqrt(vec4(0.9, 0.7, 0.3, (0.0 / 0.2))))), vec4(0.0, 0.6, (gl_FragCoord.y / iResolution.y), 0.0)), vec4(0.1, ((gl_FragCoord.y / iResolution.y) / iTime), 0.4, ((iTime + 0.6) - 1.4))), vec4(1.4, 0.1, (1.1 + 0.6), ((0.8 / 0.4) + tan((gl_FragCoord.y / iResolution.y))))), vec4((gl_FragCoord.y / iResolution.y), float(iFrame), 0.6, 0.4)), vec4((gl_FragCoord.x / iResolution.x), (gl_FragCoord.x / iResolution.x), 0.1, 0.0)))))), degrees(acos(normalize(vec4(0.3, 1.7, min((gl_FragCoord.x / iResolution.x), 1.3), max(1.8, float(iFrame))))))), inversesqrt(atan(atan(vec4((0.8 * 1.5), 1.5, 0.6, 1.0), sin(reflect(vec4((gl_FragCoord.y / iResolution.y), min(0.9, 1.9), 0.4, cos(exp2(1.5))), vec4(iTime, 1.2, 0.4, 1.9)))), pow(vec4(0.5, (sqrt(float(iFrame)) + radians(1.6)), (gl_FragCoord.y / iResolution.y), (gl_FragCoord.x / iResolution.x)), max(pow(inversesqrt(pow(vec4(0.4, 1.3, 1.9, 1.5), vec4(0.9, (gl_FragCoord.y / iResolution.y), 1.1, 1.2))), step(floor(fract(max(step(min(vec4(1.3, 0.0, 0.1, iTime), vec4(1.4, 0.0, ((0.8 * (1.6 + 1.4)) + degrees(0.7)), 1.8)), inversesqrt(pow(floor(min(vec4(1.4, step((0.9 + 1.4), (gl_FragCoord.x / iResolution.x)), 0.3, (1.6 - 0.4)), vec4(0.7, (1.1 + 1.0), 0.5, (gl_FragCoord.y / iResolution.y)))), asin(step(max(atan(pow(vec4(0.5, (gl_FragCoord.y / iResolution.y), iTime, 0.6), vec4(1.4, 1.5, 1.4, 0.8)), abs(tan(vec4(sign(float(iFrame)), 0.9, 1.6, 0.8)))), vec4((gl_FragCoord.x / iResolution.x), 1.7, reflect(1.2, atan(1.8)), 1.5)), vec4((gl_FragCoord.y / iResolution.y), 1.2, 0.0, (1.0 * 1.3))))))), vec4(1.8, 1.3, 1.9, 1.5)))), vec4(0.8, iTime, min(0.1, 1.2), 0.3))), sin(vec4((0.9 + (0.6 * 1.8)), iTime, 0.3, float(iFrame)))))))));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dySzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 2615]], "test": "timedout"}
{"id": "4dySzm", "name": "Hill Country", "author": "innovati", "description": "It's endless hills around these parts", "tags": ["hill", "country"], "likes": 0, "viewed": 76, "published": "Public", "date": "1463417337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = mod(\n    vec4(\n      (1.2 - 0.6),\n      iTime,\n      (0.1 / 1.7),\n      fract(0.0)\n    ),\n    normalize(\n      vec4(\n        0.9,\n        1.4,\n        0.0,\n        (gl_FragCoord.y / iResolution.y)\n      )\n    )\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dySzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 289]], "test": "valid"}
{"id": "4dySzW", "name": "Purple Interference", "author": "innovati", "description": "Interference lines going across the screen!", "tags": ["interference", "static"], "likes": 1, "viewed": 73, "published": "Public", "date": "1463026015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = max(min(radians(inversesqrt(vec4(0.9, iTime, ceil(iTime), float(iFrame)))), atan(cos(sqrt(vec4(0.1, 0.0, 1.9, (1.2 / 1.3)))), atan(vec4((iTime + 1.9), (0.2 / 0.5), (gl_FragCoord.y / iResolution.y), float(iFrame)), vec4(0.7, 1.7, 1.3, 1.9)))), atan(normalize(max(cos(inversesqrt(mod(reflect(sin(vec4(1.4, iTime, iTime, ((mod(((gl_FragCoord.x / iResolution.x) / sqrt(0.3)), tan(0.6)) - (1.5 / 1.2)) * 0.8))), reflect(vec4(((gl_FragCoord.x / iResolution.x) + 0.2), 0.2, 0.3, (1.4 + 0.9)), vec4((((gl_FragCoord.x / iResolution.x) + ((0.9 * (1.0 * (((1.9 - 1.9) * normalize((reflect(1.1, 1.9) - 0.2))) * (1.5 * (gl_FragCoord.x / iResolution.x))))) + 0.4)) * 1.7), ((1.5 + max((gl_FragCoord.x / iResolution.x), 0.8)) / 0.5), 1.6, (gl_FragCoord.y / iResolution.y)))), degrees(vec4(1.7, 1.6, (gl_FragCoord.x / iResolution.x), float(iFrame)))))), vec4(0.6, 0.5, (gl_FragCoord.y / iResolution.y), 0.4))), atan(ceil(acos(vec4(0.7, 1.6, atan((gl_FragCoord.y / iResolution.y), 1.1), (float(iFrame) * 0.2)))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dySzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "4sdSDs", "name": "reality warp", "author": "tomaes", "description": "warped and shaded bathroom tiles.", "tags": ["grid", "wireframe", "monochrome", "lights", "neon"], "likes": 26, "viewed": 911, "published": "Public", "date": "1462219080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    \n    float t = (iTime+1.3)*2.;\n    float c = .0, d = .0, s = .0;\n    \n    for(float f = -5.; f < 1.; f += .6)\n    {\n        s = 20.;\n        \n        if (p.x > .0)\n        \ts = 20. + sin(  tan( (p.x+p.y)/(p.x/p.y))*10.  )*2.;\n        \t//s = 20. + sin(f+ sin(p.x/p.y)*5. )*10.;\n        \n        d = distance(\n              vec3( tan(p.x*s+t), tan(p.y*s+t), f ),\n              vec3( p.x*20., .0, -5. )\n            );\n        \n    \tc += d * sin(t + .5/p.x + cos(p.y)*5. ) * .01;\n    }\n    \n\tfragColor = vec4(.5-c, .6-c*.25,1.-c*.5, 1.);//vec4(1.-c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 670]], "test": "valid"}
{"id": "4sGSzD", "name": "xem random 7", "author": "xem", "description": "random", "tags": ["random"], "likes": 1, "viewed": 374, "published": "Public API", "date": "1463080400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = reflect(mod(sin(exp(mod(vec4(float(iFrame), 1.7, 1.9, 1.8), pow(vec4(pow(0.3, 0.7), 0.9, (gl_FragCoord.x / iResolution.x), 0.5), vec4(0.8, float(iFrame), 0.9, ceil(0.8)))))), vec4(float(iFrame), ((max(((gl_FragCoord.y / iResolution.y) * 0.1), 0.2) / exp2(0.5)) + 0.1), 1.1, 1.6)), cos(vec4((gl_FragCoord.y / iResolution.y), 0.8, max(1.1, 0.5), (((1.5 * mod(atan((iTime / (gl_FragCoord.y / iResolution.y)), ((gl_FragCoord.y / iResolution.y) / 0.9)), 0.7)) - (float(iFrame) / (gl_FragCoord.x / iResolution.x))) + 1.6))));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "4sGXRR", "name": "Galaxies 1", "author": "vox", "description": "Galaxies 1", "tags": ["galaxies1"], "likes": 0, "viewed": 399, "published": "Public API", "date": "1462306258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR 2.0\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 1.0E-22\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(zoom*(uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 spiral(vec2 uv)\n{\n    return (1.0-saw(PI*(uv*.5+.5)));\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i = 32;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    float shift = time*PI*10.0;\n\n    float stripes;\n    float black = 1.0;\n        \n    \n    vec3 final = vec3(0.0);\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        \n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(0.0, 0.75, ifs);\n        \n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        float delta = sphereN(uv*2.0-1.0).z*ifs;\n        depth += (1.0-delta)*ifs;\n        \n    \tstripes = depth*PI*iResolution.x/4.0;\n    \tblack *= smoothstep(0.0, .75, saw(stripes));\n        final += (\n        \t\t\t\tvec3(saw(depth*PI*2.0),\n                \t  \t\tsaw(4.0*PI/3.0+depth*PI*2.0),\n                \t  \t\tsaw(2.0*PI/3.0+depth*PI*2.0)\n                 \t\t)\n        \t\t )*ifs;\n        \n    }\n    \n    \n    //fragColor = vec4(ifs);\n    \n    //depth /float(max_i);\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    if(pow(ifs, 1.0/float(max_i))*depth*black > EPS)\n    {\n        ifs = 1.0;\n        depth = 0.0;\n        uv = fragCoord.xy/iResolution.xy;\n        black = 1.0;\n        final = vec3(0.0);\n        discard;\n    }\n    black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n    fragColor = vec4(final*black+white, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[726, 726, 755, 755, 825], [827, 827, 856, 856, 940], [1018, 1018, 1040, 1040, 1278], [1280, 1280, 1299, 1299, 1351], [1353, 1353, 1375, 1375, 1414], [1416, 1416, 1475, 1475, 2048], [2050, 2050, 2107, 2107, 3782]], "test": "valid"}
{"id": "4sGXRW", "name": "Tricoleur", "author": "innovati", "description": "Recreating the French flag with webGL shaders", "tags": ["france", "tricoleur"], "likes": 0, "viewed": 103, "published": "Public", "date": "1463010589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = atan(\n    reflect(\n      sqrt(\n        vec4(\n          float(iFrame),\n          (gl_FragCoord.y / iResolution.y),\n          mod(1.1, iTime),\n          (1.8 - 1.2)\n        )\n      ),\n      log(\n        tan(\n          max(\n            min(\n              vec4(\n                0.2,\n                (gl_FragCoord.y / iResolution.y),\n                1.4,\n                1.5\n              ),\n              vec4(\n                (0.2 * 1.8),\n                ((max(1.9, ceil(max((gl_FragCoord.y / iResolution.y),1.5))) - 1.2) / 1.7),\n                (0.3 * 1.8),\n                1.2\n              )\n            ),\n            vec4(\n              (gl_FragCoord.x / iResolution.x),\n              1.2,\n              1.5,\n              0.3\n            )\n          )\n        )\n      )\n    ),\n    vec4(\n      0.7,\n      1.6,\n      (0.3 - 1.6),\n      (gl_FragCoord.y / iResolution.y)\n    )\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 951]], "test": "valid"}
{"id": "4sGXzz", "name": "On the Up and Up", "author": "cacheflowe", "description": "Endless arrows", "tags": ["arrows"], "likes": 15, "viewed": 649, "published": "Public API", "date": "1462380626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 128\nconst float twoPi = 6.283185307179586;\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat udBox( vec3 p, vec3 b ) {\n  return length(max(abs(p)-b,0.0));\n}\n \nfloat opRep( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return opU( sdTriPrism( q, vec2(0.9, 0.6) ), udBox( q + vec3(0,0.9,0), vec3(0.2, 0.6, 0.6) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// retrieve the fragment's coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n\n\t// camera position and ray direction\n\tvec3 pos = vec3( 0, -5.0 * iTime/twoPi, 2.3 + 0.3 * -sin(iTime));\n\tvec3 dir = normalize( vec3( uv.x, uv.y, 1.) );\n \n    // ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t// variable step size\n\tfloat t = 0.0;\n\tfloat findThresh = 0.01;\n\tint found = 0;\n    int last_i = 0;\n    \n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tlast_i = i;\n        \n        // update position along path\n        ip = pos + dir * t;\n \t\tfloat temp;\n\n\t\t// make a repeating SDF shape\n\t\ttemp = opRep( ip, vec3(5.0 + 0.8 * sin(iTime), 5.0 + 0.1 * sin(iTime), 9.0 + 2.0 * sin(iTime)) );\n\t\tif( temp < findThresh ) {\n\t\t\tfloat r = 0.5 + 0.3 * sin(2. + sin(iTime) + ip.z/6. + ip.x/2.);\n\t\t\tfloat g = 0.6 + 0.4 * cos(1. + sin(iTime) + ip.x/6. + ip.z/2.);\n\t\t\tfloat b = 0.6 + 0.3 * sin(1. + sin(iTime) + ip.z/6. + ip.x);\n\t\t\tip = vec3(g, r, b);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n\t// make background black if no shape was hit\n\tif(found == 0) {\n\t\tip = vec3(0,0,0);\n\t}\n \n\t// fragColor = vec4(ip, 1.0 - float(last_i) / float(ITERATIONS)/2. );\n   \tfragColor = vec4(ip - float(last_i) / float(ITERATIONS), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 96, 96, 121], [123, 123, 159, 159, 246], [248, 248, 279, 279, 317], [320, 320, 351, 351, 482], [485, 485, 542, 582, 1825]], "test": "valid"}
{"id": "4sKSDz", "name": "Tame Impala", "author": "ottopo", "description": "Inspired by Tame Impala artwork\nOttavio Hartman - 2016", "tags": ["tame", "impala"], "likes": 3, "viewed": 274, "published": "Public", "date": "1463842477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Ottavio Hartman - hartmano@sas.upenn.edu - https://github.com/omh1280\n\n#define PI 3.1415927\n#define NUM_STREAKS 12.\n#define STREAK_SIZE .15\n#define STREAK_WIDTH .3\n\n// HSV to RGB created by inigo quilez - iq/2014\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 _rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), _rgb, c.y);\n}\n\n// Cartesian and Polar conversions\nvec2 c2p(vec2 c) {\n    return vec2(length(c), atan(c.y, c.x));\n}\nvec2 p2c(vec2 p) {\n    return p.x*(vec2(cos(p.y), sin(p.y)));\n}\n\n// Rand and noise function. Credit to patriciogonzalezvivo\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n    float fl = floor(p);\n  \tfloat fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// Basic circle function\nfloat circle(vec2 uv, vec2 center, float radius) {\n    float delta = abs(noise(iTime))/30. + .01;\n    return smoothstep(radius + delta, radius - delta, length(uv - center));\n}\n\nfloat head(vec2 uv, vec2 center, float radius) {\n    vec2 uv2 = uv - center;\n    uv2.x /= .78;\n    \n    // Create cool \"expanding head\" technique\n    float sound = texture(iChannel0, vec2(abs(uv2.x*sin(uv2.y)), .25)).x;\n    uv2 *= 2.*noise(iTime*.5 + sound);\n    \n    // Create the head itself\n    vec2 rtheta = c2p(uv2);\n    float angle = rtheta.y;\n    float neck = 1.*pow(angle + .2, 2.) + .66;\n    float chin = .08*sin(7.*angle) + .92;\n    float face = .98 + sin((angle+.45)*7.)/22.;\n    \n    if ((angle < PI/10.) && (angle > -PI/4.)) {\n        uv2 /= neck;\n    } else if ((angle > PI/1.64) || (angle < -PI/1.03)) {\n\t\tuv2 /= face;\n    } else if (angle < -PI/2.) {\n        uv2 /= chin;\n    } else if ((angle < PI/1.64) && (angle > PI/10.)) {\n        // Cranium\n        uv2 /= .94;\n    }\n    \n    return circle(uv2 + center, center, radius);\n}\n\nfloat streak(vec2 uv, vec2 center, float radius) {\n    vec2 rtheta = c2p(uv);\n    vec2 center_p = c2p(center);\n    \n    // Make streaks skinny\n    rtheta.y -= (center_p.y - rtheta.y)/STREAK_WIDTH;\n    \n    // Waviness\n    rtheta.y += .1*noise(rtheta.x*60. + sin(rtheta.y));\n    \n    return circle(p2c(rtheta), center, radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    float maxX = iResolution.x/iResolution.y;\n\n    vec2 center = vec2(.5*maxX, .5);\n    vec2 rtheta = c2p(uv - center);\n    \n    // STREAKS\n    float radius = PI/(NUM_STREAKS*.5);\n    // Streaks' displacement away from head center\n    float disp = mod(.25*iTime, 1.);\n    // Repeat streaks in a circle\n    rtheta.y = mod(rtheta.y - .3*iTime, radius) - radius/2.;\n    vec2 uv2 = p2c(rtheta);\n    float i = streak(uv2, vec2(disp, 0.), STREAK_SIZE);\n    \n    // HEAD\n    float h = head(uv, center, .3);\n\n    // TRIPPY\n    vec3 pixel = vec3(0.08, 0.08, 0.15);\n    \n    // Streak colors (change as disp increases)\n    pixel = mix(pixel, hsv2rgb(vec3(disp, .73, 1.)), i*(length(uv2)));\n    \n    // Head color\n    vec3 pale = vec3(1.0, .88, .70);\n    pixel = mix(pixel, pale, h);\n    \n    // Trippy background\n\tfloat sound = texture(iChannel0, vec2(abs(uv2.x*sin(uv2.y)), .25)).x;\n\n    for (float i = 0.; i < 5.; i++) {\n    \tuv2 = p2c(c2p(uv2) + vec2(sin(.1*iTime), sin(.4*iTime*i)));\n    \tpixel += .1*(noise(iTime + noise(iTime*sin(uv2.x/uv2.y))*sin(uv2.x*10.)*rtheta.y)+ \n             noise(iTime*i + noise(iTime*sin(uv2.x+uv2.y))*sin(uv2.y*20.*i)*sound*i));\n    }\n    // More colors\n    pixel *= vec3(3.*noise(.1*iTime*(uv2.x * uv2.y)), 2.*noise(sound), sound);\n    \n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [{"id": "lsfGWf", "previewfilepath": "https://soundcloud.com/racso2099/the-less-i-know-the-better-vinyl", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/racso2099/the-less-i-know-the-better-vinyl", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 227, 254, 254, 382], [384, 419, 437, 437, 483], [484, 484, 502, 502, 547], [549, 608, 628, 628, 666], [667, 667, 688, 688, 785], [787, 812, 862, 862, 987], [989, 989, 1037, 1037, 1833], [1835, 1835, 1885, 1885, 2163], [2165, 2165, 2222, 2222, 3566]], "test": "error"}
{"id": "4sKSz1", "name": "Mandelbrot to tricorn", "author": "stduhpf", "description": "The formula of the complex mandelbrot set is z=sqr(z)+c\nThe formula of the complex tricorn set is z=sqr(conj(z))+c\n\nI used quaternion rotation in the hypercomplex plane to make a smooth transition between these two set.", "tags": ["2d", "fractal", "quaternion", "rotation", "morph", "mandelbar"], "likes": 4, "viewed": 200, "published": "Public", "date": "1462920473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int n = 64;\n\nvec4 qmult(vec4 a,vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.2;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec4 um = iMouse/iResolution.y;\n    vec4 quv= 3.*vec4(uv-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5),0,0);\n    vec4 qum= 3.*vec4(um.xy-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5),0,0);\n    vec4 s = normalize(vec4(0,0,1,1)); //the value of the vector should be (0,0,a,b) with (a,b)!=(0,0)\n    vec4 q = vec4(cos(time),0,0,0)+sin(time)*s;\n    vec4 qi = (vec4(cos(time),0,0,0)+sin(time)*s)*vec4(1,-1,-1,-1);\n    vec4 c = quv;// use qum istead of quv to make julia sets (not really interresting)\n    vec4 z = quv;\n    float f =0.;\n    for(int i=0;i<n;i++){\n        z = qmult(q,qmult(qmult(z,z),qi))+c; //\"rotate\" z at each iteration\n        f=max(f,length(z));\n        if(length(z)>2.)return;\n          }\n    \n    \n\tfragColor = vec4(cos(f));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 46, 46, 245], [249, 249, 306, 306, 1151]], "test": "valid"}
{"id": "4sKSzR", "name": "Muddy Cavern", "author": "zackpudil", "description": "A muddy tunnel.  Using Shane's distance formula for a tunnel, and adding noise to it. Just bored in a meeting.", "tags": ["raymarching", "tunnel", "attenuation"], "likes": 13, "viewed": 392, "published": "Public", "date": "1462481020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n\treturn fract(sin(n)*43578.4545);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0 - 2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\t\n\treturn mix(\n\t\tmix(\n\t\t\tmix(hash(n + 000.0), hash(n + 001.0), f.x),\n\t\t\tmix(hash(n + 057.0), hash(n + 058.0), f.x),\n\t\t\tf.y),\n\t\tmix(\n\t\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\t\n\tf += 0.500*noise(p); p *= 2.01;\n\tf += 0.250*noise(p); p *= 2.04;\n\tf += 0.125*noise(p);\n\t\n\tf /= 0.875;\n\treturn f;\n}\n\nvec2 path(float z) {\n\treturn vec2(sin(0.5*z), 2.0*cos(0.12*z));\n}\n\nvec3 camPath() {\n\tvec3 ro = vec3(0, 0, 2.0*iTime);\n\tro.xy = path(ro.z);\n\t\n\treturn ro;\n}\n\nvec3 lookat(vec3 ro) {\n\tvec3 la = ro + vec3(0, 0, 1);\n\tla.xy = path(la.z);\n\t\n\treturn la;\n}\n\nvec3 lightPath(vec3 la) {\n\tvec3 lp = la;\n\tlp.xy += 0.2*vec2(sin(iTime), cos(iTime));\n\t\n\t\n\treturn lp;\n}\n\nfloat map(vec3 p) {\n\tfloat r = 0.6*smoothstep(0.3, 1.0, noise(1.5*p));\n\tfloat f = 0.1*smoothstep(0.0, 1.0, fbm(6.0*p + 3.0*vec3(0, iTime, 0)));\n\t\n\tfloat l = length(p - lightPath(lookat(camPath()))) - 0.01;\n\tvec2 tun = abs(p.xy - path(p.z))*vec2(.6, 3);\n\tfloat t = 1.0 - max(tun.x, tun.y);\n\treturn min(l, t - (r + f));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\t\n\tfor(int i = 0; i < 150; i++) {\n\t\tfloat h = map(ro + rd*t);\n\t\tif(abs(h) < 0.0001 || t >= 30.0) break;\n\t\tt += h*0.5;\n\t}\n\t\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.01, 0.0);\n\t\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\t\n\treturn normalize(n);\n}\n\n\nmat3 camera(vec3 e, vec3 l) {\n\tvec3 f = normalize(l - e);\n\tvec3 r = normalize(cross(vec3(0, 1, 0), f));\n\tvec3 u = normalize(cross(f, r));\n\t\n\treturn mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*(fragCoord.xy/iResolution.xy))*vec2(iResolution.x/iResolution.y, 1.0);\n\t\n\tvec3 ro = camPath();\n\t\n\tvec3 la = lookat(ro);\n\t\n\tvec3 rd = camera(ro, la)*normalize(vec3(uv, 1.97));\n\t\n\tvec3 col = vec3(0);\n\t\n\tfloat i = march(ro, rd);\n\t\n\tif(i < 30.0) {\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\t\t\n\t\tvec3 rig = lightPath(la);\n\t\tvec3 lig = normalize(rig - pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat dis = max(length(pos - rig), 0.001);\n\t\tif(dis <= 0.015) {\n\t\t\tcol = vec3(1);\n\t\t} else {\n\t\t\tfloat att = 1.0/(1.0 + 1.5*dis + 2.0*dis*dis);\n\t\t\t\n\t\t\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\t\t\tfloat spe = pow(clamp(dot(lig, ref), 0.0, 1.0), 32.0);\n\t\t\t\n\t\t\tcol =  0.7*dif*vec3(1);\n\t\t\tcol *= vec3(0.8, 0.6, 0.2);\n\t\t\tcol += spe*vec3(1)*dif;\n\t\t\t\n\t\t\tcol *= att;\n\t\t}\n\t}\n\t\n\tcol = pow(col, vec3(.4545));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 57], [59, 59, 80, 80, 432], [434, 434, 453, 453, 587], [589, 589, 609, 609, 654], [656, 656, 672, 672, 743], [745, 745, 767, 767, 835], [837, 837, 862, 862, 939], [941, 941, 960, 960, 1260], [1262, 1262, 1293, 1293, 1445], [1447, 1447, 1468, 1468, 1647], [1650, 1650, 1679, 1679, 1814], [1816, 1816, 1873, 1873, 2722]], "test": "valid"}
{"id": "4sKXRw", "name": "Requiem for a CPC", "author": "Virgill", "description": "Requiem for a CPC / Haujobb and Alcatraz\nhttps://www.youtube.com/watch?v=GIFrs7dqv1E", "tags": ["raymarching", "tunnel", "postprocessing", "sdf", "refraction", "demoscene", "particles", "ice"], "likes": 20, "viewed": 1460, "published": "Public API", "date": "1463506103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//***************************************************************************************************\n//\n// Requiem for a CPC  /  Haujobb and Alcatraz\n// Jochen \"Virgill\" Feldkoetter\n//\n// 4k Intro for Nordlicht demoparty 2016      Shadertoy version\n//\n//***************************************************************************************************\n\n\n//const int efx_ = 3;\nint efx_=0;\nvec2 ku=vec2(0);\n\n\n//***************************************************************************************************\n// domain repetition and rotation functions\n//***************************************************************************************************\n\nvec2 pMod(inout vec2 p,vec2 size) \n{\n    vec2 hz=size/2.;\n\tvec2 c=floor((p+hz)/size);\n\tp=mod(p+hz,size)-hz;\n\tp*=mod(c,vec2(2))*2.-vec2(1);\n    if (efx_!=0)\n    {\n\t\tp-=hz;\n\t\tif (p.x>p.y) p.xy=p.yx;\n    }\n\treturn floor(c/2.);\n}\n\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n//***************************************************************************************************\n// sdf box\n//***************************************************************************************************\n\nfloat fBox(vec3 p, vec3 b) \n{\n\tvec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n//***************************************************************************************************\n// noise functions\n//***************************************************************************************************\n\nfloat snoise(vec3 p){\n    \n    const vec3 s=vec3(7,157,113);\t\n    vec3 ip=floor(p);    \n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);    \n    p-=ip;\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5453),fract(sin(h+s.x)*43758.5453),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\t\n}\n\nfloat noise(vec3 n)\n{\n \treturn snoise(n)*.6+snoise(n*2.)*.4;\n}\n\n//***************************************************************************************************\n// particle function\n//***************************************************************************************************\n\nfloat particles(vec3 direction)\n{\n\tfloat accumulate=0.;\n    const mat3 p=mat3(13.3,23.5,21.7,21.1,28.7,11.9,21.8,14.7,61.3);\n\tvec2 uvx=vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy/iResolution.xy;\n\tfloat DEPTH = direction.y*direction.y-.3;\n\tfor (float fi=0.;fi<10.;fi++) \n\t{\n\t\tvec2 q=uvx*(1.+fi*DEPTH)+vec2(DEPTH,0.2*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n=vec3(floor(q),31.1+fi);\n\t\tvec3 m=floor(n)*.0001 + fract(n);\n\t\tvec3 r=fract((31415.+m)/fract(p*m));\n\t\tvec2 s=abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d=s.x+s.y+0.7*max(s.y,s.x)-.01;\n\t\tfloat edge=.06;\n\t\taccumulate+=smoothstep(edge,-edge,d)*r.x;\n\t}\n\treturn accumulate;\n\t}\n\n//***************************************************************************************************\n// signed distance functions\n//***************************************************************************************************\n\n// \tsuper waves\nfloat fField0(vec3 p)\n{\n    float fbm_=noise(p*7.);\n\tpMod(p.xz,vec2(1.8-0.4*fbm_));\n\tpR(p.xz,iTime*0.2+0.2*fbm_);\n\tpR(p.xy,iTime*0.4+0.2*fbm_);\n\treturn fBox(p-vec3(0.0),vec3(1.1))-0.15-0.05*fbm_;\n}\n\n// \tpyramid carpet & tunnel effects\nfloat fField1(vec3 p) \n{\n\tku = pMod(p.xz,vec2(.8));\n\tpR(p.xz,iTime*.16);\n\tpMod(p.xz,vec2(.7));\n\tif (efx_!=3) pR(p.xy,iTime*.334);\n\tfloat box=fBox(p-vec3(0),vec3(.6));\n    if (efx_==2) box=.05-box;\n    if (efx_==1) box-=.02*noise(vec3(0.,0.,p.z)*8.0);\n    return box;\n}\n\n//***************************************************************************************************\n// map\n//***************************************************************************************************\n\nfloat map(vec3 p)\n{\n//\tsuper waves\n    if (efx_==0) return fField0(p);\n//\tpyramid carpet\n    if (efx_==1) return fField1(p);\t\n//\twormhole tunnel  \n    if (efx_==2) p=p.xzy;  \n//  fancy tunnel\n    if (efx_==3) {p=p.xzy;p.z-=iTime; p+=(sin(p*1.9+iTime)+sin(p.yzx+iTime*2.2))*.11;}\n\n    p.xy = vec2( (atan(p.x,p.y)+1.5*sin(0.9*sqrt(dot(p.xy,p.xy))-0.5*iTime))*1.0187,1.-length(p.xy));\n\treturn fField1(p);\n    \n}\n\n\n//***************************************************************************************************\n// softshadow\n//***************************************************************************************************\n\nfloat shadowsoft( vec3 ro, vec3 rd, float k )\n{\n\tfloat t=.1;\n\tfloat res=1.;\n    for (int i=0;i<25;++i)\n    {\n        float h=map(ro+rd*t);\n        if (h<0.001) return 0.;\n\t\tres=min(res,k*h/t);\n        t+=h;\n\t\tif (t>0.23) break;\n    }\n    return res;\n}\n\n//***************************************************************************************************\n// normal calculation\n//***************************************************************************************************\n\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.04; pos-=0.01;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n//***************************************************************************************************\n// marching outside sdf\n//***************************************************************************************************\n\nfloat castRay(vec3 ro,vec3 rd) \n{\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<100;i++) //*************************************\n\t{\n        if(abs(h)<precis||t>12.) break;\n\t\th=map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n//***************************************************************************************************\n// marching inside sdf\n//***************************************************************************************************\n\nfloat castRay2(vec3 ro,vec3 rd) \n{\n//\ttunnel effects\n    float precis=.01;\n//\tsuper waves\n    if (efx_==0) precis=.3;\n//\tmirror carpet\n    if (efx_==1) precis=.8;\n    float h=0.;\n    float t=.1;\n    for(int i=0;i<40;i++) \n\t{\n\t\tif(abs(h)>precis) break;\n\t\th=map(ro+rd*t);\n\t\tt-=h;\n\t}\n\treturn t;\n}\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) \n{\n\n// time control (only in shadertoy)\n\n    if (iTime<136.) efx_=2;\n    if (iTime<102.) efx_=0;\n    if (iTime<68. ) efx_=1;\n    if (iTime<34. ) efx_=3;\n    \n    \n    vec2 uv,p;\n\tuv=gl_FragCoord.xy/iResolution.xy; \n    p=uv*2.-1.;\n   \tp.x*=iResolution.x/iResolution.y;\n\t\n//  camera\n    float theta=sin(iTime*.1)*6.28;\n    float x=3.*cos(theta); \n    float z=3.*sin(theta);\n\tvec3 ro=vec3(x*2.2,5.+2.*sin((iTime+37.)*.15), z*1.4);\t\t\n\tif (efx_==2||efx_==3) ro=vec3(0.,8.,.01);\n    if (efx_==0) ro.y+=1.6; //*******************************************\n\tvec3 cw=normalize(vec3(0.,.25,0.)-ro);\n    vec3 cu=normalize(cross(cw,vec3(0.,1.,0.)));\n\tvec3 rd=normalize(p.x*cu+ p.y*(cross(cu,cw))+7.5*cw);\n\n// \trender:\n\tfloat t=castRay(ro,rd);\n\tvec3 pos=ro+rd*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlightning:\n\tvec3 ligvec=vec3(-.5,.2,.5);\n\tif (efx_==2) ligvec=vec3(-.3*cos(iTime),-.2,.5*sin(iTime*1.9)+.2);\n    \n\tvec3 lig=normalize(ligvec);\t\n    float dif=max(dot(lig,nor),0.);\n    float spec=pow(max(dot(reflect(rd,nor),lig),0.),32.);\n\tvec3 col=vec3(.1*dif+1.*spec);\n    if (efx_==1) col+=.5*ku.x;\n    \n//\tnew shadow\n\tfloat sh=shadowsoft(pos,lig,1.2); \n    col*=clamp(sh,.4,1.);\n\n    \n//\trefraction 1st pass\n\tvec3 te,dif2,rd2,pos2,nor2,ro3,rd3,pos3,nor3;\n\trd2=refract(rd,nor,.78);  \n    te.x=castRay2(pos,rd2);\n\tpos2=pos+rd2*te.x;\n    nor2=calcNormal(pos2);\n\tdif2.x=clamp(dot(lig,nor2),0.,1.);\n    \n\trd2=refract(rd,nor,.82);\n    te.z=castRay2(pos,rd2);\n\tpos2=pos+rd2*te.z;\n    nor2=calcNormal(pos2);\n\tdif2.z=clamp(dot(lig,nor2),0.,1.);\n    \n\trd2=refract(rd,nor,.8);\n    te.y=castRay2(pos,rd2);\n\tpos2=pos+rd2*te.y;\n    nor2=calcNormal(pos2);\n\tdif2.y=clamp(dot(lig,nor2),0.,1.);\n    \n    float spec2=pow(clamp(dot(reflect(rd2,nor2),lig),0.,1.),32.);\n    col+=.3*spec2;\n    \n    te=clamp(te,0.,1.);\n    col+=(1.-te*.25)+(1.-t*.15)*dif2;\n    \n//\tdouble shadow on tunnel effects\n    if (efx_==2||efx_==3) col*=clamp(sh,.4,1.);    \n    \n// \trefraction 2nd pass\n\tro3=pos2+rd; \n\trd3=rd2+0.05;\n    float t3=castRay(ro3,rd3);\n\tpos3=ro3+rd3*t3;\n    nor3=calcNormal(pos3);\n\tfloat dif3=clamp(dot(lig,-nor3),0.,1.);\n    col-=.2*(1.-dif3);\n\n//  add more color depth\n\tcol=mix(col,vec3(.5,.4,.4),ku.y*.2*te.z);\n\n//\ttunnel depth and particles    \n    float particlevar=.35*(particles(cw)-particles(vec3(cw.x,cw.y,cw.z+rd.z)));\n    vec3 deep=vec3(1.);\n    if (efx_==2||efx_==3) \n    {\n        deep=clamp(1.-vec3(t*t)*.007,0.,1.);\n    \tparticlevar=0.;\n    }\n\n//  fade in and out   \n\tfloat blend=min(2.*abs(sin((.1*iTime)*3.1415/3.4)),1.); \n    if (noise((gl_FragCoord.xyz)*.02)>blend) col-=(1.-blend);\n    if(iTime>136.0)blend=0.;\n    \n// \tpostprocessing\n\tcol-=.3*noise(.4*rd3*iTime);\t\t\t\t\t\t\t\t\t\n\tcol*=.9+.1*sin(uv.y*800.);\t\n    col-=1.-dot(uv,1.-uv)*2.5;\n    fragColor=vec4((deep*col+particlevar)*blend,0.);\n}\n\n\n\n", "image_inputs": [{"id": "XdX3Dl", "previewfilepath": "https://soundcloud.com/virgill/requiem-for-a-cpc", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/requiem-for-a-cpc", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[659, 659, 695, 695, 884], [886, 886, 918, 918, 955], [1173, 1173, 1202, 1202, 1282], [1508, 1508, 1529, 1529, 1806], [1808, 1808, 1829, 1829, 1870], [2098, 2098, 2131, 2131, 2753], [2989, 3005, 3028, 3028, 3202], [3204, 3240, 3264, 3264, 3508], [3722, 3722, 3741, 3756, 4130], [4352, 4352, 4399, 4399, 4603], [4832, 4832, 4859, 4859, 5012], [5243, 5243, 5276, 5276, 5497], [5727, 5727, 5761, 5779, 6020], [6236, 6236, 6291, 6328, 9061]], "test": "valid"}
{"id": "4sKXzh", "name": "Borderlands Vault Opt", "author": "Draedrus", "description": "https://www.shadertoy.com/view/lsVSzR optimization. A portal inspired from the Borderlands Vault.", "tags": ["raymarching", "optimized", "vault", "borderlands"], "likes": 7, "viewed": 339, "published": "Public", "date": "1462888800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/***********************************************************************\n * author: pierre.plans@gmail.com\n * thanks Amicozer for -No Place For A Hero- song from the Borderlands\n * thanks again to IQ for letting me discover raymarching algorithms\n ***********************************************************************/\n\n#ifdef GLSL\n#define textureProj texture2DProj\n#endif\n\n#define SOFTSHADOWS\n//#define LIGHTMOVING\n\n#define NUM_STEPS 120\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define CAMDIST 4.0\n#define CAMROTSPEED 0.5\n#define PORTALSPEED 0.5\n#define LIGHTSPEED 0.00\n#define FAR 50.0\n#define NEAR 0.002\n\n#define CAMPOS vec3(5.0, 1.0, -5.0)\n#define TARGETPOS vec3(0.0, 1.0, 0.0)\n\n#define COLORSAND vec3(0.9, 0.9, 0.5)\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n#define TYPE_FLOOR 0.0\n#define TYPE_TEMPLE 1.0\n#define TYPE_SAND 2.0\n#define TYPE_PORTAL_BLOCKS 3.0\n#define TYPE_PORTAL_EDGE 4.0\n#define TYPE_OTHER_FLOOR 5.0\n#define TYPE_OTHER_TEMPLE 6.0\n#define TYPE_OTHER_WATER 7.0\n#define TYPE_OTHER_PORTALBLOCKS 8.0\n#define TYPE_OTHER_PORTALEDGE 9.0\n#define TYPE_OTHER_GARDENS 10.0\n#define TYPE_OTHER_GARDENFLOWERS 11.0\n#define TYPE_OTHER_GARDENTREES 12.0\n\n//#define HIGHQUALITY\n\n#define ROTX(P, A) P*mat3(1.0, 0.0, 0.0, 0.0, cos(A), -sin(A), 0.0, sin(A), cos(A))\n#define ROTY(P, A) P*mat3(cos(A), 0.0, -sin(A), 0.0, 1.0, 0.0, sin(A), 0.0, cos(A))\n#define ROTZ(P, A) P*mat3(cos(A), -sin(A), 0.0, sin(A), cos(A), 0.0, 0.0, 0.0, 1.0)\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    vec3(0.0, 0.0, 0.0),\n    -normalize(TARGETPOS-vec3(0.0, 4.5, 4.5)),\n    vec4(1.0, 1.0, 0.3, 1.0),\n    2.0,\n    2.0);\n\nvec3 ray_dir = vec3(0.0);\n\n/*******************\n * TOOLS\n *******************/\n\nvec2 UVTwist(in vec2 uv, float a) {\n    float cA = cos(a+iTime*PORTALSPEED);\n    float sA = sin(a+iTime*PORTALSPEED);\n\treturn uv*mat2(cA, -sA, sA, cA);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polsmaxf( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, 1.0-h ) - k*h*(1.0-h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<-d2.x) ? d1 : d2;\n}\n\nvec2 opBlend( vec2 d1, vec2 d2, float p )\n{\n    return polsmin( d1, d2, p);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    p = RotXV3(p, 3.14/2.0);\n    p = RotYV3(p, 3.14/2.0);\n    float c = cos(3.5*p.y);\n    float s = sin(3.5*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(p.xy*m, p.z);\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat mapTemple(vec3 p) {\n    return polsmaxf(max(max(\n        \t\t\tsdHexPrism(p - vec3(-8.0, 0.0, 0.0), vec2(4.0, 4.0)),\n        \t\t\t-sdSphere(p - vec3(-4.0, 5.0, 4.0), 3.0)),\n               \t\t-sdSphere(p - vec3(-2.0, 4.0, 0.0), 4.0)),\n               \t\t-sdSphere(p - vec3(-4.0, 4.5, -4.0), 5.0), 0.5\n        );\n}\n\nfloat heightMap(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<5;++i) {\n        h += texture(iChannel1, p.xz*f).r*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapWater(vec3 p) {\n    return udBox(p, vec3(0.5, 0.01, 0.5));\n}\n\nfloat mapTerrain(vec3 p, float s) {\n    float hm = heightMap(p, s);\n    return min(\n        \tsdTorus(p-vec3(-1.0, -0.2, 0.0), vec2(0.7, 0.2))-hm*0.3,\n        \tsdPlane(p)+hm\n    \t);\n}\n\nfloat heightMapSand(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<SAND_OCTAVES;++i) {\n        h += snoise(p.xz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    for(int i=0;i<SAND_GRAINS;++i) {\n        h += hash3D(p.xyz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapSand(vec3 p, float s) {\n\treturn sdPlane(p)+heightMapSand(p, s);\n}\n\nfloat mapPortalBloc(vec3 p, vec3 s) {\n    #ifdef HIGHQUALITY\n    return udRoundBox(p, s, 0.02)+voronoi3D(p*10.0)*0.03;\n    #else\n    return udRoundBox(p, s, 0.02);\n    #endif\n}\n\nfloat mapPortalBlocs(vec3 p) {\n    float s = sin(iTime)*0.03;\n    return \n            min(mapPortalBloc(opCheapBend(p-vec3(0.0, 1.7+s, 0.0)), vec3(0.1, 0.4, 0.06))\n                /*min(\n                    mapPortalBloc(opCheapBend(p-vec3(0.0, 1.7, 0.0)), vec3(0.2, 0.1, 0.06)),\n                    min(\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 1.6, -0.15), -0.5), vec3(0.05, 0.2, 0.1)),\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 1.6, 0.15), 0.5), vec3(0.05, 0.2, 0.1))\n                    )\n                )*/,\n               min(\n                min(\n                    mapPortalBloc(RotXV3(p-vec3(0.0, 0.0-s, -0.5), -0.08), vec3(0.05, 0.2, 0.05)),\n                    min(\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 0.55+s, -0.45), -0.15), vec3(0.05, 0.2, 0.05)),\n                    \tmapPortalBloc(RotXV3(p-vec3(0.0, 1.1-s, -0.35), -0.30), vec3(0.05, 0.2, 0.05))\n                    )\n                ),\n                min(\n                    mapPortalBloc(RotXV3(p-vec3(0.0, 0.0+s, 0.5), 0.08), vec3(0.05, 0.2, 0.05)),\n                    min(\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 0.55-s, 0.45), 0.15), vec3(0.05, 0.2, 0.05)),\n                    \tmapPortalBloc(RotXV3(p-vec3(0.0, 1.1+s, 0.35), 0.30), vec3(0.05, 0.2, 0.05))\n                    )\n                )\n        \t   )\n            );\n}\n\nfloat mapPortalEdge(vec3 p) {\n    float s = sin(iTime)*0.03;\n    p.z += sin(p.y*10.0+iTime*PORTALSPEED)*0.01;\n    return min(\n        \tudTriangle(p, vec3(0.0, -0.2, -0.5), vec3(0.0, 1.6+s, 0.0), vec3(0.0, -0.2, 0.5)),\n        \tmin(\n        \t\tudTriangle(p, vec3(0.0, -0.2, -0.5), vec3(0.0, 1.6+s, 0.0), vec3(0.0, 1.2, -0.4)),\n        \t\tudTriangle(p, vec3(0.0, 1.2, 0.4), vec3(0.0, 1.6+s, 0.0), vec3(0.0, -0.2, 0.5))\n             )\n        \t);\n}\n\n/**********************\n * MAP OTHERS ELEMENTS\n **********************/\n\nfloat mapOtherTemple(vec3 p) {\n    return min(min(min(\n        \tsdHexPrism(p - vec3(-8.0, 0.0, 0.0), vec2(4.0, 4.0)),\n        \tsdCapsule(p - vec3(-8.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 4.0, 0.0), 2.0)),\n            sdTriPrism(p - vec3(20.0, 0.0, 0.0), vec2(2.0, 0.1))),\n            udBox(p - vec3(20.0, 0.0, 0.0), vec3(8.0, 0.05, 0.1))\n        );\n}\n\nfloat mapOtherGardens(vec3 p) {\n    return udBox(p, vec3(28.0, 0.005, 1000.0));\n}\n\nfloat mapOtherGardenFlowers(vec3 p) {\n    return min(\n        \tudBox(p - vec3(0.0, 0.0, 0.5), vec3(27.0, 0.07, 0.2)),\n        \tudBox(p - vec3(0.0, 0.0, -0.5), vec3(27.0, 0.07, 0.2))\n        \t);\n}\n\nfloat mapOtherGardenTrees(vec3 p) {\n    return min(min(min(\n        \t\tsdSphere(p-vec3(20.0, 0.5, 0.8), 0.2),\n        \t\tsdSphere(p-vec3(25.0, 0.5, 0.8), 0.2)),\n                sdSphere(p-vec3(20.0, 0.5, -0.8), 0.2)),\n               \tsdSphere(p-vec3(25.0, 0.5, -0.8), 0.2));\n    /*if(abs(p.z)>5.0) return -1.0;\n    float c = 1.5;\n    p = p - vec3(20.0, 1.0, 0.0);\n    p.z = mod(p.z, c)-0.5* c;\n    return sdSphere(p, 0.2);*/\n}\n\nfloat mapOtherHeightMap(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<5;++i) {\n        h += texture(iChannel0, p.xz*f).r*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapOtherWater(vec3 p) {\n    return udBox(p, vec3(0.5, 0.01, 0.5));\n}\n\nfloat mapOtherTerrain(vec3 p, float s) {\n    return min(\n        \tsdTorus(p-vec3(-1.0, -0.2, 0.0), vec2(0.7, 0.2)),\n        \tsdPlane(p)+heightMap(p, s)\n    \t);\n}\n\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 mapActual(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = opU(vec2(mapPortalBlocs(p), TYPE_PORTAL_BLOCKS), vec2(mapTerrain(p, 0.2), TYPE_FLOOR));\n    d = opU(vec2(mapTemple(p - vec3(-30.0, 0.0, 0.0)), TYPE_TEMPLE), d);\n    d = opU(vec2(mapSand(p, 0.4)-0.0, TYPE_SAND), d);\n    if(dot(ray_dir, vec3(-1.0, 0.0, 0.0))>0.0) {\n    \td = opU(vec2(mapPortalEdge(p), TYPE_PORTAL_EDGE), d);\n    }else{\n    }\n    return d;\n}\n\nvec3 mapActualNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapActual(pt).x;    \n    normal.x = mapActual(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapActual(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/*******************\n * MAP PORTAL OTHER SIDE\n *******************/\n\nvec2 mapOther(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapOtherTerrain(p, 0.2), TYPE_OTHER_FLOOR);\n    d = opU(vec2(mapOtherTemple(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_TEMPLE), d);\n    d = opU(vec2(mapOtherGardens(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_GARDENS), d);\n    d = opU(vec2(mapOtherGardenFlowers(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_GARDENFLOWERS), d);\n    d = opU(vec2(mapOtherGardenTrees(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_GARDENTREES), d);\n    d = opU(vec2(mapOtherWater(p-vec3(-1.0, -0.04, 0.0)), TYPE_OTHER_WATER), d);\n    return d;\n}\n\nvec3 mapOtherNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapOther(pt).x;    \n    normal.x = mapOther(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapOther(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapActual(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvec2 raymarchOther(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapOther(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = NEAR;\n    for(int i = 0; i<10;i++) {\n        float h = mapActual(ro + rd*t).x;\n        if( h<0.001 || t>FAR)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat shadowOther( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = NEAR;\n    for(int i = 0; i<10;i++) {\n        float h = mapOther(ro + rd*t).x;\n        if( h<0.001 || t>FAR)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/*float shadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    for( int i=0; i<10; ++i )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        if( h<tmin || t>tmax) break;\n        t+=h;//float(i)/30.0;\n    }\n    return clamp(1.0-(tmax-t)/(tmax-tmin), 0.0, 1.0);\n}*/\n\nfloat portalBlocDisp(vec3 p) {\n    vec2 uv = p.yz;\n\tvec4 horizEdge = vec4( 0.0 );\n    float x = 0.005, y = x;\n\thorizEdge -= texture( iChannel1, vec2( uv.x - x, uv.y - y ) ) * 1.0;\n\thorizEdge -= texture( iChannel1, vec2( uv.x - x, uv.y     ) ) * 2.0;\n\thorizEdge -= texture( iChannel1, vec2( uv.x - x, uv.y + y ) ) * 1.0;\n\thorizEdge += texture( iChannel1, vec2( uv.x + x, uv.y - y ) ) * 1.0;\n\thorizEdge += texture( iChannel1, vec2( uv.x + x, uv.y     ) ) * 2.0;\n\thorizEdge += texture( iChannel1, vec2( uv.x + x, uv.y + y ) ) * 1.0;\n\tvec4 vertEdge = vec4( 0.0 );\n\tvertEdge -= texture( iChannel1, vec2( uv.x - x, uv.y - y ) ) * 1.0;\n\tvertEdge -= texture( iChannel1, vec2( uv.x    , uv.y - y ) ) * 2.0;\n\tvertEdge -= texture( iChannel1, vec2( uv.x + x, uv.y - y ) ) * 1.0;\n\tvertEdge += texture( iChannel1, vec2( uv.x - x, uv.y + y ) ) * 1.0;\n\tvertEdge += texture( iChannel1, vec2( uv.x    , uv.y + y ) ) * 2.0;\n\tvertEdge += texture( iChannel1, vec2( uv.x + x, uv.y + y ) ) * 1.0;\n\tvec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));\n    return (edge.r+edge.g+edge.b)*0.33;\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 rm, vec2 uv) {\n    vec3 p = ro+rd*rm.x;\n    vec3 n;\n    if(rm.y!=TYPE_PORTAL_EDGE)\n    \tn = normalize(mapActualNormal(p, 0.001));\n    vec3 color;\n    #ifdef DEPTHMODE\n    color.r = color.g = color.b = (FAR-rm.x)/(FAR-NEAR);//*max(0.0, dot(n, -l));\n    color.rgb *= max(0.0, dot(-l, n))*1.0/(0.3*length(p - lPos));\n    #else\n    if(rm.x>NEAR && rm.x<FAR) {\n        if(rm.y==TYPE_PORTAL_BLOCKS) {\n            color = textureProj(iChannel0, p.xzy*1.0).rgb*vec3(0.7, 0.8, 1.1);\n            float v = portalBlocDisp(p);//pow(voronoi3D(p*10.0), 2.0)*2.0;\n            float tf = abs(fract(iTime*0.5)-0.5);\n            color = mix(color, vec3(0.0, v+v>0.5?tf:0.0, v+v>0.5?tf:0.0), 0.5);\n        \tcolor = color*max(0.0, dot(_light.d, n))*1.0/(0.3*length(p - _light.o));\n        }else if(rm.y >= TYPE_PORTAL_EDGE){\n            \n            vec3 worldColor;\n            vec2 rmo = raymarchOther(ro, rd, NEAR, FAR);\n            vec3 po = ro+rd*rmo.x;\n    \t\tvec3 no = normalize(mapOtherNormal(po, 0.001));\n\n            if(rmo.y == TYPE_OTHER_FLOOR){\n                worldColor = texture(iChannel0, po.xz).rgb*max(0.0, dot(_light.d, no))*1.0;\n            }else if(rmo.y == TYPE_OTHER_WATER) {\n                worldColor = vec3(0.4, 0.4, 1.0);   \n            }else if(rmo.y == TYPE_OTHER_TEMPLE) {\n                n *= texture(iChannel0, po.zy).r;\n                worldColor = vec3(1.0)*max(0.0, dot(_light.d, no));\n            }else if(rmo.y == TYPE_OTHER_GARDENS) {\n                worldColor = vec3(0.0, 1.0, 0.0)*max(0.0, dot(_light.d, no));\n            }else if(rmo.y == TYPE_OTHER_GARDENFLOWERS) {\n                worldColor = (\n                            mix(vec3(1.0, 1.0, 0.0),\n                                texture(iChannel2, po.xz*0.01).rgb,\n                                0.8)\n                        )*max(0.0, dot(_light.d, no));\n            }else if(rmo.y == TYPE_OTHER_GARDENTREES) {\n                n*=texture(iChannel1, uv*10.0).r;\n                worldColor = vec3(0.0, 1.0, 0.0)*max(0.0, dot(_light.d, no));\n            }\n            #ifdef SOFTSHADOWS\n            worldColor*=shadowOther(ro, rd, 8.0);\n            #endif\n            worldColor = mix(worldColor, mix(vec3(1.0), vec3(0.3, 0.3, 1.0), uv.y), 1.0-(FAR-rmo.x)/(FAR-NEAR));\n                    //= texture(iChannel2, uv).rgb;\n            //worldColor = vec3((FAR-rmo.x)/(FAR-NEAR));\n            // COMPUTING PORTAL EFFECT\n            vec3 portalColor = texture(iChannel0, UVTwist(uv-vec2(0.5, 0.5), 1.0)).rgb;\n    \t\t\n            portalColor += abs(pow(fract((p.y+iTime)*24.145)-0.5, 4.0));\n            p.z *= 1.9;\n            p.y *= 1.0;\n            portalColor.b += pow(length(vec3(0.0, 0.7, 0.0)- p)*1.2, 4.0);\n            // END COMPUTING PORTAL EFFECT\n            color = mix(worldColor, portalColor, 0.5);\n        }else if(rm.y == TYPE_FLOOR){\n            color = texture(iChannel1, p.xz).rgb*max(0.0, dot(_light.d, n))*1.0;\n            #ifdef SOFTSHADOWS\n        \tcolor *= shadow(p, _light.d, 8.0);\n            #endif\n        }else if(rm.y == TYPE_SAND) { // SAND\n         \tcolor = COLORSAND*max(0.0, dot(_light.d, n))*1.0;\n            #ifdef SOFTSHADOWS\n        \tcolor *= shadow(p, _light.d, 8.0);  \n            #endif\n        }else if(rm.y == TYPE_TEMPLE) {\n            vec3 c = texture(iChannel1, p.zy*2.0).rgb;\n            color = c.rgb*max(0.0, dot(_light.d, n*c.r));\n            #ifdef SOFTSHADOWS\n        \tcolor *= shadow(p, _light.d, 2.0);\n            #endif\n        }\n        // SKY COLOR\n        vec3 skyColor = mix(vec3(1.0), COLORSKY, uv.y+0.2);\n        float sunGrad = pow(max(0.0, dot(-_light.d, rd)), 4.0);\n        skyColor = mix(skyColor, vec3(sunGrad, sunGrad, 1.0), sunGrad);\n        // MIXING\n        color = mix(color, skyColor, 1.0-(FAR-rm.x)/(FAR-NEAR));\n    }else{\n        color = mix(vec3(1.0), COLORSKY, uv.y+0.2);\n        float sunGrad = pow(max(0.0, dot(-_light.d, rd)), 4.0);\n        color = mix(color, vec3(sunGrad, sunGrad, 1.0), sunGrad);\n    }\n    return color;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;/*+vec3(\n        cos(t)*CAMDIST,\n        0.0,\n        sin(t)*CAMDIST);*///vec3(cos(t), 4.0, sin(t))*CAMDIST;\n\trd = normalize(rdi*rotY);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    lPos = lPos*rotX*rotY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(pixel, 1.0);\n\tvec3 lPos = vec3(0.0, 5.0, 0.0);\n    \n    ro.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    rd = normalize(rd);\n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \n    ray_dir = rd;\n    \n    vec2 rm = raymarch(ro, rd, NEAR, FAR);\n    #ifdef LIGHTMOVING\n    lightPos(Time*LIGHTSPEED, lPos);\n    _light.o = lPos;\n    _light.d = normalize(ro+rd*rm.x-lPos);\n    #endif\n    \n    vec3 color = rendering(ro, rd, rm, uv);\n    #endif\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "lsfGDS", "previewfilepath": "https://soundcloud.com/amicozer-suemark/borderlands-2-theme-song-no-place-for-a-hero", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/amicozer-suemark/borderlands-2-theme-song-no-place-for-a-hero", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1761, 1761, 1796, 1796, 1917], [1919, 1919, 1952, 1952, 2051], [2052, 2052, 2085, 2085, 2184], [2185, 2185, 2218, 2218, 2317], [2375, 2375, 2395, 2395, 2454], [2456, 2456, 2478, 2478, 2552], [2554, 2554, 2580, 2580, 2988], [2990, 3205, 3227, 3227, 3266], [3267, 3267, 3288, 3288, 4206], [4208, 4231, 4256, 4256, 4271], [4273, 4273, 4308, 4308, 4334], [4336, 4336, 4388, 4388, 4515], [4517, 4517, 4548, 4548, 4586], [4588, 4588, 4619, 4619, 4715], [4717, 4717, 4762, 4762, 4802], [4804, 4804, 4837, 4837, 4902], [4904, 4904, 4940, 4940, 5024], [5026, 5026, 5062, 5062, 5149], [5151, 5151, 5195, 5195, 5487], [5489, 5489, 5514, 5514, 5533], [5534, 5534, 5586, 5586, 6093], [6228, 6264, 6305, 6305, 6443], [6445, 6481, 6522, 6522, 6668], [6670, 6706, 6751, 6751, 6848], [6850, 6850, 6880, 6880, 6913], [6915, 6915, 6945, 6945, 6978], [6980, 6980, 7010, 7010, 7044], [7046, 7046, 7089, 7089, 7123], [7125, 7125, 7153, 7153, 7329], [7398, 7398, 7423, 7423, 7708], [7710, 7710, 7744, 7744, 7930], [7932, 7932, 7956, 7956, 8001], [8003, 8003, 8038, 8038, 8185], [8187, 8187, 8225, 8225, 8520], [8522, 8522, 8554, 8554, 8596], [8598, 8598, 8635, 8635, 8774], [8776, 8776, 8806, 8806, 10146], [10148, 10148, 10177, 10177, 10591], [10666, 10666, 10696, 10696, 11023], [11025, 11025, 11056, 11056, 11106], [11108, 11108, 11145, 11145, 11303], [11305, 11305, 11340, 11340, 11729], [11731, 11731, 11773, 11773, 11959], [11961, 11961, 11990, 11990, 12035], [12037, 12037, 12077, 12077, 12198], [12259, 12259, 12283, 12283, 12678], [12680, 12680, 12720, 12720, 12949], [13020, 13020, 13043, 13043, 13590], [13592, 13592, 13631, 13631, 13857], [13925, 13925, 13988, 13988, 14275], [14277, 14277, 14345, 14345, 14631], [14700, 14700, 14749, 14749, 14990], [14992, 14992, 15046, 15046, 15286], [15579, 15579, 15609, 15609, 16678], [20691, 20756, 20819, 20819, 20969], [20971, 20971, 21045, 21045, 21513], [21515, 21515, 21554, 21554, 21793], [21795, 21795, 21852, 21852, 22788]], "test": "error"}
{"id": "4stSDs", "name": "G-Lectric Sheep 13", "author": "vox", "description": "G-Lectric Sheep 13", "tags": ["glectricsheep13"], "likes": 2, "viewed": 500, "published": "Public API", "date": "1462206797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat seedling;\n\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------GALAXY-----------------\n\nfloat galaxy(vec2 uv)\n{\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    float theta1 = atan(uv.y, uv.x)-r1*PI+iTime*.5;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+iTime*.5;\n    \n\tvec4 finalColor = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*vec4(1.0, 1.0, 1.0, 1.0)\n    \n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*vec4(0.0, 0.0, 2.0, 1.0)\n         + simplex3d(vec3(r2+seedling+time*.25, cos(theta2)*5., 0.0)*4.0)*(1.5-log(r2+1.))\n         + simplex3d(vec3(r2*r2+seedling+time*.25, cos(theta2)*5., 0.0)*4.0)*(1.25-log(r2+1.));\n    finalColor.b += .75;\n    \n    finalColor /= r1+1.0;\n    \n    return clamp(finalColor.b, 0.0, 1.0);\n}\n\n//-----------------RENDERING-----------------\n\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+5.0*vec2(time, time*GR/E))*GR;\n\tvec2 b = sin(seedling+4.666*vec2(time, time*GR/E))*GR;\n\tvec2 c = sin(seedling+4.333*vec2(time, time*GR/E))*GR;\n\tvec2 d = sin(seedling+4.0*vec2(time, time*GR/E))*GR;\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius((uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 reflection(vec2 uv)\n{\n    return (1.0-saw(PI*(uv*.5+.5)));\n}\nvec2 spiral(vec2 uv)\n{\n    float turns = 2.0;\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x)*turns-r*PI*2.0;\n    return vec2(saw(r*PI),\n                saw(theta));\n}\n\nvec2 perspective(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 4;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    #define FUNCTION_PERSPECTIVE 0\n    #define FUNCTION_SPIRAL 1\n    \n    int function = 0;\n    vec2 next, last; \n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        \n        if(function == FUNCTION_PERSPECTIVE)\n        {\n            last = uv;\n            next = perspective(uv, .5/iResolution.xy, magnification);\n\n            //omg so platform dependent... pls help fix:\n            float weight = smoothstep(0.0, 0.25, ifs);\n\n            ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n\n            float delta = galaxy(next*2.0-1.0);\n        \n            if(delta == 0.0)\n            {\n            depth += delta*ifs;\n\t            uv = last*ifs+uv*(1.0-ifs);\n                uv = reflection(uv*2.0-1.0);//*clamp(pow(delta, SPIRAL_BLUR_SCALAR)*2.0, 0.0, 1.0);\n            }\n            else\n            {\n                uv = next*weight+uv*(1.0-weight);\n\t\t\t\tfunction = FUNCTION_SPIRAL;\n            }\n        }\n        else if(function == FUNCTION_SPIRAL)\n        {\n            depth += galaxy(uv*2.0-1.0)*ifs;\n         \tuv = spiral(uv*2.0-1.0)*(1.0-ifs)+last*ifs;;\n                \n            function = FUNCTION_PERSPECTIVE;\n        }\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*15.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    if(ifs < .1+.05*sin(time*600.0/stripes)) discard;//DIVERGANCE + Free motion blur :)\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(saw(depth*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[761, 761, 783, 783, 980], [982, 982, 1007, 1007, 1738], [1788, 1788, 1817, 1817, 1887], [1889, 1889, 1918, 1918, 2002], [2048, 2048, 2071, 2071, 2845], [2895, 2895, 2917, 2917, 3187], [3189, 3189, 3208, 3208, 3255], [3257, 3257, 3283, 3283, 3322], [3323, 3323, 3345, 3345, 3503], [3505, 3505, 3568, 3568, 4141], [4143, 4143, 4200, 4200, 6497]], "test": "valid"}
{"id": "4sVSRR", "name": "Temporal Parameterization", "author": "akohdr", "description": "Decorated primitives with temporal parameterizations to bring everything to life.\n\n(original by Iq https://www.shadertoy.com/view/Xds3zN )", "tags": ["3d", "marching", "primitives", "distance"], "likes": 3, "viewed": 235, "published": "Public", "date": "1462477421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n\n// Parameterizations created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// simple idea that popped into my head generating printed text\n// \"why not temporally parameterize the ray marching distance primitives ?\"\n//\n// map() calls dt parameterized versions with dt as function of iFrame and iTime\n// parameterized version then chains to underlying primitive implementations\n//\n\nfloat sdSphere(float dt, vec3 p, float s);\nfloat sdBox(float dt,  vec3 p, vec3 b);\nfloat udRoundBox(float dt,  vec3 p, vec3 b, float r);\nfloat sdTorus(float dt,  vec3 p, vec2 t);\nfloat sdCapsule(float dt,  vec3 p, vec3 a, vec3 b, float r);\nfloat sdTriPrism(float dt,  vec3 p, vec2 h);\nfloat sdCylinder(float dt,  vec3 p, vec2 h);\nfloat sdCone(float dt,  in vec3 p, in vec3 c);\nfloat sdTorus82(float dt,  vec3 p, vec2 t);\nfloat sdTorus88(float dt,  vec3 p, vec2 t);\nfloat sdCylinder6(float dt,  vec3 p, vec2 h);\nfloat sdHexPrism(float dt,  vec3 p, vec2 h);\nfloat sdConeSection(float dt, in vec3 p, in float h, in float r1, in float r2);\nfloat sdEllipsoid(float dt, in vec3 p, in vec3 r);\n// implementations at the end\n\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    float f = float(iFrame),\n          dt = .5 + .5*sin(f/16.+cos(iTime));\n    \n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    dt, pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       dt, pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  dt, pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     dt, pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   dt, pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  dt, pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  dt, pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      dt, pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   dt, pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   dt, pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( dt, pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  dt, pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  1.7-dt, pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    1.5*dt,pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  1.-dt, pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder( opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    \n\tres = opU( res, vec2( 0.7*sdSphere(    dt,pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\n\tres = opU( res, vec2( 0.5*sdTorus( dt, opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2(sdConeSection( dt, pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n    res = opU( res, vec2(sdEllipsoid( dt, pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n// Example Temporal Paramterizations\n//\n// all animation is synchronized to dt which is function of iFrame and iTime\n// \n\nfloat spt(vec3 p, float dt)\n{\n    return sin(3.*p.x*p.y)*dt;\n}\n\nfloat sdSphere(float dt, vec3 p, float s)\n{\n    return sdSphere(p,dt*s);\n}\n\nfloat sdBox(float dt, vec3 p, vec3 b)\n{\n    return sdBox(p,(1.-1.3*spt(p,dt))*b);\n}\n\nfloat udRoundBox(float dt, vec3 p, vec3 b, float r)\n{\n    return udRoundBox(p,dt*b,r);\n}\n\nfloat sdTorus(float dt, vec3 p, vec2 t)\n{\n    return sdTorus(p,cos(sin(3.*dt))*t);\n}\n\nfloat sdCapsule(float dt, vec3 p, vec3 a, vec3 b, float r)\n{\n    return sdCapsule(p+vec3(1,0,0), .1+max(.1+cos(dt)*a,-.6), max(tan(dt)*b,.1), r-.05*dt);\n}\n\nfloat sdTriPrism(float dt, vec3 p, vec2 h)\n{\n    return sdTriPrism(p,(2.-1.5*cos(dt))*h);\n}\n\nfloat sdCylinder(float dt, vec3 p, vec2 h)\n{\n    return sdCylinder(p, min(dt/h,.25));\n}\n\nfloat sdCone(float dt, in vec3 p, in vec3 c)\n{\n    return sdCone(.1*dt + p,.03*dt + c);\n}\n\nfloat sdTorus82(float dt, vec3 p, vec2 t)\n{\n    return sdTorus82(p, dt*t);\n}\n\nfloat sdTorus88(float dt, vec3 p, vec2 t)\n{\n    return sdTorus88(p,(1.-dt)*t);\n}\n\nfloat sdCylinder6(float dt, vec3 p, vec2 h)\n{\n    return sdCylinder6(p,(1.-dt)*h+.05);\n}\n\nfloat sdHexPrism(float dt, vec3 p, vec2 h)\n{\n    return sdHexPrism(p, min(h/dt,.25));\n}\n    \nfloat sdConeSection(float dt, in vec3 p, in float h, in float r1, in float r2)\n{\n    return sdConeSection(p, min(h/dt,.4), r1,r2);\n}\n\nfloat sdEllipsoid(float dt, in vec3 p, in vec3 r)\n{\n    return sdEllipsoid(p,min((1.-dt)/r,.2));\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVSRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1554, 1554, 1579, 1579, 1594], [1596, 1596, 1631, 1631, 1657], [1659, 1659, 1690, 1690, 1777], [1779, 1779, 1822, 1822, 1882], [1884, 1884, 1929, 1929, 1969], [1971, 1971, 2004, 2004, 2057], [2059, 2059, 2095, 2095, 2337], [2339, 2339, 2391, 2391, 2505], [2507, 2507, 2543, 2543, 2791], [2793, 2793, 2829, 2829, 2928], [2930, 2930, 2968, 2968, 3137], [3139, 3139, 3211, 3211, 3426], [3429, 3429, 3454, 3454, 3491], [3493, 3493, 3518, 3518, 3576], [3578, 3578, 3603, 3603, 3668], [3670, 3670, 3705, 3705, 3772], [3774, 3774, 3809, 3809, 3876], [3878, 3878, 3915, 3915, 3966], [4042, 4042, 4075, 4075, 4101], [4103, 4103, 4133, 4133, 4166], [4168, 4168, 4198, 4198, 4227], [4229, 4229, 4253, 4253, 4385], [4461, 4461, 4486, 4486, 6810], [6812, 6812, 6852, 6852, 7442], [7445, 7445, 7519, 7519, 7780], [7782, 7782, 7814, 7814, 8035], [8037, 8037, 8079, 8079, 8378], [8383, 8383, 8422, 8422, 9993], [9995, 9995, 10047, 10047, 10224], [10226, 10226, 10283, 10283, 10877], [11011, 11011, 11040, 11040, 11073], [11075, 11075, 11118, 11118, 11149], [11151, 11151, 11190, 11190, 11234], [11236, 11236, 11289, 11289, 11324], [11326, 11326, 11367, 11367, 11410], [11412, 11412, 11472, 11472, 11566], [11568, 11568, 11612, 11612, 11659], [11661, 11661, 11705, 11705, 11748], [11750, 11750, 11796, 11796, 11839], [11841, 11841, 11884, 11884, 11917], [11919, 11919, 11962, 11962, 11999], [12001, 12001, 12046, 12046, 12089], [12091, 12091, 12135, 12135, 12178], [12184, 12184, 12264, 12264, 12316], [12318, 12318, 12369, 12369, 12416]], "test": "error"}
{"id": "4sVSzm", "name": "Hyperbolic Lamp", "author": "soma_arc", "description": "Hyperbolic tesselation on sphere.", "tags": ["3d", "tiling"], "likes": 15, "viewed": 202, "published": "Public", "date": "1463654635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 tp1 = vec2(0.26607724, 0);\nvec2 tp2 = vec2(0, 0.14062592);\nvec2 cPos = vec2(2.01219217, 3.62584500);\nfloat r = 4.02438434;\nconst float PI = 3.14159265359;\nconst float EPSILON = 0.001;\n\nvoid calcCircle(float theta, float phi){\n\tfloat tanTheta = tan(PI/2. - theta);\n    float tanPhi = tan(phi);\n    float tanTheta2 = tanTheta * tanTheta;\n    float tanPhi2 = tanPhi * tanPhi;\n    \n    tp1 = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)) - \n               tanTheta * sqrt((1. + tanPhi2)/(-tanPhi2 + tanTheta2))/tanTheta, 0.);\n    tp2 = vec2(0., -tanPhi * sqrt(-(1. + tanTheta2)/(tanPhi2 - tanTheta2))+\n              tanTheta * sqrt(-(1. + tanPhi2)/(tanPhi2 - tanTheta2)));\n    \n    \n    cPos = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)),\n                 sqrt((1. + tanPhi2)*tanTheta2/(-tanPhi2 + tanTheta2))\n               );\n    r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 50;\nfloat loopNum = 0.;\n\nint IIS(vec2 pos){\n    if(length(pos) > 1.) return 0;\n\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) < r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            fund = false;\n        }\n        if(fund)\n        \treturn invCount;\n    }\n\n\treturn invCount;\n}\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.z), p.y / (1. - p.z));\n}\n\nvec2 twistedReflect(vec2 p){\n\treturn -p / (p.x * p.x + p.y * p.y);\n}\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n\tvec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 p = (rayOrigin + t * rayDir);\n            int d = 0;\n            if(p.y > 0.5)\n            \td = IIS(twistedReflect(stereoProject(p.xzy)));\n            else\n                d = IIS(stereoProject(p.xzy));\n\t\t\tif(mod(float(d), 2.) == 0.)\n                return vec4(t, normalize(p - sphereCenter));\n            t = -b + s;\n            if(EPSILON < t && t < isect.x){\n            \tp = (rayOrigin + t * rayDir);\n            \tif(p.y > 0.5)\n            \t\td = IIS(twistedReflect(stereoProject(p.xzy)));\n            \telse\n               \t\td = IIS(stereoProject(p.xzy));\n\t\t\t\tif(mod(float(d), 2.) == 0.)\n                \treturn vec4(t, normalize(p - sphereCenter));\n            }\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nfloat distFunc(vec3 p){\n  return length(p) - 100.;\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                           distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                           distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 spherePos = vec3(0, .5, 0);\nfloat sphereR = 0.5;\n\nbool visible(vec3 org, vec3 target){\n    vec3 v = target - org;\n    vec4 result = vec4(length(v));\n    result = intersectSphere(spherePos, sphereR, org, normalize(v), result);\n    if(result.x < length(v)) return false;\n    result = intersectPlane(vec3(0), vec3(0, 1, 0), org, normalize(v), result);\n    if(result.x < length(v)) return false;\n\treturn true;\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.1);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. && visible(p, lightPos)) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\nconst vec3 lightPos = vec3(3, 5, 0);\nconst vec3 lightPower = vec3(100.);\nconst vec3 lightPos2 = vec3(0, 0.5, 0);\nconst vec3 lightPower2 = vec3(50.);\nconst int MAX_MARCHING_LOOP = 800;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold){\n    vec3 rayPos = origin;\n  \tfloat dist;\n  \tfloat rayLength = 0.;\n  \tfor(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    \tdist = distFunc(rayPos);\n    \trayLength += dist;\n    \trayPos = origin + ray * rayLength ;\n    \tif(dist < threshold) break;\n  \t}\n  \treturn vec2(dist, rayLength);\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n  \tvec4 result = intersectSphere(spherePos, sphereR, eye, ray, vec4(99999.));\n    result = intersectPlane(vec3(0), vec3(0, 1, 0), eye, ray, result);\n    \n    vec3 matColor = vec3(1.);\n  \t\n  \tif(result.x > 0.){\n        vec3 intersection = eye + ray * result.x;\n        vec3 normal = result.yzw;\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower2);\n\n    }\n  \treturn l;\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 eye = vec3(1, 0.5, 1);\nconst vec3 target = vec3(0., 0.5, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    calcCircle(PI/(4. + sin(iTime)), PI/8.);\n    eye = vec3(1.5 * cos(iTime/2.) , 1.5, 1.5 *sin(iTime/2.));\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVSzm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[131, 220, 261, 261, 550], [742, 742, 782, 782, 1465], [1467, 1467, 1527, 1527, 1643], [1693, 1693, 1711, 1711, 2294], [2296, 2296, 2323, 2323, 2375], [2377, 2377, 2405, 2405, 2445], [2447, 2447, 2565, 2565, 3567], [3569, 3569, 3667, 3667, 3853], [3855, 3855, 3878, 3878, 3907], [3940, 3940, 3969, 3969, 4182], [4267, 4267, 4303, 4303, 4624], [4694, 4694, 4833, 4833, 5038], [5224, 5224, 5294, 5294, 5577], [5579, 5579, 5614, 5614, 6134], [6136, 6136, 6157, 6157, 6326], [6328, 6328, 6480, 6480, 6844], [6890, 6890, 6919, 6919, 7099], [7254, 7254, 7310, 7310, 7668]], "test": "valid"}
{"id": "4sVXDz", "name": "Candy core  2", "author": "tdhooper", "description": "Another view on https://www.shadertoy.com/view/4dVSWR", "tags": ["sdf"], "likes": 18, "viewed": 1417, "published": "Public API", "date": "1463850738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: \n// Title: \n\n\n#define PI 3.14159265359\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\nfloat t;\n//vec2 iResolution = u_resolution;\n//vec2 iMouse = u_mouse;\n\n// #define t u_time\n//#define iResolution u_resolution\n//#define iMouse u_mouse\n\n\n// HG_SDF\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n        // Fold in corner A \n        \n        vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n        vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            // Get corners of triangle created by fold\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n            \n            // Fold in corner A\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n            // Fold in corner B\n            \n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n\n    return p;\n}\n\nvec3 pRoll(inout vec3 p) {\n    //return p;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n    return p;\n}\n\nvec3 lerp(vec3 a, vec3 b, float s) {\n\treturn a + (b - a) * s;\n}\n\nfloat face(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    p = reflect(p, rn);\n\treturn min(\n        fPlane(p, vec3(0,0,-1), -1.4),\n        length(p + vec3(0,0,1.4)) - 0.02\n    );\n}\n\nvec3 planeNormal(vec3 p) {\n    // Align face with the xy plane\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    return reflect(p, rn);  \n}\nvec3 pSpin(vec3 p) {\n    pR(p.xz, t/2.);\n    pR(p.yz, t/4. + 10.);\n    pR(p.xy, t);\n    return p;\n}\n\nfloat spinningBox(vec3 p) {\n    p = pSpin(p);\n    return fBox(p, vec3(1., 1., 1.));\n}\n\n// float inner(vec3 p) {\n//     //float t = 1.;\n//     int i = int(mod(t/4., 2.));\n// \tpModIcosahedron(p, i+1);\n//     p = planeNormal(p);\n//     p.z += 1.;\n//     //p.z += sin(t*PI/2. + .2) * 0.5;\n//     //pR(p.xy, t*1.5);\n//     //pR(p.zy, t/2.);\n    \n//     pR(p.zy, PI*t/4.);\n//     pR(p.zy, PI*.5);\n\t\n//     //return fBox(p, vec3(9.,.05,(float(i)/3.)+.1));\n//     return fBox(p, vec3(9., .05, .2));\n// }\n\nfloat inner(vec3 p) {\n    // float t = 0.;\n\tpModIcosahedron(p, 2);\n    p = planeNormal(p);\n    p.z += 2.;\n    pR(p.zy, PI*t/4.);\n    pR(p.zy, PI*.5);\n    return fBox(p, vec3(9., .1, .1));\n}\n\nfloat other(vec3 p) {\n    //pR(p.xz, t*.3);\n    //pR(p.zy, t*.3);\n    pModIcosahedron(p, 1);\n    p = planeNormal(p);\n    p += vec3(0.,0.,2.);\n    pR(p.xz, t*1.5 * 1.);\n    pR(p.zy, t/2. + 2.);\n\treturn fBox(p, vec3(.5,.1,.2));\n}\n\nfloat exampleModelC(vec3 p) {\n    pR(p.xy, 2.832);\n    \n    // pR(p.xz, t/3.);\n\n    // pR(p.yz, t*PI/2.);\n    // pR(p.xy, t*PI/4.);\n\t //pModIcosahedron(p, 2);\n     //pR(p.xy, t/8.);\n     // pR(p.yz, t/16.);\n\t//pModIcosahedron(p, 1);\n    //p = planeNormal(p);\n    float b = inner(p);\n    float a = other(p);\n    return b;\n    return fOpDifferenceRound(a, b, 0.3);\n}\n\nfloat exampleModel(vec3 p) {\n    //pRoll(p);\n\treturn exampleModelC(p);\n}\n\nvec3 doBackground(vec3 rayVec) {\n    return vec3(.13);\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n    return (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){  \n    \n    vec2 res = vec2(exampleModel(p) ,1.); \n    // vec2 res2 = vec2(core(p) ,2.); \n    return res;\n    // return opU(res, res2);\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float x = .366 + (mouse.x * 0.5);\n    float y = .4 + (mouse.y * 0.33);\n    \n    float an = 10.0 * x + PI / 2.;\n    //an = 10.;\n    float roll = .6;\n    //roll = 0.;\n    \n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(y * PI / 2.) - roll,\n        cos(an) - roll\n    ) * d;\n    \n    camPos = vec3(1.,0.,0.)*5.5;\n\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = doBackground(rd);\n  \n    if (res.y == 2.) {\n        return vec3(0.987,0.257,1.000);\n    }\n    \n  if( res.y > -.5 ){\n      \n\tfloat mult = (sin(PI*t/2. + 4.408) + .5) / 2.;\n\t// mult = pow(mult, 2.);\n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\tcolor = norm * 0.5 + 0.5;\n    float split = .7 - (dot(pos, norm) / PI);\n\t// split = 1. - split;\n    // split = clamp(split + mult, 0., 1.);\n\tsplit = pow(split, 4.);\n    float light = dot(ref, normalize(vec3(0,1,1)));\n    light *= 1. - split;\n    // float mult = (sin(PI*t/2. + -2.966) + 1.) / 2.;\n\tcolor *= split;\n    color += light * 0.3;\n\t// color = vec3(split);\n    \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, t, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n    \n    vec3 color = render( res , ro , rd );\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 307, 307, 342], [344, 344, 400, 400, 445], [447, 483, 511, 511, 592], [594, 832, 864, 864, 909], [911, 939, 1001, 1001, 1125], [1128, 1207, 1255, 1255, 1386], [1388, 1388, 1443, 1443, 1578], [1580, 1580, 1634, 1634, 1676], [1763, 1763, 1787, 1820, 2255], [2257, 2286, 2339, 2339, 2408], [2410, 2410, 2464, 2464, 3637], [3639, 3639, 3665, 3681, 3850], [3852, 3852, 3888, 3888, 3915], [3917, 3917, 3937, 3973, 4150], [4152, 4152, 4178, 4214, 4296], [4297, 4297, 4317, 4317, 4396], [4398, 4398, 4425, 4425, 4483], [4895, 4895, 4916, 4937, 5084], [5086, 5086, 5107, 5151, 5313], [5315, 5315, 5344, 5344, 5679], [5681, 5681, 5709, 5725, 5753], [5755, 5755, 5787, 5787, 5811], [6074, 6168, 6197, 6197, 6243], [6246, 6330, 6349, 6349, 6486], [6490, 6490, 6538, 6538, 7011], [7014, 7045, 7109, 7109, 7287], [7289, 7289, 7368, 7368, 7784], [7787, 7900, 7931, 7931, 8175], [8180, 8180, 8224, 8224, 8939], [8943, 8943, 9000, 9000, 9623]], "test": "error"}
{"id": "4sVXR1", "name": "Voronoi multiplayer split screen", "author": "gorsman", "description": "This is a simple demonstration of how Voronoi partitioning can be used in gaming for single-screen multiplayer experience.\n", "tags": ["2d", "voronoi", "splitscreen"], "likes": 8, "viewed": 923, "published": "Public", "date": "1462961772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Screen coords:\n//   vec2 in \"screen units\" relative to the center of viewport\n//   y axis pointing up, x axis pointing to the right\n//   screen units are chosen so that a square [-1, 1] x [-1, 1] fits into the screen\n// World coords: vec2 in units.\n// Cameras: vec3, .xy is world coords of the center of the camera, .z is \"zoom\" (in screen units per world unit)\n\n\n#define PI 3.1415926535897932384626433832795\n\n#define CAMERA_ZOOM_MIN 0.6\n#define CAMERA_ZOOM_MAX 1.0\n\n#define N_PLAYERS 4\nvec3 playersColor[N_PLAYERS];\nvec3 playersBgColor[N_PLAYERS];\n\n\n// Inputs of the shader.\nvec2 playersPos[N_PLAYERS];  // player positions in world coordinates\nvec3 globalCam;             // global camera (zoomed out camera that sees all players)\nvec3 playersCam[N_PLAYERS];  // positions of cameras for each player\n\n\n// *****************************************************\n//  Utility functions\n// *****************************************************\n\nfloat atan2(float y, float x) {\n\t// For some reason GLSL's atan doesn't work as atan2\n    // and only returns angles [0, PI).\n    if (y > 0.0) {\n        return atan(y, x);\n    } else {\n        return PI + atan(-y, -x);\n    }\n}\n\nvec2 camScreen2World(vec3 cam, vec2 screenCoord) {\n    return cam.xy + screenCoord / cam.z;\n}\n\nfloat camScreen2World(vec3 cam, float screenLength) {\n    return screenLength / cam.z;\n}\n\nvec2 camWorld2Screen(vec3 cam, vec2 worldCoord) {\n    return (worldCoord - cam.xy) * cam.z;\n}\n\nfloat camWorld2Screen(vec3 cam, float worldLength) {\n    return worldLength * cam.z;\n}\n\nfloat screen2px(float x) {\n    return x * 0.5 * min(iResolution.x, iResolution.y);\n}\n\nfloat camWorld2Px(vec3 cam, float worldLength) {\n    return screen2px(camWorld2Screen(cam, worldLength));\n}\n\n// Weighted aggregation of the color information for overlapping objects on the same layer.\n// The resulting color is a weighted average of all aggreageted colors.\nvoid aggregateColorSiblings(inout vec4 aggColor, inout float aggWeight, vec4 addedColor) {\n    if (addedColor.w > 0.0001) {\n        float opacity = max(aggColor.w, addedColor.w);        \n        aggWeight += addedColor.w;\n        aggColor = vec4(mix(aggColor.xyz, addedColor.xyz, addedColor.w / aggWeight), opacity);\n    }    \n}\n\n// *****************************************************\n//  Scene rendering (demo vesion)\n// *****************************************************\n\nvec3 renderBackgroundRadialChecker(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    float radius = length(worldCoord.xy);\n    float angularD = atan2(worldCoord.y, worldCoord.x) * radius;\n    \n    const float rowWidthGrowthPow = 2.5;    \n    const float rowRadiusScale = 100.0;\n    // index of a radial checker row.\n    float row = ceil(pow(radius * rowRadiusScale, 1.0 / rowWidthGrowthPow));\n    \n    float rowOuterRadius = pow(row, rowWidthGrowthPow) / rowRadiusScale;    \n    float radialBorderD = abs(radius - rowOuterRadius);\n    float columns = 10.0;\n    const float minRow = 2.0;\n    if (row < minRow + 0.1) {\n        row = minRow;\n        columns = 4.0;\n    } else {\n  \t\tfloat rowInnerRadius = pow(row - 1.0, rowWidthGrowthPow) / rowRadiusScale;\n        radialBorderD = min(radialBorderD, abs(radius - rowInnerRadius));\n        \n        columns = 10.0;        \n    }\n    \n    // index of a concentric checker column.\n    float columnWidth = (radius * 2.0 * PI) / columns;\n    float col = ceil(angularD / columnWidth);\n    \n    float concentricBorderD = abs(mod(angularD / columnWidth + 0.5, 1.0) - 0.5) * columnWidth;\n    \n    \n    const vec3 white = vec3(1.0);\n    const vec3 black = vec3(0.0);\n    vec3 midColor = 0.5 * (black + white);\n    \n    vec3 color;\n    if (mod(row + col, 2.0) > 0.5) {\n        color = white;\n    } else {\n        color = black;\n    }\n    \n    float borderDPx = camWorld2Px(cam, min(radialBorderD, concentricBorderD));\n    float aaColorWeight = smoothstep(0.0, 0.6, borderDPx);\n    \n    return mix(midColor, color, aaColorWeight);\n}\n\nvec4 renderPlayers(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    // Player is a 10px at furthest possible zoom and gets bigger when gets closer.\n    float radiusPx = 10.0 * max(cam.z, CAMERA_ZOOM_MIN) / CAMERA_ZOOM_MIN;\n    const float radiusAaPx = 1.0;\n    \n    vec4 color = vec4(0.0);\n    float weight = 0.0;\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat distPx = camWorld2Px(cam, length(worldCoord - playersPos[i]));\n        \n        float playerWeight = 1.0 - smoothstep(radiusPx, radiusPx + radiusAaPx, distPx);\n        vec4 playerColor = vec4(playersColor[i], playerWeight);\n        aggregateColorSiblings(color, weight, playerColor);\n  \t}    \n    return color;\n}\n\nvec3 renderScene(vec3 cam, vec2 screenCoord) {\n    vec3 color = renderBackgroundRadialChecker(cam, screenCoord);\n    vec4 playersColor = renderPlayers(cam, screenCoord);\n    color = mix(color, playersColor.xyz, playersColor.w);\n    \n    return color;\n}\n\n// *****************************************************\n//  Screen partitioning\n// *****************************************************\n\n// Returns a number that is guaranteed to be higher than any\n// of the distances within Global Camera.\nfloat maxGlobalDist() {\n    return camScreen2World(globalCam, 100.0);\n}\n\nint closestPlayer(vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(globalCam, screenCoord);\n\n    int minPlayer = 0;\n    float minDist = maxGlobalDist();\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat dist = length(worldCoord - playersPos[i]);\n        \n        if (dist < minDist) {\n            minDist = dist;\n            minPlayer = i;\n        }\n  \t}\n    \n    return minPlayer;\n}\n\n\n// *****************************************************\n//  Faking inputs\n// *****************************************************\n\nvec2 initPlayerPos(vec2 basePos, float radius, float basePhase, float timeC) {\n    vec2 center = basePos - radius * vec2(cos(basePhase), sin(basePhase));\n    float phase = basePhase + iTime * timeC;\n    return center + radius * vec2(cos(phase), sin(phase));\n}\n\nvoid fakePlayers() {\n    // Colors taken from http://www.materialui.co/colors (500).\n    playersColor[0] = vec3(0.957, 0.263, 0.212);  // red\n    playersColor[1] = vec3(0.129, 0.588, 0.953);  // blue\n    playersColor[2] = vec3(0.298, 0.686, 0.314);  // green\n    playersColor[3] = vec3(0.612, 0.153, 0.69);   // purple\n    \n    const float timeScale = 0.2;\n    playersPos[0] = initPlayerPos(vec2(0.2, 0.1), 2.0, PI, 1.0 * timeScale);\n    playersPos[1] = initPlayerPos(vec2(-0.2, 0.1), 1.0, 3.0 * PI * 0.5, 3.0 * timeScale);\n    playersPos[2] = initPlayerPos(vec2(-0.2, -0.1), 3.0, 0.0, 0.5 * timeScale);\n    playersPos[3] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 4.0, 1.0 * timeScale);\n}\n\n\nvoid fakeGlobalCamera() {\n    vec2 minPlayerCoord = playersPos[0];\n    vec2 maxPlayerCoord = playersPos[0];\n    for(int i = 1; i < N_PLAYERS; i++) {\n        minPlayerCoord = min(minPlayerCoord, playersPos[i]);\n        maxPlayerCoord = max(maxPlayerCoord, playersPos[i]);\n  \t}\n    const float cameraMarginScreen = 0.4;\n    // (maxPlayerCoord.x - minPlayerCoord.x) * zoom + 2.0 * cameraMarginScreen = iResolution.x / screen2px(1.0);\n    vec2 zoom = (iResolution.xy / screen2px(1.0) - 2.0 * cameraMarginScreen) / (maxPlayerCoord - minPlayerCoord);\n\tglobalCam = vec3((minPlayerCoord + maxPlayerCoord) * 0.5, min(min(zoom.x, zoom.y), CAMERA_ZOOM_MAX));\n}\n\nvoid fakePlayerCameras() {\n    if (globalCam.z > CAMERA_ZOOM_MIN) {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            playersCam[i] = globalCam;\n        }\n    } else {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            vec2 playerPosScreen = camWorld2Screen(globalCam, playersPos[i]);\n            playersCam[i] = vec3(playersPos[i] - playerPosScreen / CAMERA_ZOOM_MIN, CAMERA_ZOOM_MIN);\n        }\n    }\n}\n\nvoid adjustPlayerCameras(float uniformCamZoom) {\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        playersBgColor[i] = playersColor[i];\n    }\n    float mergeDistMin = 0.6 * CAMERA_ZOOM_MIN;\n    float mergeDistMax = 0.8 * CAMERA_ZOOM_MIN;\n    for (int k = 0; k < 2; k++) {\n        // Moving cameras closer to each other.\n        for(int i = 0; i < N_PLAYERS; i++) {\n            for(int j = 0; j < N_PLAYERS; j++) {\n                if (i < j) {\n                    vec2 camPosI = playersCam[i].xy;\n                    vec2 camPosJ = playersCam[j].xy;\n                    float camDistScreen = length(camPosI - camPosJ) * uniformCamZoom;\n                    float mergeWeight = 0.5 * (1.0 - pow(smoothstep(mergeDistMin, mergeDistMax, camDistScreen), 4.0));\n                    playersCam[i].xy = mix(camPosI, camPosJ, mergeWeight);\n                    playersCam[j].xy = mix(camPosJ, camPosI, mergeWeight);\n\n                    vec3 bgColorI = playersBgColor[i];\n                    vec3 bgColorJ = playersBgColor[j];\n                    playersBgColor[i] = mix(bgColorI, bgColorJ, mergeWeight);\n                    playersBgColor[j] = mix(bgColorJ, bgColorI, mergeWeight);\n                }            \n            }\n        }\n        mergeDistMin *= 0.5;\n        mergeDistMax *= 0.5;\n    }\n}\n\n// *****************************************************\n//  Demos\n// *****************************************************\n\nvec4 mainSimpleDemo(vec2 screenCoord) {\n    fakePlayers();    \n    \n    float zoom = (CAMERA_ZOOM_MAX + CAMERA_ZOOM_MIN) * 0.5; // x axis spans [-10, 10]\n    zoom = zoom - (CAMERA_ZOOM_MAX - CAMERA_ZOOM_MIN) * 0.5 * cos(iTime * 0.3);  // animate zoom\n    const float camRadius = 0.2;\n\tvec3 camera = vec3(camRadius * cos(iTime), camRadius * sin(iTime), zoom);\n    \n    return vec4(renderScene(camera, screenCoord), 1.0);\n}\n\nvec4 mainGlobalCameraDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    \n    vec3 color = renderScene(globalCam, screenCoord);\n    int player = closestPlayer(screenCoord);\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = mix(color, playersColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvec4 mainSplitScreenDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    fakePlayerCameras();\n\n    // We assume that all player cams have the same zoom.\n    float uniformCamZoom = playersCam[0].z;\n    adjustPlayerCameras(uniformCamZoom);\n    \n    int player = closestPlayer(screenCoord);\n    vec3 color;\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = renderScene(playersCam[i], screenCoord);\n        \tcolor = mix(color, playersBgColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCoord = (fragCoord.xy - 0.5 * iResolution.xy) / screen2px(1.0);\n    // vec4 color = mainSimpleDemo(screenCoord);\n    // vec4 color = mainGlobalCameraDemo(screenCoord);\n    vec4 color = mainSplitScreenDemo(screenCoord);\n\tfragColor = vec4(color.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[944, 944, 975, 1069, 1170], [1172, 1172, 1222, 1222, 1265], [1267, 1267, 1320, 1320, 1355], [1357, 1357, 1406, 1406, 1450], [1452, 1452, 1504, 1504, 1538], [1540, 1540, 1566, 1566, 1624], [1626, 1626, 1674, 1674, 1733], [1735, 1899, 1989, 1989, 2227], [2378, 2378, 2442, 2442, 3991], [3993, 3993, 4041, 4041, 4718], [4720, 4720, 4766, 4766, 4972], [5113, 5216, 5239, 5239, 5287], [5289, 5289, 5326, 5326, 5683], [5819, 5819, 5897, 5897, 6078], [6080, 6080, 6100, 6164, 6775], [6778, 6778, 6803, 6803, 7427], [7429, 7429, 7455, 7455, 7846], [7848, 7848, 7896, 7896, 9142], [9269, 9269, 9308, 9308, 9690], [9692, 9692, 9737, 9737, 10059], [10061, 10061, 10105, 10105, 10618], [10620, 10620, 10675, 10675, 10946]], "test": "valid"}
{"id": "4sVXRD", "name": "blood sugar tunnel", "author": "tomaes", "description": "Pseudo-glass mosaic/stencil, radial blured tunnel-y things.", "tags": ["layeredstuff"], "likes": 3, "viewed": 171, "published": "Public", "date": "1463330391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r(vec2 _uv, float _t)\n{\n    return mod((cos(_t+_uv.x*6./_uv.y*1.5))/length(_uv), mod(_t*_uv.y*.01+.4*(sin(_uv.x*8.))*(cos(_uv.y*8.)),.5)*abs(tan(_t+length(_uv))*_uv.y*6. ) );    \n}\n\nfloat rb(vec2 _uv, float _t)\n{\n    float v = .0;\n    \n    for(float f = 1.; f > .0; f -= .05)\n        v += r(_uv*f,_t)*.05;\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;     \n    float t = iTime + 44.75;\n    \n    float c = r(uv,t) - r(uv*2.,t+5.);\n\n    if (c > mod(-t*.1 + abs(sin(t*.1+uv.y*.5/uv.x*.2)),.2)*2. )\n    \tc -= .5*rb(uv,t);     \n    \n\tfragColor = vec4(c+length(uv)*.35,c*.9,c+uv.y*.1, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 186], [188, 188, 218, 218, 332], [334, 334, 391, 391, 693]], "test": "valid"}
{"id": "4sySRW", "name": "Moir Lines", "author": "innovati", "description": "Moir pattern in white and blue lines", "tags": ["moire", "pattern"], "likes": 3, "viewed": 98, "published": "Public", "date": "1463009220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = max(vec4(0.2, (gl_FragCoord.x / iResolution.x), (gl_FragCoord.y / iResolution.y), 1.9), acos(fract(reflect(exp(cos(vec4(0.5, 0.6, 0.3, sin((0.0 + (gl_FragCoord.y / iResolution.y)))))), vec4((0.3 / float(iFrame)), (0.1 * (0.6 / ((gl_FragCoord.x / iResolution.x) + 0.4))), (0.4 * (atan(1.6, 1.9) * (gl_FragCoord.y / iResolution.y))), float(iFrame))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sySRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 422]], "test": "valid"}
{"id": "4sySWD", "name": "Grain bg", "author": "gigatron", "description": "from Razor 1911 Amiga Voyage demo\nthx to erwin94 --&amp;gt; green key color replaced by grain !", "tags": ["tv", "grain", "bg"], "likes": 4, "viewed": 272, "published": "Public", "date": "1464288955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Uploaded by erwin94 \n\nfloat saturation(vec4 col, float rw, float bw)\n{\n    return col.g - (col.r*rw+col.b*bw);\n}\n\nvec4 key_green(vec4 color, vec4 reference_color, float red_weight, float blue_weight)\n{\n    float col_sat = saturation(color, red_weight, blue_weight);\n    float ref_sat = saturation(reference_color, red_weight, blue_weight);\n    float key = (1.0-clamp(col_sat / ref_sat, 0.0, 1.0))*color.a;\n    // subtract green\n    vec4 result = clamp(color-reference_color*(1.0-key), 0.0, 1.0);\n    result.a = key;\n    // despill\n    result.g = min(result.g, 0.5*result.r+0.5*result.b);\n    return result;\n}\n\nvec4 over(vec4 bg, vec4 fg)\n{\n    return fg + bg * (1.0-fg.a);\n}\n\nfloat clamp_uv(vec2 uv)\n{\n    return float((uv.x > 0.0 && uv.x < 1.0) && (uv.y > 0.0 && uv.y < 1.0));\n}\n\nvec4 hue_shift(vec4 col)\n{\n    float t = 0.5+0.5*sin(5.0*iTime);\n    float r = col.r;\n    col.r = t*col.b;\n    col.b = (1.-t)*r;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 =uv;\n    uv.y =1.-uv.y; \n \n    vec4 in1 = texture(iChannel0, uv);\n    in1 = key_green(in1, vec4(0.25,.55,.15,1), 0.6, 0.6);\n\n    float strength = 500.0; \n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 2.0);\n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n  \n    if( uv2.x < 1.0 && in1.r<0.01   ){\n   \n      fragColor = vec4(over(over(in1, in1), in1))+grain;\n    }\n\telse\n   fragColor = vec4(over(in1,in1));// mac\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sySWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 72, 72, 114], [116, 116, 203, 203, 610], [612, 612, 641, 641, 676], [678, 678, 703, 703, 781], [783, 783, 809, 809, 929], [931, 931, 988, 988, 1511]], "test": "error"}
{"id": "4syXRD", "name": "Fuzzy scratches", "author": "Daedelus", "description": "Fuzzy scratches mask", "tags": ["fuzzyscratchesmask"], "likes": 22, "viewed": 1103, "published": "Public API", "date": "1463075898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// uniform float uWavyness;\n// uniform vec2 uScale;\n// uniform vec2 uOffset;\n// uniform int uLayers;\n// uniform vec2 uBaseFrequency;\n// uniform vec2 uFrequencyStep;\n#define uWavyness 0.1\n#define uScale vec2(3.0, 3.0)\n#define uOffset vec2(iTime, 0.0)\n#define uLayers 4\n#define uBaseFrequency vec2(0.5, 0.5)\n#define uFrequencyStep vec2(0.25, 0.25)\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\n\nfloat scratch(vec2 uv, vec2 seed)\n{\n    seed.x = floor(sin(seed.x * 51024.0) * 3104.0);\n    seed.y = floor(sin(seed.y * 1324.0) * 554.0);\n \n    uv = uv * 2.0 - 1.0;\n    pR(uv, seed.x + seed.y);\n    uv += sin(seed.x - seed.y);\n    uv = clamp(uv * 0.5 + 0.5, 0.0, 1.0);\n    \n    float s1 = sin(seed.x + uv.y * 3.1415) * uWavyness;\n    float s2 = sin(seed.y + uv.y * 3.1415) * uWavyness;\n    \n    float x = sign(0.01 - abs(uv.x - 0.5 + s2 + s1));\n    return clamp(((1.0 - pow(uv.y, 2.0)) * uv.y) * 2.5 * x, 0.0, 1.0);\n}\n\nfloat layer(vec2 uv, vec2 frequency, vec2 offset, float angle)\n{\n    pR(uv, angle);\n    uv = uv * frequency + offset;\n    return scratch(fract(uv), floor(uv));\n}\n\nfloat scratches(vec2 uv)\n{\n    uv *= uScale;\n    uv += uOffset;\n    vec2 frequency = uBaseFrequency;\n    float scratches = 0.0;\n    for(int i = 0; i < uLayers; ++i)\n    {\n        float fi = float(i);\n    \tscratches = max(scratches, layer(uv, frequency, vec2(fi, fi), fi * 3145.0)); // Nicer blending, thanks Shane!\n        frequency += uFrequencyStep;\n    }\n    return clamp(scratches, 0.0, 1.0); // Saturate for AA to work better\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // using AA by Shane:\n    // https://www.shadertoy.com/view/4d3SWf\n    const float AA = 4.; // Antialias level. Set to 1 for a standard, aliased scene.\n    const int AA2 = int(AA*AA);\n    float col = 0.0;\n    vec2 pix = 2.0/iResolution.yy/AA; // or iResolution.xy\n    for (int i=0; i<AA2; i++){ \n\n        float k = float(i);\n        vec2 uvOffs = uv + vec2(floor(k/AA), mod(k, AA)) * pix;\n        col += scratches(uvOffs);\n    }\n    col /= (AA*AA);\n\t\n\tfragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 379, 379, 459], [461, 461, 496, 496, 977], [979, 979, 1043, 1043, 1140], [1142, 1142, 1168, 1168, 1574], [1576, 1576, 1631, 1631, 2183]], "test": "valid"}
{"id": "4syXRR", "name": "Galaxies 2", "author": "vox", "description": "Galaxies 2", "tags": ["galaxies2"], "likes": 1, "viewed": 459, "published": "Public API", "date": "1462310495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR 2.0\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 1.0E-20\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E))*.1+.75;\n\tvec2 b = sin(seedling+vec2(time, time*GR/E))*.1+.3;\n\tvec2 c = sin(seedling+vec2(time, time*GR/E))*.1-.5;\n\tvec2 d = sin(seedling+vec2(time, time*GR/E))*.1-.5;\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(zoom*(uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 spiral(vec2 uv)\n{\n    return (1.0-saw(PI*(uv*.5+.5)));\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i = 32;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    float shift = time*PI*10.0;\n\n    float stripes;\n    float black = 1.0;\n        \n    \n    vec3 final = vec3(0.0);\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        \n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(0.0, 0.75, ifs);\n        \n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        float delta = sphereN(uv*2.0-1.0).z*ifs;\n        depth += (1.0-delta)*ifs;\n        \n    \tstripes = depth*PI*iResolution.x;\n    \tblack *= smoothstep(0.0, .75, saw(stripes));\n        final += (\n        \t\t\t\tvec3(saw(depth*PI*2.0),\n                \t  \t\tsaw(4.0*PI/3.0+depth*PI*2.0),\n                \t  \t\tsaw(2.0*PI/3.0+depth*PI*2.0)\n                 \t\t)\n        \t\t );\n        \n    }\n    \n    \n    //fragColor = vec4(ifs);\n    \n    //depth /float(max_i);\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    if(pow(ifs, 1.0/float(max_i))*depth*black > EPS)\n    {\n        ifs = 1.0;\n        depth = 0.0;\n        uv = fragCoord.xy/iResolution.xy;\n        black = 1.0;\n        final = vec3(0.0);\n        discard;\n    }\n    black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n    fragColor = vec4(final*black/float(max_i)+white, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[726, 726, 755, 755, 825], [827, 827, 856, 856, 940], [1018, 1018, 1040, 1040, 1303], [1305, 1305, 1324, 1324, 1376], [1378, 1378, 1400, 1400, 1439], [1441, 1441, 1500, 1500, 2073], [2075, 2075, 2132, 2132, 3812]], "test": "valid"}
{"id": "4syXRw", "name": "Forever Fan Wall", "author": "innovati", "description": "This wall goes on forever", "tags": ["wall", "fan", "forever"], "likes": 1, "viewed": 114, "published": "Public", "date": "1463377290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  fragColor = vec4(\n    1.2,\n    0.7,\n    mod(\n      iTime,\n      (gl_FragCoord.x / iResolution.x)\n    ),\n    iTime\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 179]], "test": "valid"}
{"id": "4syXWD", "name": "Constant Width Edge Demo", "author": "Xerophyte", "description": "A pretty crappy demo of how you can do some sort of constant width borders between texture regions procedurally in a shader.", "tags": ["bad", "terrible", "horrible", "useless", "nogood"], "likes": 3, "viewed": 296, "published": "Public", "date": "1464298110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Parameters and crap\n\n// Scale of the texture\nconst float texture_scale = 5.0;\n\n// Number of distinct bands that we divide the texture range into.\nconst float bands = 10.0;\n\n// Width of edges between bands, in pixels.\nconst float edge_width = 2.0;\n\n// Octaves of summed noise to use for the texture.\nconst int octaves = 5;\n\n// Colors\nconst vec3 color_0 = vec3(0.8, 0.3, 0.1);\nconst vec3 color_1 = vec3(0.1, 0.3, 0.6);\n\n// Morgan McGuire's shader hash and noise implementation\nfloat hash(in float n) { return fract(sin(n) * 1e4); }\nfloat hash(in vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(in float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(in vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Summed octave noise\nfloat summed_noise(in vec2 uv) {\n    float sum_noise = 0.0;\n    float weight = 1.0;\n    float frequency = 1.0;\n    \n    vec4 time = vec4(\n        cos(0.0021 * iTime + 2.3461),\n        sin(0.0411 * iTime + 0.1241),\n        cos(0.7865 * iTime + 1.2350),\n    \tsin(1.2421 * iTime + 0.7853)\n    );\n    \n    for (int octave = 0 ; octave < octaves ; ++octave ) {\n        float o = float(octave);\n        o = 1431.0 * o * o + 74.121 * o + 12.24;\n        \n        vec4 translation_weights_u = 0.048 * vec4(\n        \t-50.94 * mod(o, 1.6623),\n        \t7.752  * mod(o, 3.1367),\n        \t-3.775 * mod(o, 5.2141),\n        \t0.913  * mod(o, 7.9832)\n\t\t);\n        vec4 translation_weights_v = 0.030 * vec4(\n        \t22.43  * mod(o, 0.7472),\n        \t-9.220 * mod(o, 2.9782),\n        \t-4.870 * mod(o, 7.2122),\n        \t0.840  * mod(o, 5.5672)\n\t\t);\n        vec2 shift = vec2(dot(translation_weights_u, time),\n                          dot(translation_weights_v, time));\n        \n        sum_noise += weight * (noise(frequency * (uv - 0.5 + shift)));\n        weight = 0.5 * weight;\n        \n        vec4 frequency_weights = 0.05 * vec4(\n        \t14.20 * mod(o, 2.085),\n        \t4.210 * mod(o, 6.325),\n        \t1.290 * mod(o, 5.211),\n        \t0.821 * mod(o, 2.760)\n\t\t);\n        \n        frequency = 2.0 * frequency + dot(frequency_weights, time);\n    }\n    return 0.5 * (sum_noise + 1.0 - weight) / (1.0 - weight);\n}\n\nvec2 texture_mapping(in vec2 pixel) {\n    return texture_scale * (pixel - 0.5 * iResolution.xy) / iResolution.xy;\n}\n\n// Summed octave noise segmented into N bands.\nfloat segment(in vec2 pixel, in float bands) {\n    return floor(summed_noise(texture_mapping(pixel)) * bands); \n}\n\n// Cruddy edge detection of the above noise segments.\nfloat edge_weight(in vec2 pixel, in float edge_width, in float bands, out float pixel_segment) {\n    \n    // 4 samples around the point in a cross pattern. You could take more, do this stochastically, etc.\n    edge_width = 0.5 * edge_width;\n    float segment_px = segment(pixel + vec2(edge_width, 0.0), bands);\n    float segment_py = segment(pixel + vec2(0.0, edge_width), bands);\n    float segment_nx = segment(pixel - vec2(edge_width, 0.0), bands);\n    float segment_ny = segment(pixel - vec2(0.0, edge_width), bands);\n        \n    // Return weight 0 if all surrounding segment samples are equal to the segment at the pixel, 1 otherwise.\n    // Note that this is crap: we really want to lerp at the edge a little bit to avoid aliasing. This\n    // requires better proper processing, or an analytic SDF.\n    pixel_segment = segment(pixel, bands);\n    vec4 segments = vec4(pixel_segment);\n    if (segments == vec4(segment_px, segment_py, segment_nx, segment_ny)) {\n        return 0.0;\n    }\n    else {\n        return 1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float segment;\n    float edge = edge_weight(fragCoord.xy, edge_width, bands, segment);\n    \n    // Alternate segment colors\n    vec3 col;\n    if (mod(segment, 2.0) == 0.0) {\n        col = color_0;\n    }\n    else  {\n        col = color_1;\n    }\n    \n    // Black on the edges.\n    col = mix(col, vec3(0.0), edge);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 478, 502, 502, 532], [533, 533, 556, 556, 644], [646, 646, 671, 671, 803], [805, 805, 829, 829, 1139], [1141, 1164, 1196, 1196, 2558], [2560, 2560, 2597, 2597, 2675], [2677, 2724, 2770, 2770, 2837], [2839, 2893, 2989, 3098, 3922], [3924, 3924, 3981, 3981, 4332]], "test": "valid"}
{"id": "ld3XRj", "name": "168531", "author": "Natthan", "description": "6546", "tags": ["5487"], "likes": 2, "viewed": 658, "published": "Public", "date": "1463761812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLU_SPEED\t2.4\n#define RED_SPEED\t5.8\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos=(fragCoord.xy/iResolution.y);\n\tpos.x-=iResolution.x/iResolution.y/2.0;pos.y-=0.5;\n\tvec2 mse;\n\t//mse.x+=(mouse.x-0.5)*resolution.x/resolution.y;mse.y+=mouse.y-0.5;\n\t\n\tfloat fx=sin(pos.x*10.0+iTime*BLU_SPEED+mse.x*BLU_SPEED*2.0)/4.0;\n\tfloat dist=abs(pos.y-fx)*80.0;\n\tfragColor+=vec4(0.5/dist,0.5/dist,1.0/dist,1.0);\n\t\n\tfx=cos(pos.x*10.0+iTime*RED_SPEED+mse.x*RED_SPEED*2.0)/4.0;\n\tdist=abs(pos.y-fx)*80.0;\n\tfragColor+=vec4(1.0/dist,0.5/dist,0.5/dist,1.0);\n\t\n\tif (pos.y<=-0.2) {\n\t\tfragColor+=vec4(abs(pos.y+0.2),abs(pos.y+0.2),abs(pos.y+0.2),1.0);\n        }\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 669]], "test": "valid"}
{"id": "ld3XWl", "name": "Dithering methods", "author": "kuvkar", "description": "Trying out couple of dithering methods to get rid of quantization artefacts. Reference: https://www.shadertoy.com/view/MslGR8# by hornet. Also http://www.loopit.dk/banding_in_games.pdf.  Dithered version is on the right side, undithered on the left.\n\n", "tags": ["dithering"], "likes": 5, "viewed": 357, "published": "Public", "date": "1462103259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* trying out couple of dithering methods to get rid of quantization artefacts.\n* http://www.loopit.dk/banding_in_games.pdf\n*/\n\n// method to get compressed color\nconst float COLOR_LEVELS = 20.0;\nvec4 getColorCompressed(vec4 color)\n{\n    return floor(color * COLOR_LEVELS) / COLOR_LEVELS;\n}\n\n// standard \"rand\" function \nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n///////////////////////// dithering functions from ////////////////\n// https://www.shadertoy.com/view/MslGR8# by hornet           /////\n///////////////////////////////////////////////////////////////////\n\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\n// note: valve edition\n//       from http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// note: input in pixels (ie not normalized uv)\nvec3 ScreenSpaceDither( vec2 vScreenPos )\n{\n\t// Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n    vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy ) );\n    vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) ) - vec3( 0.5, 0.5, 0.5 );\n\treturn (vDither.rgb / 255.0) * 0.375;\n}\n\n////////////\n////////////\n////////////\n\n// three different dithering methods.\n#define TRIANGLE_NOISE\n//#define SCREENSPACE_DITHER\n//#define UNIFORM_NOISE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 col = texture(iChannel0, uv);\n\tvec2 seed = uv;\n    \n    vec4 ditherCol;\n    seed += fract(iTime);\n\tfloat ditherAmount = 0.045;\n    \n#ifdef TRIANGLE_NOISE\n    ditherCol.r = (hash12( seed ) + hash12(seed + 0.59374) - 0.5 );\n    seed += 0.1;\n    ditherCol.g = (hash12( seed ) + hash12(seed + 0.59374) - 0.5 );\n    seed += 0.04;\n    ditherCol.b = (hash12( seed ) + hash12(seed + 0.59374) - 0.5 );\n#endif\n\n#ifdef SCREENSPACE_DITHER\n    ditherCol = vec4(ScreenSpaceDither(fragCoord), 1.0);\n   \tditherAmount = 35.0;\n#endif\n    \n#ifdef UNIFORM_NOISE    \n\tditherCol.r = rand(seed);\n    seed += 0.1;\n    ditherCol.g = rand(seed);\n    seed += 0.04;\n    ditherCol.b = rand(seed);\n#endif\n\n    // dithered version on the right side.\n    if(uv.x > 0.5) col += ditherCol * ditherAmount;\n\n    // compress the result\n    col = getColorCompressed(col);\n    \n    // black line\n    if(abs(uv.x - 0.5) < 0.003) col = vec4(0.0);\n    \n\tfragColor = col;    \n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 235, 235, 292], [294, 323, 343, 343, 413], [667, 667, 690, 690, 802], [803, 803, 825, 825, 941], [942, 942, 963, 963, 1116], [1119, 1284, 1327, 1417, 1621], [1778, 1778, 1835, 1835, 2818]], "test": "error"}
{"id": "ldcSDl", "name": "G-Lectric Sheep 2", "author": "vox", "description": "G-Lectric Sheep 2", "tags": ["glectricsheepelectric2"], "likes": 1, "viewed": 407, "published": "Public API", "date": "1462075779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(uv*2.0-1.0)*1.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 fbdim = vec2(851.0, 315.0); //Facebook cover photo dimensions.\n    vec2 fbdim = iResolution.xy;\n    float fbaspect = fbdim.y/fbdim.x;\n   \n    vec2 uv = fragCoord.xy-iResolution.xy/2.0;\n    \n    if(abs(uv.x) > fbdim.x/2.0 || abs(uv.y) > fbdim.y/2.0)\n        discard;\n    \n    float zoom = (3.0+2.0*sin(time))*PI;\n    \n    uv = uv.xy / (iResolution.xy/2.0-fbdim.xy);\n    uv.x *= fbaspect;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    \n   \tconst int max_i = 16;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float sum = 0.0;\n    float magnification;\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/fbdim, magnification);\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(0.0, 1.0, ifs);\n        \n        ifs *= sqrt(1.0/(1.0+magnification));\n        \n        noise = min(noise, ifs);\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        sum += (pow(clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0), .5))*noise;\n        \n\t\tif(ifs == 0.0)\n            break;\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //sum /= float(max_i);\n    float shift = time;\n\n    vec3 final = (\n        \t\t\t\tvec3(saw(sum*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+sum*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+sum*PI*2.0+shift)\n                 \t\t)\n        \t\t )*smoothstep(0.0, .25, saw(sum*PI*3.0+time*5.0))+ifs;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 314, 314, 384], [386, 386, 415, 415, 499], [565, 565, 587, 587, 825], [827, 827, 846, 846, 891], [893, 893, 952, 952, 1525], [1527, 1527, 1584, 1658, 3216]], "test": "valid"}
{"id": "ldcSRj", "name": "123654789", "author": "Natthan", "description": "sfg", "tags": ["dg"], "likes": 0, "viewed": 111, "published": "Public", "date": "1463761673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n\tvec2 screen = fragCoord.xy / iResolution.xy; // <== environement\n    \n    float sound = texture ( iChannel0, vec2(screen.x, 0.75) ).x; // <== chargement de l'image\n    \n    vec3 color = vec3(.0); // <== initialisation\n    \n    color += vec3(abs(sin(iTime)) - smoothstep ( 0.0, 0.02, abs(sound - screen.y)),\n                  abs(sin(iTime * 2.0/3.0 * 3.1415 )) - smoothstep (0.0 , 0.02, abs(sound - screen.y)),\n                  abs(sin(iTime * 4.0/3.0 * 3.1415 )) - smoothstep (0.0 , 0.02, abs(sound - screen.y)));\n    \n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [{"id": "lsX3Rf", "previewfilepath": "https://soundcloud.com/arhen-blaz/darude-sandstrom-arhen-blaz-remix-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/arhen-blaz/darude-sandstrom-arhen-blaz-remix-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 612]], "test": "error"}
{"id": "lddSDl", "name": "Acid fractal stuff", "author": "mlavik1", "description": "Started out as an implementation of mandelbrot fractals, but ended up as something slightly different", "tags": ["fractal"], "likes": 1, "viewed": 138, "published": "Public", "date": "1462260087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float minR = -2.0;\nconst float maxR = 1.0;\nconst float minI = -1.0;\nconst float maxI = 1.0;\nconst int maxIterations = 40;\n\nstruct complexNumber\n{\n\tfloat r;\n\tfloat i;\n};\n\t\ncomplexNumber c_add(complexNumber a, complexNumber b)\n{\n\tcomplexNumber ret;\n\tret.r = a.r + b.r;\n\tret.i = a.i + b.i;\n\treturn ret;\n}\n\ncomplexNumber c_subtract(complexNumber a, complexNumber b)\n{\n\tcomplexNumber ret;\n\tret.r = a.r - b.r;\n\tret.i = a.i - b.i;\n\treturn ret;\n}\n\ncomplexNumber c_divide(complexNumber a, float d)\n{\n\tcomplexNumber ret;\n\tret.r = ret.r / d;\n\tret.i = ret.i / d;\n\treturn ret;\n}\n\ncomplexNumber c_pow(complexNumber a, const int p)\n{\n\tcomplexNumber ret = a;\n\tint iCount = 1;\n\tfor(int i = 1; i < 5; i++)\n\t{\n\t\tret.r = ret.r*ret.r - ret.i*ret.i;\n\t\tret.i = 2.0*a.r*a.i;\n\t\tif(++iCount == p)\n\t\t\tbreak;\n\t}\n\t\n\treturn ret;\n}\n\n\n\nfloat c_abs(complexNumber a)\n{\n\tfloat absVal = sqrt(a.r*a.r + a.i*a.i);\n\treturn absVal;\n}\n\ncomplexNumber c_exp(complexNumber a)\n{\n\tcomplexNumber ret =  c_add(complexNumber(1.0,0.0), a); // not really exp, but it looks nice\n\t//ret = c_add(ret, c_divide(c_pow(ret,2), 2.0));\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n\tvec2 pos = ( fragCoord.xy / iResolution.xy );\n\tvec3 col = vec3(0.0,0.0,0.0);\n\n\tcomplexNumber c = complexNumber(0.0,0.0);\t\n\tc.r = minR + (cos(pos.x*16.0)/2.0+1.0)*(maxR-minR);\n\tc.i = minI + (cos(pos.y*16.0)/2.0+1.0)*(maxI-minI);\n\t\n\tcomplexNumber z = c;\n\tint iterations = -1;\n\tfor(int i = 0; i < maxIterations; i++)\n\t{\n\t\tif(c_abs(z) > 50.0)\n\t\t{\n\t\t\titerations = i;\n\t\t\tbreak;\n\t\t}\n\t\tz = c_add(c_exp(c_pow(z,3)), complexNumber(-2.0*sin(time+(pos.x - sin(pos.y)))-2.0, 0.0));\n\t\t\n\t}\n\t\n\tif(iterations >= 0)\n\t{\n\t\tfloat i = float(iterations)/float(maxIterations);\n\t\tcol.r = smoothstep(0.0,0.5+(0.5*sin(time)/2.0), i);\n\t\tcol.g = smoothstep(0.0,1.0,i);\n\t\tcol.b = smoothstep(0.4,1.0, i);\n\t}\n\telse\n\t{\n\t\tcol.g = 0.3*cos(iResolution.x*length(vec2(0.5,0.5) - pos)) * cos(iResolution.x*length(vec2(0.8,0.2) - pos));\n\t\tcol.b = cos(sin(time)*10.0+10.0*length(vec2(0.2,0.6) - pos));\n\t}\n\t\n\tfragColor.rgb = col;\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 344, 344, 419], [421, 421, 481, 481, 556], [558, 558, 608, 608, 683], [685, 685, 736, 736, 918], [922, 922, 952, 952, 1011], [1013, 1013, 1051, 1051, 1209], [1211, 1211, 1268, 1268, 2200]], "test": "error"}
{"id": "lddSWl", "name": "More Mobius 1", "author": "vox", "description": "More Mobius 1", "tags": ["moremobius1"], "likes": 6, "viewed": 525, "published": "Public API", "date": "1462229079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E))*10.0;\n\tvec2 b = sin(seedling+vec2(time, time*GR/E))*10.0;\n\tvec2 c = sin(seedling+vec2(time, time*GR/E))*10.0;\n\tvec2 d = sin(seedling+vec2(time, time*GR/E))*10.0;\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    vec2 mob = mobius(zoom*(uv*2.0-1.0));\n    \n    return saw(mob*2.0*PI);\n}\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0;\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x)*turns-r*PI*2.0;\n    return vec2(saw(r*PI),\n                saw(theta));\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i =16;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float ifsSqrt = 1.0;\n    float depth = 0.0;\n    float magnification;\n    int last_i;\n    seedling = 0.0;\n    vec3 final;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        last_i = i;\n        \n        float iteration = saw(time*4.0)*float(max_i);\n        \n        float fade = i == max_i-1 ? 1.0-fract(iteration) : 1.0;\n        \n        seedling += fract(float(i)*123456.123456);\n        \n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        \n        float weight = ifs;\n        \n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        ifsSqrt = sqrt(ifs);\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        float delta = sphereN(uv*2.0-1.0).z*ifsSqrt;\n        depth += fade*(1.0-delta)*ifs;\n        \n\t\tif(ifs != 0.0)\n        {\n            uv = spiral(uv*2.0-1.0);//*clamp(pow(delta, SPIRAL_BLUR_SCALAR)*2.0, 0.0, 1.0);\n        }\n        \n        ifs = ifsSqrt;\n        \n        seedling += saw(atan(uv.y*2.0-1.0, uv.x*2.0-1.0));\n        seedling += depth;\n        \n        float shift = time;\n\n        float stripes = depth*PI*5.0*ifs*(sin(time)+2.0);\n        float black = smoothstep(0.0, .25, saw(stripes))*ifs/float(i+1);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*ifs/float(i+1);\n\n\n        final += (\n            vec3(saw(depth*PI*2.0+shift),\n                 saw(4.0*PI/3.0+depth*PI*2.0+shift),\n                 saw(2.0*PI/3.0+depth*PI*2.0+shift)\n                )\n        )*black\n            +white;\n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(last_i+1.0);\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final/2.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[745, 745, 774, 774, 844], [846, 846, 875, 875, 959], [1037, 1037, 1059, 1059, 1317], [1319, 1319, 1338, 1338, 1415], [1417, 1417, 1439, 1439, 1597], [1599, 1599, 1658, 1658, 2231], [2233, 2233, 2290, 2290, 4291]], "test": "valid"}
{"id": "lddXD2", "name": "close encounters u.f.o.", "author": "tomaes", "description": "Vaguely inspired by old time-y sci-fi movies. :)", "tags": ["pseudo3d", "layered"], "likes": 0, "viewed": 184, "published": "Public", "date": "1462125324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Close Encounters Shader / tomaes.32x.de\n// v20160429\n\nfloat r(vec2 _p, float _t, float _s)\n{\n    float rs  = sin(_t+_p.y*(10.+_s))+sin(_t+_p.y*(20.+_s))+sqrt(sin(_t+_p.x*(20.+_s))+tan(_p.y*20.));\n          rs /= sin(_t+_p.y*(12.+_s))+sin(_t+_p.y*(30.+_s))+sqrt(sin(_t+_p.x*(30.+_s))+tan(_p.y*20.));\n\n    return rs;\n}\n\nvec4 rr(vec2 _p, float _t, float _s)\n{\n    _p = _p*acos( tan(_p.y+_p.x+_t*.5)/_p+_p*.5);\n    \n    vec4 f = vec4(.0,.0,.0,1.);\n    \n    f  = vec4(r(_p.xy+mod(_p.x,.01),_t,-20.+mod(_t*5.,50.) ),.1,.0, 1.);\n    f *= vec4(r(_p.yx+mod(_p.y,.01),_t,-20.+mod(_t*5.,50.) ),.1,.0, 1.);\n\n    f += .1*vec4(r(_p.xy+mod(_p.x,.05),_t,-20.+mod(_t*5.,50.)*_s ),.1,.0, 1.).xxyx;\n    f += .1*vec4(r(_p.yx+mod(_p.y,.05),_t,-20.+mod(_t*5.,50.)*_s ),.1,.0, 1.).xxyx;\n\n    if (mod(_t,.5)<.25)\n\t\tf += ((mod(_p.x,.2) < 0.01+sin(_t*.5+_p.x*5.+_p.y*5.)*.005) ? .8 : .0);    \t\n\n    return f;    \n}\n\nvoid mainImage( out vec4 c, vec2 p )\n{    \n    p = p / iResolution.y;\n    float t = iTime + 5.58;\n\n    c = vec4(0.,0.,0.,1.);\n    float b = mod(.5 * sin(t + p.y/mod(p.y,.1) *5.),min(p.y*p.x,.03)  );\n    \n\tc  = rr( p, t, 1. );\n\n    // blue swipes\n    c += abs(b * sin(p.x + t*5.)) * 10.;    \n    \n    // bright \"scan\" lines\n    if (mod(t+p.y,.5) < 0.03)\n    \tc = vec4( length(c) );\n    \n    //if (p.x < .1 || p.x > 1.7) c = vec4(1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 95, 95, 319], [321, 321, 359, 359, 891], [893, 893, 931, 931, 1327]], "test": "valid"}
{"id": "ldGSRh", "name": "Fractal of Disapproval", "author": "dextero", "description": "Look of Disapproval as a fractal.", "tags": ["fractal", "disapproval", "look"], "likes": 3, "viewed": 96, "published": "Public", "date": "1462748454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nconst vec4 cBackgroundColor = vec4(0.4, 0.4, 1.0, 1.0);\nconst vec4 cObjectColor = vec4(1.0, 1.0, 1.0, 1.0);\n\nconst float MARGIN = 1.0;\nconst float EYE_RADIUS = 10.0;\nconst float EYE_OFFSET = EYE_RADIUS;\nconst float EYEBROW_RADIUS = 0.5 * EYE_RADIUS;\nconst float EYEBROW_LENGTH = EYE_RADIUS * 2.0 - EYEBROW_RADIUS;\nconst float FOLD_SCALE = (4.0 * EYE_RADIUS + 2.0 * EYE_OFFSET);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat3(oc * x * x + c,      oc * x * y - z * s,  oc * z * x + y * s,\n                oc * x * y + z * s,  oc * y * y + c,      oc * y * z - x * s,\n                oc * z * x - y * s,  oc * y * z + x * s,  oc * z * z + c);\n}\n\nstruct State {\n    bool hit;\n    vec3 pos;\n};\n\nState translate(State state,\n                vec3 offset) {\n    if (state.hit) { return state; }\n\n    state.pos -= offset;\n    return state;\n}\n\nState rotate(State state,\n             vec3 axis,\n             float angle) {\n    if (state.hit) { return state; }\n\n    state.pos = rotationMatrix(axis, -angle) * state.pos;\n    return state;\n}\n\nState scale(State state,\n            vec3 scale) {\n    if (state.hit) { return state; }\n\n    state.pos *= scale;\n    return state;\n}\n\nState x_line(State state,\n             vec3 offset,\n             float width) {\n    if (state.hit) { return state; }\n\n    if (abs(state.pos.y - offset.y) > MARGIN\n            || abs(state.pos.z - offset.z) > MARGIN\n            || abs(state.pos.x - offset.x - width / 2.0) > width / 2.0) {\n        return state;\n    }\n\n    state.pos -= offset;\n    state.pos.x = mod(state.pos.x, MARGIN * 2.0) - MARGIN;\n    state.hit = true;\n\n    return state;\n}\n\nState xy_circle(State state,\n                vec3 center,\n                float radius) {\n    if (state.hit) { return state; }\n\n    if (distance(state.pos.xy, center.xy) > radius\n            || distance(state.pos.xy, center.xy) < (radius - MARGIN * 2.0)) {\n        return state;\n    }\n\n    state = translate(state, center);\n    float angle = atan(state.pos.y, state.pos.x);\n    float part_radius = MARGIN;\n    float part_radians = asin(part_radius / (radius - part_radius)) * 2.0;\n    part_radians += mod(2.0 * PI, part_radians) / floor(2.0 * PI / part_radians);\n    float rot_angle = angle - mod(angle, part_radians) + part_radians / 2.0;\n    state = rotate(state, vec3(0.0, 0.0, 1.0), -rot_angle);\n    state = translate(state, vec3(radius - part_radius, 0.0, 0.0));\n    state = scale(state, vec3(MARGIN / part_radius));\n\n    state.hit = true;\n    return state;\n}\n\nState eyebrow_arc(State state,\n                  vec3 center,\n                  float radius) {\n    if (state.pos.x - center.x < 0.0) {\n        return state;\n    }\n\n    return xy_circle(state, center, radius);\n}\n\nState eyebrow(State state,\n              vec3 offset,\n              float length,\n              float radius) {\n    if (state.hit) { return state; }\n\n    state = x_line(state, offset, length);\n    state = eyebrow_arc(state, vec3(offset.x + length, offset.y + radius - MARGIN, offset.z), radius);\n    return state;\n}\n\nState eye(State state,\n          vec3 offset,\n          float eye_radius,\n          float eyebrow_radius) {\n    if (state.hit) { return state; }\n\n    if (length(state.pos - offset) < MARGIN) {\n        state.hit = true;\n        state.pos -= offset;\n        return state;\n    }\n\n    state = xy_circle(state, offset, eye_radius);\n    state = eyebrow(state,\n            // HACK: MARGIN\n                    vec3(offset.x - eye_radius + MARGIN, offset.y + eye_radius + MARGIN, offset.z),\n                    2.0 * eye_radius - eyebrow_radius - MARGIN,\n                    eyebrow_radius);\n\n    return state;\n}\n\nvec4 fractalOfDisapproval(vec3 pos) {\n    State state;\n    state.hit = false;\n    state.pos = pos;\n\n    int numHits = 0;\n    for (int i = 0; i < 8; ++i) {\n        state.hit = false;\n\n        state = x_line(state, vec3(EYE_RADIUS, -EYE_RADIUS, 0.0), 2.0 * EYE_OFFSET);\n        state = eye(state, vec3(0.0, 0.0, 0.0), EYE_RADIUS, EYEBROW_RADIUS);\n        state = eye(state, vec3(2.0 * (EYE_OFFSET + EYE_RADIUS), 0.0, 0.0), EYE_RADIUS, EYEBROW_RADIUS);\n\n        if (state.hit) {\n            ++numHits;\n        } else {\n            break;\n        }\n\n        state.pos *= FOLD_SCALE;\n    }\n\n    float dist = distance(state.pos / FOLD_SCALE, vec3(0.0, 0.0, 0.0));\n\n    if (state.hit && dist < MARGIN) {\n        return cObjectColor;\n    }\n\n    vec4 backgroundColor = vec4(numHits == 4 || numHits == 5 || numHits == 6 || numHits == 7 ? 0.6 : 0.0,\n                                numHits == 2 || numHits == 3 || numHits == 5 || numHits == 6 ? 0.6 : 0.0,\n                                numHits == 1 || numHits == 3 || numHits == 5 || numHits == 7 ? 0.6 : 0.0,\n                                1.0);\n\n    return backgroundColor / sqrt(dist);\n}\n\nvoid mainImage(out vec4 fragColor,\n               in vec2 fragCoord) {\n  vec2 screenSize = vec2(1.0, iResolution.y / iResolution.x) * 100.0;\n  vec3 pos = vec3(fragCoord.x / iResolution.x * screenSize.x - screenSize.x / 2.0,\n                  fragCoord.y / iResolution.y * screenSize.y - screenSize.y / 2.0,\n                  0.0);\n\n  pos /= exp(13.0 * (1.0 + sin((iTime - 8.0) / 5.0)));\n\n  fragColor = fractalOfDisapproval(pos);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 477, 477, 882], [931, 931, 990, 990, 1073], [1075, 1075, 1152, 1152, 1268], [1270, 1270, 1320, 1320, 1402], [1404, 1404, 1483, 1483, 1848], [1850, 1850, 1939, 1939, 2714], [2716, 2716, 2811, 2811, 2927], [2929, 2929, 3040, 3040, 3244], [3246, 3246, 3353, 3353, 3849], [3851, 3851, 3888, 3888, 4983], [4985, 4985, 5055, 5055, 5415]], "test": "valid"}
{"id": "ldGSWD", "name": "Ode to Cosine", "author": "s23b", "description": "Inspired by my coworker's drawing", "tags": ["2d", "cosine", "drawing", "desert", "hourglass"], "likes": 36, "viewed": 1064, "published": "Public API", "date": "1464614627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec4 blend(vec4 c1, vec4 c2) {\n    return vec4(mix(c1.rgb, c2.rgb, c2.a), max(c1.a, c2.a)); \n}\n\nvec4 sky(vec2 uv) {\n    return vec4(mix(vec3(.3, .6, 1.), vec3(.1, .3, .7), uv.y), 1);\n}\n\nvec4 hill(vec2 uv) {\n    return vec4(mix(vec3(.0, .5, .2), vec3(.4, .8, .4), smoothstep(-.2, .3, uv.x + uv.y / 3.)),\n\t\tsmoothstep(uv.y, uv.y + .005, cos(uv.x * 4.) * .2));\n}\n\nvec4 dune(vec2 uv) {\n    return vec4(\n        mix(vec3(.7, .5, .2), vec3(.9, .8, .5), smoothstep(-.2, .3, uv.x + uv.y / 3.)),\n\t\tsmoothstep(uv.y, uv.y + .01, cos(uv.x * 4.) * .2));\n}\n\nvec4 overlay(vec2 uv) {\n    uv = abs(uv);\n    return vec4(vec3(0), step(.85, uv.y) + (1. - smoothstep(uv.x + .57, uv.x + .575, 1. - pow(cos(uv.y * 2.), 4.) / 2.5)));\n}\n\nfloat dunemask(vec2 uv) {\n    if (uv.y > 0.) return 1.;\n    float w = .03;\n    float h = smoothstep(uv.y + .85, uv.y + .855, cos(uv.x * 7.) / 10.);\n    uv.x += cos(uv.y * 10. + iTime * 10.) / 100. * abs(uv.y);\n    return max(smoothstep(-w, -w + .005, uv.x) - smoothstep(w - .005, w, uv.x), h);\n}\n\nvec4 rect(vec2 uv) {\n    uv = abs(uv);\n    return vec4(vec3(.5), uv.x < 1. && uv.y < 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = sky(uv);\n    \n    fragColor = blend(fragColor, hill(uv - vec2(-.2, -.75)));\n    fragColor = blend(fragColor, hill(uv - vec2(.3, -.7)));\n    \n    vec4 d = dune(uv * 2. + vec2(0, -.9));\n    d = blend(d, dune(uv * 2. + vec2(-.6, -.7)));\n    d = blend(d, dune(uv * 2. + vec2(.5, -.7)));\n    \n    fragColor = blend(fragColor, vec4(d.rgb, min(d.a, dunemask(uv))));\n    \n    fragColor = blend(fragColor, overlay(uv));\n    \n    uv = abs(uv);\n    fragColor = blend(fragColor, rect(uv * vec2(2.1, 40) - vec2(0, 37)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 56, 56, 120], [122, 122, 141, 141, 210], [212, 212, 232, 232, 385], [387, 387, 407, 407, 568], [570, 570, 593, 593, 737], [739, 739, 764, 764, 1034], [1036, 1036, 1056, 1056, 1127], [1129, 1129, 1186, 1186, 1809]], "test": "valid"}
{"id": "ldGXWh", "name": "TreeGenerator", "author": "kuvkar", "description": "Create your own tree! Move the cursor around to generate them. Try fullscreen!", "tags": ["procedural", "tree", "generator"], "likes": 54, "viewed": 840, "published": "Public", "date": "1464123193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Can add more if your GPU can handle it! :)\n#define LEAFS 8\n#define BRANCHES 6\n#define TRUNKS 6\n\n\n///////////////////////////////////////////\n///////////////////////////////////////////\nconst float PI = 3.14159265;\nconst float WSCALE = 0.8;\n#define T (iTime*0.5)\nconst float LEAF = 1.0;\nconst float TRUNK = 2.0;\n\nvec2 seed;\nvec2 im;\n\n//http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b )\n{\n    float k = 0.003;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat rand(vec2 co)\n{\n    co += im.xy + seed;\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 rotate(vec2 point, float angle)\n{\n    float x = point.x; float y = point.y;\n    float ca = cos(angle);\n    float sa = sin(angle);\n    point.x = x * ca - y * sa;\n    point.y = y * ca + x * sa;\n    return point;\n}\n\nfloat sdTreePart(vec2 pos, vec2 uv, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rotate(uv, angle) + pivot;\n    \n    float b = WSCALE + smoothstep(0.0, -h * 2., uv.y - h) * (1.0 - WSCALE);\n    w *= b;\n    \n    float y = max(uv.y - h, -h - uv.y);\n    float x = max(uv.x - w, -w - uv.x);\n    \n    return max(x, y);\n}\n\nfloat sdLeaf(vec2 pos, vec2 uv, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rotate(uv, angle) + pivot;\n    \n    w -= cos(uv.y * 500.) * 0.001;\n    h -= sin(uv.x * 500.) * 0.002;\n    float y = max(uv.y - h, -h - uv.y);\n    float x = max(uv.x - w, -w - uv.x);\n    \n    return max(x, y);\n}\n\n\nfloat Cursor(in vec2 uv, inout vec2 pos, float H, inout float angle, inout float W)\n{\n    seed += vec2(0.01, 0.04);\n    W *= WSCALE;\n    vec2 pivot = vec2(0.0, -H);\n    float b = sdTreePart(pos, uv, pivot, angle, W, H);\n    pos += vec2(sin(angle), cos(angle)) * H * 2.;\n    float r = rand(seed);\n    angle += (r - 0.5) * 0.9;\n    return b;\n}\n\nint leafIndex = 0;\n\nvec2 Tree (vec2 pos, vec2 uv)\n{\n    float H = 0.02;\n    vec2 pivot = vec2(0.0, -H);\n    float b = 999.0;\n    float angle = 0.0;\n    float W = 0.01;\n    \n    float randH = 0.5 * (rand(im.xy) - 0.5);\n    float randA = rand(im.yx) - 0.5;\n    float lf = 999.0;\n    float LEAFANGLE = PI * 0.2;\n    vec2 leafSize = vec2(0.005, 0.01);\n    \n    for (int i = 0; i < TRUNKS; ++i)\n    {\n        b = smin(b, Cursor(uv, pos, H, angle, W));\n        \n        vec2 p = pos;\n        float h = H; \n        float a = randA + angle + sin(T + float(i)) * 0.1;\n        float w = W;\n\t\t\n        for (int j = 0; j < BRANCHES; ++j)\n        {\n            b = smin(b, Cursor(uv, p, h, a, w));    \n            \n            vec2 p1 = p;\n            float h1 = max(randH * 0.06, 0.006); \n            float a1 = randA + a + sin(T + float(j) * 0.4) * 0.1;\n            float w1 = w;\n\n            for (int k = 0; k < LEAFS; ++k)\n            {\n               b = smin(b, Cursor(uv, p1, h1, a1, w1));    \n               float angl = mod(float(k), 2.0)  == 0.0 ? 1.0 : -1.0;\n               float newLeaf = sdLeaf(p1, uv, vec2(0.0, -leafSize.y),  (a1 + angl * LEAFANGLE), leafSize.x, leafSize.y);\n               if(newLeaf < lf) leafIndex = i * 100 + j * 10 + k;\n               lf = min(lf, newLeaf);\n               if(lf < 0.0 || b < 0.0) break; \n            }\n            if(lf < 0.0 || b < 0.0) break; \n        }\n        if(lf < 0.0 || b < 0.0) break; \n    }\n    \n    \n    if(b < lf)\n    {\n        return vec2(TRUNK, b);\n    }\n    return vec2(LEAF, lf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    im = iMouse.xy;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    fragColor = vec4(1.0 - (uv.y + 0.4)) * vec4(.3, 0.3, 0.5, 0.0) * 0.7;\n    \n    // bg stars\n    vec2 star_uv = mod(fragCoord.xy, vec2(512.0)) / 512.0;\n    float F = 0.9;\n    vec4 tx = texture(iChannel0, star_uv);\n    vec4 tx2 = texture(iChannel0, star_uv * 0.2 + vec2(iTime * 0.01));\n    tx = clamp(tx - F, 0.0, 1.0);\n    tx /= 1.0 - F;\n    fragColor += tx.r * tx2.r;\n    \n    \n    vec2 pos = vec2(-0., -0.32);\n    vec2 material = Tree(pos, uv);\n    \n    float margin = 2.0 * fwidth(uv).x;\n    float t = material.y / margin;\n    t = clamp(t, -0.1, 1.0);\n    \n    vec4 col = vec4(t);\n\tcol = smoothstep(.5, 0.0, col);\n    \n    if(material.x == LEAF)\n    {\n        float leafCol = sin(float(leafIndex) * .5) * 0.5 + 0.5;\n        leafCol = mix(leafCol, 1.0, 0.5);\n        col = vec4(leafCol) * vec4(1.0, 0.2, 0.1, 0.0);\n    }\n    else if (material.x == TRUNK)\n    {\n        col *= vec4(.8, 0.5, 0.3, 0.0);\n    }\n\n    fragColor = mix(col, fragColor, t);\n    \n    \n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 387, 419, 419, 533], [535, 535, 556, 556, 652], [654, 654, 676, 676, 748], [751, 751, 789, 789, 967], [969, 969, 1049, 1049, 1307], [1309, 1309, 1385, 1385, 1620], [1623, 1623, 1708, 1708, 1964], [1986, 1986, 2017, 2017, 3505], [3507, 3507, 3564, 3564, 4664]], "test": "error"}
{"id": "ldGXWR", "name": "Antialiasing on 2d metaballs", "author": "lowww", "description": "study on 2d metaballs and antialiasing", "tags": ["aa", "2dmetaballs"], "likes": 1, "viewed": 123, "published": "Public", "date": "1463710323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 metaballs[3]; \n    metaballs[0] = vec3(sin(iTime) * 0.1 + 0.1, cos(iTime) * 0.1 + 0.4, 0.05);\n\tmetaballs[1] = vec3(1.0, 0.5, 0.1);\n    metaballs[2] = vec3(iMouse.xy / iResolution.y, 0.1);\n\n    vec2 ssnormal = fragCoord.xy / iResolution.y;\n    \n    float frag = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < 3; i++) {\n    \td += metaballs[i].z / distance(metaballs[i].xy, ssnormal);\n        frag += smoothstep(0.97, 1.0, length(d));\n    }\n    \n\tfragColor = vec4(frag, frag, frag, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 553]], "test": "valid"}
{"id": "ldGXWW", "name": "Gradual Change", "author": "Lawliet", "description": "Gradual Change", "tags": ["gradualchange"], "likes": 2, "viewed": 535, "published": "Public API", "date": "1464333684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //fragColor = vec4(uv.xx * 0.5 + 0.25,0.5+0.5*sin(iTime),1.0);\n    \n    float x = uv.x / 4.0 + 0.5 + 0.5 * sin(iTime * 0.5);\n    \n    fragColor = vec4(x*1.0,(1.0-x)*1.0,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 332]], "test": "valid"}
{"id": "ldGXzD", "name": "Shiny Chocolate Star", "author": "zachernuk", "description": "Learning how to use 2D SDF functions. So far so good!", "tags": ["2d", "sdf", "star", "chrome"], "likes": 3, "viewed": 161, "published": "Public", "date": "1463169623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\nvec2 st;\nfloat starDist(in vec2 off) {\n    \n    vec2 starST = st - vec2(0.500,0.460)+off;\n    \n    starST = starST*(1.+1.176*abs(sin(atan(starST.x,starST.y)*2.5+iTime*0.9040)));\n    starST = abs(starST);\n    \n    return length(starST);\n}\n\n#define pi 3.141\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    st = fragCoord.xy/iResolution.xy;\n    st.x-=0.25;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(1.);\n\n    \n  \n    float low = 0.144+0.00002*abs(sin(iTime*4.));\n    float range = 0.324;\n    float d = 0.452/100.;\n    float mixVal = smoothstep(low, low+range, starDist(vec2(0.000,-0.000)));\n\tfloat offX = smoothstep(low, low+range, starDist(vec2(d,-0.000)));\n\tfloat offY = smoothstep(low, low+range, starDist(vec2(0.000,d)));\n\tfloat angle = (atan(mixVal-offX, mixVal-offY)+pi)/2./pi;    \n    \n    \n    \n    \n    vec3 color1 = vec3(0.970,0.959,1.000);\n    vec3 color2 = vec3(0.350,0.340,0.318);\n    color = mix(color1, color2, mixVal);\n\tfragColor.rgb = color;\n    fragColor.a = 1.;\n   fragColor.rgb = pow(vec3(fract(angle*3.)),4.680*vec3(0.268,0.607,1.000));\n    fragColor *=smoothstep(1., 1.-0.098, mixVal);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 55, 55, 630], [640, 640, 669, 669, 868], [887, 887, 944, 944, 1777]], "test": "valid"}
{"id": "ldKXRm", "name": "Passage Infinitum", "author": "JasonD", "description": "Inspiration from my own EvalDraw demo that essentially did the same thing. This time on the GPU.", "tags": ["floor", "textured", "ceiling"], "likes": 5, "viewed": 175, "published": "Public", "date": "1463633577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// Passage Infinitum\n// May 18, 2016\n\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n#define X_SCALE 0.3     // size of texture stretch horizontally\n#define Z_SCALE 0.2     // size of texture stretch into screen\n\n#define Z_SPEED     0.3    // speed of motion into screen\n#define X_SPEED_MAX 0.5    // max speed horizontally \n#define X_CYCLE_SPEED 0.1  // cycle of horizontal (left/right) motion switch\n\n#define CAM_YAW_CYCLE_SPEED 0.225     // cycle of camera rotate left/right angle\n#define CAM_YAW_MAX_ANGLE 1.570796    // max camera rotate left/right angle\n\n#define CAM_ROLL_CYCLE_SPEED 0.168    // cycle of camera tilt angle\n#define CAM_ROLL_MAX_ANGLE 0.6642     // max camera rotate tilt angle\n\n#define CEN_POINT_CYCLE_SPEED1 0.562 // how fast the point goes around in a circle\n#define CEN_POINT_CYCLE_SPEED2 0.383 // how fast the point goes around in a circle\n#define CEN_POINT_CYCLE_MAG    0.3   // radius of the circle\n\n#define COLOR_CYCLE 0.25\n#define FADE_POWER 0.3\n\n\n// ---- CONSTANTS ----------------------------------------------------------------\n\n#define PI 3.1415926535897932384626\n\n\n// ---- CODE ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    float minRes = min(iResolution.x, iResolution.y);\n    fragCoord /= minRes;\n   \n    // center point on screen\n    vec2 center = (iResolution.xy / minRes) / 2.0;    \n\n    // select a point on screen, upon which to rotate the screen\n    //vec2 p = center;\n    float angle1 = CEN_POINT_CYCLE_SPEED1 * iTime;\n    float angle2 = CEN_POINT_CYCLE_SPEED2 * iTime;\n    vec2 p = center + vec2(cos(angle1), sin(angle2)) * CEN_POINT_CYCLE_MAG;\n        \n    \n    // rotate point on screen (rotate entire screen)\n    // around point P\n    float angle = sin(iTime * CAM_ROLL_CYCLE_SPEED) * CAM_ROLL_MAX_ANGLE;\n    float cs = cos(angle);\n    float sn = sin(angle);\n\n    // ----------------------------------------------\n    // TODO -- MAKE FUNCTION FOR THIS, AND RE-USE:\n    fragCoord.xy -= p;\n    vec2 newCoord;\n#if 0\n    newCoord = vec2(\n        fragCoord.x * cs + fragCoord.y * sn,\n        fragCoord.y * cs - fragCoord.x * sn);\n    fragCoord.xy = newCoord;\n#else\n    mat2 m = mat2( \n        cs, -sn,\n        sn,  cs\n        );\n    fragCoord = m * fragCoord;    \n#endif\n    fragCoord.xy += p;\n    // ----------------------------------------------\n    \n    \n    \n    // distance from center\n    vec2 dCenter = center - fragCoord.xy;\n    \n    // height of screen\n    float height = (iResolution.y / minRes) / 2.0;\n    \n    // 3D perspective: 1/Z = constant\n    float zCamera = 1.0 / abs(dCenter.y);\n    float xCamera = X_SCALE * dCenter.x * zCamera;\n    float yCamera = Z_SCALE * zCamera;\n\n    // static texture coordinates\n    fragCoord.xy = vec2(xCamera, yCamera);\n    \n    \n    // rotate camera\n    // via rotating texture\n    angle = sin(iTime * CAM_YAW_CYCLE_SPEED) * CAM_YAW_MAX_ANGLE;\n    cs = cos(angle);\n    sn = sin(angle);\n    newCoord = vec2(\n        fragCoord.x * cs + fragCoord.y * sn,\n        fragCoord.y * cs - fragCoord.x * sn);\n    fragCoord.xy = newCoord;    \n\n    // move\n    fragCoord.y += iTime * Z_SPEED;\n    fragCoord.x += cos(iTime * X_CYCLE_SPEED) * X_SPEED_MAX;\n\n    // textured\n    if (dCenter.y > 0.0)\n        fragColor = texture(iChannel0, fragCoord);\n    else\n        fragColor = texture(iChannel1, fragCoord);\n    \n    \n    // get rainbow color\n    angle = iTime * COLOR_CYCLE; // 0...1...2...\n    float mag = mod(angle, 1.0/6.0) * 6.0; // 0..1\n    vec3 fadeColor = clamp(\n        abs(\n            fract(\n                vec3( angle + 2./3. ) + vec3(3,2,1) / 3.\n            ) * 6. - 3.\n        ) - 1., \n        0., \n        1.\n    );\n        \n\n    // fade into distance\n    // y=1-(1/x)\n    // x=0..infinity, y=0..1=fade\n\n    // 0=no fade, 1=full fade\n    float fade = 1.0 - (1.0 / (1.0 + zCamera * FADE_POWER));\n    fragColor.rgb = mix( fragColor.rgb, fadeColor.rgb, fade );\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1269, 1269, 1326, 1506, 4203]], "test": "error"}
{"id": "ldKXz1", "name": "Pixel Patterns", "author": "innovati", "description": "Pixel patterns, cross hatch, shading", "tags": ["pixel", "pattern"], "likes": 0, "viewed": 84, "published": "Public", "date": "1463005884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = min(pow(vec4(float(iFrame), 0.1, pow(0.4, 0.3), 0.0), vec4(((1.5 - 0.1) - (gl_FragCoord.x / iResolution.x)), 1.9, (mod((gl_FragCoord.x / iResolution.x), float(iFrame)) * ((1.8 + 1.0) + (iTime - (gl_FragCoord.x / iResolution.x)))), 0.1)), fract(exp2(sin(sqrt(exp(log2(sin(pow(pow(vec4(0.2, (0.3 - 0.4), 0.1, (gl_FragCoord.y / iResolution.y)), min(acos(degrees(vec4(((gl_FragCoord.y / iResolution.y) / (gl_FragCoord.y / iResolution.y)), 1.3, 1.2, ((exp2(1.7) / 0.9) + ((step(1.4, 1.8) + float(iFrame)) * ((gl_FragCoord.x / iResolution.x) * 0.0)))))), vec4(0.4, cos((1.0 - 1.5)), 0.9, 0.3))), radians(radians(vec4(iTime, 0.4, 0.5, 0.1))))))))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 715]], "test": "timedout"}
{"id": "ldVSzD", "name": "Audio Vis", "author": "ottopo", "description": "Audio", "tags": ["audio"], "likes": 1, "viewed": 60, "published": "Public", "date": "1463346238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Nice colors\nvec3 rgb(vec3 col)  {\n    return vec3(col.r / 255., col.g / 255., col.b / 255.);\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), \n               mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat circle(vec2 r, float radius, vec2 center) {\n    return smoothstep(radius - .002, radius + .002, length(r - center));    \n}\n\nfloat wavyCircle(vec2 r, float radius, vec2 center, float waviness) {\n    vec2 r2 = center - r;\n    r2*=1.+waviness*(noise(r * 20. * sin(iTime)) - .5);\n    return circle(center + r2, radius, center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    float maxX = iResolution.x / iResolution.y;\n    vec3 background_color = rgb(vec3(sin(iTime * 6.)*255., 133, 27));\n    vec3 circle_color = rgb(vec3(0, 31, 63));\n    float circle_alpha = wavyCircle(uv , .3, vec2(.5 * maxX, .5), .14);\n    vec3 pixel = mix(circle_color,background_color, circle_alpha);\n    if ((circle_alpha > 0.0) && (circle_alpha < 1.0)) {\n        float new_alpha = -10.*abs(circle_alpha - .5) + 5.;\n        new_alpha = clamp(new_alpha, 0.0, 1.0);\n    \tpixel = mix(pixel, rgb(vec3(1, 255, 112)), new_alpha);\n    }\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 35, 35, 96], [98, 98, 118, 118, 188], [190, 190, 211, 211, 431], [433, 433, 482, 482, 561], [563, 563, 632, 632, 764], [766, 766, 823, 823, 1431]], "test": "valid"}
{"id": "ldVXR1", "name": "When raytracing goes wrong...", "author": "ivcoar", "description": "I was doing a simple raytracer, changed some things and this thing appeared. I think it looks cool but I have no idea how it works.", "tags": ["raytracing", "sphere", "bug", "wtf", "cool"], "likes": 0, "viewed": 137, "published": "Public", "date": "1462997759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 100\n#define MAX_DIST 20.0\n#define EPSILON 0.001\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p)\n{\n    float d = sdSphere(p, 10.);\n    d = max(d, -sdSphere(p, 10.));\n    \n\treturn d; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 camera = vec3(0., 0., sin(iTime * 3.));\n    vec3 target = vec3(sin(iTime), cos(iTime), 0.);\n    vec3 up = vec3(0., 1., 0.);\n    \n    vec3 cameraDir = normalize(target - camera);\n    vec3 cameraRight = cross(up, cameraDir);\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    float totalDist = 0.0;\n    vec3 pos = camera;\n    float dist = EPSILON;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n    \t\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n        \n        dist = map(pos);\n        totalDist += dist;\n        pos += dist * ray;\n        \n    }\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (dist < EPSILON)\n    {\n        \n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            map(pos + eps.yxx) - map(pos - eps.yxx),\n            map(pos + eps.xyx) - map(pos - eps.xyx),\n            map(pos + eps.xxy) - map(pos - eps.xxy)));\n        \n        color = vec3(1.0, 1.0, 1.0) * step(0.5, max(0.0, length(cross(ray, normal))));\n    }\n    \n    fragColor = vec4(color, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 101, 101, 125], [127, 127, 146, 146, 232], [234, 234, 291, 291, 1574]], "test": "valid"}
{"id": "ldVXRW", "name": "Spongebob Squarepants", "author": "zackpudil", "description": "Inspired by [Inigo's Mike](https://www.shadertoy.com/view/MsXGWr). ", "tags": ["raymarching", "distancefields", "character"], "likes": 15, "viewed": 366, "published": "Public", "date": "1463273980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n    return fract(sin(n)*4358.5453);\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    \n    return mix(\n        mix(\n            mix(hash(n + 000.0), hash(n + 001.0), f.x),\n            mix(hash(n + 057.0), hash(n + 058.0), f.x),\n            f.y),\n        mix(\n            mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 170.0), hash(n + 171.0), f.x),\n            f.y),\n        f.z);\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nfloat len(vec3 p, float l) {\n    p = pow(abs(p), vec3(l));\n    return pow(p.x + p.y + p.z, 1.0/l);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat dBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec2 dSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return vec2(length(pa - ba*h), h);\n}\n\nvec2 dSegment15(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return vec2(len(pa - ba*h, 15.0), h);\n}\n\nvec2 dSpongeBob(vec3 p) {\n    float res = 0.0;\n    // body\n    float b = dBox(p - vec3(0, 0.5, 0), vec3(1.0, 1.5, .5)/2.0) - 0.02;\n    b += 0.02*smoothstep(0.4, 1.0, noise(10.0*p))*smoothstep(0.1, 0.11, p.y);\n    b -= 0.75*smoothstep(0.2, 1.0, p.y)*smoothstep(-0.13, -0.12, -p.y);\n    \n    // belt\n    vec3 q = p;\n    q.y *= 18.0;\n    q.z *= 1.9;\n    float e = len(q + vec3(0, 2.3, 0), 15.0) - 0.54;\n    b = min(b, e);\n    \n    // tie\n    q = p;\n    q.x *= 0.4;\n    vec2 s = dSegment15(q + vec3(0, -0.09, -0.28), vec3(0, -0.23, 0), vec3(0));\n    float r = 0.04 - 0.02*smoothstep(0.5, 0.8, s.y) - 0.04*(1.0 - s.y);\n    if(s.x - r < b) res = 1.0;\n    b = min(b, s.x - r);\n    \n    // collar\n    p.x = -abs(p.x);\n    q = p;\n    s = dSegment15(q + vec3(0, -0.09, -0.25), vec3(0), vec3(-0.15, 0, 0));\n    r = 0.01 + 0.045*s.y*smoothstep(-0.2, -0.0, -q.y);\n    if(s.x - r < b) res = 0.0;\n    b = smin(b, s.x - r, 70.0);\n    \n    // arms\n    q = p;\n    rotate(q.xy, 0.4*q.y);\n    s = dSegment(q + vec3(0.63, -0.3, 0.0), vec3(0., -0.5, 0), vec3(0.05, 0, 0));\n    r = 0.034 + 0.05*smoothstep(0.85, 0.88, s.y) + 0.015*smoothstep(-0.1, 0.0, -s.y);\n    if(s.x - r < b) res = 0.0;\n    b = min(b, s.x - r);\n    \n    // hands\n    q = p;\n    q.z *= 1.9;\n    q += vec3(0.61, 0.26, 0.0);\n    q.x *= 2.7;\n    e = length(q) - 0.08;\n    if(e < b) res = 0.0;\n    b = smin(b, e, 100.0);\n    \n    // fingers\n    q = p;\n    q += vec3(0.61, 0.26, 0.0);\n    q = q.zyx;\n    float f = 100.0;\n    s = dSegment(q, vec3(0, -0.01, 0.04), vec3(0, -0.08, 0.07));\n    r = 0.01;\n    rotate(q.xy, 0.3*smoothstep(0.12, 0.17, -q.y));\n    f = min(f, s.x - r);\n    s = dSegment(q, vec3(0, -0.07, -0.02), vec3(0, -0.16, -0.04));\n    f = min(f, s.x - r);\n    s = dSegment(q, vec3(0, -0.07, -0.0), vec3(0, -0.16, -0.0));\n    f = min(f, s.x - r);\n    s = dSegment(q, vec3(0, -0.07, 0.02), vec3(0, -0.16, 0.04));\n    f = min(f, s.x - r);\n    \n    b = smin(f, b, 60.0);\n    \n    // legs\n    s = dSegment(p + vec3(0.25, 0.3, 0.0), vec3(0), vec3(0, -0.65, 0));\n    r = 0.05;\n    r -= 0.02*smoothstep(0.2, 0.21, s.y);\n    r += 0.015*smoothstep(0.7, 0.715, s.y);\n    if(s.x - r < b) res = 0.0;\n    b = min(b, (s.x) - r); \n    \n    // shoes\n    q = p;\n    q.y *= 1.0 + 0.05*smoothstep(0.05, 0.2, p.z);\n    q.z *= 0.6;\n    e = length(q + vec3(0.25, 0.98, -0.05)) - 0.08;\n    if(s.x - r < b) res = 0.0;\n    b = smin(b, e, 60.0);\n    \n    // nose\n    q = p;\n    rotate(q.zy, -0.25*p.z*p.z);\n    s = dSegment(q + vec3(0.0, -0.6, 0.0), vec3(0), vec3(0.0, 0.0, .6));\n    b = min(b, s.x - 0.035);\n    \n    // eyes\n    q = p;\n    q.y *= 0.75;\n    q.z *= 1.5;\n    q += vec3(0.15, -0.6, -0.3);\n    e = length(q) - 0.2 - 0.02*smoothstep(0.56, 0.58, p.y - 0.39);\n    if(e < b) res = 2.0;\n    b = min(b, e);\n    e = length(q + vec3(0, 0, -0.14)) - 0.07;\n    if(e < b) res = 3.0;\n    b = min(b, e);\n    \n    // mouth\n    q = p;\n    rotate(q.xy, 0.45*q.z);\n    s = dSegment(q + vec3(0, -0.4, -0.27), vec3(-0.25, 0.0, 0.0), vec3(0.2, 0.0, 0.0));\n    r =  0.03 - 0.02*smoothstep(0.0, 0.1, s.y);\n    if(s.x - r < b) res = 1.0;\n    b = min(b, s.x - r);\n    \n    // teeth\n    e = dBox(p + vec3(0.042, -0.36, -0.27), vec3(0.03, 0.05, 0.01));\n    if(e < b) res = 2.0;\n    b = min(b, e);\n    \n    return vec2(b, res); \n}\n\nvec2 map(vec3 p) {\n    vec2 g = vec2(p.y + 1.0, -2.0);\n    vec2 sb = dSpongeBob(p);\n        return g.x < sb.x ? g : sb;\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float m = -4.0;\n    \n    for(int i = 0; i < 150; i++) {\n        vec2 h = map(ro + rd*t);\n        if(abs(h.x) < 0.0001 || t >= 10.0) break;\n        t += h.x*0.5;\n        m = h.y;\n    }\n    \n    return vec2(t, m);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n    );\n    return normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    float res = 1.0;\n    float t = 0.002;\n    \n    for(int i = 0; i < 200; i++) {\n        float h = map(p + l*t).x;\n        if(abs(h) < 0.00 || t >= 6.0) break;\n        t += h;\n        res = min(res, 16.0*h/t);\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float s = 0.004;\n    float t = s;\n    \n    float o = 0.0;\n    float w = 1.0;\n    \n    for(int i = 0; i < 10; i++) {\n        float h = map(p + n*t).x;\n        \n        o += (t - h)*w;\n        w *= 0.95;\n        \n        t += s;\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n    vec3 ww = normalize(lat - eye);\n    vec3 vv = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 uu = normalize(cross(ww, vv));\n    \n    return mat3(vv, uu, ww);\n}\n\nvec3 material(vec3 p, float m) {\n    vec3 mat = vec3(2.000,1.938,0.129);\n    \n    if(p.y < -0.86) {\n        mat = vec3(0.2);\n    } else if(p.y < -0.75) {\n        mat = mix(vec3(2.0, 0.0, 0.0), vec3(2.0), 1.0 - smoothstep(-0.79, -0.78, p.y));\n    } else if(p.y >= -0.45 && p.y < -0.15 && abs(p.x) < 0.55) {\n        mat = vec3(1.0, 0.2, 0.0);\n    } else if(p.y >= -0.17 && p.y < -0.095 && abs(p.x) < 0.55) {\n        mat = vec3(0.1);\n        float a = atan(p.z, p.x);\n        a = mod(a, 0.4);\n        mat = mix(mat, vec3(1.0, 0.2, 0.0), smoothstep(0.1, 0.101, a));\n    } else if(p.y >= -0.095 && p.y < 0.12 && abs(p.x) < 0.55) {\n        mat = vec3(2.0);\n        if(m == 1.0) mat = vec3(2.0, 0.0, 0.0);\n    } else if(p.y > 0.3 && p.y < 0.48 && abs(p.x) > 0.5 && abs(p.z) < 0.08) {\n        mat = vec3(2.0);\n    } else if(m == 2.0 && p.y < 0.96) {\n        mat = vec3(2.0);\n    } else if(m == 3.0) {\n        p.x = -abs(p.x) + 0.15;\n        p.y -=  0.8;\n        mat = mix(vec3(0.3, 0.5, 1.0), vec3(0.2), 1.0 - smoothstep(0.0, 0.001, length(p.xy) - 0.02));\n    }\n    \n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = -1.0 + 2.0*(fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.20, 0.34, 0.70);\n    \n    float an = iTime*0.5;\n    \n    vec3 ro = 2.5*vec3(cos(an), .9/3.0, -sin(-1.0));\n    vec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 1.97));\n    \n    vec2 i = march(ro, rd);\n    \n    if(i.x < 10.0) {\n        vec3 pos = ro + rd*i.x;\n        vec3 nor = normal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        vec3 sli = normalize(vec3(0.8, 0.7, 0.6));\n        vec3 gli = normalize(vec3(0.0, -0.7, 0.0));\n        vec3 bli = vec3(-sli.x, sli.y, -sli.z);\n\n        float amb = clamp(0.5 + 0.5*nor.y, 0.0, 1.0);\n        float gif = clamp(dot(gli, nor), 0.0, 1.0);\n        float sif = clamp(dot(sli, nor), 0.0, 1.0);\n        float bac = clamp(0.3 + 0.7*dot(bli, nor), 0.0, 1.0);\n        float spe = pow(clamp(dot(sli, ref), 0.0, 1.0), 8.0);\n        float fre = pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0);\n\n        float sha = shadow(pos, sli);\n        float occ = ao(pos, nor);\n\n        col  = 0.2*amb*vec3(0.20, 0.34, 0.70);\n        col += 0.3*gif*vec3(1.00, 1.00, 1.00)*sha;\n        col += 0.7*sif*vec3(1.00, 0.97, 0.85)*sha;\n        col += 0.1*bac*vec3(1.00, 0.97, 0.85);\n\n        if(pos.y > -0.99) {\n            col *= material(pos, i.y);\n        } else {\n            col *= vec3(0.8, 0.8, 0.5);\n        }\n\n        col += 0.4*spe*vec3(1.00, 0.97, 0.85)*sif*sha;\n        col += 0.2*fre*vec3(1.00, 1.00, 1.00);\n\n        col *= vec3(occ);\n    }\n    \n    col = pow(col, vec3(.454545));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 59], [61, 61, 82, 82, 525], [527, 527, 563, 563, 643], [645, 645, 673, 673, 745], [747, 747, 786, 786, 851], [853, 853, 881, 881, 976], [978, 978, 1017, 1017, 1166], [1168, 1168, 1209, 1209, 1361], [1363, 1363, 1388, 1388, 4607], [4609, 4609, 4627, 4627, 4730], [4732, 4732, 4762, 4762, 4999], [5001, 5001, 5022, 5022, 5240], [5242, 5242, 5272, 5272, 5529], [5531, 5531, 5557, 5557, 5838], [5840, 5840, 5873, 5873, 6036], [6038, 6038, 6070, 6070, 7114], [7116, 7116, 7173, 7173, 8741]], "test": "valid"}
{"id": "ldVXz1", "name": "Fractal Gradient", "author": "innovati", "description": "animated fractal gradients", "tags": ["fractal", "gradient"], "likes": 0, "viewed": 86, "published": "Public", "date": "1463006560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = fract(radians(reflect(reflect(vec4((0.1 / reflect(1.4, (gl_FragCoord.y / iResolution.y))), 1.3, (gl_FragCoord.y / iResolution.y), ((gl_FragCoord.x / iResolution.x) / inversesqrt(exp2(iTime)))), mod(vec4((1.1 - 1.8), 0.4, 1.9, (atan((1.6 + 1.3), 0.9) / ((0.1 / ((1.1 - 1.1) / 0.9)) - 1.1))), pow(vec4(0.5, (gl_FragCoord.y / iResolution.y), 1.2, 1.9), vec4(1.4, ((gl_FragCoord.x / iResolution.x) * 1.4), 0.2, 0.2)))), vec4(0.3, 0.3, 0.8, step(0.2, 0.4)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 526]], "test": "error"}
{"id": "ldy3zt", "name": "Social Commentary on Pie Charts", "author": "gnalvesteffer", "description": "Quite possibly the best thing you've ever seen.", "tags": ["trippy"], "likes": 0, "viewed": 136, "published": "Public", "date": "1463557554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distance(float x1, float y1, float x2, float y2)\n{\n    float x = x2 - x1;\n    float y = y2 - y1;    \n    return sqrt(x * x + y * y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timeScale = tan(log(iTime) / 100.0) * 0.15;\n    float drawScale = tan(cos(iTime * timeScale + log(iTime))) * timeScale;\n    float amplitude = (iTime * timeScale) * drawScale;\n    float dist = distance(fragCoord.x, fragCoord.y, iResolution.x / 2.0, iResolution.y / 2.0);\n    float value;\n    if(distance(fragCoord.x, fragCoord.y, iResolution.x / 2.0, iResolution.y / 2.0) < 300.0 + (tan(iTime)) * dist)\n    {\n        value = asin(fragCoord.x * fragCoord.y * drawScale);    \n        fragColor = vec4(fragColor.b + fragColor.r + iTime, fragColor.g, fragColor.b * tan(value * amplitude), 1.0);\n        if(fragColor.r < value)\n        {\n            fragColor = vec4(distance(fragCoord.x, fragCoord.y, 0.0, 0.0) / iResolution.x, fragColor.r, fragColor.g, 1);\n        }    \n        else\n        {\n            value = tan(fragCoord.x + iTime + fragColor.r * drawScale);\n            fragColor = vec4(value * amplitude, sin(iTime * 10.0), value * amplitude, 0.5) * tan(iTime);             \n        } \n    }    \n    else\n    {\n        value = sin(tan(fragCoord.y + fragCoord.x * drawScale));\n        fragColor = vec4(fragColor.g * cos(value), sin(amplitude), sin(value), 1.0) * log(value) + 0.5;        \n    }\n    fragColor *= (dist * tan(fragColor.r) + sin(fragColor.g)) * sin(iTime + amplitude);  \n    fragColor = vec4(fragColor.g, fragColor.r, fragColor.b, 1.0);\n    if(fragCoord.x > iResolution.x / 2.0)\n    {\n        fragColor *= tan(iTime) * -1.0;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldy3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 140], [142, 142, 199, 199, 1660]], "test": "valid"}
{"id": "ldySRR", "name": "I can't feel anything", "author": "lainga", "description": "places to go and ways to grow a reading rainbow", "tags": ["plasma", "hsv"], "likes": 2, "viewed": 126, "published": "Public", "date": "1462388399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535;\n\nfloat t = iTime * 2.;\nfloat scale = 2.;\n\n//stolen and modified from las @ pouet.net\nvec3 hsv(in float h, in float s, in float v, in vec3 p){\n    return mix(\tvec3(1.),\n               \tclamp(\t(abs(fract(h+(p/3.))*6.-3.)-1.),\n                   \t\t0.,\n                   \t\t1.),\n            \ts)\n    \t*v;\n}\n\nvec3 palette(){\n    float r = cos(t) + 2.;\n    float g = 0.;\n    float b = cos((t + PI)*.25) + 2.;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1. + 2.*(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y*.5+.5;\n    uv *= scale;\n    \n    float a = .5;\n    float b = .4;\n    \n    vec2 point = vec2(cos(t*a + PI/2.), sin(t*b))*4.;\n    \n    float cola = cos(distance(uv, point));\n                     \n    float colb = cos(distance(uv + t*1., vec2(0.)));\n    \n    float colc = cos(uv.x + t*.5);\n    \n\tfragColor = vec4(hsv((cola + colb + colc)/3., 1., 1., palette()) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldySRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 116, 172, 172, 332], [334, 334, 349, 349, 458], [460, 460, 517, 517, 977]], "test": "valid"}
{"id": "ldyXWw", "name": "escher-like 2", "author": "FabriceNeyret2", "description": "reproducing [url]https://twitter.com/CPriestman/status/684874950944100352/photo/1[/url]", "tags": ["2d", "gif", "short", "copies", "reproductions", "escherlike"], "likes": 60, "viewed": 1371, "published": "Public API", "date": "1464726757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reproducing https://twitter.com/CPriestman/status/684874950944100352/photo/1\n\n#define R(t) mat2(c=cos(t),s=sin(t),-s,c)                      // R(1.25) = tilted grid\n\nfloat t, c,s, k=sqrt(10.); \nvec2 R, u;\n\nvec4 C(vec2 U, float m) {\n    U += m*vec2(1,2);                                   // white (m=0) or black (m=1) grid\n    u = floor( R(1.25)*U/k +.5);                                           // tilted grid\n    t = clamp( mod( iTime -u.y-.3*u.x+ 3.*m, 6.) -4., 0.,1.) *1.57;  // rotates ?\n    if (m>0.) t=-t;                                                        // if black\n    u = R(-1.25)*u*k;\n    \n  //U = floor(R(t)*(U-u)+.5);                                              // cross frame\n  //return vec4((U.x==0.||U.y==0.)&&abs(U.x)<2.&&abs(U.y)<2.);             // cross shape\n                                                       // antialiased version :\n    U = abs( R(t)*(U-u) );                                                 // cross frame\n    return vec4(smoothstep(.55, .45, max(min(U.x,U.y),max(U.x,U.y)-1.) )); // cross shape\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O -= O; R = iResolution.xy;\n\tU =  15.* (U-R/2.)/ R.y; \n    \n    if (abs(U.x) < 7.5)  {\n        U += 3.;   O =    C(U, 0.);                 // for white rotating wave\n        if (t==0.) O = 1.-C(U, 1.);                 // for black rotating wave\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// -------------- drafts ------------------ \n\n\n/** \n\n#define R(t) mat2(cos(t),sin(t),-sin(t),cos(t))    // R(-1.25) = tilted grid\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float t, T = iTime/1.5708, k=sqrt(10.), o = 0.; \n    vec2 R = iResolution.xy, u;\n\tU =  15.* (U-R/2.)/ R.y; \n    if (abs(U.x)>7.5) { O-=O; return; }\n    U += 3.;\n\n    u = floor(R(1.25)*U/k+.5);\n    t = clamp(mod(T,8.)-4.-u.y-.3*u.x,0.,1.)*1.5708; \n\n    if (t==0.) { \n        o=1.;\n        U += vec2(1,2);\n        u = floor(R(1.25)*U/k+.5);\n        t = -clamp(mod(T+4.,8.)-4.-u.y-.3*u.x,0.,1.)*1.5708; \n    }\n   \n    u = R(-1.25)*u*k;\n    \n   \n    U = floor(R(t)*(U-u)+.5);\n    O = vec4((U.x==0.||U.y==0.)&&abs(U.x)<2.&&abs(U.y)<2.);\n    O = o>0. ? 1.-O : O;\n}\n\n/**/    \n\n\n/**\n\n#define M(s) mat2(1,s,-s,1)/sqrt(10.)\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float t = iTime, c=cos(t),s=sin(t), l=sqrt(.9),k=sqrt(10.),\n          o = 0.; // floor(mod(t/1.5708,2.));\n    vec2 u, R = iResolution.xy;\n\tU =  15.* (U-R/2.)/ R.y; \n    if (abs(U.x)>7.5) { O-=O; return; }\n    U += 3.+ vec2(o,o+o);\n\t//U *=  15./ iResolution.y;\n    u = M(3)*U;\n    u = floor(u/k+.5);\n    //u = floor(u/3.*l+.5)*3./l;\n    //if (u.y != floor(mod(t/1.5708,8.)-4.)) c=1.,s=0.;\n    t = clamp(mod(t/1.5708,8.)-4.-u.y-.3*u.x,0.,1.)*1.5708; c=cos(t),s=sin(t);\n    //if (u*l/3.!=vec2(0)) c=1.,s=0.;\n    //if (mod(u*l/3.,3.)!=vec2(0)) c=1.,s=0.;\n    //O  = vec4(mod(u*l/3.,3.)/3.,0,0); return;\n    u = M(-3)*u*k;\n    U -= u;\n    //O = vec4(length(U)<1.5);\n    // O  = vec4(mod(u,3.)/3.,0,0); return;\n    \n    U = floor(mat2(c,s,-s,c)*U+.5);\n    O = vec4((U.x==0.||U.y==0.)&&abs(U.x)<2.&&abs(U.y)<2.);\n    O = o>0. ? 1.-O : O;\n}\n    \n/**/\n\n\n\n\n/**\n#define M(s) mat2(1,s,-s,1)/sqrt(10.)\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float t = iTime, c=cos(t),s=sin(t), l=sqrt(.9),\n          o = 0.; // floor(mod(t/1.5708,2.));\n    vec2 u, R = iResolution.xy;\n\tU =  15.* (U-R/2.)/ R.y + vec2(o,o+o);\n\t//U *=  15./ iResolution.y;\n    u = M(3)*U;\n    u = floor(u/3.*l+.5)*3./l;\n    u = M(-3)*u;\n    //O = vec4(length(U-u)<1.5);\n    \n    U = floor(mat2(c,s,-s,c)*(U-u)+.5);\n    O = vec4((U.x==0.||U.y==0.)&&abs(U.x)<2.&&abs(U.y)<2.);\n    O = o>0. ? 1.-O : O;\n}\n    \n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 235, 235, 1054], [1056, 1056, 1095, 1095, 1352]], "test": "valid"}
{"id": "ldyXWz", "name": "Diamond HSV2RGB", "author": "MichaelPohoreski", "description": "HSL to recolor texture demo.  Click and Drag the mouse:\n* up/down to change the saturation (bottom = 0%, top = 100%)\n* left/right to change the lightness (left = 0%, right = 100%)\nVersion 1 = HSV, Version 2 = HSL", "tags": ["procedural", "diamond", "hsv"], "likes": 3, "viewed": 309, "published": "Public", "date": "1463759947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Demo by Michael Pohoreski aka mysticreddit\n// Reddit Thread: \n// * https://www.reddit.com/r/gamedev/comments/4k8l33/using_an_hsl_shader_to_recolor_textures/\n\n// 1 == HSV\n// 2 == HSL\n#define VERSION 2\n\n\n// Original\nvec3 hsl2rgb(vec3 HSL)\n{\n   float R = abs(HSL.x * 6.0 - 3.0) - 1.0;\n   float G = 2.0 - abs(HSL.x * 6.0 - 2.0);\n   float B = 2.0 - abs(HSL.x * 6.0 - 4.0);\n   vec3 RGB = clamp(vec3(R,G,B), 0.0, 1.0);\n   float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n   return (RGB - 0.5) * C + HSL.z;\n}\n\n// References:\n// * http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// * http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n// Optimized by Michael Pohoreski\nvec3 hsv2rgb( vec3 c )\n{\n    vec3 K = vec3(3,2,1) / 3.0;\n    vec3 p = abs(fract(c.rrr + K.rgb) * 6.0 - vec3(3));\n    return c.b * mix(K.rrr, clamp(p - K.rrr, 0.0, 1.0), c.g);\n}\n\n// no texture, so simulate one\n// /\\\n// \\/\nvec4 diamond( vec2 uv )\n{\n#if VERSION == 1\n    // Ideally,\n    // R = Saturation\n    // A = lightness (outside = 0, inside = 0.5 to 1.0) \n\n    vec2  p = uv*2.0 - 1.0; // remap [0,1] -> [-1,+1]\n    float d =      abs(p.x)+abs(p.y); // diamond shape\n    float curvature  = d*16.0;\n    float a = 1.0-(abs(p.x)*abs(p.y)*curvature); // simple alpha fade\n    bool  inside     = (d < 1.0);\n    float g          = inside ? 1.0 : 0.0; // in or out\n    //return vec4(       vec3(g), d ); // flat  , hard-diamond\n    //return vec4( 1.0 - vec3(d), d ); // smooth, hard-diamond\n    if( !inside ) return vec4(0.); // force to black if outside diamond\n    return vec4(       vec3(a), g ); // smooth, 1/x\n#endif\n    \n#if VERSION == 2\n    // sphere\n    vec2  p      = uv*2.0 - 1.0; // remap [0,1] -> [-1,+1]\n    float d      = dot(p,p);\n    float dist   = smoothstep( 0.2, 0.8, d );\n    bool  inside = (dist < 1.0); \n    float lit  = inside ? 1. - dist : 0.0;\n\n\n    // mix with diamond\n#if 1\n    float g      = abs(p.x) + abs(p.y);\n    float grid   = g;\n    lit *= (1.0 - (grid*2.0)/2.0); // OR: lit *= 1.0 - clamp( 0.0, 1.0, grid );    \n#endif\n\n    vec4 color =       vec4( 1.0, 0.0, 0.0, lit  ); // outside=white, edge=pure     pure .. center=black\n//  vec4 color = 1.0 - vec4( 0.0, 0.0, 0.0, lit  ); // outside=white, edge=white .. pure .. center=black \n//  vec4 color =       vec4( 1.0, 0.0, 0.0, grid ); // outside=white, edge=color .. pur  .. center=black\n//  vec4 color = 1.0 - vec4( 0.0, 0.0, 0.0, grid ); // outside=color, edge=black .. pure .. center=white \n    return color;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m  = iMouse.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = diamond( uv ); // or texture( iChannel0, uv );\n    \n    float duration = 10.0;\n    float u_Hue    = fract( iTime / duration );\n\n    if( iMouse.z < 0.1 ) // if mouse left button not down default to nice saturation\n        m = vec2( 1.0, 0.75 ); // default to top-right mouse position\n    \n#if VERSION == 1\n    float u_Sat    = m.y;\n    float u_Light  = color.r + color.r*m.x; // HACK! // 0.5 + m.x; // color.r*m.x;\n    float u_Alpha  = color.a;\n#else\n    float u_Sat    = color.r * m.y;\n    float u_Light  = color.a * m.x;\n    float u_Apha   = color.a;\n#endif\n\n// Original    \n//   gl_FragColor = texture(u_TextureUnit, v_TextureCoordinates);\n//   vec3 rgb = hsl2rgb(vec3(u_Hue / 360.0, u_Sat / 100.0, gl_FragColor.x + gl_FragColor.x * u_Light / 100.0));\n//   gl_FragColor = vec4(rgb.r, rgb.g, rgb.b, gl_FragColor.a * u_Alpha / 100.0);\n    \n    // Fixed\n#if VERSION == 1\n    vec3 rgb = hsv2rgb( vec3( u_Hue, u_Sat, u_Light ));\n#else\n    vec3 rgb = hsl2rgb( vec3( u_Hue, u_Sat, u_Light ));\n#endif\n    fragColor = vec4( rgb, 1. );\n\n    // Debug 1 HSL\n    //fragColor.rgb = hsl2rgb( vec3( u_Hue, m.y, m.x ) ); // Verified\n    // Debug 2 HSV\n    //fragColor.rgb = hsv2rgb( vec3( u_Hue, m.y, m.x ) ); // Verified\n    // Debug 3 Diamond \"Texture\" \n    //fragColor = color;\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 217, 241, 241, 504], [506, 715, 739, 739, 891], [893, 936, 961, 961, 2513], [2515, 2515, 2572, 2572, 3944]], "test": "valid"}
{"id": "ldyXz1", "name": "EuropeanCobblestoneTiles", "author": "kuvkar", "description": "Fan-shaped european cobblestone tiles. ", "tags": ["procedural", "texture", "tiles"], "likes": 12, "viewed": 331, "published": "Public", "date": "1462910809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reference : http://www.pavingexpert.com/setts01.htm\n// the \"formula\" is there at the end :)\n\nfloat fan(vec2 uv)\n{\n    uv *= 1.002;\n    float l = (length(uv) - 0.5);\n    vec2 corner = sign(vec2(uv.x, -abs(uv.y))) * vec2(0.5, 0.25);\n    float x = max(0.5 - length (uv - corner), .0);\n    x = smoothstep(0.0, 0.001, x);\n    l = smoothstep(0.0, 0.001, l);\n    l = max(l, x);\n    return 1.0 - clamp(l, 0.0, 1.0);\n}\n\nvec4 texProceduralTiles(vec2 uv)\n{\n    // these variables can be tweaked\n    float floors = 8.0; \n    float width = 1.2;\n    //\n    \n    float yblock = floor(uv.y * floors);\n    float y = mod(uv.y, 1.0 / floors) * floors;\n    \n    vec4 color = vec4(.9, 0.5, 0.25, 0.0);\n\n    float x = mod(uv.x * (2.0 + (yblock * width)), width) / width;\n    float xblock = mod( floor(uv.x * (2.0 + yblock * width) / width), 4.0);\n    \n    if(xblock == 1.0) color = vec4(1.0, 0.52, .2, 0.0);\n    else if(xblock == 2.0) color = vec4(1.0, 0.57, .2, 0.0);\n    else if(xblock == 3.0) color = vec4(1.0, 0.5, .2, 0.0);\n    \n    if (yblock == floors / 2. - 1.) color = vec4(0.9, 0.4, 0.4, 0.0);\n    \n    x = abs(x - 0.5);\n    y = abs(y - 0.5);\n    \n    return color * mix(1.0, 1.0 - smoothstep(0.4, .5, max(x, y)), 0.3);\n}\n\nvec4 getTexture(vec2 uv)\n{\n    uv = vec2(atan(uv.y, uv.x  ), length(uv));\n\treturn texProceduralTiles(uv);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    uv *= 5.5 + sin(iTime * 0.2) * 0.7;\n    vec4 color = vec4(0.0);\n    \n    vec2 uvmod = vec2(1., 0.5);\n    for (int i = 0; i < 2; ++i)\n    {\n        vec2 _uv = uv + float(i) * uvmod * 0.5;\n        _uv = (mod(_uv, uvmod) / uvmod) * uvmod;\n        _uv -= vec2(0.5, .0);\n        \n\t    vec4 c = vec4(fan(_uv));\n        c.rgb *= getTexture(_uv).rgb;\n        color += c;\n    }\n    color = clamp(color, 0.0, 1.0);\n    fragColor = mix(vec4(.7, .6, .5, .0), color, step(1.0 - color.a, 0.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 116, 116, 412], [414, 414, 448, 486, 1212], [1214, 1214, 1240, 1240, 1325], [1327, 1327, 1384, 1384, 1976]], "test": "valid"}
{"id": "lscSDl", "name": "G-Lectric Sheep 3", "author": "vox", "description": "G-Lectric Sheep 3", "tags": ["glectricsheepelectric3"], "likes": 0, "viewed": 518, "published": "Public API", "date": "1462089253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(uv*2.0-1.0)*1.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 fbdim = vec2(851.0, 315.0); //Facebook cover photo dimensions.\n    vec2 fbdim = iResolution.xy;\n    float fbaspect = fbdim.y/fbdim.x;\n   \n    vec2 uv = fragCoord.xy-iResolution.xy/2.0;\n    \n    if(abs(uv.x) > fbdim.x/2.0 || abs(uv.y) > fbdim.y/2.0)\n        discard;\n    \n    float zoom = (3.0+2.0*sin(time))*PI;\n    \n    uv = uv.xy / (iResolution.xy/2.0-fbdim.xy);\n    uv.x *= fbaspect;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    \n   \tconst int max_i = 8;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float sum = 0.0;\n    float magnification;\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/fbdim, magnification);\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(0.0, 1.0, ifs);\n        \n        ifs *= sqrt(1.0/(1.0+magnification));\n        \n        noise = min(noise, ifs);\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        sum += (pow(clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0), .5))*noise;\n        \n\t\tif(ifs == 0.0)\n            break;\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //sum /= float(max_i);\n    float shift = time;\n\n    vec3 final = (\n        \t\t\t\tvec3(saw(sum*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+sum*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+sum*PI*2.0+shift)\n                 \t\t)\n        \t\t )*smoothstep(0.0, .75, saw(sum*PI*5.0+time*5.0))+ifs;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 314, 314, 384], [386, 386, 415, 415, 499], [565, 565, 587, 587, 825], [827, 827, 846, 846, 891], [893, 893, 952, 952, 1525], [1527, 1527, 1584, 1658, 3215]], "test": "valid"}
{"id": "lscXWs", "name": "G-Lectric Sheep 4", "author": "vox", "description": "G-Lectric Sheep 4", "tags": ["glectricsheepelectric4fractalflames"], "likes": 3, "viewed": 556, "published": "Public API", "date": "1462127086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(uv*2.0-1.0)*1.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 fbdim = vec2(851.0, 315.0); //Facebook cover photo dimensions.\n    vec2 fbdim = iResolution.xy;\n    float fbaspect = fbdim.y/fbdim.x;\n   \n    vec2 uv = fragCoord.xy-iResolution.xy/2.0;\n    \n    if(abs(uv.x) > fbdim.x/2.0 || abs(uv.y) > fbdim.y/2.0)\n        discard;\n    \n    float zoom = (3.0+2.0*sin(time))*PI;\n    \n    uv = uv.xy / (iResolution.xy/2.0-fbdim.xy);\n    uv.x *= fbaspect;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    \n   \tconst int max_i = 8;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float sum = 0.0;\n    float magnification;\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/fbdim, magnification);\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(0.0, 1.0, ifs);\n        \n        ifs *= sqrt(1.0/(1.0+magnification));\n        \n        noise = min(noise, ifs);\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        sum += (pow(clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0), .5))*noise;\n        \n\t\tif(ifs == 0.0)\n            break;\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //sum /= float(max_i);\n    float shift = time;\n\n    vec3 final = (\n        \t\t\t\tvec3(saw(sum*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+sum*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+sum*PI*2.0+shift)\n                 \t\t)\n        \t\t )*smoothstep(0.0, .75, saw(sum*PI*5.0+time*5.0))+ifs;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 383, 412, 412, 482], [484, 484, 513, 513, 597], [663, 663, 685, 685, 923], [925, 925, 944, 944, 989], [991, 991, 1050, 1050, 1623], [1625, 1625, 1682, 1756, 3313]], "test": "valid"}
{"id": "lsdXWs", "name": "Phong-blinn shader model", "author": "oboforty", "description": "opengl3 like environment, based on this example: https://www.shadertoy.com/view/4sG3W1", "tags": ["phong", "sphere", "specular", "shader", "diffuse", "blinn"], "likes": 2, "viewed": 273, "published": "Public", "date": "1462289462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.raywenderlich.com/70208/opengl-es-pixel-shaders-tutorial\n// all noise from iq\n\n#define time iTime*0.5\n\n\nvec3 planet(float radius, vec2 center, vec2 position, vec3 cLight)\n{\n    //gomb hack:\n    float z = sqrt(radius*radius - position.x*position.x - position.y*position.y);\n\tvec3 normal = normalize(vec3(position.x, position.y, z)); // for visualize->(normal+1.)/2.\n\n    \n    //PHONG-BLINN DIFFZ & SPEKULRIS MODEL:\n \tvec3 kd = vec3(0.2, 0.5, 0.2);\n    vec3 ks = vec3(1.0, 1.0, 1.0);\n    float shine = 100.0;\n\n    vec3 H = normalize(cLight + normal);\n    \n    float cosa = max(0.,dot(normal, cLight));\n    float cosd = max(0.,dot(normal, H));\n    \n    vec3 result = vec3(kd * cosa) + vec3(ks * pow(cosd, shine));\n    return result;\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif\t\t(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if\t(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse \t\t\t{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif\t\t(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if\t(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse \t\t\t{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    // SPHERE\n    vec2 center = iResolution.xy/2.0;\n    float radius = iResolution.y/3.0;\n    vec2 position = gl_FragCoord.xy - center;\n    \n    // light position\n    vec3 cLight = normalize(vec3(sin(time), 2.5*sin(time), cos(time)));\n        \n    vec3 colorat = planet(radius, center, position, cLight);\n    \n\tif(length(position) < radius)\n    {\n    \tfragColor = vec4(colorat, 1.);\n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 186, 203, 753], [755, 755, 778, 778, 859], [861, 861, 886, 886, 3022], [3025, 3025, 3082, 3082, 3525]], "test": "valid"}
{"id": "lsGSWh", "name": "Raymarching v1", "author": "Tandaradeii", "description": "First experiments with raymarching", "tags": ["raymarching", "beginner", "learning"], "likes": 1, "viewed": 120, "published": "Public", "date": "1464013975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 256\n#define MAXDISTANCE 100.0\n#define EPSILON 0.001\n#define LIGHT vec3(5.0, 10.0, 0.0)\n#define BACKGROUNDCOLOR vec4(0.0, 0.2, 0.4, 1.0)\n\nstruct Sphere\n{\n\tvec3 position;\n    float radius;\n};\n\nfloat mapSphere(in Sphere s, in vec3 p)\n{\n    return length(p - s.position) - s.radius;   \n}\n\nfloat mapBetweenSpheres(in Sphere s1, in Sphere s2, in vec3 p)\n{\n\treturn abs((length(p - s1.position) - s1.radius)-(length(p - s2.position) - s2.radius)) - 0.5;   \n}\n\nfloat map(in vec3 p)\n{\n    Sphere s1;\n    s1.position = vec3(4.0 * sin(iTime), 4.0 - 2.0 * cos(iTime * 0.5), 4.0);\n    s1.radius = 1.0;\n    Sphere s2;\n    s2.position = vec3(2.0 * sin(iTime), 2.0 + cos(iTime * 0.5), 5.0);\n    s2.radius = 1.0;\n\tfloat dToS1 = mapSphere(s1, p);\n    float dToS2 = mapSphere(s2, p);\n    float dToS = min(dToS1, dToS2);\n    //float dToS = min(dToS, dToS1)\n    return min(dToS, p.y - sin(p.x) * cos(p.z) * 0.4);\n}\n\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < MAXSTEPS-1; ++i){\n    \tvec3 p = ro + rd * t;\n        float d = map(p);\n        if(d < EPSILON || t >= MAXDISTANCE){\n        \tbreak;\n        }\n        t += d;\n    }\n    return t;\n\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float t = 0.0 + 100.0 * EPSILON;\n    float res = 1.0;\n    for(int i = 0; i < MAXSTEPS; ++i) {\n        float d = map(ro + rd * t);\n        if(d < EPSILON) {\n            return 0.0;\n        }\n        res = min( res, k*d/t );\n        t += d;\n    }\n    return res;\n    \n}\n\nfloat lerp(float a, float b, float w)\n{\n    return a * w + b * (1.0 - w);\n}\n\nvec3 lerpVec3(vec3 a, vec3 b, float w)\n{\n\treturn vec3(lerp(a.x, b.x, w),\n               lerp(a.y, b.y, w),\n               lerp(a.z, b.z, w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.xy = uv.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = BACKGROUNDCOLOR * ((uv.y + 1.0) / 2.0);\n    \n    vec3 ro = vec3(0.0, 2.0 + cos(iTime * 0.6), 3.0 * sin(iTime * 0.2));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float t = trace(ro, rd);\n    \n    vec3 p = ro + rd * t;\n    \n    if(t < MAXDISTANCE) {\n    \tvec3 lightDirection = normalize(LIGHT - p);\n        float dotProduct = dot(normal(p), lightDirection);\n        float ss = softShadow(p, lightDirection, 16.0);\n        fragColor = vec4(lerpVec3(vec3(BACKGROUNDCOLOR.xyz), \n                                  vec3(1.0), \n                                  t/MAXDISTANCE) \n                         * dotProduct * ss, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 249, 249, 300], [302, 302, 366, 366, 467], [469, 469, 491, 491, 909], [911, 911, 948, 948, 1171], [1173, 1173, 1199, 1199, 1408], [1410, 1410, 1461, 1461, 1733], [1735, 1735, 1774, 1774, 1810], [1812, 1812, 1852, 1852, 1955], [1958, 1958, 2015, 2015, 2799]], "test": "valid"}
{"id": "lsGSzR", "name": "Spherical Harmonics Ray Tracer", "author": "maldicion069", "description": "Ray tracer scene with Spherical Harmonics", "tags": ["raytracer", "sphericalharmonics"], "likes": 1, "viewed": 325, "published": "Public", "date": "1462399982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSAMPLES 64\n#define INFINITY 1000.0\n\n#define SA  // Comment this to disable Spherical Harmonics Irradiance\n#define MB // Comment this to disable Motion Blur\n\nfloat random(float seed) { \n    return fract(sin(seed++)*74532.563045); \n}\n\nhighp float rand(vec2 co) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt= dot(co.xy ,vec2(a,b));\n  highp float sn= mod(dt,3.1415926);\n  return fract(sin(sn) * c);\n}\n\nfloat pseudorandom(float u) {\n  float a = fract(sin(gl_FragCoord.x*12.9898*3758.5453));\n  float b = fract(sin(gl_FragCoord.x*63.7264*3758.5453));\n  return rand(gl_FragCoord.xy * mod(u * 4.5453,3.1415926));\n}\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Sphere {\n    vec3 center;\n    vec3 color;\n    float radius;\n    vec3 pos;\n    vec3 normal;\n};\n    \nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients sph_arm = SHCoefficients(\n  vec3( 1.630401,  1.197034,  1.113651),\n  vec3( 0.699675,  0.540300,  0.536132),\n  vec3(-0.354008, -0.287976, -0.268514),\n  vec3( 1.120136,  0.854082,  0.880019),\n  vec3( 1.012764,  0.783031,  0.812029),\n  vec3(-0.181137, -0.147510, -0.132195),\n  vec3(-0.589437, -0.434048, -0.452781),\n  vec3(-0.266943, -0.211540, -0.210316),\n  vec3( 0.868657,  0.665028,  0.655598)\n);\n\nconst SHCoefficients sph_arm2 = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\nconst SHCoefficients sph_arm3 = SHCoefficients(\n  vec3( 2.479083,  2.954692,  3.087378),\n  vec3( 1.378513,  1.757425,  2.212955),\n  vec3(-0.321538, -0.574806, -0.866179),\n  vec3( 1.431262,  1.181306,  0.620145),\n  vec3( 0.580104,  0.439953,  0.154851),\n  vec3(-0.446477, -0.688690, -0.986783),\n  vec3(-1.225432, -1.270607, -1.146588),\n  vec3( 0.274751,  0.234544,  0.111212),\n  vec3( 2.098766,  2.112738,  1.652628)\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = sph_arm2;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nfloat hitSphere(Sphere inSp, Ray r) {\n    vec3 oc = r.o - inSp.center;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(oc, r.d);\n    float c = dot(oc,oc) - inSp.radius*inSp.radius;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) {\n        return -1.0;}\n    else {\n        return (-b - sqrt(discriminant)) / (2.0 * a);\n    }\n}\n\n// Camera definition\nvec3 lowerLeft = vec3(-2.0, -1.0, -1.0);\nvec3 origin = vec3(0.0, 0.0, 0.0);\nvec3 horizontal = vec3(4.0, 0.0, 0.0);\nvec3 vertical = vec3(0.0, 2.0, 0.0);\n\nSphere spheres[2];\n\nfloat checkShadow(Ray ray) {\n    float h = INFINITY;\n    for (int i = 0; i < 2; i++) {\n        float t = hitSphere(spheres[i], ray);\n\n        if (t > 1.0 && t < h) {\n            return 0.3;\n        }\n\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 accumulator = vec3(0.0);\n    \n    spheres[0] =  Sphere(vec3(-0.5,0,sin(iTime * 2.0) - 2.0), vec3(1.0, 0.0, 0.0), 0.5, vec3(0,0,0), vec3(0,0,0));\n    spheres[1] =  Sphere(vec3(0.5,0,cos(iTime * 2.0) - 2.0), vec3(0.0, 1.0, 0.0), 0.5, vec3(0,0,0), vec3(0,0,0));\n\n    vec2 times = vec2(0.1, 0.2);\n    float seed = iTime;\n    \n    #ifdef MB\n        spheres[0].center += vec3(0.0, 0.0, -( times.x + ( times.y - times.x ) * ( pseudorandom(seed*14.53+1.6) ) ) );\n        spheres[1].center += vec3(0.0, 0.0, -( times.x + ( times.y - times.x ) * ( pseudorandom(seed*14.53+1.6) ) ) );\n    #endif\n    \n    for (int s = 0; s < MAXSAMPLES; s++) {\n        seed += float (s); \n        float u = (fragCoord.x + random(seed) * 2.0) / iResolution.x;\n        float v = (fragCoord.y + random(seed+1.0) * 2.0) / iResolution.y;\n        float h = INFINITY;\n        \n        Ray ray = Ray(origin,lowerLeft + horizontal * u + vertical * v);\n        \n        vec3 hitCol = vec3(1.0);\n        #ifdef SA\n            hitCol *= calcIrradiance(normalize(ray.d));\n        #endif\n        \n        for (int i = 0; i < 2; i++) {\n            float t = hitSphere(spheres[i], ray);\n\n            if (t > 0.0 && t < h) {\n                h = t;\n                \n                spheres[i].pos = ray.o + t * ray.d;\n                spheres[i].normal = normalize(spheres[i].pos - spheres[i].center);\n                \n                float occ = 0.5 + 0.5 * spheres[i].normal.y;\n                hitCol = spheres[i].color * occ;\n                #ifdef SA\n                    hitCol *= calcIrradiance(spheres[i].normal);\n                #endif\n            }\n\n        }\n        \n        // Check shadow\n        //hitCol *= checkShadow(ray);\n        \n        accumulator += hitCol;\n\n    }\n    \n    fragColor = vec4(vec3(accumulator)/float(MAXSAMPLES),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 194, 194, 242], [465, 465, 494, 494, 672], [2223, 2223, 2254, 2254, 2842], [2844, 2844, 2881, 2881, 3194], [3390, 3390, 3418, 3418, 3614], [3616, 3616, 3673, 3673, 5496]], "test": "valid"}
{"id": "lsGSzW", "name": "Spacefold", "author": "FreeFull", "description": "Experimenting with folding space. Note that the pattern evolves rather slowly at first.", "tags": ["2d", "fractal", "fold"], "likes": 17, "viewed": 348, "published": "Public", "date": "1463108812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tau = 8.0 * atan(1.0);\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n// http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t )\n{\n    vec3 a = vec3(0.5);\n    vec3 b= vec3(0.5);\n    vec3 c= vec3(1.0, 1.0, 0.5);\n    vec3 d= vec3(0.8, 0.9, 0.3);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    for(int i = 0; i < 32; i++) {\n        uv = abs(uv);\n        uv *= rot(iTime/30.0);\n        uv += -vec2(0.5,0.5);\n        uv *= 1.03;\n    }\n    uv = pow(abs(sin(uv)),vec2(0.3));\n    vec3 col = palette(uv.x*uv.y*1.9);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 59, 59, 143], [145, 205, 233, 233, 389], [391, 391, 448, 448, 795]], "test": "error"}
{"id": "lsGXR1", "name": "Punched Pi In The Sky", "author": "dr2", "description": "** PI **", "tags": ["pi", "punchcard"], "likes": 6, "viewed": 1009, "published": "Public API", "date": "1462806825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Punched Pi In The Sky\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Large window helps; mouse enabled.\n\nfloat PrRnd2BoxDf (vec3 p, vec3 b, float r);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Fbm2 (vec2 p);\n\nconst float pi = 3.14159;\n\nmat3 vuMat;\nvec3 ltDir;\nvec2 cSize;\nfloat dstFar, tCur;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  q = p.xzy;\n  d = PrRnd2BoxDf (q, vec3 (cSize.x - 0.1, 0.003, cSize.y - 0.1), 0.1);\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd = rd * vuMat;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (0.01 * tCur + rd.xy / rd.z);\n  return mix (mix (vec3 (0., 0., 0.7), vec3 (0.8), 0.7 * Fbm2 (12. * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\n#define NDIG  51\n// 314159265358979323846264338327950288419716939937510\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, bgCol;\n  vec2 fd, id, cBox;\n  float pv[NDIG], dstObj, t;\n  pv[0]  = 3.;\n  pv[1]  = 1.; pv[2]  = 4.; pv[3]  = 1.; pv[4]  = 5.; pv[5]  = 9.;\n  pv[6]  = 2.; pv[7]  = 6.; pv[8]  = 5.; pv[9]  = 3.; pv[10] = 5.;\n  pv[11] = 8.; pv[12] = 9.; pv[13] = 7.; pv[14] = 9.; pv[15] = 3.;\n  pv[16] = 2.; pv[17] = 3.; pv[18] = 8.; pv[19] = 4.; pv[20] = 6.;\n  pv[21] = 2.; pv[22] = 6.; pv[23] = 4.; pv[24] = 3.; pv[25] = 3.;\n  pv[26] = 8.; pv[27] = 3.; pv[28] = 2.; pv[29] = 7.; pv[30] = 8.;\n  pv[31] = 5.; pv[32] = 0.; pv[33] = 2.; pv[34] = 8.; pv[35] = 8.;\n  pv[36] = 4.; pv[37] = 1.; pv[38] = 9.; pv[39] = 7.; pv[40] = 1.;\n  pv[41] = 6.; pv[42] = 9.; pv[43] = 3.; pv[44] = 9.; pv[45] = 9.;\n  pv[46] = 3.; pv[47] = 7.; pv[48] = 5.; pv[49] = 1.; pv[50] = 0.;\n  t = mod (2. * tCur, 60.);\n  cSize = vec2 (2.269, 1.);\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  cBox = vec2 (0.45, 0.3);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col = vec3 (1., 0.9, 0.9);\n    ro.y *= -1.;\n    fd = 0.5 * (ro.xy / cSize + 1.) * vec2 (84., 13.) - vec2 (2., 0.5);\n    id = floor (fd) - vec2 (0., 2.);\n    fd = fract (fd) - 0.5;\n    fd.y *= -1.;\n    if (id.y <= 9. && id.x >= 0. && id.x < 80. && vn.z < -0.99) {\n      if (id.y >= 0.) {\n        col *= 1. - 0.15 * (1. - smoothstep (0.35, 0.38, abs (fd.x))) *\n           (1. - smoothstep (0.25, 0.27, abs (fd.y)));\n        col = mix (col, vec3 (0.05), ShowInt (fd - vec2 (0.2, -0.15),\n           cBox, 1., id.y));\n      } else if (id.y == -1.) col = mix (col, vec3 (0.05),\n         ShowInt (fd - vec2 (0.2, -0.15), 0.8 * cBox, 1., mod (id.x + 1., 10.)));\n    }\n    col *= (0.5 + 0.5 * max (dot (vn, ltDir), 0.));\n    if (t > 2.) {\n      for (int k = 0; k < NDIG; k ++) {\n        if (id.x == 6. + float (k)) {\n          if (id.y == pv[k]) col = mix (col, bgCol,\n             (1. - step (0.38, abs (fd.x))) * (1. - step (0.27, abs (fd.y))));\n          else if (id.y == -2. && vn.z < -0.99) col = mix (col, vec3 (0.2),\n             ShowInt (fd - vec2 (0.2, -0.15), 1.2 * cBox, 1., pv[k]));\n        }\n        if (float (k + 1) >= t - 2.) break;\n      }\n    }\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n  }\n  dstFar = 15.;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  ro = vuMat * vec3 (0., 0., -7.);\n  ltDir = vuMat * normalize (vec3 (0., 0., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRnd2BoxDf (vec3 p, vec3 b, float r)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return max (length (max (d.xz, 0.)) - r, d.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.23, 0.27, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.7, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGXR1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[379, 379, 401, 401, 521], [523, 523, 556, 556, 733], [735, 735, 756, 756, 984], [986, 986, 1008, 1008, 1318], [1393, 1393, 1428, 1428, 3600], [3602, 3602, 3658, 3658, 4381], [4383, 4383, 4428, 4428, 4508], [4631, 4631, 4655, 4655, 4702], [4704, 4704, 4729, 4729, 4928], [4930, 4930, 4951, 4951, 5090], [5092, 5092, 5115, 5115, 5217], [5219, 5219, 5251, 5251, 6189], [6191, 6191, 6251, 6251, 6834]], "test": "error"}
{"id": "lsKSRh", "name": "What a World", "author": "Draedrus", "description": "A world generation, sorry for the code, this is a total trash.\nShader crashes often with Google Chrome.\nOptions : line 5 to 196\nFeatures :\n- Procedural terrain, forests, sky, moon, sun\n- Water (Reflective, Refractive)\n- Cheap clouds\n- (soft)shadows", "tags": ["procedural", "3d", "raymarching", "water", "sky", "aurora", "world", "islands", "forests"], "likes": 5, "viewed": 651, "published": "Public", "date": "1462958392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/**\n * CAMERA BEHAVIOUR RELATED CONSTANTS\n **/\n// By default, the camera is fixed at CAMPOS position and looks straight forward\n// perform a flight over the world\n//#define USE_MARCH\n// camera rotation around TARGETPOS using CAMROTSPEED+CAMDIST, disable USE_MARCH\n//#define SET_CAMERA_TARGET_ROTATION\n// default camera rotation (look around)\n//#define SET_CAMERA_DEFAULT_ROTATION\n// setup the camera to see the sundawn\n#define SET_CAMERA_SUNDOWN\n// setup the camera to see the sunrise\n//#define SET_CAMERA_SUNRISE\n\n//#define SET_NIGHT\n\n/**\n * RENDERING OPTION GLOBALS\n **/\n// wanna see only the depth camera ? Okay !\n//#define USE_DEPTHMODE\n// make the setting more realistic with a few computing performance\n#define USE_SOFTSHADOWS\n// this makes shader crashing under firefox\n//#define USE_SOFTSHADOWS_ON_REFLECTION\n// defines if the algorithm will use a rotating (X axis) light around 0.0, 0.0, 0.0\n// using LIGHTSPEED\n#define USE_LIGHTMOVING\n// defines if the algorithm will use a rotating (Y axis) moon around 0.0, 0.0, 0.0\n// using MOONSPEED\n//#define USE_MOONMOVING\n// defines if the clouds are animated or not, using CLOUDSPEED\n#define USE_ANIMATECLOUDS\n// defines that the algorithm will perform water reflection (costs a lot)\n#define USE_WATER_REFLECTION\n// defines that the algorithm will perform water refraction (costs a few)\n#define USE_WATER_REFRACTION\n// defines that the algorithm will perform day&night simulation\n#define USE_DAYANDNIGHT\n// defines that the algorithm will use a better noise for the star generation\n//#define USE_HD_STARNOISE\n// defines if the algorithm will draw the sun\n#define DRAW_SUN\n// defines if the algorithm will draw the moon\n#define DRAW_MOON\n// old looking lighting without moon light and not accurate lighting\n//#define OLDLIGHTING\n#define USE_BOREALS\n// define if we are going to have more rocks or not\n#define USE_MORE_ROCKY\n// have the mountains noise different from terrain one\n#define USE_HD_MOUNTAIN\n// USE_HD_MOUNTAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a voronoi 3D noise for the rocky bump map (costs a lot)\n//#define USE_HD_MOUNTAIN_NOISE\n// Use a voronoi 2D noise for the rocky bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_MOUNTAIN_NOISE\n// USE_HD_TERRAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a simplex 3D noise for the terrain bump map (costs a lot)\n//#define USE_HD_TERRAIN_NOISE\n// Use a simplex 2D noise for the terrain bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_TERRAIN_NOISE\n\n#define RAYMARCHING_NUM_STEPS 40\n#define RAYMARCHING_REFL_NUM_STEPS 20\n#define RAYMARCHING_REFR_NUM_STEPS 20\n#define SOFTSHADOW_STEPS 8\n\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define CAMDIST 8.0\n#define CAMROTSPEED 0.2\n#define LIGHTSPEED 1.0\n#define MOONSPEED 0.5\n#define CLOUDSPEED 0.1\n#define AURORABOREALISSPEED 3.0\n#define FAR 100.0\n#define NEAR 0.002\n\n#define OCTAVES 2\n\n// 0.4 default only for OLDLIGHTING\n#define VAR_REFL_OVER_REFR_PERCT 0.5\n\n#define VAR_MOUNTAIN_LEVEL 5.0\n#define VAR_MOUNTAIN_AMP 8.0\n#define VAR_MOUNTAIN_FREQ 0.2\n#define VAR_MOUNTAIN_LIGHTING_KD 0.4\n#define VAR_MOUNTAIN_LIGHTING_KS 1.5\n/*\n\tA variation I liked, with greater islands/continents\n\n#define VAR_TERRAIN_LEVEL 9.0\n#define VAR_TERRAIN_AMP 12.5\n#define VAR_TERRAIN_FREQ 0.05\n*/\n/*\n\tDefault variation\n#define VAR_TERRAIN_LEVEL 5.0\n#define VAR_TERRAIN_AMP 8.5\n#define VAR_TERRAIN_FREQ 0.2\n*/\n// 5.0\n#define VAR_TERRAIN_LEVEL 5.0\n// 8.5\n#define VAR_TERRAIN_AMP 8.5\n// 0.2\n#define VAR_TERRAIN_FREQ 0.2\n#define VAR_TERRAIN_LIGHTING_KD 1.0\n#define VAR_TERRAIN_LIGHTING_KS 0.0\n#define VAR_TREE_LIGHTING_KD 1.0\n#define VAR_TREE_LIGHTING_KS 0.0\n\n#define VAR_WATER_LEVEL 0.0\n// 0.08 - 0.1 is a good value for VAR_WATER_AMP\n#define VAR_WATER_AMP 0.08\n#define VAR_WATER_FREQ 1.2\n#define VAR_WATER_SPEED 0.8\n#define VAR_WATER_LIGHTING_KD 0.4\n#define VAR_WATER_LIGHTING_KS 1.0\n\n#define VAR_FRESNEL_BIAS 0.2\n#define VAR_FRESNEL_SCALE 1.0\n#define VAR_FRESNEL_POW 2.0\n\n// old\n//#define VAR_MOONRADIUS 1.0\n#define VAR_MOONRADIUS 200.0\n\n#define CAMPOS vec3(0.0, 10.0, 10.0)\n#define TARGETPOS vec3(0.0, 1.0, 0.0)\n// old\n#define ASTRALMAXDIST 4000.0\n//#define MOONPOS vec3(-10.0, 20.0, 50.0)\n#define MOONPOS normalize(vec3(4000.0, 400.0, 2000.0))*ASTRALMAXDIST\n#define LIGHTPOS normalize(vec3(-2000.0, 2000.0, -2000.0))*ASTRALMAXDIST\n\n//#define COLORROCK vec3(0.5, 0.5, 0.6)\n#define COLORROCK vec3(0.8, 0.8, 0.7)\n#define COLORGRASS vec3(0.5, 0.7, 0.5)\n#define COLORTREE vec3(0.0, 0.2, 0.0)\n#define COLORSAND vec3(0.9, 0.9, 0.5)\n#define COLORWATER vec3(0.1, 0.5, 0.7)\n#define COLORSKYDAY vec3(0.5, 0.5, 1.0)\n#define COLORSKYDAWN vec3(1.0, 0.6, 0.5)\n#define COLORSKYNIGHT vec3(0.1, 0.2, 0.4)\n\n#define TYPE_TERRAIN 0.0\n#define TYPE_WATER 1.0\n#define TYPE_TREES 2.0\n#define TYPE_MOUNTAIN 3.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n    \n#ifdef OLDLIGHTING\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.01,\n    1.5);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(TARGETPOS-MOONPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    2.01,\n    1.5);\n\n#else\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 0.7, 1.0),\n    16.0,\n    1.0);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(TARGETPOS-MOONPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.01,\n    4.0);\n\n#endif\n\n/*******************\n * TOOLS\n *******************/\n\nvec2 UVTwist(in vec2 uv, float a) {\n    float cA = cos(a+iTime);\n    float sA = sin(a+iTime);\n\treturn uv*mat2(cA, -sA, sA, cA);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash1D(float x) {\n\treturn fract(((x+124.2394943)*134.400594)*((x+7.13571113)*1.13497));\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(0.4955, 490.4294, 0.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n/**\n * noise and smoothNoise function were inspired by common knowledge found in internet.\n **/\nfloat hash2(float x) {\n    return fract(sin(x)*556858.4905705783);\n}\n\n/**\n * Inspired from a noisy function in \"Seascape\" by TDM\n **/\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash2(wx+0.0)     , hash2(wx+1.0), f.x),\n                mix(hash2(wx+0.0+winy), hash2(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash2(wx+0.0+winz)     , hash2(wx+1.0+winz), f.x),\n                mix(hash2(wx+0.0+winy+winz), hash2(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat noise1D(float x) {\n    float p = floor(x);\n    float n = fract(x);\n    float f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 2.0;\n    \n    return mix(\n                mix(hash1D(p)     , hash1D(p+winx), f),\n                mix(hash1D(p+winy), hash1D(p+winx+winy), f),\n                f);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += iTime*CLOUDSPEED;\n    #endif\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p) {\n    float total = 0.0;\n    /*total += 0.5000*smoothNoise(p*2.0);\n    total += 0.2500*smoothNoise(p*2.01);\n    total += 0.1250*smoothNoise(p*2.02);\n    total += 0.0625*smoothNoise(p*2.04);*/\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += iTime*CLOUDSPEED;\n    #endif\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3DTerrain(vec3 p) {\n    float total = 0.0;\n    #ifdef USE_HD_TERRAIN_NOISE\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    #else\n    \t#ifdef USE_FAST_HD_TERRAIN_NOISE\n        p*=0.8;\n        total  = 0.5000* snoise(p.xz); p = p*2.0;\n        total += 0.2500* snoise(p.xz); p = p*2.0;\n        total += 0.1250* snoise(p.xz); p = p*2.0;\n        total += 0.0625* snoise(p.xz); p = p*2.0;\n   \t \t#else\n        total  = 0.5000* noise3D(p); p = p*2.0;\n        total += 0.2500* noise3D(p); p = p*2.0;\n        total += 0.1250* noise3D(p); p = p*2.0;\n        total += 0.0625* noise3D(p); p = p*2.0;\n    \t#endif\n    #endif\n    return total;\n}\n\nfloat fbm3DMountain(vec3 p) {\n    float total = 0.0;\n    #ifdef USE_HD_MOUNTAIN_NOISE\n    p*=2.0;\n    total  = 0.5000* voronoi3D(p); p = p*2.0;\n    total += 0.2500* voronoi3D(p); p = p*2.0;\n    total += 0.1250* voronoi3D(p); p = p*2.0;\n    total += 0.0625* voronoi3D(p); p = p*2.0;\n    #else\n    \t#ifdef USE_FAST_HD_MOUNTAIN_NOISE\n        p*=2.0;\n        total  = 0.5000* voronoi2D(p.xz); p = p*2.0;\n        total += 0.2500* voronoi2D(p.xz); p = p*2.0;\n        total += 0.1250* voronoi2D(p.xz); p = p*2.0;\n        total += 0.0625* voronoi2D(p.xz); p = p*2.0;\n   \t \t#else\n        total  = 0.5000* waterNoise(p.xz); p = p*2.0;\n        total += 0.2500* waterNoise(p.xz); p = p*2.0;\n        total += 0.1250* waterNoise(p.xz); p = p*2.0;\n        total += 0.0625* waterNoise(p.xz); p = p*2.0;\n    \t#endif\n    #endif\n    return total;\n}\n\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES+2;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<-d2.x) ? d1 : d2;\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat heightMap(vec3 p, float s, float f) {\n    float h = 0.0;\n    float a = s;\n    for(int i=0;i<4;++i) {\n        h += waterNoise(p.xz*f)*a;\n        //h += (1.0-voronoi2D(p.xz*f))*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat heightMapWater(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = VAR_WATER_FREQ;\n    for(int i=0;i<10;++i) {\n        h += waterNoise(p.xz*f+iTime*VAR_WATER_SPEED)*a;\n        h -= waterNoise(p.xz*f-iTime*VAR_WATER_SPEED)*a;\n        a *= 0.6;\n        f *= 1.4;\n    }\n    return h;\n}\n\nfloat heightMapMountain(vec3 p, float s, float f) {\n    float h = 0.0;\n    float a = s;\n    for(int i=0;i<6;++i) {\n        h += waterNoise(p.xz*f)*a;\n        //h += (1.0-voronoi2D(p.xz*f))*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapWater(vec3 p, float a) {\n    return sdPlane(p)+heightMapWater(p, a);\n}\n\nfloat mapTerrain(vec3 p, float hm, float fbm) {\n    float t = sdPlane(p)+hm+fbm;\n    return t;\n}\n\nfloat mapMountain(vec3 p, float hm, float fbm) {\n    float t = sdPlane(p)+hm+fbm;\n    return t;\n}\n\nfloat mapTrees(vec3 p, float hm, float fbm) {\n    /*p.x = sin(p.x)+1.0;\n    p.z = cos(p.z)+1.0;*/\n    vec3 m = vec3(0.2, 0.2, 0.1);// ok\n    //vec3 m = vec3(0.2+fract(p.x)*0.2, 0.2+fract(p.y)*0.2, 0.1+fract(p.z)*0.1);// noisy\n    vec3 p2 = mod(p-vec3(0.0, 0.2, 0.0), m)-0.5*m;\n    return sdPlane(p)+hm+fbm+sdSphere(p2, 0.2);\n}\n\nvec2 mapWorld(vec3 p, float s) {\n    float hmTerrain = heightMap(p, s, VAR_TERRAIN_FREQ);\n    #ifdef USE_HD_MOUNTAIN\n    float hmMountain = heightMapMountain(p-vec3(0.0, VAR_MOUNTAIN_LEVEL, 0.0), VAR_MOUNTAIN_AMP, VAR_MOUNTAIN_FREQ);\n    float fbmMountain = fbm3DMountain(p*0.5);\n    #endif\n    float fbmTerrain = fbm3DTerrain(p*0.5);\n    float t = mapTerrain(p, hmTerrain, fbmTerrain);\n    float ts = mapTrees(p, hmTerrain, fbmTerrain);\n    /*if(waterNoise(p.xz*0.3)>0.5 &&\n       p.y>=(VAR_WATER_LEVEL-(VAR_TERRAIN_LEVEL-1.0-noise3D(p)))) {\n        return opU(vec2(t, TYPE_TERRAIN), vec2(ts, TYPE_TREES));\n    #ifdef USE_MORE_ROCKY\n    }else if((waterNoise(p.xz*0.5)*0.5+waterNoise(p.xz*8.0))>0.8) {\n    #else\n    }else if(waterNoise(p.xz*8.0)>0.8) {\n    #endif\n        #ifdef USE_HD_MOUNTAIN\n        return opU(vec2(mapMountain(p, hmMountain, fbmMountain), TYPE_MOUNTAIN), vec2(t, TYPE_TERRAIN));\n        #else\n        return vec2(min(t, mapMountain(p, hmTerrain, fbmTerrain)), TYPE_MOUNTAIN);\n        #endif\n    }else{\n        return vec2(t, TYPE_TERRAIN);\n    }*/\n    if(waterNoise(p.xz*0.3)>0.5 &&\n       p.y>=(VAR_WATER_LEVEL-(VAR_TERRAIN_LEVEL-1.0-noise3D(p)))) {\n        return opU(vec2(t, TYPE_TERRAIN), vec2(ts, TYPE_TREES));\n    }\n    else\n    {\n        return opU(vec2(t, TYPE_TERRAIN),\n        \t#ifdef USE_HD_MOUNTAIN\n        \tvec2(mapMountain(p, hmMountain, fbmMountain), TYPE_MOUNTAIN)\n        \t#else\n        \tvec2(mapMountain(p, hmTerrain, fbmTerrain)+(1.0-2.0*waterNoise(p.xz)), TYPE_MOUNTAIN)\n        \t#endif\n                );\n    }\n}\n\nfloat heightMapSand(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<SAND_OCTAVES;++i) {\n        h += snoise(p.xz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    for(int i=0;i<SAND_GRAINS;++i) {\n        h += hash3D(p.xyz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapSand(vec3 p, float s) {\n\treturn sdPlane(p)+heightMapSand(p, s);\n}\n\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    //d = vec2(mapTerrain(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP), TYPE_TERRAIN);\n    d = mapWorld(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP);\n    d = opU(vec2(mapWater(p-vec3(0.0, VAR_WATER_LEVEL, 0.0), VAR_WATER_AMP), TYPE_WATER), d);\n    return d;\n}\n\nvec2 mapRefl(vec3 p) {\n    return mapWorld(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP);\n}\n\n\nvec2 mapUnderWater(vec3 p) {\n    float hmTerrain = heightMap(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP, VAR_TERRAIN_FREQ);\n    return vec2(mapTerrain(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), hmTerrain, 0.0), TYPE_TERRAIN);\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;\n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapNormalRefl(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapRefl(pt).x;\n    normal.x = mapRefl(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapRefl(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapUnderWaterNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapUnderWater(pt).x;    \n    normal.x = mapUnderWater(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapUnderWater(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n// the reflection one\nvec2 raymarchRefl(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_REFL_NUM_STEPS; i++ )\n\t{\n        m = mapRefl(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvec2 raymarchUnderWater(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_REFR_NUM_STEPS; i++ )\n\t{\n        m = mapUnderWater(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += /*0.5**/m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\n\treturn res;\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = NEAR;\n    for(int i = 0; i<SOFTSHADOW_STEPS;i++) {\n        float h = map(ro + rd*t).x;\n        if( h<NEAR || t>FAR)\n            break;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat Fresnel(vec3 I, vec3 n, float fBias, float fScale, float fPow)\n{\n    return fBias + fScale * pow(1.0 + dot(I, n), fPow);\n}\n\nfloat clouds(in vec3 ro, in vec3 rd)\n{\n    float sum = 0.0;\n    rd = rd*100.0;\n    sum = pow(fbm3D(ro*0.4+rd/rd.y*0.6), 4.0)*10.0;\n    sum *= rd.y/length(rd);\n    return sum;\n}\n\nvec3 lighting(vec3 rd, vec3 n, float Kd, float Ks) {\n    vec3 lightingComp = vec3(0.0);\n    float lopy = _light.o.y/ASTRALMAXDIST;//_light.o.y/length(_light.o);\n    float limit = 0.15;\n    #ifdef SET_NIGHT\n    lopy = -1.0;\n    #endif\n    float blendingP = clamp(0.5*(sin(lopy*3.14/2.0)+1.0), 0.0, 1.0);\n    \n    vec3 lightingCompDay = Kd*max(0.0, dot(-_light.d, n))*_light.diffuseColor.rgb;\n    if(Ks>0.0)\n    {\n        float sT = dot(rd, -reflect(_light.d, n));\n        lightingCompDay += Ks*pow(sT, _light.shininess);\n    }\n    vec3 lightingCompNight = Kd*max(0.0, dot(-_moon.d, n))*_moon.diffuseColor.rgb;\n    if(Ks>0.0)\n    {\n        float sT = max(0.0, dot(rd, -reflect(_moon.d, n)));\n        lightingCompNight += Ks*pow(sT, _moon.shininess);\n    }\n    lightingComp = mix(lightingCompNight, lightingCompDay, blendingP);\n    /*if(lopy>=0.0) {\n        // day\n        if(lopy>limit)\n        {\n    \t\tfloat lDT = max(0.0, dot(-_light.d, n));\n            lightingComp = Kd*lDT*_light.diffuseColor.rgb;\n            if(Ks>0.0)\n            {\n            \tfloat sT = max(0.0, dot(rd, -reflect(_light.d, n)));\n                lightingComp+=Ks*pow(sT, _light.shininess);\n            }\n        }\n        // sundown\n        else\n        {\n            vec3 lightingCompDay = Kd*max(0.0, dot(-_light.d, n))*_light.diffuseColor.rgb;\n            if(Ks>0.0)\n            {\n            \tfloat sT = dot(rd, -reflect(_light.d, n));\n                lightingCompDay+=Ks*pow(sT, _light.shininess);\n            }\n            vec3 lightingCompNight = Kd*max(0.0, dot(-_moon.d, n))*_moon.diffuseColor.rgb;\n            if(Ks>0.0)\n            {\n            \tfloat sT = max(0.0, dot(rd, -reflect(_moon.d, n)));\n                lightingCompNight+=Ks*pow(sT, _moon.shininess);\n            }\n            //lopy = clamp(lopy*(1.0/limit), 0.0, 1.0);\n            //lopy = clamp(sin(lopy*3.14/2.0), 0.0, 1.0);\n            lightingComp = mix(lightingCompNight, lightingCompDay, blendingP);\n        }\n    }\n    else\n    {\n        lopy = abs(lopy);\n        // night\n        if(lopy>limit)\n        {\n    \t\tfloat lNT = max(0.0, dot(-_moon.d, n));\n            lightingComp = Kd*lNT*_moon.diffuseColor.rgb;\n            if(Ks>0.0)\n            {\n            \tfloat sT = max(0.0, dot(rd, -reflect(_moon.d, n)));\n                lightingComp+=Ks*pow(sT, _moon.shininess);\n            }\n        }\n        // sunrise\n        else\n        {\n            vec3 lightingCompDay = Kd*max(0.0, dot(-_light.d, n))*_light.diffuseColor.rgb;\n            if(Ks>0.0)\n            {\n            \tfloat sT = max(0.0, dot(rd, -reflect(_light.d, n)));\n                lightingCompDay+=Ks*pow(sT, _light.shininess);\n            }\n            vec3 lightingCompNight = Kd*max(0.0, dot(-_moon.d, n))*_moon.diffuseColor.rgb;\n            if(Ks>0.0)\n            {\n            \tfloat sT = max(0.0, dot(rd, -reflect(_moon.d, n)));\n                lightingCompNight+=Ks*pow(sT, _moon.shininess);\n            }\n            //lopy = clamp(lopy*(1.0/limit), 0.0, 1.0);\n            //lopy = clamp(sin(lopy*3.14/2.0), 0.0, 1.0);\n            lightingComp = mix(lightingCompDay, lightingCompNight, blendingP);\n        }\n    }*/\n    return clamp(lightingComp, 0.0, 1.0);\n}\n\nfloat fractWave(float x)\n{\n    return abs(2.0*fract(x-0.5));\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd, vec2 uv, bool isStarsNeeded) {\n    vec3 color = vec3(0.0);\n    float c = max(0.0, clouds(ro, rd));\n    #ifdef USE_DAYANDNIGHT\n        // day & night\n        float lopy = _light.o.y/ASTRALMAXDIST;//_light.o.y/length(_light.o);\n        #ifdef SET_NIGHT\n        lopy = -1.0;\n        #endif\n        if(lopy>0.0) {\n            if(lopy>0.4) color = COLORSKYDAY;\n            else{\n                color = mix(COLORSKYDAWN, COLORSKYDAY, lopy*2.5);\n            }\n        }else{ // the night\n            vec3 colorSkyNight = vec3(0.0);\n            vec3 _c = COLORSKYNIGHT;\n            \n\n            #ifdef USE_BOREALS\n            float T = iTime*AURORABOREALISSPEED;\n            /*float bf = cos(rd.x*8.0+T)*(rd.y+0.4)*sin(rd.y*8.0+T);\n            bf = clamp(bf, 0.0, 1.0);\n            bf *= pow(1.0+bf, 4.0)-1.0;\n            vec3 colorBoreals = smoothstep(vec3(0.0, 1.0, 0.4), vec3(0.6, 0.2, 0.5), vec3(uv.y-0.3));\n            colorBoreals *= bf;\n            colorBoreals *= waterNoise((uv.xx+0.002*waterNoise(uv.yy*100.0))*100.0)*1.0;\n            \n            colorBoreals = mix(COLORSKYNIGHT, colorBoreals, 0.5);\n            _c = mix(COLORSKYNIGHT, colorBoreals, rd.y+0.4);*/\n            vec3 rdp = (ro+rd*100.0);\n            rdp /= rdp.y;\n            //float bf = max(0.0, sin((rdp.z+cos(rdp.x+T))*1.0+T)); // not bad\n            float bf = max(0.0, sin((rdp.z+cos(rdp.x+T))*0.5)); // not bad\n            if(bf>0.0)\n            {\n                vec3 colorBoreals = mix(vec3(0.6, 0.2, 0.5), vec3(0.0, 1.0, 0.4), 2.0*(bf-0.5));\n                _c = mix(COLORSKYNIGHT, colorBoreals, (uv.y-0.3)*(uv.y-0.3)*(pow(1.0+bf, 2.0)-1.0));\n            \t//_c = colorBoreals;\n            }\n            #endif\n            \n            if(rd.y>-0.1 && isStarsNeeded)\n            {\n                #ifdef USE_HD_STARNOISE\n                    vec2 _uv = (uv+rd.xz*0.01)*100.0/rd.y;//rd.xz*100.0/rd.y;\n                    float tf = iTime*0.001;\n                    float starnoise = mix(mix(mix(\n                                    1.0-step(waterNoise(_uv+vec2(0.0, 0.0)+tf), 0.96),\n                                    1.0-step(waterNoise(_uv+vec2(0.05, 0.0)+tf), 0.96),\n                                    0.5),\n                                    1.0-step(waterNoise(_uv+vec2(0.0, 0.05)+tf), 0.96),\n                                    0.5),\n                                    1.0-step(waterNoise(_uv+vec2(0.05, 0.05)+tf), 0.96),\n                                    0.5\n                                );\n                #else\n                    vec2 _uv = rd.xz*10.0/rd.y;\n                    float starnoise = 1.0-step(hash2D(_uv), 0.999);\n                #endif\n                colorSkyNight = mix(_c, vec3(1.0), starnoise*(1.0-c));\n            }\n            else // midnight more or less\n            {\n                colorSkyNight = _c;\n            }\n            lopy = abs(lopy);\n            if(lopy>0.4) color = colorSkyNight;\n            else{\n                color = mix(COLORSKYDAWN, colorSkyNight, lopy*2.5);\n            }\n        }\n    #else\n    \tcolor = COLORSKYDAY;\n    #endif\n    \n    color = mix(vec3(1.0), color, uv.y+0.4);\n    color = mix(color, vec3(1.0), c);\n    \n    #ifdef DRAW_SUN\n    float d = IntersectSphere(ro, rd, _light.o, 2000.0);\n    if(d>0.0) {\n        vec3 ps = ro+d*rd;\n        vec3 ns = normalize(ps-_light.o);\n        float a = max(0.0, dot(-rd, ns));\n        color += vec3(1.0, 1.0, 0.0)*pow(a, 8.0);\n    }\n    #endif\n    #ifdef DRAW_MOON\n    \n    float dm = IntersectSphere(ro, rd, _moon.o, VAR_MOONRADIUS);\n    if(dm>0.0) {\n        float time = normalize(_light.o).y;\n        vec3 ps = ro+dm*rd;\n        vec3 ns = normalize(ps-MOONPOS);\n        float a = max(0.0, dot(-rd, ns));\n        float ac = a*3.0;\n        float cf = max(0.3, 0.8-max(perlin(ps*2.0*(1.0/VAR_MOONRADIUS)), 0.3));\n        vec3 colorm = _moon.diffuseColor.rgb*3.0/*ac*/*cf;\n        if(time<-0.2)\n            color = mix(color, colorm, clamp(pow(1.0+a, 2.0)-1.0, 0.0, 1.0));\n        else if(time<=0.2)\n        {\n            float _a = (time+0.2)*2.5;\n            color = mix(color, mix(colorm, vec3(1.0)*3.0*cf, _a), mix(a, 0.1*a, _a));\n        }\n        else\n        {\n            color = mix(color, _moon.diffuseColor.rgb*3.0*cf, 0.1*a);\n        }\n    }\n    #endif\n    color *= abs(uv.y);\n    return color;\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 rm, vec2 uv) {\n    vec3 p = ro+rd*rm.x;\n    vec3 n = vec3(0.0);\n    vec3 color = vec3(0.0);\n    #ifdef USE_DEPTHMODE\n    color.r = color.g = color.b = (FAR-rm.x)/(FAR-NEAR);\n    //color.rgb *= max(0.0, dot(-_light.d, n))*1.0/(0.3*length(p - _light.o));\n    #else\n    if(rm.x>NEAR && rm.x<FAR) {\n        n = normalize(mapNormal(p, 0.001));\n        #ifdef OLDLIGHTING\n        float lT = dot(-_light.d, n);\n        #endif\n        if(rm.y==TYPE_TERRAIN) {\n            color = mix(COLORSAND,\n                        COLORGRASS*(hash2D(p.xz)+8.0)*0.09,\n                        min(1.0, max(0.0, (p.y+VAR_WATER_LEVEL)*VAR_TERRAIN_LEVEL*0.2))\n                       );\n            color *= max(0.4, hash3D(p));\n            #ifdef OLDLIGHTING\n            color *= lT*_light.power;\n            #else\n            color += lighting(rd, n, VAR_TERRAIN_LIGHTING_KD, VAR_TERRAIN_LIGHTING_KS);\n            #endif\n        }else if(rm.y==TYPE_TREES) {\n            \n            if(p.y<VAR_WATER_LEVEL+0.1)\n            \tcolor = COLORSAND;\n            else{\n                color = COLORTREE*hash2D(p.xz);\n            }\n            \n        \t#ifdef OLDLIGHTING\n            color *= lT*_light.power;\n            #else\n            color += lighting(rd, n, VAR_TREE_LIGHTING_KD, VAR_TREE_LIGHTING_KS);\n            #endif\n        }else if(rm.y == TYPE_MOUNTAIN) {\n            color = COLORROCK*max(0.8, hash3D(p));\n            #ifdef OLDLIGHTING\n             color *= lT*_light.power;\n            #else\n            color += lighting(rd, n, VAR_MOUNTAIN_LIGHTING_KD, VAR_MOUNTAIN_LIGHTING_KS);\n            #endif\n        }else if(rm.y==TYPE_WATER) {\n\t\t\t#ifdef USE_WATER_REFRACTION\n            vec3 rfc = refract(rd, n, 1.33);\n            // refraction\n            vec2 rmr = raymarchUnderWater(p, rfc, NEAR, FAR);\n            vec3 rcolor = vec3(0.0);;\n        \tif(rmr.y==TYPE_TERRAIN) {\n                rcolor = COLORSAND;\n                #ifdef OLDLIGHTING\n                rcolor *= lT*_light.power;\n                #else\n                rcolor += lighting(rfc, n, VAR_TERRAIN_LIGHTING_KD, VAR_TERRAIN_LIGHTING_KS);\n                #endif\n                rcolor *= (FAR-rmr.x)/(FAR-NEAR);\n            }\n            #endif\n\t\t\t#ifdef USE_WATER_REFLECTION\n                #if !defined(USE_WATER_REFRACTION)\n                vec2 rmr = vec2(-1.0, -1.0);\n            \tvec3 rcolor = vec3(0.0);\n                #endif\n                // reflection\n                vec3 rxcolor = vec3(0.0);\n            \tvec3 rdr = normalize(reflect(rd, n));\n            \tvec3 rxp = p;//+vec3(0.0, 0.08, 0.0);\n                rmr = raymarchRefl(p, rdr, NEAR, FAR);\n            \trxp = rxp+rdr*rmr.x;\n        \t\tvec3 rxn = normalize(mapNormalRefl(rxp, 0.001));\n            \n    \t\t\tif(rmr.x>NEAR && rmr.x<FAR)\n                {\n                    if(rmr.y==TYPE_TERRAIN) {\n                        rxcolor = mix(COLORSAND,\n                            COLORGRASS*(hash2D(rxp.xz)+8.0)*0.09,\n                            min(1.0, max(0.0, (rxp.y+VAR_WATER_LEVEL)*VAR_TERRAIN_LEVEL*0.2))\n                           );\n                        #ifdef OLDLIGHTING\n                        rxcolor *= lT*_light.power;\n                        #else\n                        rxcolor += lighting(rdr, rxn, VAR_TERRAIN_LIGHTING_KD, VAR_TERRAIN_LIGHTING_KS);\n                        #endif\n\n                    }else if(rmr.y==TYPE_TREES) {\n                        rxcolor = COLORTREE*hash2D(rxp.xz);//vec3(hash(p.xz), hash(p.zy), 0.0)*pl+lT;\n                        #ifdef OLDLIGHTING\n                        rxcolor *= lT*_light.power;\n                        #else\n                        rxcolor += lighting(rdr, rxn, VAR_TREE_LIGHTING_KD, VAR_TREE_LIGHTING_KS);\n                        #endif\n                    }else if(rmr.y == TYPE_MOUNTAIN)\n                    {\n                        rxcolor = COLORROCK*max(0.8, hash2D(rxp.xz));\n                        #ifdef OLDLIGHTING\n                        rxcolor *= lT*_light.power;\n                        #else\n                        rxcolor += lighting(rdr, rxn, VAR_MOUNTAIN_LIGHTING_KD, VAR_MOUNTAIN_LIGHTING_KS);\n                        #endif\n                    }\n        \t\t\tcolor *= max(0.2, 1.0-2.0*clouds(rxp, vec3(rdr.x, -rdr.y, rdr.z)));\n                    #ifdef USE_SOFTSHADOWS_ON_REFLECTION\n                    if(_light.o.y>0.0)\n                        rxcolor *= shadow(rxp, normalize(_light.o-rxp), _light.power);\n                    else\n                        rxcolor *= shadow(rxp, normalize(_moon.o-rxp), _moon.power);\n                    #endif\n                    // MIXING\n                    rxcolor = mix(rxcolor, getSkyColor(rxp, rdr, uv, false), max(0.0, 1.0-(FAR-rmr.x)/(FAR-NEAR)));\n                }\n            \telse\n                {\n                    rxcolor = getSkyColor(rxp, rdr, uv, true);\n                }\n            \trxcolor = clamp(rxcolor, 0.0, 1.0);\n            #endif\n\n            float fresnel = Fresnel(rd, n, VAR_FRESNEL_BIAS, VAR_FRESNEL_SCALE, VAR_FRESNEL_POW);\n            \n            #if defined(USE_WATER_REFRACTION) && defined(USE_WATER_REFLECTION)\n            \t#ifdef OLDLIGHTING\n           \t\trcolor = mix(rcolor, rxcolor, VAR_REFL_OVER_REFR_PERCT);\n            \t#else\n            \trcolor = mix(rcolor, rxcolor, fresnel);\n            \t#endif\n            #else\n            \t#if defined(USE_WATER_REFLECTION)\n            \t\trcolor = rxcolor;\n            \t#endif\n            #endif\n            // lT, 0.2, 0.4\n            #if defined(USE_WATER_REFRACTION) || defined(USE_WATER_REFLECTION)\n            \t#ifdef OLDLIGHTING\n            \tcolor = mix(COLORWATER, rcolor, fresnel);\n            \t#else\n            \tcolor = COLORWATER+rcolor;\n            \t#endif\n                #ifdef OLDLIGHTING\n                float spec = 0.0;\n            \tfloat sT = dot(rd, -reflect(_light.d, n));\n                if(sT>0.0)\n                    spec = pow(sT, _light.shininess);\n                color *= lT*_light.power+spec;\n                #else\n                color += lighting(rd, n, VAR_WATER_LIGHTING_KD, VAR_WATER_LIGHTING_KS);\n                #endif\n            #else\n            \tcolor = COLORWATER;\n                #ifdef OLDLIGHTING\n                float spec = 0.0;\n            \tfloat sT = dot(rd, -reflect(_light.d, n));\n                if(sT>0.0)\n                    spec = pow(sT, _light.shininess);\n                color *= lT*_light.power+spec;\n                #else\n                color += lighting(rd, n, VAR_WATER_LIGHTING_KD, VAR_WATER_LIGHTING_KS);\n                #endif\n            #endif\n        }\n        color *= (FAR-rm.x)/(FAR-NEAR);\n\n        color *= max(0.2, 1.0-2.0*clouds(ro, vec3(rd.x, -rd.y, rd.z)));\n        #ifdef USE_SOFTSHADOWS\n        //p+=vec3(0.0, 0.05, 0.0);\n        if(_light.o.y>0.0)\n        \tcolor *= shadow(p, normalize(_light.o-p), _light.power);\n        else\n        \tcolor *= shadow(p, normalize(_moon.o-p), _moon.power);\n        #endif\n\n        // MIXING WITH SKY COLOR\n        color = mix(color, getSkyColor(ro, rd, uv, false), max(0.0, 1.0-(FAR-rm.x)/(FAR-NEAR)));\n        color = clamp(color, 0.0, 1.0);\n    }else{\n        color = getSkyColor(ro, rd, uv, true);\n    }\n    #endif\n    return clamp(color, 0.0, 1.0);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;\n\trd = normalize(rdi*rotY);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    lPos = lPos*rotZ*rotX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    #ifdef SET_CAMERA_TARGET_ROTATION\n    ro.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    #else\n    \t#ifdef USE_MARCH\n    \tvec3 campath = vec3(\n            cos(iTime*CAMROTSPEED)*CAMDIST,\n            0.0,\n            sin(iTime*CAMROTSPEED)*CAMDIST+Time*30.0);\n        ro += campath;\n        mat3 ca = setCamera(ro, ro+campath, vec3(0.0, 1.0, 0.0));\n        rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \t#else\n            mat3 ca = setCamera(ro, ro+vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n            rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \t#endif\n    #endif\n    #ifdef SET_CAMERA_DEFAULT_ROTATION\n        rd = RotYV3(rd, Time*CAMROTSPEED);\n    #endif\n    #ifdef SET_CAMERA_SUNDOWN\n    \trd = RotYV3(rd, -1.0);\n    #endif\n    #ifdef SET_CAMERA_SUNRISE\n    \trd = RotYV3(rd, 3.10);\n    #endif\n\n    vec2 rm = vec2(FAR, -1.0);\n    if(rd.y<.0)\n        rm = raymarch(ro, rd, NEAR, FAR);\n    #ifdef USE_LIGHTMOVING\n    \t_light.o = RotXV3(RotZV3(_light.o, Time*LIGHTSPEED), Time*LIGHTSPEED);\n    #endif\n    #ifdef USE_MOONMOVING\n    \t_moon.o = RotYV3(_moon.o, Time*MOONSPEED);\n    #endif\n    _light.d = normalize(ro+rd*rm.x-_light.o);\n    _moon.d = normalize(ro+rd*rm.x-_moon.o);\n    \n    \n    vec3 color = rendering(ro, rd, rm, uv);\n    #ifdef CLOUDS\n    float m = raymarchClouds(ro, rd, NEAR, FAR);\n    if((ro+m*rd).y<7.5) color = mix(color, vec3(0.0), 0.5);\n    else color = mix(color, vec3(1.0)*(FAR-m)/(FAR-NEAR), 0.5);\n    #endif\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5717, 5717, 5752, 5752, 5849], [5851, 5851, 5884, 5884, 5983], [5984, 5984, 6017, 6017, 6116], [6117, 6117, 6150, 6150, 6249], [6251, 6251, 6311, 6311, 6607], [6665, 6665, 6688, 6688, 6760], [6762, 6762, 6784, 6784, 6843], [6845, 6845, 6867, 6867, 6940], [6942, 6942, 6968, 6968, 7346], [7348, 7348, 7374, 7374, 7782], [7784, 7880, 7902, 7902, 7948], [7950, 8014, 8041, 8041, 8587], [8589, 8589, 8612, 8612, 9219], [9221, 9221, 9247, 9247, 9562], [9564, 9564, 9588, 9588, 9871], [9873, 10088, 10110, 10110, 10149], [10150, 10150, 10171, 10171, 11101], [11102, 11158, 11179, 11179, 11216], [11217, 11217, 11244, 11244, 11292], [11294, 11294, 11315, 11315, 13286], [13288, 13351, 13372, 13372, 13657], [13659, 13659, 13680, 13680, 14136], [14138, 14138, 14166, 14166, 14904], [14906, 14906, 14935, 14935, 15735], [15926, 15949, 15974, 15974, 15989], [15991, 15991, 16026, 16026, 16052], [16054, 16054, 16106, 16106, 16233], [16235, 16235, 16266, 16266, 16304], [16306, 16306, 16337, 16337, 16433], [16435, 16435, 16480, 16480, 16520], [16522, 16522, 16555, 16555, 16620], [16622, 16622, 16658, 16658, 16742], [16744, 16744, 16780, 16780, 16867], [16869, 16869, 16913, 16913, 17205], [17207, 17207, 17232, 17232, 17251], [17252, 17252, 17304, 17304, 17811], [17946, 17982, 18023, 18023, 18161], [18163, 18199, 18240, 18240, 18386], [18388, 18388, 18418, 18418, 18451], [18453, 18453, 18483, 18483, 18516], [18518, 18518, 18548, 18548, 18582], [18651, 18651, 18694, 18694, 18893], [18895, 18895, 18934, 18934, 19200], [19202, 19202, 19253, 19253, 19452], [19454, 19454, 19487, 19487, 19533], [19535, 19535, 19582, 19582, 19631], [19633, 19633, 19681, 19681, 19730], [19732, 19732, 19777, 19829, 20058], [21616, 21616, 21654, 21654, 21949], [21951, 21951, 21983, 21983, 22025], [22086, 22086, 22104, 22104, 22413], [22415, 22415, 22437, 22437, 22514], [22517, 22517, 22545, 22545, 22748], [22750, 22750, 22784, 22784, 22991], [22993, 22993, 23031, 23031, 23250], [23252, 23252, 23296, 23296, 23537], [23605, 23605, 23668, 23668, 23948], [23950, 23972, 24039, 24039, 24328], [24330, 24330, 24403, 24403, 24703], [24772, 24772, 24821, 24821, 25064], [25066, 25066, 25136, 25136, 25194], [25196, 25196, 25234, 25234, 25372], [25374, 25374, 25426, 25426, 28563], [28565, 28565, 28591, 28591, 28627], [28629, 28629, 28694, 28694, 32961], [32963, 32963, 33015, 33015, 40198], [40200, 40265, 40328, 40328, 40478], [40480, 40480, 40554, 40554, 40914], [40916, 40916, 40955, 40955, 41296], [41298, 41298, 41355, 41355, 43363]], "test": "valid"}
{"id": "lsKSWh", "name": "Spherical Triangular Lamp", "author": "soma_arc", "description": "Dodecahedral tiling on sphere.\nInspired by Gerard Westendorp (http://westy31.home.xs4all.nl/index.html) and Henry Segerman\nFilm about Lamp https://www.youtube.com/watch?v=mk-qWF26A14\nVisualizing Mathematics with 3D Printing\n", "tags": ["3d", "volume", "tiling"], "likes": 17, "viewed": 338, "published": "Public", "date": "1464172276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc, Kazushi Ahara - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 cPos = vec2(-1.618033, 0.);\nfloat r = 1.90211;\nconst float PI = 3.14159265359;\nconst float EPSILON = 0.001;\n\nconst float k_isotropic = 1. / 12.566368;\n\n// PVR p297\nvec3 lightIntensity(vec3 lightPos, vec3 lightPower, vec3 p){\n\tvec3 dir = lightPos - p;\n    return lightPower * (1. / dot(dir, dir));\n}\n\n// PVR p301\nfloat phaseFunction(vec3 w, vec3 w_light){\n\t// isotropic phase function 1/(4 * PI)\n    return k_isotropic;\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 50;\nfloat loopNum = 0.;\nint IIS(vec2 pos){\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) > r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            fund = false;\n        }\n        if (atan(pos.y, pos.x) > PI/5.){\n            float theta = PI*2./5.;\n            mat2 reflectMat = mat2(cos(theta), sin(theta), sin(theta), -cos(theta));\n            pos = reflectMat * pos;\n            invCount++;\n\t       \tfund = false;\n        }\n        if(fund){\n            if(length(pos) < .05 ||\n               distance(pos, cPos + vec2(r, 0)) < .05 ||\n               distance(pos, cPos + vec2(r, 0.2)) < .05){\n            \treturn 0;\n            }\n        \treturn invCount;\n        }\n    }\n\n\treturn invCount;\n}\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.z), p.y / (1. - p.z));\n}\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n\tvec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 p = (rayOrigin + t * rayDir);\n            int d = 0;\n            vec2 projected = stereoProject(p.xzy);\n            d = IIS(projected);\n\t\t\tif(mod(float(d), 2.) == 0.)\n                return vec4(t, normalize(p - sphereCenter));\n            t = -b + s;\n            if(EPSILON < t && t < isect.x){\n            \tp = (rayOrigin + t * rayDir);\n               \td = IIS(stereoProject(p.xzy));\n\t\t\t\tif(mod(float(d), 2.) == 0.)\n                \treturn vec4(t, normalize(p - sphereCenter));\n            }\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nfloat distFunc(vec3 p){\n  return length(p) - 100.;\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 spherePos = vec3(0, .5, 0);\nfloat sphereR = 0.5;\nvec3 planeP = vec3(0, -0.5, 0);\nvec3 planeN = normalize(vec3(1, 1, 0));\n\nfloat lightVisibility(vec3 org, vec3 target){\n    vec3 v = target - org;\n    vec4 result = vec4(length(v));\n    result = intersectSphere(spherePos, sphereR, org, normalize(v), result);\n    if(result.x < length(v)) return 0.;\n    result = intersectPlane(planeP, planeN, org, normalize(v), result);\n    if(result.x < length(v)) return 0.;\n\treturn 1.;\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.1);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. && lightVisibility(p, lightPos) == 1.) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\n\n\nconst vec3 lightPos = vec3(3, 6, 0);\nconst vec3 lightPower = vec3(1.);\nconst vec3 lightPos2 = vec3(0, 0.5, 0);\nconst vec3 lightPower2 = vec3(2., .2, .2);\nconst int MAX_MARCHING_LOOP = 800;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold){\n    vec3 rayPos = origin;\n  \tfloat dist;\n  \tfloat rayLength = 0.;\n  \tfor(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    \tdist = distFunc(rayPos);\n    \trayLength += dist;\n    \trayPos = origin + ray * rayLength ;\n    \tif(dist < threshold) break;\n  \t}\n  \treturn vec2(dist, rayLength);\n}\n\n// PVR p186 Code 10.2\nvec3 integrateScattering(vec3 p, vec3 w, float rayLength){\n    const float current = 0.;\n    const float end = 10.;\n    const float stepSize = .1;\n    // Integration variables\n    vec3 T = vec3(1.);\n    vec3 L = vec3(0.);\n\t// Integration loop\n    for(float current = 0. ; current < end ; current += stepSize){\n\t\tif(current > rayLength) break;\n    \t// Determine sample position\n        vec3 p_i = p + w * current;\n        // Sample volume properties (This is constant volume)\n        //vec3 sigma_s = vec3(1. * (1. + sin(iTime)), 1., 1.);\n        vec3 sigma_s = vec3(.02);\n        \n        // Compute change in transmittance\n        vec3 T_i = vec3(exp(-sigma_s.x * stepSize),\n                         exp(-sigma_s.y * stepSize),\n                         exp(-sigma_s.z * stepSize));\n        // Update accumulated transmittance\n        T *= T_i;\n        \n        //Sample light source\n        vec3 w_light = lightPos - p_i;\n        vec3 L_light = lightIntensity(lightPos, lightPower, p_i);\n        L_light *= lightVisibility(lightPos, p_i);\n        // Accumulate reflected light\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n        \n        w_light = lightPos2 - p_i;\n        L_light = lightIntensity(lightPos2, lightPower2, p_i);\n        L_light *= lightVisibility(lightPos2, p_i);\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n    }\n    return L;\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n  \tvec4 result = intersectSphere(spherePos, sphereR, eye, ray, vec4(99999.));\n    result = intersectPlane(planeP, planeN, eye, ray, result);\n    \n    vec3 matColor = vec3(1.);\n  \t\n  \tif(result.x > 0.){\n        vec3 intersection = eye + ray * result.x;\n        l += integrateScattering(eye, ray, result.x);\n        vec3 normal = result.yzw;\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower2);\n\n    }\n  \treturn l;\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 eye = vec3(1, 0.5, 1);\nconst vec3 target = vec3(0., 0.5, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(1.5 * cos(iTime/2.) , 1.5, 1.5 *sin(iTime/2.));\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKSWh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[145, 234, 275, 275, 564], [723, 735, 795, 795, 869], [871, 883, 925, 965, 991], [993, 993, 1053, 1053, 1169], [1218, 1218, 1236, 1236, 2123], [2125, 2125, 2152, 2152, 2204], [2206, 2206, 2324, 2324, 3152], [3154, 3154, 3252, 3252, 3438], [3440, 3440, 3463, 3463, 3492], [3649, 3649, 3694, 3694, 3999], [4069, 4069, 4208, 4208, 4427], [4620, 4620, 4690, 4690, 4973], [4975, 4997, 5055, 5055, 6383], [6385, 6385, 6420, 6420, 6986], [6988, 6988, 7009, 7009, 7178], [7180, 7180, 7332, 7332, 7696], [7742, 7742, 7771, 7771, 7951], [8106, 8106, 8162, 8162, 8475]], "test": "valid"}
{"id": "lsKXDW", "name": "Plasma Box", "author": "sillsm", "description": "Plasma Cube", "tags": ["raymarching", "distancefield", "plasmaeffect"], "likes": 1, "viewed": 217, "published": "Public", "date": "1464548541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Max Sills 2016, licensed under the MIT license.\n// Plasma cube.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\naxis = normalize(axis);\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Derived from http://www.bidouille.org/prog/plasma\nfloat plasma2 (vec2 uv)\n{\n    uv *= 2.;\n    float v = sin((uv.x+iTime));\n    v += sin((uv.y+iTime)/2.0);\n    v += sin((uv.x+uv.y+iTime)/2.0);\n    vec2 c = uv/2.0 * vec2(sin(iTime/3.0), cos(iTime/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+iTime);\n    v = v/2.0;\n    return v;\n}\n\n// Rounded box with a plasma displacement.\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  float dist = max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p)));\n  return dist - plasma2(5.*p.xy)/6.;\n}\n\nvec4 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\t\t\t\t\n        float dist = udBox(p, vec3(1,1,1));\n        t += dist * .9;\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    // Rotate the viewer position (near clipping plane center).\n    vec3 position = qRotate(vec3(0,1.,0.),iTime/2. + 4.*mo.x,vec3(0.), vec3(0, 5.*mo.y, -5));\n    \n    mat4 mat = LookAtRH(position, vec3(0,0,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    vec4 tr     = trace(ray, pt);\n    float t     = tr.w;\n    float v = plasma2(5.*tr.xy);\n        \n    vec3 col = 5.*(1./t)*vec3(1, sin(3.14*v), cos(3.14*v));\n    col *= .8; // Gamma correction.\n    fragColor = vec4(col, 0);\n    if (length(col) < .05) {\n        float v2 = plasma2(uv*20.);\n        col = 5.*vec3(sin(v2), sin(v2 + iTime), sin(v2+7.));\n    }\n     fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKXDW.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 146, 209, 209, 638], [640, 693, 718, 718, 972], [974, 1017, 1048, 1048, 1202], [1204, 1204, 1247, 1247, 1476], [1478, 1548, 1597, 1597, 1975], [1977, 1977, 2034, 2034, 2969]], "test": "valid"}
{"id": "lsKXzD", "name": "Spotlight Torus", "author": "docwhite", "description": "Practising spot lights, soft shadows and distance functions.", "tags": ["torus", "spotlight"], "likes": 0, "viewed": 490, "published": "Public API", "date": "1463351393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Detail = 0.0025;\n\nmat4 Rot4X(float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    \n    return mat4( 1, 0, 0, 0,\n                 0, c,-s, 0,\n                 0, s, c, 0,\n                 0, 0, 0, 1);\n}\n\nfloat sdTorus(vec3 p, vec2 t, vec3 c) {\n    p -= c;\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdSphere(vec3 p, vec3 c, float rad) {\n\treturn length(p-c) - rad;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y + 0.5;\n}\n\nfloat map(vec3 p) {\n    mat4 rot = Rot4X(iTime);\n    vec4 rotated = rot * vec4(p, 1.0);\n    float torus = sdTorus(rotated.xyz, vec2(0.3, 0.1), vec3(0.0, 0.1, 0.0));\n    float sphere = sdSphere(p, vec3(cos(iTime), 0.0, sin(iTime)), 0.5);\n    float plane = sdPlane(p);\n    \n    \n    \n    return min(torus, plane);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0.0, Detail);\n    return -normalize(vec3(\n        map(p-e.yxx)-map(p+e.yxx),\n        map(p-e.xyx)-map(p+e.xyx),\n        map(p-e.xxy)-map(p+e.xxy)\n    ));\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float k) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++) {\n    \tfloat h = map(ro + rd * t);\n        if (h < 0.001) { return 0.0; }\n        res = min(res, k*h/t);\n       \tt += h;\n    }\n    return res;\n}\n\nfloat spotLight(vec3 p, vec3 n) {\n    vec3 spotDir = normalize(vec3(0.0, -1.0, 0.0));\n    vec3 spotPos = vec3(0.0, 1.0, 0.0);\n    float coneAngle = 20.0;\n    float coneDelta = 30.0;\n    \n\tvec3 lray = normalize(spotPos - p);\n    float falloff = (dot(lray, -spotDir) - cos(radians(coneDelta))) / (cos(radians(coneAngle)) - cos(radians(coneDelta)));\n    float diffuse = max(0.0, dot(lray, n));\n    float sh = softShadow(p, lray, 0.01, 32.0);\n    return diffuse * falloff * sh;\n}\n\nfloat light(vec3 p, vec3 dir) {\n    vec3 n = normal(p);\n    float diffuse = spotLight(p, n);\n    return diffuse;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n    float d = 1.0;\n    vec3 p;\n    for (int i = 0; i < 128; ++i) {\n        if (d > Detail && t < 50.0) {\n            p = ro + rd * t;\n            d = map(p);\n            t += d;\n        }\n    }\n    float bg = 0.0;\n    float col;\n    if (d < Detail) {\n    \tcol = light(p-Detail*rd, rd);\n    } else {\n        col = bg;    \n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 cu = normalize( cross(cw,-cp) );\n\tvec3 cv = normalize( cross(cu,-cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n\t// Camera\t\n\tvec3 ro = vec3(0.0, 1.0, -3.5);\n\tvec3 ta = vec3(0.0);\n    mat3 ca = setCamera(ro, ta);\n    vec3 rd = ca * normalize(vec3(uv.xy, 2.0));\n    \n    float t = trace(ro, rd);\n    //float fog = 1.0 / (1.0 + t * t * 0.1);\n    //vec3 fc = vec3(fog);\n    //fragColor = vec4(fc,1.0);\n    fragColor = vec4(t, t, t, 1.0);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 51, 51, 216], [218, 218, 257, 257, 340], [342, 342, 385, 385, 414], [416, 416, 439, 439, 460], [462, 462, 481, 481, 775], [777, 777, 798, 798, 969], [971, 971, 1034, 1034, 1252], [1254, 1254, 1287, 1287, 1729], [1731, 1731, 1762, 1762, 1845], [1847, 1847, 1878, 1878, 2239], [2241, 2241, 2282, 2282, 2465], [2467, 2467, 2524, 2524, 2962]], "test": "valid"}
{"id": "lstXDj", "name": "Segmented Bezier", "author": "akohdr", "description": "Temporally builds primitive line segments.  Includes quadratic Bezier approximated to straight sections.\nMouse sets Bezier control point, Mouse.x sets circle time offset.", "tags": ["2d", "bezier", "lines"], "likes": 35, "viewed": 955, "published": "Public", "date": "1462239869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Examples of generation and traversal of primitive line segments in interval 0<=t<=1\n\n// comment to hide output\n#define SHOW_GRN_LINES\n#define SHOW_BLU_LINES\n#define SHOW_CURSORS\n#define BLOOM\n\n#define RED vec4(1.,.5,0,1)\n#define GRN vec4(0,.5,0,1)\n#define BLU vec4(0,0,1,1)\n#define BLK vec4(0,0,0,1)\n\n#define PI  3.14159265358979\n#define PI2 6.28318530717858\n\nvec2 rot2D(vec2 p, float a) \n{\n    vec3 csa = vec3(cos(a),-sin(a),0);\n               csa.z = -csa.y;\n    return p * mat2( csa.xyzx);\n}\n\n           \n// convert (x,y) to polar coordinate (r,a)\nvec2 polar(vec2 p)\n{\n    float x = p.x,  \n          y = p.y,\n          a = atan(abs(y/x)),\n          r = sqrt(x*x+y*y);\n    \n    // quadrant adjustment\n    a = x>0. ? y>0. ?    a : PI2-a :\n               y>0. ? PI-a :  PI+a;\n                   \n\treturn vec2(r, a);    \n}\n\n\nvoid antialias(inout vec4 k, float d, float w)\n{\n    float w1 = max(.2,.5*w),\n          s  = w1/(d+2e-9);\n    \t  s += w1/(d-3e-9);\n    \n    k += vec4(1)*s;\n}\n\n\nfloat dLine(vec2 p, vec2 a, vec2 b) \n{\n    b -= a;  \n    p -= a;\n    return length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n}\n\n\nvec2 linePos(vec2 a,vec2 b, float t)\n{\n    vec2 d = a - b,\n         s = -d / d;\n    float g = s.y / s.x,\n          d1 = 1. - t;\n    vec2 l = g * d1 * d;\n    return b + l;\n}\n\n// temporal straight line t steps from a -> b\nfloat dLine(vec2 p, vec2 a, vec2 b, float t) \n{\n    return dLine(p, a, linePos(a,b,t));\n}\n\n// standard circle\nfloat dCircle(vec2 p, vec2 a, float r, float w)\n{\n    float w2 = w/2.,\n           l = length(p-a);\n    return (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n}\n\n\nvec2 cirPos(vec2 a, float r, float t)\n{\n    return a+r*vec2(cos(PI2*t),sin(PI2*t));\n}\n\n\n// circular arc (anti clockwise) t steps from s toward full circle\nfloat dCircle(vec2 p, vec2 a, float r, float w, float t, float s)\n{\n    vec2 pa = rot2D(p-a,PI2*s),\n        pol = polar(pa);\n    float l = length(pa),\n         w2 = w/2.;\n    \n    return (pol.x>r+w || pol.y > PI2*t) ? 1e9 : \n    \t\t(l>r) ? abs((l-r)+w2) : abs((r-l)-w2);\n}\n\n\n// optimized version of quadratic bezier curve position\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c) \n{\n    float mT = 1.-t;\n//    vec2 pos = a * 1.      * mT*mT +\n//               b * 2.* t   * mT    + \n//               c * 1.* t*t          ;\n    return a *           mT*mT +\n           b * 2.* t   * mT    + \n           c *     t*t          ;\n}\n\n\n// standard math version\nvec2 bzPos_Math(float t, vec2 a, vec2 b, vec2 c) {  \n    // b is control point a,c endpoints\n    \n    t = 1.-t;\n//    vec3 tv = vec3(1, t, t*t);   // forgot to reverse tv\n    vec3 tv = vec3(t*t, t, 1);\n    \n    const mat3 bz2D = mat3( 1, 0, 0,\n                           -2, 2, 0,\n                            1,-2, 1);\n\n    // pad mat3 since no 2x3 matrices\n    mat3 m_xy = mat3(a.x, b.x, c.x,\n                     a.y, b.y, c.y,\n                     0,   0,   0   );\n   \n\tvec3 v3 = tv * (bz2D * m_xy);\t// are padded mat3 op more efficient on GPU?\n    return v3.xy;\n}\n\n\n// bezier curve abc built from segments dt steps from a -> c\nfloat dBezierSegs(vec2 p, vec4 ac, vec2 b, float dt) {\n    float d = 9999.;\n    vec2 a = ac.xy, c = ac.zw, q = a, r;\n    \n    for(float t=0.; t<=1.; t+=.03) {\n        r = bzPos(t,a,b,c);\n        d = min(d, dLine(p,q,r));\n        q = r;\n        if(t>dt) return d;\n    }\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    float t = iTime,\n         st = .5-.5*cos(t),\n          w = 3.;\n    \n\tvec2 ir = iResolution.xy,\n          a = ir * vec2(.15),\n          b = ir * vec2(.8),\n          c = ir * vec2(.3,.8),\n         dx = ir * vec2(.3,0),\n//          q = iMouse.z>0. ? iMouse.xy : b;\n          q = iMouse.x>0. ? iMouse.xy : b;\n    float cs = q.x/ir.x;\n        \n    vec4 ka = BLK;\n#ifdef SHOW_GRN_LINES\n    // antialiases lines\n    antialias(ka, dBezierSegs(p,vec4(a,c),q,1.), w);\n    antialias(ka, dLine(p,a+dx,c+dx), w);\n    antialias(ka, dCircle(p, a+vec2(2,.5)*dx.xx, a.x,w), w);\n#endif \n    \n#ifdef BLOOM\n    w = max(2., 15.*st);\n#else\n    w = 2.;\n#endif\n    float w2 = w/2.;\n    \n    vec4 kt = BLK;\n#ifdef SHOW_BLU_LINES\n    // temporal lines\n    antialias(kt, dBezierSegs(p,vec4(a,c),q,st), w);\n    antialias(kt, dLine(p,a+dx,c+dx,st), w);\n    antialias(kt, dCircle(p, a+vec2(2,.5)*dx.xx, a.x+w2, w, st, cs), w);\n#endif \n    \n    vec4 kc = BLK;\n#ifdef SHOW_CURSORS\n    // cursor points\n    antialias(kc, dCircle(p, q, 2.,w), w);\n    antialias(kc, dCircle(p, bzPos(st, a, q, c), 2., w), w);\n    antialias(kc, dCircle(p, linePos(a+dx,c+dx, st), 2., w), w);\n    antialias(kc, dCircle(p, cirPos(a+vec2(2,.5)*dx.xx, a.x, st-cs), 2., w), w);\n#endif \n    \n\t// GRN line is fixed line primitive for interval 0<t<1\n    // BLU line temporal section for interval 0<t\n    k = mix(mix(GRN*ka,BLU*kt,.5),RED*kc,.5);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstXDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[491, 491, 521, 521, 625], [639, 682, 702, 702, 952], [955, 955, 1003, 1003, 1112], [1115, 1115, 1153, 1153, 1250], [1253, 1253, 1291, 1291, 1425], [1427, 1473, 1520, 1520, 1562], [1564, 1583, 1632, 1632, 1732], [1735, 1735, 1774, 1774, 1820], [1823, 1890, 1957, 1957, 2161], [2164, 2220, 2266, 2266, 2509], [2512, 2537, 2587, 2629, 3104], [3107, 3168, 3222, 3222, 3457], [3460, 3460, 3501, 3501, 4892]], "test": "error"}
{"id": "lsVSD1", "name": "wifa", "author": "lennyjpg", "description": "for wissensfabrik.ch", "tags": ["2d", "gadient"], "likes": 4, "viewed": 417, "published": "Public API", "date": "1464263859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 f ) {\n    vec2 uv = f.xy / iResolution.xy - 1.;\n    vec3 g =  mix(vec3(215, 95, 67), vec3(150, 196, 168), f.y / iResolution.y) / 255.;   \n    vec3 n = texture( iChannel0, 1. + uv, 7.0 * abs(1. + uv.y - .5) ).xyz;\n    vec3 m = mix(n, g, f.y / iResolution.y);\n    float x = (uv.x + 4. ) * (uv.y + 4. ) * iTime * 10.;\n    O = vec4(m*(g*.8)*2.,1.) + (mod((mod(x, 13.) + 1.) * (mod(x, 123.) + 1.), .01)-.005) * 5.;\n    if( uv.x > fract( abs( sin(iTime * .2) ) ) - .5 * 2.) O = texture(iChannel0, 1. + uv);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 538]], "test": "error"}
{"id": "lsVSDh", "name": "Spherical shader tutorial", "author": "WilstonOreo", "description": "This commented shader explains how transform the camera rays so that the output is rendered in equirectangular or fisheye format.  Can be used in domes or other immersive environments. Hold mouse for equirectangular view and move mouse to rotate camera. ", "tags": ["raymarching", "tutorial", "fisheye", "equirectangular"], "likes": 8, "viewed": 1428, "published": "Public API", "date": "1464186964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licensed under Creative Commons 3.0 Share Alike License\n// Based on dila's ray marching tutorial:\n// https://www.shadertoy.com/view/XdKGWm\n\n// (C) 2016-2017 by WilstonOreo http://omnido.me\n\n\n#define MAP_EQUIRECTANGULAR 0\n#define MAP_FISHEYE 1\n\n// Display equirectangular view when clicked.\n\nconst float speed = 0.5;\n\n\nint map_mode() {\n    return (iMouse.w > 0.0) ? MAP_EQUIRECTANGULAR : MAP_FISHEYE;\n}\n\n\n// Camera rotation with mouse\n\nfloat camera_yaw() {\n\treturn iMouse.x / iResolution.x * 360.0;\n}\n\nfloat camera_pitch() {\n\treturn iMouse.y / iResolution.y * 360.0;\n}\n\n\nconst float camera_roll = 0.0;\nconst float sphere_size = 0.25;\n\n\n//////////////////////////////////////////////////\n// Code section for spherical translation\n\nconst float PI = 3.14159265358979323846264;\n\n/// Convert degrees to radians\nfloat deg2rad(in float deg)\n{\n  return deg * PI / 180.0;\n}\n\n/// Calculates the rotation matrix of a rotation around X axis with an angle in radians\nmat3 rotateAroundX( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0,0.0,0.0,\n              0.0,  c, -s,\n              0.0,  s,  c);\n}\n\n// Calculates the rotation matrix of a rotation around Y axis with an angle in radians\nmat3 rotateAroundY( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c,0.0,  s,\n              0.0,1.0,0.0,\n               -s,0.0,  c);\n}\n\n// Calculates the rotation matrix of a rotation around Z axis with an angle in radians\nmat3 rotateAroundZ( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c, -s,0.0,\n                s,  c,0.0,\n              0.0,0.0,1.0);\n}\n\n// Calculate rotation by given yaw and pitch angles (in degrees!)\nmat3 rotationMatrix(in float yaw, in float pitch, in float roll)\n{\n  return rotateAroundZ(deg2rad(yaw)) *\n         rotateAroundY(deg2rad(-pitch)) *\n         rotateAroundX(deg2rad(roll));\n}\n\n// Get fisheye camera ray from screen coordinates\n#ifdef MAP_FISHEYE\nfloat fisheye_direction(out vec3 rd)\n{\n  // Move screen coordinates to the center, so\n  // it is bound to [-0.5,-0.5] and [0.5,0.5]\n  vec2 uv = gl_FragCoord.xy / iResolution.xy - vec2(0.5);\n  \n  // Calculate polar coordinates (angle phi and length)\n  float phi = atan(uv.x,uv.y);\n  float l = length(uv);\n\n  if (l > 0.5)\n  {\n  \t// Return -1.0 because the calculated polar coordinates are \n  \t// outside the half sphere\n    return -1.0;\n  }\n  \n  // Calculate ray direction\n  float theta  = l * PI;\n  rd = normalize(vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));\n  \n  // Formulas are on wikipedia:\n  // https://en.wikipedia.org/wiki/Polar_coordinate_system\n  return 1.0;\n}\n#endif\n\n\n// Calculate camera ray in equirectangular direction from screen coordinates\n#ifdef MAP_EQUIRECTANGULAR\nfloat equirectangular_direction(out vec3 rd)\n{\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  // Calculate azimuthal and polar angles from screen coordinates\n  float theta =  uv.t * PI,\n        phi =  uv.s * 2.0 * PI;\n        \n  // Calculate ray directions from polar and azimuthal angle\n  rd = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n  \n  // formulas are on wikipedia:\n  // https://en.wikipedia.org/wiki/Spherical_coordinate_system\t\n  return 1.0;\n}\n#endif\n\n\n// Calculate camera ray direction in equirectangular\nfloat direction(out vec3 rd)\n{\n  // Select mapping mode based on input parameter\n#ifdef MAP_EQUIRECTANGULAR\n  if (map_mode() == MAP_EQUIRECTANGULAR)\n  {\n    return equirectangular_direction(rd);\n  }\n#endif\n#ifdef MAP_FISHEYE\n  if (map_mode() == MAP_FISHEYE)\n  {\n    return fisheye_direction(rd);\n  }\n#endif\n  return -1.0;\n}\n\n\n// Calculate camera ray with rotation\nfloat direction(float roll, float pitch, float yaw, out vec3 rd)\n{\n  if (direction(rd) < 0.0)\n  {\n    return -1.0;\n  }\n  // Rotate the ray direction to have camera rotation with\n  // pitch, yaw and roll angles\n  rd *= rotateAroundZ(yaw)*rotateAroundY(pitch)*rotateAroundX(roll);\n  return 1.0;\n}\n\n// END Code section for spherical translation\n//////////////////////////////////////////////////\n\n\n\n//////////////////////////////////////////////////\n// Code section from dila's raymarch tutorial\n\n\n// Output resolution\n\n// Current TIME\n\n//map function, core of all the ray marching shaders. They return a scalar value, given a 3D point.\nfloat map(vec3 p){\n    //instancing:\n    // you transform the space so it's a repeating coordinate system\n    vec3 q = fract(p) * 2.0 -1.0;\n    \n  \t//sphere map function is the length of the point minus the radius\n    //it's negative on the inside of the sphere and positive on the outside and 0 on the surface.\n    float radius = sphere_size;\n \treturn length(q) - radius;   \n}\n\n//we use a numerical marching algorithim called trace\n//o = origin\n//r = ray to march along\n//t = intersection along the ray\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for (int i =0; i <32; i++){\n        //origin + ray*t = where we are along the ray;\n        // we step along the ray in variable length segments, \n     \tvec3 p = o+r*t;   \n        //until we gradual converge on the intersection and evaluate the map function at that point\n        float d=map(p);\n        //we add that to t\n        // the smaller the 0.5 value, the less accurate the map function is\n        t += d * 0.5;\t\n    }\n     return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //////////////////////////////////////// \n    // This commented out code section explains how setup\n    // a camera ray for standard perspective camera.\n    // For a fisheye or equirectangular camera, this is different.\n    // The calculation is done in the equirectangular_direction or \n    // fisheye_direction function.\n\t// vec2 uv = fragCoord.xy / iResolution.xy;\n    //transform the cordinates to -1 to 1, instead of 0 to 1\n    // uv = uv * 2.0 - 1.0;\n    // correct the aspect ratio\n    // uv.x *= iResolution.x / iResolution.y;\n        \n    //r = ray\n    // it needs to be normalized so it doesn't poke through the geometry when it's really close to the camera\n    //the z cordinate is 1.0, that's how you project the 2D coordinate into 3D space, \n    //you just decide the z value, which determines the field of view of the camera\n    // smaller z = higher fov. 1.0 = 90 degrees\n    //vec3 r = normalize(vec3(uv,1.0));\n    \n    //rotation around the y axis\n    //you have to look up on wikipedia what this is\n    // float the= iTime*.25;\n    //r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    // END of commented out section for generating a perspective view camera ray\n    //////////////////////////////////////// \n\n    // Spherical ray generation code\n    // This is entry point where the generation of \n    // camera ray in spherical direction happens! \n    /////////////////////////////////////////////////\n    vec3 r;\n    // Calculate ray direction with camera rotation\n    if (direction(\n    \t\tdeg2rad(camera_roll),\n    \t\tdeg2rad(camera_pitch()),\n    \t\tdeg2rad(camera_yaw()),r) != 1.0) {\n    \t// Transparent pixel if ray direction is not valid for screen coordinates\n    \tfragColor = vec4(0.0,0.0,0.0,0.0);\n    \treturn;\n    }\n \n    // the sphere is at (0.0,0.0,0.0)\n    vec3 o = vec3(0.0,0.0, iTime);\n    \n    //trace from the origin along the ray to find the intersection from our map function\n    float t = trace(o, r);\n    // simple fogging funcition to darken things the further away they are\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSDh.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[321, 321, 337, 337, 404], [438, 438, 458, 458, 502], [504, 504, 526, 526, 570], [777, 808, 837, 837, 866], [868, 956, 994, 994, 1126], [1128, 1215, 1253, 1253, 1385], [1387, 1474, 1512, 1512, 1644], [1646, 1712, 1778, 1778, 1900], [3253, 3306, 3336, 3386, 3629], [3632, 3670, 3736, 3736, 3964], [4204, 4304, 4322, 4409, 4681], [4683, 4808, 4836, 4836, 5303], [5305, 5305, 5362, 6796, 7495]], "test": "valid"}
{"id": "lsVSDW", "name": "Radiolarian seamless loop", "author": "udart", "description": "Based on this model:\nhttps://www.shadertoy.com/view/Mdt3RX", "tags": ["raycasting", "animation", "loop"], "likes": 2, "viewed": 160, "published": "Public", "date": "1464546642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\n#define t iTime\n\n#define EXO_SPIKE 1.\n\n\nvec2 rot2D(vec2 p, float angle) {\n\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n        \n    \n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nvec3 pModDodecahedron(inout vec3 p) {\n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    p.z = abs(p.z);\n    \n    pR(p.xz, -halfDdihedral);\n    pR(p.xy, faceAngle / 4.);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n    \n    return p;\n}\n\nvec3 pModIcosahedron(inout vec3 p) {\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float sides = 3.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n\n    p.z = abs(p.z);    \n    pR(p.yz, halfDdihedral);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n     \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n  \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n\n\treturn p;\n}\n\nfloat spikeModel(vec3 p, float spikeLen) {\n    pR(p.zy, PI/2.);\n    return fCone(p, 0.25, spikeLen);\n}\n\nfloat spikesModel(vec3 p, float spikeLen) {\n    float smoother = 0.6;\n    \n    pModDodecahedron(p);\n    \n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    float spikeA = spikeModel(p, spikeLen);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = spikeModel(p, spikeLen);\n\n    pR(p.xy, -faceAngle);\n    pR(p.zy, dihedral);\n    \n    float spikeC = spikeModel(p, spikeLen);\n    \n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            smoother\n       \t),\n        smoother\n   \t);\n}\n\n\nfloat exoHolesModel(vec3 p, float dist) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += dist;\n    return length(p) - 2.2;\n}\n\nfloat coreModel(vec3 p, float interval) {\n    float outerInterval = min(interval*1.02,2.5);\n    outerInterval = interval > 6.5 ? 0.0001 : outerInterval;\n    float outer = length(p) - outerInterval;\n    \n    float thickness = 0.28;\n    float inner = outer + thickness;\n    \n    float spikeLength = 1.0 + interval;\n    float spikeLFinish = interval > 7.2 ? 1.0 : 3.0 - interval/3.0;\n    spikeLength = interval > 3.0 ? spikeLFinish : spikeLength;\n\tfloat spikes = spikesModel(p, spikeLength);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n    \n    float shell = max(-inner, outer);\n\n    float dist = 6.0 - interval/2.0;\n    dist = interval > 6.5 ? 6.0 : dist;\n    float holes = exoHolesModel(p, dist);\n\tshell = fOpIntersectionRound(-holes, shell, thickness/2.0);\n\n\treturn shell;\n}\n\n\n\n// Based on Template 3D by iq: https://www.shadertoy.com/view/ldfSWs\n\nfloat doModel(vec3 p) {\n    float interval = 9.0 - mod(iTime*3.0, 9.0);\nfloat intervalPhase = 9.0 - mod(iTime*3.0+4.5, 9.0);\n\n    \n    p.y -= 2.5;\n       \n    p.xz = rot2D(p.xz, interval * 180.0 / 9.0);\n    \n    float core = coreModel(p, interval);\n    float core2 = coreModel(p, intervalPhase);\n    return min(core, core2);\n\t//return core;\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float an = 10.0 * mouse.x + PI / 2.;\n    //an = 10.;\n\n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - mouse.y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(mouse.y * PI / 2.),\n        cos(an)\n    ) * d;\n\n   \tcamTar = vec3(0);\n}\n\n\n\nvec3 doMaterial(in vec3 pos, in vec3 nor) {\n    return vec3(0.85, 0.85, 0.9);\n}\n\n\nfloat doRulerModel(vec3 p) {\n    return 1000.0;\n    float t = 0.1;\n    return abs(p.y) - mod(t/5., 1.);\n}\n\nfloat rule(float d, float scale) {\n    return mix(1., .35, smoothstep(.6, 1., abs(fract(d * scale) * 2. - 1.)));\n}\n\nvec3 rulerColor(float t) {\n    t = clamp(log(t+1.0), 0.0, 1.0);\n    return mix(mix(vec3(0.,.1,1.), vec3(1.,.1,0.), t*5.), vec3(1.0), smoothstep(.2,.5,t));\n}\n\nvec3 doRulerMaterial(vec3 p, float d, float t) {\n    float lt = log(t) / log(10.0);\n    float s = pow(10.0, -floor(lt));\n    float m = smoothstep(0.0, 0.33, fract(lt));\n    float r = rule(d, s * 10.) * mix(rule(d, s * 100.0), rule(d, s), m);\n    return mix(rulerColor(s * d), rulerColor(s * d * 0.1), m) * 0.8 * r;\n}\n\nfloat doCombinedModels(vec3 p) {\n    return min(doModel(p), doRulerModel(p));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd);\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    //vec3 lig = normalize(vec3(1.1, 0.7, 0.9));\n    vec3 lig = normalize(vec3(0.0,1.0,0.8)); \n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0;\n    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n    lin += dif * vec3(2.) * sha;\n\n    // ambient light\n    //-----------------------------\n    //lin += vec3(0.5);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal * lin;\n\n    // fog\n    //-----------------------------\n    //col *= exp(-0.01 * dis * dis);\n\n    //Specular\n    float nrm = (60.0 + 8.0) / (3.1415 * 8.0);\n    col += pow(max(dot(reflect(rd,nor),lig),0.0),60.0) * nrm;\n \n//////experiment\n    \n    float fresnel = 1.0 - max(dot(nor,rd),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n    \n    //sky color\n\tvec3 e = reflect(rd,nor);\n    \n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    //Reflected\n    vec3 reflected = ret*0.1;\n\n    //color\n    vec3 base = vec3(0.01,0.01,0.01);\n    vec3 scolor = vec3(0.01,0.01,0.01);\n\n    float diffuse = pow(dot(nor,lig) * 0.4 + 0.6,80.0)*200.0;\n  \t\n    //Refracted\n    vec3 refracted = base + diffuse * scolor * 0.32 * lin + col*1.4; \n    \n\t//Experiment - overwrite color\n\tcol = mix(refracted,reflected,fresnel);    \n    \n    //col = vec3(reflected);\n    \n    \n    return col;\n}\n\nvec3 calcIntersection(in vec3 ro, in vec3 rd) {\n    const float maxd = 10.0;    // max trace distance\n    const float precis = 0.00001; // precission of the intersection\n    vec3 p;\n    float h = precis * 2.0;\n    float d, r;\n    float t = 0.0;\n    float res = -1.0;\n    for (int i = 0; i < 70; i++) // max number of raymarching iterations is 90\n    {\n        if (h < precis || t > maxd) break;\n        p = ro + rd * t;\n        r = doRulerModel(p);\n        d = doModel(p);\n        h = min(d, r);\n        t += h;\n    }\n\n    if (t < maxd) res = t;\n    return vec3(res, r < d ? 1.0 : 0.0, d);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float eps = 0.002; // precision of the normal computation\n\n    const vec3 v1 = vec3(1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3(1.0, 1.0, 1.0);\n\n    return normalize(v1 * doCombinedModels(pos + v1 * eps) + \n                     v2 * doCombinedModels(pos + v2 * eps) +\n                     v3 * doCombinedModels(pos + v3 * eps) + \n                     v4 * doCombinedModels(pos + v4 * eps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.5; // selfintersection avoidance distance\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps\n        h = doModel(ro + rd * t);\n        res = min(res, 4.0 * h / t); // 64 is the hardness of the shadows\n        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n          float circle(in vec2 _st, in float _radius, float gradient){\n              vec2 dist = _st-vec2(0.5);\n            return 1.-smoothstep(_radius-(_radius*gradient),\n                                   _radius+(_radius*gradient),\n                                   dot(dist,dist)*4.0);\n          }\n\n          vec3 radialGradient(vec2 st, float radius, float gradientWidth, vec3 innerColor, vec3 outerColor) {\n              float circleMix = circle(st,radius, gradientWidth);\n            return mix(outerColor, innerColor, circleMix);\n          }\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 realUv = uv;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3;\n        \n    // ray\n    //vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);   \n    vec3 ang = vec3(0.0, 0.3, 0.0);\n    vec3 ori = vec3(0.0,4.5, 7.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n\n    //\n \n    vec3 color = radialGradient(realUv, 0.3, 3.5,vec3(1.0, 0.97, 0.95), vec3(0.5, 0.49, 0.475));\n\n    vec3 t = calcIntersection(ori, dir);\n    if (t.x > -0.5) {\n        // geometry\n        vec3 pos = ori + t.x * dir;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal;\n        if (t.y > 0.) {\n            mal = doRulerMaterial(pos, t.z, t.x);\n        \t//mal = doLighting(pos, nor, rd, t.x, mal);\n        } else {\n            mal = doMaterial(pos, nor);\n        }\n        \n        color = doLighting(pos, nor, dir, t.x, mal);\n    }\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 129, 129, 253], [269, 269, 324, 324, 459], [461, 557, 606, 606, 1105], [1107, 1135, 1197, 1197, 1303], [1305, 1543, 1575, 1575, 1617], [1619, 1698, 1746, 1746, 1877], [1879, 1992, 2042, 2042, 2432], [2435, 2435, 2472, 2472, 3337], [3339, 3339, 3375, 3375, 4200], [4202, 4202, 4244, 4244, 4304], [4306, 4306, 4349, 4349, 5033], [5036, 5036, 5077, 5077, 5169], [5171, 5171, 5212, 5212, 5948], [6022, 6022, 6045, 6045, 6364], [6366, 6366, 6445, 6445, 6705], [6709, 6709, 6752, 6752, 6788], [6791, 6791, 6819, 6819, 6896], [6898, 6898, 6932, 6932, 7012], [7014, 7014, 7040, 7040, 7170], [7172, 7172, 7220, 7220, 7488], [7490, 7490, 7522, 7522, 7569], [7618, 7618, 7700, 7700, 9140], [9142, 9142, 9189, 9189, 9733], [9735, 9735, 9765, 9765, 10253], [10255, 10255, 10301, 10301, 10711], [10713, 10713, 10775, 10775, 10949], [10951, 10959, 10985, 10985, 11331], [11343, 11343, 11403, 11403, 11636], [11648, 11648, 11747, 11747, 11884], [11886, 11894, 11951, 11951, 13026]], "test": "valid"}
{"id": "lsVSR1", "name": "innovati random 2", "author": "xem", "description": "random", "tags": ["random"], "likes": 1, "viewed": 418, "published": "Public API", "date": "1462991547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Paste this code in shadertoy.com/new\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = vec4((mod(max(radians((iMouse.y / iResolution.y)), float(iFrame)), ((gl_FragCoord.x / iResolution.x) - atan(1.6, 0.7))) * (0.2 - 1.4)), 1.9, float(iFrame), 0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 95, 95, 273]], "test": "valid"}
{"id": "lsVSRR", "name": "Barnsley's fractal", "author": "tgb", "description": "https://www.reddit.com/r/fractals/comments/4i68yu/what_fractal_is_this_image/ attempted recreation", "tags": ["2d", "fractal"], "likes": 1, "viewed": 123, "published": "Public", "date": "1462564483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst vec4 color = vec4(0.3, 0.8, 0.7, 1.0);\n\n\n\n// Complex multiplication\nvec2 mult(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 f(vec2 z, vec2 inv_k) {\n    z.x += -2.0*float(z.x >= 0.0) + 1.0;\n    return mult(z, inv_k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 k = vec2(0.45+0.05*cos(iTime*0.123), 0.5+0.1*sin(iTime*1.0));\n\tvec2 inv_k = vec2(k.x, k.y)/(length(k)*length(k));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 z = vec2(uv.x-0.5, uv.y-0.5)*1.0;\n   \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    int I = 0;\n    for(int i = 0; i < 300; i++) {\n        z = f(z, inv_k);\n        \n        if(dot(z,z) > 1e5) {break;}\n        I = i;\n    }\n    \n    fragColor = color*float(I)/200.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 76, 103, 103, 168], [170, 170, 198, 198, 268], [270, 270, 327, 327, 783]], "test": "valid"}
{"id": "lsVSRW", "name": "Dusty nebula 3", "author": "Duke", "description": "Based on [url=https://www.shadertoy.com/view/MdtGRl]Protoplanetary disk[/url], otaviogood's [url=https://www.shadertoy.com/view/ld2SzK]Alien Beacon[/url]\nand Shane's [url=https://www.shadertoy.com/view/Xsc3R4]Cheap Cloud Flythrough[/url] shaders.", "tags": ["cloud", "star", "space", "nebula", "dust"], "likes": 46, "viewed": 3320, "published": "Public API", "date": "1463266791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Dusty nebula 3\" by Duke\n//-------------------------------------------------------------------------------------\n// Based on \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------------\n\n#define ROTATION\n\n//#define MOUSE_CAMERA_CONTROL\n\n#define DITHERING\n#define BACKGROUND\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(vec3 p)\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//=====================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat Nebulae(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n   #ifdef ROTATION\n   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n   #endif\n   p.y+=4.1;\n   return Nebulae(p) + fbm(p*50.+iTime);\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/1.30, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 20.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*2.);\n    R(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*2.);\n    R(ro.xz, iMouse.x*0.01*pi*2.);\n    #else\n    R(rd.yz, -pi*3.93);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.93);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n   \t// randomizing the length \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03);\n\t#endif \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<64; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n        if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t    \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.08);\n      \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.0));\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\t\t\n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.185;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n       \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // star in center\n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        sum.rgb+=lightColor/(lDist*lDist*6.); //add a bloom around the light\n\n        sum.a *= 0.8;\n        \n        // enforce minimum stepsize\n        d = max(d, 0.1); \n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        d=abs(d)*(1.+0.2*rand(seed*vec2(i)));\n        #endif \n\t  \n        //t += max(d * 0.25, 0.02);\n        t += max(d * 0.1 * max(length(ldst),2.0), 0.02);\n      \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n    \n   fragColor = vec4(sum.xyz,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSRW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-2.0", "functions": [[794, 808, 834, 834, 1053], [1055, 1055, 1074, 1074, 1163], [1165, 1165, 1186, 1186, 1257], [1259, 1900, 1928, 1928, 2477], [2479, 2479, 2508, 2508, 2756], [2758, 2758, 2781, 2781, 2970], [2972, 2972, 2992, 2992, 3118], [3120, 3149, 3199, 3284, 3556], [3558, 3558, 3634, 3634, 3851], [3853, 3853, 3910, 3910, 7292]], "test": "error"}
{"id": "lsVSWz", "name": "Another Voronoi", "author": "Zavie", "description": "A Voronoi / Worley implementation, based upon the legions of experiments by IQ and Fabrice Neyret. The randomness changes vertically, and the distance used evolves horizontally. They can be controlled with the mouse.", "tags": ["voronoi", "noise", "worley", "distance", "cells"], "likes": 11, "viewed": 889, "published": "Public API", "date": "1463915249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nA Voronoi implementation, featuring some of the tricks seen\nin other shaders.\n\n--\nZavie\n\n*/\n\nfloat hash(float x) { return fract(sin(x) * 43758.5453); }\nfloat hash(vec2 xy) { return fract(sin(dot(xy, vec2(12.9898, 78.233))) * 43758.5453); }\nvec2 hash2(vec2 xy) { return fract(sin(vec2(dot(xy, vec2(127.1,311.7)), dot(xy, vec2(269.5,183.3)))) * 43758.5453); }\n\nstruct VoronoiInfo\n{\n    float f1;\n    float f2;\n    float f3;\n    float f4;\n    float id;\n    vec2 pos;\n};\n\nVoronoiInfo Voronoi(vec2 p, float frequency, float randomness, float norm)\n{\n    p *= frequency;\n    vec2 p0 = floor(p);\n    float f1 = 1e30;\n    float f2 = 1e30;\n    float f3 = 1e30;\n    float f4 = 1e30;\n    float id = -1.;\n    vec2 pos = vec2(0.);\n\n    for (int j = -1; j <= 1; ++j)\n    for (int i = -1; i <= 1; ++i)\n    {\n        vec2 p_i = p0 + vec2(float(i), float(j));\n        vec2 cellOrigin = p_i + mix(vec2(0.5), hash2(p_i), randomness);\n        float cellId = hash(p_i);\n\n        vec2 delta = abs(cellOrigin - p);\n        float d1 = delta.x + delta.y;\t\t\t\t// Manhattan\n        float d2 = length(delta);\t\t\t\t\t// Euclid\n        float dInfinite = max(delta.x, delta.y);\t// Chebychev\n\n        float d = 0.;\n        if (norm <= 1.)      d = mix(d1, d2, norm);\n        else if (norm <= 2.) d = mix(d2, dInfinite, norm - 1.);\n        else if (norm <= 3.) d = mix(dInfinite, d1, norm - 2.);\n\n        if (d < f1)\n        {\n            f4 = f3;\n            f3 = f2;\n            f2 = f1;\n            f1 = d;\n            id = cellId;\n            pos = cellOrigin;\n        }\n        else if (d < f2)\n        {\n            f4 = f3;\n            f3 = f2;\n            f2 = d;\n        }\n        else if (d < f3)\n        {\n            f4 = f3;\n            f3 = d;\n        }\n        else if (d < f4)\n        {\n            f4 = d;\n        }\n    }\n\treturn VoronoiInfo(f1, f2, f3, f4, id, pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float randomness = mix(0.2, 1., smoothstep(0., 1., abs(2. * fract(0.2*iTime + 0.5*uv.y) - 1.)));\n    float norm = 3. * fract(-uv.x + 0.5*iTime);\n    \n    if (iMouse.z > 0.)\n    {\n        randomness = iMouse.y / iResolution.y;\n        norm = 3. * iMouse.x / iResolution.x;\n    }\n    VoronoiInfo vi = Voronoi(uv, 10., randomness, norm);\n    \n    vec3 red = vec3(0.698, 0., 0.082);\n    vec3 green = vec3(0.129, 0.612, 0.);\n    vec3 baseColor = mix(red, green, vi.id);\n    float cellDot = smoothstep(0.05, 0.1, length(10.*uv - vi.pos));\n\n    fragColor = vec4(mix(vec3(1.), baseColor, pow(vi.f2 - vi.f1, 0.2)) * cellDot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 118, 118, 155], [156, 156, 177, 177, 243], [244, 244, 265, 265, 361], [472, 472, 548, 548, 1853], [1855, 1855, 1912, 1912, 2581]], "test": "valid"}
{"id": "lsVSz1", "name": "Bioscan: Lifeform Detected", "author": "innovati", "description": "Stop right there galactic scum, it's time to subject yourself to a bioscan.", "tags": ["bars", "scanning"], "likes": 0, "viewed": 90, "published": "Public", "date": "1463005346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = mod(degrees(step(sin(vec4(reflect((gl_FragCoord.x / iResolution.x), 1.6), 0.7, 1.1, (gl_FragCoord.y / iResolution.y))), max(exp2(vec4((inversesqrt(0.4) - 0.4), min(0.7, float(iFrame)), 0.3, 1.0)), floor(mod(exp(vec4(1.8, min(0.6, 1.2), (0.7 / 0.2), float(iFrame))), inversesqrt(asin(log2(max(min(asin(pow(log(log(atan(vec4((1.6 * (gl_FragCoord.x / iResolution.x)), 0.7, 1.9, 0.9)))), vec4(0.1, 1.5, iTime, max(0.0, (gl_FragCoord.y / iResolution.y))))), atan(atan(vec4(((gl_FragCoord.y / iResolution.y) - 1.8), 0.5, (1.1 * 0.2), 0.2), log(vec4(float(iFrame), 0.9, (gl_FragCoord.y / iResolution.y), ((gl_FragCoord.y / iResolution.y) + (1.3 + 0.0))))), vec4((gl_FragCoord.x / iResolution.x), (gl_FragCoord.y / iResolution.y), iTime, 1.4))), vec4(0.8, 0.3, (1.9 / (0.4 + (sqrt(1.5) / 1.2))), (1.5 - (0.8 - ((gl_FragCoord.x / iResolution.x) / 0.7))))))))))))), abs(pow(atan(floor(exp2(vec4(1.6, 1.9, 0.8, 1.6))), vec4((gl_FragCoord.x / iResolution.x), 0.2, float(iFrame), (gl_FragCoord.x / iResolution.x))), atan(vec4(0.5, (1.4 / 0.6), 0.5, 0.5), reflect(exp2(reflect(vec4(pow(reflect((max((0.1 + (gl_FragCoord.x / iResolution.x)), 1.8) + 1.8), (gl_FragCoord.y / iResolution.y)), 0.6), 0.0, ((gl_FragCoord.x / iResolution.x) * (1.5 / step((gl_FragCoord.x / iResolution.x), 1.3))), 1.7), pow(reflect(vec4(0.4, 0.1, 1.7, (gl_FragCoord.x / iResolution.x)), vec4((float(iFrame) * float(iFrame)), iTime, 0.9, 1.8)), reflect(exp(vec4((gl_FragCoord.x / iResolution.x), 1.1, 0.7, 0.2)), cos(atan(mod(vec4(float(iFrame), pow((float(iFrame) + 1.5), log(((0.5 * 1.2) / 0.3))), 0.7, 1.8), vec4(0.6, 0.4, ((gl_FragCoord.y / iResolution.y) * 1.1), 1.3)))))))), min(cos(sqrt(vec4(1.8, 1.2, iTime, 0.9))), sqrt(inversesqrt(step(vec4(1.4, 0.8, 0.4, 1.3), min(normalize(radians(vec4(0.0, exp(1.2), 1.5, 1.8))), vec4(0.7, 1.3, 0.5, 0.2)))))))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "timedout"}
{"id": "lsVXDR", "name": "Creepy Forest", "author": "zackpudil", "description": "My first attempt at mixing volumetric ray casting and sphere tracing.", "tags": ["raymarching", "distancefields", "volumetric"], "likes": 6, "viewed": 333, "published": "Public", "date": "1463895587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvec2 hash(vec2 n) {\n\tvec2 x = vec2(\n\t\tdot(n, vec2(171.0, 311.0)),\n\t\tdot(n, vec2(269.0, 382.0)));\n\t\n\treturn fract(sin(x)*43578.5453);\n}\n\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\t\n\treturn mix(\n\t\tmix(\n\t\t\tmix(hash(n + 000.0), hash(n + 001.0), f.x),\n\t\t\tmix(hash(n + 057.0), hash(n + 058.0), f.x),\n\t\t\tf.y),\n\t\tmix(\n\t\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\t\n\tf += 0.5000*noise(p); p *= m3*2.03;\n\tf += 0.2500*noise(p); p *= m3*2.07;\n\tf += 0.1250*noise(p); p *= m3*2.01;\n\tf += 0.0625*noise(p);\n\tf /= 0.9375;\n\t\n\treturn f;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat res = exp(-a*k) + exp(-b*k);\n\t\n\treturn -log(res)/k;\n}\n\nfloat volume(vec3 p) {\n\tfloat d = -p.y - 1.2;\n\td = clamp(d + 1.0*fbm(2.0*p + 0.2*iTime), 0.0, 1.0);\n\treturn d;\n}\n\nvec4 volumetric(vec3 ro, vec3 rd, float md, vec2 p) {\n\tfloat s = 0.05, t = 0.0;\n\tvec4 sum = vec4(0);\n\t\n\tt += 0.1*hash(p).x;\n\t\n\tfor(int i = 0; i < 100; i++) {\n\t\tif(sum.a > 0.99) continue;\n\t\tif(t > md) continue;\n\t\t\n\t\tfloat d = volume(ro + rd*t);\n\t\t\n\t\tvec4 vol = vec4(mix(vec3(0.7), vec3(1.0), d), d);\n\t\tvol.rgb = mix(vol.rgb, vec3(0), 1.0 - exp(-0.6*t));\n\t\t\n        vol.a *= 0.3;\n\t\tvol.rgb *= vol.a;\n\t\tsum += vol*(1.0 - sum.a);\n\t\t\n\t\tt += s;\n\t}\n\t\n\treturn clamp(sum, 0.0, 1.0);\n}\n\nfloat map(vec3 p) {\n\tvec3 q = p;\n\t\n\tq.z += 30.0;\n\tq = q + noise(q);\n\tfloat n = dot(cos(q*PI/2.0), sin(q.yzx*PI/2.0));\n\tfloat s =  .45 - .45*n + 0.2*fbm(10.0*p) - 0.2*smoothstep(0.1, 1.0, noise(3.0*p))*fbm(50.0*p);\n\t\n\treturn smin(p.y + 1.2, s, 10.0);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\t\n\tfor(int i = 0; i < 50; i++) {\n\t\tfloat h = map(ro + rd*t);\n\t\tif(abs(h) < 0.001 || t >= 10.0) break;\n\t\tt += h*0.75;\n\t}\n\t\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\t\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat s = 0.005;\n\tfloat t = s;\n\t\n\tfloat o = 0.0;\n\tfloat w = 1.0;\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tfloat h = map(p + n*t);\n\t\t\n\t\to += (t - h)*w;\n\t\tw *= 0.95;\n\t\t\n\t\tt += s;\n\t}\n\t\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n\tvec3 ww = normalize(lat - eye);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\t\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n    \n\tvec3 col = vec3(0);\n\t\n\tvec3 ro = vec3(iTime*0.4, -0.4 - 0.01*sin(9.0*iTime), -4.0);\n    float x = smoothstep(-1.0, 1.0, 2.0*cos(iTime))*sign(cos(0.5*iTime));\n\tvec3 rd = normalize(camera(ro, ro + vec3(1.0, 0, x))*vec3(uv, 1.97));\n\t\n\tfloat i = march(ro, rd);\n\t\n\tif(i < 10.0) {\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\t\t\n\t\tvec3 rig = vec3(0, .5, 0);\n\t\tvec3 lig = normalize(pos - rig);\n\t\t\n\t\tcol  = 0.3*vec3(1);\n\t\tcol += 0.8*clamp(dot(lig, nor), 0.0, 1.0)*vec3(1);\n\t\t\n\t\tvec3 mat= mix(vec3(0.62, 0.32, 0.17), vec3(0.0), fbm(10.0*pos*vec3(1.77, 0, 2.0)));\n        mat = mix(mat, vec3(0.2, 0.55, 0.2), smoothstep(0.4, 1.0, noise(3.0*pos)));\n\t\t\n\t\tcol *= mat;\n\t\tcol *= ao(pos, nor);\n\t}\n\t\n\tvec4 vol = volumetric(ro, rd, i, uv);\n\tcol = mix(col, vec3(0), 1.0 - exp(-0.39*i));\n\tcol = mix(col, smoothstep(0.0, 1.0, vol.rgb), vol.a);\n\tcol = pow(col, vec3(.454545));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 154], [156, 156, 177, 177, 213], [215, 215, 236, 236, 586], [703, 703, 722, 722, 903], [905, 905, 944, 944, 1005], [1007, 1007, 1029, 1029, 1119], [1121, 1121, 1174, 1174, 1596], [1598, 1598, 1617, 1617, 1849], [1851, 1851, 1882, 1882, 2033], [2035, 2035, 2056, 2056, 2234], [2236, 2236, 2262, 2262, 2475], [2477, 2477, 2510, 2510, 2658], [2660, 2660, 2717, 2717, 3705]], "test": "valid"}
{"id": "lsVXR1", "name": "Khronos logo remixed", "author": "jimbo00000", "description": "Unauthorized remix of the Khronos logo.", "tags": ["2d", "logo", "webgl", "opengl", "khronos"], "likes": 2, "viewed": 463, "published": "Public API", "date": "1463103596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Join or start your local Khronos chapter!\n\n#define PI 3.1415926535897932384\n\n// Trefoil shape from iq\n// http://www.iquilezles.org/www/articles/distance/distance.htm\nfloat dFunc( in float r, in float a )\n{\n    a -= .54;\n    if (a > 2.2)\n        return 9999.0;\n    a -= 2.;\n    \n\tfloat num = .5;\n\tfloat sweep = -.05;\n\tfloat pointy = 2.5+.1*sin(4.*iTime);\n    float phase = .5+PI*.85*(1.-PI*.45*fract(.25*iTime));\n        //.5+.25*sin(1.*iTime)\n    float amp = .1*(1.+(sin(2.*iTime)));\n    r += //amp*(3.+2.)*\n        clamp(1.-.5*abs(3.*(5.*a+4.*(\n\t\tphase\n    \t))),0., 1.);\n\treturn r - 1.0 - pointy*sin( num*a + 1.-sweep*(r) );\n}\n\nfloat polarFunc(in vec2 pt, in vec2 cent)\n{\n\tfloat r = 2.7 * length( pt - cent );\n\tfloat a = atan( pt.y, pt.x );\n\tfloat d = dFunc( r, a );\n    return smoothstep( 0.19, 0.22, abs(d) );\n}\n\n// Convert {uv, center} pair to polar coords {r, theta}\n// and pass them on to dist func\nfloat getDist( in vec2 pt, in vec2 cent )\n{\n    pt *= vec2(.45, -.8);\n    float t = 2.*iTime;\n    vec2 shift = vec2(.2,-.38) + vec2(.03,.01)*vec2(sin(t), cos(t));\n    return min(\n        polarFunc(pt-shift, cent),\n        polarFunc(-pt-shift, cent)\n        );\n}\n\n\n// Ripped off from: https://www.shadertoy.com/view/XsXXRN\nfloat rand(vec2 n) {\n    return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 4; i++) {\n        total += noise(n) * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nvoid fire301( out vec4 fragColor, in vec2 fragCoord ) {\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.0, 0.0);\n    const vec3 c3 = vec3(0.2, 0.0, 0.0);\n    const vec3 c4 = vec3(1.0, 0.9, 0.0);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.7, 0.4);\n    float shift = 1.6;\n    float alpha = 1.0;\n\n    vec2 p = fragCoord.xy * 8.0 / iResolution.xx;\n    float q = fbm(p - iTime * 0.1);\n    vec2 r = vec2(fbm(p + q + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    fragColor = vec4(c * cos(shift * fragCoord.y / iResolution.y), alpha);\n}\n\n// Simple thresholding\nfloat color( in vec2 x, in vec2 cent )\n{\n    float v = getDist( x, cent );\n    return v;//smoothstep( 0.19, 0.24, abs(v) );\n}\n\nvec3 getColorFromUV( in vec2 rawuv, in vec2 uv11 )\n{\n    vec4 fireColor;\n    fire301(fireColor, rawuv);    \n    vec3 fgCol = fireColor.rgb;//vec3(1.,0.,0.);\n    fgCol.r *= 1.8;\n    fgCol = mix(fgCol,vec3(1.,0.,0.),.25);\n    //return fgCol;\n\treturn mix(fgCol, vec3(1.), color( uv11, vec2(0.0, 0.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Fit [-1,1] into screen and expand for aspect ratio\n\tvec2 uv11 = 2.0*uv - vec2(1.0,1.0);\n\tfloat aspect = iResolution.x / iResolution.y;\n\tif (aspect > 1.0)\n\t{\n\t\tuv11.x *= aspect;\n\t}\n\telse\n\t{\n\t\tuv11.y /= aspect;\n\t}\n\t\n\tfragColor = vec4(getColorFromUV(fragCoord, uv11), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 169, 208, 208, 630], [632, 632, 675, 675, 817], [819, 908, 951, 951, 1169], [1172, 1230, 1250, 1250, 1319], [1321, 1321, 1342, 1342, 1548], [1550, 1550, 1569, 1569, 1750], [1752, 1752, 1807, 1807, 2444], [2446, 2469, 2509, 2509, 2594], [2596, 2596, 2648, 2648, 2897], [2899, 2899, 2956, 2956, 3276]], "test": "valid"}
{"id": "lsySD1", "name": "Colorful Flowing Thing", "author": "sillsm", "description": "It's a colorful flowing thing.", "tags": ["raymarching"], "likes": 1, "viewed": 117, "published": "Public", "date": "1464061619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Max Sills 2016, licensed under the MIT license.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\naxis = normalize(axis);\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Rounded box minus a sphere with oscilating radius.\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  float dist = max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p)));\n  dist += 5.*sin(iTime+ p.x)*cos(p.y);\n    return dist;\n}\n\n\nvec4 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i)\t\t\t\t\n    {\t\n        //   the amount t must be to get to it\n        p = viewportxy + (t* ray);\t\t\t\t\n        float dist = udBox(p, vec3(1,1,1));\n        t += dist * .9;\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(0, 0, -7);\n    vec3 screen = vec3(0,0,-5);\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    eye = qRotate(vec3(0,1.,0.),iTime,vec3(0.), eye);\n    vec3 newScreen = qRotate(vec3(0,1.,0.),iTime,vec3(0.), screen);\n    \n    mat4 mat = LookAtRH(newScreen, vec3(0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(pt - eye);\n    \n    vec4 tr     = trace(ray, pt);\n    vec3 ref    = vec3(0.,0.,1.);\n    float t     = tr.w;\n\n    vec3 x = dFdx(tr.xyz);\n    vec3 y = dFdy(tr.xyz);\n    vec3 normal = normalize(cross(x,y));\n    \n    normal = abs(normal);\n\n    vec3 col = 5.*(1./t)*vec3(normal);\n    col *= .8; // Gamma correction.\n\n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsySD1.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 130, 193, 193, 622], [624, 678, 709, 709, 882], [885, 885, 928, 928, 1204], [1206, 1276, 1325, 1325, 1703], [1705, 1705, 1762, 1762, 2641]], "test": "valid"}
{"id": "lsyXRD", "name": "Superformula 2D ", "author": "unbird", "description": "Application of https://en.wikipedia.org/wiki/Superformula with slight distortion.\n", "tags": ["procedural", "2d", "distortion", "superformula", "superellipse", "lam"], "likes": 7, "viewed": 421, "published": "Public", "date": "1463162836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://en.wikipedia.org/wiki/Superformula\n\nfloat super(float phi, float a, float b, float m, float n1, float n2, float n3)\n{    \n    return 1.0 / pow(pow(abs(cos(m*phi/4.0))/a, n2) + pow(abs(sin(m*phi/4.0))/b, n3), 1.0 / n1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv *= 1.5;\n    uv.x *= iResolution.x / iResolution.y;        \n    float d1 = sin(2.0*(uv.x+iTime)) + sin(2.0*(uv.y+iTime));\n    uv.x += 0.1 * d1;\n    uv.y += 0.1 * d1;\n    float phi = atan(uv.y, uv.x);\n\tfloat r = length(uv);\n\t\n\t// distort r    \n    float fade = (0.5+0.5*sin(iTime));\n    float distort = 0.5*sin(2.0*phi) + 0.3 * sin(5.0*phi);\n\t//r += fade * 0.2 * distort;\n    float m = sin(iTime*0.2) * 5.0 + 6.0;\n    float n1 = sin(iTime*0.3+1.0) * 5.0 + 6.0;\n    float n2 = sin(iTime*0.4+2.0) * 5.0 + 6.0;\n    float n3 = sin(iTime*0.5+3.0) * 5.0 + 6.0;\n    //float c = super(phi, 1.0, 1.0,11.0, 6.0, 10.0,5.0) - r;\n    float c = super(phi, 1.0, 1.0,m,n1,n2,n3) - r;\n    // AA        \n    c = c / fwidth(c);        \n    fragColor = vec4(c,c,c,1);        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 128, 128, 231], [233, 233, 290, 290, 1110]], "test": "valid"}
{"id": "lsyXRw", "name": "Trippy Checkerboards", "author": "innovati", "description": "Endless trippy checkerboards", "tags": ["trip", "checckerboard"], "likes": 1, "viewed": 94, "published": "Public", "date": "1463432896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = step(cos(reflect(mod(vec4(1.9, sign(1.8), (0.8 - (1.6 / cos(((fragCoord.y / iResolution.y) / (min(sin(1.8), 0.6) / 0.6))))), (1.7 + 1.6)), abs(vec4((fragCoord.x / iResolution.x), 0.1, iTime, 0.3))), vec4(1.2, ((fragCoord.x / iResolution.x) + 1.8), 1.5, 0.5))), vec4(log2(1.3), ((0.0 - iTime) + iTime), 0.2, inversesqrt(0.2)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 400]], "test": "valid"}
{"id": "MdcSDl", "name": "cheese trip", "author": "tomaes", "description": "...", "tags": ["cartoon", "wip", "cheese"], "likes": 0, "viewed": 117, "published": "Public", "date": "1462097219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 rect(vec2 _uv, vec2 _p, vec2 _s, vec3 _c)\n{\n    return vec4((_uv.x > _p.x) && (_uv.x < (_p.x+_s.x)) &&\n                (_uv.y > _p.y) && (_uv.y < (_p.y+_s.y)) ? _c : vec3(0), 1. );        \n}\n\nvec4 circle(vec2 _uv, vec2 _p, float _d, vec3 _c)\n{\n    float h = distance(_p,_uv*vec2(1.,1.02));\n    \n    return vec4( h < _d ? _c - h*5. : vec3(0), 1. ); \n}\n\nvoid mainImage( out vec4 f, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfloat t = iTime + 2.4;\n    \n    float b  = abs(sin(t))*.5; \n    float b2 = sin(t*5.)*.1;\n    \n    vec2 q  = vec2(tan(t+mod(uv.x,.2)*10.+mod(uv.y,.2)*10. )*.5, cos(t*uv.x)*.5);\n         q += vec2(cos(t-mod(uv.x,.2)*10.+mod(uv.y,.2)*10. )*.5, cos(t*uv.y)*.5);\n\n    // bg fx\n    f  = vec4( uv.y*.2+max(length( .05/dot(uv-.75+q.x,uv-.75+q.y) -.5),b), .3, .1, 1. );\n    f += vec4( max(length( .05/dot(uv-.25+q.x,uv-.25+q.y) -.5),b), .4, .2, 1. );\n    \n    f += .3*circle(uv, vec2(.50+b*.05,.50 + mod(t-uv.y,.4)*2. ), .170-b*.1, vec3(.5, .5, .5 ) );\n    \n    // face\n    f += circle(uv, vec2(.50+b*.05+b2*.1,.50), .124+mod((t+tan(uv.x*4.+uv.y))*.01,.01)*2., vec3( .4, .2, .25) );\n    f += circle(uv, vec2(.50+b*.05,.50),       .170, vec3(1., 1., 1. ) );\n    \n    // eyes\n    f -= circle(uv, vec2(.45,.50), .010+b*.02, vec3(1.,1.,0.) );\n    f -= circle(uv, vec2(.55,.50), .010+b*.01, vec3(1.,1.,0.) );\n    \n    // mouth\n    f -= circle(uv, vec2(.5,.45), .026, vec3(1.,1.,0.) );\n    f += rect(uv, vec2(.475,.45-b2*.02), vec2(.05,.05), vec3(1.,1.,1.) );\n    \n    // \"3d\"\n    //f += .01/length(uv-mod(t+tan(uv.x*5.+sin(uv.y*2.)),.4))-.1*uv.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 49, 49, 196], [198, 198, 249, 249, 356], [358, 358, 407, 407, 1590]], "test": "valid"}
{"id": "MddXDs", "name": "Temporal Text", "author": "akohdr", "description": "By tracking time and appropriately sequencing temporal primitives we can mimic simple hand printed text.\nOutput progressively slows to better show the development of each individual stroke.  Mouse resizes characters.", "tags": ["2d", "bezier", "text", "font"], "likes": 22, "viewed": 569, "published": "Public", "date": "1462314523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Example showing sequencing of temporal drawing primitives to mimic hand printed text\n//\n// Font 'eidos' is more or less the same as previous examples with few ordering tweaks\n// and addition of circle starting and direction meta information.\n//\n\n// use of temporal primitives refer https://www.shadertoy.com/view/lstXDj\n#define TEMPORAL_TEXT\n#define STAGGERED\n\n// Use debug flag to colour primitives RGB\n//#define DEBUG\n\n#define INK ORG\n//#define INK GRN\n//#define LINE_WIDTH 1.1\n#define LINE_WIDTH 5.1\n\n// Select screen mode text res. size\n//#define MODE vec2(14,7)\n#define MODE vec2(26,9)\n//#define MODE vec2(40,25)\n\n// Advise full screen and/or resizing chars with mouse\n//#define MODE vec2(80,30)\n//#define MODE vec2(132,43)\n//#define MODE vec2(132,60)\n\n// For those with retina display and magnifying glass (it's there!)\n//#define MODE vec2(264,128)\n\n// Using point to line distances gives us an antialiasing pointcut we can exploit\nvoid antialias(inout vec4 k, float d, float w, vec4 K) {\n    // Standard filled antialiased lines\n//    k += K*(w-d);\n\n    // Neon glow\n    k += K/d;\n    \n\t// Partially stenciled lines \n//    k += K*sin(d-w);\n    \n    // Hollow lines (provides reasonable high res. legibility)\n//    k += K*cos(1.5+d-w);\n    \n    // Center line plus outline\n//  k += K*tan(.2+d-w);\n    \n    // Stripe filled (using screen x/y would give stable fill)\n//    k += K*max(K*cos(d-w), cos(7.*(d-w)));\n    \n    // Temporally striped and outlined\n//  k += K*max(K*cos(d-w), 1.+2.*cos(7.*(d-w)*(1.1+sin(iTime/2.))));\n    \n    // Flashing font (temporal)\n//    k += K*max(K*cos(d-w), sin(5.*iTime));\n}\n\n\n#define BLK vec4(.0,.0,.0,1.)\n#define GRY vec4(.5,.5,.5,1.)\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ORG vec4(1.,.5,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n\nfloat dBezier1(vec2 p, vec4 ac, vec2 b);// exact  https://www.shadertoy.com/view/Mlj3zD\nfloat dBezier2(vec2 p, vec4 ac, vec2 b);// approx https://www.shadertoy.com/view/XsX3zf\n\n// Provides distance of p to quadratic bezier curve described by abc\n#define dBezier dBezier1\n\n//=============================================================================\n// The primitives.\n\n#define PI  3.14159265358979\n#define PI2 6.28318530717858\n\nvec2 rot2D(vec2 p, float a) \n{\n    vec3 csa = vec3(cos(a),-sin(a),0);\n               csa.z = -csa.y;\n    return p * mat2( csa.xyzx);\n}\n\n           \nvec2 polar(vec2 p)\n{\n    float x = p.x,  \n          y = p.y,\n          a = atan(abs(y/x)),\n          r = sqrt(x*x+y*y);\n    a = x>0. ? y>0. ?    a : PI2-a :\n               y>0. ? PI-a :  PI+a;\n                   \n\treturn vec2(r, a);    \n}\n\n\nvoid antialias(inout vec4 k, float d, float w)\n{\n    float w1 = max(.2,.5*w),\n          s  = w1/(d+2e-9);\n    \t  s += w1/(d-3e-9);\n    \n    k += vec4(1)*s;\n}\n\n\nfloat dLine(vec2 p, vec2 a, vec2 b) \n{\n    b -= a;  \n    p -= a;\n    return length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n}\n\n\nvec2 linePos(vec2 a, vec2 b, float t)\n{\n\tt = clamp(t,0.,1.);\n    vec2 d = b - a;\n    return a + t * d;\n}\n\nfloat dCircle(vec2 p, vec2 a, float r, float w)\n{\n    float w2 = w/2.,\n           l = length(p-a);\n    return (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n}\n\n\nvec2 cirPos(vec2 a, float r, float t)\n{\n    return a+r*vec2(cos(PI2*t),sin(PI2*t));\n}\n\nfloat dCircle(vec2 p, vec2 a, float r, float w, float t, float s)\n{\n    t *=PI2;\n    vec2 pa = rot2D(p-a,abs(s)),\n        pol = polar(pa);\n    float l = length(pa),\n         w2 = w/2.;\n    \n    bool bo = s<0. ? pol.y < PI2-t : pol.y > t;\n        \n    return (pol.x>r+w || bo) ? 1e9 : \n    \t\t(l>r) ? abs((l-r)+w2) : abs((r-l)-w2);\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c); \n\nfloat dBezierSegs(vec2 p, vec4 ac, vec2 b, float dt) {\n    float d = 9999.;\n    vec2 a = ac.xy, c = ac.zw, q = a, r;\n    \n    for(float t=0.; t<=1.; t+=.03) {\n        r = bzPos(t,a,b,c);\n        d = min(d, dLine(p,q,r));   //TODO make temporal\n        q = r;\n        if(t>dt) return d;\n    }\n    \n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid bezier(inout vec4 k, vec2 p, vec4 ac, vec4 bw, vec4 K, float t) {\n    if(t<.1) return;\n#ifdef DEBUG \n    K = RED; \n#endif\n    \n#ifdef TEMPORAL_TEXT\n    float d = dBezierSegs(p,ac,bw.xy,t);\n#else\n    float d = dBezier(p,ac,bw.xy);    \n#endif\n    if(d<bw.z) antialias(k,d,bw.z,K);\n}\n\nvoid circle(inout vec4 k, in vec2 p, vec4 a, vec4 K, float t, float s) \n{\n    if(t<.1) return;\n#ifdef DEBUG \n    K = GRN; \n#endif\n    float r = a.z,\n          w = a.w,\n          w2 = w/2.,\n          l = length(p-a.xy),\t\t\t\t\t\t\t// distance from p to center\n#ifdef TEMPORAL_TEXT\n          d = dCircle(p,a.xy,r,w,t,s);\n#else\n          d = (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\t\t// distance to edge line width(w)\n#endif\n    if(d<w) antialias(k,d,w,K);\n}\n\nvoid line(inout vec4 k, vec2 p, vec4 l, float w, vec4 K, float t) \n{\n    if(t<.1) return;\n#ifdef DEBUG \n    K = BLU; \n#endif\n    vec2 a = l.xy, \n         b = l.zw;\n    \n#ifdef TEMPORAL_TEXT\n    float d = dLine(p,a,linePos(a,b,t));\n#else\n    float d = dLine(p,a,b);\n#endif \n\n    if(d<w) antialias(k,d,w,K);\n}\n\n//=============================================================================\n// We (micro)codify the control point data to drive the rendering process\n\n// input params getting unwieldy start using context struct\nstruct glyphCtx {\n    vec2 p; \t\t// fragCoord\n    vec2 s; \t\t// scale XY\n    float w; \t\t// line width\n    vec4 K;\t\t\t// colour\n    mat4 gp; \t\t// glyph microcode\n    int gw;\t\t\t// glyph width\n    float t;\t\t// time\n};\n\nvoid procGlyph(inout vec4 k, inout vec4 c, \n               glyphCtx g)\n{\n    vec2 s = g.s;\n    \n    vec4 ss = vec4(s,s);\n    bool skip = false;\n    for(int i=0;i<4;i++) {\n        if(skip) {skip = false; continue;}\n        \n        float t = g.t-float(i)/2.;\n        vec4 u = ss*g.gp[i];\n        if(u.x<0.)\n            if(u.z<0.){ // second point x \n                vec4 v = ss*g.gp[i+1]; skip = true;\n                bezier(k, g.p, vec4(-u.x,u.y,-u.z,u.w), vec4(v.xy,g.w,0.), g.K, t);\n            }\n        else\n            circle(k, g.p, vec4(-u.x,u.yz,g.w), g.K, t, u.w);\n        else\n            if(u.z>0.)   // 0 is NOP\n                line(k, g.p, u,g.w, g.K, t);\n    }\n    // advance cursor in font x direction (proportional font)\n    c.x += s.x*float(g.gw);\n}\n\n// glyph functions ============================================================\n// hanging macro (compile quicker less source noise)\n//#define PROC procGlyph(k,c,p,s,w,K,mat4(\nmat4 retMat(mat4 m, int w) { return m; }\n#define PROC retMat(mat4(\n#define Z4 0,0,0,0\n#define Z8 Z4,Z4\n\n//The 'eidos' of the font.....\n\n//#define R 6.\n#define R 8.\n//#define R 10.\n#define a_    PROC -6,-2,.8*R,-4, \tZ4,\t\t\t -2,8,-13,-8, \t16,15,0,0),\t\t20)\n#define b_    PROC 1,20,1,-7,   \tZ4,          -8,0,R,-4,   \tZ4),\t\t\t20)\n#define c_    PROC -13,5,-1,0,   \t3,12,0,0, \t -1,0,-14,-3,   -2,-12,0,0), \t22)\n#define d_    PROC -5,0,R,0,  \t\tZ4,          13,20,13,-7,   Z4), \t\t\t20)\n#define e_    PROC  -1,-2,-6,6,   \t25,2,0,0,\t -6,6,-15,-6,   -8,-10,0,0), \t22)\n#define f_    PROC -9,18,-2,-8,  \t1,25,0,0,    Z4,            1,4,9,5),\t    14)\n#define g_    PROC -7,0,R,0,   \t\tZ4,          -15,8,-1,-16,  17,-28,0,0),    22)\n#define h_    PROC 1,20,1,-8,   \tZ4,          -1,4,-14,-8,   13,15,0,0),     18)\n#define i_    PROC -2,7,-4,-6,  \t-1,-16,0,0,  Z4,            -3,13,2,0), \t10)\n#define j_    PROC -5,7,-1,-10, \t8,-25,0,0,   Z4,            -5,13,2,0), \t12)\n#define k_    PROC 1,18,1,-8,   \t13,6,1,-2,   Z4,            5,0,13,-8), \t18)\n#define l_    PROC -1,19,-6,-5,  \t0,-18,0,0,   Z8), \t\t\t\t\t\t\t12)\n#define m_    PROC -1,-9,-8,-3,   \t2,20,0,0,  \t -8,-3,-16,-9,  14,20,0,0),\t\t24)\n#define n_    PROC 1,7,1,-8,   \t\tZ4,          -1,4,-14,-8,   15,15,0,0), \t20)\n#define o_    PROC -7,0,R,-6, \t\tZ4, \t\t Z8), \t\t\t\t\t\t\t20)\n#define p_    PROC 1,7,1,-20,\t\tZ8,          -9,0,R,-4),         \t\t\t22)\n#define q_    PROC -6,0,R,0,   \t\tZ8,\t\t\t 14,7,14,-20), \t     \t\t\t20)\n#define r_    PROC 1,8,1,-7,   \t\tZ4,\t\t\t -2,3,-13,5,    11,12,0,0), \t20)\n#define s_    PROC -8,7,-6,-1,   \t-8,8,0,0,  \t -6,-1,-1,-6,   15,-11,0,0), \t14)\n#define t_    PROC -4,15,-12,-5, \t1,-15,0,0,   1,8,8,8, \t\tZ4),         \t16)\n#define u_    PROC -1,8,-13,-4,  \t0,-16,0,0,   Z4,\t\t\t14,8,14,-8), \t20)\n#define v_    PROC 1,8,6,-8,   \t\tZ4,\t\t\t 6,-8,11,8,   \tZ4), \t\t\t16)\n#define w_    PROC 1,8,4,-8,   \t\t4,-8,9,4,    9,4,14,-8,   \t14,-8,18,8), \t23)\n#define x_    PROC 1,8,8,-8,   \t\tZ8,\t\t\t 8,8,1,-8), \t\t\t\t\t12)\n#define y_    PROC -2,8,-13,-4,  \t4,-11,0,0,   -14,8,-1,-18,  14,-28,0,0), \t22)\n#define z_    PROC 1,8,8,8,   \t\t8,8,1,-8,    1,-8,8,-8,   \tZ4), \t\t\t14)\n\n#define Sp_ c.x += s.x*16.;\n#define Cr_ c.y -= s.x*35.; c.x = s.x*40.;\n\nvoid mainImage(out vec4 k, in vec2 p )\n{   \n    k = vec4(0);\n    \n    vec2 ir = iResolution.xy,\n         sc = MODE,\n         cr = ir/sc,\n          s,\n        off = cr/vec2(4.,2.),\n         mp = mod(p, ir/sc)-off;\n\n     vec4 c = vec4(floor(p/cr),0,0),\n          K = INK;\n    \n    s = (iMouse.x>0.) ? \n        3.*iMouse.xy/iResolution.xy :\n    \tvec2(.04,.02)*ir/sc;\n    \n    float ch = floor(p.x/cr.x);\n\n    // need vectored jump?!\n    mat4 gp = ch< 1. ? a_ :\n       \t      ch< 2. ? b_ :\n       \t      ch< 3. ? c_ :\n              ch< 4. ? d_ :\n      \t      ch< 5. ? e_ :\n      \t      ch< 6. ? f_ :\n       \t      ch< 7. ? g_ :\n       \t      ch< 8. ? h_ :\n       \t      ch< 9. ? i_ :\n       \t      ch<10. ? j_ :\n       \t      ch<11. ? k_ :\n       \t      ch<12. ? l_ :\n       \t      ch<13. ? m_ :\n       \t      ch<14. ? n_ :\n       \t      ch<15. ? o_ :\n       \t      ch<16. ? p_ :\n       \t      ch<17. ? q_ :\n       \t      ch<18. ? r_ :\n       \t      ch<19. ? s_ :\n       \t      ch<20. ? t_ :\n       \t      ch<21. ? u_ :\n       \t      ch<22. ? v_ :\n       \t      ch<23. ? w_ :\n       \t      ch<24. ? x_ :\n       \t      ch<25. ? y_ :\n    \t      z_;\n    \nglyphCtx ctx;\n    ctx.p = mp;\n    ctx.s = s;\n    ctx.w = LINE_WIDTH;\n    ctx.K = K;\n    ctx.gp = gp;\n    ctx.gw = 0;\t\t\t\t\t// fixed width for now....\n    \n#ifdef STAGGERED\n    ctx.t = -48.+(-2.*ch)+2.*iTime*(.7*c.y) + 6.*c.y;\n#else\n    ctx.t = (-2.*ch)+2.*iTime;\n#endif\n    \n    \n    procGlyph(k, c, ctx);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//Bezier line implementations follow\n//=============================================================================\n// derived from bezier code @ https://www.shadertoy.com/view/Mlj3zD\n#define PI 3.14159265358979\nint findRoots(vec4 abcd, out vec3 r)\n{\n    float a = abcd[0],\n    b = abcd[1],\n    c = abcd[2],\n    d = abcd[3];\n    vec3 vS = vec3(-1);\n    if (abs(a) > 1e-9){\n        \n        float z = 1./a;\n        abcd *= z;\n        a = abcd[1];\n        b = abcd[2];\n        c = abcd[3];\n        \n        float d3 = 1./3.,\n        aa = a*a,\n        d27 = 1./27.,\n        p = b-aa*d3,\n        q = a*(2.*aa-9.*b)*d27+c,\n        ppp = p*p*p,\n        D = q*q+4.*ppp*d27,\n        delta = -a*d3;\n        \n        if (D > 1e-9){\n            z = sqrt(D);\n            vec2 uv = .5*(vec2(z,-z)-q),\n            s = sign(uv);\n            uv = abs(uv);\n            float u = s.x*pow(uv.x,d3),\n            v = s.y*pow(uv.y,d3);\n            r.x = u+v+delta;\n            return 1;\n        }\n        else if (D < -1e-9){\n            float u = sqrt(-p*d3)*2.,\n            s = -sqrt(-27.0/ppp)*q*.5;\n            if (abs(s) > 0.) {}\n            r = u*cos(vec3(acos(s)*d3) + vec3(0,2,4)*PI*d3)+delta;\n            return 3;\n        }\n        else {\n            q = sign(q)*pow(abs(q)*.5,d3);\n            r.xy = vec2(-q,q)+delta;\n            r.x *= 2.;\n            return 2;\n        }\n    }\n    else {\n        if (abs(b) <= 1e-9 && abs(c) > 1e-9) {\n            r.x = -d/c;\n            return 1;\n        }\n        else {\n            float D = c*c-4.*b*d,\n            z = 1./(2.*b);\n            if (D > 1e-9) {\n                D = sqrt(D);\n                r.xy = (vec2(-D,D)-c)*z;\n                return 2;\n            }\n            else if (D > -1e-9) {\n                r.x = -c*z;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c)\n{\n    float mT = 1.-t;\n    vec2 pos = mT*mT*a+2.*t*mT*b+t*t*c;\n    return pos;\n}\n\nfloat dBezier1(vec2 p, vec4 ac, vec2 b)\n{\n    vec2 a = ac.xy,\n    c = ac.zw,\n    dap = a-p,\n    dba = b-a,\n    sac = a+c-b*2.;\n    vec3 r;\n    float dist = 999.;\n    int roots = findRoots(vec4(dot(sac,sac),\n                               dot(dba,sac)*3.,\n                               dot(dba,dba)*2.+dot(dap, sac),\n                               dot(dap,dba)),r);\n    float r1 = r.x,\n    r2 = r.y,\n    r3 = r.z;\n    if (roots > 0 && r1 >= 0. && r1 <= 1.)\n        dist = distance(p,bzPos(r1,a,b,c));\n    if (roots > 1 && r2 >= 0. && r2 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[1],a,b,c)));\n    if (roots > 2 && r3 >= 0. && r3 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[2],a,b,c)));\n    return min(dist, min(distance(p, a), distance(p, c)));\n}\n\n\n//=============================================================================\n// Alternative Bezier Implementation derived from https://www.shadertoy.com/view/XsX3zf\n// approximation shows on thicker lines when endpoints are close\n// may be useful for finer lines/small text higher speed (?)\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 bzPtInSeg( vec2 a, vec2 b ){\n    vec2 d = b - a;\n    return a + d*clamp( -dot(a,d)/dot(d,d), 0., 1. );\n}\n\nvec2 bzVec(vec2 a, vec2 b, vec2 c) {\n    float q = det(a,c),\n    r = det(b,a),\n    s = det(c,b),\n    q2 = 2.*(q + r + s);\n    if( abs(q2) < 1000. )\n        return bzPtInSeg(a,c);\n    vec2 dba = b - a,\n    dca = c - a,\n    gf = q*dca + 2.*(r*(c-b) + s*dba),\n  \t\tgs = 2.*vec2(gf.y,-gf.x),\n    d = a + (4.*r*s - q*q)*gs/dot(gs,gs);\n    \n    float t = clamp((det(d,dca) + 2.*det(dba,d)) / q2, 0. ,1.);\n    \n    return mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nfloat dBezier2(vec2 p, vec4 ac, vec2 b) {\n    return length(bzVec(ac.xy-p, b-p, ac.zw-p));\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddXDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[989, 1071, 1127, 1206, 1745], [2540, 2540, 2570, 2570, 2674], [2688, 2688, 2708, 2708, 2926], [2929, 2929, 2977, 2977, 3086], [3089, 3089, 3127, 3127, 3224], [3227, 3227, 3266, 3266, 3331], [3333, 3333, 3382, 3382, 3482], [3485, 3485, 3524, 3524, 3570], [3572, 3572, 3639, 3639, 3903], [3952, 3952, 4006, 4006, 4264], [4279, 4279, 4349, 4349, 4564], [5015, 5015, 5083, 5083, 5322], [5752, 5752, 5824, 5824, 6518], [6520, 6696, 6724, 6724, 6736], [8867, 8867, 8907, 8907, 10320], [10554, 10554, 10592, 10592, 12171], [12173, 12173, 12218, 12218, 12297], [12299, 12299, 12340, 12340, 13060], [13358, 13358, 13385, 13385, 13411], [13413, 13413, 13446, 13446, 13522], [13524, 13524, 13560, 13560, 13969], [13971, 13971, 14012, 14012, 14063]], "test": "error"}
{"id": "MdGSzz", "name": "Crystal worm", "author": "axelduch", "description": "A crystal worm", "tags": ["3d", "planet", "worm", "crystal"], "likes": 2, "viewed": 156, "published": "Public", "date": "1462445810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define CLIP_FAR 1000.0\n# define STOP_THRESHOLD 0.008\n# define MAX_ITERATIONS 64\n# define PI 3.14159265359\n# define DEG_TO_RAD 3.14159265359 / 180.0\n    \nfloat dist_sphere (vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat dist_field (vec3 pos) {\n    float bigPlanetR = 1.25;\n    float bigPlanet = dist_sphere(pos, bigPlanetR);\n    \n    float res = bigPlanet;\n    \n    const float l = 4.0;\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.19);\n        smallPlanetPos.x += cos(-iTime * 5.0 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += sin(-iTime * 4.0 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 + smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    \n    return res;\n}\n\nfloat ray_march(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        float dist = dist_field(ro + rd * depth);\n        \n        if (dist < STOP_THRESHOLD) {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= CLIP_FAR) {\n            return CLIP_FAR;\n        }\n    }\n    \n    return CLIP_FAR;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\nvec3 shading(vec3 pos, vec3 n, vec3 ro, vec2 uv) {\n    vec3 lightPos = vec3(20.0, 20.0, 20.0);\n    vec3 lightColor = vec3(uv,0.5+0.5*sin(iTime));\n    \n    vec3 Normal     = vec3(uv.x, uv.y, sqrt(n.z));\n\n    float t = iTime;\n\tfloat U = 1.0-atan(Normal.z, Normal.x) / (2.0* PI);\n\tfloat V = 1.0-(atan(length(Normal.xz), Normal.y)) / PI;\n \tvec3 Ground = pow(texture(iChannel0, vec2(U - t/4.0, V)).xyz, vec3(2.22));\n    \n    lightColor = mix(lightColor, vec3(1.0), Ground);\n    \n    vec3 vl = normalize(lightPos - ro);\n    \n    float ambient = 0.8;\n    float diffuse = max(0.0, dot(vl, n));\n    \n    // specular\n    vec3 ev = normalize(pos - ro);\n    vec3 ref_ev = reflect(ev, n);\n    float specular = max(0.0, dot(vl, ref_ev));\n    \n    return lightColor * (ambient + diffuse + specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = ray_dir(20.0 + sin(iTime * 6.0), iResolution.xy, fragCoord.xy );\n    \n    float depth = ray_march(ro, rd);\n    \n    if (depth >= CLIP_FAR) {\n    \tfragColor = vec4(vec3(0.0), 1.0);\n        fragColor = vec4(vec3(uv,0.5+0.5*sin(iTime)), 1.0);\n        return;\n    }\n    \n    \n    vec3 pos = ro + rd * depth;\n    \n    fragColor = vec4(shading(pos, pos * 0.7, ro, uv), 1.0);\n}\n\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 194, 194, 224], [226, 226, 255, 255, 972], [974, 974, 1009, 1009, 1363], [1365, 1386, 1434, 1434, 1610], [1613, 1613, 1663, 1663, 2399], [2401, 2401, 2458, 2458, 2928]], "test": "error"}
{"id": "MdKXz1", "name": "Too much Acid", "author": "innovati", "description": "Too much acid", "tags": ["acid", "trip"], "likes": 0, "viewed": 110, "published": "Public", "date": "1463006036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = mod(min(vec4(0.4, 0.4, 1.3, (gl_FragCoord.x / iResolution.x)), reflect(sign(mod(vec4(1.2, 0.3, (1.6 - (1.2 + 0.7)), 0.7), asin(vec4(0.2, 1.2, 1.8, 1.4)))), sin(mod(min(reflect(reflect(min(step(step(vec4(float(iFrame), 0.8, (1.1 * 0.4), (0.8 - degrees(0.3))), step(vec4((iTime + float(iFrame)), tan(1.3), 0.1, 0.6), min(cos(sqrt(mod(vec4(0.7, iTime, iTime, float(iFrame)), atan(vec4(((gl_FragCoord.y / iResolution.y) + float(iFrame)), (0.6 - 1.9), 0.2, ((0.4 + iTime) * 1.6)))))), vec4((0.4 * (gl_FragCoord.x / iResolution.x)), 1.5, iTime, radians(0.5))))), mod(mod(vec4(1.5, 1.9, (gl_FragCoord.y / iResolution.y), 0.6), max(vec4(1.2, 0.2, 1.3, iTime), vec4((gl_FragCoord.y / iResolution.y), 0.1, 0.1, 1.7))), degrees(vec4(float(iFrame), 0.2, (0.3 * 1.9), (reflect(ceil((0.3 - 0.4)), (1.4 + (acos(0.0) + (gl_FragCoord.y / iResolution.y)))) - 1.9))))), log(asin(reflect(min(min(pow(vec4(reflect(0.4, (gl_FragCoord.y / iResolution.y)), reflect((gl_FragCoord.x / iResolution.x), (gl_FragCoord.y / iResolution.y)), 1.4, 1.5), tan(vec4((gl_FragCoord.y / iResolution.y), ((1.8 * sign(1.1)) - (gl_FragCoord.x / iResolution.x)), iTime, ((gl_FragCoord.y / iResolution.y) * (0.3 * 0.0))))), vec4(iTime, (1.9 / 1.6), ((0.5 - (gl_FragCoord.y / iResolution.y)) * (gl_FragCoord.x / iResolution.x)), 0.4)), vec4(log2(1.6), (float(iFrame) * 1.4), degrees(float(iFrame)), 0.5)), vec4((0.3 * 0.7), float(iFrame), 0.1, 1.5))))), vec4(0.0, (1.5 / 0.5), 0.8, float(iFrame))), vec4((0.5 + 1.3), 1.6, (1.4 * ((gl_FragCoord.x / iResolution.x) / 0.8)), 1.1)), atan(sin(ceil(reflect(step(vec4(float(iFrame), reflect(iTime, ((gl_FragCoord.y / iResolution.y) + 1.4)), 1.8, (exp(1.8) - (1.6 * 0.7))), step(vec4(1.7, (float(iFrame) * 0.4), (iTime * 0.6), 1.9), acos(vec4(1.4, 1.7, (gl_FragCoord.y / iResolution.y), (1.0 - 1.6))))), exp2(sqrt(min(vec4(1.0, 0.0, reflect((1.8 - 1.6), 1.7), (1.5 - (sin(iTime) / 0.1))), floor(abs(asin(vec4(0.2, floor(1.8), float(iFrame), (gl_FragCoord.x / iResolution.x))))))))))), vec4(((((0.1 - ceil(((((1.5 + 0.1) + 0.7) * ((1.8 / float(iFrame)) * 1.2)) * ((0.5 - min(0.0, iTime)) - 1.2)))) + 0.1) + degrees(normalize(0.8))) * 0.4), ((gl_FragCoord.x / iResolution.x) - 1.0), 1.4, 1.2))), vec4((0.0 / 0.0), 1.3, (atan(0.4, 0.2) * 1.2), (gl_FragCoord.y / iResolution.y)))))), vec4(0.7, 1.4, 0.0, float(iFrame)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "timedout"}
{"id": "MdtSRl", "name": "Cellular Tiled Tunnel 2", "author": "Shane", "description": "Just an accompanying shader to my cellular tiled tunnel example.", "tags": ["tunnel", "cell", "tile"], "likes": 15, "viewed": 1055, "published": "Public API", "date": "1463125806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Cellular Tiled Tunnel 2\n    -----------------------\n    \n    Creating a 2nd order Voronoi feel with minimal instructions by way of a 3D tile constructed via a\n\tsimplistic cellular pattern algorithm.\n\n\tThis is just an accompanying shader to my \"Cellular Tiled Tunnel\" example, and was patched togther\n    fairly quickly. I wanted to use the cellular tiles to create a more natual surface, albeit slightly \n\tstylized. I also added in a firey afterglow and a swiftly moving camera - just like an elite demo... \n\tfrom the late 90s. :) The cubic tile is being reused to create the lame, firey, volumetric haze... \n\tor whatever it's supposed to be. There are much better ways to go about it.\n\n\tJust for the fun, I kept the example textureless. Everything is generated with either tiles or \n\tsimple value noise. To keep the framerate up, I raymarched one layer of cellular tiling, then \n\tbump mapped the finer layers. For anyone interested, comment out the bump mapping and compare the\n\tsurface to a regular 2nd Order Voronoi surface. It looks pretty similar, but is considerably \n\tquicker to produce.\n\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\tCellular Tiled Tunnel - Shane\n\thttps://www.shadertoy.com/view/MscSDB\n\n*/\n\n#define PI 3.14159265\n#define FAR 50.\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(27, 57, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n////////\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\nfloat drawSphere(in vec3 p){\n  \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));  \n}\n\n\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y);\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n}\n\n\n// Standard perturbed tunnel function.\n//\nfloat map(vec3 p){\n    \n   \n    float sf = cellTile(p*.25); // Cellular layer.\n    \n/*    \n     p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z/12.)*p.xy; // Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime*.0)), vec3(.25)); // Sinusoidal layer.\n     \n     return 2. - abs(p.y) + n + (.5-sf)*.25; // Warped double planes, \"abs(p.y),\" plus surface layers.\n*/\n\n     float n = dot(sin(p*.5 + sin(p.yzx)), vec3(.333));\n    \n     // Standard tunnel. Comment out the above first.\n     return 2.5 - length(p.xy - path(p.z)) - sf*.75 +  n;\n\n \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    \n    float noi = noise3D(p*25.)*.67 + noise3D(p*50.)*.33;\n    float vor = cellTile(p*.65);\n    \n    return vor*.9 + noi*.1;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 80; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Shadows.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24;\n\n    float dist = start;\n    //float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    for (int i=0; i<maxIterationsShad; i++){\n    \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        // +=h, += min(h, stepDist), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        dist += clamp(h, 0.02, 0.25 );\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // Shadow value.\n    return min(max(shade, 0.) + .1, 1.); \n}\n*/\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calcAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + hash(i)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*.7/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\n\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/64.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<8; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(1./(1. + sDi*0.25 + sDi*sDi*0.25), 1.);\n\t    // Noise layer.\n        //float n = trigNoise3D(ro/2.);//noise3D(ro/2.)*.66 + noise3D(ro/1.)*.34;\n        float n = cellTile(ro/2.);\n        mist += n*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/8.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/4. + hash31(ro)*0.2-0.1, 0., 1.);\n\n}\n//////\n\n\nvec3 RandomSphereDir(vec2 rnd){\n\n\tfloat s = rnd.x * 3.141592653 * 2.0;\n\tfloat t = rnd.y * 2.0 - 1.0;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1. + t*t);\n}\n\n// Standard semi hemispherical direction calculation.\nvec3 RandomHemisphereDir(vec3 dir, float i){\n\n\tvec3 v = RandomSphereDir(vec2(hash(i + 1.0), hash(i + 2.0)));\n\treturn v * sign(dot(v, dir));\n}\n\n\n/*\n// A mix between ZigguratVertigo's local thickness calculation and XT95's - Basically the same \n// as XT95's, but it gives the kind of results I was after.\n// Sources:\n// Local Thickness - ZigguratVertigo: https://www.shadertoy.com/view/ldGGzR\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\nfloat thickness(vec3 p, vec3 n)\n{\n    float thickness = 0.0;\n    \n    \n    const float nbIte = 6.;\n    const float maxDist = .3;\n    const float rad = 1.-1./nbIte; //Hemispherical factor (self occlusion correction).\n   \n    for (float i=0.; i < nbIte; i++)\n    {\n        // Randomly sample along the hemisphere inside the surface.\n        //float l = hash(float(i)) * maxDist;\n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)*maxDist;\n        vec3 rd = normalize(-n + RandomHemisphereDir(-n, l)*rad);\n        \n        // Accumulate.\n        thickness += (l + map(p + rd*l));\n    }\n\t\n    return max(thickness, 0.);\n}\n*/\n\n\n// Using a variation of IQ's AO function to calculate thickness, but with the normal flipped.\n// IQ uses a similar setup to calculate SSS... Subsurface AO, I guess you'd call it.\nfloat thickness(in vec3 p, in vec3 n){\n    \n    float sNum = 4.;\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<sNum + .001; i++ ){\n    \n        float hr = 0.05 + .4*i/sNum; \n        //vec3 rn = normalize(n + RandomHemisphereDir(n, hr)*rad*.5);\n        float dd = map(p - n*hr);\n        occ += (hr - min(dd, 0.))*sca;\n        sca *= .9;\n    }\n    return 1. - max(occ/sNum, 0.); \n    \n}\n\n\n/*\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0., 0.0, iTime*5. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, .25, 6);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .2);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calcAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lightPos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + distlpsp*0.25); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.3*ao;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        \n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Obtaining the texel color. \n        //vec3 ref = reflect(sn, rd);\n\n        // Object texturing. Two second texture algorithm. Terrible, but it's dark, so no one will notice. :)\n        vec3 texCol = vec3(.65)*(noise3D(sp*32.)*.66 + noise3D(sp*64.)*.34)*(1. - cellTile(sp*16.)*.75);\n        texCol *= smoothstep(-.1, .5, cellTile(sp*.65))*.9 + .1; // Darkening the crevices. Cheap, but effective.\n        texCol *= mix(vec3(.2, .4, .6), vec3(.3, .6, .4), abs(sn))*1.2 + .3; // Bad pearlescence. :)\n    \t\n        /////////   \n        // Translucency, courtesy of XT95. See the \"thickness\" function.\n        vec3 hf = normalize(ld + sn);\n        float th = thickness(sp, sn);\n        //float th = thickness( sp, sn, 1., 1. );\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = (tdiff + .125)*th;  \n        trans = pow(trans, 2.)*16.;        \n    \t////////        \n\n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading = 1.;//crv*0.5+0.5; \n    \t\n        // Shadows - They didn't add enough aesthetic value to justify the GPU drain, so they\n        // didn't make the cut.\n        //shading *= softShadow(sp, ld, 0.05, distlpsp, 8.);\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff*diff + ambience) + vec3(1, .9, .85)*spec*1.5;// + vec3(.5, .8, 1)*spec2;\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*4.;\n        sceneCol += texCol*vec3(1, .025, .05)*trans;\n        \n        //vec3 refCol = vec3(.7, .9, 1)*smoothstep(.25, 1., noise3D((sp + ref*2.)*4.)*.66 + noise3D((sp + ref*2.)*8.)*.34 );\n        //sceneCol += refCol*.5;\n        \n        \n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n\t   \n\t\n\t}\n       \n    // Blend the scene and the background with some very basic, 8-layered smokey haze.\n    float mist = getMist(camPos, rd, lightPos, t);\n    vec3 sky = vec3(2, 1, .85)*mix(1., .75, mist);//*(rd.y*.25 + 1.);\n    sceneCol = mix(sky, sceneCol, 1./(t*t/FAR/FAR*16. + 1.));\n\n    // Clamp and present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1313, 1385, 1407, 1407, 1442], [1444, 1488, 1508, 1508, 1617], [1619, 1771, 1792, 1792, 1858], [1861, 1937, 1962, 2055, 3007], [3009, 3681, 3709, 3709, 3827], [3830, 3830, 3856, 3964, 4599], [4601, 4701, 4723, 4746, 4852], [4855, 4897, 4915, 4915, 5520], [5523, 5587, 5616, 5616, 5752], [5754, 5804, 5861, 5861, 6243], [6245, 6266, 6302, 6302, 6732], [6734, 6834, 6861, 6861, 7019], [8542, 8694, 8734, 8734, 8983], [9282, 9333, 9354, 9354, 9420], [9422, 9710, 9772, 9772, 10490], [10500, 10500, 10531, 10531, 10652], [10654, 10708, 10752, 10752, 10849], [11791, 11970, 12008, 12008, 12360], [12966, 12966, 13022, 13048, 18190]], "test": "valid"}
{"id": "MdtXDf", "name": "danaga's wingman", "author": "s23b", "description": "music: [url=https://www.youtube.com/watch?v=JyBgQjiPlMw]danaga - cafea alba[/url]\n\neffect inspired by the album art. work in progress?", "tags": ["visualization", "danaga"], "likes": 8, "viewed": 546, "published": "Public API", "date": "1463145446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat hash(vec2 uv) {\n    float f = fract(cos(sin(dot(uv, vec2(.009123898, .00231233))) * 48.512353) * 1111.5452313);\n    return f;\n}\n\nfloat noise(vec2 uv) {\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        hash(fuv + vec2(0, 0)),\n        hash(fuv + vec2(0, 1)),\n        hash(fuv + vec2(1, 0)),\n        hash(fuv + vec2(1, 1))\n    );\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i) {\n        f += noise((uv += .25) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\nvec4 blend(vec4 c1, vec4 c2)\n{\n    return vec4(mix(c1.rgb, c2.rgb, c2.a), max(c1.a, c2.a)); \n}\n\nfloat mask(vec2 uv) {\n    uv *= .9 - fbm(-uv * 2. + vec2(0, -iTime)) * (texture(iChannel0, vec2(.25, .25)).x) * .5;\n    return length(uv) - .55;\n}\n\nvec4 spiral(vec2 uv) {\n    if (mask(uv) > 0.) return vec4(0);\n    float angel = atan(uv.x, uv.y) / TAU + .5 - iTime / 10. - texture(iChannel0, vec2(.1, .25)).x * .1;\n    angel -= (uv.y + uv.x) / 20.;\n    float dist = length(uv);\n    float _smooth = dist * 15.;\n    float alpha = saturate(sin(angel * 17. * TAU + sin(dist * 6. + 2.) * 2.) * _smooth);\n    float base = .64 - texture(iChannel0, vec2(.9, .25)).x / 5.;\n    float scratch = smoothstep(base, base + .01, fbm((uv - vec2(0, -iTime * .2)) * vec2(30., 2.)));\n    alpha = saturate(alpha - scratch);\n    alpha = saturate(alpha - smoothstep(-.1, .0, -dist));\n    vec3 color = vec3(.04, .27, .86) + noise(uv * 4.) * .3;\n\treturn vec4(color, alpha);\n}\n\nvec4 circle(vec2 uv) {\n    float width = .05;\n    float m = mask(uv);\n    float alpha = smoothstep(-width, -width + .005, m)* smoothstep(-width - .005, -width, -m);\n    vec3 color = vec3(.16, .21, .5) + (noise(uv * 03.) - .65) * .1;\n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\tfragColor = blend(vec4(.86, .86, .79, 1.), spiral(uv));\n    fragColor = blend(fragColor, circle(uv));\n    uv *= 1000.;\n    float amount = .1;\n    fragColor.r += (hash(uv) - .5) * amount;\n    uv += 100.;\n    fragColor.g += (hash(uv) - .5) * amount;\n    uv += 100.;\n    fragColor.b += (hash(uv) - .5) * amount;\n}", "image_inputs": [{"id": "ltB3Dd", "previewfilepath": "https://soundcloud.com/danaga/08-danaga-cafea-alba", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/danaga/08-danaga-cafea-alba", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 197], [199, 199, 221, 221, 502], [504, 504, 524, 524, 681], [683, 683, 713, 713, 777], [779, 779, 800, 800, 925], [927, 927, 949, 949, 1628], [1630, 1630, 1652, 1652, 1895], [1897, 1897, 1954, 1954, 2361]], "test": "error"}
{"id": "MdVSDh", "name": "Voxel Corridor", "author": "Shane", "description": "Utilizing fb39ca4's, IQ's, Reinder's, etc, voxel code to produce a very simple block work corridor.", "tags": ["tunnel", "raymarch", "voxel", "brick", "corridor", "passage"], "likes": 104, "viewed": 10560, "published": "Public API", "date": "1464265328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tVoxel Corridor\n\t--------------\n\n\tI love the voxel aesthetic, so after looking at some of Akohdr's examples, I went on a bit \n\tof a voxel trip and put this simple scene together... Although, \"scene\" would  be putting \n\tit loosely. :)\n\n\tQuasi-discreet distance calculations sound simple enough to perform in theory, but are just \n\tplain fiddly to code, so I was very thankful to have fb39ca4's, IQ's, Reinder's, and everyone \n\telses voxel examples to refer to.\n\n\tThe code is pretty straight forward. I tried my best to write it in such way that enables\n\tsomeone to plug in any normal distance function and have it render the voxelized version.\n\n\tMainly based on the following:\n\n\tVoxel Ambient Occlusion - fb39ca4\n    https://www.shadertoy.com/view/ldl3DS\n\n\tMinecraft - Reinder\n    https://www.shadertoy.com/view/4ds3WS\n\n\tOther examples:\n\tRounded Voxels - IQ\n    https://www.shadertoy.com/view/4djGWR\n\n\tSampler - w23\n\thttps://www.shadertoy.com/view/MlfGRM\n\n\tText In Space - akohdr\n\thttps://www.shadertoy.com/view/4d3SWB\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n/*\n// Alternate distance field -- Twisted planes. \nfloat map(vec3 p){\n    \n     // You may need to reposition the light to work in with the shadows, but for\n     // now, I'm repositioning the scene up a bit.\n     p.y -= .75;\n     p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z/8.)*p.xy; // Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime*.0)), vec3(.25)); // Sinusoidal layer.\n     \n     return 4. - abs(p.y) + n; // Warped double planes, \"abs(p.y),\" plus surface layers.\n \n}\n*/\n\n// Standard perturbed tunnel function.\n//\nfloat map(vec3 p){\n     \n     // Offset the tunnel about the XY plane as we traverse Z.\n     p.xy -= path(p.z);\n    \n     // Standard tunnel. Comment out the above first.\n     float n = 5. - length(p.xy*vec2(1, .8));\n    \n     // Square tunnel. Almost redundant in a voxel renderer. :)\n     //n = 4. - max(abs(p.x), abs(p.y)); \n     \n     // Tunnel with a floor.\n     return min(p.y + 3., n); //n = min(-abs(p.y) + 3., n);\n \n}\n\n/*\nfloat brickShade(vec2 p){\n    \n    p.x -= step(p.y, 1.)*.5;\n    \n    p = fract(p);\n    \n    return pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), 0.25);\n    \n}\n*/\n\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 2.; // Width to height ratio.\nconst float mortW = 0.05; // Morter width.\n\nfloat brickMorter(vec2 p){\n\t\n    p.x -= step(1., p.y)*.5;\n    \n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    \n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n    \n}\n\nfloat brick(vec2 p){\n    \n\tp = fract(p*vec2(0.5/w2h, 0.5))*2.;\n\n    return brickMorter(p);//*(brickShade(p)*.25 + .75);\n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n\n    n = abs(n);\n    \n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    \n    return brick(p.xy);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// This is just a slightly modified version of fb39ca4's code, with some\n// elements from IQ and Reinder's examples. They all work the same way:\n// Obtain the current voxel, then test the distance field for a hit. If\n// the ray has moved into the voxelized isosurface, break. Otherwise, move\n// to the next voxel. That involves a bit of decision making - due to the\n// nature of voxel boundaries - and the \"mask,\" \"side,\" etc, variable are\n// an evolution of that. If you're not familiar with the process, it's \n// pretty straight forward, and there are a lot of examples on Shadertoy, \n// plus a lot more articles online.\n//\nvec3 voxelTrace(vec3 ro, vec3 rd, out vec3 mask){\n    \n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd); // 1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    mask = vec3(0);\n\t\n\tfor (int i = 0; i < 64; i++) {\n\t\t\n        if (map(p)<0.) break;\n        \n        // Note that I've put in the messy reverse step to accomodate\n        // the \"less than or equals\" logic, rather than just the \"less than.\"\n        // Without it, annoying seam lines can appear... Feel free to correct\n        // me on that, if my logic isn't up to par. It often isn't. :)\n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;\n\t}\n    \n    return p;    \n}\n\n\n// Voxel shadows. They kind of work like regular hard-edged shadows. They\n// didn't present too many problems, but it was still nice to have Reinder's\n// Minecraft shadow example as a reference. Fantastic example, if you've\n// never seen it:\n//\n// Minecraft - Reinder\n// https://www.shadertoy.com/view/4ds3WS\n//\nfloat voxShadow(vec3 ro, vec3 rd, float end){\n\n    float shade = 1.0;\n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd);//1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    vec3 mask = vec3(0);\n    \n    float d = 1.;\n\t\n\tfor (int i = 0; i < 16; i++) {\n\t\t\n        d = map(p);\n        \n        if (d<0. || length(p-ro)>end) break;\n        \n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;                \n\t}\n\n    // Shadow value. If in shadow, return a dark value.\n    return shade = step(0., d)*.7 + .3;\n    \n}\n\n///////////\n//\n// This is a trimmed down version of fb39ca4's voxel ambient occlusion code with some \n// minor tweaks and adjustments here and there. The idea behind voxelized AO is simple. \n// The execution, not so much. :) So damn fiddly. Thankfully, fb39ca4, IQ, and a few \n// others have done all the hard work, so it's just a case of convincing yourself that \n// it works and using it.\n//\n// Refer to: Voxel Ambient Occlusion - fb39ca4\n// https://www.shadertoy.com/view/ldl3DS\n//\nvec4 voxelAO(vec3 p, vec3 d1, vec3 d2) {\n   \n    // Take the four side and corner readings... at the correct positions...\n    // That's the annoying bit that I'm glad others have worked out. :)\n\tvec4 side = vec4(map(p + d1), map(p + d2), map(p - d1), map(p - d2));\n\tvec4 corner = vec4(map(p + d1 + d2), map(p - d1 + d2), map(p - d1 - d2), map(p + d1 - d2));\n\t\n    // Quantize them. It's either occluded, or it's not, so to speak.\n    side = step(side, vec4(0));\n    corner = step(corner, vec4(0));\n    \n    // Use the side and corner values to produce a more honed in value... kind of.\n    return 1. - (side + side.yzwx + max(corner, side*side.yzwx))/3.;    \n\t\n}\n\nfloat calcVoxAO(vec3 vp, vec3 sp, vec3 rd, vec3 mask) {\n    \n    // Obtain four AO values at the appropriate quantized positions.\n\tvec4 vAO = voxelAO(vp - sign(rd)*mask, mask.zxy, mask.yzx);\n    \n    // Use the fractional voxel postion and and the proximate AO values\n    // to return the interpolated AO value for the surface position.\n    sp = fract(sp);\n    vec2 uv = sp.yz*mask.x + sp.zx*mask.y + sp.xy*mask.z;\n    return mix(mix(vAO.z, vAO.w, uv.x), mix(vAO.y, vAO.x, uv.x), uv.y);\n\n}\n///////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0., 0.5, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = camPos + vec3(0.0, 0.0, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, 2.5, 8);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/24. )*rd.xy;\n\n    // Raymarch the voxel grid.\n    vec3 mask;\n\tvec3 vPos = voxelTrace(camPos, rd, mask);\n\t\n    // Using the voxel position to determine the distance from the camera to the hit point.\n    // I'm assuming IQ is responsible for this clean piece of logic.\n\tvec3 tCube = (vPos-camPos - .5*sign(rd))/rd;\n    float t = max(max(tCube.x, tCube.y), tCube.z);\n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        vec3 sn = -(mask * sign( rd ));\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./4.;\n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.02);\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .15);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calcVoxAO(vPos, sp, rd, mask) ;//calculateAO(sp, sn);//*.75 + .25;\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.2 + lDist*0.1); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n \n        // Object texturing.\n        //\n        // Obfuscated way to tinge the floor and ceiling with a bit of brown.\n\t    vec3 texCol = vec3(1, .6, .4) + step(abs(snNoBump.y), .5)*vec3(0,.4, .6);\n\t    \n        // Multiplying by the texture color.\n\t    texCol *= tex3D(iChannel0, sp*tSize0, sn);\n        \n        //texCol *= bumpSurf3D( sp, sn)*.25 + .75; // Darken the grout, if you wanted.\n\n        \n        // Shadows... I was having all sorts of trouble trying the move the ray off off the\n        // block. Thanks to Reinder's \"Minecraft\" example for showing me the ray needs to \n        // be bumped off by the normal, not the unit direction ray. :)\n        float shading = voxShadow(sp + snNoBump*.01, ld, lDist);\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec;// + vec3(.5, .8, 1)*spec2;\n        //sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*2.; // White mortar... not really.\n        \n\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n        \n        // \"fb39ca4\" did such a good job with the AO, that it's worth a look on its own. :)\n        //sceneCol = vec3(ao); \n\n\t   \n\t\n\t}\n       \n    // Blend in a bit of logic-defying fog for atmospheric effect. :)\n    sceneCol = mix(sceneCol, vec3(.08, .16, .34), smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1066, 1218, 1239, 1239, 1305], [1307, 1373, 1423, 1423, 1632], [1634, 1734, 1756, 1792, 1993], [2564, 2606, 2624, 2693, 3032], [3396, 3396, 3422, 3422, 3633], [3635, 3635, 3655, 3655, 3756], [3759, 3823, 3863, 3863, 3986], [3988, 4038, 4095, 4095, 4497], [4499, 4686, 4748, 4748, 5258], [5261, 5887, 5936, 5936, 6614], [6617, 6929, 6974, 6974, 7539], [7541, 8026, 8066, 8219, 8688], [8690, 8690, 8745, 8819, 9179], [9193, 9193, 9249, 9275, 14558]], "test": "error"}
{"id": "MdVSDz", "name": "Particle Test", "author": "Ape", "description": "test", "tags": ["particles"], "likes": 16, "viewed": 311, "published": "Public", "date": "1463934961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float NUM_PARTICLES = 50.0;\n\nfloat lerp(float a, float b, float w) {\n    return a*w + b*(1.0 - w);\n}\n\nvec4 getParticleLight(float particle, vec2 coord) {\n    float factor = particle / NUM_PARTICLES;\n\n    float red = 1.3*sin(0.05*iTime);\n    float blue = 1.3*cos(0.05*iTime);\n    vec4 color = (0.02 / NUM_PARTICLES) * factor\n        * vec4(0.5 + lerp(red*red, 0.5, factor), 1.0,\n               0.5 + lerp(blue*blue, 0.5, factor), 1.0);\n\n    float scale = 0.05 + 0.4 * factor\n        * (0.8 - 0.3*cos(iTime) - 0.1*cos(2.0*iTime));\n\n    vec2 location = scale * vec2(\n        cos((3.0 + 5.2 * factor) * iTime),\n        sin((3.2 + 5.0 * factor) * iTime)\n    );\n\n    vec2 diff = location - coord;\n    float r2 = (diff.x*diff.x + diff.y*diff.y);\n    return color / r2;\n}\n\nvec2 normalizeCoord(vec2 fragCoord) {\n    float scale = min(iResolution.x, iResolution.y);\n\n    return vec2((fragCoord.x - iResolution.x/2.0) / scale,\n                (fragCoord.y - iResolution.y/2.0) / scale);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = normalizeCoord(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (float i = 1.0; i <= NUM_PARTICLES; ++i) {\n        fragColor += getParticleLight(i, coord);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 74, 74, 106], [108, 108, 159, 159, 769], [771, 771, 808, 808, 983], [985, 985, 1040, 1040, 1235]], "test": "valid"}
{"id": "MdVSz1", "name": "Raymarching with distance fields", "author": "Rikstar", "description": "My demo includes the following features:\n\n* ambient, diffuse and specular lighting;\n* hard and soft shadows;\n* ambient occlusion;\n* sun colored fog;", "tags": ["raymarching", "distancefields", "distance", "field"], "likes": 4, "viewed": 1071, "published": "Public API", "date": "1463308798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Rik Hendriks - Rikstar/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Changes to be made:\n//--------------------------------------------------------------------------------------------------------------------//\n// * Add a feature to the shadow functions such that it begins to calculate for shadows when it isn't in the object.\n// * Add a better shadow combiner. If the ambient occlusion is in a hard shadow right now, then it can't be seen.\n// * Give an id with the map function, such that the id tells which object is the closest to the vector p.\n// * Give objects different lighting parameters via the id system, this also includes different ambient occlusions.\n//--------------------------------------------------------------------------------------------------------------------//\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Rotation functions\n//--------------------------------------------------------------------------------------------------------------------//\n\nvec3 rotX(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x, p.z*s + p.y*c, p.z*c - p.y*s);\n}\n\nvec3 rotY(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c - p.z*s, p.y, p.x*s + p.z*c);\n}\n\nvec3 rotZ(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c - p.y*s, p.x*s + p.y*c, p.z);\n}\n\nvec3 rotXYZ(vec3 p, vec3 a)\n{\n    return rotZ(rotY(rotX(p, radians(a.x)), radians(a.y)), radians(a.z));\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Distance functions\n//--------------------------------------------------------------------------------------------------------------------//\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p, c) - (0.5 * c);\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Map function\n//--------------------------------------------------------------------------------------------------------------------//\n\nfloat Map(vec3 p)\n{\n    vec3 c = vec3(5.0, 0.0, 5.0);\n    \n    vec3 prim = opRep(p, c);\n    float d1 = sdSphere(prim, 1.5);\n    \n    prim = opRep(p - vec3(0.0, 0.5, 1.5), c);\n    float d2 = sdSphere(prim, 1.0);\n    \n    prim = opRep(p - vec3(1.5, 0.5, 0.0), c);\n    float d3 = sdSphere(prim, 1.0);\n    \n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float p1 = dot(p, n / length(n));\n    return min(min(min(d1, d2), d3), p1);\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// After effect funtions\n//--------------------------------------------------------------------------------------------------------------------//\n\nvec3 Gradient(vec3 p)\n{\n\tfloat d = Map(p);\n    \n    vec3 r = vec3(0.0, 0.0, 0.0);\n    float f = 0.00001;\n    \n    r.x = (Map(p + vec3(f, 0.0, 0.0)) - d) / f;\n    r.y = (Map(p + vec3(0.0, f, 0.0)) - d) / f;\n    r.z = (Map(p + vec3(0.0, 0.0, f)) - d) / f;\n    \n    return r / length(r);\n}\n\nfloat Shadow(vec3 p, vec3 lDir, float minT, float maxT, float k)\n{\n    float r = 1.0;\n    float t = minT;\n    float d = 0.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        d = Map(p + (lDir * t));\n\t\t\n        if(t > maxT) break;\n        if(d < minT) return 0.0;\n\n        r = min(r, (k * d) / t);\n              \n        t += d;\n    }\n    return r;\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 normal, float stepSize, float k)\n{\n    float r = 0.0;\n    float t = 0.0;\n  \n    for(int i = 0; i < 5; i++)\n    {\n        t += stepSize;\n        r += (1.0 / pow(2.0, t)) * (t - Map(p + (normal * t)));\n    }\n    return max(0.0, 1.0 - (k * r));\n}\n\nvec3 Fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering)\n{\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0.5, 0.6, 0.7), vec3(1.0, 0.9, 0.7), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Renderer function\n//--------------------------------------------------------------------------------------------------------------------//\n\nvec4 Renderer(vec2 uv)\n{\n    vec3 cameraPoint = vec3(0.0, 3.0, -20.0);\n    \n    vec3 eye = vec3(0.0, 0.0, -1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    \n    vec3 lightDir = rotXYZ(vec3(0.0, 0.0, 1.0), vec3(-30.0, 135.0, 0.0));\n    \n    vec3 planePoint = uv.x * right + uv.y * up;\n    \n    vec3 rot = vec3(0.0, 0.0, 0.0);\n    \n    float breakLength = 0.001;\n    \n    float maxLength = 1000.0;\n    \n    planePoint = rotXYZ(planePoint, rot);\n    eye = rotXYZ(eye, rot);\n    \n    planePoint += cameraPoint;\n    eye += cameraPoint;\n    \n    rot = vec3(-15.0 + (10.0 * sin(iTime * 0.7)), iTime * 30.0, 0.0);\n    \n    planePoint = rotXYZ(planePoint, rot);\n    eye = rotXYZ(eye, rot);\n    \n    vec3 forward = normalize(planePoint - eye);\n    \n    float t = 0.0;\n    \n    vec3 objectDiffuseColor = vec3(1.0, 1.0, 1.0);\n    vec3 objectSpecularColor = vec3(1.0, 1.0, 1.0);\n    \n    float ambientReflectance = 0.1;\n    vec3 ambientColor = vec3(1.0, 1.0, 1.0);\n    \n    float diffuseIntensity = 0.8;\n    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n    \n    float specularIntensity = 0.3;\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 5.0;\n    \n    float shadowIntensity = 0.4;\n    \n    float ambientOcclusionIntensity = 0.5;\n    float ambientOcclusionStepSize = 0.2;\n    \n    float fogExtintion = 0.02;\n    float fogInscattering = 0.01;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 ambient = vec3(0.0, 0.0, 0.0);\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    \n    float shadowC = 0.0;\n    float ambientO = 0.0;\n    vec3 gradient = vec3(0.0, 0.0, 0.0);\n    float fogC = 0.0;\n    \n    float d = 0.;\n    vec3 p = vec3(0.);\n    \n    // Main loop\n    for(int a = 0; a < 200; a++)\n    {\n        p = planePoint + (forward * t);\n        d = Map(p);\n        if(d < breakLength || t > maxLength) break;\n        t += d;\n    }\n    \n    t = min(t, maxLength);\n    \n    if(t < maxLength)\n    {\n        // Do the after effect functions\n        ambient = ambientReflectance * ambientColor;\n        shadowC = Shadow(p - (forward * breakLength), -lightDir, breakLength, 100.0, 10.0);\n        gradient = Gradient(p);\n        ambientO = AmbientOcclusion(p - (forward * breakLength), gradient, ambientOcclusionStepSize, ambientOcclusionIntensity);\n        \n        // Apply lighting\n        float dP = dot(gradient, -lightDir);\n        diffuse = diffuseColor * diffuseColor * diffuseIntensity * ((dP + 1.0) / 2.0);\n        if(dP >= 0.0)\n        {\n            vec3 h = - lightDir - forward;\n            h /= length(h);\n            specular = specularIntensity * specularColor * specularColor * pow(max(dot(gradient, h), 0.0), shininess);\n        }\n        \n        color = ambient + diffuse + specular;\n    }\n\t\n    float totalShadowC = min(shadowC, ambientO);\n    color = (color * shadowIntensity * (1.0 - totalShadowC)) + (color * totalShadowC);\n    \n    color = Fog(color, t, forward, -lightDir, fogExtintion, fogInscattering);\n    \n    color = pow(color.xyz, vec3(1.0 / 2.2));\n    \n    return vec4(color.x, color.y, color.z, 1.0);\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Main image function\n//--------------------------------------------------------------------------------------------------------------------//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    fragColor = Renderer(uv * 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVSz1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1236, 1236, 1264, 1264, 1362], [1364, 1364, 1392, 1392, 1490], [1492, 1492, 1520, 1520, 1618], [1620, 1620, 1649, 1649, 1725], [1992, 1992, 2025, 2025, 2053], [2055, 2055, 2083, 2083, 2119], [2380, 2380, 2399, 2399, 2798], [3068, 3068, 3091, 3091, 3354], [3356, 3356, 3422, 3422, 3708], [3710, 3710, 3780, 3780, 3989], [3991, 3991, 4085, 4085, 4316], [4582, 4582, 4606, 4606, 7685], [7953, 7953, 8008, 8008, 8147]], "test": "valid"}
{"id": "MdVXRz", "name": "Infinite Teeth", "author": "zackpudil", "description": "Someone needs to brush their teeth.", "tags": ["raymarching", "distancefields", "perlinnoise"], "likes": 13, "viewed": 425, "published": "Public", "date": "1462647038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n\treturn fract(sin(n)*42758.4545);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0 - 2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\t\n\treturn mix(\n\t\tmix(\n\t\t\tmix(hash(n + 000.0), hash(n + 001.0), f.x),\n\t\t\tmix(hash(n + 057.0), hash(n + 058.0), f.x),\n\t\t\tf.y),\n\t\tmix(\n\t\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat len(vec3 p, float l) {\n\tp = pow(abs(p), vec3(l));\n\treturn pow(p.x + p.y + p.z, 1.0/l);\n}\n\nfloat dTeeth(vec3 p) {\n    vec3 q = p;\n    p.x = mod(p.x + 1.0, 2.0) - 1.0;\n\tp.y -= 0.7*dot(p.xz, p.xz) - 0.25 - 0.2*smoothstep(0.2, 1.0, noise(3.0*p));\n\tp.y *= 1.25;\n\treturn len(p, 2.8) - 1.00 - 0.03*smoothstep(0.2, 0.8, noise(3.0*q));\n}\n\nfloat dMouth(vec3 p) {\n    float f = 0.4*smoothstep(0.1, 0.9, noise(2.0*p));\n    vec3 q = p;\n    p.y -= 1.0 - smoothstep(0.4, 2.0, abs(p.z));\n    return min(p.y + 1.0 + f, q.z + 2.5 + 0.3*f);\n}\n\nvec2 map(vec3 p) {\n    p.x += sign(p.y)*sin(iTime*5.0)*0.1;\n    p.y = -abs(p.y) + 0.75*texture(iChannel0, vec2(.25)).x + 1.0;\n    \n    vec2 m = vec2(dMouth(p), 0.0);\n    vec2 t = vec2(dTeeth(p), 1.0);\n    \n    return m.x < t.x ? m : t;\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n    float m = 0.0;\n\t\n\tfor(int i = 0; i < 60; i++) {\n\t\tvec2 h = map(ro + rd*t);\n\t\tif(abs(h.x) < 0.0001 || t >= 15.0) break;\n\t\tt += h.x*0.60;\n        m = h.y;\n\t}\n\t\n\treturn vec2(t, m);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 g = (vec3(\n\t\tmap(p + h.xyy).x,\n\t\tmap(p + h.yxy).x,\n\t\tmap(p + h.yyx).x) - map(p).x)/h.x;\n\t\n\treturn normalize(g);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float s = 0.013;\n    float t = s;\n    \n    float o = 0.0;\n    \n    for(int i = 0; i < 10; i++) {\n        float h = map(p + n*t).x;\n        o += t - h;\n        t += s;\n    }\n    \n    return clamp(1.0 - o, 0.0, 1.0);\n    \n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n\tvec3 ww = normalize(lat - eye);\n\tvec3 vv = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 uu = normalize(cross(ww, vv));\n\t\n\treturn mat3(vv, uu, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(iTime, 1.5, 4);\n\tvec3 rd = camera(ro, ro + vec3(-1.0, -1.5, -4.0))*normalize(vec3(uv, 1.97));\n\t\n\tvec3 col = vec3(1, .1, .1);\n\t\n\tvec2 i = march(ro, rd);\n\t\n\tif(i.x < 15.0) {\n\t\tvec3 pos = ro + rd*i.x;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tvec3 lig = normalize(vec3(0.8, 0.0, 0.6));\n\t\t\n\t\tfloat amb = clamp(0.5 + 0.5*nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\t\tfloat spe = pow(clamp(dot(lig, ref), 0.0, 1.0), 32.0);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        \n        float occ = ao(pos, nor);\n\t\t\n\t\tcol  = 0.2*amb*vec3(1);\n\t\tcol += 0.7*dif*vec3(1);\n\t\t\n\t\tif(i.y == 1.0) {\n\t\t\tvec3 mat = vec3(1);\n            \n            pos.x += sign(pos.y)*sin(iTime*5.0)*0.1;\n            pos.y -= sign(pos.y)*0.5*texture(iChannel0, vec2(.25)).x;\n\t\t\tfloat f = smoothstep(0.1, 0.4, noise(3.0*pos));\n\t\t\tmat = mix(mat, vec3(0.7, 0.7, 0.1), 1.0 - f);\n            \n\t\t\tpos.x = mod(pos.x + 1.0, 2.0) - 1.0;\n\t\t\tf = smoothstep(0.0, 0.4, length(pos.xz));\n\t\t\tmat = mix(mat, vec3(0.0), smoothstep(0.0, 1.0, 2.0*(1.0 - f)));\n\t\t\t\n\t\t\tcol *= mat;\n\t\t} else {\n\t\t\tcol *= vec3(0.8, 0.1, 0.1);\n\t\t}\n\t\t\n\t\tcol += 1.0*spe*vec3(1)*dif;\n\t\tcol += 0.4*fre*vec3(1);\n        \n        col *= occ;\n\t}\n\t\n\tcol = pow(col, vec3(.454545));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 57], [59, 59, 80, 80, 432], [434, 434, 462, 462, 528], [530, 530, 552, 552, 768], [770, 770, 792, 792, 963], [965, 965, 983, 983, 1202], [1204, 1204, 1234, 1234, 1434], [1436, 1436, 1457, 1457, 1605], [1607, 1607, 1633, 1633, 1859], [1861, 1861, 1894, 1894, 2042], [2044, 2044, 2101, 2101, 3493]], "test": "error"}
{"id": "MdVXzw", "name": "Squares Background v2", "author": "vamoss", "description": "Square animation for background", "tags": ["square", "rectangle", "background", "watery"], "likes": 41, "viewed": 1127, "published": "Public", "date": "1463608473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 bgColor = vec3(0.01, 0.16, 0.42);\nvec3 rectColor = vec3(0.01, 0.26, 0.57);\n\n//noise background\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\n//rectangles\nconst float total = 60.;//number of rectangles\nconst float minSize = 0.03;//rectangle min size\nconst float maxSize = 0.08-minSize;//rectangle max size\nconst float yDistribution = 0.5;\n\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv )\n{\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    \n\tf = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv )\n{\n    float velocity = iTime/1.6;\n    float intensity = sin(uv.x*3.+velocity*2.)*1.1+1.5;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    //rb = sqrt(rb); \n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp)+1.2;\n\n    //bazooca line\n    //rz *= sin(uv.x*.5+velocity*.8);\n\n\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n\nfloat rectangle(vec2 uv, vec2 pos, float width, float height, float blur) {\n    \n    pos = (vec2(width, height) + .01)/2. - abs(uv - pos);\n    pos = smoothstep(0., blur , pos);\n    return pos.x * pos.y; \n   \n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //bg\n    vec3 color = bg(uv)*(2.-abs(uv.y*2.));\n    \n    //rectangles\n    float velX = -iTime/8.;\n    float velY = iTime/10.;\n    for(float i=0.; i<total; i++){\n        float index = i/total;\n        float rnd = random(vec2(index));\n        vec3 pos = vec3(0, 0., 0.);\n        pos.x = fract(velX*rnd+index)*4.-2.0;\n        pos.y = sin(index*rnd*1000.+velY) * yDistribution;\n        pos.z = maxSize*rnd+minSize;\n        vec2 uvRot = uv - pos.xy + pos.z/2.;\n    \tuvRot = rotate2d( i+iTime/2. ) * uvRot;\n        uvRot += pos.xy+pos.z/2.;\n        float rect = rectangle(uvRot, pos.xy, pos.z, pos.z, (maxSize+minSize-pos.z)/2.);\n\t    color += rectColor * rect * pos.z/maxSize;\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 405, 427, 427, 499], [501, 501, 527, 527, 849], [851, 851, 876, 876, 1138], [1140, 1140, 1159, 1159, 1647], [1650, 1650, 1725, 1725, 1859], [1861, 1861, 1889, 1889, 1975], [1977, 1977, 2034, 2034, 2852]], "test": "valid"}
{"id": "MdySRW", "name": "Saturns Rings", "author": "innovati", "description": "A trip through the solar system", "tags": ["rings", "saturn"], "likes": 0, "viewed": 109, "published": "Public", "date": "1463090428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n  fragColor = vec4((gl_FragCoord.y / iResolution.y), (gl_FragCoord.y / iResolution.y), tan(tan(((float(iFrame) * 1.8) / (min(atan((gl_FragCoord.x / iResolution.x), (gl_FragCoord.y / iResolution.y)), 2.5) + (gl_FragCoord.y / iResolution.y))))), 2.6);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdySRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "MdySWW", "name": "Flooded Canyon", "author": "zackpudil", "description": "A very simple ray marched terrain with volumetric water. This seems to render very weird on my Windows 7 ThinkPad work laptop, so apologizes if you see that. Please let me know if you see something weird.", "tags": ["raymarching", "volumetric"], "likes": 6, "viewed": 246, "published": "Public", "date": "1464328346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tmax = 20.0;\n\n// ----- random -----\nfloat hash2(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.988, 71.233)))*43758.5453);\n}\n\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nvec3 hash(vec3 x) {\n\tvec3 n = vec3(\n\t\tdot(x, vec3(171.0, 311.0, 57.0)),\n\t\tdot(x, vec3(269.0, 382.0, 113.0)),\n\t\tdot(x, vec3(129.0, 234.0, 170.0))\n\t);\n\n\treturn fract(sin(n)*43758.5453);\n}\n\n// ---- perlen noise, most basic implemntation ----\nfloat noise(vec3 g) { // 3d\n\tvec3 p = floor(g);\n\tvec3 f = fract(g);\n\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\n\tfloat x = mix(hash(n + 0.), hash(n + 1.), f.x);\n\tfloat y = mix(hash(n + 57.), hash(n + 58.), f.x);\n\tfloat z = mix(hash(n + 113.), hash(n + 114.), f.x);\n\tfloat w = mix(hash(n + 170. /* this number is the addition of y coeff and z coeff*/), hash(n + 171.), f.x);\n\n\treturn mix(mix(x, y, f.y), mix(z, w, f.y), f.z);\n}\n\nfloat noise(vec2 g) { //2d\n\tvec2 p = floor(g);\n\tvec2 f = fract(g);\n\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat x = mix(hash(n + 0.0), hash(n + 1.0), f.x);\n\tfloat y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n\n\treturn mix(x, y, f.y);\n}\n\nconst mat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n// 2d fractional browning motion.\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m2*2.01;\n\tf += 0.2500*noise(p); p *= m2*2.04;\n\tf += 0.1250*noise(p); p *= m2*2.07;\n\tf += 0.0625*noise(p);\n\n\treturn f;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n// 3d fractional browning motion.\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m3*2.01;\n\tf += 0.2500*noise(p); p *= m3*2.04;\n\tf += 0.1250*noise(p); p *= m3*2.07;\n\tf += 0.0625*noise(p);\n\n\treturn f;\n}\n\n// vornoi pattern.\nfloat voronoi(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tfloat d = 8.0;\n\tfor(int i = -1; i <= 1; i++)\n\tfor(int j = -1; j <= 1; j++) \n\tfor(int k = -1; k <= 1; k++) {\n\t\tvec3 g = vec3(float(i), float(j), float(k));\n\t\tvec3 r = g + hash(p + g) - f;\n\n\t\td = min(d, dot(r, r));\n\t}\n\n\treturn sqrt(d);\n}\n\nfloat map(vec3 p) {\n    // a simple plan modified with fbm and some noise for hills.\n\treturn p.y + 1.0  \n\t\t- 0.8*noise(p) // hills\n\t\t- smoothstep(0.4, 0.7, fbm(2.0*p.xz)); // mountains\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\n\tfor(int i = 0; i < 300; i++) {\n\t\tfloat d = map(ro + rd*t);\n\t\tif(abs(d) < 0.001 || t >= tmax) return t;\n        // only stepping a small amount to get more details.\n        // con is we have to march we more or the ray get's stopped to soon.\n\t\tt += d*0.1;\n\t}\n\n\treturn t;\n}\n\nfloat volume(vec3 p) {\n    // a simple cosine plan with fbm modification.\n\tfloat d = -(p.y + 0.5);\n\td += 0.5*fbm(4.0*p + iTime);\n\td += 0.4*cos(2.0*p.x + iTime)*sin(2.0*p.z + iTime);\n\treturn clamp(d, 0.0, 1.0);\n}\n\nvec4 volumetric(vec3 ro, vec3 rd, float mt, vec2 p) {\n\tfloat s = 0.05, t = 0.0;\n\tvec4 sum = vec4(0);\n\n\tt += 0.05*hash2(p); // dithering for psuedo aa.\n\tfor(int i = 0; i < 200; i++) {\n\t\tif(sum.a > 1.00) continue; // break the loop if we got 100% opacity.\n\t\tif(t > mt) continue; // break if the volume ray intersected with solid geometry. Don't render any fog  behind it.\n\n\t\tfloat d = volume(ro + rd*t);\n        // mixing between a light blue and white.\n\t\tvec4 c = vec4(mix(vec3(1), vec3(0.0, 0.4, 1.0), 1.0 - d), d);\n        // fog for the water.\n        c.rgb = mix(c.rgb, vec3(1), 1.0 - exp(-0.02*t));\n\n        // increase the opacity 10 fold so it looks less like fog and more like water.\n\t\tc.a *= 10.0;\n\t\tc.rgb *= c.a;\n        // back to front blending.\n\t\tsum += c*(1.0 - sum.a);\n\n\t\tt += s;\n\t}\n\n    // adding this step outside the loop...\n    // a white vornoi pattern on the total distance traveled for the ray.\n\tsum.rgb = mix(sum.rgb, vec3(1), 0.4*voronoi(2.0*(ro + rd*t)));\n\n\treturn clamp(sum, 0.0, 1.0);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\n    // bump mapping on the canyons.\n\tfloat f = 20.0; \n\tvec3 b = 0.3*vec3(\n\t\tfbm(f*(p + h.xyy)) - fbm(f*(p - h.xyy)),\n\t\tfbm(f*(p + h.yxy)) - fbm(f*(p - h.yxy)),\n\t\tfbm(f*(p + h.yyx)) - fbm(f*(p - h.yyx))\n\t);\n\n\treturn normalize(n + b);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    // the simplest ambient occlusion.\n\tfloat s = 0.005, t = s;\n\tfloat o = 0.0, w = 1.0;\n\n\tfor(int i = 0; i < 25; i++) {\n\t\tfloat d = map(p + n*t);\n\t\to += (t - d)*w;\n        // this adds a scattering effect.\n        //Dampins the occlusion as the distance travele\n\t\tw *= 0.85;\n        \n        // a simple constant step.\n\t\tt += s;\n\t}\n\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\n// a basic camera matrix. Right hand rule.\nmat3 camera(vec3 eye, vec3 lat) {\n    // the vector pointing from the eye to the look at position.\n\tvec3 ww = normalize(lat - eye);\n    // vector pointing to the left\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    // vector pointing up (relative to the foward vector).\n\tvec3 vv = normalize(cross(ww, uu));\n\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy); // [0, 1] -> [-1, 1]\n\tuv.x *= iResolution.x/iResolution.y; // aspect ratio.\n\n    // camera position, just move along the z direction linearly.\n\tvec3 ro = vec3(0, 1.0 - 0.25*cos(iTime*0.5), iTime*0.6);\n    // construct the ray direction, using the 3x3 camera matrix, and the current uv coord.\n\tvec3 rd = normalize(camera(ro, ro + vec3(0.0, -1.2, 3))*vec3(uv, 1.97));\n\n    // background color a blue sky. mixed in with some clouds. fbm based on xy coords of ray direction\n\tvec3 col = mix(vec3(0.2, 0.6, 1.0), vec3(1), smoothstep(0.4, 1.0, fbm(20.0*rd.xy)));\n\n    // ray march.\n\tfloat i = march(ro, rd);\n\n    // if the ray is less then the max we hit something.\n\tif(i < tmax) {\n        // get the geometry of what we hit.\n        //  Position, surface normal, and the reflected vector of the norm and the veiw dir.\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\n        /* very simple lighting, only ambient and diffuse */\n        \n        // two lights, both direction. \n\t\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6)); // sun light.\n\t\tvec3 gli = normalize(vec3(0, -1.0, 0.0)); // ground light.\n\n\n\t\tcol  = 0.2*vec3(1); // ambient light.\n\t\tcol += 0.7*clamp(dot(lig, nor), 0.0, 1.0); // diffuse light for sun.\n\t\tcol += 0.1*clamp(dot(gli, nor), 0.0, 1.0); // diffuse light for ground.\n\n        // material, nothing fancy just a mixing of a brown and a darker brown.\n\t\tcol *= mix(vec3(0.72, 0.45, 0.3), vec3(0.33, 0.2, 0.0), fbm(30.0*pos));\n\n        // ambient occlusion.\n\t\tcol *= vec3(ao(pos, nor));\n\n        // fog, only affected when we intersect so we don't loose are background color.\n\t\tcol = mix(col, vec3(0.5), 1.0 - exp(-1.0*smoothstep(4.0, 10.0, i)));\n\t}\n\n    // render the render with volumetric rendering.\n\tvec4 v = volumetric(ro, rd, i, uv);\n\tcol = mix(col, v.rgb, v.a); // mix that with the overall color of the scene.\n\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdySWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 48, 69, 69, 132], [134, 134, 155, 155, 191], [193, 193, 212, 212, 378], [380, 432, 453, 459, 879], [881, 881, 902, 907, 1131], [1184, 1218, 1237, 1237, 1402], [1519, 1553, 1572, 1572, 1737], [1739, 1758, 1781, 1781, 2059], [2061, 2061, 2080, 2145, 2247], [2249, 2249, 2280, 2280, 2570], [2572, 2572, 2594, 2645, 2783], [2785, 2785, 2838, 2838, 3797], [3799, 3799, 3820, 3820, 4208], [4210, 4210, 4236, 4275, 4606], [4608, 4651, 4684, 4749, 4990], [4992, 4992, 5049, 5049, 6990]], "test": "valid"}
{"id": "MdySzR", "name": "marbling", "author": "lainga", "description": "trying to recreate the marbling effect seen on endpapers from old books.", "tags": ["paper", "marbling", "renaissance"], "likes": 1, "viewed": 258, "published": "Public", "date": "1462403129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 pa(in vec2 uv, in float per){\n    vec2 result = (sin(uv.x*per)) * normalize(vec2(cos((uv.x)*per), .5));\n    return result;\n}\n\nvec2 pb(in vec2 uv, in float per){\n    vec2 result = (cos(uv.y*per)) * normalize(vec2(1., cos((uv.y)*per)));\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/4.;\n    \n\tvec2 uv = -1. + 2.*(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y*.5+.5;\n        \n    vec2 vpert = pa(uv, 20.);\n    uv += vpert * sin(t) *.2;\n    \n    vec2 hpert = pb(uv, 51.);\n     uv += hpert * sin(t) * .08;\n    \n    vec4 col = texture(iChannel0, uv);\n\tfragColor = fragColor = mix(vec4(sin(uv.y*2.), 0., cos(uv.y*3.), 1.), col, .9);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdySzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 36, 36, 131], [133, 133, 167, 167, 262], [264, 264, 321, 321, 714]], "test": "error"}
{"id": "Ms3SDl", "name": "G-Lectric Sheep", "author": "vox", "description": "Sorry guys! I still can't wrap my mind around why we can't do Fractal Flames in GLSL alone... This is my latest attempt, and at least my eyes are fooled :)", "tags": ["glectricsheepelectric"], "likes": 3, "viewed": 701, "published": "Public API", "date": "1462073949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map))\n        \t*smoothstep(0.0, .5, saw(map*2.0*PI));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\n\nfloat seedling;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(uv*2.0-1.0)*1.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 fbdim = vec2(851.0, 315.0); //Facebook cover photo dimensions.\n    vec2 fbdim = iResolution.xy;\n    float fbaspect = fbdim.y/fbdim.x;\n   \n    vec2 uv = fragCoord.xy-iResolution.xy/2.0;\n    \n    if(abs(uv.x) > fbdim.x/2.0 || abs(uv.y) > fbdim.y/2.0)\n        discard;\n    \n    float zoom = 4.0;//(8.0+3.0*sin(time))*PI;\n    \n    uv = uv.xy / (iResolution.xy/2.0-fbdim.xy);\n    uv.x *= fbaspect;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    \n   \tconst int max_i = 16;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float sum = 0.0;\n    float magnification;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/fbdim, magnification);\n        \n        stretch *= magnification;\n        \n        //omg so platform dependent... pls help fix:\n        float weight = smoothstep(.25, 1.0, ifs*2.0);\n        \n        uv = next*weight+uv*(1.0-weight);\n        \n        sum += (seedling+pow(clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0), .5))*weight;    \n        \n        ifs *= sqrt(clamp(1.0/stretch, 0.0, 1.0)*weight);\n        \n\t\tif(ifs == 0.0)\n            break;\n    }\n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = vec4(phase(sum*PI), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 264, 264, 414], [463, 463, 492, 492, 562], [564, 564, 593, 593, 677], [743, 743, 765, 765, 1003], [1005, 1005, 1024, 1024, 1069], [1071, 1071, 1130, 1130, 1703], [1705, 1705, 1762, 1836, 2987]], "test": "valid"}
{"id": "Ms3SR2", "name": "Shadertoy on Dome", "author": "bergi", "description": "Description of the process used to make this video:\n[url]https://vimeo.com/defgsus/shadertoy[/url]\nDrag mouse up/down to blend between flat browser and fulldome view. ", "tags": ["3d", "fulldome"], "likes": 15, "viewed": 875, "published": "Public API", "date": "1463421002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\tShadertoy on Dome - https://www.shadertoy.com/view/Ms3SR2\n  \t(cc) 2016, Stefan Berke / berke@cymatrix.org\n\n  \tA little making-of of my https://vimeo.com/defgsus/shadertoy video. \n   \n  \tThis uses the \"Voxel Edges\" shader from iq as example\n  \thttps://www.shadertoy.com/view/4dfGzs\n\n    The typical Shadertoy mainImage() function is extended to \n\t\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord, \n                   in vec3 sphereDir, in float sphereMix)\n\n\twhere sphereDir is the normalized ray direction of the spherical\n\tfulldome view and sphereMix is a mix variable between 0 and 1. \n\n\tIn order to view a particular 3d-shader on the dome i overwrite the\n\tray direction before the ray-marching. To make the transition between\n\tthe flat screen and the fulldome/fisheye view seamless the sphereMix\n\tvariable is used. \n\t\n\tAlso all post-processing wich depends on the uv-screen-coordinate\n\t(like vignetting) is mixed out, because there is no screen coordinate\n\tin fulldome view.\n\n\tSee the _uv_to_sphere(in vec2 uv, in float angle) function below in\n\tthe helper section for the screen-to-fulldome conversion. \n\tIn my video above, i used a skybox and the 5-camera-rig model to \n\trender the fulldome master.\n\n\tTo get the right fulldome ray direction for the 'shader' in the virtual browser,\n\ti simply use the direction of the ray which hits the browser plane in the \n\tfirst place. If your 3d environment supports fulldome rendering via 5-camera-rigs\n\tor other means that should be no problem. Otherwise you can use the approach\n\tfrom this shader and simply render everything on the screen-quad using _uv_to_sphere().\n\t\n\t\n\tThank you Shadertoyers around the world for all your effort and inspiration!\n*/\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 ed = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 co = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 ep = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 cp = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        vec4 ee = 1.0-ep*(1.0-ed);\n        float www = 1.0;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.x )*ee.x;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.x )*ee.y;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.y )*ee.z;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.y )*ee.w;\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x))*(1.0-ee.x)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y))*(1.0-ee.y)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z))*(1.0-ee.y)*(1.0-ee.w);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w))*(1.0-ee.x)*(1.0-ee.w);\n\t\t\n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = 2.0*texture( iChannel1,0.01*pos.xz ).zyx; \n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = 0.0; \n        // (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        // (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-ep.x*(1.0-ed.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-ep.y*(1.0-ed.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-ep.z*(1.0-ed.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-ep.w*(1.0-ed.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.90, 0.95, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImageST(out vec4 fragColor, in vec2 fragCoord, \n                 in vec3 sphereDir, in float sphereMix)\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n    \n    // XXX Here the ray-direction is mixed\n    rd = mix(rd, cam * sphereDir, sphereMix); \n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\n    vec3 ppcol = col * (0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ) );\n\t\n    // XXX Here we mix the color with the post-processed color\n    // which depends on the screen uv\n    col = mix(col, ppcol, 1.-sphereMix);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n// -------------- helper -----------------------------------\n\n/* Insert cartesian [-1,1], receive sphere surface [-1,1].\n   @p angle is in degree */\nvec3 _uv_to_sphere(in vec2 uv, in float angle)\n{\n    // distance from center\n    float dist = length(uv);\n\n    if (dist > 1.0)\n        return vec3(0.);\n\n    float   // cartesian screen-space to spherical\n            theta = dist * 3.14159265 * angle / 360.0,\n            phi = atan(uv.y, uv.x);\n\n    // spherical-to-cartesian\n    return vec3(sin(theta) * cos(phi),\n                sin(theta) * sin(phi),\n                -cos(theta));\n}\n\n/** Returns intersection position along the ray ro -> rd\n    for a plane with normal plane.xyz and position plane.xyz * plane.w.\n    Result is either negative for no hit\n    or the distance between ro and the intersection point. */\nfloat _intersect_plane(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    float dir = dot(plane.xyz, rd);\n    if (abs(dir) < 0.0001) return -1.;\n    return dot(plane.xyz, plane.xyz * plane.w - ro) / dir;\n}\n\nfloat _hash1(in vec2 x) { return fract(sin(x.x*11.+x.y*17.)*(17162.31+111.*x.y)); }\nvec2 _hash2(in vec2 x) { return vec2(_hash1(x),_hash1(x*1.1-3.13)); }\n\n\n// ----- chars ---------------------------------------------\n\n// uv = [-1,1]\nfloat _random_char(in vec2 uv, in vec2 seed)\n{\n    float l = length(uv);\n    float d = 100.;\n#define SEG(prob, di) d = min(d, floor(1./(prob)*_hash1(seed+=.1*seed-.1)) + di);\n    SEG(.3 , abs(uv.x - uv.y*.8)-.2)\n    SEG(.3 , abs(uv.x + uv.y*.8)-.2)\n    SEG(.3 , abs(uv.x)-.15)\n    SEG(.1 , abs(uv.y)-.15)\n    SEG(.1 , abs(uv.y-.7)-.15)\n    SEG(.1 , abs(uv.x-.7)-.2)\n    SEG(.1 , abs(uv.x+.7)-.2)\n    SEG(.07, max(l-.8, -l+.5))\n    SEG(.1 , max(max(l-.8, -l+.5), -uv.x))\n    SEG(.1 , max(max(l-.8, -l+.5),  uv.x))\n#undef SEG\n    d = max(d, -uv.x-.8);    \n    d = max(d,  uv.x-.8);    \n    d = max(d, -uv.y-.8);    \n    d = max(d,  uv.y-.8);    \n        \n\t//d = max(d, -d); // edge\n        \n    return smoothstep(.1, .0, d);\n}\n\n/** creates left-bounded text, one char per uv-unit */\nfloat _random_text(in vec2 uv, in vec2 seed, in float max_len)\n{\n    vec2 cell = floor(uv); \n    if (uv.x >= max_len || _hash1(vec2(cell.y)) < cell.x / max_len) \n        return 0.;\n    \n    return _random_char(fract(uv)*2. - 1., cell + seed);\n\t     \n}\n// --------------------------------------------------\n\n\n// --------------- fake browser ---------------------\n\nfloat _rect(in vec2 uv, in vec2 si)\n{\n    return uv.x >= 0. && uv.y >= 0. && uv.x <= si.x && uv.y <= si.y ? 1. : 0.; \n}\n\nvec4 _codeWindow(in vec2 uv, in vec2 si)\n{\n    vec4 col = vec4(1,1,1, _rect(uv,si));\n    col.xyz *= 1.-_random_text(uv*40., vec2(1.), 40.);\n\treturn col;\n}\n\nvec4 _browserWindow(in vec2 uv, in float aspect, \n                    in float sphereMix, in vec3 sphereDir)\n{\n    vec2 si = vec2(aspect, 1.);\n    vec4 col = vec4(.8,.8,.8, _rect(uv, si));\n\t\n    // header\n    float head = _rect(uv-vec2(0.,.92), si * vec2(1.,.08));\n    col.xyz += head * (vec3(.4) - col.xyz);\n\tcol.xyz += head * _random_text(uv*12.-vec2(0,10), vec2(5), 10.);\n    vec2 headuv = (uv-vec2(si.x/1.7,0.11)) * 24.;\n    if (headuv.x > 0. && int(headuv.y) == 20)\n\tcol.xyz += head * _random_text(headuv, vec2(.1), 50.);\n    \n    // code window\n    vec4 cCode = _codeWindow(uv-si/vec2(2.1,5.), si*vec2(.5,.63));\n    col += cCode.w * (cCode - col);\n    col.xyz *= 1.-.3*_rect(uv-si/vec2(2.1,1.2), vec2(.06, .05));\n    col.xyz += _rect(uv-si/vec2(1.95,1.2), vec2(.09, .05)) * (vec3(1.,.7,0) - col.xyz);\n    \n    // texture inputs\n    for (float i=0.; i<4.; ++i)\n    \tcol.xyz *= 1. - _rect(uv - vec2(si.x/2.1 + si.x*i/8.,.02), si/8.5);\n    \n    // messages\n    if (uv.x > 0.02 && uv.y < .3)\n    \tcol.xyz *= 1. - _random_text((uv-vec2(0.02,0))*40., vec2(.1), 30.);\n    \n    // shader window\n    vec2 suv = (uv - vec2(.03, .38)) * vec2(2.3/si.x, 2.);\n    if (suv.x >= 0. && suv.y >= 0. && suv.x < 1. && suv.y < 1.)\n        mainImageST(col, suv * iResolution.xy, sphereDir, sphereMix);\n    \n    return col;\n}\n\n// --------------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float onDome = .5+.6*sin(iTime/4.+.3);\n    if (iMouse.z > .5)\n        onDome = iMouse.y / iResolution.y * 1.1;\n    onDome = clamp(onDome, 0., 1.);\n    \n    \n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n    if (length(uv) > 1.)\n        fragColor = vec4(0,0,0,1);\n    else\n    {\n        // fulldome/fisheye ray direction \n        vec3 sphereDir = _uv_to_sphere(uv, 180.);\n\n        // render dome image\n       \tmainImageST(fragColor, fragCoord, sphereDir, 1.);\n        fragColor.xyz *= onDome * onDome;\n\t\t\n        // render browser window\n        if (onDome < 1.)\n        {\n            vec3 planeNorm = normalize(vec3(0,1,2.-onDome));\n            float t = _intersect_plane(vec3(0.), sphereDir, vec4(planeNorm,-(1.-onDome)));\n            if (t > 0.)\n            {\n                vec2 puv = (sphereDir * t).xy+1.-.4*onDome;\n                vec4 c = _browserWindow(puv, 1.9, onDome, sphereDir);\n                fragColor.xyz += c.w * (c.xyz - fragColor.xyz);\n            }\n        }\n        \n    }\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1833, 1833, 1859, 1859, 2070], [2072, 2072, 2125, 2125, 2277], [2279, 2279, 2307, 2307, 2682], [2707, 2707, 2730, 2730, 2869], [2916, 2916, 2987, 2987, 3524], [3526, 3526, 3558, 3558, 3742], [3744, 3744, 3796, 3796, 3974], [3976, 3976, 4015, 4015, 8696], [8698, 8698, 8812, 8827, 9809], [9877, 9964, 10012, 10040, 10399], [10401, 10633, 10696, 10696, 10832], [10834, 10834, 10859, 10859, 10917], [10918, 10918, 10942, 10942, 10987], [11793, 11848, 11912, 11912, 12099], [12211, 12211, 12248, 12248, 12330], [12332, 12332, 12374, 12374, 12486], [12488, 12488, 12598, 12598, 13796], [13855, 13855, 13910, 13910, 14933]], "test": "error"}
{"id": "Ms3SWr", "name": "Sound Blob", "author": "seb0fh", "description": "blobby sound visualizer", "tags": ["raymarching", "metaball", "soundcloud"], "likes": 30, "viewed": 1264, "published": "Public API", "date": "1462594272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tSound Blob\n\t05/2016\n\tseb chevrel\n*/\n#define PI 3.14159\n#define TWO_PI 6.2831\n\n// rotations\nvec3 rotateX(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 rotateY(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x); }\nvec3 rotateZ(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n// signed distance primitives (from IQ)\nfloat sdSphere(vec3 p,float r) { return (length(p) - r); }\nfloat sdTorus(vec3 p,float r,float r2) { return(length( vec2(length(p.xz)-r,p.y) )-r2); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdHexPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x); }\n\nfloat smin( float a, float b, float k ) {float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\n\n// scene distance function\n// returns vec2( ID, distance) ID of object and distance from scene to point p\n#define NUMFREQ 12\nvec2 map(in vec3 p) \n{\n\tfloat freqs[NUMFREQ];\n    float t,d,minD = 100000000.0,minID=0.0;\n\n    float a=2.5*TWO_PI,b,c;\n    float total=0.0;\n    \n\tfor(int i=0; i<NUMFREQ; i++) {\n        t=float(i)/float(NUMFREQ);\n    \tfreqs[i]=texture(iChannel0,vec2(t,0.25)).x;\n        b=sin(PI*t+iTime*1.3);\n        c=t*a;\n        d=sdSphere(p+vec3(cos(c*0.9+iTime*2.)*b, sin(c+iTime*1.7)*b, 2.0*t-1.0)*0.1 , 0.01+freqs[i]*pow(1.11,float(i))*0.05);        \n        total+=d;\n        minD=smin(minD,d,0.07);\n        //if (d<minD) { minD=d; }\n        \n    }    \n    return vec2( 1.0, minD );\n}\n\n// calculate scene normal vector at point p\n// normal is calculated from the distance gradient on each axis\nvec3 calcNormal( in vec3 pos,in float epsilon )\n{\n\tvec3 eps = vec3( epsilon, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).y - map(pos-eps.xyy).y,\n\t    map(pos+eps.yxy).y - map(pos-eps.yxy).y,\n\t    map(pos+eps.yyx).y - map(pos-eps.yyx).y );\n\treturn normalize(nor);\n}\n\n// Raymarch function\n// returns vec2(ray length,normalized iterations, object ID)\n\n\n#define RM_EPSILON 0.002\n#define RM_MIN_STEP_SIZE 0.001\n#define RM_MIN_DISTANCE 0.01\n\nvec3 rayMarch(in vec3 from, \t\t// ray origin\n               in vec3 direction \t// ray normalized direction\n)\n{\n    float travel_distance = 0.0; // the total length of the ray\n    for (float i = 0.0; i < 64.0; i+=1.0) \n    {    \n\t    vec3 position = from + direction * travel_distance; // current position   \n        vec2 result = map(position);  \n        \n        float object_id = result.x;\n        float distance_to_scene = result.y;\n    \t\n        if (distance_to_scene < RM_EPSILON) \t// distance to obj is below epsilon\n        {\t\n            return vec3(travel_distance,i/64.0,object_id); // return distance\n    \t}\n        // advance the ray by the scene distance or minimum ray step size\n        travel_distance += max(distance_to_scene,RM_MIN_STEP_SIZE);\n    }\n    // we haven't hit anything, return 0.0 distance, 1.0 iterations, ID 0.0\n    return vec3(0.0,1.0,0.0);\n}                \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xx) -vec2( 0.5,0.5*iResolution.y/iResolution.x);\n\t\n    float time=iTime*1.5;\n    float dist=0.8;\n    \n    vec3 camera_position = vec3(0.0,0.0,-dist);\n    vec3 ray_direction = normalize(vec3(uv, 1.0)); // fov\n \t\n    //ray_direction=rotateX(ray_direction,iMouse.y/iResolution.y);\n    camera_position=vec3(sin(time)*dist,0.,-cos(time)*dist); // orbit cam\n    ray_direction=rotateY(ray_direction,-time);\n    \n    // raymarch the scene (result x = distance, y = iterations, z = object_ID)\n    vec3 result = rayMarch(camera_position, ray_direction); \n    \n    float amp=texture(iChannel0,vec2(0.5,0.75)).x;\n    vec4 color=vec4( vec3(0.3,0.9,1.0)*amp*0.1/length(uv),1.0);;\n    \n    if (result.x!=0.0) {\n        vec3 position = camera_position+(ray_direction*result.x);\n    \tvec3 normal = calcNormal(position,0.001);\n    \tvec3 light = normalize(vec3(-1.0,1.0,-0.5));\n        vec3 reflection = reflect( ray_direction, normal );\n    \tfloat diffuse = dot(normal,light);\n        float specular = pow(clamp( dot( reflection, light ), 0.0, 1.0 ),20.0);\n        float iterations = (1.-result.y);\n        color=vec4( vec3(specular*diffuse)*vec3(1.,1.,1.)+\n                    vec3(diffuse*0.4+0.6)*vec3(0.9,0.5-(result.y)*0.5,(1.0/result.x)*0.1),1.0);\n    }   \n\tfragColor = color;\n}\n\n", "image_inputs": [{"id": "XtlXW4", "previewfilepath": "https://soundcloud.com/sebchevrel/ninetyseven", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sebchevrel/ninetyseven", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 95, 126, 126, 206], [207, 207, 238, 238, 318], [319, 319, 350, 350, 430], [431, 471, 503, 503, 529], [530, 530, 570, 570, 619], [620, 620, 651, 651, 734], [735, 735, 771, 771, 847], [849, 849, 890, 890, 974], [1102, 1102, 1124, 1124, 1677], [1679, 1787, 1836, 1836, 2059], [2231, 2231, 2340, 2340, 3104], [3122, 3122, 3179, 3179, 4485]], "test": "error"}
{"id": "Ms3SWs", "name": "Stargate Ripples", "author": "ShardFenix", "description": "It's basically four circular wave generators outside the corners of the screen, plus a spiral generator in the middle.", "tags": ["sinewaves"], "likes": 4, "viewed": 338, "published": "Public", "date": "1462243866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat ang(vec2 uv, vec2 center){\n\treturn atan((uv.y-center.y),(uv.x-center.x));\n}\n\nfloat spir(vec2 uv, vec2 loc){\n    float dist1=length(uv-loc);\n    float dist2=dist1*dist1;\n    float layer6=sin((ang(uv,loc)+dist2-iTime)*6.0);\n    layer6 = layer6*dist1;\n    return layer6;\n}\n\nfloat ripl(vec2 uv, vec2 loc, float speed, float frequency){\n    return sin(iTime*speed-length(uv-loc)*frequency);\n}\n\nfloat height(in vec2 uv){\n    float layer1=sin(iTime*8.54-sin(length(uv-vec2(-0.41,-0.47)))*55.0);\n    float layer2=sin(iTime*7.13-sin(length(uv-vec2(1.35,1.32)))*43.0);\n    float layer3=sin(iTime*7.92-sin(length(uv-vec2(-0.34,1.28)))*42.5);\n    float layer4=sin(iTime*6.71-sin(length(uv-vec2(1.23,-0.24)))*47.2);\n\n    float spiral=spir(uv,vec2(0.5,0.5));\n    spiral*=3.0;\n    \n    float temp = layer1+layer2+layer3+layer4+spiral;\n    \n    float b=smoothstep(-2.5,5.0,temp);\n    return b*3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    \n    if (length(uv-vec2(0.5,0.5))>0.5)\n    \t{\n        fragColor=vec4(0.0,0.0,0.0,0.0);return;\n        }\n    \n    float waveHeight=0.4+height(uv);\n    \n    vec3 color=vec3(waveHeight*0.3,waveHeight*0.5,waveHeight);\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3SWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 138], [140, 140, 172, 172, 221], [223, 223, 253, 253, 415], [417, 417, 477, 477, 533], [535, 535, 560, 560, 1029], [1031, 1031, 1088, 1088, 1387]], "test": "valid"}
{"id": "MscSDB", "name": "Cellular Tiled Tunnel", "author": "Shane", "description": "Using a cheaply constructed 3D cellular tile to emulate a 2nd order Voronoi surface in realtime.", "tags": ["3d", "voronoi", "tunnel", "cellular", "tile", "2ndorder"], "likes": 167, "viewed": 8634, "published": "Public API", "date": "1463060978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Cellular Tiled Tunnel\n    ---------------------\n    \n    I've always liked the look of a 2nd order Voronoi surface. IQ's Leizex demo is a great\n\tprerendered example, and for anyone who can remember, Tomasz Dobrowolski's Suboceanic\n\twas cutting edge back in the day.\n\n\tAnyway, I've always wanted to get a proper example working in a shader... Yeah, I need\n\tbigger dreams. :) Unfortunately, I kind of realized that it wasn't going to be possible \n\tuntil GPUs become even faster than they already are, so I figured I'd try the next best \n\tthing and come up with a way to emulate the look with something cheap. This is the \n\tresult. It's not perfect, but it looks surprisingly similar.\n\n\tThe regular 2nd order Voronoi algorithm involves a \"lot\" of operations. In general,\n\t27 cell checks - all involving a bunch of vector arithmetic, fract, sin, floor, \n\tcomparisons, etc... It's possible to cut down on cell checks, perform a bunch of\n\toptimizations, etc, but it's still too much work for a raymarcher.\n\n\tThe surface here is produced via a repeat 3D tile approach. The look is achieved by \n\tperforming 2nd order distance checks on the tiles. I used a highly scientific approach\n\twhich involved crossing my fingers, doing the distance checks and hoping for the best. :)\n\tAmazingly, it produced the result I was looking for.\n\n\tI covered the tile construction in other \"cell tile\" examples, so I'll spare you the \n\tdetails, but it's pretty simple. The only additions here are the second order distance\n\tchecks.\n\n\tIn order to show the surface itself, I've made the example geometric looking - I hope\n\tyou like brown, or whatever color that is. :) Note that individual cell regions are \n\tcolored\tdifferently. I did that to show that it could be done, but I'm not convinced \n\tthat it adds to the aesthetics in any meaningful way.\n\n\tAnyway, I have a few more interesting examples that I'll put up pretty soon.\n\t\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\t// For comparison, this example uses the standard 2nd order Voronoi algorithm. For fun,\n\t// I dropped the cell tile routine into it and it ran a lot faster.\n\tVoronoi - rocks - iq\n\thttps://www.shadertoy.com/view/MsXGzM\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttp://www.iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define PI 3.14159265358979\n#define FAR 50. // Maximum allowable ray distance.\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\nfloat drawSphere(in vec3 p){\n    \n    // Anything that wraps the domain will suffice, so any of the following will work.\n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);    \n    p = fract(p)-.5;    \n    \n    return dot(p, p);\n    \n    // Other metrics to try.\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n// Faster (I'm assuming), more streamlined version. See the comments below for an expanded explanation.\n// The function below is pretty quick also, and can be expanded to include more spheres. This one\n// takes advantage of the fact that only four object need sorting. With three spheres, it'd be even\n// better.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y);\n        \n    return (d.x*2.66); // Normalize... roughly.\n    \n}\n\n/*\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. Note the \n// normalized planar positional roation between sphere rendering to really mix things up. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n\n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    //\n    // Set the maximum possible value - dot(vec3(.5), vec3(.5)). I think my reasoning is\n    // correct, but I have lousy deductive reasoning, so you may want to double check. :)\n    vec3 d = (vec3(.75)); \n   \n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53));\n    d.x = min(d.x, d.z); //d.y = max(d.x, min(d.y, d.z)); // Not needed on the first iteration.\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n     \n\t// More spheres means better patterns, but slows things down.\n    //p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    //d.z = drawSphere(p - vec3(.48, .29, .2));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    //p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    //d.z = drawSphere(p - vec3(.06, .87, .78));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n\t\n\n    \n    // Returning what I'm hoping is a normalized result. Not that it\n    // matters too much, but I'd like it normalized.\n    // 2.66 seems to work, but I'll double check at some stage.\n    // d.x: Minimum distance. Regular round Voronoi looking.\n    // d.y - d.x - Maximum minus minimum, for that beveled Voronoi look.\n    //\n    return (d.y - d.x)*2.66; \n    //return 1. - d.x*2.66;\n    //return 1. - sqrt(d.x)*1.63299; // etc.\n\n    \n}\n*/\n\n// Just like the function above, but used to return the regional cell ID...\n// kind of. Either way, it's used to color individual raised sections in\n// the same way that a regular Voronoi function can. It's only called once,\n// so doesn't have to be particularly fast. It's kept separate to the\n// raymarched version, because you don't want to be performing ID checks\n// several times a frame when you don't have to. By the way, that applies\n// to identifying any object in any scene.\n//\n// By the way, it's customary to bundle the respective distance and cell\n// ID into a vector (vec3(d.x, d.y, cellID)) and return that, but I'm \n// keeping it simple here.\n//\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n/* \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere2(p - vec3(.48, .29, .2)); if(d.z<d.x) cellID = 5;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere2(p - vec3(.06, .87, .78)); if(d.z<d.x) cellID = 6;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n*/ \n    \n    return cellID;\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/16.); return vec2(s*9., 0); }\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A tunnel is just a tube \n// with a smoothly shifting center as you traverse lengthwise. The walls of the tube are perturbed by the\n// cheap 3D surface function I described above.\nfloat map(vec3 p){\n\n    \n    float sf = cellTile(p/2.5);\n    \n    // Tunnel bend correction, of sorts. Looks nice, but slays framerate, which is disappointing. I'm\n    // assuming that \"tan\" function is the bottleneck, but I can't be sure.\n    //vec2 g = (path(p.z + 0.1) - path(p.z - 0.1))/0.2;\n    //g = cos(atan(g));\n    p.xy -= path(p.z);\n    //p.xy *= g;\n  \n    // Round tunnel.\n    // For a round tunnel, use the Euclidean distance: length(p.xy).\n    return 1.- length(p.xy*vec2(0.5, 0.7071)) + (0.5-sf)*.35;\n\n    \n/*\n    // Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1/n)\n    vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    tun = pow(tun, vec2(8.));\n    float n =1.-pow(tun.x + tun.y, 1.0/8.) + (0.5-sf)*.35;\n    return n;//min(n, p.y + FH);\n*/\n    \n/*\n    // Square tunnel.\n    // For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- max(tun.x, tun.y) + (0.5-sf)*.5;\n    return n;\n*/\n \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. By the way, there is an \n// aesthetic difference between this and the regular six tap version. Sometimes, it's noticeable,\n// and other times, like this example, it's not.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n/*\n// Oldschool hatching effect. Interesting under the right circumstances.\nvec3 ch(in vec3 col, in vec2 fragCoord){\n    \n    vec3 fColor = col;\n    \n    float lum = dot(col, vec3(.299, .587, .114));// length(col);\n\tfloat mx = 1./7.; // 1.732/7.;\n    \n    float rgt = fragCoord.x + fragCoord.y;\n    float lft = fragCoord.x - fragCoord.y;\n    \n    fColor = col*4.; col *= .6;\n    \n    if (lum < mx*6. && mod(rgt, 8.) == 0.) fColor = col;\n    if (lum < mx*5. && mod(lft, 8.) == 0.) fColor = col;\n    if (lum < mx*4. && mod(rgt, 4.) == 0.) fColor = col;\n    if (lum < mx*3. && mod(lft, 4.) == 0.) fColor = col;\n    if (lum < mx*2. && mod(rgt, 2.) == 0.) fColor = col;\n    if (lum < mx*1. && mod(lft, 2.) == 0.) fColor = col;\n    \n    return min(fColor, 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime*6.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x/32. )*rd.xy;\n\t\t\n    // Standard ray marching routine.\n    float t = trace(camPos, rd);\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n\t\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./1.; \n        const float tSize1 = 1./1.;\n    \t\n    \t// Texture-based bump mapping.\n\t    //if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); // Floor.\n\t    //else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); // Walls.\n        \n        sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.02);\n        //sn = doBumpMap(sp, sn, 0.01);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDdist;\n\t    ld2 /= lDdist2;\n\t    \n\t    // Light attenuation, based on the distances above. In case it isn't obvious, this\n        // is a cheap fudge to save a few extra lines. Normally, the individual light\n        // attenuations would be handled separately... No one will notice, or care. :)\n\t    float atten = 1./(1. + lDdist*.125 + lDdist*lDdist*.05);\n        float atten2 =  1./(1. + lDdist2*.125 + lDdist2*lDdist2*.05);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.75;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 32.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n \n        \n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = min(texCol*1.5, 1.);\n        //texCol = vec3(1)*dot(texCol, vec3(0.299, 0.587, 0.114));\n        //texCol = smoothstep(-.0, .6, texCol); // etc.\n        \n        //texCol = texCol*vec3(1., .5, .2); \n        int id = cellTileID(sp/2.5);\n        if(id == 4) texCol = texCol*vec3(1., .5, .3); \n        if(id == 3) texCol = texCol*.5 + texCol*vec3(.5, .25, .15); \n        \n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75+0.25; \n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        //\n        // Shiny.\n        sceneCol = (texCol*(diff + ambience + spec) + spec*vec3(.7, .9, 1))*atten;\n        sceneCol += (texCol*(diff2 + ambience + spec2) + spec2*vec3(.7, .9, 1))*atten2;\n        //\n        // Other combinations:\n        //\n        // Glow.\n        //float gr = dot(texCol, vec3(0.299, 0.587, 0.114));\n        //sceneCol = (gr*(diff + ambience*0.25) + spec*texCol*2. + fre*crv*texCol.zyx*2.)*atten;\n        //sceneCol += (gr*(diff2 + ambience*0.25) + spec2*texCol*2. + fre*crv*texCol.zyx*2.)*atten2;\n        \n        // Shading.\n        sceneCol *= shading*ao;\n        \n        // Drawing the lines on the surface.      \n        sceneCol *= clamp(abs(curve(sp, 0.035)), .0, 1.)*.5 + 1.;  // Glow lines.\n        sceneCol *= 1. - smoothstep(0., 4., abs(curve(sp, 0.0125)))*vec3(.82, .85, .88); // Darker.\n\t   \n\t\n\t}\n    \n    // Some simple post processing effects.\n    //float a = dot(sceneCol, vec3(0.299, 0.587, 0.114));\n    //sceneCol = min(vec3(a*3., pow(a, 2.5)*2., pow(a, 6.)), 1.); // Fire palette.\n    //sceneCol = floor(sceneCol*15.999)/15.; // Oldschool effect.  \n    // Oldschool hatching effect. Uncomment the \"ch\" function to use this one.\n    //sceneCol = ch(clamp(sceneCol, 0., 1.), fragCoord); \n\t\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n\t\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2546, 2561, 2583, 2583, 2627], [2629, 2673, 2693, 2693, 2802], [2804, 2828, 2847, 2847, 2921], [2923, 2989, 3039, 3039, 3261], [3264, 3927, 3955, 4117, 4556], [4558, 4871, 4897, 5005, 5642], [7963, 8625, 8651, 8651, 10060], [10063, 10163, 10185, 10185, 10242], [10244, 10504, 10522, 10522, 11545], [11548, 11569, 11605, 11605, 12040], [12042, 12229, 12291, 12291, 12801], [12804, 13048, 13075, 13184, 13344], [13577, 13935, 13978, 13978, 14323], [14325, 14697, 14732, 14732, 14936], [15699, 15699, 15755, 15782, 21347]], "test": "error"}
{"id": "MscSWj", "name": "Hideously inefficient 3D voronoi", "author": "tomator", "description": "Very slow, but I got fed up with repeatedly screwing something up while trying to fix it, so help would be appreciated.", "tags": ["3d", "raymarch", "newbie"], "likes": 23, "viewed": 468, "published": "Public", "date": "1462232967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rand3f( vec3 co )\n{\n/*\treturn fract(sin(vec3(dot(co,vec3(12.9898,78.233,37.8323)),\n                          dot(co,vec3(15.9113,77.173,31.9797)),\n                          dot(co,vec3(13.3117,79.321,31.7113)))*91363.7113));*/\n    \n    return texture(iChannel0, co.xy*co.z*.0625).rgb;\n}\n\nfloat worley( vec3 co )\n{\n    vec3 p = floor(co);\n    vec3 f = fract(co);\n    \n    vec2 dist = vec2(100.);\n    for(float x=-1.; x<=1.; x++)\n    for(float y=-1.; y<=1.; y++)\n    for(float z=-1.; z<=1.; z++)\n    {\n        vec3 cell = vec3(x, y, z);\n        vec3 offset = rand3f(p + cell);\n        \n        vec3 r = cell - f + offset;\n        float d = dot(r, r);\n        \n        if(d < dist.x)\n            dist = vec2(d, dist.x);\n        else if(d < dist.y)\n            dist.y = d;\n    }\n    \n    return dist.x - dist.y + .5;\n}\n\n#define MAX_STEPS 200\n#define MAX_DIST 8.\nfloat trace( vec3 origin, vec3 ray )\n{\n    float t = 1.6;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 hit = origin + ray*t;\n        float dist = worley(hit);\n        \n        if(dist < .001*(1. + t) || t > MAX_DIST) break;\n        t += dist*.25;\n    }\n    return t;\n}\n\n#define AMBCOLOR .043, 0., 0.\n#define DIFCOLOR .43, 0., 0.\n#define SPECOLOR .78, .57, 0.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*2.-1.; //coords to -1..1;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec2 mousepos = (iMouse.xy / iResolution.xy)*2.-1.;\n    mousepos.x *= aspect;\n    \n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 origin = vec3(5., 10.*sin(iTime*.2), iTime);\n    vec3 lightdir = normalize(vec3(-.85, 1.3, 1.));\n    \n    float res = trace(origin, ray);\n    vec3 hit = origin + ray*res;\n    vec2 ep = vec2(.0001, 0.);\n    //Calculate normals\n   \tvec3 normal = normalize(vec3(\n   \t   \t\tworley(hit+ep.xyy) - worley(hit-ep.xyy),\n  \t     \tworley(hit+ep.yxy) - worley(hit-ep.yxy),\n   \t   \t\tworley(hit+ep.yyx) - worley(hit-ep.yyx)));\n    \n    float dif = dot(normal, lightdir);\n    dif = max(0., dif);\n        \n    vec3 specdir = reflect(ray, normal);\n    float spec = dot(lightdir, specdir);\n    spec = pow(max(0., spec), 8.);\n        \n    vec3 color = vec3(AMBCOLOR) +\n        \t\tvec3(DIFCOLOR)*dif +\n        \t\tvec3(SPECOLOR)*spec;\n        \n    float fog =  (res*res) / (MAX_DIST*MAX_DIST);\n    float fogb = clamp(dot(ray, lightdir), 0., 1.);\n    vec3 fogc = mix(vec3(0., .68, .75), vec3(.09, .53, 0.), fogb);\n    \n    color = mix(color, fogc, fog);\n                \n    color = pow(color, vec3(.4545)); //Gamma correct\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 231, 291], [293, 293, 318, 318, 819], [863, 863, 901, 901, 1145], [1236, 1236, 1293, 1293, 2604]], "test": "error"}
{"id": "MsdGRN", "name": "Deconstructing Worley Noise", "author": "danim", "description": "Trying to understand worley noise", "tags": ["noise", "worley"], "likes": 2, "viewed": 137, "published": "Public", "date": "1463341807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GRID_SIZE 9.\n#define ERROR 0.015\n//#define DEBUG\n#define NOISE\n#define ANIMATION_SPEED 0.001\n\nfloat noise(vec2 p)\n{\n    p += sin(iTime*ANIMATION_SPEED);\n#ifdef NOISE\n\treturn fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n#else\n    return 0.;\n#endif\n}\n\n//Calculate the squared length of a vector\nfloat sqr_len(vec2 p)\n{\n    return dot(p,p);\n}\n\nfloat manhattan_dist(vec2 p)\n{\n    return abs(p.x) + abs(p.y);\n}\n\nfloat distance_function( vec2 a, vec2 b )\n{\n    return sqr_len(a - b);\n    //return manhattan_dist( a - b );\n}\n\nfloat worley(vec2 p) \n{\n    //Set our distance to infinity\n \tfloat d = 1e30;\n    //For the 9 surrounding grid points\n \tfor (int xo = -1; xo <= 1; ++xo) {\n  \t\tfor (int yo = -1; yo <= 1; ++yo) {\n            //Floor our vec2 and add an offset to create our point\n   \t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n            //Calculate the minimum distance for this grid piont\n            d = min(d, distance_function(p,tp + noise(tp)));\n  \t\t}\n \t}\n \treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float _step = 1.;\n    vec2 s = uv * GRID_SIZE;\n#ifdef DEBUG\n    //paint a grid for debugging\n    vec2 diff = s - floor(s);\n    _step = step( ERROR, min( diff.x, diff.y ) );\n#endif\n    s += fract( iTime * ANIMATION_SPEED );\n\tfragColor = vec4( (1.-_step)*vec3(1.0,0.,0.)  + _step*vec3(0.0,0.0,0.2+worley(s)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 123, 123, 269], [271, 314, 337, 337, 360], [362, 362, 392, 392, 426], [428, 428, 471, 471, 538], [540, 540, 563, 598, 990], [992, 992, 1049, 1049, 1409]], "test": "valid"}
{"id": "MsdSWl", "name": "Gilmore Leaves", "author": "airtight", "description": "Some nice shapes. good at fullscreen.", "tags": ["circles", "grid", "tiles"], "likes": 59, "viewed": 2557, "published": "Public API", "date": "1462320054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535;\nconst float flipTime  = 2.;\n\nvec2 tileDims = vec2(3.0,3.0); //number of rows ,columns\n\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat randomRange (in vec2 seed, in float min, in float max) {\n\t\treturn min + random(seed) * (max - min);\n}\n\nvec2 rotate2D(vec2 position, float theta)\n{\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//returns 1 for inside circ, 0 for outside\nfloat circle(in vec2 _st, in vec2 pos, in float _radius){\n    \n    float circEdge  =  20.0 / iResolution.x;\n    \n    vec2 dist = _st - pos;    \n\treturn 1. - smoothstep(_radius-(_radius*circEdge),\n                         _radius+(_radius*circEdge),\n                         dot(dist,dist)*4.0);\n}\n\nvec3 gilmoreCol(float x){    \n    //offset hue to put red in middle\n    float hue = fract((1.0 - x) - 0.45);    \n    //saturation is higher for warmer colors\n    float sat = 0.3 + sin(x*PI)*0.5;    \n    //brightness higher in middle\n    float bri = (smoothstep(0.,0.6, x) - smoothstep(0.6,1.0,x))*.6 + 0.3;  \n    return vec3(hue, sat,bri);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n     //0-1 on both axes\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //square aspect ratio, centered\n    vec2 uvs = vec2( fragCoord.xy - 0.5*iResolution.xy ) / min(iResolution.x,iResolution.y);\n    \n    //switch tileDims every 2 seconds\n    float rndTime = randomRange(vec2(floor(iTime/flipTime), 79834.345),3.,16.);\n    //number of rows ,columns\n    tileDims = vec2(floor(rndTime),floor(rndTime));\n    \n    //rotate\n    uvs = rotate2D(uvs,cos(iTime/10.));\n    \n    //warp\n    //uvs.x = uvs.x + sin(uvs.x*4.+iTime*6.)*0.005;\n    \n    //zoomer\n    //uvs *= (cos(iTime/2.) *0.2 + 1.);\n    \n    //slide columns down separately\n    //tile H coord \n    float colId = floor(uvs.x * tileDims.x);   \n    //rand per column\n    float rndColumn = random(vec2(colId, 687.890));\n    uvs.y += iTime * (rndColumn ) /30.;\n    \n    //bounce\n    //uvs.y += cos(iTime*PI * rndColumn)/10.;\n    \n\t//rnd per tile   \n    float rnd = random(floor(uvs.xy * tileDims) +  floor(iTime/flipTime));\n    \n    //mostly green w/ some reds\n    vec3 tileHSV;\n    if(rnd < 0.9){        \n       tileHSV = gilmoreCol(rnd/2.6);       \n    }else{\n        tileHSV = gilmoreCol(rnd - 0.4);      \n    }\n             \n    //get random int 0 - 3 per tile\n    float tileRnd = random(floor(uvs.xy * tileDims ) * 88.89 );\n    tileRnd = floor(tileRnd * 4.);\n    \n    //st is 0-1 coords within tile \n    vec2 st = fract(uvs * tileDims);\n    \n    //flip tiles\n    if (tileRnd == 1.) {\n    \tst.y = 1.0 - st.y;    \n    }else if (tileRnd == 2.) {\n       st.x = 1.0 - st.x;       \n    } else if (tileRnd == 3.) {        \n        st.x = 1.0 - st.x;    \n        st.y = 1.0 - st.y;    \n    }\n    \n    //draw circles\n    float circ = circle(st,vec2(0),4.);\n\ttileHSV.z *= circ;\n  \n    //column shadows\n    float hShadow = smoothstep(0.4, 0., fract(-uvs.x*tileDims.x)) * 0.12;\n   \ttileHSV.z -= hShadow;\n    \n    //slight vertical hue shift\n    float vShift = smoothstep(0.9, 0., st.y) * 0.03;\n   \ttileHSV.x -= vShift;\n    \n    //screen vertical brightness gradient\n    tileHSV.z -= fract( 1.0 - uv.y  ) * 0.3;\n    \n    fragColor = vec4(hsv2rgb(tileHSV),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 142, 142, 217], [219, 219, 281, 281, 326], [328, 328, 371, 371, 468], [470, 470, 491, 491, 660], [662, 705, 762, 762, 1001], [1003, 1003, 1028, 1070, 1348], [1350, 1350, 1407, 1433, 3523]], "test": "valid"}
{"id": "MsGSRw", "name": "evil simple", "author": "visy", "description": "evil simple", "tags": ["evilsimple"], "likes": 0, "viewed": 131, "published": "Public", "date": "1463427671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// WTFPL\n\n// Based on FlyGuy's shader: https://www.shadertoy.com/view/llSGRm\n#define FONTSC_SZ vec2(2.5, 5)     // Font size\n#define SCREEN_SZ vec2(800, 600) // Screen size\n#define CHR       vec4(6,7,6.*FONTSC_SZ.x,9.*FONTSC_SZ.y)  // Character size (xy), spacing(zw)\n#define STR_SZ(c) vec2(c*CHR.zw) // String size\n#define DWN_SC    2.             // Downscale\n\n#define C vec2\nC c_spc = C(      0,      0), c_exc = C( 276705,  32776), c_quo = C(1797408,      0)\n, c_hsh = C(  10738,1134484), c_dol = C( 538883,  19976), c_pct = C(1664033,  68006)\n, c_amp = C( 545090, 174362), c_apo = C( 798848,      0), c_lbr = C( 270466,  66568)\n, c_rbr = C( 528449,  33296), c_ast = C(  10471,1688832), c_crs = C(   4167,1606144)\n, c_per = C(      0,   1560), c_dsh = C(      7,1572864), c_com = C(      0,   1544)\n, c_lsl = C(   1057,  67584), c_0   = C( 935221, 731292), c_1   = C( 274497,  33308)\n, c_2   = C( 934929,1116222), c_3   = C( 934931,1058972), c_4   = C( 137380,1302788)\n, c_5   = C(2048263,1058972), c_6   = C( 401671,1190044), c_7   = C(2032673,  66576)\n, c_8   = C( 935187,1190044), c_9   = C( 935187,1581336), c_col = C(    195,   1560)\n, c_scl = C(    195,   1544), c_les = C( 135300,  66052), c_equ = C(    496,   3968)\n, c_grt = C( 528416, 541200), c_que = C( 934929,1081352), c_ats = C( 935285, 714780)\n, c_A   = C( 935188, 780450), c_B   = C(1983767,1190076), c_C   = C( 935172, 133276)\n, c_D   = C(1983764, 665788), c_E   = C(2048263,1181758), c_F   = C(2048263,1181728)\n, c_G   = C( 935173,1714334), c_H   = C(1131799,1714338), c_I   = C( 921665,  33308)\n, c_J   = C(  66576, 665756), c_K   = C(1132870, 166178), c_L   = C(1065220, 133182)\n, c_M   = C(1142100, 665762), c_N   = C(1140052,1714338), c_O   = C( 935188, 665756)\n, c_P   = C(1983767,1181728), c_Q   = C( 935188, 698650), c_R   = C(1983767,1198242)\n, c_S   = C( 935171,1058972), c_T   = C(2035777,  33288), c_U   = C(1131796, 665756)\n, c_V   = C(1131796, 664840), c_W   = C(1131861, 699028), c_X   = C(1131681,  84130)\n, c_Y   = C(1131794,1081864), c_Z   = C(1968194, 133180), c_lsb = C( 925826,  66588)\n, c_rsl = C(  16513,  16512), c_rsb = C( 919584,1065244), c_pow = C( 272656,      0)\n, c_usc = C(      0,     62), c_a   = C(    224, 649374), c_b   = C(1065444, 665788)\n, c_c   = C(    228, 657564), c_d   = C(  66804, 665758), c_e   = C(    228, 772124)\n, c_f   = C( 401543,1115152), c_g   = C(    244, 665474), c_h   = C(1065444, 665762)\n, c_i   = C( 262209,  33292), c_j   = C( 131168,1066252), c_k   = C(1065253, 199204)\n, c_l   = C( 266305,  33292), c_m   = C(    421, 698530), c_n   = C(    452,1198372)\n, c_o   = C(    228, 665756), c_p   = C(    484, 667424), c_q   = C(    244, 665474)\n, c_r   = C(    354, 590904), c_s   = C(    228, 114844), c_t   = C(   8674,  66824)\n, c_u   = C(    292,1198868), c_v   = C(    276, 664840), c_w   = C(    276, 700308)\n, c_x   = C(    292,1149220), c_y   = C(    292,1163824), c_z   = C(    480,1148988)\n, c_lpa = C( 401542,  66572), c_bar = C( 266304,  33288), c_rpa = C( 788512,1589528)\n, c_tid = C( 675840,      0), c_lar = C(   8387,1147904);\n\nvec2 carret = vec2(0);\n\n// Returns the digit sprite for the given number.\nvec2 digit(float d) {    \n    vec3 r = vec3(0, 0, floor(d));\n         if (r.z == 0.) r.xy = c_0; else if (r.z == 1.) r.xy = c_1;\n    else if (r.z == 2.) r.xy = c_2; else if (r.z == 3.) r.xy = c_3;\n    else if (r.z == 4.) r.xy = c_4; else if (r.z == 5.) r.xy = c_5;\n    else if (r.z == 6.) r.xy = c_6; else if (r.z == 7.) r.xy = c_7;\n    else if (r.z == 8.) r.xy = c_8; else if (r.z == 9.) r.xy = c_9;\n    return r.xy;\n}\n// Extracts bit\nfloat bit(float n, float b) {\n    b = clamp(b,-1.,22.);\n    return floor(mod(floor(n / pow(2.,floor(b))),2.));\n}\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat spr(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv/ FONTSC_SZ);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float b = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? bit(spr.x, b - 21.0) + bit(spr.y, b) : 0.0;\n}\n// Prints a character and moves the carret forward by 1 character width.\nfloat print_char(vec2 ch, vec2 uv) { \n    float px = spr(ch, CHR.xy, uv - carret);\n    carret.x += CHR.z;\n    return px;\n}\n// Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.;\n    \n\tfor(int i = 3; i >= -2; --i) {\n        //Clip off leading zeros.\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0);        \n        float d = mod(number / pow(10., float(i)),10.);\n        \n        if(i == -1) {\n            result += spr(c_per,CHR.xy, uv - dec_pos) * clip;\n            dec_pos.x += CHR.z * clip;\n        }\n        \n        result += spr(digit(d),CHR.xy, uv - dec_pos) * clip;\n        dec_pos.x += CHR.z * clip;\n    }\n    \n    return result;\n}\n\n#define T(x) print_char(x,uv)\nfloat Text(vec2 uv)\n{    \n    vec2 res = iResolution.xy / DWN_SC,\n         pos = vec2(80,350.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_W) + T(c_H) + T(c_A) + T(c_T) + T(c_spc) + T(c_E) + T(c_L) + T(c_E) + T(c_M) + T(c_E) + T(c_N) + T(c_T) + T(c_S) + T(c_spc) + T(c_D) + T(c_O) + T(c_spc) + T(c_I) + T(c_spc) + T(c_N) + T(c_E) + T(c_E) + T(c_D) + T(c_spc) + T(c_F) + T(c_O) + T(c_R) + T(c_spc) + T(c_A) + T(c_spc) + T(c_B) + T(c_L) + T(c_A) + T(c_C) + T(c_K) + T(c_spc) + T(c_M) + T(c_A) + T(c_S) + T(c_S) + T(c_que);\n    \n    carret = pos + vec2(0, -40.);\n    \n    r += T(c_hsh);\n    \n    return r;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 uv = p.xy / iResolution.xy * SCREEN_SZ;\n\tvec3 startcolor = vec3(0.6,1.0,0.3);\n\tvec3 endcolor = vec3(1.0,0.0,0.0);\n    vec3 fontcolor = mix(startcolor,endcolor,iTime*0.05);\n    c = vec4(fontcolor * Text(uv/vec2(1.00+cos(iTime)*0.01,0.5+sin(iTime*0.1)*0.04)),1);\n    c -= vec4(fontcolor * Text(uv/vec2(1.00+cos(iTime)*0.01,0.5+sin(uv.x+iTime*0.1)*(0.02)*cos(iTime*2.+p.x))),1)*2.0;\n    c += vec4(fontcolor * Text(uv/vec2(1.00+cos(iTime)*0.01,0.5+sin(uv.x+iTime*0.2)*(0.02)*sin(iTime*1.+p.x))),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGSRw.jpg", "access": "shaders20k", "license": "wtfpl-2.0", "functions": [[3137, 3187, 3208, 3208, 3606], [3607, 3623, 3652, 3652, 3735], [3736, 3795, 3836, 3836, 4235], [4236, 4309, 4345, 4345, 4431], [4432, 4480, 4532, 4532, 5063], [5095, 5095, 5116, 5116, 5722], [5724, 5724, 5760, 5760, 6266]], "test": "valid"}
{"id": "MsGSWw", "name": " Mandelbrot", "author": "metric", "description": " ", "tags": ["mandelbrot"], "likes": 3, "viewed": 128, "published": "Public", "date": "1464690023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 multiply(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 coord) {\n\tvec2 w = floor(coord),\n         f = fract(coord);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    return mix( mix( hash(w+vec2(0, 0)), hash(w+vec2(1, 0)), f.x ),\n                mix( hash(w+vec2(0, 1)), hash(w+vec2(1, 1)), f.x ), f.y );\n} \n\nfloat fbm(vec2 coord) {\n    float _fbm = 0.0;\n    _fbm += .5000*noise(2.*coord) +\n    \t\t.2500*noise(4.*coord) +\n    \t\t.1250*noise(8.*coord) +\n        \t.0625*noise(16.*coord);\n\treturn _fbm;\n}\n\nvoid mainImage( out vec4 col, in vec2 fc )\n{\n\tvec2 uv = fc.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1.67;\n    vec2 z_prev = vec2(0.0);\n\n    // update: animation\n    uv *= 3.4*fbm((.4*iTime)*fc.xy / iResolution.xy);\n    \n    for(int i=0; i<4; i++) {\n        z_prev += multiply(z_prev,\n                          multiply(z_prev, \n                                   multiply(z_prev,\n                                                multiply(z_prev, z_prev)))) + multiply(uv, uv);\n        uv /= multiply(uv, uv);\n    }\n    col.rg = multiply(z_prev, z_prev);\n    col.b  = 1.*length(multiply(z_prev, multiply(z_prev, multiply(z_prev, multiply(z_prev, multiply(z_prev, z_prev))))));\n    col.r = abs(col.r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 83], [85, 85, 105, 105, 177], [179, 179, 204, 204, 437], [440, 440, 463, 463, 630], [632, 632, 676, 676, 1380]], "test": "valid"}
{"id": "MsGXD1", "name": "Real raytrace in 3D", "author": "LaBodilsen", "description": "As a comparison to my \t[url=https://www.shadertoy.com/view/MscXDX]Faux raytrace in 2D[/url], i wanted so see how well it compared to real raytracing,  so i recreated the same scene with raytracing. \n\nthanks to all authors of the original shaders..", "tags": ["3d", "tutorial", "raytrace"], "likes": 14, "viewed": 621, "published": "Public", "date": "1464252173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Derived from the following shaders\n\nMain Raytracer from: \t  \t\t\t https://www.shadertoy.com/view/4ds3zs\nSpecular highlight from:  \t\t\t https://www.shadertoy.com/view/XllGRf\nChecker board floor and shadow from: https://www.shadertoy.com/view/lslXz8\nReflections from: \t\t\t\t\t https://www.shadertoy.com/view/lsfGWS\n*/\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sphere)\n{\n    // a sphere centered at the origin has equation |xyz| = r\n    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2\n    // now, xyz = ro + t*rd, therefore |ro|^2+|t*rd|^2 + 2<ro, rd> t - r^2 = 0\n\t// |rd| = 1 (normalized) so equation reduce to |ro|^2+ t^2 + 2<ro, rd> t - r^2 = 0\n    // which is a quadratic equation, so\n\n    vec3 oc = ro - sphere.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if(h <0.0) return -1.0; //no intersection\n\n    //pick smaller one(i.e, close one)\n    //not (-b+sqrt(h)) /2\n    float t = (-b - sqrt(h));\n    return t;\n}\n\nvec3 nSphere(in vec3 pos, in vec4 sphere)\n{\n    //sphere center at (l, m, n) radius r\n    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )\n    return (pos - sphere.xyz)/sphere.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd)\n{\n    //equation of a plane, y=0 = ro.y+t*rd.y\n    // t = -ro.y/rd.y\n    return ro.y-.31/rd.y;  //-31 = plane y position\n}\nvec3 nPlane(in vec3 pos)\n{// normal of plane\n    return vec3(0.0, 1.0, 0.0);\n}\n\n\t//sphere center + movement\n\tvec4 sphere1 = vec4(-.143, -.05, .95, .3);\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n    resT = 1000.0;\n    float id = -1.;\n    float tsph = iSphere(ro, rd, sphere1);// intersect with a sphere\n    float tpla = iPlane(ro, rd);//intersect with a plane\n    if(tsph >0.0)//if intersect with sphere\n    {\n        id  = 1.;\n        resT = tsph;\n    }\n    if(tpla > 0.0 && tpla < resT)\n    {//if intersect with plane and nearer than sphere or -1\n        id = 2.;\n        resT = tpla;\n    }\n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv are the pixel coordinates, from -1 to 1\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    float time = iTime*.15;\n    //we generate a ray with origin \"ro\" and direction \"rd\"\n    vec3 ro = vec3(.0, .0, 2.);\n\n    //Ray direction \n    vec3 rd = normalize(vec3( uv-vec2(0.,0.),-2.));\n\n    //we intersect the ray with the 3d scene\n    float t;\n    float id = intersect (ro, rd, t);\n    \n    //intersect position\n\tvec3 pos = ro + t*rd;\n\n    //light and direction\n    vec3 light = vec3(1.5, 1.75, 3.);\n    vec3 lightDir = normalize(light - pos);\n\n    //we draw gradien black to red, by default\n    vec3 col = vec3(.8-sqrt(uv.y),0.,0.);\n    if (id == 1.)\n    {//if we hit the sphere\n        //normal at intersect position\n        vec3 normal = nSphere(pos, sphere1);\n        //diffuse light cos(theta) = dot(surface normal, direction to light)\n        float dif = clamp(dot(normal, lightDir), 0., 1.);//use clamp restrict cos to[0, 1]\n\n    \tvec3 r = reflect(lightDir, normal);\n    \tvec3 spe = pow(max(dot(r, rd), 0.0), 50.) * vec3(1.5);        \n\n        col = vec3(1.2, 0.0, 0.)*dif+spe;\n\n\t\t// Reflections\n\t\tfloat id = intersect(pos, reflect(rd, normal),t);\n        if (id == 2.){\n\n            pos = pos + t*reflect(rd, normal);\n        \tvec3 normal = nPlane( pos );\n\t\t\t//ambient occlusion reflection\n            float amb = smoothstep(0.0, 1.* sphere1.w, length(pos.xz-sphere1.xz));\n\t    \tfloat falloff = length(pos.xz-light.xz);            \n            col += amb*vec3(1.)*dot(normal, lightDir)/falloff;\n\n            // Shadow reflection\n            vec3 shadowRay = normalize(light - pos);\n\t\t\tfloat shadow = 1.0;\n\t\n\t\t\tif(intersect(pos, shadowRay, t) > 0.0)\n\t\t\tshadow = 0.5;\n\t        col *= shadow;\n\n            // move the floor plane\n            pos.z -= time;\n            pos.x += sin(time*5.)/4.;\n            // checkerboard texture\n\t        if(fract(pos.x / .5) > 0.5 ^^ fract(pos.z / .5) > 0.5)\n   \t\t\tcol = vec3(1.2, 0.0, 0.)*dif+spe;\n        }\n    }\n    else if (id == 2.)\n    {//we hit the plane\n        vec3 normal = nPlane( pos );\n        //ambient occlusion\n        float amb = smoothstep(0.0, 1.2* sphere1.w, length(pos.xz-sphere1.xz));\n        float falloff = length(pos.xz-light.xz)/2.;\n        col = vec3(amb*vec3(1.)*dot(normal, lightDir-pos)/falloff);\n\n\t\t// Shadows\n        vec3 shadowRay = normalize(light - pos);\n\t\tfloat shadow = 1.0;\n\t\n\t\tif(intersect(pos, shadowRay, t) > 0.0)\n\t\t\tshadow = 0.5;\n        col *= shadow;\n\n        // move the floor plane\n        pos.z -= time;\n        pos.x += sin(time*5.)/4.;\n        // checkerboard texture\n        if(fract(pos.x / .5) > 0.5 ^^ fract(pos.z / .5) > 0.5)\n   \t\tcol *= 0.;\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 369, 691, 977], [979, 979, 1022, 1129, 1171], [1173, 1173, 1211, 1278, 1332], [1333, 1333, 1359, 1377, 1411], [1486, 1486, 1543, 1543, 1958]], "test": "valid"}
{"id": "MsGXRz", "name": "lantern stones", "author": "tomaes", "description": "radial blur on sun light and some 3d-ish blends. And then it got off the rails...", "tags": ["simple", "sun", "light", "radialblur", "style"], "likes": 2, "viewed": 184, "published": "Public", "date": "1462439140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r(vec2 _uv, float _t)\n{\n    return min(.30/length(_uv), mod(_t*length(_uv)*.001+.4*sin(_uv.x*8.)*cos(_uv.y*8.),.5)* abs(sin(_t-length(_uv))*5. ) );    \n}\n\nfloat rb(vec2 _uv, float _t)\n{\n    float v = .0;\n    \n    if (mod(_uv.y+_uv.x+_t*.1,.1) > abs(sin(_uv.x/_uv.y)*.05))\n    for(float f = 1.; f > .0; f -= .05)\n    {\n        v += r(_uv*f,_t)*.05;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y; \n    \n    float c = 1.;\n    float t = iTime + 1.5;\n    \n    c = r(uv,t);\n   \n    if (c > mod(-t*.1 + tan(t*.1+uv.y*.5/uv.x*.2),.2)*2. )\n    \tc -= .5*rb(uv,t);     \n    \n\tfragColor = vec4(c,c*.9,c-uv.x,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 159], [161, 161, 191, 191, 380], [383, 383, 440, 484, 760]], "test": "valid"}
{"id": "MsKSRh", "name": "SDF Visualizer", "author": "daseyb", "description": "Making images for presentations.", "tags": ["sdf"], "likes": 10, "viewed": 491, "published": "Public", "date": "1462960198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////\n// Settings\n////////////////////////\n#define VISUALIZE_GRADIENT_ERROR false\n#define VISUALIZE_GRADIENT_ONLY false\n#define VIS_STEP_SIZE 10.0\n#define GRADIENT_FALL_OFF 0.02\n#define GRADIENT_MOVEMENT_SPEED 10.0\n#define SOLID_INSIDE true\n#define COLOR_INSIDE vec3(32.0/255.0, 72.0/255.0, 211.0/255.0)\n#define COLOR_OUTSIDE vec3(211.0/255.0, 72.0/255.0, 23.0/255.0)\n\n// I recommend http://mercury.sexy/hg_sdf/ for more primitives and operations.\n////////////////////////\n// Utility Methods\n////////////////////////\n\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define PI 3.14159265\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);   \n}\n\n////////////////////////\n// Operations\n////////////////////////\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opSubtract(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opIntersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.0);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nfloat opUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat opUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat opSSoft(float d1, float d2, float r) {\n\tfloat e = max(r - abs(-d1 - d2), 0.0); \n\tfloat factor = (e*e*0.25)/r;\n\treturn max(-d1, d2) + factor;\n}\n\n////////////////////////\n// Primitives\n////////////////////////\nfloat sdBox(vec2 p, vec2 pos, vec2 e) {\n\tvec2 d = abs(p-pos)-e;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat sdCircle (vec2 p, vec2 pos, float r) {\n\treturn length(p - pos) - r;\n}\n\nfloat sdHexPrism(vec2 p, vec2 pos, vec2 h )\n{\n    vec2 q = abs(p-pos);\n    return max(-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat fCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n////////////////////////\n// Scene\n////////////////////////\n// EDIT THIS TO CHANGE WHAT'S BEING RENDERED\nfloat scene(vec2 p) {\n    p -= - iResolution.xy/vec2(2.0);\n    return fCappedCylinder( vec3(p.x, p.y, iMouse.x), 100.0, 100.0);\n    return opSSoft(length(p - iResolution.xy/vec2(2.0)) - 100.0, \n               length(p - iResolution.xy/vec2(2.0) + vec2(80.0)) - 30.0, 1.0);\n}\n\n////////////////////////\n// Visualization\n////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy;\n    float dist = scene(uv);\n    float absDist = abs(dist);\n    vec3 finalColor;\n    \n    // Rings\n    float visDist = mod(abs(dist) - iTime * GRADIENT_MOVEMENT_SPEED, VIS_STEP_SIZE)/VIS_STEP_SIZE;\n    visDist = abs(visDist - 0.5) * 2.0;\n\n    float visDistFac = pow(visDist, 3.0) * exp(-absDist * GRADIENT_FALL_OFF);\n\n    vec3 white = vec3(1, 1, 1);\n    vec3 black = vec3(0, 0, 0);\n\n    vec3 colorOutside = mix(COLOR_OUTSIDE, vec3(0, 0, 0), dist * GRADIENT_FALL_OFF); \n    vec3 colorInside = mix(COLOR_INSIDE  * 3.0, vec3(0, 0, 0), -dist * GRADIENT_FALL_OFF); \n\n    finalColor = dist < 0.0 ? (SOLID_INSIDE ? white : mix(colorInside, white, visDistFac)) : mix(colorOutside, white, visDistFac);\n\n    finalColor = mix(black, finalColor, smoothstep(0.0, 2.0, absDist));\n    \n    finalColor = clamp(finalColor, vec3(0, 0, 0), vec3(1, 1, 1));\n    \n    if(VISUALIZE_GRADIENT_ERROR) {\n        vec2 distGradient = vec2(scene(uv + vec2(1, 0)), scene(uv + vec2(0, 1))) - vec2(dist);\n        float gradLength = length(distGradient);\n        if(gradLength < 1.0) {\n            finalColor = mix(finalColor * 0.5, vec3(0.2, .0, 1.0), 1.0 -gradLength);\n        } else {\n            finalColor = mix(finalColor * 0.5, vec3(1.0, .0, 0.2), gradLength - 1.0);\n        }\n        \n        if(VISUALIZE_GRADIENT_ONLY) {\n            finalColor = vec3(0.5 + (gradLength-1.0) * 0.5);\n        }\n    } \n    \n\n    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[594, 594, 614, 614, 642], [644, 708, 743, 743, 769], [771, 771, 809, 809, 836], [838, 838, 877, 877, 903], [905, 905, 951, 951, 1022], [1024, 1024, 1073, 1073, 1122], [1124, 1124, 1171, 1171, 1256], [1258, 1258, 1302, 1302, 1406], [1408, 1472, 1511, 1511, 1597], [1599, 1599, 1643, 1643, 1674], [1676, 1676, 1721, 1721, 1806], [1808, 1808, 1859, 1859, 1966], [1969, 2073, 2094, 2094, 2347], [2349, 2416, 2473, 2473, 3927]], "test": "valid"}
{"id": "MsKSz1", "name": "Racing Through a Tunnel", "author": "innovati", "description": "Racing through a tunnel", "tags": ["tunnel", "fast", "racing", "move"], "likes": 0, "viewed": 72, "published": "Public", "date": "1463005085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = pow(atan(mod(reflect(vec4((gl_FragCoord.x / iResolution.x), 1.7, float(iFrame), (1.1 + 1.8)), min(atan(pow(tan(vec4(float(iFrame), 0.3, 1.8, 1.3)), step(atan(acos(log(vec4(max((1.2 / 0.3), (((gl_FragCoord.x / iResolution.x) - 1.9) - atan(tan(0.3)))), (gl_FragCoord.y / iResolution.y), (gl_FragCoord.x / iResolution.x), 0.7))), max(log(floor(exp(vec4(sin(0.9), 0.4, 0.6, 1.2)))), reflect(vec4(0.2, 1.4, (0.3 - (1.9 / (gl_FragCoord.y / iResolution.y))), 1.6), atan(vec4(iTime, (1.8 * abs(0.6)), 0.7, 1.4), exp2(mod(vec4(float(iFrame), 1.9, (1.1 + (gl_FragCoord.x / iResolution.x)), 1.2), vec4(1.4, 0.3, 0.2, 1.8))))))), step(vec4((gl_FragCoord.x / iResolution.x), 1.2, (1.5 - float(iFrame)), ((fract((0.6 - (gl_FragCoord.y / iResolution.y))) + sign(iTime)) - (1.0 - iTime))), sin(log(floor(cos(normalize(radians(exp2(pow(vec4(0.5, float(iFrame), 1.8, 0.0), pow(reflect(min(vec4((gl_FragCoord.y / iResolution.y), (gl_FragCoord.x / iResolution.x), ((0.0 / 0.9) * (gl_FragCoord.x / iResolution.x)), 0.1), degrees(sin(vec4(1.1, 0.0, (gl_FragCoord.x / iResolution.x), 0.7)))), vec4(0.1, 0.4, 1.8, 0.7)), atan(vec4(1.4, (0.4 + 0.8), (gl_FragCoord.y / iResolution.y), iTime), log(reflect(atan(vec4(iTime, (0.7 - 1.2), 0.5, (iTime * 0.5)), vec4(iTime, (((1.3 / (1.8 * 0.5)) / degrees(1.5)) - (gl_FragCoord.y / iResolution.y)), 1.8, 0.0)), vec4(0.2, 0.2, 0.6, 1.8)))))))))))))))), vec4(1.4, (float(iFrame) * 1.0), 0.6, 0.6)), degrees(sqrt(max(atan(floor(pow(radians(step(reflect(vec4(0.9, 0.4, 1.4, 0.1), vec4(0.3, 1.9, 1.3, 1.2)), fract(vec4(0.8, float(iFrame), atan(reflect(0.8, 1.5), 1.5), (0.4 + (1.3 + 0.1)))))), floor(atan(acos(vec4(1.9, 0.1, (0.7 - 0.1), 1.2)), vec4(float(iFrame), 0.2, 0.9, 0.8))))), mod(vec4(iTime, 0.6, ((1.3 + (pow(1.4, 0.2) * 1.1)) - log((0.8 + ((0.0 - (tan((0.9 + (gl_FragCoord.y / iResolution.y))) + min(0.2, 0.2))) + 0.0)))), log2(cos(0.7))), exp2(log2(reflect(asin(normalize(vec4(0.0, 0.0, (gl_FragCoord.x / iResolution.x), 1.7))), vec4(1.7, (0.4 * float(iFrame)), (gl_FragCoord.x / iResolution.x), 1.3)))))), vec4((iTime / iTime), (0.8 + (1.7 + 0.9)), iTime, (0.4 + 0.9))))))), vec4(1.1, 0.2, 0.8, iTime)), sign(pow(exp(vec4(1.9, (0.9 - ((0.7 - 1.4) + (0.2 / iTime))), (gl_FragCoord.y / iResolution.y), 0.9)), pow(ceil(inversesqrt(atan(vec4(0.3, 0.3, 0.4, 0.4), vec4(1.7, 1.3, (gl_FragCoord.y / iResolution.y), 1.7)))), vec4(1.4, 0.2, float(iFrame), (gl_FragCoord.y / iResolution.y)))))), vec4(inversesqrt(1.3), 1.0, (gl_FragCoord.x / iResolution.x), (inversesqrt((gl_FragCoord.x / iResolution.x)) + (0.9 / 1.7))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "timedout"}
{"id": "MsKXz1", "name": "Traffic Jam", "author": "innovati", "description": "Join the rat race", "tags": ["jam", "traffic"], "likes": 0, "viewed": 1265, "published": "Public", "date": "1463006342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = step(step(min(pow(vec4(float(iFrame), 0.9, (1.8 * (gl_FragCoord.x / iResolution.x)), (gl_FragCoord.y / iResolution.y)), vec4(pow(1.4, 0.1), (((gl_FragCoord.x / iResolution.x) + 0.4) - (0.4 + 0.5)), atan(((0.9 * 1.6) + iTime), iTime), ceil(1.5))), log2(vec4(0.2, 0.2, (0.9 + sin(((gl_FragCoord.x / iResolution.x) * iTime))), 0.1))), log(vec4(abs(float(iFrame)), (gl_FragCoord.x / iResolution.x), 1.5, (0.2 - (0.7 - float(iFrame)))))), vec4(0.4, 0.0, acos(1.0), iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 539]], "test": "valid"}
{"id": "MsVXWW", "name": "Dusty nebula 4", "author": "Duke", "description": "Visualization technique is basically the same as in the [url=https://www.shadertoy.com/view/lsVSRW]Dusty nebula 3[/url], but this time, I tried to imitate the filaments, which can be seen on most of the photos of nebulae.", "tags": ["cloud", "star", "space", "nebula", "dust", "filament"], "likes": 215, "viewed": 12674, "published": "Public API", "date": "1464534583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Dusty nebula 4\" by Duke\n// https://www.shadertoy.com/view/MsVXWW\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 3\" (https://www.shadertoy.com/view/lsVSRW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define ROTATION\n//#define MOUSE_CAMERA_CONTROL\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//=====================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*2.);\n    R(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*2.);\n    R(ro.xz, iMouse.x*0.01*pi*2.);\n    #else\n    R(rd.yz, -pi*3.93);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.93);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n\t#endif \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<56; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n        if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t    \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.08);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // star in center\n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        sum.rgb+=(lightColor/(lDist*lDist)/30.); // star itself and bloom around the light\n      \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n\t\t\n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.185;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.04); \n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        d=abs(d)*(.8+0.2*rand(seed*vec2(i)));\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.02);\n      \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVXWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[940, 954, 980, 980, 1199], [1201, 1201, 1222, 1222, 1293], [1295, 1936, 1964, 1964, 2513], [2515, 2515, 2544, 2544, 2792], [2794, 2794, 2821, 2821, 3072], [3074, 3074, 3094, 3094, 3240], [3307, 3336, 3386, 3471, 3741], [3743, 3743, 3819, 3819, 4035], [4037, 4152, 4188, 4188, 4352], [4354, 4354, 4411, 4411, 7763]], "test": "error"}
{"id": "MsySRR", "name": "2D Grid demo", "author": "cubby208", "description": "This has a draggable grid.\n\nI cant get the mouse to work when it is not down", "tags": ["trial"], "likes": 1, "viewed": 149, "published": "Public", "date": "1462417480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool isEven(float val)\n{\n    return bool(mod(val, 2.0));\n}\nfloat dist(vec2 p1, vec2 p2)\n{\n \treturn sqrt(abs((p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y)));   \n}\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = vec2(0.0);\n    if (mouse.x == 0.0)\n    {\n     \tmouse = vec2(iMouse.x, iMouse.y);   \n    }\n    else\n    {\n        mouse = vec2(iMouse.z, iMouse.w);  \n    }\n    \n\tfloat width = 30.0;\n    float row = floor((-fragCoord.x + mouse.x) / width);\n    float col = floor((-fragCoord.y + mouse.y) / width);\n    \n   \tfloat distt = dist(fragCoord, vec2(mouse));\n    \n    \n    vec4 col1 = vec4(1.0);\n    vec4 col2 = vec4(1.0);\n    \n    if (distt < 80.0 * (abs(sin(iTime * 5.0)) + 0.1))\n    {\n     \tcol1 = vec4(1.0, 0.0, 0.0, 1.0);\n        col2 = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        col2 = vec4(1.0);\n        col1 = vec4(0.0);\n    }\n    \n    \n    \n    if ((isEven(row) && !isEven(col)) || (!isEven(row) && isEven(col)))\n    {\n        fragColor = col1;\n    }\n    else\n    {\n     \tfragColor = col2;   \n    }\n    \n    \n    fragColor += hsv_to_rgb((iTime  + ((fragCoord.x - mouse.x) / 50.0)) / 10.0, 0.6, 0.6, 0.1);\n    \n    float dist2 = dist(fragCoord, vec2(0.0));\n    fragColor -= vec4(dist2 / 1000.0);\n    fragColor -= vec4(dist2 / 1000.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsySRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 58], [59, 59, 89, 89, 173], [175, 175, 228, 228, 803], [805, 805, 862, 862, 1925]], "test": "valid"}
{"id": "MsySW1", "name": "FRESH MINTY", "author": "netgrind", "description": "final pass from a colab between connor bell and myself.\nfull video, lerping between passes - https://www.youtube.com/watch?v=bMonV2q6b10", "tags": ["3d", "raymarch", "green", "netgrind", "mint", "minty", "fresh", "connorbell", "macbooktall"], "likes": 11, "viewed": 724, "published": "Public API", "date": "1464039236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// hyper tweaked copy of https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// part of a colab between connor bell and cale bradbury\n\n//increase steps for higher detail, will run slower\n#define steps 30\n\n//how foggy the zone is\n#define fog 1.1\n\nfloat size = .1;\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{\nreturn p.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\nreturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opU( float d1, float d2 )\n{\nreturn (d1<d2) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    return ((d2.x<d1.x)) ? d2 : d1;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 rotate(vec2 v, float a){\nfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\nvec2 stretch(vec2 v, float s){\nfloat t = atan(v.y,v.x);\n    float d = length(v);\n    d +=d*s;\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;  \n}\n\nvec2 gif9(in vec3 pos){\n    pos.x = abs(mod(pos.x, size*4.)-size*2.);\n    pos.y = 0.-abs(mod(abs(pos.y), size*4.)-size*2.);\n \tpos.z = abs(mod(pos.z-size, size*4.)-size*2.);\n    \n    vec2 res = vec2(sdBox(pos+vec3(0.,-size,0.), vec3(100.,.1,100.)), 1.1);\n    res = opU(res, vec2(sdBox(pos, vec3(size)), 2.));\n    res = opU(res, vec2(sdBox(pos+vec3(0., size, 0.), vec3(size*.5,size,size*.5)), 3.));\n//res = opU(res, vec2(sdBox(pos, vec3(size*1.5, size*0.5, size*1.5)), 2.5));\n\n    res = opU(res, vec2(sdBox(pos, vec3(size*2.5, size*0.5, size*1.5)), 2.5));    \n    res = opU(res, vec2(sdBox(pos, vec3(size*0.5, size*0.6, size*1.55)), 3.5));\n    res = opU(res, vec2(sdBox(pos, vec3(size*2.5, size*0.6, size*.25)), 3.5));\n    res = opU(res, vec2(sdBox(pos, vec3(size*.4, size*0.5, size*2.)), 2.5));    \nres = opU(res, vec2(sdBox(pos, vec3(size*2., size*0.25, size*1.55)), 4.5));\nres = opU(res, vec2(sdBox(pos, vec3(size*0.5, size*0.25, size*2.)), 4.5));\n\n    float s = sdBox(vec3(pos.x,mod(pos.y-.55,size*.4),pos.z), vec3(size*.7, size*0.2, size*.7));\n    s = opS(s, sdBox(vec3(pos.x,mod(pos.y-.55,size*.4),pos.z), vec3(size*.3, size*0.3, size*.3)));\n    res.x = opS(res.x,s);\n    res.x = opS(res.x,sdBox(pos+vec3(-size*1.5,size*.55,0.),vec3(size*.15,size*.3,1.)));\n    \n   \tres = opU(res,vec2(sdBox(pos+vec3(-size*1.5,size*0.35,0.),vec3(size*.15,size*.25,size*1.5)), 2.));\n\n    float box = sdBox(pos+vec3(-size*.9, size*1.2, -size*.95), vec3(size*.1,size*1.1,size*.05));\n    res = opU(res, vec2(box,2.));\n    \n    res = opU(res,vec2(sdBox(pos+vec3(-size*2.,size*.3,0.),vec3(size*.15,size*.3,size*1.55)), 3.5));\n    res = opU(res,vec2(sdBox(pos+vec3(0.,size*.3,0.),vec3(size*.1,size*.3,size*2.)), 3.5));\n    \n    //res.x = opS(res.x,sdSphere(pos+vec3(-size*2.,size*.5,0.),size*1.5));\n    s = sdSphere(pos+vec3(-size*2.,size*.5,-size*2.),size*1.);\n    \n    //res.x = opS(res.x,sdBox(pos+vec3(-size*2.,0.,-size*2.),vec3(size*1.2,size*.4,size*.3)));\n   \ts = opU(s,sdBox(vec3(pos.x-size*.9,mod(pos.y,size*.3),pos.z-size*.95),vec3(size*.11,size*.1,size*.051)));\n    s = opU(s,sdBox(vec3(pos.x,pos.y-size,mod(pos.z+size*.25,size*.2)),vec3(size*10.,size*.8,size*.1)));\n    res.x = opS(res.x,s);\n    \n   \ts = sdTriPrism(pos+vec3(-size*2.,-size*.2,-size*2.),vec2(size*2.5, size*0.1));\ns = opS(s, sdSphere(pos+vec3(-size*2.,-size*.1,-size*2.5),size*1.25));\n\n    res = opU(res, vec2(s, 2.));\n\n    res = opU(res, vec2(sdBox(pos-vec3(0.,0.,size*2.), vec3(size*0.8, size*0.8, size*.1)), 3.5));\n \n    res = opU(res, vec2(sdBox(pos-vec3(0.,0.,size*2.), vec3(size*0.05, size*2., size*.15)), 3.5));\n \tres = opU(res, vec2(sdBox(pos-vec3(size*0.75,-size*1.5,size*2.), vec3(size*0.05, size*.5, size*.1)), 1.5));\n \n    box = sdBox(pos+vec3(-size*.9, size*1.2, -size*.95), vec3(size*.05,size*1.1,size*.025));\n    res = opU(res, vec2(box,3.5));\n    \n    box = sdCylinder(pos.yxz+vec3(size*2.,0.,0.),vec2(size*.4,size*4.));\n    res.x = opS(res.x,box);\n    box = sdCylinder(pos.yxz+vec3(size*2.,0.,-size*2.),vec2(size*.09,size*4.));\n    res.x = opS(res.x,box);\n    box = sdCylinder(pos.yxz+vec3(size*1.7,0.,-size*2.),vec2(size*.06,size*4.));\n    res.x = opS(res.x,box);\n    box = sdCylinder(pos.yxz+vec3(size*1.5,0.,-size*2.),vec2(size*.03,size*4.));\n    res.x = opS(res.x,box);\n    \n    res = opU(res, vec2(box, 3.5));\n    \n    box = sdBox(pos+vec3(0.,0.,-size*1.3),vec3(size*.2,1.,size*.1));\n    res.x = opS(res.x,box);\n    \n    res = opU(res, vec2(box, 1.5));\n    res = opU(res, vec2(sdCylinder(pos, vec2(size*0.5, size*2.)), 2.));\n    \n    s = sdSphere(pos+vec3(-size*2.,-size*1.,-size*2.),size*1.);\n    s = opS(s,sdBox(vec3(pos.x,pos.y-size*2.,-mod(pos.z+size*.15,size*.2)),vec3(size*10.,size*2.8,size*.1)));\n\tvec2 ii = vec2(s, 3.5);\n    res = opU(res,ii);\n    \n    res = opU(res,vec2(sdBox(pos+vec3(-size*2.,size*.25,0.),vec3(size*.05,size*.4,size*0.6)), 2.));\n    \n    box = sdCylinder(pos.yxz+vec3(size*2.,-size*.5,0.),vec2(size*.3,size*.2));\n    box =opU(box, sdCylinder(pos.yxz+vec3(size*2.,-size*.5,0.),vec2(size*.2,size*.4)));\n    box =opU(box, sdCylinder(pos.yxz+vec3(size*2.,0.,0.),vec2(size*.1,size*4.)));\n    res.x = opS(res.x,box);\n    \n    return res;\n}\n#define loop 4.\n\nvec2 map( in vec3 pos ){\n    float t = iTime*.1;\n    \n    float s = t;\n    s = mod(s,loop)-(loop*.5);\n    s = clamp(s*.5,0.,1.);   \n    \n    t/=loop;\n    vec2 res = gif9(pos);\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 100.0;\n \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<steps; i++ )\n    {\n   vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n   m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 calcNormal( in vec3 pos ){\nvec3 eps = vec3( 0.0001, 0.0, 0. );\nvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\nreturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ ) {\n        float hr = 0.01 + 0.006*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    vec3 pos = ro + res.x*rd;\n    vec3 nor = calcNormal(pos);\n    float ao = calcAO(pos,nor);\n    \n    const vec3 a = vec3(.5, .1, .5);\n    const vec3 b = vec3(.5, .1, .5);\n    const vec3 c = vec3(.3, 1.4, 0.);\n    const vec3 d = vec3(.5, .0, .25);\n    col = palette(res.y, a, b, c, d);\n\tcol = 1.0-(col+(1.0-ao))*(1.0-res.x*fog)*.85;\n\treturn vec3( clamp(col,0.0,1.0) );\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n\tvec3 ro = vec3( 0.,0.,-iTime*.1 );\n\tvec3 ta = ro+vec3( 0.,0.,1. );\n    mat3 ca = setCamera( ro, ta, 0.0 );    \n    \n    float warp =.666;    \n    float fov = 70.0;\n    float rayZ = tan ((90. - 0.5 * fov) * 0.01745329252);\n\tvec3 rd = normalize( vec3(p.xy,-rayZ) )*ca;\n    rd = vec3(rd.xy,sqrt (1.0 - warp * warp) * (rd.z + warp));\n    rd = normalize(rd);\n    \n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsySW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[363, 363, 398, 398, 422], [424, 424, 460, 460, 547], [549, 549, 580, 580, 676], [678, 678, 714, 714, 813], [815, 815, 840, 840, 854], [856, 856, 886, 886, 918], [919, 919, 952, 952, 980], [982, 982, 1012, 1012, 1050], [1051, 1051, 1084, 1084, 1110], [1112, 1112, 1141, 1141, 1249], [1250, 1250, 1280, 1280, 1401], [1403, 1403, 1426, 1426, 5543], [5561, 5561, 5585, 5585, 5754], [5756, 5756, 5796, 5796, 6075], [6077, 6077, 6149, 6149, 6192], [6194, 6194, 6225, 6225, 6437], [6439, 6439, 6481, 6481, 6772], [6774, 6774, 6813, 6813, 7243], [7244, 7244, 7296, 7296, 7473], [7475, 7475, 7532, 7532, 8066]], "test": "valid"}
{"id": "MsyXRw", "name": "Flickering Wall", "author": "innovati", "description": "A wall lit by flickering webGL candlelight", "tags": ["wall", "flickering"], "likes": 0, "viewed": 137, "published": "Public", "date": "1463433258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = asin(atan(mod(vec4(((fragCoord.y / iResolution.y) + iTime), ((0.0 / sqrt(1.8)) + (0.2 * 0.9)), 0.2, 0.7), vec4(1.9, 0.8, iTime, (float(iFrame) * 1.8))), max(exp(normalize(fract(vec4(((0.6 - (fragCoord.x / iResolution.x)) + (1.8 / 0.8)), 0.1, iTime, (float(iFrame) * 1.2))))), cos(sin(asin(vec4(0.9, 0.7, atan((0.9 - fract(1.6)), 1.1), 0.2)))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "MsyXzz", "name": "Path tracer test #1", "author": "elzeru", "description": "A first path tracing with depth of field.\nQuantities are not physical for now. Has to be improved !", "tags": ["3d", "pathtracer", "montecarlo", "pathtracinf"], "likes": 3, "viewed": 331, "published": "Public", "date": "1462462472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A first path tracing with depth of field.\n// By El Zeru\n// Some things from https://drive.google.com/file/d/0B8g97JkuSSBwUENiWTJXeGtTOHFmSm51UC01YWtCZw/view\n// and some lines of code from iq and other members of the Shadertoy community (love you all)\n\n#define PI 3.14159265359\n\n// PRIM_RAY_IT : Max number of iteration for the raycasting\n// PRIM_RAY_STEP : Min step size for the raycasting\n// EPS_NOR : Shift for the normal computation. No need to change\n// NB_RAY : Number of primary ray cast\n// FOCAL_DIST : Focal distance.\n// BLUR_AMOUNT : Amount of blur\n\nconst int PRIM_RAY_IT = 80 ;\nconst float PRIM_RAY_STEP = 0.01;\nconst float EPS_NOR = 0.001;\nconst int NB_RAY = 64;\nconst float FOCAL_DIST = 3.0;\nconst float BLUR_AMOUNT = 0.001;\n\n//Describe the properties of a ray/surface intersection\nstruct Impact {\n\tfloat d;\n    float lum;\n\tvec3 col;\n\tint refl;\n};\n\n//Describe a light \n//In a next version, other objects could be structures.\nstruct Light{\n\tvec3 p;\n    float r;    \n    float lum; \n    vec3 col;\n}\n\n//The light move through time\nlight = Light(vec3( sin(iTime)*1.5, cos(iTime), 1.0), 0.15, 2.0, vec3(1.0,1.0,1.0));\n   \n//Seed and generator\nfloat seed = 0.;\n\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\n// A min function based on the distance for the Impact structures\nImpact getClosest( Impact p1, Impact p2 )\n{\n if (p1.d<p2.d)\n    {\n        return p1;\n    }\n    else return p2;\n}\n\n\n//Primitive definition\nfloat dPlaneY( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat dSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n\nfloat dBox( vec3 p, vec3 s )\n{\n\tvec3 d = abs(p) - s; \n    return min(max(d.x,max(d.y,d.z)),0.0) +length(max(d,0.0));\n}\n\nfloat dInvertedBox( vec3 p, vec3 s )\n{\n\treturn -dBox(p,s);\n}\n\n\n//Return information about the closest primitives\nImpact map(in vec3 pos)\n{\n    //Sphere1\n\tfloat sphereRadius = 0.5;\n\tfloat sphereDistance = dSphere( pos-vec3( -1.5, -1.0, 2.5), sphereRadius );\n\tvec3 sphereColour = vec3(1.0, 1.0, 0.8);\n    Impact sphere1_p = Impact(sphereDistance,0.0,sphereColour,0);\n    \n    //Sphere2\n\tsphereRadius = 0.5;\n\tsphereDistance = dSphere( pos-vec3( 2.0, 1.0, 2.0), sphereRadius );\n\tsphereColour = vec3(1.0, 1.0, 0.8);\n    Impact sphere2_p = Impact(sphereDistance,0.0,sphereColour,0);\n    \n    //Box 1\n    vec3 boxSize = vec3(0.2,2.0,2.0);\n    vec3 boxPosition = vec3(1.5,-2.0, 5.0);\n    float boxDistance = dBox(pos-boxPosition, boxSize);\n    vec3 boxColour = vec3(1.0, 1.0, 0.8);   \n   \tImpact box1_p = Impact(boxDistance, 0.0, boxColour,0); \n    \n    //Room\n    vec3 roomSize = vec3(5.0,3.0,5.0);\n    vec3 roomPosition = vec3(0.0,0.0, 1.0);\n    float roomDistance = dInvertedBox(pos-roomPosition, roomSize);\n    \n    //Room colour, fancy or regular\n    //vec3 roomColour = vec3(pow(abs(pos)*0.1,vec3(2.0)) );//+tex.rgb*0.3; \n    vec3 roomColour =vec3(0.8,0.8,0.8);\n    if (pos.x > roomSize.x-0.01) roomColour = vec3(1.0,0.0,0.0);\n    if (pos.x < - roomSize.x+0.01) roomColour = vec3(0.0,0.0,1.0);\n    if (pos.y > roomSize.y-0.01) roomColour = vec3(1.0,0.6,0.2);\n    if (pos.y < - roomSize.y+0.01) roomColour = vec3(0.0,1.0,0.2);\n    Impact room_p = Impact(roomDistance, 0.0, roomColour, 0);\n    \n    //Light globe\n    float lightRadius = light.r;\n\tfloat lightDistance = dSphere( pos-light.p, lightRadius );\n\t\n    Impact light_p = Impact(lightDistance,light.lum, light.col, 0);\n    \n  \n    Impact closest = getClosest(box1_p,sphere1_p);\n    closest= getClosest(closest,sphere2_p); \n    closest= getClosest(closest,room_p); \n    closest= getClosest(closest,light_p); \n      \n    return closest;\n}\n\n//Compute the normal - Gradient of the distance function\nvec3 getNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( EPS_NOR, 0.0 );\t\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t\tmap(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t\tmap(pos+eps.yyx).d - map(pos-eps.yyx).d );\n    \n\treturn normalize(nor);\n}\n\n//Cast a ray from ro in direction d\nImpact castRay(in vec3 ro, in vec3 d)\n{\n    vec3 r = ro+d*PRIM_RAY_STEP*1.0;\n    Impact impact;\n \tfor (int i = 0; i < PRIM_RAY_IT; i++)\n    {\n        impact = map(r);     \n        if(impact.d < PRIM_RAY_STEP*0.1) {\n            impact.d = length(r-ro);\n            return impact;\n        }\n        r += (impact.d)*d;          \n    }\n    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);\n}\n\n//Return a vector in the \"hemisphere\" of dir\nvec3 vecInHemisphere(vec3 dir, float phi, float sina, float cosa) {\n    // Define a local frame from the normal\n\tvec3 w = normalize(dir), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n   \n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n\nvec3 tracePath(in vec3 po, in vec3 dir, in vec2 fragCoord)\n{\n    //Fist impact\n    vec3 p = po;\n    vec3 col_base = vec3(1.0);\n    vec3 col = vec3(0.0);\n    vec3 norm = getNormal(p);\n    \n    //Secondary impacts\n    float fact_r = 1.0;\n    for (int i = 0; i<2   ;i++)\n        {   \n     \n\t        Impact impact = castRay(p,dir);\n    \t    p = p+dir*impact.d;\n            \n            vec3 norm = getNormal(p);             \n\t\t\t\n\t\t\tvec3 dirToLight0 = light.p - p;\n            //Compute cos of angular diameter of the light sphere\n\t\t\tfloat cos_a_max = sqrt(1. - clamp(light.r * light.r / dot(dirToLight0, dirToLight0), 0., 1.));\n\n\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n            \n            //Compute sample direction\n \t\t    vec3 dirToLight = normalize(vecInHemisphere(dirToLight0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa));\n    \n\t\t\tImpact impactOnLight = castRay(p,dirToLight);\n            \n            //Compute intensity of light on surface\n\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\tfloat e = (impactOnLight.lum * clamp(dot(dirToLight, norm),0.,1.) * omega) / PI;\t\t\t\t    \n  \t\t   \n            //Dirty 100.0 factor to produce nice image. To improve...\n            vec3 myCol = col_base*(impact.col*impact.lum)*1.0 + col_base*impact.col*e*100.0;\n                      \n            col_base = impact.col;             \t\n          \t  \t    \n    \t    col += myCol*fact_r;\n            \n            //Decay of intensity\n            fact_r *=0.9;\n            \n            //Next ray direction\n            norm = getNormal(p);\n            float rand2 = rand();\n            rand2 = rand2 * rand2;\n            dir = vecInHemisphere(norm, 2.*PI*rand(), sqrt(rand2), sqrt(1. - rand2));            \n        }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.0, 0.0+0.1,-0.6);\n\n    float resRatio = iResolution.x/iResolution.y;\n    \n    vec3 pixelPos = vec3(fragCoord.xy/ iResolution.xy*vec2(resRatio,1.0)-vec2(0.5*resRatio,0.5),0.0);\n    \n    vec3 dir = normalize(pixelPos - eye);  \n    \n    vec3 focalPoint = pixelPos + dir * FOCAL_DIST;\n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n\n    for (int j = 0; j<NB_RAY\t ; j++)\n    { \n    \tvec3 focOp = vec3(rand(),rand(),0.0)*BLUR_AMOUNT;\n        eye = eye+focOp; \n       \tdir = normalize (focalPoint - eye);\n        \n        col+=tracePath(eye,dir, fragCoord*sin(float(j)));             \n    }   \n    \n\tcol /= vec3(NB_RAY);\n    col = pow(col,vec3(0.8));\n       \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1171, 1171, 1185, 1185, 1228], [1230, 1296, 1339, 1339, 1408], [1411, 1434, 1459, 1459, 1474], [1476, 1476, 1510, 1510, 1533], [1536, 1536, 1566, 1566, 1654], [1656, 1656, 1694, 1694, 1716], [1719, 1769, 1794, 1808, 3545], [3547, 3604, 3635, 3635, 3850], [3852, 3888, 3927, 3927, 4270], [4272, 4317, 4384, 4428, 4562], [4565, 4565, 4625, 4643, 6287], [6290, 6290, 6347, 6347, 7142]], "test": "valid"}
{"id": "XddSDs", "name": "G-Lectric Sheep 14", "author": "vox", "description": "G-Lectric Sheep 14", "tags": ["glectricsheep14"], "likes": 2, "viewed": 441, "published": "Public API", "date": "1462208142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------SETTINGS-----------------\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(seedling+iTime+12345.12345)/PI/2.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat seedling;\n\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------GALAXY-----------------\n\nfloat galaxy(vec2 uv)\n{\n    uv *= 2.5;\n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    //float theta = atan(uv.y, uv.x)/3.14*.5+.5;\n//finalColor = vec4(vec3(theta),1.0);\n    float theta1 = atan(uv.y, uv.x)-r1*PI+iTime*.5;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+iTime*.5;\n    \nvec4 finalColor = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*vec4(1.0, 1.0, 1.0, 1.0)\n    \n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*vec4(0.0, 0.0, 2.0, 1.0)\n         + simplex3d(vec3(r2+iTime*.25, cos(theta2)*5., 0.0)*4.0)*(1.5-log(r2+1.))\n         + simplex3d(vec3(r2*r2+iTime*.25, cos(theta2)*5., 0.0)*4.0)*(1.25-log(r2+1.));\n    //finalColor.g *= (2.0+sin(iTime*.55));\n    //finalColor.r *= (3.0+cos(iTime*.45));\n    finalColor.b += .75;\n    \n    finalColor /= r1;\n    \n    finalColor *= 2.0;\n    return length(finalColor);\n    \n    //fragColor += (1.0-log(r1+1.));\n    \n    //fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0)+texture(iChannel0, uv/5.0).rgb;\n    \n    //fragColor.rgb *= .5;\n    return clamp(finalColor.b, 0.0, 1.0);\n}\n\n//-----------------RENDERING-----------------\n\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+5.0*vec2(time, time*GR/E))*GR;\n\tvec2 b = sin(seedling+4.666*vec2(time, time*GR/E))*GR;\n\tvec2 c = sin(seedling+4.333*vec2(time, time*GR/E))*GR;\n\tvec2 d = sin(seedling+4.0*vec2(time, time*GR/E))*GR;\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius((uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 reflection(vec2 uv)\n{\n    return (1.0-saw(PI*(uv*.5+.5)));\n}\nvec2 spiral(vec2 uv)\n{\n    float turns = 2.0;\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x)*turns-r*PI*2.0;\n    return vec2(saw(r*PI),\n                saw(theta));\n}\n\nvec2 perspective(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 16;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    int last_i;\n    \n    #define FUNCTION_PERSPECTIVE 0\n    #define FUNCTION_SPIRAL 1\n    \n    int function = 0;\n    vec2 next, last; \n    \n    for(int i = 0; i < max_i; i++)\n    {\n        last_i = 0;\n        seedling += fract(float(i)*123456.123456);\n        \n        if(function == FUNCTION_PERSPECTIVE)\n        {\n            last = uv;\n            next = perspective(uv, .5/iResolution.xy, magnification);\n\n            //omg so platform dependent... pls help fix:\n            float weight = smoothstep(0.0, 0.25, ifs);\n\n            ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n\n            float delta = galaxy(next*2.0-1.0);\n        \n            if(delta == 0.0)\n            {\n            depth += delta*ifs;\n\t            uv = last*ifs+uv*(1.0-ifs);\n                uv = reflection(uv*2.0-1.0);//*clamp(pow(delta, SPIRAL_BLUR_SCALAR)*2.0, 0.0, 1.0);\n            }\n            else if(delta >= 1.0)\n            {\n                \n                uv = next*weight+uv*(1.0-weight);\n\t\t\t\tfunction = FUNCTION_SPIRAL;\n            }\n            else\n            {\n                uv = next*weight+uv*(1.0-weight);\n\t\t\t\tfunction = FUNCTION_SPIRAL;\n            }\n        }\n        else if(function == FUNCTION_SPIRAL)\n        {\n            depth += galaxy(uv*2.0-1.0)*ifs/float(max_i)/float(i);\n         \tuv = uv*(1.0-ifs)+last*ifs;;\n                \n            function = FUNCTION_PERSPECTIVE;\n        }\n        \n        //if(mod(iTime, float(max_i))-float(i) < 0.0) break;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*15.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    if(pow(ifs, 1.0/abs(float(last_i-max_i))) < 1.0/2.0) discard;//DIVERGANCE + Free motion blur :)\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(saw(depth*PI*2.0+shift),\n                \t  \t\tsaw(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tsaw(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[770, 770, 792, 792, 989], [991, 991, 1016, 1016, 1747], [1797, 1797, 1826, 1826, 1896], [1898, 1898, 1927, 1927, 2011], [2057, 2057, 2080, 2080, 3236], [3286, 3286, 3308, 3308, 3578], [3580, 3580, 3599, 3599, 3646], [3648, 3648, 3674, 3674, 3713], [3714, 3714, 3736, 3736, 3894], [3896, 3896, 3959, 3959, 4532], [4534, 4534, 4591, 4591, 7104]], "test": "valid"}
{"id": "XdGXzW", "name": "Purple Interference Lines", "author": "innovati", "description": "Purple interference lines!", "tags": ["interference", "purple"], "likes": 2, "viewed": 74, "published": "Public", "date": "1463026815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = max(min(radians(inversesqrt(vec4(0.9, iTime, ceil(iTime), float(iFrame)))), atan(cos(sqrt(vec4(0.1, 0.0, 1.9, (1.2 / 1.3)))), atan(vec4((iTime + 1.9), (0.2 / 0.5), (gl_FragCoord.y / iResolution.y), float(iFrame)), vec4(0.7, 1.7, 1.3, 1.9)))), atan(normalize(max(cos(inversesqrt(mod(reflect(sin(vec4(1.4, iTime, iTime, ((mod(((gl_FragCoord.x / iResolution.x) / sqrt(0.3)), tan(0.6)) - (1.5 / 1.2)) * 0.8))), reflect(vec4(((gl_FragCoord.x / iResolution.x) + 0.2), 0.2, 0.3, (1.4 + 0.9)), vec4((((gl_FragCoord.x / iResolution.x) + ((0.9 * (1.0 * (((1.9 - 1.9) * normalize((reflect(1.1, 1.9) - 0.2))) * (1.5 * (gl_FragCoord.x / iResolution.x))))) + 0.4)) * 1.7), ((1.5 + max((gl_FragCoord.x / iResolution.x), 0.8)) / 0.5), 1.6, (gl_FragCoord.y / iResolution.y)))), degrees(vec4(1.7, 1.6, (gl_FragCoord.x / iResolution.x), float(iFrame)))))), vec4(0.6, 0.5, (gl_FragCoord.y / iResolution.y), 0.4))), atan(ceil(acos(vec4(0.7, 1.6, atan((gl_FragCoord.y / iResolution.y), 1.1), (float(iFrame) * 0.2)))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "XdKSzW", "name": "StupidBox", "author": "dila", "description": "Doesn't know if it wants to be open or closed.", "tags": ["raymarch"], "likes": 10, "viewed": 164, "published": "Public", "date": "1463350016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float t)\n{\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat mgt = 0.0;\nvec3 mpos = vec3(0.0);\nfloat mat = 0.0;\n\nfloat anim(float idx)\n{\n    float c = clamp(mgt - idx, 0.0, 1.0);\n    c = smoothstep(0.0, 1.0, c);\n    return c;\n}\n\nfloat map(vec3 p)\n{    \n    vec2 fs = vec2(0.1, 1.0);\n    float fo = 1.0;\n    \n    float d = fs.x + p.y;\n    mpos = p;\n    mat = 0.0;\n        \n    float sat = udBox(p, fs.yxy);\n    if (sat < d) {\n        d = sat;\n    \tmpos = p;\n        mat = 1.0;\n    }\n    \n    float sbt = anim(2.0);\n    vec3 sbp = p;\n    sbp.x -= fo;\n    sbp.xy *= rot(sbt * -1.57);\n    sbp.y -= fo;\n    float sb = udBox(sbp, fs.xyy);\n    if (sb < d) {\n        d = sb;\n        mpos = sbp;\n        mat = 1.0;\n    }\n    \n    float sct = anim(4.0);\n    vec3 scp = p;\n    scp.z -= fo;\n    scp.yz *= rot(sct * 1.57);\n    scp.y -= fo;\n    float sc = udBox(scp, fs.yyx);\n    if (sc < d) {\n        d = sc;\n        mpos = scp;\n        mat = 1.0;\n    }\n    \n\tfloat sdt = anim(1.0);\n    vec3 sdp = p;\n    sdp.x += fo;\n    sdp.xy *= rot(sdt * 1.57);\n    sdp.y -= fo;\n    float sd = udBox(sdp, fs.xyy);\n    if (sd < d) {\n        d = sd;\n        mpos = sdp;\n        mat = 1.0;\n    }\n    \n    float set = anim(3.0);\n    vec3 sep = p;\n    sep.z += fo;\n    sep.yz *= rot(set * -1.57);\n    sep.y -= fo;\n    float se = udBox(sep, fs.yyx);\n    if (se < d) {\n        d = se;\n        mpos = sep;\n        mat = 1.0;\n    }\n    \n    float sft = anim(0.0); \n    sep.y -= fo;\n    sep.z -= fo;\n    sep.yz *= rot(1.57);\n    sep.y += fo;\n    sep.yz *= rot(sft * -1.57);\n    sep.y -= fo;\n    float sf = udBox(sep, fs.yyx);\n    if (sf < d) {\n        d = sf;\n        mpos = sep;\n        mat = 1.0;\n    }\n\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nvec3 _texture(vec3 p)\n{\n    vec3 ta = texture(iChannel0, p.yz).xyz;\n    vec3 tb = texture(iChannel0, p.xz).xyz;\n    vec3 tc = texture(iChannel0, p.xy).xyz;\n    return (ta*ta + tb*tb + tc*tc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fgt = fract(iTime);\n    mgt = abs(fgt - 0.5) * 2.0 * 5.0;\n    float fcl = 0.0;\n\n    mat2 m = rot(iTime);\n    vec3 r = normalize(vec3(uv, 1.0));\n    r.yz *= rot(-0.5);\n    r.xz *= m;\n\n    vec3 o = vec3(0.0, 4.0, -4.0);\n    o.xz *= m;\n\n    float t = trace(o, r);\n\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n\n    float eye = max(dot(sn, -r), 0.0);\n    vec3 fc = eye * _texture(mpos * 0.25);\n    \n    if (mat == 0.0) {\n        fc *= 0.5;\n    }\n    \n    vec3 lpos = o + vec3(0.0, 6.0, 0.0);\n    vec3 ldir = w + sn * 0.01 - lpos;\n    float ldist = length(ldir);\n    ldir /= ldist;\n    float lt = trace(lpos, ldir);\n    float la = 0.0;\n    if (ldist < lt) {\n        float lit = max(dot(sn, -ldir), 0.0);\n        lit /= 1.0 + ldist * ldist * 0.0001;\n\t\tla += lit;\n    }\n    \n    fc *= la;\n    \n    float fog = 1.0 / (1.0 + t * t * 0.001);\n    fc = mix(vec3(1.0), fc, fog);\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [73, 73, 104, 104, 142], [202, 202, 225, 225, 316], [318, 318, 337, 337, 1774], [1776, 1776, 1797, 1797, 2001], [2003, 2003, 2032, 2032, 2178], [2180, 2180, 2203, 2203, 2373], [2375, 2375, 2432, 2432, 3468]], "test": "error"}
{"id": "XdKXD1", "name": "Balls Texture", "author": "gigatron", "description": "Phong ball textured... bordel ce code !!", "tags": ["phong", "texture", "balls"], "likes": 3, "viewed": 186, "published": "Public", "date": "1464160392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T 3.*iTime\n\n\nfloat intersect(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius)\n{\n  vec3  r = rayOrigin - sphereCenter;\n  float a = dot(rayDir, rayDir),\n        b = dot(r, rayDir),\n        c = dot(r, r) - radius*radius,\n        d = b*b - a*c;\n    \n  return  d < 0. ? -1. : (-b -sqrt(d)) / a;\n}\n\nvec4 getColor(vec3 p, vec3 center, vec4 diffuseColor, vec3 lightPosition)\n{\n \n    vec3 cameraPosition = vec3(.5, .5, 10),\n                       li = vec3(5.*cos(T), 10.*sin(T), 20.);\n    \n    vec3 n = normalize(p - center),\n       l = normalize(lightPosition - p),\n       v = normalize(cameraPosition - p),\n       h = normalize(v + l);\n  return diffuseColor * max(0., dot(n,l)) + max(0., pow(dot(n,h), 100.));\n}  \n\nvec4 drawSphere(vec3 rayDir, vec3 pos, float r, vec4 color, vec3 light)\n{\n  \n    vec3 cameraPosition = vec3(.5, .5, 10),\n                       li = vec3(5.*cos(T), 10.*sin(T), 20.);\n    float t = intersect(cameraPosition, rayDir, pos, r);\n  return t > -1. ? getColor(cameraPosition + t*rayDir, pos, color, light)\n                 : vec4(-1,0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   vec2 g=fragCoord.xy/iResolution.xy ;\n   \n    \n   vec2 uv  = fragCoord.xy  ; \n   vec4 col = vec4(0.,0.,0.,1.0); \n    \n    vec3 cameraPosition = vec3(.5, .5, 10),\n                       li = vec3(5.*cos(T), 10.*sin(T), 20.);\n    \n    uv   /= iResolution.xy ; \n    uv.x *= iResolution.x/iResolution.y;\n     \n    \n  vec3 npos = vec3(uv,0),\n     rayDir = normalize(npos - cameraPosition),\n          C = vec3(floor(uv*25.+.5)/25., 0);\n    \n  float r = .02;\n  vec4 cl = texture(iChannel0,g),\n     sphC = drawSphere(rayDir , C, r, cl, li);      \nfragColor = vec4(sphC.x > -1. ? sphC*1.2 : col-col);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 100, 100, 312], [314, 314, 389, 389, 726], [730, 730, 803, 803, 1080], [1082, 1082, 1136, 1136, 1732]], "test": "error"}
{"id": "XdtSWl", "name": "Raymarcher Visualization", "author": "jackdavenport", "description": "This shader visualises the way a raymarcher works. The left side of the screen shows the depth (distance from the camera to FAR_PLANE), and the iterations (how many times the for loop in raymarch() runs to calculate that pixel).", "tags": ["raymarch", "distance", "depth", "steps", "debug", "visual", "view"], "likes": 1, "viewed": 625, "published": "Public API", "date": "1462145859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 128\n#define MIN_DISTANCE .001\n#define FAR_PLANE    64.\n\nstruct Ray { vec3 ori; vec3 dir;  };\nstruct Hit { float dst; int iter; };\n\nfloat dstSphere(vec3 p, vec3 pos, float r) {\n \n    return length(pos - p) - r;\n    \n}\n\nfloat dstFloor(vec3 p, float y) {\n \n    return p.y - y;\n    \n}\n\n//Smooth Minimum by iq\n//Source: http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dstScene(vec3 p) {\n    \n    float dst = dstFloor(p, -1.);\n    float sphDst = dstSphere(p, vec3(0.), 1.);\n    sphDst = smin(sphDst, dstSphere(p, vec3(1.5 * sin(iTime),.5,-.5), .5), .1);\n    sphDst = smin(sphDst, dstSphere(p, vec3(-1.5* sin(iTime),.25,-.5), .5), .1);\n    \n    dst = min(dst, sphDst);\n    return dst;\n    \n}\n\nHit raymarch(Ray ray) {\n \n    float d  = 0.;\n    int iter = 0;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        d += dstScene(ray.ori + ray.dir * d) * .75;\n        \n        if(d <= MIN_DISTANCE || d > FAR_PLANE) {\n         \n            iter = i;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(d,iter);\n    \n}\n\nvec3 shade(Ray ray, vec2 fragCoord) {\n \n    Hit scn = raymarch(ray);\n    float x = iMouse.x / iResolution.x;\n    if(iMouse.x == 0.) x = .5;\n    \n    vec3 col = vec3(0.);\n    \n    if((fragCoord.x / iResolution.x) <= x) {\n        \n        col = vec3(scn.dst) / FAR_PLANE;\n        \n    } else {\n\n        col = vec3(scn.iter) / float(MAX_ITERATIONS);\n        \n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-3.);\n    vec3 dir = vec3(uv, 1.);\n    \n\tfragColor = vec4(shade(Ray(ori,dir),fragCoord),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 198, 198, 239], [241, 241, 274, 274, 303], [305, 391, 432, 432, 525], [527, 527, 551, 551, 854], [856, 856, 879, 879, 1210], [1212, 1212, 1249, 1249, 1601], [1603, 1603, 1660, 1660, 1848]], "test": "valid"}
{"id": "XdVSW1", "name": "Desert biome", "author": "Karang", "description": "Rocky desert", "tags": ["procedural", "planet", "desert", "biome"], "likes": 24, "viewed": 658, "published": "Public", "date": "1464124717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat terrain(vec2 p, int octaves) {\t\n\tfloat h = 0.0;\n\tfloat w = 0.5;\n\tfloat m = 0.4;\n\tfor (int i=0; i<12; i++) {\n\t\tif (i==octaves) break;\n\t\th += w * snoise((p * m));\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\nfloat terrainSand(vec2 p, int octaves) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<12 ; i++) {\n        if (i==octaves) break;\n        h += abs(snoise(p*f)/f);\n        f *= 2.0;\n    }\n    return h;\n}\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\th += smoothstep(0.0, 1.1, h);\n    h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\t// Sand dunes\n\tif (h<0.5) {\n\t\tfloat s = 0.3 * terrainSand(p.xz*0.2, octaves);\n\t\td = p.y -0.35 + s;\t\n\t\tif (d<dMin) { \n\t\t\tdMin = d;\n\t\t\tmID = 1.0;\n\t\t}\n\t}\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n\n\t// Camera\n\tfloat x = 0.0 + (0.5*iTime);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*iTime);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 394, 394, 564], [566, 566, 606, 606, 781], [783, 783, 814, 814, 1223], [1289, 1289, 1334, 1334, 1620], [1622, 1622, 1660, 1660, 1915], [1917, 1917, 1984, 1984, 2211], [2213, 2213, 2244, 2244, 3661], [3663, 3663, 3720, 3720, 4339]], "test": "valid"}
{"id": "XdVXRD", "name": "Isosurface raycasting", "author": "mpj500", "description": "Started with ray/AABB code from J-E-L-L-O by @demofox ([url]https://www.shadertoy.com/view/4lXSDf[/url]). Added some within-cell isosurface ray tracing.", "tags": ["isosurface"], "likes": 4, "viewed": 435, "published": "Public", "date": "1463240167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FLT_MAX 3.402823466e+38\n#define PI 3.1415926536\n\nconst float c_scale = 1.0;\n\n//=======================================================================================\n\nfloat snoise(vec3 p) {\n\t\n    float igt = iTime * 0.01;\n    vec2 uv = p.xy + vec2(17.0,7.0)*(p.z+igt);\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn (rg.x - 0.5)*55.5;\n}\n\n//=======================================================================================\n\nfloat RayIntersectAABoxMax (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)\n{\n    vec3 boxMid = vec3(cellPos)+vec3(0.5);\n    \n\tvec3 roo = rayPos - boxMid;\n    vec3 rad = vec3(0.5);\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t2 = -n + k;\n\n    return min( min( t2.x, t2.y ), t2.z );\n}\n\nfloat RayIntersectAABoxMin (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)\n{\n    vec3 boxMid = vec3(cellPos)+vec3(0.5);\n    \n\tvec3 roo = rayPos - boxMid;\n    vec3 rad = vec3(0.5);\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n\n    return max( max( t1.x, t1.y ), t1.z );\n}\n\nfloat CubicLERP(vec4 A, vec4 B, vec3 p)\n{\n    return mix( mix( mix(A.x, A.y, p.x),\n                     mix(A.z, A.w, p.x), p.y),\n                mix( mix(B.x, B.y, p.x),\n                     mix(B.z, B.w, p.x), p.y), p.z);\n}\n\nfloat DistanceFunc_ (in vec3 p)\n{\n    ivec3 cellPos = ivec3(floor(p));\n    \n    vec4 A = vec4(snoise(vec3(cellPos+ivec3(0,0,0))),\n              snoise(vec3(cellPos+ivec3(1,0,0))),\n\t \t\t  snoise(vec3(cellPos+ivec3(0,1,0))),\n\t \t\t  snoise(vec3(cellPos+ivec3(1,1,0))));\n\n    vec4 B = vec4(snoise(vec3(cellPos+ivec3(0,0,1))),\n              snoise(vec3(cellPos+ivec3(1,0,1))),\n\t \t\t  snoise(vec3(cellPos+ivec3(0,1,1))),\n\t \t\t  snoise(vec3(cellPos+ivec3(1,1,1))));\n\n    return CubicLERP(A,B, p - vec3(cellPos));\n}\n\n\nfloat DistanceFunc (in vec3 p)\n{\n    p *= c_scale;\n    \n    vec3 fp = floor(p);\n    ivec3 cellPos = ivec3(fp);\n   \n    vec4 A = vec4(DistanceFunc_(vec3(cellPos+ivec3(0,0,0))),\n              DistanceFunc_(vec3(cellPos+ivec3(1,0,0))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(0,1,0))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(1,1,0))));\n\n    vec4 B = vec4(DistanceFunc_(vec3(cellPos+ivec3(0,0,1))),\n              DistanceFunc_(vec3(cellPos+ivec3(1,0,1))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(0,1,1))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(1,1,1))));\n    \n    return CubicLERP(A,B,p-fp);\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// Adaptation of SolveCubic from \"Roots3And4.c\" by Jochen Schwarze found in Graphics Gems\n///////////////////////////////////////////////////////////////////////////////////////////\n\nfloat cbrt( float x )\n{\n    return pow(abs(x), 1.0/3.0) * sign(x);\n}\n\nvec2 SolveQuadric(vec3 coeff)\n{\n    float c0 = coeff.x;\n    float c1 = coeff.y;\n    float c2 = coeff.z;\n\n    // normal form: x^2 + px + q = 0\n\n    float p = c1 / (2.0 * c2);\n    float q = c0 / c2;\n\n    float D = p * p - q;\n\n    if (D < 0.0)\n    {\n\t\treturn vec2(FLT_MAX);\n    }\n    float sqrt_D = sqrt(D);\n    return vec2( sqrt_D - p, -sqrt_D - p );\n}\n\nvec3 SolveCubic(vec4 coeff)\n{\n    vec3 s;\n    \n    if( abs(coeff.x) < 0.01 )\n    {\n        return SolveQuadric(coeff.wzy).xyy;\n    }\n    \n    // normal form: x^3 + Ax^2 + Bx + C = 0\n\n    vec3 ABC = coeff.yzw / coeff.x;\n    float A = ABC.x;\n    float B = ABC.y;\n    float C = ABC.z;\n\n    // substitute x = y - A/3 to eliminate quadric term:\n\t// x^3 +px + q = 0\n\n    float sq_A = A * A;\n    float p = (-1.0/3.0  * sq_A + B) / 3.0;\n    float q = ( 2.0/27.0 * A * sq_A - 1.0/3.0 * A * B + C) / 2.0;\n\n    // use Cardano's formula\n\n    float cb_p = p * p * p;\n    float D = q * q + cb_p;\n\n    if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n        float phi = 1.0/3.0 * acos(-q * inversesqrt(-cb_p));\n        float t = 2.0 * sqrt(-p);\n\n        s = t * vec3(cos(phi), -cos(phi + PI / 3.0), -cos(phi - PI / 3.0));\n    }\n    else // one real solution\n    {\n        float sqrt_D = sqrt(D);\n        float u =  cbrt(sqrt_D - q);\n        float v = -cbrt(sqrt_D + q);\n\n        s = vec3(u + v);\n    }\n\n    // resubstitute\n    return s - vec3(A/3.0);\n}\n\nconst mat4 isoCubicCoeff = mat4(\n    vec4( -9.0/2.0, 27.0/2.0, -27.0/2.0, 9.0/2.0),\n    vec4(  9.0,    -45.0/2.0,  18.0,    -9.0/2.0),\n    vec4(-11.0/2.0,  9.0,      -9.0/2.0, 1.0),\n    vec4(  1.0,      0.0,       0.0,     0.0));\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// Cubic polynomial equation from:\n// \"Analytic Isosurface Rendering and Maximum Intensity Projection on the GPU\"\n///////////////////////////////////////////////////////////////////////////////////////////\n\nfloat DoRootFinding( vec3 o, vec3 disp)\n{\n    vec4 samples = vec4(DistanceFunc(o),\n                        DistanceFunc(o + disp*(1.0/3.0)),\n                        DistanceFunc(o + disp*(2.0/3.0)),\n                        DistanceFunc(o + disp));\n    \n    if( samples.x < 0.0 )\n    {\n        return -1.0;\n    }\n\n    vec3 s = SolveCubic(samples * isoCubicCoeff);\n    \n    float tmin = 1.0;\n    if( s.x >=0.0 && s.x < tmin ) tmin = s.x;\n    if( s.y >=0.0 && s.y < tmin ) tmin = s.y;\n    if( s.z >=0.0 && s.z < tmin ) tmin = s.z;\n    \n    return tmin;\n}\n\n\n//=======================================================================================\nvec3 HandleRay (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir, inout float hitTime)\n{\n    // calculate surface normal\n    float tMin = RayIntersectAABoxMin(cellPos, rayPos, rayDir);\n    float tMax = RayIntersectAABoxMax(cellPos, rayPos, rayDir);\n    \n    if( tMin>tMax && tMin > 0.0 )\n    {\n        hitTime = FLT_MAX;\n        return vec3(1.0);\n    }\n   \tif( tMin > hitTime )\n    {\n        hitTime = FLT_MAX;\n        return vec3(0.0);        \n    }\n    \n    vec3 frontCollisionPos = rayPos + rayDir*tMin;\n    vec3 backCollisionPos = rayPos + rayDir*tMax;\n    \n    float tt = DoRootFinding(frontCollisionPos, backCollisionPos - frontCollisionPos);\n    if( tt < 1.0 )\n    {\n        if( tt < 0.0 )\n        {\n            hitTime = tMin;\n        \treturn vec3(1.0,0.0,0.0);\n        }\n        \n        hitTime = mix(tMin,tMax, tt);\n        return vec3(0.0,1.0,0.0);\n    }\n    hitTime = FLT_MAX;\n    return vec3(1.0);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    //----- camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt = vec3(0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * (9.0 + 2.0 * (sin(iTime)*0.5+0.5));\n    cameraPos += vec3(0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\t\n\t\t\n\t// Objects\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float skyY = 0.8+rayDir.y;\n    vec3 minPixCol = vec3(0.3,0.6,1.0)*skyY;\n    float minHitTime = FLT_MAX;\n    \n    const int xs = 2;\n    const int ys = 2;\n    const int zs = 2;\n    \n    for( int z=-zs;z<=zs; z++)\n    {\n        for( int y=-ys;y<=ys; y++)\n        {\n            for( int x=-xs;x<=xs; x++)\n            {\n                float hitTime = minHitTime;\n\t\t\t\tvec3 pixelColor = HandleRay(ivec3(x,y,z), cameraPos, rayDir, hitTime);\n                \n                if( hitTime < minHitTime )\n                {\n                    vec3 pos = cameraPos + rayDir * hitTime;\n                    pos *= 2.0;\n                    vec3 cellPos = pos - floor(pos);\n                    float gridMin = min(min(cellPos.x,cellPos.y),cellPos.z);\n                    float gridMax = max(max(cellPos.x,cellPos.y),cellPos.z);\n                    gridMin = min(gridMin, 1.0-gridMax);\n                    \n                    float gridScale = gridMin < 0.05 ? 0.5 : 1.0;\n                                        \n                    \n                    minHitTime = hitTime;\n                    minPixCol = pixelColor * gridScale;\n                }\n            }\n        }\n    }\n    \n    if( minHitTime < FLT_MAX )\n    {\n        // calculate and apply absorption\n    \tvec3 c_absorb = vec3(1.8,1.8,1.8)*0.2;\n    \tvec3 absorb = vec3(exp(-c_absorb * (minHitTime-7.0)));\n    \tminPixCol *= absorb;\n    }\n    \n    fragColor = vec4(clamp(minPixCol,0.0,1.0), 1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 198, 198, 366], [459, 459, 538, 538, 782], [784, 784, 863, 863, 1107], [1109, 1109, 1150, 1150, 1334], [1336, 1336, 1369, 1369, 1839], [1842, 1842, 1874, 1874, 2430], [2707, 2707, 2730, 2730, 2775], [2777, 2777, 2808, 2808, 3127], [3129, 3129, 3158, 3158, 4182], [4714, 4714, 4755, 4755, 5265], [5268, 5358, 5446, 5478, 6271], [6273, 6363, 6420, 6446, 9015]], "test": "error"}
{"id": "XdVXzw", "name": "Tuubit", "author": "luutifa", "description": "I've been holding on to this one to possibly release it in a proper demo one day but I decided that it's not that special anyway and nobody likes to see ray marching on big screen these days (at least not me). Monte Carlo -ish DOF as an afterthought.", "tags": ["3d", "raymarching", "dof", "spheretracing", "depthoffield", "focalpoint"], "likes": 11, "viewed": 199, "published": "Public", "date": "1463515023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2016 Lauri Gustafsson\n/*\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n    and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\n    AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifdef GL_ES\n    precision highp float;\n#endif\n\nfloat t = iTime*0.6;\n\n#define PI 3.14159265\n#define E 0.001\n//maximum traced distance\n#define MD 60.0\n//sphere trace maximum steps\n#define I 80\n//ray initial depth\n#define MS 10.0\n//slows the sphere tracing for less artifacts\n#define B .8\n\n#define DOF_FOCAL_POINT_DEPTH 12.0\n#define DOF_SAMPLES 32\n#define DOF_SCATTER 1.0\n\n//http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n\nvoid repX(inout vec3 p, float s) {\n    vec3 r = p;\n    r.x = mod(p.x, s)-(s*0.5);\n    p=r;\n}\n\nvoid repXY(inout vec3 p, float s) {\n    vec3 r = p;\n    r.x = mod(p.x, s)-(s*0.5);\n    r.y = mod(p.y, s)-(s*0.5);\n    p=r;\n}\n\nvoid repXYZ(inout vec3 p, float s) {\n    vec3 r = p;\n    r.x = mod(p.x, s)-(s*0.5);\n    r.y = mod(p.y, s)-(s*0.5);\n    r.z = mod(p.z, s)-(s*0.5);\n    p=r;\n}\n\n//SDF for an infinite square tubelike object\nfloat tube(vec3 p) {\n    vec2 d = abs(p.yz) - vec2(1.0);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Signed Distance Field function for the whole scene\nfloat f(vec3 p) {\n    vec3 tp = p;\n    tp.z=max(tp.z, 10.0);\n    tp.y*=sin(tp.x*0.1+t*0.8)*0.4+1.0;\n    repXY(tp.yzx, 8.0);\n    tp.y+=sin(tp.x*.4+t*2.0+tp.z*0.3)*.7;\n    tp=getXRotMat(tp.x*.1+t*0.8+tp.y*0.07)*tp;\n    return tube(tp);\n}\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(E, 0.0);\n    return (vec3(f(p+e.xyy), f(p+e.yxy), f(p+e.yyx)) - f(p)) / e.x;\n}\n\n//sphere trace to scene, should return the point where our ray hits a surface defined by an SDF function (f)\n//http://computergraphics.stackexchange.com/questions/161/what-is-ray-marching-is-sphere-tracing-the-same-thing\nvec3 m(vec3 o, vec3 v) {\n    float d;\n    float t=MS;\n    for (int i=0;i<I;i++) {\n        d=f(o+v*t);\n        t+=d*B;\n        if (d<E||t>MD)\n            break;\n    }\n    return o+v*t;\n}\n\nvec3 applyFog(float z, float i, vec3 ci, vec3 fc) {\n    return mix(ci, fc, clamp(i*z, 0.0, 1.0));\n}\n\nvec3 c(vec3 cam, vec3 dir) {\n    //point in the scene\n    vec3 p=m(cam, dir);\n    \n    //normal for that point\n\tvec3 nm = normalize(grad(p));\n    //basic shading\n    float diff = max(dot(normalize(p-cam), -nm), 0.0);\n    vec3 c = vec3(1.0, 0.2, 0.1)*(1./length(p-cam))*diff*max(pow(diff, 2.0)*8.0, 1.0)*max(pow(diff, 20.0)*2.0, 1.0)*12.0;\n    //fog/BG colors, alternating\n    vec3 fc1=vec3(1.0, 0.0, 0.1);\n    vec3 fc2=vec3(0.1, 0.0, 1.0);\n    float fp = sin(t*0.4)*0.5+0.5;\n\tvec3 fc = fc1*fp+(fc2*(1.0-fp));\n    c=applyFog(p.z, 0.03, c, fc);\n    return c;\n}\n\nvoid mainImage(out vec4 fcolor, in vec2 fcoord) {\n    //transform gl_FragCoord to a more usable screen space coordinate\n    vec2 sp = (2.*fcoord.xy-iResolution.xy)/iResolution.y;\n    \n    //camera position, rotation, direction for current pixel ray\n    vec3 cam = vec3(sin(t*0.3)*0.2, cos(t)*6.0, sin(t*0.6)*0.4);\n    mat3 camRotMat = getXRotMat(sin(t*0.3)*0.3)*getYRotMat(sin(t*0.7)*0.2)*getZRotMat(sin(t*0.1)*0.4);\n    vec3 dir;\n\n    vec3 color = vec3(0.0);\n    for (int i=0; i<DOF_SAMPLES; i++) { //take multiple samples of the render\n        //noise, needed to simulate rays hitting wrong parts of the image plane (which causes defocus)\n        vec3 noise = vec3(rand(sp+float(i)+t), rand(sp+float(i)*1.1+t), rand(sp+float(i)*1.2+t))*DOF_SCATTER;\n        //compute the actual direction that the ray needs to take towards the scene\n        //so that no matter how displaced is the starting point, it will intersect the \"correct\"\n\t\t//ray at DOF_FOCAL_POINT_DEPTH\n        dir = camRotMat * normalize((vec3(sp, 1.0)*DOF_FOCAL_POINT_DEPTH)-noise);\n        //render, displacing the ray origin a little\n        color += c(cam+noise, dir);\n    }\n    fcolor = vec4(color/float(DOF_SAMPLES), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVXzw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1484, 1561, 1581, 1581, 1651], [1653, 1653, 1679, 1679, 1797], [1799, 1799, 1825, 1825, 1943], [1945, 1945, 1971, 1971, 2092], [2094, 2094, 2128, 2128, 2186], [2188, 2188, 2223, 2223, 2312], [2314, 2314, 2350, 2350, 2470], [2472, 2517, 2537, 2537, 2630], [2632, 2685, 2702, 2702, 2920], [2922, 2922, 2941, 2941, 3038], [3040, 3261, 3285, 3285, 3446], [3448, 3448, 3499, 3499, 3547], [3549, 3549, 3577, 3602, 4107], [4109, 4109, 4158, 4228, 5302]], "test": "valid"}
{"id": "XdySDh", "name": "'Murica", "author": "elpuri", "description": "Ladies and gentlemen, start your hamburgers!\n \nSadly I'm no iq, so no ray marched bald eagle :/ ", "tags": ["2d", "flag"], "likes": 2, "viewed": 260, "published": "Public", "date": "1463977795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Juha Turunen (turunen@iki.fi)\n// http://www.usflag.org/flag.specs.html\n\n#define M_PI 3.14159\nconst vec4 oldGloryRed = vec4(191.0 / 255.0, 10.0 / 255.0, 48.0 / 255.0, 1.0);  // PMS 193C\nconst vec4 oldGloryBlue = vec4(0.0, 40.0 / 255.0, 104.0 / 255.0, 1.0);  // PMS 281C\nconst vec4 cosmeticDentistryWhite = vec4(1.0);\n\nfloat smoothbump(float low, float high, float x, float eps)\n{\n    return smoothstep(low - eps, low + eps, x) - smoothstep(high - eps, high + eps, x);\n}\n\nvec4 stripes(in float y, float eps) {\n\teps *= 20.0;\n    float m = mod(y * 13.0, 2.0);\n    float a = smoothstep(1.0 - eps, 1.0 + eps, m) - smoothstep(2.0 - eps, 2.0 + eps, m);\n    return mix(oldGloryRed, cosmeticDentistryWhite, a);\n}\n\nfloat inTriangle(in vec2 p, in vec2 t0, in vec2 t1, in vec2 t2, in float eps) \n{\n\tvec2 v0 = t2 - t0;\n\tvec2 v1 = t1 - t0;\n\tvec2 v2 = p - t0;\n\n\tfloat d00 = dot(v0, v0);\n\tfloat d01 = dot(v0, v1);\n\tfloat d02 = dot(v0, v2);\n\tfloat d11 = dot(v1, v1);\n\tfloat d12 = dot(v1, v2);\n\n\tfloat d = d00 * d11 - d01 * d01;\n\tfloat u = (d11 * d02 - d01 * d12) / d;\n\tfloat v = (d00 * d12 - d01 * d02) / d;\n\n    eps = 0.2;\n    float uvStep = smoothstep(1.0 + eps, 1.0 - eps,  u + v);\n\tfloat uStep = u > 0.0 ? 1.0 : 0.0;\n\tfloat vStep = v > 0.0 ? 1.0 : 0.0;\n    return min(uvStep, min(uStep, vStep));\n}\n\nfloat star(in vec2 p, in float radius, in float eps) {\n    p.y = -p.y;\n    mat2 transform = mat2(1.0);\n    float thetaOffset = 0.5 * M_PI;\n    float theta = M_PI * 2.0 / 5.0;\n    mat2 rotate = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    float tri = 0.0;\n    vec2 p1 = vec2(cos(-theta + thetaOffset), sin(-theta + thetaOffset)) * radius;\n    vec2 p2 = vec2(cos( theta + thetaOffset), sin( theta + thetaOffset)) * radius;\n    for (int i = 0; i < 5; i++) {\n    \ttri = max(tri, inTriangle(p, vec2(0.0), transform * p1, transform * p2, eps));\n        transform = rotate * transform;\n    }\n\treturn tri;\n}\n\nvec4 starPattern(in vec2 p, in float eps)\n{\n    const float starHSpacing = 0.063;\n    const float starVSpacing = 0.054;\n    const float starRadius = 0.052 * 0.5;\n    \n    p -= vec2(starHSpacing, starVSpacing);\n    vec2 pa = p;\n    p.x = mod(p.x + 0.5 * starHSpacing, starHSpacing * 2.0) - 0.5 * starHSpacing;\n    p.y = mod(p.y + 0.5 * starVSpacing, starVSpacing) - 0.5 * starVSpacing;\n    float line = mod(pa.y + 0.5 * starVSpacing, 2.0 * starVSpacing) - 0.5 * starVSpacing;\n    p.x -= line < starVSpacing * 0.5 ? 0.0 : starHSpacing;\n\tfloat c = star(p, starRadius, eps);\n    \n    if (pa.x < -starHSpacing * 0.5  || \n        pa.x > 10.5 * starHSpacing  ||\n        pa.y < -starVSpacing * 0.5  ||\n        pa.y > 8.5 * starVSpacing )\n        c = 0.0;\n\n    return vec4(cosmeticDentistryWhite.rgb, c);\n}\t\n\nvec4 theUnion(in vec2 p, in float eps) {\n    vec4 s = starPattern(p, eps);\n    vec4 c = mix(oldGloryBlue, s, s.a);\n    \n    const float unionWidth = 0.76;\n\tfloat unionHeight = 0.5385;\n    c.a = smoothstep(unionWidth + eps, unionWidth - eps, p.x);\n    c.a *= smoothstep(unionHeight + eps, unionHeight - eps, p.y);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy;\n\tp.y = iResolution.y - p.y;\n    p /= iResolution.xx;\n    p *= 2.5;\n    \n    const vec2 amplitude = vec2(0.06, 0.05);\n\tp -= vec2(0.275 + cos(iTime + p.y * 3.0) * amplitude.x, \n              0.22 + sin(iTime + p.x * 5.0) * amplitude.y);\n\n    float eps = dFdx(p).x * 0.5;\n    \n    vec4 stripesColor = stripes(p.y, eps); \n    vec4 unionColor = theUnion(p, eps);\n    vec4 flagColor = vec4(mix(stripesColor.rgb, unionColor.rgb, unionColor.a), 1.0);\n\n    flagColor.a = smoothbump(0.0, 1.9, p.x, eps);\n    flagColor.a *= smoothbump(0.0 + eps, 1.0 - eps, p.y, eps);\n    \n    vec3 bgColor = vec3(0.25);\n    vec3 outputColor = mix(bgColor, flagColor.rgb, flagColor.a);\n\n    float vignette = pow(length((fragCoord - 0.5 * iResolution.xy) / iResolution.xy), 3.0) * 3.0; \n\toutputColor = mix(outputColor, vec3(0.0), vignette);\n    fragColor = vec4(outputColor, 1.0);\n}", "image_inputs": [{"id": "XsfGWj", "previewfilepath": "https://soundcloud.com/francescodandrea/star-spangled-banner-jimi", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/francescodandrea/star-spangled-banner-jimi", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdySDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 381, 381, 471], [473, 473, 510, 510, 705], [707, 707, 787, 787, 1286], [1288, 1288, 1342, 1342, 1901], [1903, 1903, 1946, 1946, 2700], [2703, 2703, 2743, 2743, 3031], [3033, 3033, 3090, 3090, 3968]], "test": "valid"}
{"id": "XdySRW", "name": "Jacob's Ladder", "author": "innovati", "description": "Climb jacob's ladder", "tags": ["jacobs", "ladder"], "likes": 0, "viewed": 85, "published": "Public", "date": "1463008391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = mod(mod(exp2(min(tan(degrees(atan(reflect(mod(vec4(log((gl_FragCoord.x / iResolution.x)), 1.3, 0.4, atan((0.0 - 1.7))), max(vec4(((1.3 / (gl_FragCoord.x / iResolution.x)) * iTime), 1.6, min(float(iFrame), atan(1.7, 1.2)), 1.8), floor(vec4(1.3, 0.2, 0.5, 0.3)))), vec4(1.7, 0.2, 0.4, iTime))))), max(sin(vec4(0.3, 1.5, 0.1, 1.4)), vec4(0.3, (degrees((0.9 - 0.5)) * (gl_FragCoord.y / iResolution.y)), iTime, (gl_FragCoord.y / iResolution.y))))), vec4((0.8 / (gl_FragCoord.x / iResolution.x)), 0.5, (0.7 + 0.9), (1.0 / tan(1.4)))), max(mod(vec4(1.7, 1.2, (0.5 / 0.0), pow(0.6, (gl_FragCoord.x / iResolution.x))), vec4(0.3, sin(1.5), 0.8, 1.6)), min(vec4(1.1, 0.5, pow(float(iFrame), 0.6), 1.2), vec4(1.8, 1.4, (gl_FragCoord.x / iResolution.x), 0.3))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdySRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 820]], "test": "valid"}
{"id": "Xs3Sz2", "name": "Rotate 123456789", "author": "Natthan", "description": ".", "tags": ["ro"], "likes": 1, "viewed": 94, "published": "Public", "date": "1463761903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI (3.1415)\n \nfloat map(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 -1.0;\n   \n    return length(q) - 0.25;\n}\n \nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.3;\n    }\n    return t;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv = uv * (iResolution.x / iResolution.y); // notre environement\n   \n    vec3 r = normalize(vec3(uv, 1.)); // <== camera\n    vec3 o = vec3(.0, .0, iTime); // <== direction\n    \n    float rotate = iTime;\n    r.xy *= mat2(cos(rotate), \n                  sin(rotate), \n                  -sin(rotate),\n                  cos(rotate)); // on change r ( r= camera)\n   \n    r.xz *= mat2(cos(rotate), \n                  sin(rotate), \n                  -sin(rotate),\n                  cos(rotate));\n   \n    float t = trace(o, r); // <== rendu\n    float fog = 1.0 / (1.0 + t * t * 0.1); // <== pour le fun\n   \n    vec3 fc = vec3(sin(iTime) * fog,\n                   sin(iTime - (2.0/3.0 * M_PI)) * fog,\n                   sin(iTime - (4.0/3.0 + M_PI)) * fog);\n    // <== la couleur\n   \n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3Sz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 112], [115, 115, 144, 144, 296], [299, 299, 356, 356, 1237]], "test": "valid"}
{"id": "Xs3Xz2", "name": "test 124657451894", "author": "Natthan", "description": "test", "tags": ["test"], "likes": 2, "viewed": 103, "published": "Public", "date": "1463762041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 f, in vec2 p )\n{\n    float n = 0.;\n    vec2 c = vec2(-.745,.186) + 3. * (p.xy/iResolution.y-.5)*pow(.01,1.+cos(.5*iTime )* 2.5), z=c*n;\n   \n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y ) + c;\n \n        if( dot(z,z)>1e6 ) break;\n \n        n++;\n    }\n   \n    f = .5 + .5*cos( vec4(3,4,11,0) + .05*(n - log2(log2(dot(z,z)))) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3Xz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 391]], "test": "valid"}
{"id": "XsGSR1", "name": "light dome", "author": "tomaes", "description": "additive bubble worm, tunnel. another minimal style piece.\n\nupdate: weird nets. :)", "tags": ["tunnel", "blur", "light", "abstract"], "likes": 2, "viewed": 237, "published": "Public", "date": "1462712295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// v2.5\nvoid mainImage( out vec4 f, in vec2 p )\n{\n\tvec2 uv = ( (p.xy - (iResolution.xy*.5)) / iResolution.y );\n\n    float t = iTime+4.77; // + 6.77;\n\tfloat c = sin(uv.x*10.+t)*.3;\n\n\tfor(float f = -.5; f < .5; f += .08)\n    {\n\t\tc +=   min( (.015 + sin((t+f*2.)*3.)*.005 ) /         distance( vec2(uv.x+mod(uv.y*uv.x,.001),sin(uv.x*2.+uv.y*5.+t)*.5) ,vec2( sin( uv.x*5.+f*5.+t )*.1,f) ), .25 );\n        float tmp = (.015 + sin((t+f*2.)*3.)*.005 ) / (fract( 20.*distance( vec2(uv.x+mod(uv.y*uv.x,.001),sin(uv.x*2.+uv.y*5.+t)*.5) ,vec2( sin( uv.x*5.+f*5.+t )*.1,f) )) );\n        \n        c += tmp * uv.y*.5;\n    }\n\n    c += .04*mod(t+10./length(uv-sin(t+uv.x+uv.y)*.1 ),1.25);    \n\n   // if (uv.x < -.6 || uv.x > .6)\n   //     c = .1-c;\n    \n\tf = vec4( c*.83-uv.x*.1,c*.8,c*.75+uv.y*.15, 1. );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 49, 49, 795]], "test": "valid"}
{"id": "XsGXR1", "name": "Linked Rings", "author": "dr2", "description": "Two Moebius strips", "tags": ["moebius"], "likes": 5, "viewed": 649, "published": "Public API", "date": "1462719414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Linked Rings\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nconst float pi = 3.14159;\n\nmat3 vuMat;\nvec3 ltDir;\nfloat dstFar, tCur, mobRad;\n\nfloat MobiusTDf (vec3 p, float r, float b, float rc, float ns)\n{\n  vec3 q;\n  float d, a, na, aq;\n  p.xz = Rot2D (p.xz, 0.1 * tCur);\n  q = vec3 (length (p.xz) - r, 0., p.y);\n  a = atan (p.z, p.x);\n  q.xz = Rot2D (q.xz, 0.5 * a);\n  d = length (max (abs (q.xz) - b, 0.)) - rc;\n  q = p;\n  na = floor (ns * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / ns;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 0.5 * aq);\n  d = max (d, - max (PrBoxDf (q, vec3 (1.1, 1.1, 0.18) * b),\n    - PrBox2Df (q.xy, vec2 (0.5, 0.5) * b)));\n  return 0.7 * d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, a, aq, na;\n  q = p;\n  q.z -= 0.5 * mobRad;\n  d = MobiusTDf (q, mobRad, 0.6, 0.01, 16.);\n  q = p;\n  q.z += 0.5 * mobRad;\n  d = min (d, MobiusTDf (q.zxy, mobRad, 0.6, 0.01, 16.));\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd = rd * vuMat;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (0.1 * tCur + rd.xy / rd.z);\n  return mix (mix (vec3 (0., 0., 0.6), vec3 (1.), 0.7 * Fbm2 (2. * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ror, rdr, vn, col;\n  float dstObj, dstObjR, reflFac;\n  dstObj = ObjRay (ro, rd);\n  reflFac = 1.;\n  if (dstObj < dstFar) {\n    ror = ro + rd * dstObj;\n    rdr = reflect (rd, ObjNf (ror));\n    ror += 0.01 * rdr;\n    dstObjR = ObjRay (ror, rdr);\n    if (dstObjR < dstFar) {\n      dstObj = dstObjR;\n      ro = ror;\n      rd = rdr;\n      reflFac = 0.7;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col = vec3 (0.3, 0.3, 0.6) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n    col = reflFac * mix (col, BgCol (reflect (rd, vn)), 0.5);\n  } else col = vec3 (0., 0.2, 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n  } else {\n    az -= 0.2 * tCur;\n    el -= 0.2 * pi * cos (0.2 * tCur);\n  }\n  dstFar = 20.;\n  mobRad = 1.8;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.8));\n  ro = vuMat * vec3 (0., 0., -10.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGXR1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[317, 317, 381, 381, 883], [885, 885, 907, 907, 1120], [1122, 1122, 1155, 1155, 1332], [1334, 1334, 1355, 1355, 1583], [1585, 1585, 1607, 1607, 1914], [1916, 1916, 1951, 1951, 2655], [2657, 2657, 2713, 2713, 3526], [3528, 3528, 3560, 3560, 3655], [3657, 3657, 3690, 3690, 3774], [3776, 3776, 3806, 3806, 3864], [3987, 3987, 4011, 4011, 4058], [4060, 4060, 4085, 4085, 4284], [4286, 4286, 4307, 4307, 4446]], "test": "error"}
{"id": "XsGXzw", "name": "Colourful Fan Blades", "author": "innovati", "description": "Beautiful fat colourful fan blades", "tags": ["blades", "fan"], "likes": 0, "viewed": 76, "published": "Public", "date": "1463382079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  fragColor = max(abs(normalize(exp2(tan(atan(vec4((gl_FragCoord.x / iResolution.x), iTime, 0.7, (1.6 - 0.3)), atan(vec4(0.3, (gl_FragCoord.x / iResolution.x), 0.9, 1.5), pow(exp2(vec4(mod((0.4 - (0.4 * 0.1)), iTime), pow((1.9 + (0.2 * 0.1)), 0.2), (gl_FragCoord.x / iResolution.x), ((0.6 + 1.3) * 0.4))), log2(vec4(max(min(1.1, 1.8), (float(iFrame) / (float(iFrame) - 1.7))), pow(iTime, (gl_FragCoord.y / iResolution.y)), 1.7, 0.0))))))))), max(cos(vec4((0.8 / 0.5), (gl_FragCoord.y / iResolution.y), 1.4, (1.4 / iTime))), reflect(vec4((gl_FragCoord.x / iResolution.x), 0.0, 0.2, 1.7), vec4(1.2, ((0.8 / (gl_FragCoord.x / iResolution.x)) + (float(iFrame) - 0.4)), 1.6, (iTime - 1.4)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "XsKSRm", "name": "rings on water from rain", "author": "Emil", "description": "rings on water. useful as a displacement/height map or similair\n\nUse mouse to zoom", "tags": ["2d"], "likes": 32, "viewed": 742, "published": "Public", "date": "1463673169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 randVec(float inVal){\n    \n    return vec2(fract(sin(dot(vec2(inVal*1.1,2352.75053) ,vec2(12.9898,78.233))) * 43758.5453)-0.5,\n                fract(sin(dot(vec2(715.23515, inVal) ,vec2(27.2311,31.651))) * 65161.6513)-0.5);\n                \n}\n\nfloat randFloat(vec2 inVal){\n    return fract(sin(dot(vec2(inVal.x, inVal.y) ,vec2(89.4516,35.516))) * 13554.3651);\n                \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Controls:\n    float zoom = 0.6+0.46*sin(iTime*0.6);\n    zoom = 0.9+pow(((iMouse.x+iMouse.y)/iResolution.x)*1.,3.0);\n    float sharpness = 4.5*zoom; // maybe plug in ddx and ddy here to mimic mip-mapping (avoid artifacts at long distances)\n    //sharpness = 6.5; // uncomment this line to see when it's not \"blurring\" when zoomed out, crispy!\n    float expansionSpeed = 4.0;\n    float rainSpeed = 0.6;\n    float numRings = 3.0;\n    const float numIterations = 4.;\n    float strength = 0.3;\n    \n    // other numbers:\n    const float pi = 3.141592;\n    float newTime = iTime*rainSpeed;\n    \n    vec2 uv;\n    vec2 uvStep;\n    fragColor = vec4(0.);\n    for(float iterations = 0.; iterations < numIterations; iterations++){\n        for(float xpos = -1.;xpos<=1.;xpos++){\n            for(float ypos = -1.;ypos<=1.;ypos++){\n                uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n                uv /= zoom;\n                uv += iterations*vec2(3.21,2.561);\n                uv += vec2(xpos*0.3333,ypos*0.3333);\n                uvStep = (ceil((uv*1.0-vec2(.5,.5)))/1.);\n                uvStep += vec2(xpos,ypos)*100.;\n                uv = vec2(fract(uv.x+0.5)-.5,fract(uv.y+0.5)-.5);\n\n                // Variables:\n                float timeRand = randFloat(uvStep);\n                float timeLoop = fract(newTime+timeRand);\n                float timeIter = floor(newTime+timeRand);\n\n\n                /// Creating ringMap:\n                float ringMap = sharpness*9.*distance(uv, randVec(timeIter+uvStep.x+uvStep.y)*0.5);\n                //float ringMap = sharpness*9.*distance(uv, randVec(0.)*0.);\n                float clampMinimum = -(1.+((numRings-1.)*2.0));\n                ringMap = clamp((ringMap-expansionSpeed*sharpness*(timeLoop))+1., clampMinimum, 1.);\n\n                // Rings and result\n                float rings = (cos((ringMap+newTime)*pi)+1.0)/2.;\n                rings *= pow(1.-timeLoop,2.);\n                float bigRing = sin((ringMap-clampMinimum)/(1.-clampMinimum)*pi);\n                float result = rings * bigRing;\n                fragColor += vec4(result)*strength;\n            }\n        }\n    }\n    \n    // Debuging:\n    /*\n    float uvCorners = (abs(uv.x*2.)>0.45&&abs(uv.x*2.)<0.55)&&(abs(uv.y*2.)>0.45&&abs(uv.y*2.)<0.55)?1.0:0.0;\n    fragColor += 0.5*vec4(uvCorners); // border overlay\n    fragColor += 0.4*vec4(fract(uvStep.x*0.1)+fract(uvStep.y*0.1));\n    //*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 247], [249, 249, 277, 277, 383], [385, 385, 442, 459, 2859]], "test": "valid"}
{"id": "XsKSRw", "name": "Julia - Traps 1 Time Warp", "author": "MichaelPohoreski", "description": "Modified i.q.'s Juliabrot animation for time warp (left = past, middle = zero, right = future)\n\nComplexity Comparison: https://www.shadertoy.com/view/4dKSRw\nExplorer: https://www.shadertoy.com/view/4dVSRw", "tags": ["2d", "fractal", "julia", "orbittrap", "complex", "splitscreen"], "likes": 3, "viewed": 157, "published": "Public", "date": "1463497231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// INSTRUCTIONS: \"Scrub\" from middle to right to fast-forward! (See end note)\n// Split Screen Functionality by Michael Pohoreski/2016 (borrowed from i.q.!)\n// Original version by inigo quilez - iq/2014 https://www.shadertoy.com/view/4d23WG\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// line 34: pixel coordinates\t\n// line 14: c travels around the main cardiod c(t) = e^it - e^i2t\n// line 25: z = z + c\t\t\n// line 26: trap orbit\n// line 45: remap\t\n// line 46: color\t\n// line 47: split screen\n\nvec2 offset( float t )\n{\n    return 0.51*cos( vec2(0.0,1.5708) + 0.1*t )\n         - 0.25*cos( vec2(0.0,1.5708) + 0.2*t );\n}\n\nfloat orbit( vec2 z, vec2 bias )\n{\n\tfloat f = 1e20;\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + bias;\n\t\tf = min( f, dot(z,z) );\n\t}\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float ar = 4./3.; // aspect ratio\n\tvec2 p = ar*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 m = ar*(-iResolution.xy+2.0*iMouse.xy   )/iResolution.y;\n    \n\tfloat f, duration = 1.0; // -100%*time (left), +100%*time (right)\n    float time = 2.0*duration*(iMouse.x / iResolution.x)-duration; // remap [0,1] -> [-d,+d]\n    // Right Half = Static, Time=0\n//    if( p.x > m.x )\n//        f = orbit( p, offset( time ));\n//    else\n        f = orbit( p, offset( iTime * time ) );\n\n    f = 1.0+log(f)/16.0;\n    vec3 color = vec3( f*f*f, f, f*f ); // changed f^3, f^1, f^2 for sick green :-)\n    color *= smoothstep( 0.006, 0.008, abs(p.x-m.x) );\n\n\tfragColor = vec4(color,1.0);\n}\n\n/*\nNotes on time:\nThe mouse left/right controls the time scaling.\n\n\n* \"Scrubbing\" (click+drag) the mouse buttin in the output window from\n   the middle to the right edge will let you \"fast forward\" time.\n* \"Scrubbing\" from the middle to the left edge will let you \"rewind\" time.\n\nDetails:\n\nThe current mouse x position is used as a time warp.\n\nLeft Edge  = -1.0 Negative current time (rewind)\nMiddle     = +0.0 Zero Time\nRigth Edge = +1.0 Positive current time (fast forward)\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKSRw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[548, 548, 572, 572, 671], [673, 673, 707, 707, 852], [854, 854, 911, 911, 1601]], "test": "valid"}
{"id": "XsKXRh", "name": "Cellular Lattice", "author": "Shane", "description": "An underwater cellular lattice structure.", "tags": ["voronoi", "cell", "tile", "gyroid", "lattice"], "likes": 75, "viewed": 3629, "published": "Public API", "date": "1463149717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tCellular Lattice\n\t----------------\n\n\tStill playing around with 3D cellular tiles.\n\n\tTraversing a cellular, coral-like structure through an alien ocean ... Is anyone buying that?\n    I don't know what it is either, but it looks grotesquely interesting. :)\n\n\tIn technical terms, it's an intertwined sinusoidal lattice structure (a mutated gyroid of sorts) \n\twith a prominent cellular surface attached.\n\n    The scene was mildly inspired by IQ's Leizex demo and Tomasz Dobrowolski's Suboceanic.\n\n\n\tCellular Tiled Tunnel 2 - Shane\n\thttps://www.shadertoy.com/view/MdtSRl\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttp://www.iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define FAR 20.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvec3 camPath(in float t){ return vec3(sin(t * 0.45)*.75, cos(t * 0.75)*.75, t); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tvec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n// Akohdr's multitextured suggestion, with some small changes.\n#define t2D texture\nvec3 tpl4( sampler2D a, sampler2D b, \n           sampler2D c, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );\n    \n    float h = dot(cos(p*6.), sin(p.yzx*6.));\n    \n\tvec3 tx  = (t2D(a, p.yz)*n.x + t2D(a, p.zx)*n.y + t2D(a, p.xy)*n.z).xyz; // Pink sandstone.\n\tvec3 tx2 = (t2D(b, p.yz)*n.x + t2D(b, p.zx)*n.y + t2D(b, p.xy)*n.z).xyz; // Sandstone.\n    vec3 tx3 = 1.-(t2D(c, p.yz)*n.x + t2D(c, p.zx)*n.y + t2D(c, p.xy)*n.z).zyx; // Pink coral.\n\n    tx = mix(tx*tx, tx2*tx2, h*.5 + .5);\n    \n    h = dot(sin(p*5.), cos(p.zxy*5.));\n    \n\ttx2 = mix(tx3*tx3, tx2*tx2, h*.5 + .5);\n    \n    return mix(tx, tx2, dot(sin(p*2.), sin(p.zxy*2.))*.5 + .5);\n}\n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    p = cos(p*6.2831853) + 1.;\n    return dot(p, p);\n    \n}\n/*\n// Draw four warped spheres on a wrappable cube, and return the closest distance metric. Try to normalize\n// the result between zero and one.\nfloat cellTile(in vec3 p){\n    \n    vec4 d;\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    d.xy = min(d.xy, d.zw); // Minimum distance determination.\n    \n    return 1.- min(d.x, d.y)*.166; // Normalize... roughly.\n    \n}\n*/\n\n// Fast, three tap version, but I feel four should be the minimum... Even so, this should give \n// a pretty convincing pattern, under the right circumstances.\nfloat cellTile(in vec3 p){\n    \n    vec3 d;\n    \n    // Draw three overlapping objects (spherical, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.2, .82, .64));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.41, .06, .70));\n    \n    return 1.- min(min(d.x, d.y), d.z)*.1666; // Normalize... roughly.\n    \n}\n\n\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty.\nfloat map(in vec3 p){\n    \n    float b = cellTile(p*3.); \n    //float b = cellTile(p + iTime/16.); // Animation.\n\n    // Offsetting the lattice around the camera path.\n    p.xy -= camPath(p.z).xy; \n\n    // Perturbing the surface slightly, prior to construction.\n    p += (sin(p*3.14159 - sin(p.zyx*3.14159)*3.14159*1.25))*.1;\n\n    // The main surface. A weird, molecular looking lattice.\n    float n = abs(dot(cos(p*3.14159), sin(p.yzx*3.14159)));\n\n    // Combining element to form the final structure.\n    return .45 - n*.33  - b*.1;\n    \n}\n\n \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., h;\n    for(int i = 0; i < 128; i++){\n\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.0015*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += (step(1., h)*.25 + .5)*h;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float vor = cellTile(p*27.);\n    \n    return pow(max(vor, 0.), 18.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    // Perturbing the screen coordinates to create the lamest underwater effect ever. :)\n    // Seriously, though, it's quite effective, all things considered.\n    u += sin(u*32. + cos(u.yx*16. + iTime*4.))*.0035;\n\n\t\n\t// Camera Setup.\n    vec3 o = camPath(iTime*.5); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*.5 + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*.5 + 1.5) + vec3(.0, .0, 0.); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2( camPath(lk.z).x/16. )*r.xy;\n \n    // Raymarch.\n    float t = trace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .02/(1. + t/FAR));\n        \n        n = dbF(p*sz, n, .01);\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n);\n        \n        // Texture variance: Akohdr's suggestion.\n        // Requires an additional sandstone texture in iChannel1, and the pink coral texture\n        // in iChannel2.\n        //vec3 tx = tpl4(iChannel0, iChannel1, iChannel2, p*sz, n);\n        \n        float c = dot(tx, vec3(0.299, 0.587, 0.114));\n        \n        tx += vec3(c*c*.8, c, c*c*.5)*fr;\n        \n\n\t\t// Very simple coloring. Fresnel and texture combination.\n        col = tx*(di + .1 + sp)+ tx*fr*2.;\n        col *= 1./(1. + d*.125 + d*d*.025)*ao*sh;\n\n        \n    }\n\n    // Mixing in a simple blue background.\n    vec3 bg = vec3(.5, .7, 1);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-5., t));\n    \n    // Half hearted gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[830, 839, 861, 861, 896], [898, 1050, 1071, 1071, 1137], [1139, 1139, 1164, 1164, 1220], [1222, 1376, 1422, 1422, 1595], [1680, 1680, 1765, 1765, 2361], [2363, 2363, 2391, 2484, 2544], [3297, 3456, 3482, 3482, 3919], [3923, 4072, 4093, 4093, 4613], [4617, 4769, 4806, 4806, 5065], [5068, 5107, 5127, 5127, 5286], [5289, 5310, 5346, 5346, 5797], [5799, 5811, 5887, 5887, 6496], [6499, 6563, 6592, 6592, 6673], [6675, 6725, 6776, 6776, 7158], [7160, 7242, 7297, 7297, 7796], [7801, 7801, 7857, 7891, 10904]], "test": "error"}
{"id": "XsKXzw", "name": "supernova particles", "author": "tomaes", "description": "Walls of particles, blured and layered, zooming out and in.", "tags": ["blur", "zoom", "particles", "pseudo3d"], "likes": 8, "viewed": 583, "published": "Public", "date": "1463513534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    \n    float c = .0, z = .0;\n    float t = iTime;\n    \n    for(float f = 0.; f < 2.; f += .07)\n    {   \n        z += sin( cos(uv.y*4.*f)+t+f*f)*1.3 - 2.;\n        c += (.04+f*f*.001)/distance( uv, vec2( sin(t+f*f+uv.x*z), cos(t-f*f+uv.y*z) ) );   \n    }\n    \n    c -= .5*(1.2-fract(c+1.5+uv.y*2.5));\n    \n    if (uv.x+c*.05 < -.7 || uv.x-c*.05 >.7)\n        c /= 1.6-mod(uv.x,.05)*14.-uv.y*.7;\n    \n\tfragColor = vec4(c-length(uv)*.5,c*.7,c*.53-uv.y*.15, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 579]], "test": "valid"}
{"id": "XsVSRh", "name": "Right Triangular tiling", "author": "soma_arc", "description": "Right Triangular tiling", "tags": ["2d", "tiling"], "likes": 1, "viewed": 111, "published": "Public", "date": "1463036144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float sampleNum = 50.;\nconst float PI = 3.141592653589;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    vec3 sum = vec3(0.);\n    float theta = PI / 4. + PI/6. * sin(iTime);\n    float xc = 10. * 2. * cos(theta);\n    float yc = 10. * 2. * sin(theta);\n    vec2 tileSize = vec2(xc, yc);\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        position *= 100.;\n        \n    \tvec2 p = position - tileSize * floor(position / tileSize) - tileSize / 2.;\n    \tfloat angle = atan(p.y, p.x);\n \n    \tif(mod(floor(angle / (PI/2.0)), 2.0) == 0. ){\n        \tif(mod(angle, PI/2.0) < theta){\n        \t\tsum += vec3(1);\n        \t}\n    \t}else{\n    \t\tif(mod(angle, PI/2.0) < PI / 2.0 - theta){\n        \t\tsum += vec3(1);\n        \t}\n    \t}\n    }\n    \n    fragColor = vec4(sum / sampleNum,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 130, 130, 419], [483, 483, 540, 540, 1372]], "test": "valid"}
{"id": "XsVSRm", "name": "Lightning in Future City", "author": "innovati", "description": "Lightning happens when the skylamps are in need of a reset", "tags": ["lightning", "city", "future"], "likes": 1, "viewed": 170, "published": "Public", "date": "1463524678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = tan(min(mod(acos(vec4((fragCoord.y / iResolution.y), 0.5, ((0.2 + (fragCoord.y / iResolution.y)) + degrees(mod((fragCoord.y / iResolution.y), (0.4 + 1.5)))), 0.9)), sqrt(mod(atan(floor(tan(reflect(atan(vec4(1.3, atan((sqrt(0.5) + min(atan(1.7), 0.0)), (min(1.4, floor(0.7)) - 1.1)), float(iFrame), 1.5)), vec4(atan((fragCoord.x / iResolution.x)), 1.3, 1.1, (min(1.9, (0.2 * max(1.6, step(1.7, 1.2)))) + (cos(1.8) * 0.2))))))), vec4(float(iFrame), 1.7, pow(float(iFrame), 1.2), 0.7)))), inversesqrt(log(mod(cos(vec4(iTime, 0.3, float(iFrame), 0.5)), vec4(0.0, (1.0 - atan(0.4, (fragCoord.y / iResolution.y))), 0.9, ((1.5 - (0.6 * 0.7)) * 1.6)))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 722]], "test": "valid"}
{"id": "XsVSzW", "name": "klk's Simple Plasma", "author": "klk", "description": "plasma", "tags": ["plasma"], "likes": 67, "viewed": 3439, "published": "Public API", "date": "1463246022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime*1.0;\n\tvec2 uv = (fragCoord.xy / iResolution.xx-0.5)*8.0;\n    vec2 uv0=uv;\n\tfloat i0=1.0;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<7;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4+time/i1),sin(uv.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.3;\n\t\tuv.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.15;\n\t\ti2*=1.7;\n\t\ti4+=0.05+0.1*time*i1;\n\t}\n    float r=sin(uv.x-time)*0.5+0.5;\n    float b=sin(uv.y+time)*0.5+0.5;\n    float g=sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.5+0.5;\n\tfragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 580]], "test": "valid"}
{"id": "XsVXRh", "name": "Pac-Man 140 chars", "author": "GregRostami", "description": "I was working on another shader and this idea came to me ... Please help me make it shorter (One-Tweet) - Thank you.", "tags": ["pacman", "short", "onetweet"], "likes": 4, "viewed": 945, "published": "Public API", "date": "1462867627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 u)\n{\n    float t = iTime/.1, l = length(u = u/.1/iResolution.y-5.);\n    o = vec4(l<3. && u.x/l<.9+.1 * sin(t));\n    o.ab = sin(u.x>0. ? l+t: 0.) - u*u;\n}/*\n\n// 149 chars - Just when we thought it's over, LaBodilsen strikes back by removing 2 chars!\n// Is Fabrice down for the count?!\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u=u/.1/iResolution.y-5.;\n    float t = iTime/.1,\n          l = length(u);\n    o = vec4(l<3. && u.x/l<.9+.1 * sin(t));\n    o.ab = sin(u.x>0. ? l+t: 0.) - u*u;\n}\n\n\n// 151 chars - As Fabrice and LaBodilsen battle, Fabrice strikes back with this ...\n// LaBodilsen throws a jab by removing a char from the blue dots.\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float t = iDate.w/.1, \n          l = length(u=u/iResolution.y-.5); u/=.1;\n    o = vec4(l<.3&&u.x/l<9.+sin(t));\n    o.ab = sin(u.x>0. ? u.x+t: 0.) - u*u;\n}\n\n\n// 139 chars - a little cheating, but it still looks good:\n// Using optimizations from Fabrice and LaBodilsen (Thank you)\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float t = iDate.w/.1,\n          l = length(u=u/.1/iResolution.y-4.);\n    o = vec4(l<4.&&u.x/l<.9+.1*sin(t));\n    o.ab = sin(l+t) - u*u;\n}\n\n\n// 156 chars - My Amiga brother LaBodilsen, replaced the square dots with circles.\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float t = iDate.w/.1, \n          l = length(u=u/iResolution.y-.5);\n    o = vec4(l<.3&&u.x/l<.9+.1*sin(t));\n    o.b = sin(u.x>.0 ?l /.1+t:0.)-abs(u.y)/.1;\n}\n\n\n// 161 chars - Fabrice reduced sin(atan(u.x,u.y))= u.x/length(u)\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float t = iDate.w/.1, \n          l = length(u=u/iResolution.y-.5);\n    o = vec4(l<.3&&u.x/l<.9+.1*sin(t));\n    o.b = u.x>0.&&abs(u.y)<.05 ? sin(u.x/.05 + t):0.;\n}\n\n\n// 150 chars - B&W Pac-Man\n// Thanks to LaBodilsen, saved another 2 chars \n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float a = .1,\n        t = iDate.w/a,\n        l = length(u=u/iResolution.y-.4);\n    o = vec4(l < .5&&u.x / l < .9+a*sin(t)||abs(u.y) < a&&sin(u.x/a + t) >.5);\n}\n\n\n// 159 chars, LaBodilsen's version\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float f = .1,\n        t = iDate.w/f,\n        l = length(u = u/iResolution.y-.5);\n    o = vec4(l<.5&&u.x/l<.9+f*sin(t));\n    o.b = u.x>f&&abs(u.y)<f ? sin(u.x/f + t):0.;\n}\n\n\n// I got him eating dots in 173 chars but it's not one-tweet :(\n// Please help me make this shader better/shorter.\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float t = 15.*iDate.w;\n    o = vec4(length(u=u/iResolution.y-.5)<.3&&sin(atan(u.x,u.y))<.9+.1*sin(t));\n    o.b = u.x>.0 && abs(u.y)<.05 ? sin(u.x/.05 + t):0.;\n}\n\n\n// 126 chars - Original shader - no dots\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o-=o;\n    o.rg = vec2(length(u=u/iResolution.y-.5)<.3&&sin(atan(u.x,u.y))<.9+.1*sin(15.*iDate.w));\n}\n*/", "image_inputs": [{"id": "XsjGRc", "previewfilepath": "https://soundcloud.com/j-be-da-infamous/pacman-game-over", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/j-be-da-infamous/pacman-game-over", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 185]], "test": "error"}
{"id": "XsVXRR", "name": "Nearest Point 2", "author": "anastadunbar", "description": "Because the previous one was too horrible but explained the basics.", "tags": ["2d", "voronoi"], "likes": 3, "viewed": 185, "published": "Public", "date": "1462475703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nconst int size = 10;\nvec2 point[size];\nvec3 color[size];\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 position = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord.xy/iResolution.xy)-.5;\n    uv.x /= iResolution.y/iResolution.x;\n    float circle_size = .01;\n    float allcircles=0.; float minimum; vec3 output_colors;\n    for(int i=0;i<size;i++){\n        float fi = float(i);\n    \tpoint[i] = vec2(cos((time*rand(fi+.15))+(rand(fi*2.)*14.)),sin((time*rand(fi+.4))+(rand(fi)*14.)))*.5 ;\n    \tcolor[i] = vec3(rand(fi),rand(fi+.2),rand(fi+.3))*1.5;\n        if(i==0){minimum=length(point[i]-uv);output_colors=color[i];}\n        allcircles+=step(length(uv-point[i]),circle_size);\n        if (length(point[i]-uv)<minimum) {\n            output_colors = color[i];\n            minimum = length(point[i]-uv);\n        }\n    }\n\tfragColor = vec4(clamp(output_colors,0.,1.)-allcircles,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 70], [128, 128, 185, 185, 995]], "test": "valid"}
{"id": "XsVXzW", "name": "Hyperbolic triangular tiling 2", "author": "soma_arc", "description": "Tiling with Hyperbolic triangle. Their interior angles are (PI/2, PI/3, PI/8), (PI/2, PI/4, PI/8), and (PI/2, PI/5, PI/8). We use the Algorithm which called Iterated Inversion System (IIS) developed with Kazushi Ahara (Meiji University).", "tags": ["2d", "tiling"], "likes": 9, "viewed": 635, "published": "Public API", "date": "1463225324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc, Kazushi Ahara - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 tp1 = vec2(0.26607724, 0);\nvec2 tp2 = vec2(0, 0.14062592);\nvec2 cPos = vec2(2.01219217, 3.62584500);\nfloat r = 4.02438434;\nconst float PI = 3.14159265359;\n\nvoid calcCircle(float theta, float phi){\n\tfloat tanTheta = tan(PI/2. - theta);\n    float tanPhi = tan(phi);\n    float tanTheta2 = tanTheta * tanTheta;\n    float tanPhi2 = tanPhi * tanPhi;\n    \n    tp1 = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)) - \n               tanTheta * sqrt((1. + tanPhi2)/(-tanPhi2 + tanTheta2))/tanTheta, 0.);\n    tp2 = vec2(0., -tanPhi * sqrt(-(1. + tanTheta2)/(tanPhi2 - tanTheta2))+\n              tanTheta * sqrt(-(1. + tanPhi2)/(tanPhi2 - tanTheta2)));\n    \n    \n    cPos = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)),\n                 sqrt((1. + tanPhi2)*tanTheta2/(-tanPhi2 + tanTheta2))\n               );\n    r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 50;\nfloat loopNum = 0.;\nint IIS(vec2 pos){\n    if(length(pos) > 1.) return 0;\n\n    int invCount = 1;\n    bool fund = true;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tfund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) < r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            fund = false;\n        }\n        if(fund)\n        \treturn invCount;\n    }\n\n\treturn invCount;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    vec3 sum = vec3(0);\n    calcCircle(PI/(4. + sin(iTime)), PI/8.);\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\n        position = position * 2.;\n        //position *= 0.03 + abs(1. * sin(iTime) * sin(iTime));\n        position *= 1.0;\n        //position += vec2(cos(iTime), 0.3 * sin(iTime));\n\n        int d = IIS(position);\n\n        if(d == 0){\n            sum += vec3(0.,0.,0.);\n        }else{\n            if(mod(float(d), 2.) == 0.){\n                sum += hsv2rgb(vec3(0.3, 1., 1.));\n            }else{\n                sum += hsv2rgb(vec3(0.7, 1., 1.));\n            }\n        }\n    }\n    fragColor = vec4(sum/sampleNum, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVXzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[145, 234, 275, 275, 564], [727, 727, 767, 767, 1450], [1452, 1452, 1512, 1512, 1628], [1677, 1677, 1695, 1695, 2272], [2274, 2274, 2296, 2296, 2465], [2496, 2496, 2552, 2552, 3347]], "test": "valid"}
{"id": "XsySDR", "name": "Why my mouse aim is jumping?", "author": "foxes", "description": "many do not understand why the pointer jumps when viewed from another angle, now you can see why. just change the mouse vertical viewing angle. (thanks IQ for examples https://www.shadertoy.com/view/Xds3zN)", "tags": ["procedural", "3d", "raymarching", "example", "distancefields", "primitives"], "likes": 6, "viewed": 782, "published": "Public API", "date": "1463675834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nvec3 castrz;\nfloat scale;\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-castrz, scale*0.1 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    //res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\t//res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\t//res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\t//res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\t//res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\t//res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\t//res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\t//res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(0.0,0.20, 0.0), vec2(0.25,0.05) ),17.0 ) );\n\n    //res = opU( res, vec2( opS(\n\t//\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t//                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\t//res = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t//\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n    //                                   65.0 ) );\n\t//res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    //res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n    //res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n    if (iMouse.z <1. ) mo.xy=vec2(0.5,0.66666);\n    \n\t// camera\n\tvec3 ro = vec3( -3.5, 2.-1.2*mo.y, 1.5-mo.x*3.  );\n\tvec3 ta = vec3( -0.5, -0.4, 0. );\n\t\n    \n    vec3 castp = vec3(-3.5,1.2,0.);\n    vec3 castn = normalize(vec3(4.3-cos(time*1.4)*3.1,-1.,0.));\n    vec2 castl = castRay( castp, castn);\n\n    castrz=castp+castn * castl.x;\n    scale=length(ro-castrz);\n    castrz=castp+castn * (castl.x-scale*0.1);\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsySDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[405, 405, 430, 430, 445], [447, 447, 482, 482, 508], [510, 510, 541, 541, 628], [630, 630, 673, 673, 733], [735, 735, 780, 780, 820], [822, 822, 855, 855, 908], [910, 910, 946, 946, 1188], [1190, 1190, 1242, 1242, 1356], [1358, 1358, 1394, 1394, 1642], [1644, 1644, 1680, 1680, 1779], [1781, 1781, 1819, 1819, 1988], [1990, 1990, 2062, 2062, 2277], [2280, 2280, 2305, 2305, 2342], [2344, 2344, 2369, 2369, 2427], [2429, 2429, 2454, 2454, 2519], [2521, 2521, 2556, 2556, 2623], [2625, 2625, 2660, 2660, 2727], [2729, 2729, 2766, 2766, 2817], [2893, 2893, 2926, 2926, 2952], [2954, 2954, 2984, 2984, 3017], [3019, 3019, 3049, 3049, 3078], [3080, 3080, 3104, 3104, 3236], [3312, 3312, 3337, 3337, 5515], [5517, 5517, 5557, 5557, 6147], [6150, 6150, 6224, 6224, 6485], [6487, 6487, 6519, 6519, 6740], [6742, 6742, 6784, 6784, 7083], [7088, 7088, 7127, 7127, 8698], [8700, 8700, 8752, 8752, 8929], [8931, 8931, 8988, 8988, 9839]], "test": "valid"}
{"id": "XsySRD", "name": "AA Triangle Drawing", "author": "gPlatl", "description": "Draw framed antialiased triangles and check triangle hit.\nPress mouse button and check if mouse hits rotating triangle.\nPress small triangle arrows to toggle some action. ", "tags": ["2d", "triangle", "distance", "drawing", "input", "hit", "inside", "mousepressed"], "likes": 3, "viewed": 543, "published": "Public", "date": "1463479520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// AATriangleDrawing.glsl    by gPlatl   \n//   v1.0 2016-05-15  initial release\n//   v1.1 2016-08-21  improved\n//   v1.2 2018-02-26  drawArrows added\n// License Creative Commons Attribution - NonCommercial - ShareAlike 3.0 Unported License.\n// Tags:  2d, triangle, distance, drawing, input, hit, inside, mousePressed\n//---------------------------------------------------------\n\n//---------------------------------------------------------\n// return signed distance to a 2D triangle \n//   inside if distance <= 0.0\n// created by inigo quilez - iq/2014\n//   see https://www.shadertoy.com/view/XsXSz4\n//---------------------------------------------------------\nfloat sdTriangle(in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p)\n{\n  vec2 e0 = p2 - p1;  vec2 e1 = p3 - p2;  vec2 e2 = p1 - p3;\n  vec2 v0 = p - p1;   vec2 v1 = p - p2;   vec2 v2 = p - p3;\n\n  vec2 pq0 = v0 - e0*clamp(dot(v0,e0) / dot(e0,e0), 0.0, 1.0);\n  vec2 pq1 = v1 - e1*clamp(dot(v1,e1) / dot(e1,e1), 0.0, 1.0);\n  vec2 pq2 = v2 - e2*clamp(dot(v2,e2) / dot(e2,e2), 0.0, 1.0);\n    \n  vec2 d = min( min(vec2( dot(pq0, pq0), v0.x*e0.y-v0.y*e0.x),\n                    vec2( dot(pq1, pq1), v1.x*e1.y-v1.y*e1.x)),\n                    vec2( dot(pq2, pq2), v2.x*e2.y-v2.y*e2.x));\n\n  return -sqrt(d.x)*sign(d.y);\n}\n//---------------------------------------------------------\n// draw 2D triangle (return drawing color)\n//---------------------------------------------------------\nvec4 triangle(in vec2 p1, in vec2 p2, in vec2 p3, in vec2 pos\n             ,in vec4 col, in vec4 fillColor, in vec4 frameColor\n             ,in float frameSize)\n{\n  float d = sdTriangle(p1, p2, p3, pos);\n  if (d > frameSize)   // outside ?\n    return col;\n  float s = 1.0 - smoothstep(0.0,frameSize,abs(d));\n  if (d <= 0.0)\n    return mix( fillColor, frameColor, s*col.w); // inside\n  else \n    return mix( col, frameColor, s);   // outside\n}\n//---------------------------------------------------------\n\nvec2 uv, mp;\n\n//---------------------------------------------------------\n// return circle intensity at pos with given radius\n//---------------------------------------------------------\nfloat circle(in vec2 pos, in float radius, in float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw triangle and return true on mousePressed\n//---------------------------------------------------------\nbool arrow(in vec2 p1, in vec2 p2, in vec2 p3, inout vec4 col)\n{\n  vec4 fill =  vec4(0.5, 0.3, 0.6, 1.0);\n  vec4 frame = vec4(0.8, 0.8, 0.4, 1.0);\n  bool inside = sdTriangle(p1,p2,p3, mp) < 0.0;\n  if (inside)\n  {  \n     frame = vec4(1.0);  // last input\n     if (iMouse.z > 0.0)    // mousePressed ?\n       fill = vec4(0.2, 0.1, 0.4, 1.0);\n  }\n  col = triangle (p1,p2,p3, uv, col, fill, frame, 0.02);\n  return inside;\n}\n//---------------------------------------------------------\n// draw arrows and return command > 0 if arrow is pressed \n//---------------------------------------------------------\nint drawArrows(inout vec4 col)\n{\n  // draw triangle arrows and check input\n  float s= 0.1, s2 = 0.05;\n  float x= iResolution.x / iResolution.y * 0.91;  // arrow x middle position  \n  float y= -0.75;\n  bool inside1 = arrow(vec2(x,y-2.*s),vec2(x-s,y-s2), vec2(x+s,y-s2), col);\n  bool inside2 = arrow(vec2(x-s,y+s2),vec2(x,y+2.*s), vec2(x+s,y+s2), col);\n\n  int command = 0;  \n  if (inside1) command = 1;\n  if (inside2) command = 2;\n  return command;\n}\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\tmp = (2.0*iMouse.xy-iResolution.xy) / iResolution.y;\n\n    vec4 col = vec4(uv.x, uv.y, 0.5, 1.0);  // background\n    int command = drawArrows(col);\n    \n    // input handling\n    vec4 fill =  vec4(0.3, 0.6, 0.6, 0.5);\n    vec4 frame = vec4(0.9, 0.8, 0.2, 1.0);\n    float time = iTime;\n    if (iMouse.z > 0.0)    // mousePressed ?\n    {\n      if (command == 1) fill = vec4(0.8, 0.2, 0.2, 0.5);  // red\n      if (command == 2) time = -time;  // change rotation direction\n    }\n\n    // rotating triangle\n    vec2 p1 = 0.9*cos(time + vec2(0.0,1.57) + 0.0);\n\tvec2 p2 = 0.9*cos(time + vec2(0.0,1.57) + 2.0);\n\tvec2 p3 = 0.9*cos(time + vec2(0.0,1.57) + 4.0);\n    const vec4 circleColor = vec4(0.6, 0.4, 0.4, 0.2);\n\t// change triangle color if last mouse position is inside triangle\n    if (sdTriangle(p1,p2,p3, mp) < 0.0)\n      fill = circleColor;\n    float frameSize = 0.03 + 0.02*cos( iTime);\n\tcol = triangle(p1,p2,p3, uv, col, fill, frame, frameSize);\n    \n    // draw mouse point\n    if (command == 0)\n    {\n      float intensity = circle(mp, 0.05, 100.0);\n      col = mix(col, 1.6*circleColor, intensity);\n    }\n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsySRD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[439, 718, 783, 783, 1324], [1325, 1488, 1650, 1650, 1930], [2006, 2178, 2237, 2237, 2300], [2301, 2470, 2534, 2534, 2889], [2890, 3069, 3101, 3143, 3517], [3518, 3578, 3635, 3635, 4826]], "test": "valid"}
{"id": "XsySRm", "name": "Perlin noise fun", "author": "metric", "description": " ", "tags": ["noise", "perlin", "fun"], "likes": 2, "viewed": 123, "published": "Public", "date": "1463402446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\nvec2 _smooth(vec2 x) { return vec2(fade(x.x), fade(x.y)); }\n\nvec2 hash(vec2 co) {\n    float m = dot(co, vec2(12.9898, 78.233));\n    return fract(vec2(sin(m),cos(m))* 43758.5453*(iTime+50.)*.000003) * 2. - 1.;\n}\n\nfloat perlinNoise(vec2 uv) {\n    vec2 PT  = floor(uv);\n    vec2 pt  = fract(uv);\n    vec2 mmpt= _smooth(pt);\n    \n    vec4 grads = vec4(\n    \tdot(hash(PT + vec2(.0, 1.)), pt-vec2(.0, 1.)),   dot(hash(PT + vec2(1., 1.)), pt-vec2(1., 1.)),\n        dot(hash(PT + vec2(.0, .0)), pt-vec2(.0, .0)),   dot(hash(PT + vec2(1., .0)), pt-vec2(1., 0.))\n    );\n\n    return 1.*mix (mix (grads.z, grads.w, mmpt.x), mix (grads.x, grads.y, mmpt.x), mmpt.y);\n}\n\n\nfloat fbm(vec2 uv) {\n    float finalNoise = 0.;\n\tfinalNoise += .50000*perlinNoise(2.*uv);\n    finalNoise += .25000*perlinNoise(4.*uv);\n    finalNoise += .12500*perlinNoise(8.*uv);\n    finalNoise += .06250*perlinNoise(16.*uv);\n    finalNoise += .03125*perlinNoise(32.*uv);\n    \n    return finalNoise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\n    float noiseSample = fbm(2.*uv)+.5;\n    float x = fbm(2.*uv*(.5-noiseSample))+.5;\n    \n    if (x > -1.)\n        fragColor = vec4(0.4, .1, .4, 1.);\n    \n    if (x > .3)\n        fragColor = vec4(0.1, .7, .3, 1.);\n    \n    if (x > .4)\n        fragColor = vec4(0.9, .9, .3, 1.);\n    \n    if (x > clamp(abs(sin(.5*iTime)), .45, 1.) )\n        fragColor = vec4(0.8, .1, .3, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsySRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [71, 71, 93, 93, 130], [132, 132, 152, 152, 281], [283, 283, 311, 311, 725], [728, 728, 748, 748, 1029], [1032, 1032, 1089, 1089, 1509]], "test": "valid"}
{"id": "XsySzW", "name": "All 64 I Ching", "author": "vamoss", "description": "All 64 I Ching animated", "tags": ["ching", "iching"], "likes": 3, "viewed": 257, "published": "Public", "date": "1463026734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original work\n//https://www.shadertoy.com/view/ldVXzh\n\n//128 possibilities\n/*\nvec2 grid = vec2(16.0, 8.0);\nconst float slices = 7.;\n/**/\n\n//64 possibilities\n//*\nvec2 grid = vec2(16.0, 4.0);\nconst float slices = 6.;\n/**/\n\n//32 possibilities\n/*\nvec2 grid = vec2(8.0, 4.0);\nconst float slices = 5.;\n/**/\n\n//16 possibilities\n/*\nvec2 grid = vec2(8.0, 2.0);\nconst float slices = 4.;\n/**/\n\n//8 possibilities\n/*\nvec2 grid = vec2(4.0, 2.0);\nconst float slices = 4.;\n/**/\n\n//4 possibilities\n/*\nvec2 grid = vec2(2.0, 2.0);\nconst float slices = 2.;\n/**/\n\n//2 possibilities\n/*\nvec2 grid = vec2(2.0, 1.0);\nconst float slices = 1.;\n/**/\n\n#define pi 3.1415926\n#define two_pi 6.283185\n#define half_pi 1.570796\n\nfloat rectangle(vec2 uv, vec2 pos, float width, float height) {\n\treturn step(pos.x, uv.x) * step(uv.x, pos.x + width) * step(pos.y, uv.y) * step(uv.y, pos.y + height);\n}\n\nfloat iChing( vec2 uv , float time)\n{\n\tconst float vel = 0.3;\n\n    float index = slices - floor(slices * uv.y);\n    uv.y *= slices;\n    \n\t//mirror\n    if(step(uv.x, 0.5)==0.) uv.x = 1.-uv.x; \n    uv.x = fract(uv.x*2.);\n\t\n    //binary progression\n    float freq = pow(2., index-1.) * (iTime * -vel + time);\n    //*\n    float osc = freq;\n    for(float i=0.;i<slices;i++){\n        if(slices-i<index-1.) break;\n        osc = sin(sin(osc)*half_pi)*half_pi;//square curve\n    }\n    osc = sin(osc);\n\t/**/\n    //simplier version\n    //float osc = sin(sin(sin(sin(sin(freq)*half_pi)*half_pi)*half_pi)*half_pi);//square curve\n    osc = (osc+1.)/2.;\n    \n    vec2 pos = vec2(0.1, 0.15);\n    float width = 0.9+0.1*osc;\n    float height = 0.7;\n    \n    return rectangle(fract(uv), pos, width-pos.x, height);\n}\n\n//  Function from Iigo Quiles \n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 index = floor(grid * uv);\n    float index1D = index.x + index.y*grid.x;\n    uv *= grid;\n    \n    vec3 color = hsb2rgb(vec3(index1D*iTime*0.01,0.7,1.0));\n    \n    float iching = iChing(fract(uv), index1D/(grid.x*grid.y)*two_pi);\n    \n    fragColor = vec4(color*iching, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsySzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 759, 759, 865], [867, 867, 904, 904, 1663], [1665, 1742, 1768, 1768, 2003], [2005, 2005, 2062, 2062, 2392]], "test": "valid"}
{"id": "XsyXDh", "name": "Kaliset Variations", "author": "wjbgrafx", "description": "Variations on the Kaliset Fractal, based on 'Simplicity', uploaded by JoshP on 2013-May-7 : https://www.shadertoy.com/view/lslGWr", "tags": ["2d", "fractal"], "likes": 4, "viewed": 853, "published": "Public API", "date": "1463965996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* 'Kaliset Variations' by wjbgrafx \n   \n    Minor modifications to code from 'Simplicity', uploaded by JoshP on 2013-May-7 \n    https://www.shadertoy.com/view/lslGWr\n*/\n//================================================================================\n\nfloat field( vec3 p ) \n{\n\t// Pattern fades out at around 310 seconds. Rather than figure out why, just\n    // reverse the time between 310 and 620 seconds ( You're *still* watching this!? )\n    float time = mod( iTime, 620.0 );\n    time = time > 310.0 ? 620.0 - time : time;\n\t    \n    //float strength = 7.0 + 0.03 * log( 1.e-6 + fract( sin( time ) * 4373.11 ) ),\n\t// Smaller value of 'strength' = brighter image\n\tfloat strength = 4.0 - sin( time * 0.0005 ),\n\t      //power = 2.3,\n\t      power = 2.3 + sin( time * 0.003 ),\n\t      accum = 0.0,\n\t      prev = 0.0,\n\t      tw = 0.0;\n\t      \n\tfor ( int i = 0; i < 32; i++ ) \n\t{\t\t\n\t\tfloat mag = dot( p, p ),\n\t\t      w = exp( -float( i ) / 7.0 );\n\t\t\n\t\tp = abs( p ) / mag + vec3( -0.5, -0.4, -1.5 );\n\t\t//accum += w * exp( -strength * pow( abs( mag - prev ), 2.3 ) );\n\t\taccum += w * exp( -strength * pow( abs( mag - prev ), power ) );\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\t\n\treturn max( 0.0, 5.0 * accum / tw - 0.7 );\n}\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = mod( iTime, 620.0 );\n    time = time > 310.0 ? 620.0 - time : time;\n\n\n    // 'uv' is a -1 to 1 range coord in both x and y ( without aspect ratio ).\n\t// 'uvs' is a -1 to 1 range coord in x, and a y-range of -y/x to +y/x =\n\t// smaller values since yres is smaller.\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tvec2 uvs = uv * iResolution.xy / max( iResolution.x, iResolution.y );\t\n\t\n\t//----------------------------------------------------------\n\t// Original - off-center image\n\t//vec3 p = vec3( uvs / 4.0, 0.0 ) + vec3( 1.0, -1.3, 0.0 );\n\t\n\t// Movement via altering the z position of off-center image\n\t//vec3 p = vec3( uvs / 4.0, 0.0 ) + vec3( 1.0, -1.3, time * 0.01 );\n\t\n\t// Altering z position of centered image\n\t//vec3 p = vec3( uvs / 4.0, time * 0.01 );// + vec3( 1.0, -1.3, time * 0.01 );\n\t\n\t// Using time to zoom in on the off-center image\n\t//vec3 p = vec3( uvs / (4.0 + time * 0.1 ), 0.0 ) + vec3( 1.0, -1.3, 0.0 );\n\n\t// Using time to zoom out of the centered image\n\t//vec3 p = vec3( uvs / (4.0 - time * 0.1 ), 0.0 );// + vec3( 1.0, -1.3, 0.0 );\n\t\n\t// Altering z position of centered image while slowly zooming in\n\t//vec3 p = vec3( uvs / exp( time * 0.005 ), time * 0.01 );\n\t\n\t// Very slow zoom-in\n\t//vec3 p = vec3( uvs / exp( time * 0.005 ), log( time * 0.01 ) );\n\t\n\t//--------------------------------------------------------------\n\t\n\t// Altering z position of centered image while slowly zooming out\n\tvec3 p = vec3( uvs / log( time * 0.001 ), exp( time * 0.005 ) );\n\t\n\t//----------------------------------------------------------\n\t\n\t// Moves the image around the screen in original code\n\t//----------------------------------\n//\tfloat transRate = 0.2;\t\n//\tp += transRate * \n//\t       vec3( sin( time / 16.0 ), sin( time / 12.0 ), sin( time / 128.0 ) );\n\t//----------------------------------\n\t\n\t// 'v' ranges from 0 at the edges of the screen, and rapidly approaches\n\t// 1.0 ( without equalling it ) towards the center of the screen; i.e.,\n\t// 1/10th of the way from edge to center, 'v' already equals about 0.45;\n\t// 1/4 of the way, 'v' equals about 0.75; 1/2 of the way, 'v' equals about\n\t// 0.9475; 3/4 of the way, 'v' equals about 0.986. This applies when the\n\t// multiplier = 6.0. A smaller multiplier makes the range smoother, larger\n\t// makes the range increase very rapidly moving away from the edges, but \n\t// still approaching but not reaching 1.0.\n\tfloat t = field( p ),\n\t      v = ( 1.0 - exp( ( abs( uv.x ) - 1.0 ) * 6.0 ) ) * \n\t          ( 1.0 - exp( ( abs( uv.y ) - 1.0 ) * 6.0 ) );\n\t          \n//------------------------------------------------------------------\n// Original\n// -------- Mixing based on 'v' makes multiplier of final color 0.4 at the \n// edges, rapidly increasing towards 1.0 at the center ( see value of 'v', above).\n\t\n//\tfragColor = mix( 0.4, 1.0, v ) * vec4( 1.8 * t * t * t, \n//\t                                          1.4 * t * t, t, 1.0 );\n//------------------------------------------------------------------\n// Modified original\n// -----------------\n\n\tfloat rTime = time * 0.05,\n\t\t  gTime = time * 0.03,\n\t      bTime = time * 0.01,\n\t      red = mod( ( 1.1 + sin( rTime) ) * t * t * t + rTime, 2.0 ),\n\t      grn = mod( ( 1.1 + sin( gTime ) ) * t * t + gTime, 2.0 ),\n\t      blu = mod( t + bTime, 2.0 );\n\t      \n\tred = red > 1.0 ? 2.0 - red : red;\n\tgrn = grn > 1.0 ? 2.0 - grn : grn;\n\tblu = blu > 1.0 ? 2.0 - blu : blu;\t      \n\t\n\tfragColor = mix( 0.05, 1.1 + sin( bTime ), v ) * vec4( red, grn, blu, 1.0 );\n\t\t\n//------------------------------------------------------------------\n\t\n// Simple greyscale\n//\tfragColor = vec4( t, t, t, 1.0 );\n\n//------------------------------------------------------------------\n\n// Abhuese\n/*\n\tfloat red = mod( t * t + v * v, 2.0 ),\n\t      grn = t * v,\n\t      blu =  dot( t, v );\n\t      \n\tred = ( red > 1.0 ) ? 2.0 - red : red;\n\t\n\tred = mod( red + grn, 1.0 );\n\tgrn = mod( grn + blu, 1.0 );\t      \n\tblu = mod( blu + red, 1.0 );\n\n\tfragColor = vec4( red,grn,blu, 1.0 );\n*/\n//------------------------------------------------------------------\n\n// ( and now for ) Something completely different\n/*\n\tfloat red = t,\n\t      grn = v,\n\t      blu = t + v;\n\t      \t      \n\tfragColor = vec4( red,grn,blu, 1.0 );\n*/\n\n//------------------------------------------------------------------\n\n// Something else entirely\n/*\t\n\tfloat red = mod( 2.0 * t * t * t, 2.0 ),\n\t      grn = mod( red * t * t, 2.0 ),\n\t      blu = mod( grn * t, 2.0 );\n\t      \n\t      \n\tred = red > 1.0 ? 2.0 - red : red;\n\tgrn = grn > 1.0 ? 2.0 - grn : grn;\n\tblu = blu > 1.0 ? 2.0 - blu : blu;\n\t\t                                               \n\tfragColor = vec4( red,grn,blu, 1.0 );\n*/\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 278, 443, 1205], [1206, 1287, 1344, 1344, 5978]], "test": "valid"}
{"id": "XsyXRW", "name": "Moire in Color", "author": "innovati", "description": "visual effect", "tags": ["color", "moire"], "likes": 2, "viewed": 88, "published": "Public", "date": "1463010888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = cos(reflect(max(vec4((0.6 + ((gl_FragCoord.x / iResolution.x) * ((0.2 - 1.7) + 0.0))), (gl_FragCoord.y / iResolution.y), float(iFrame), float(iFrame)), vec4(1.8, 1.1, 0.7, float(iFrame))), vec4(1.4, 1.2, 0.8, (gl_FragCoord.x / iResolution.x))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 316]], "test": "valid"}
{"id": "XsyXzw", "name": "Dancing Dots", "author": "s23b", "description": "music: [url=https://www.youtube.com/watch?v=zl4BIxg5GTg]bhkata - mental astronaut (danaga remix)[/url]\n\nfirst silly attempt at raymarching", "tags": ["raymarching", "helloworld"], "likes": 34, "viewed": 2240, "published": "Public API", "date": "1463500637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 hsv2rgb (in vec3 hsv) {\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\n}\n\nfloat hash(vec3 uv) {\n    return fract(sin(dot(uv, vec3(7.13, 157.09, 113.57))) * 48543.5453);\n}\n\n// better distance function thanks to Shane\nfloat map(vec3 p) {\n    float radius = texture(iChannel0, vec2(hash(floor(p)), .25)).x * .99 + .01;\n    return length(fract(p) - .5) - .25 * radius;\n}\n\n// raymarching function\nfloat trace(vec3 o, vec3 r) {\n\n    float t = 0.;\n    \n    for (int i = 0; i < 32; ++i) { // Low iterations for blur.\n        float d = map(o + r * t);\n        t += d * .9; // Ray shortening to blur a bit more. \n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // ray\n    vec3 r = normalize(vec3(uv, 2.));\n    // origin\n    vec3 o = vec3(-3, iTime, -1);\n     \n    // rotate origin and ray\n    float a = -iTime * .5;\n    mat2 rot = mat2(cos(a), -sin(a), sin(a), cos(a));\n    o.xz *= rot;\n    r.xy *= rot;\n    r.xz *= rot;\n    \n    // march\n    float f = trace(o, r);\n    \n    // calculate color from angle on xz plane\n    vec3 p = o + f * r;\n    float angel = atan(p.x, p.z) / PI / 2.;\n    vec3 c = hsv2rgb(vec3(angel, 1., 1.));\n    \n    // add with fog\n\tfragColor = vec4(c / (1. + f * f * .1),1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 160], [162, 162, 183, 183, 258], [260, 304, 323, 323, 454], [456, 480, 509, 509, 717], [719, 719, 776, 776, 1420]], "test": "error"}
